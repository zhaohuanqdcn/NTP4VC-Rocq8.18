theory powm_Powm_getbitsqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.c_C" "mach.int_Unsigned" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/sub_1_Sub_1"
begin
definition redc :: "int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "redc ur u n m \<longleftrightarrow> ur emod m = ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i n * u emod m" for ur u n m
definition valueb :: "64 word ptr \<Rightarrow> int \<Rightarrow> int"
  where "valueb p nbits = (if nbits < (0 :: int) then 0 :: int else let i :: int = nbits ediv (64 :: int) in value p i + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i i * (uint (pelts p (offset p + i)) emod (2 :: int) ^\<^sub>i (nbits - (64 :: int) * i)))" for p nbits
theorem getbits'vc:
  fixes nbits :: "32 word"
  fixes bi :: "32 word"
  fixes pn :: "32 word"
  fixes p :: "64 word ptr"
  assumes fact0: "(1 :: int) \<le> sint nbits"
  assumes fact1: "sint nbits < (64 :: int)"
  assumes fact2: "(0 :: int) \<le> sint bi"
  assumes fact3: "(1 :: int) \<le> sint pn"
  assumes fact4: "valid p (sint pn)"
  assumes fact5: "(sint bi + (63 :: int)) ediv (64 :: int) \<le> sint pn"
  shows "if sint bi < sint nbits then (0 :: int) \<le> sint bi \<and> (\<forall>(o1 :: 64 word). uint o1 = sint bi \<longrightarrow> (((0 :: int) \<le> uint o1 \<and> uint o1 < (64 :: int)) \<and> (2 :: int) ^\<^sub>i uint o1 * uint (1 :: 64 word) \<le> (18446744073709551615 :: int)) \<and> (\<forall>(o2 :: 64 word). uint o2 = (2 :: int) ^\<^sub>i uint o1 * uint (1 :: 64 word) \<longrightarrow> (c_C.min p \<le> offset p \<and> offset p < c_C.max p) \<and> (let o3 :: 64 word = pelts p (offset p) in (\<not>uint o2 = (0 :: int) \<and> uint'64_in_bounds (uint o3 cmod uint o2)) \<and> (\<forall>(result :: 64 word). uint result = uint o3 cmod uint o2 \<longrightarrow> (sint nbits \<le> sint bi \<longrightarrow> valueb p (sint bi) = valueb p (sint bi - sint nbits) + (2 :: int) ^\<^sub>i (sint bi - sint nbits) * uint result) \<and> (sint bi < sint nbits \<longrightarrow> valueb p (sint bi) = uint result) \<and> ((0 :: int) \<le> uint result \<and> uint result < (2 :: int) ^\<^sub>i sint nbits) \<and> uint result = value p (sint pn) ediv (2 :: int) ^\<^sub>i (sint bi - sint nbits) emod (2 :: int) ^\<^sub>i sint nbits)))) else int'32_in_bounds (sint bi - sint nbits) \<and> (\<forall>(o1 :: 32 word). sint o1 = sint bi - sint nbits \<longrightarrow> (\<not>(64 :: int) = (0 :: int) \<and> int'32_in_bounds (sint o1 cdiv (64 :: int))) \<and> (\<forall>(o2 :: 32 word). sint o2 = sint o1 cdiv (64 :: int) \<longrightarrow> (\<not>(64 :: int) = (0 :: int) \<and> int'32_in_bounds (sint o1 cmod (64 :: int))) \<and> (\<forall>(o3 :: 32 word). sint o3 = sint o1 cmod (64 :: int) \<longrightarrow> (c_C.min p \<le> offset p + sint o2 \<and> offset p + sint o2 < c_C.max p) \<and> int'32_in_bounds (sint o2 + (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint o2 + (1 :: int) \<longrightarrow> (c_C.min p \<le> offset p + sint o4 \<and> offset p + sint o4 \<le> c_C.max p) \<and> (\<forall>(p' :: 64 word ptr). offset p' = offset p + sint o4 \<and> plength p' = plength p \<and> pelts p' = pelts p \<and> data p' = data p \<and> c_C.min p' = c_C.min p \<and> c_C.max p' = c_C.max p \<and> zone1 p' = zone1 p \<and> writable p' = writable p \<longrightarrow> (0 :: int) \<le> sint o3 \<and> (\<forall>(o5 :: 64 word). uint o5 = sint o3 \<longrightarrow> ((0 :: int) \<le> uint o5 \<and> uint o5 < (64 :: int)) \<and> (\<forall>(o6 :: 64 word). uint o6 = uint (pelts p (offset p + sint o2)) ediv (2 :: int) ^\<^sub>i uint o5 \<longrightarrow> \<not>(2 :: int) ^\<^sub>i sint o3 = (0 :: int) \<and> int'32_in_bounds ((64 :: int) - sint o3) \<and> (\<forall>(nbits_in_r :: 32 word). sint nbits_in_r = (64 :: int) - sint o3 \<longrightarrow> (if sint nbits_in_r < sint nbits then int'32_in_bounds (sint o2 + (1 :: int)) \<and> (\<forall>(o7 :: 32 word). sint o7 = sint o2 + (1 :: int) \<longrightarrow> (c_C.min p \<le> offset p + sint o7 \<and> offset p + sint o7 < c_C.max p) \<and> (0 :: int) \<le> sint nbits_in_r \<and> (\<forall>(o8 :: 64 word). uint o8 = sint nbits_in_r \<longrightarrow> ((0 :: int) \<le> uint o8 \<and> uint o8 < (64 :: int)) \<and> (\<forall>(prs :: 64 word). uint prs = uint (pelts p (offset p + sint o7)) * (2 :: int) ^\<^sub>i uint o8 emod ((18446744073709551615 :: int) + (1 :: int)) \<and> uint prs \<le> (18446744073709551615 :: int) + (1 :: int) - (2 :: int) ^\<^sub>i uint o8 \<longrightarrow> int'32_in_bounds (sint o2 + (2 :: int)) \<and> (\<forall>(o9 :: 32 word). sint o9 = sint o2 + (2 :: int) \<longrightarrow> (c_C.min p \<le> offset p + sint o9 \<and> offset p + sint o9 \<le> c_C.max p) \<and> (\<forall>(p'' :: 64 word ptr). offset p'' = offset p + sint o9 \<and> plength p'' = plength p \<and> pelts p'' = pelts p \<and> data p'' = data p \<and> c_C.min p'' = c_C.min p \<and> c_C.max p'' = c_C.max p \<and> zone1 p'' = zone1 p \<and> writable p'' = writable p \<longrightarrow> \<not>(18446744073709551615 :: int) + (1 :: int) = (0 :: int) \<and> uint'64_in_bounds (uint o6 + uint prs) \<and> (\<forall>(o10 :: 64 word). uint o10 = uint o6 + uint prs \<longrightarrow> (0 :: int) \<le> sint nbits \<and> (\<forall>(o11 :: 64 word). uint o11 = sint nbits \<longrightarrow> (((0 :: int) \<le> uint o11 \<and> uint o11 < (64 :: int)) \<and> (2 :: int) ^\<^sub>i uint o11 * uint (1 :: 64 word) \<le> (18446744073709551615 :: int)) \<and> (\<forall>(o12 :: 64 word). uint o12 = (2 :: int) ^\<^sub>i uint o11 * uint (1 :: 64 word) \<longrightarrow> (\<not>uint o12 = (0 :: int) \<and> uint'64_in_bounds (uint o10 cmod uint o12)) \<and> (\<forall>(result :: 64 word). uint result = uint o10 cmod uint o12 \<longrightarrow> (sint nbits \<le> sint bi \<longrightarrow> valueb p (sint bi) = valueb p (sint bi - sint nbits) + (2 :: int) ^\<^sub>i (sint bi - sint nbits) * uint result) \<and> (sint bi < sint nbits \<longrightarrow> valueb p (sint bi) = uint result) \<and> ((0 :: int) \<le> uint result \<and> uint result < (2 :: int) ^\<^sub>i sint nbits) \<and> uint result = value p (sint pn) ediv (2 :: int) ^\<^sub>i (sint bi - sint nbits) emod (2 :: int) ^\<^sub>i sint nbits))))))))) else (0 :: int) \<le> sint nbits \<and> (\<forall>(o7 :: 64 word). uint o7 = sint nbits \<longrightarrow> (((0 :: int) \<le> uint o7 \<and> uint o7 < (64 :: int)) \<and> (2 :: int) ^\<^sub>i uint o7 * uint (1 :: 64 word) \<le> (18446744073709551615 :: int)) \<and> (\<forall>(o8 :: 64 word). uint o8 = (2 :: int) ^\<^sub>i uint o7 * uint (1 :: 64 word) \<longrightarrow> (\<not>uint o8 = (0 :: int) \<and> uint'64_in_bounds (uint o6 cmod uint o8)) \<and> (\<forall>(result :: 64 word). uint result = uint o6 cmod uint o8 \<longrightarrow> (sint nbits \<le> sint bi \<longrightarrow> valueb p (sint bi) = valueb p (sint bi - sint nbits) + (2 :: int) ^\<^sub>i (sint bi - sint nbits) * uint result) \<and> (sint bi < sint nbits \<longrightarrow> valueb p (sint bi) = uint result) \<and> ((0 :: int) \<le> uint result \<and> uint result < (2 :: int) ^\<^sub>i sint nbits) \<and> uint result = value p (sint pn) ediv (2 :: int) ^\<^sub>i (sint bi - sint nbits) emod (2 :: int) ^\<^sub>i sint nbits))))))))))))"
  sorry
end
