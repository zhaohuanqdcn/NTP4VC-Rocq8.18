import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.c.C
import Why3.mach.int.Unsigned
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.valuation.Valuation
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.sub_1.Sub_1
open Classical
open Lean4Why3
namespace powm_Powm_getbitsqtvc
noncomputable def redc (ur : ℤ) (u : ℤ) (n : ℤ) (m : ℤ) := ur % m = HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat n) * u % m
noncomputable def valueb (p : C.ptr (BitVec 64)) (nbits : ℤ) := if nbits < (0 : ℤ) then (0 : ℤ) else let i : ℤ := nbits / (64 : ℤ); Lemmas.value p i + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat i) * (BitVec.toUInt (C.pelts p (C.offset p + i)) % HPow.hPow (2 : ℤ) (Int.toNat (nbits - (64 : ℤ) * i)))
theorem getbits'vc (nbits : BitVec 32) (bi : BitVec 32) (pn : BitVec 32) (p : C.ptr (BitVec 64)) (fact0 : (1 : ℤ) ≤ BitVec.toInt nbits) (fact1 : BitVec.toInt nbits < (64 : ℤ)) (fact2 : (0 : ℤ) ≤ BitVec.toInt bi) (fact3 : (1 : ℤ) ≤ BitVec.toInt pn) (fact4 : C.valid p (BitVec.toInt pn)) (fact5 : (BitVec.toInt bi + (63 : ℤ)) / (64 : ℤ) ≤ BitVec.toInt pn) : if BitVec.toInt bi < BitVec.toInt nbits then (0 : ℤ) ≤ BitVec.toInt bi ∧ (∀(o1 : BitVec 64), BitVec.toUInt o1 = BitVec.toInt bi → (((0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o1)) * BitVec.toUInt (1 : BitVec 64) ≤ (18446744073709551615 : ℤ)) ∧ (∀(o2 : BitVec 64), BitVec.toUInt o2 = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o1)) * BitVec.toUInt (1 : BitVec 64) → (C.min p ≤ C.offset p ∧ C.offset p < C.max p) ∧ (let o3 : BitVec 64 := C.pelts p (C.offset p); (¬BitVec.toUInt o2 = (0 : ℤ) ∧ uint'64_in_bounds (Int.tmod (BitVec.toUInt o3) (BitVec.toUInt o2))) ∧ (∀(result : BitVec 64), BitVec.toUInt result = Int.tmod (BitVec.toUInt o3) (BitVec.toUInt o2) → (BitVec.toInt nbits ≤ BitVec.toInt bi → valueb p (BitVec.toInt bi) = valueb p (BitVec.toInt bi - BitVec.toInt nbits) + HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt bi - BitVec.toInt nbits)) * BitVec.toUInt result) ∧ (BitVec.toInt bi < BitVec.toInt nbits → valueb p (BitVec.toInt bi) = BitVec.toUInt result) ∧ ((0 : ℤ) ≤ BitVec.toUInt result ∧ BitVec.toUInt result < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt nbits))) ∧ BitVec.toUInt result = Lemmas.value p (BitVec.toInt pn) / HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt bi - BitVec.toInt nbits)) % HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt nbits)))))) else int'32_in_bounds (BitVec.toInt bi - BitVec.toInt nbits) ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = BitVec.toInt bi - BitVec.toInt nbits → (¬(64 : ℤ) = (0 : ℤ) ∧ int'32_in_bounds (Int.tdiv (BitVec.toInt o1) (64 : ℤ))) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = Int.tdiv (BitVec.toInt o1) (64 : ℤ) → (¬(64 : ℤ) = (0 : ℤ) ∧ int'32_in_bounds (Int.tmod (BitVec.toInt o1) (64 : ℤ))) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = Int.tmod (BitVec.toInt o1) (64 : ℤ) → (C.min p ≤ C.offset p + BitVec.toInt o2 ∧ C.offset p + BitVec.toInt o2 < C.max p) ∧ int'32_in_bounds (BitVec.toInt o2 + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt o2 + (1 : ℤ) → (C.min p ≤ C.offset p + BitVec.toInt o4 ∧ C.offset p + BitVec.toInt o4 ≤ C.max p) ∧ (∀(p' : C.ptr (BitVec 64)), C.offset p' = C.offset p + BitVec.toInt o4 ∧ C.plength p' = C.plength p ∧ C.pelts p' = C.pelts p ∧ C.data p' = C.data p ∧ C.min p' = C.min p ∧ C.max p' = C.max p ∧ C.zone1 p' = C.zone1 p ∧ C.writable p' = C.writable p → (0 : ℤ) ≤ BitVec.toInt o3 ∧ (∀(o5 : BitVec 64), BitVec.toUInt o5 = BitVec.toInt o3 → ((0 : ℤ) ≤ BitVec.toUInt o5 ∧ BitVec.toUInt o5 < (64 : ℤ)) ∧ (∀(o6 : BitVec 64), BitVec.toUInt o6 = BitVec.toUInt (C.pelts p (C.offset p + BitVec.toInt o2)) / HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o5)) → ¬HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt o3)) = (0 : ℤ) ∧ int'32_in_bounds ((64 : ℤ) - BitVec.toInt o3) ∧ (∀(nbits_in_r : BitVec 32), BitVec.toInt nbits_in_r = (64 : ℤ) - BitVec.toInt o3 → (if BitVec.toInt nbits_in_r < BitVec.toInt nbits then int'32_in_bounds (BitVec.toInt o2 + (1 : ℤ)) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt o2 + (1 : ℤ) → (C.min p ≤ C.offset p + BitVec.toInt o7 ∧ C.offset p + BitVec.toInt o7 < C.max p) ∧ (0 : ℤ) ≤ BitVec.toInt nbits_in_r ∧ (∀(o8 : BitVec 64), BitVec.toUInt o8 = BitVec.toInt nbits_in_r → ((0 : ℤ) ≤ BitVec.toUInt o8 ∧ BitVec.toUInt o8 < (64 : ℤ)) ∧ (∀(prs : BitVec 64), BitVec.toUInt prs = BitVec.toUInt (C.pelts p (C.offset p + BitVec.toInt o7)) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o8)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) ∧ BitVec.toUInt prs ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o8)) → int'32_in_bounds (BitVec.toInt o2 + (2 : ℤ)) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt o2 + (2 : ℤ) → (C.min p ≤ C.offset p + BitVec.toInt o9 ∧ C.offset p + BitVec.toInt o9 ≤ C.max p) ∧ (∀(p'' : C.ptr (BitVec 64)), C.offset p'' = C.offset p + BitVec.toInt o9 ∧ C.plength p'' = C.plength p ∧ C.pelts p'' = C.pelts p ∧ C.data p'' = C.data p ∧ C.min p'' = C.min p ∧ C.max p'' = C.max p ∧ C.zone1 p'' = C.zone1 p ∧ C.writable p'' = C.writable p → ¬(18446744073709551615 : ℤ) + (1 : ℤ) = (0 : ℤ) ∧ uint'64_in_bounds (BitVec.toUInt o6 + BitVec.toUInt prs) ∧ (∀(o10 : BitVec 64), BitVec.toUInt o10 = BitVec.toUInt o6 + BitVec.toUInt prs → (0 : ℤ) ≤ BitVec.toInt nbits ∧ (∀(o11 : BitVec 64), BitVec.toUInt o11 = BitVec.toInt nbits → (((0 : ℤ) ≤ BitVec.toUInt o11 ∧ BitVec.toUInt o11 < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o11)) * BitVec.toUInt (1 : BitVec 64) ≤ (18446744073709551615 : ℤ)) ∧ (∀(o12 : BitVec 64), BitVec.toUInt o12 = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o11)) * BitVec.toUInt (1 : BitVec 64) → (¬BitVec.toUInt o12 = (0 : ℤ) ∧ uint'64_in_bounds (Int.tmod (BitVec.toUInt o10) (BitVec.toUInt o12))) ∧ (∀(result : BitVec 64), BitVec.toUInt result = Int.tmod (BitVec.toUInt o10) (BitVec.toUInt o12) → (BitVec.toInt nbits ≤ BitVec.toInt bi → valueb p (BitVec.toInt bi) = valueb p (BitVec.toInt bi - BitVec.toInt nbits) + HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt bi - BitVec.toInt nbits)) * BitVec.toUInt result) ∧ (BitVec.toInt bi < BitVec.toInt nbits → valueb p (BitVec.toInt bi) = BitVec.toUInt result) ∧ ((0 : ℤ) ≤ BitVec.toUInt result ∧ BitVec.toUInt result < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt nbits))) ∧ BitVec.toUInt result = Lemmas.value p (BitVec.toInt pn) / HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt bi - BitVec.toInt nbits)) % HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt nbits))))))))))) else (0 : ℤ) ≤ BitVec.toInt nbits ∧ (∀(o7 : BitVec 64), BitVec.toUInt o7 = BitVec.toInt nbits → (((0 : ℤ) ≤ BitVec.toUInt o7 ∧ BitVec.toUInt o7 < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o7)) * BitVec.toUInt (1 : BitVec 64) ≤ (18446744073709551615 : ℤ)) ∧ (∀(o8 : BitVec 64), BitVec.toUInt o8 = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o7)) * BitVec.toUInt (1 : BitVec 64) → (¬BitVec.toUInt o8 = (0 : ℤ) ∧ uint'64_in_bounds (Int.tmod (BitVec.toUInt o6) (BitVec.toUInt o8))) ∧ (∀(result : BitVec 64), BitVec.toUInt result = Int.tmod (BitVec.toUInt o6) (BitVec.toUInt o8) → (BitVec.toInt nbits ≤ BitVec.toInt bi → valueb p (BitVec.toInt bi) = valueb p (BitVec.toInt bi - BitVec.toInt nbits) + HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt bi - BitVec.toInt nbits)) * BitVec.toUInt result) ∧ (BitVec.toInt bi < BitVec.toInt nbits → valueb p (BitVec.toInt bi) = BitVec.toUInt result) ∧ ((0 : ℤ) ≤ BitVec.toUInt result ∧ BitVec.toUInt result < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt nbits))) ∧ BitVec.toUInt result = Lemmas.value p (BitVec.toInt pn) / HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt bi - BitVec.toInt nbits)) % HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt nbits))))))))))))))
  := sorry
end powm_Powm_getbitsqtvc
