import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace coincidence_count_CoincidenceCountBag_coincidence_countqtvc
noncomputable def increasing (a : List ℤ) := ∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length a) → a[Int.toNat i]! ≤ a[Int.toNat j]!
axiom bagofsub :  {α : Type} -> [Inhabited α] -> List α -> ℤ -> ℤ -> Multiset α
axiom bagofsub'def {α : Type} [Inhabited α] (lo : ℤ) (hi : ℤ) (a : List α) (fact0 : (0 : ℤ) ≤ lo) (fact1 : lo ≤ hi) (fact2 : hi ≤ Int.ofNat (List.length a)) : if hi ≤ lo then bagofsub a lo hi = (∅ : Multiset α) else bagofsub a lo hi = Multiset.cons (a[Int.toNat lo]!) (bagofsub a (lo + (1 : ℤ)) hi)
noncomputable def bagof {α : Type} [Inhabited α] (a : List α) := bagofsub a (0 : ℤ) (Int.ofNat (List.length a))
noncomputable def drop {α : Type} [Inhabited α] (a : List α) (i : ℤ) := bagofsub a i (Int.ofNat (List.length a))
theorem coincidence_count'vc (a : List ℤ) (b : List ℤ) (fact0 : increasing a) (fact1 : increasing b) : (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length a) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length b) ∧ (0 : ℤ) + Int.ofNat (Multiset.card (drop a (0 : ℤ) ∩ drop b (0 : ℤ))) = Int.ofNat (Multiset.card (bagof a ∩ bagof b)) ∧ (∀(c : ℤ) (j : ℤ) (i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ j ∧ j ≤ Int.ofNat (List.length b)) ∧ c + Int.ofNat (Multiset.card (drop a i ∩ drop b j)) = Int.ofNat (Multiset.card (bagof a ∩ bagof b)) → (∀(o1 : Bool), (if i < Int.ofNat (List.length a) then o1 = (if j < Int.ofNat (List.length b) then true else false) else o1 = false) → (if o1 = true then ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length b)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if a[Int.toNat i]! < b[Int.toNat j]! then ((0 : ℤ) ≤ Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - j ∧ Int.ofNat (List.length a) - (i + (1 : ℤ)) + Int.ofNat (List.length b) - j < Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - j) ∧ ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ j ∧ j ≤ Int.ofNat (List.length b)) ∧ c + Int.ofNat (Multiset.card (drop a (i + (1 : ℤ)) ∩ drop b j)) = Int.ofNat (Multiset.card (bagof a ∩ bagof b)) else ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length b)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if b[Int.toNat j]! < a[Int.toNat i]! then ((0 : ℤ) ≤ Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - j ∧ Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - (j + (1 : ℤ)) < Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - j) ∧ ((0 : ℤ) ≤ i ∧ i ≤ Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ j + (1 : ℤ) ∧ j + (1 : ℤ) ≤ Int.ofNat (List.length b)) ∧ c + Int.ofNat (Multiset.card (drop a i ∩ drop b (j + (1 : ℤ)))) = Int.ofNat (Multiset.card (bagof a ∩ bagof b)) else ((0 : ℤ) ≤ Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - j ∧ Int.ofNat (List.length a) - (i + (1 : ℤ)) + Int.ofNat (List.length b) - (j + (1 : ℤ)) < Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - j) ∧ ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ j + (1 : ℤ) ∧ j + (1 : ℤ) ≤ Int.ofNat (List.length b)) ∧ c + (1 : ℤ) + Int.ofNat (Multiset.card (drop a (i + (1 : ℤ)) ∩ drop b (j + (1 : ℤ)))) = Int.ofNat (Multiset.card (bagof a ∩ bagof b)))) else c = Int.ofNat (Multiset.card (bagof a ∩ bagof b)))))
  := sorry
end coincidence_count_CoincidenceCountBag_coincidence_countqtvc
