import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
open Classical
open Lean4Why3
namespace pancake_sorting_Top_flipqtvc
noncomputable def sorted (a : List ℤ) (hi : ℤ) := ∀(j1 : ℤ) (j2 : ℤ), (0 : ℤ) ≤ j1 ∧ j1 ≤ j2 ∧ j2 < hi → a[Int.toNat j2]! ≤ a[Int.toNat j1]!
theorem flip'vc (i : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ i) (fact1 : i < Int.ofNat (List.length a)) : let n : ℤ := Int.ofNat (List.length a); ¬(2 : ℤ) = (0 : ℤ) ∧ (let o1 : ℤ := Int.tdiv (n - i) (2 : ℤ) - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → ((∀(j : ℤ), i ≤ j ∧ j < i + (0 : ℤ) → a[Int.toNat j]! = a[Int.toNat (n - (1 : ℤ) - (j - i))]!) ∧ (∀(j : ℤ), n - (0 : ℤ) ≤ j ∧ j < n → a[Int.toNat j]! = a[Int.toNat (n - (1 : ℤ) - (j - i))]!) ∧ List.Perm a a) ∧ (∀(a1 : List ℤ), List.length a1 = List.length a → (∀(k : ℤ), ((0 : ℤ) ≤ k ∧ k ≤ o1) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → a1[Int.toNat j]! = a[Int.toNat j]!) ∧ (∀(j : ℤ), i ≤ j ∧ j < i + k → a1[Int.toNat j]! = a[Int.toNat (n - (1 : ℤ) - (j - i))]!) ∧ (∀(j : ℤ), i + k ≤ j ∧ j < n - k → a1[Int.toNat j]! = a[Int.toNat j]!) ∧ (∀(j : ℤ), n - k ≤ j ∧ j < n → a1[Int.toNat j]! = a[Int.toNat (n - (1 : ℤ) - (j - i))]!) ∧ List.Perm a a1 → (let o2 : ℤ := n - (1 : ℤ) - k; let o3 : ℤ := i + k; (((0 : ℤ) ≤ o3 ∧ o3 < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ o2 ∧ o2 < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 o3 o2 → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → a2[Int.toNat j]! = a[Int.toNat j]!) ∧ (∀(j : ℤ), i ≤ j ∧ j < i + (k + (1 : ℤ)) → a2[Int.toNat j]! = a[Int.toNat (n - (1 : ℤ) - (j - i))]!) ∧ (∀(j : ℤ), i + (k + (1 : ℤ)) ≤ j ∧ j < n - (k + (1 : ℤ)) → a2[Int.toNat j]! = a[Int.toNat j]!) ∧ (∀(j : ℤ), n - (k + (1 : ℤ)) ≤ j ∧ j < n → a2[Int.toNat j]! = a[Int.toNat (n - (1 : ℤ) - (j - i))]!) ∧ List.Perm a a2))) ∧ ((∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → a1[Int.toNat j]! = a[Int.toNat j]!) ∧ (∀(j : ℤ), i ≤ j ∧ j < i + (o1 + (1 : ℤ)) → a1[Int.toNat j]! = a[Int.toNat (n - (1 : ℤ) - (j - i))]!) ∧ (∀(j : ℤ), i + (o1 + (1 : ℤ)) ≤ j ∧ j < n - (o1 + (1 : ℤ)) → a1[Int.toNat j]! = a[Int.toNat j]!) ∧ (∀(j : ℤ), n - (o1 + (1 : ℤ)) ≤ j ∧ j < n → a1[Int.toNat j]! = a[Int.toNat (n - (1 : ℤ) - (j - i))]!) ∧ List.Perm a a1 → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → a1[Int.toNat j]! = a[Int.toNat j]!) ∧ (∀(j : ℤ), i ≤ j ∧ j < Int.ofNat (List.length a1) → a1[Int.toNat j]! = a[Int.toNat (Int.ofNat (List.length a1) - (1 : ℤ) - (j - i))]!) ∧ List.Perm a a1))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (∀(j : ℤ), i ≤ j ∧ j < Int.ofNat (List.length a) → a[Int.toNat j]! = a[Int.toNat (Int.ofNat (List.length a) - (1 : ℤ) - (j - i))]!) ∧ List.Perm a a))
  := sorry
end pancake_sorting_Top_flipqtvc
