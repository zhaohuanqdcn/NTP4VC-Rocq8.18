theory generate_all_trees_GenerateAllTrees_all_treesqtvc
  imports "NTP4Verif.NTP4Verif"
begin
datatype  tree = Empty | Node "tree" "tree"
fun size :: "tree \<Rightarrow> int"
  where "size (Empty :: tree) = (0 :: int)"
      | "size (Node l r) = (1 :: int) + size l + size r" for l r
definition all_trees :: "int \<Rightarrow> tree list \<Rightarrow> _"
  where "all_trees n l \<longleftrightarrow> distinct l \<and> (\<forall>(t :: tree). size t = n \<longleftrightarrow> t \<in> set l)" for n l
theorem all_trees'vc:
  fixes n :: "int"
  assumes fact0: "(0 :: int) \<le> n"
  shows "let o1 :: int = n + (1 :: int) in (0 :: int) \<le> o1 \<and> (\<forall>(a :: tree list list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < o1 \<longrightarrow> a ! nat i = (Nil :: tree list)) \<and> int (length a) = o1 \<longrightarrow> (let o2 :: tree list = Cons (Empty :: tree) (Nil :: tree list) in ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length a)) \<and> (length (a[nat (0 :: int) := o2]) = length a \<longrightarrow> nth (a[nat (0 :: int) := o2]) o nat = (nth a o nat)(0 :: int := o2) \<longrightarrow> ((1 :: int) \<le> n + (1 :: int) \<longrightarrow> (\<forall>(k :: int). (0 :: int) \<le> k \<and> k < (1 :: int) \<longrightarrow> all_trees k (a[nat (0 :: int) := o2] ! nat k)) \<and> (\<forall>(a1 :: tree list list). length a1 = length (a[nat (0 :: int) := o2]) \<longrightarrow> (\<forall>(i :: int). ((1 :: int) \<le> i \<and> i \<le> n) \<and> (\<forall>(k :: int). (0 :: int) \<le> k \<and> k < i \<longrightarrow> all_trees k (a1 ! nat k)) \<longrightarrow> (let o3 :: tree list = (Nil :: tree list) in ((0 :: int) \<le> i \<and> i < int (length a1)) \<and> (length (a1[nat i := o3]) = length a1 \<longrightarrow> nth (a1[nat i := o3]) o nat = (nth a1 o nat)(i := o3) \<longrightarrow> (let o4 :: int = i - (1 :: int) in ((0 :: int) \<le> o4 + (1 :: int) \<longrightarrow> ((\<forall>(k :: int). (0 :: int) \<le> k \<and> k < i \<longrightarrow> all_trees k (a1[nat i := o3] ! nat k)) \<and> distinct (a1[nat i := o3] ! nat i) \<and> (\<forall>(t :: tree). t \<in> set (a1[nat i := o3] ! nat i) \<longleftrightarrow> (\<exists>(l :: tree) (r :: tree). t = Node l r \<and> size t = i \<and> size l < (0 :: int)))) \<and> (\<forall>(a2 :: tree list list). length a2 = length (a1[nat i := o3]) \<longrightarrow> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j \<le> o4) \<and> (\<forall>(k :: int). (0 :: int) \<le> k \<and> k < i \<longrightarrow> all_trees k (a2 ! nat k)) \<and> distinct (a2 ! nat i) \<and> (\<forall>(t :: tree). t \<in> set (a2 ! nat i) \<longleftrightarrow> (\<exists>(l :: tree) (r :: tree). t = Node l r \<and> size t = i \<and> size l < j)) \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a2)) \<and> (let o5 :: int = i - (1 :: int) - j in ((0 :: int) \<le> o5 \<and> o5 < int (length a2)) \<and> (let o6 :: int = i - (1 :: int) - j in ((0 :: int) \<le> j \<and> j < int (length a2)) \<and> ((0 :: int) \<le> j \<and> all_trees j (a2 ! nat j) \<and> (0 :: int) \<le> o6 \<and> all_trees o6 (a2 ! nat o5)) \<and> (\<forall>(o7 :: tree list). distinct o7 \<and> (\<forall>(t :: tree). t \<in> set o7 \<longleftrightarrow> (\<exists>(l :: tree) (r :: tree). t = Node l r \<and> size l = j \<and> size r = o6)) \<longrightarrow> (let o8 :: tree list = o7 @ a2 ! nat i in ((0 :: int) \<le> i \<and> i < int (length a2)) \<and> (length (a2[nat i := o8]) = length a2 \<longrightarrow> nth (a2[nat i := o8]) o nat = (nth a2 o nat)(i := o8) \<longrightarrow> (\<forall>(k :: int). (0 :: int) \<le> k \<and> k < i \<longrightarrow> all_trees k (a2[nat i := o8] ! nat k)) \<and> distinct (a2[nat i := o8] ! nat i) \<and> (\<forall>(t :: tree). t \<in> set (a2[nat i := o8] ! nat i) \<longleftrightarrow> (\<exists>(l :: tree) (r :: tree). t = Node l r \<and> size t = i \<and> size l < j + (1 :: int))))))))) \<and> ((\<forall>(k :: int). (0 :: int) \<le> k \<and> k < i \<longrightarrow> all_trees k (a2 ! nat k)) \<and> distinct (a2 ! nat i) \<and> (\<forall>(t :: tree). t \<in> set (a2 ! nat i) \<longleftrightarrow> (\<exists>(l :: tree) (r :: tree). t = Node l r \<and> size t = i \<and> size l < o4 + (1 :: int))) \<longrightarrow> (\<forall>(k :: int). (0 :: int) \<le> k \<and> k < i + (1 :: int) \<longrightarrow> all_trees k (a2 ! nat k))))) \<and> (o4 + (1 :: int) < (0 :: int) \<longrightarrow> (\<forall>(k :: int). (0 :: int) \<le> k \<and> k < i + (1 :: int) \<longrightarrow> all_trees k (a1[nat i := o3] ! nat k))))))) \<and> ((\<forall>(k :: int). (0 :: int) \<le> k \<and> k < n + (1 :: int) \<longrightarrow> all_trees k (a1 ! nat k)) \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> n \<longrightarrow> all_trees i (a1 ! nat i))))) \<and> (n + (1 :: int) < (1 :: int) \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> n \<longrightarrow> all_trees i (a[nat (0 :: int) := o2] ! nat i))))))"
  sorry
end
