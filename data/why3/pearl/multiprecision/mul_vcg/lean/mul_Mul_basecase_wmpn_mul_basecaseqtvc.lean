import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import pearl.multiprecision.lib.lean.mul.Mul
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.add.Add
open Classical
open Lean4Why3
namespace mul_Mul_basecase_wmpn_mul_basecaseqtvc
theorem wmpn_mul_basecase'vc (sy : BitVec 32) (sx : BitVec 32) (x : C.ptr (BitVec 64)) (y : C.ptr (BitVec 64)) (r : C.ptr (BitVec 64)) (fact0 : (0 : ℤ) < BitVec.toInt sy) (fact1 : BitVec.toInt sy ≤ BitVec.toInt sx) (fact2 : C.valid x (BitVec.toInt sx)) (fact3 : C.valid y (BitVec.toInt sy)) (fact4 : C.valid r (BitVec.toInt sy + BitVec.toInt sx)) (fact5 : C.writable r = true) : C.min y ≤ C.offset y ∧ C.offset y < C.max y ∧ C.valid x (BitVec.toInt sx) ∧ C.valid r (BitVec.toInt sx) ∧ C.writable r = true ∧ (∀(r1 : C.ptr (BitVec 64)), List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → (∀(c : BitVec 64), Lemmas.value r1 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt sx) * BitVec.toUInt (C.pelts y (C.offset y)) ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sx ≤ j → C.pelts r1 j = C.pelts r j) → ((C.min r1 ≤ C.offset r1 + BitVec.toInt sx ∧ C.offset r1 + BitVec.toInt sx < C.max r1) ∧ C.writable r1 = true) ∧ (∀(r2 : C.ptr (BitVec 64)), List.length (C.data r2) = List.length (C.data r1) ∧ C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.max r2 = C.max r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → C.pelts r2 = Function.update (C.pelts r1) (C.offset r2 + BitVec.toInt sx) c ∧ C.pelts r2 (C.offset r2 + BitVec.toInt sx) = c → (C.min r2 ≤ C.offset r2 + (1 : ℤ) ∧ C.offset r2 + (1 : ℤ) ≤ C.max r2) ∧ (∀(o1 : C.ptr (BitVec 64)), C.offset o1 = C.offset r2 + (1 : ℤ) ∧ C.plength o1 = C.plength r2 ∧ C.pelts o1 = C.pelts r2 ∧ C.data o1 = C.data r2 ∧ C.min o1 = C.min r2 ∧ C.max o1 = C.max r2 ∧ C.zone1 o1 = C.zone1 r2 ∧ C.writable o1 = C.writable r2 → (C.min y ≤ C.offset y + (1 : ℤ) ∧ C.offset y + (1 : ℤ) ≤ C.max y) ∧ (∀(o2 : C.ptr (BitVec 64)), C.offset o2 = C.offset y + (1 : ℤ) ∧ C.plength o2 = C.plength y ∧ C.pelts o2 = C.pelts y ∧ C.data o2 = C.data y ∧ C.min o2 = C.min y ∧ C.max o2 = C.max y ∧ C.zone1 o2 = C.zone1 y ∧ C.writable o2 = C.writable y → int'32_in_bounds (BitVec.toInt sy - (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt sy - (1 : ℤ) → (((1 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ BitVec.toInt sy) ∧ (1 : ℤ) = BitVec.toInt sy - BitVec.toInt o3 ∧ Lemmas.value r2 ((1 : ℤ) + BitVec.toInt sx) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (1 : ℤ) ∧ C.offset o1 = C.offset r2 + (1 : ℤ) ∧ C.plength o1 = C.plength r2 ∧ C.min o1 = C.min r2 ∧ C.max o1 = C.max r2 ∧ C.pelts o1 = C.pelts r2 ∧ C.writable o1 = true ∧ C.offset o2 = C.offset y + (1 : ℤ) ∧ C.plength o2 = C.plength y ∧ C.min o2 = C.min y ∧ C.max o2 = C.max y ∧ C.pelts o2 = C.pelts y ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + (BitVec.toInt sy + BitVec.toInt sx) ≤ j → C.pelts r2 j = C.pelts r j)) ∧ (∀(vn : BitVec 32) (i : BitVec 32) (vp : C.ptr (BitVec 64)) (rp : C.ptr (BitVec 64)) (r3 : C.ptr (BitVec 64)), List.length (C.data r3) = List.length (C.data r2) ∧ C.offset r3 = C.offset r2 ∧ C.min r3 = C.min r2 ∧ C.max r3 = C.max r2 ∧ C.writable r3 = C.writable r2 ∧ C.zone1 r3 = C.zone1 r2 → ((1 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sy) ∧ BitVec.toInt i = BitVec.toInt sy - BitVec.toInt vn ∧ Lemmas.value r3 (BitVec.toInt i + BitVec.toInt sx) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt i) ∧ C.offset rp = C.offset r3 + BitVec.toInt i ∧ C.plength rp = C.plength r3 ∧ C.min rp = C.min r3 ∧ C.max rp = C.max r3 ∧ C.pelts rp = C.pelts r3 ∧ C.writable rp = true ∧ C.offset vp = C.offset y + BitVec.toInt i ∧ C.plength vp = C.plength y ∧ C.min vp = C.min y ∧ C.max vp = C.max y ∧ C.pelts vp = C.pelts y ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + (BitVec.toInt sy + BitVec.toInt sx) ≤ j → C.pelts r3 j = C.pelts r j) → (if (2 : ℤ) ≤ BitVec.toInt vn then ((0 : ℤ) < BitVec.toInt sx ∧ C.valid x (BitVec.toInt sx) ∧ C.valid vp (2 : ℤ) ∧ C.valid rp (BitVec.toInt sx + (2 : ℤ)) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)) (r4 : C.ptr (BitVec 64)), C.data rp1 = C.data r4 ∧ List.length (C.data r4) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → C.data rp1 = C.data r4 ∧ List.length (C.data r4) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → List.length (C.data r4) = List.length (C.data r3) ∧ C.offset r4 = C.offset r3 ∧ C.min r4 = C.min r3 ∧ C.max r4 = C.max r3 ∧ C.writable r4 = C.writable r3 ∧ C.zone1 r4 = C.zone1 r3 → (∀(res : BitVec 64), Lemmas.value rp1 (BitVec.toInt sx + (1 : ℤ)) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx + (1 : ℤ))) * BitVec.toUInt res = Lemmas.value rp (BitVec.toInt sx) + Lemmas.value x (BitVec.toInt sx) * Lemmas.value vp (2 : ℤ) ∧ (∀(j : ℤ), j < C.offset rp1 ∨ C.offset rp1 + BitVec.toInt sx + (1 : ℤ) ≤ j → C.pelts rp1 j = C.pelts rp j) → int'32_in_bounds (BitVec.toInt sx + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt sx + (1 : ℤ) → ((C.min rp1 ≤ C.offset rp1 + BitVec.toInt o4 ∧ C.offset rp1 + BitVec.toInt o4 < C.max rp1) ∧ C.writable rp1 = true) ∧ (∀(rp2 : C.ptr (BitVec 64)) (r5 : C.ptr (BitVec 64)), C.data rp2 = C.data r5 ∧ List.length (C.data r5) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → C.data rp2 = C.data r5 ∧ List.length (C.data r5) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → List.length (C.data r5) = List.length (C.data r4) ∧ C.offset r5 = C.offset r4 ∧ C.min r5 = C.min r4 ∧ C.max r5 = C.max r4 ∧ C.writable r5 = C.writable r4 ∧ C.zone1 r5 = C.zone1 r4 → C.pelts rp2 = Function.update (C.pelts rp1) (C.offset rp2 + BitVec.toInt o4) res ∧ C.pelts rp2 (C.offset rp2 + BitVec.toInt o4) = res → int'32_in_bounds (BitVec.toInt i + (2 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt i + (2 : ℤ) → (C.min rp2 ≤ C.offset rp2 + (2 : ℤ) ∧ C.offset rp2 + (2 : ℤ) ≤ C.max rp2) ∧ (∀(o6 : C.ptr (BitVec 64)), C.offset o6 = C.offset rp2 + (2 : ℤ) ∧ C.plength o6 = C.plength rp2 ∧ C.pelts o6 = C.pelts rp2 ∧ C.data o6 = C.data rp2 ∧ C.min o6 = C.min rp2 ∧ C.max o6 = C.max rp2 ∧ C.zone1 o6 = C.zone1 rp2 ∧ C.writable o6 = C.writable rp2 → (C.min vp ≤ C.offset vp + (2 : ℤ) ∧ C.offset vp + (2 : ℤ) ≤ C.max vp) ∧ (∀(o7 : C.ptr (BitVec 64)), C.offset o7 = C.offset vp + (2 : ℤ) ∧ C.plength o7 = C.plength vp ∧ C.pelts o7 = C.pelts vp ∧ C.data o7 = C.data vp ∧ C.min o7 = C.min vp ∧ C.max o7 = C.max vp ∧ C.zone1 o7 = C.zone1 vp ∧ C.writable o7 = C.writable vp → int'32_in_bounds (BitVec.toInt vn - (2 : ℤ)) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt vn - (2 : ℤ) → BitVec.toInt o8 < BitVec.toInt vn ∧ ((1 : ℤ) ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 ≤ BitVec.toInt sy) ∧ BitVec.toInt o5 = BitVec.toInt sy - BitVec.toInt o8 ∧ Lemmas.value r5 (BitVec.toInt o5 + BitVec.toInt sx) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt o5) ∧ C.offset o6 = C.offset r5 + BitVec.toInt o5 ∧ C.plength o6 = C.plength r5 ∧ C.min o6 = C.min r5 ∧ C.max o6 = C.max r5 ∧ C.pelts o6 = C.pelts r5 ∧ C.writable o6 = true ∧ C.offset o7 = C.offset y + BitVec.toInt o5 ∧ C.plength o7 = C.plength y ∧ C.min o7 = C.min y ∧ C.max o7 = C.max y ∧ C.pelts o7 = C.pelts y ∧ (∀(j : ℤ), j < C.offset r5 ∨ C.offset r5 + (BitVec.toInt sy + BitVec.toInt sx) ≤ j → C.pelts r5 j = C.pelts r j))))))))) else (((1 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sy) ∧ BitVec.toInt i = BitVec.toInt sy - BitVec.toInt vn ∧ Lemmas.value r3 (BitVec.toInt i + BitVec.toInt sx) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt i) ∧ C.offset rp = C.offset r3 + BitVec.toInt i ∧ C.plength rp = C.plength r3 ∧ C.min rp = C.min r3 ∧ C.max rp = C.max r3 ∧ C.pelts rp = C.pelts r3 ∧ C.writable rp = true ∧ C.offset vp = C.offset y + BitVec.toInt i ∧ C.plength vp = C.plength y ∧ C.min vp = C.min y ∧ C.max vp = C.max y ∧ C.pelts vp = C.pelts y ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + (BitVec.toInt sy + BitVec.toInt sx) ≤ j → C.pelts r3 j = C.pelts r j)) ∧ (∀(vn1 : BitVec 32) (i1 : BitVec 32) (vp1 : C.ptr (BitVec 64)) (rp1 : C.ptr (BitVec 64)) (r4 : C.ptr (BitVec 64)), List.length (C.data r4) = List.length (C.data r3) ∧ C.offset r4 = C.offset r3 ∧ C.min r4 = C.min r3 ∧ C.max r4 = C.max r3 ∧ C.writable r4 = C.writable r3 ∧ C.zone1 r4 = C.zone1 r3 → ((1 : ℤ) ≤ BitVec.toInt i1 ∧ BitVec.toInt i1 ≤ BitVec.toInt sy) ∧ BitVec.toInt i1 = BitVec.toInt sy - BitVec.toInt vn1 ∧ Lemmas.value r4 (BitVec.toInt i1 + BitVec.toInt sx) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt i1) ∧ C.offset rp1 = C.offset r4 + BitVec.toInt i1 ∧ C.plength rp1 = C.plength r4 ∧ C.min rp1 = C.min r4 ∧ C.max rp1 = C.max r4 ∧ C.pelts rp1 = C.pelts r4 ∧ C.writable rp1 = true ∧ C.offset vp1 = C.offset y + BitVec.toInt i1 ∧ C.plength vp1 = C.plength y ∧ C.min vp1 = C.min y ∧ C.max vp1 = C.max y ∧ C.pelts vp1 = C.pelts y ∧ (∀(j : ℤ), j < C.offset r4 ∨ C.offset r4 + (BitVec.toInt sy + BitVec.toInt sx) ≤ j → C.pelts r4 j = C.pelts r j) → (if (1 : ℤ) ≤ BitVec.toInt vn1 then (C.min vp1 ≤ C.offset vp1 ∧ C.offset vp1 < C.max vp1) ∧ (C.valid x (BitVec.toInt sx) ∧ C.valid rp1 (BitVec.toInt sx) ∧ C.writable rp1 = true) ∧ (∀(rp2 : C.ptr (BitVec 64)) (r5 : C.ptr (BitVec 64)), C.data rp2 = C.data r5 ∧ List.length (C.data r5) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → C.data rp2 = C.data r5 ∧ List.length (C.data r5) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → List.length (C.data r5) = List.length (C.data r4) ∧ C.offset r5 = C.offset r4 ∧ C.min r5 = C.min r4 ∧ C.max r5 = C.max r4 ∧ C.writable r5 = C.writable r4 ∧ C.zone1 r5 = C.zone1 r4 → (∀(res : BitVec 64), Lemmas.value rp2 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt res = Lemmas.value rp1 (BitVec.toInt sx) + Lemmas.value x (BitVec.toInt sx) * BitVec.toUInt (C.pelts vp1 (C.offset vp1)) ∧ (∀(j : ℤ), j < C.offset rp2 ∨ C.offset rp2 + BitVec.toInt sx ≤ j → C.pelts rp2 j = C.pelts rp1 j) → ((C.min rp2 ≤ C.offset rp2 + BitVec.toInt sx ∧ C.offset rp2 + BitVec.toInt sx < C.max rp2) ∧ C.writable rp2 = true) ∧ (∀(rp3 : C.ptr (BitVec 64)) (r6 : C.ptr (BitVec 64)), C.data rp3 = C.data r6 ∧ List.length (C.data r6) = List.length (C.data rp2) ∧ C.offset rp3 = C.offset rp2 ∧ C.min rp3 = C.min rp2 ∧ C.max rp3 = C.max rp2 ∧ C.writable rp3 = C.writable rp2 ∧ C.zone1 rp3 = C.zone1 rp2 → C.data rp3 = C.data r6 ∧ List.length (C.data r6) = List.length (C.data rp2) ∧ C.offset rp3 = C.offset rp2 ∧ C.min rp3 = C.min rp2 ∧ C.max rp3 = C.max rp2 ∧ C.writable rp3 = C.writable rp2 ∧ C.zone1 rp3 = C.zone1 rp2 → List.length (C.data r6) = List.length (C.data r5) ∧ C.offset r6 = C.offset r5 ∧ C.min r6 = C.min r5 ∧ C.max r6 = C.max r5 ∧ C.writable r6 = C.writable r5 ∧ C.zone1 r6 = C.zone1 r5 → C.pelts rp3 = Function.update (C.pelts rp2) (C.offset rp3 + BitVec.toInt sx) res ∧ C.pelts rp3 (C.offset rp3 + BitVec.toInt sx) = res → int'32_in_bounds (BitVec.toInt i1 + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt i1 + (1 : ℤ) → (C.min rp3 ≤ C.offset rp3 + (1 : ℤ) ∧ C.offset rp3 + (1 : ℤ) ≤ C.max rp3) ∧ (∀(o5 : C.ptr (BitVec 64)), C.offset o5 = C.offset rp3 + (1 : ℤ) ∧ C.plength o5 = C.plength rp3 ∧ C.pelts o5 = C.pelts rp3 ∧ C.data o5 = C.data rp3 ∧ C.min o5 = C.min rp3 ∧ C.max o5 = C.max rp3 ∧ C.zone1 o5 = C.zone1 rp3 ∧ C.writable o5 = C.writable rp3 → (C.min vp1 ≤ C.offset vp1 + (1 : ℤ) ∧ C.offset vp1 + (1 : ℤ) ≤ C.max vp1) ∧ (∀(o6 : C.ptr (BitVec 64)), C.offset o6 = C.offset vp1 + (1 : ℤ) ∧ C.plength o6 = C.plength vp1 ∧ C.pelts o6 = C.pelts vp1 ∧ C.data o6 = C.data vp1 ∧ C.min o6 = C.min vp1 ∧ C.max o6 = C.max vp1 ∧ C.zone1 o6 = C.zone1 vp1 ∧ C.writable o6 = C.writable vp1 → int'32_in_bounds (BitVec.toInt vn1 - (1 : ℤ)) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt vn1 - (1 : ℤ) → BitVec.toInt o7 < BitVec.toInt vn1 ∧ ((1 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ BitVec.toInt sy) ∧ BitVec.toInt o4 = BitVec.toInt sy - BitVec.toInt o7 ∧ Lemmas.value r6 (BitVec.toInt o4 + BitVec.toInt sx) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt o4) ∧ C.offset o5 = C.offset r6 + BitVec.toInt o4 ∧ C.plength o5 = C.plength r6 ∧ C.min o5 = C.min r6 ∧ C.max o5 = C.max r6 ∧ C.pelts o5 = C.pelts r6 ∧ C.writable o5 = true ∧ C.offset o6 = C.offset y + BitVec.toInt o4 ∧ C.plength o6 = C.plength y ∧ C.min o6 = C.min y ∧ C.max o6 = C.max y ∧ C.pelts o6 = C.pelts y ∧ (∀(j : ℤ), j < C.offset r6 ∨ C.offset r6 + (BitVec.toInt sy + BitVec.toInt sx) ≤ j → C.pelts r6 j = C.pelts r j)))))))) else Lemmas.value r4 (BitVec.toInt sy + BitVec.toInt sx) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r4 ∨ C.offset r4 + (BitVec.toInt sy + BitVec.toInt sx) ≤ j → C.pelts r4 j = C.pelts r j)))))))))))
  := sorry
end mul_Mul_basecase_wmpn_mul_basecaseqtvc
