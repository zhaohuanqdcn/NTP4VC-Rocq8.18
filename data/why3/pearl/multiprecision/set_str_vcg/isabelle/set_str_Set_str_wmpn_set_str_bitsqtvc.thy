theory set_str_Set_str_wmpn_set_str_bitsqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "mach.c_UChar" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/powm_Powm" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/sub_1_Sub_1" "../../lib/isabelle/stringlemmas_String_lemmas" "../../lib/isabelle/base_info_BaseInfo"
begin
theorem wmpn_set_str_bits'vc:
  fixes sn :: "32 word"
  fixes sz :: "32 word"
  fixes rp :: "64 word ptr"
  fixes sp :: "8 word ptr"
  fixes bits :: "32 word"
  assumes fact0: "(0 :: int) < uint sn"
  assumes fact1: "uint sn \<le> (2147483647 :: int)"
  assumes fact2: "(0 :: int) < sint sz"
  assumes fact3: "valid rp (sint sz)"
  assumes fact4: "valid sp (uint sn)"
  assumes fact5: "(1 :: int) \<le> uint bits"
  assumes fact6: "uint bits \<le> (8 :: int)"
  assumes fact7: "(2 :: int) ^\<^sub>i (uint bits * uint sn) \<le> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sz"
  assumes fact8: "writable rp = True"
  assumes fact9: "in_base ((2 :: int) ^\<^sub>i uint bits) (pelts sp) (offset sp) (offset sp + uint sn)"
  shows "uint sn \<le> (2147483647 :: int)"
  and "\<forall>(o1 :: 32 word). sint o1 = uint sn \<longrightarrow> (let b :: int = (2 :: int) ^\<^sub>i uint bits in (((0 :: int) \<le> sint o1 \<and> sint o1 \<le> uint sn) \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> sint sz) \<and> (uint sn - sint o1) * uint bits = (0 :: int) \<and> ((0 :: int) < sint o1 \<longrightarrow> (0 :: int) = (64 :: int) * (0 :: int)) \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < (64 :: int)) \<and> ((0 :: int) < (0 :: int) \<longrightarrow> uint (pelts rp (offset rp + (0 :: int) - (1 :: int))) < (2 :: int) ^\<^sub>i (0 :: int)) \<and> value rp (0 :: int) = svalue_sub b (pelts sp) (offset sp + sint o1) (offset sp + uint sn)) \<and> (\<forall>(j :: 32 word) (shift :: 32 word) (rn :: 32 word) (rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> ((0 :: int) \<le> sint j \<and> sint j \<le> uint sn) \<and> ((0 :: int) \<le> sint rn \<and> sint rn \<le> sint sz) \<and> ((0 :: int) < sint j \<longrightarrow> (if uint shift = (0 :: int) then (uint sn - sint j) * uint bits = (64 :: int) * sint rn else (uint sn - sint j) * uint bits = (64 :: int) * sint rn - (64 :: int) + uint shift)) \<and> ((0 :: int) \<le> uint shift \<and> uint shift < (64 :: int)) \<and> ((0 :: int) < uint shift \<longrightarrow> uint (pelts rp1 (offset rp1 + sint rn - (1 :: int))) < (2 :: int) ^\<^sub>i uint shift) \<and> (sint rn = (0 :: int) \<longrightarrow> uint shift = (0 :: int)) \<and> value rp1 (sint rn) = svalue_sub b (pelts sp) (offset sp + sint j) (offset sp + uint sn) \<longrightarrow> (if (0 :: int) < sint j then int'32_in_bounds (sint j - (1 :: int)) \<and> (\<forall>(o2 :: 32 word). sint o2 = sint j - (1 :: int) \<longrightarrow> (c_C.min sp \<le> offset sp + sint o2 \<and> offset sp + sint o2 < c_C.max sp) \<and> (\<forall>(sj :: 64 word). uint sj = uint (pelts sp (offset sp + sint o2)) \<longrightarrow> (uint shift = (0 :: int) \<longrightarrow> shift = (0 :: 32 word)) \<longrightarrow> (if shift = (0 :: 32 word) then ((c_C.min rp1 \<le> offset rp1 + sint rn \<and> offset rp1 + sint rn < c_C.max rp1) \<and> writable rp1 = True) \<and> (\<forall>(rp2 :: 64 word ptr). length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> pelts rp2 = (pelts rp1)(offset rp2 + sint rn := sj) \<and> pelts rp2 (offset rp2 + sint rn) = sj \<longrightarrow> int'32_in_bounds (sint rn + (1 :: int)) \<and> (\<forall>(o3 :: 32 word). sint o3 = sint rn + (1 :: int) \<longrightarrow> sint o2 < sint j \<and> ((0 :: int) \<le> sint o2 \<and> sint o2 \<le> uint sn) \<and> ((0 :: int) \<le> sint o3 \<and> sint o3 \<le> sint sz) \<and> (uint sn - sint o2) * uint bits = (uint sn - sint j) * uint bits + uint bits \<and> ((0 :: int) < sint o2 \<longrightarrow> (if uint bits = (0 :: int) then (uint sn - sint j) * uint bits + uint bits = (64 :: int) * sint o3 else (uint sn - sint j) * uint bits + uint bits = (64 :: int) * sint o3 - (64 :: int) + uint bits)) \<and> ((0 :: int) \<le> uint bits \<and> uint bits < (64 :: int)) \<and> ((0 :: int) < uint bits \<longrightarrow> uint (pelts rp2 (offset rp2 + sint o3 - (1 :: int))) < (2 :: int) ^\<^sub>i uint bits) \<and> (sint o3 = (0 :: int) \<longrightarrow> uint bits = (0 :: int)) \<and> value rp2 (sint o3) = svalue_sub b (pelts sp) (offset sp + sint o2) (offset sp + uint sn))) else int'32_in_bounds (sint rn - (1 :: int)) \<and> (\<forall>(o3 :: 32 word). sint o3 = sint rn - (1 :: int) \<longrightarrow> (c_C.min rp1 \<le> offset rp1 + sint o3 \<and> offset rp1 + sint o3 < c_C.max rp1) \<and> (let rlow :: 64 word = pelts rp1 (offset rp1 + sint o3) in \<forall>(o4 :: 64 word). uint o4 = uint shift \<longrightarrow> ((0 :: int) \<le> uint o4 \<and> uint o4 < (64 :: int)) \<and> (\<forall>(slow :: 64 word). uint slow = uint sj * (2 :: int) ^\<^sub>i uint o4 emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> uint'64_in_bounds (uint rlow + uint slow) \<and> (\<forall>(nr :: 64 word). uint nr = uint rlow + uint slow \<longrightarrow> int'32_in_bounds (sint rn - (1 :: int)) \<and> (\<forall>(o5 :: 32 word). sint o5 = sint rn - (1 :: int) \<longrightarrow> ((c_C.min rp1 \<le> offset rp1 + sint o5 \<and> offset rp1 + sint o5 < c_C.max rp1) \<and> writable rp1 = True) \<and> (\<forall>(rp2 :: 64 word ptr). length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> pelts rp2 = (pelts rp1)(offset rp2 + sint o5 := nr) \<and> pelts rp2 (offset rp2 + sint o5) = nr \<longrightarrow> uint'32_in_bounds (uint shift + uint bits) \<and> (\<forall>(o6 :: 32 word). uint o6 = uint shift + uint bits \<longrightarrow> (if (64 :: int) \<le> uint o6 then uint'32_in_bounds (uint o6 - (64 :: int)) \<and> (\<forall>(o7 :: 32 word). uint o7 = uint o6 - (64 :: int) \<longrightarrow> (if (0 :: int) < uint o7 then uint'32_in_bounds (uint bits - uint o7) \<and> (\<forall>(o8 :: 32 word). uint o8 = uint bits - uint o7 \<longrightarrow> (\<forall>(o9 :: 64 word). uint o9 = uint o8 \<longrightarrow> ((0 :: int) \<le> uint o9 \<and> uint o9 < (64 :: int)) \<and> (\<forall>(shigh :: 64 word). uint shigh = uint sj ediv (2 :: int) ^\<^sub>i uint o9 \<longrightarrow> ((c_C.min rp2 \<le> offset rp2 + sint rn \<and> offset rp2 + sint rn < c_C.max rp2) \<and> writable rp2 = True) \<and> (\<forall>(rp3 :: 64 word ptr). length (data rp3) = length (data rp2) \<and> offset rp3 = offset rp2 \<and> c_C.min rp3 = c_C.min rp2 \<and> c_C.max rp3 = c_C.max rp2 \<and> writable rp3 = writable rp2 \<and> zone1 rp3 = zone1 rp2 \<longrightarrow> pelts rp3 = (pelts rp2)(offset rp3 + sint rn := shigh) \<and> pelts rp3 (offset rp3 + sint rn) = shigh \<longrightarrow> int'32_in_bounds (sint rn + (1 :: int)) \<and> (\<forall>(o10 :: 32 word). sint o10 = sint rn + (1 :: int) \<longrightarrow> sint o2 < sint j \<and> ((0 :: int) \<le> sint o2 \<and> sint o2 \<le> uint sn) \<and> ((0 :: int) \<le> sint o10 \<and> sint o10 \<le> sint sz) \<and> (uint sn - sint o2) * uint bits = (uint sn - sint j) * uint bits + uint bits \<and> ((0 :: int) < sint o2 \<longrightarrow> (if uint o7 = (0 :: int) then (uint sn - sint j) * uint bits + uint bits = (64 :: int) * sint o10 else (uint sn - sint j) * uint bits + uint bits = (64 :: int) * sint o10 - (64 :: int) + uint o7)) \<and> ((0 :: int) \<le> uint o7 \<and> uint o7 < (64 :: int)) \<and> ((0 :: int) < uint o7 \<longrightarrow> uint (pelts rp3 (offset rp3 + sint o10 - (1 :: int))) < (2 :: int) ^\<^sub>i uint o7) \<and> (sint o10 = (0 :: int) \<longrightarrow> uint o7 = (0 :: int)) \<and> value rp3 (sint o10) = svalue_sub b (pelts sp) (offset sp + sint o2) (offset sp + uint sn)))))) else sint o2 < sint j \<and> ((0 :: int) \<le> sint o2 \<and> sint o2 \<le> uint sn) \<and> ((0 :: int) \<le> sint rn \<and> sint rn \<le> sint sz) \<and> (uint sn - sint o2) * uint bits = (uint sn - sint j) * uint bits + uint bits \<and> ((0 :: int) < sint o2 \<longrightarrow> (if uint o7 = (0 :: int) then (uint sn - sint j) * uint bits + uint bits = (64 :: int) * sint rn else (uint sn - sint j) * uint bits + uint bits = (64 :: int) * sint rn - (64 :: int) + uint o7)) \<and> ((0 :: int) \<le> uint o7 \<and> uint o7 < (64 :: int)) \<and> ((0 :: int) < uint o7 \<longrightarrow> uint (pelts rp2 (offset rp2 + sint rn - (1 :: int))) < (2 :: int) ^\<^sub>i uint o7) \<and> (sint rn = (0 :: int) \<longrightarrow> uint o7 = (0 :: int)) \<and> value rp2 (sint rn) = svalue_sub b (pelts sp) (offset sp + sint o2) (offset sp + uint sn))) else sint o2 < sint j \<and> ((0 :: int) \<le> sint o2 \<and> sint o2 \<le> uint sn) \<and> ((0 :: int) \<le> sint rn \<and> sint rn \<le> sint sz) \<and> (uint sn - sint o2) * uint bits = (uint sn - sint j) * uint bits + uint bits \<and> ((0 :: int) < sint o2 \<longrightarrow> (if uint o6 = (0 :: int) then (uint sn - sint j) * uint bits + uint bits = (64 :: int) * sint rn else (uint sn - sint j) * uint bits + uint bits = (64 :: int) * sint rn - (64 :: int) + uint o6)) \<and> ((0 :: int) \<le> uint o6 \<and> uint o6 < (64 :: int)) \<and> ((0 :: int) < uint o6 \<longrightarrow> uint (pelts rp2 (offset rp2 + sint rn - (1 :: int))) < (2 :: int) ^\<^sub>i uint o6) \<and> (sint rn = (0 :: int) \<longrightarrow> uint o6 = (0 :: int)) \<and> value rp2 (sint rn) = svalue_sub b (pelts sp) (offset sp + sint o2) (offset sp + uint sn)))))))))))) else ((0 :: int) \<le> sint rn \<and> valid rp1 (sint rn)) \<and> (\<forall>(rn1 :: 32 word). ((0 :: int) \<le> sint rn1 \<and> sint rn1 \<le> sint rn) \<and> value rp1 (sint rn1) = value rp1 (sint rn) \<and> (sint rn1 = (0 :: int) \<or> (0 :: int) < uint (pelts rp1 (offset rp1 + sint rn1 - (1 :: int)))) \<and> (sint rn1 = (0 :: int) \<or> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint rn1 - (1 :: int)) \<le> value rp1 (sint rn1)) \<longrightarrow> ((0 :: int) \<le> sint rn1 \<and> sint rn1 \<le> sint sz) \<and> value rp1 (sint rn1) = svalue ((2 :: int) ^\<^sub>i uint bits) sp (uint sn) \<and> ((0 :: int) < sint rn1 \<longrightarrow> (0 :: int) < uint (pelts rp1 (offset rp1 + sint rn1 - (1 :: int))))))))"
  sorry
end
