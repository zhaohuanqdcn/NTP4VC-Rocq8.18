theory split_string_SplitString_split_stringqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref"
begin
typedecl  char
typedecl  string'
consts concat :: "char list list \<Rightarrow> char \<Rightarrow> char list"
axiomatization where concat'def:   "if int (length ss) = (1 :: int) then concat ss sep = ss ! (0 :: nat) else concat ss sep = concat (drop (0 :: nat) (take (nat (int (length ss) - (1 :: int)) - (0 :: nat)) ss)) sep @ Cons sep (ss ! nat (int (length ss) - (1 :: int)))"
 if "(1 :: int) \<le> int (length ss)"
  for ss :: "char list list"
  and sep :: "char"
definition notin :: "char \<Rightarrow> char list \<Rightarrow> _"
  where "notin sep s \<longleftrightarrow> \<not>sep \<in> set s" for sep s
theorem split_string'vc:
  fixes limit :: "int"
  fixes s :: "char list"
  fixes sep :: "char"
  assumes fact0: "limit = -(1 :: int) \<or> (1 :: int) \<le> limit"
  shows "if limit = (1 :: int) then let r :: char list list = [s] in int (length r) = (1 :: int) \<and> r ! (0 :: nat) = s \<longrightarrow> (1 :: int) \<le> int (length r) \<and> (limit = -(1 :: int) \<or> int (length r) \<le> limit) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length r) - (1 :: int) \<longrightarrow> notin sep (r ! nat j)) \<and> (int (length r) = limit \<or> notin sep (r ! nat (int (length r) - (1 :: int)))) \<and> concat r sep = s else (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> int (length s)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length []) \<longrightarrow> notin sep ([] ! nat j)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> \<not>s ! nat j = sep) \<and> (limit = -(1 :: int) \<or> int (length []) < limit - (1 :: int)) \<and> concat ([] @ [drop (0 :: nat) s]) sep = s) \<and> (\<forall>(b :: int) (i :: int) (ss :: char list list). ((0 :: int) \<le> b \<and> b \<le> i \<and> i \<le> int (length s)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length ss) \<longrightarrow> notin sep (ss ! nat j)) \<and> (\<forall>(j :: int). b \<le> j \<and> j < i \<longrightarrow> \<not>s ! nat j = sep) \<and> (limit = -(1 :: int) \<or> int (length ss) < limit - (1 :: int)) \<and> concat (ss @ [drop (nat b) s]) sep = s \<longrightarrow> (if i < int (length s) then ((0 :: int) \<le> i \<and> i < int (length s)) \<and> (if s ! nat i = sep then ((0 :: int) \<le> b \<and> b \<le> i \<and> i \<le> int (length s)) \<and> (let o1 :: char list = drop (nat b) (take (nat i - nat b) s) in int (length o1) = i - b \<and> (\<forall>(k :: int). (0 :: int) \<le> k \<and> k < i - b \<longrightarrow> o1 ! nat k = s ! nat (b + k)) \<longrightarrow> (let o2 :: char list list = ss @ [o1] in int (length o2) = (1 :: int) + int (length ss) \<and> o2 ! length ss = o1 \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < int (length ss) \<longrightarrow> o2 ! nat i1 = ss ! nat i1) \<longrightarrow> (if int (length o2) = limit - (1 :: int) then let o3 :: int = i + (1 :: int) in ((0 :: int) \<le> o3 \<and> o3 \<le> int (length s)) \<and> (let o4 :: char list = drop (nat o3) s; r :: char list list = o2 @ [o4] in int (length r) = (1 :: int) + int (length o2) \<and> r ! length o2 = o4 \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < int (length o2) \<longrightarrow> r ! nat i1 = o2 ! nat i1) \<longrightarrow> (1 :: int) \<le> int (length r) \<and> (limit = -(1 :: int) \<or> int (length r) \<le> limit) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length r) - (1 :: int) \<longrightarrow> notin sep (r ! nat j)) \<and> (int (length r) = limit \<or> notin sep (r ! nat (int (length r) - (1 :: int)))) \<and> concat r sep = s) else ((0 :: int) \<le> int (length s) - i \<and> int (length s) - (i + (1 :: int)) < int (length s) - i) \<and> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> int (length s)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length o2) \<longrightarrow> notin sep (o2 ! nat j)) \<and> (\<forall>(j :: int). i + (1 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> \<not>s ! nat j = sep) \<and> (limit = -(1 :: int) \<or> int (length o2) < limit - (1 :: int)) \<and> concat (o2 @ [drop (nat (i + (1 :: int))) s]) sep = s))) else ((0 :: int) \<le> int (length s) - i \<and> int (length s) - (i + (1 :: int)) < int (length s) - i) \<and> ((0 :: int) \<le> b \<and> b \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> int (length s)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length ss) \<longrightarrow> notin sep (ss ! nat j)) \<and> (\<forall>(j :: int). b \<le> j \<and> j < i + (1 :: int) \<longrightarrow> \<not>s ! nat j = sep) \<and> (limit = -(1 :: int) \<or> int (length ss) < limit - (1 :: int)) \<and> concat (ss @ [drop (nat b) s]) sep = s) else ((0 :: int) \<le> b \<and> b \<le> int (length s)) \<and> (let o1 :: char list = drop (nat b) s; r :: char list list = ss @ [o1] in int (length r) = (1 :: int) + int (length ss) \<and> r ! length ss = o1 \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < int (length ss) \<longrightarrow> r ! nat i1 = ss ! nat i1) \<longrightarrow> (1 :: int) \<le> int (length r) \<and> (limit = -(1 :: int) \<or> int (length r) \<le> limit) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length r) - (1 :: int) \<longrightarrow> notin sep (r ! nat j)) \<and> (int (length r) = limit \<or> notin sep (r ! nat (int (length r) - (1 :: int)))) \<and> concat r sep = s)))"
  sorry
end
