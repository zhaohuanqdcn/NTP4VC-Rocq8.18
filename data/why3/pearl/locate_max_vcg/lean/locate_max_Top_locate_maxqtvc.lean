import Why3.Base
import Why3.why3.Ref.Ref
import Why3.mach.c.C
import Why3.mach.int.Unsigned
open Classical
open Lean4Why3
namespace locate_max_Top_locate_maxqtvc
noncomputable def mixfix_lbrb {α : Type} [Inhabited α] (a : C.ptr α) (i : ℤ) := (getElem! (C.data a) ∘ Int.toNat) (C.offset a + i)
theorem locate_max'vc (n : BitVec 32) (a : C.ptr (BitVec 64)) (fact0 : (0 : ℤ) < BitVec.toInt n) (fact1 : C.valid a (BitVec.toInt n)) : int'32_in_bounds (BitVec.toInt n - (1 : ℤ)) ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = BitVec.toInt n - (1 : ℤ) → ((1 : ℤ) ≤ BitVec.toInt o1 + (1 : ℤ) → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < BitVec.toInt n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (1 : ℤ) → BitVec.toInt (mixfix_lbrb a i) ≤ BitVec.toInt (mixfix_lbrb a (0 : ℤ)))) ∧ (∀(idx : BitVec 32), (∀(j : BitVec 32), let j1 : ℤ := BitVec.toInt j; ((1 : ℤ) ≤ j1 ∧ j1 ≤ BitVec.toInt o1) ∧ ((0 : ℤ) ≤ BitVec.toInt idx ∧ BitVec.toInt idx < BitVec.toInt n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < j1 → BitVec.toInt (mixfix_lbrb a i) ≤ BitVec.toInt (mixfix_lbrb a (BitVec.toInt idx))) → (C.min a ≤ C.offset a + BitVec.toInt j ∧ C.offset a + BitVec.toInt j < C.max a) ∧ (C.min a ≤ C.offset a + BitVec.toInt idx ∧ C.offset a + BitVec.toInt idx < C.max a) ∧ (if BitVec.toInt (C.pelts a (C.offset a + BitVec.toInt idx)) < BitVec.toInt (C.pelts a (C.offset a + BitVec.toInt j)) then ((0 : ℤ) ≤ BitVec.toInt j ∧ BitVec.toInt j < BitVec.toInt n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < j1 + (1 : ℤ) → BitVec.toInt (mixfix_lbrb a i) ≤ BitVec.toInt (mixfix_lbrb a (BitVec.toInt j))) else ((0 : ℤ) ≤ BitVec.toInt idx ∧ BitVec.toInt idx < BitVec.toInt n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < j1 + (1 : ℤ) → BitVec.toInt (mixfix_lbrb a i) ≤ BitVec.toInt (mixfix_lbrb a (BitVec.toInt idx))))) ∧ (((0 : ℤ) ≤ BitVec.toInt idx ∧ BitVec.toInt idx < BitVec.toInt n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt o1 + (1 : ℤ) → BitVec.toInt (mixfix_lbrb a i) ≤ BitVec.toInt (mixfix_lbrb a (BitVec.toInt idx))) → ((0 : ℤ) ≤ BitVec.toInt idx ∧ BitVec.toInt idx < BitVec.toInt n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt n → BitVec.toInt (mixfix_lbrb a i) ≤ BitVec.toInt (mixfix_lbrb a (BitVec.toInt idx)))))) ∧ (BitVec.toInt o1 + (1 : ℤ) < (1 : ℤ) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < BitVec.toInt n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt n → BitVec.toInt (mixfix_lbrb a i) ≤ BitVec.toInt (mixfix_lbrb a (0 : ℤ)))))
  := sorry
end locate_max_Top_locate_maxqtvc
