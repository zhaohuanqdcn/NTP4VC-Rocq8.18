import Why3.Base
import Why3.why3.WellFounded.WellFounded
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace isqrt_von_neumann_VonNeumann32_isqrt32qtvc
noncomputable def sqr (x : BitVec 32) := x * x
noncomputable def is_pow2 (x : BitVec 32) (n : BitVec 32) := x &&& ((1 : BitVec 32) <<< BitVec.toNat n) - (1 : BitVec 32) = (0 : BitVec 32)
theorem isqrt32'vc (x : BitVec 32) : (16 : BitVec 32) ≤ (16 : BitVec 32) ∧ (32768 : BitVec 32) = (if (16 : BitVec 32) = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat ((16 : BitVec 32) - (1 : BitVec 32))) ∧ (1073741824 : BitVec 32) = sqr (32768 : BitVec 32) ∧ is_pow2 (0 : BitVec 32) (16 : BitVec 32) ∧ (0 : BitVec 32) < (65536 : BitVec 32) ∧ (0 : BitVec 32) = (0 : BitVec 32) * ((1 : BitVec 32) <<< BitVec.toNat (16 : BitVec 32)) ∧ x ≤ x ∧ x - x = sqr (0 : BitVec 32) ∧ (0 : BitVec 32) + ((1 : BitVec 32) <<< BitVec.toNat (16 : BitVec 32)) ≤ (65536 : BitVec 32) ∧ x ≤ sqr ((0 : BitVec 32) + ((1 : BitVec 32) <<< BitVec.toNat (16 : BitVec 32))) - (1 : BitVec 32) ∧ (∀(res_g : BitVec 32) (m : BitVec 32) (num : BitVec 32), m ≤ (16 : BitVec 32) ∧ is_pow2 res_g m ∧ res_g < (65536 : BitVec 32) ∧ num ≤ x ∧ x - num = sqr res_g ∧ res_g + ((1 : BitVec 32) <<< BitVec.toNat m) ≤ (65536 : BitVec 32) ∧ x ≤ sqr (res_g + ((1 : BitVec 32) <<< BitVec.toNat m)) - (1 : BitVec 32) → (if ¬sqr (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) = (0 : BitVec 32) then let b : BitVec 32 := res_g * ((1 : BitVec 32) <<< BitVec.toNat m) ||| sqr (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))); if num ≥ b then BitVec.toUInt (sqr (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) >>> BitVec.toNat (2 : BitVec 32)) < BitVec.toUInt (sqr (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32)))) ∧ m - (1 : BitVec 32) ≤ (16 : BitVec 32) ∧ (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) >>> BitVec.toNat (1 : BitVec 32) = (if m - (1 : BitVec 32) = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32) - (1 : BitVec 32))) ∧ sqr (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) >>> BitVec.toNat (2 : BitVec 32) = sqr ((if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) >>> BitVec.toNat (1 : BitVec 32)) ∧ is_pow2 (res_g + (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32)))) (m - (1 : BitVec 32)) ∧ res_g + (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) < (65536 : BitVec 32) ∧ res_g * ((1 : BitVec 32) <<< BitVec.toNat m) >>> BitVec.toNat (1 : BitVec 32) ||| sqr (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) = (res_g + (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32)))) * ((1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) ∧ num - b ≤ x ∧ x - (num - b) = sqr (res_g + (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32)))) ∧ res_g + (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) + ((1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) ≤ (65536 : BitVec 32) ∧ x ≤ sqr (res_g + (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) + ((1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32)))) - (1 : BitVec 32) else BitVec.toUInt (sqr (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) >>> BitVec.toNat (2 : BitVec 32)) < BitVec.toUInt (sqr (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32)))) ∧ m - (1 : BitVec 32) ≤ (16 : BitVec 32) ∧ (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) >>> BitVec.toNat (1 : BitVec 32) = (if m - (1 : BitVec 32) = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32) - (1 : BitVec 32))) ∧ sqr (if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) >>> BitVec.toNat (2 : BitVec 32) = sqr ((if m = (0 : BitVec 32) then (0 : BitVec 32) else (1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) >>> BitVec.toNat (1 : BitVec 32)) ∧ is_pow2 res_g (m - (1 : BitVec 32)) ∧ res_g < (65536 : BitVec 32) ∧ res_g * ((1 : BitVec 32) <<< BitVec.toNat m) >>> BitVec.toNat (1 : BitVec 32) = res_g * ((1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) ∧ num ≤ x ∧ x - num = sqr res_g ∧ res_g + ((1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32))) ≤ (65536 : BitVec 32) ∧ x ≤ sqr (res_g + ((1 : BitVec 32) <<< BitVec.toNat (m - (1 : BitVec 32)))) - (1 : BitVec 32) else sqr (res_g * ((1 : BitVec 32) <<< BitVec.toNat m)) ≤ x ∧ x ≤ sqr (res_g * ((1 : BitVec 32) <<< BitVec.toNat m) + (1 : BitVec 32)) - (1 : BitVec 32)))
  := sorry
end isqrt_von_neumann_VonNeumann32_isqrt32qtvc
