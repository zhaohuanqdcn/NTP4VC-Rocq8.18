From Coq Require Import Strings.String.
From Coq Require Import String Ascii.
From Coq Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Coq Require Classical.
From Coq Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Coq Require Import Sorting.Sorted.
From Coq Require Import Reals.Rbasic_fun.
From Coq Require Import Reals.Abstract.ConstructiveAbs.
From Coq Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Coq Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Coq Require Import ZArith.Zeuclid.
From Coq Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Coq Require Import Reals.
Require Import Why3.Base.
Require Import Why3.why3.Ref.Ref.
Require Import Why3.map.Const.
Require Import Why3.map.MapEq.
Require Import Why3.mach.int.Unsigned.
Require Import Why3.mach.c.C.
Require Import multiprecision.lemmas.Lemmas.
Require Import multiprecision.types.Config.
Require Import multiprecision.types.Types.
Require Import multiprecision.types.Int32Eq.
Require Import multiprecision.types.UInt64Eq.
Require Import multiprecision.util.Util.
Require Import multiprecision.ptralias.Alias.
Require Import multiprecision.util.UtilOld.
Require Import multiprecision.compare.Compare.
Require Import multiprecision.logical.LogicalUtil.
Require Import multiprecision.logical.Logical.
Require Import multiprecision.logical.LogicalOld.
Require Import multiprecision.mpz.Z.
Require Import multiprecision.mpz.Zutil.
Open Scope Z_scope.
Theorem wmpz_mul_2exp'vc (mpz : mpz_memo) (r : mpz_ptr) (u : mpz_ptr) (cnt : bv 64%N) (fact0 : 1%Z ≤ alloc mpz r) (fact1 : 1%Z ≤ alloc mpz u) (fact2 : readers mpz r = 0%Z) (fact3 : readers mpz u = 0%Z) (fact4 : abs_size mpz u + ZEuclid.div (bv_unsigned cnt) 64%Z + 1%Z ≤ 2147483647%Z) : - 2%Z < readers mpz u ∧ (∀(un : bv 32%N), bv_signed un = abs_size mpz u -> (¬ 64%Z = 0%Z ∧ uint'64_in_bounds (Z.rem (bv_unsigned cnt) 64%Z)) ∧ (∀(o1 : bv 64%N), bv_unsigned o1 = Z.rem (bv_unsigned cnt) 64%Z -> bv_unsigned o1 ≤ 2147483647%Z ∧ (∀(limb_cnt : bv 32%N), bv_signed limb_cnt = bv_unsigned o1 -> int'32_in_bounds (bv_signed un + bv_signed limb_cnt) ∧ (∀(o2 : bv 32%N), bv_signed o2 = bv_signed un + bv_signed limb_cnt -> (∀(o3 : bool), (bv_signed un = bv_signed (0%bv : bv 32%N) -> o3 = true) ∧ (o3 = true -> un = (0%bv : bv 32%N)) -> (if decide (o3 = true) then (- 1%Z ≤ readers mpz r ∧ readers mpz r ≤ 0%Z) ∧ (∀(mpz1 : mpz_memo), alloc mpz1 = alloc mpz ∧ sgn mpz1 = sgn mpz ∧ readers mpz1 = readers mpz ∧ zones mpz1 = zones mpz -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz1 mpz) ∧ abs_size mpz1 r = 0%Z ∧ abs_value_of mpz1 r = 0%Z -> value_of r mpz1 = value_of u mpz * Z.pow 2%Z (bv_unsigned cnt) ∧ (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz1 mpz) ∧ readers mpz1 r = 0%Z ∧ readers mpz1 u = 0%Z) else int'32_in_bounds (bv_signed o2 + 1%Z) ∧ (∀(o4 : bv 32%N), bv_signed o4 = bv_signed o2 + 1%Z -> (readers mpz r = 0%Z ∧ 1%Z ≤ alloc mpz r) ∧ (∀(mpz1 : mpz_memo), sgn mpz1 = sgn mpz -> (∀(rp : C.ptr (bv 64%N)), (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz1 mpz) ∧ readers mpz1 r = - 1%Z ∧ abs_value_of mpz1 r = value rp (abs_size mpz1 r) ∧ zones mpz1 r = zone1 rp ∧ offset rp = 0%Z ∧ plength rp = alloc mpz1 r ∧ min rp = 0%Z ∧ C.max rp = plength rp ∧ writable rp = true ∧ abs_size mpz1 r = abs_size mpz r ∧ value rp (abs_size mpz r) = abs_value_of mpz r ∧ (if decide (alloc mpz r < bv_signed o4) then alloc mpz1 r = bv_signed o4 else alloc mpz1 r = alloc mpz r) -> (¬ 64%Z = 0%Z ∧ uint'64_in_bounds (Z.quot (bv_unsigned cnt) 64%Z)) ∧ (∀(c : bv 64%N), bv_unsigned c = Z.quot (bv_unsigned cnt) 64%Z -> mpz_eq u r = (u = r) -> (if decide (mpz_eq u r) then ∀(o5 : bool), (bv_unsigned c = bv_unsigned (0%bv : bv 64%N) -> o5 = true) ∧ (o5 = true -> c = (0%bv : bv 64%N)) -> (if decide (¬ o5 = true) then (min rp ≤ offset rp + bv_signed limb_cnt ∧ offset rp + bv_signed limb_cnt ≤ C.max rp) ∧ (∀(rl : C.ptr (bv 64%N)), offset rl = offset rp + bv_signed limb_cnt ∧ plength rl = plength rp ∧ pelts rl = pelts rp ∧ data rl = data rp ∧ min rl = min rp ∧ C.max rl = C.max rp ∧ zone1 rl = zone1 rp ∧ writable rl = writable rp -> ((0%Z < bv_unsigned c ∧ bv_unsigned c < 64%Z) ∧ valid rl (bv_signed un) ∧ valid rp (bv_signed un) ∧ writable rl = true ∧ 0%Z < bv_signed un ∧ (offset rp ≤ offset rl ∨ offset rl + bv_signed un ≤ offset rp)) ∧ (∀(rl1 : C.ptr (bv 64%N)) (rp1 : C.ptr (bv 64%N)), data rl1 = data rp1 ∧ length (data rp1) = length (data rl) ∧ offset rl1 = offset rl ∧ min rl1 = min rl ∧ C.max rl1 = C.max rl ∧ writable rl1 = writable rl ∧ zone1 rl1 = zone1 rl -> length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> (∀(rlimb : bv 64%N), value rl1 (bv_signed un) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed un) * bv_unsigned rlimb = value rp (bv_signed un) * Z.pow 2%Z (bv_unsigned c) ∧ (∀(j : Z), j < offset rl1 ∨ offset rl1 + bv_signed un ≤ j -> pelts rl1 j = pelts rl j) ∧ (min rl1 = min rl ∧ C.max rl1 = C.max rl ∧ plength rl1 = plength rl) ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ plength rp1 = plength rp -> ((min rp1 ≤ offset rp1 + bv_signed o2 ∧ offset rp1 + bv_signed o2 < C.max rp1) ∧ writable rp1 = true) ∧ (∀(rp2 : C.ptr (bv 64%N)), length (data rp2) = length (data rp1) ∧ offset rp2 = offset rp1 ∧ min rp2 = min rp1 ∧ C.max rp2 = C.max rp1 ∧ writable rp2 = writable rp1 ∧ zone1 rp2 = zone1 rp1 -> pelts rp2 = fun_updt (pelts rp1) (offset rp2 + bv_signed o2) rlimb ∧ pelts rp2 (offset rp2 + bv_signed o2) = rlimb -> (∀(o6 : bool), (bv_unsigned rlimb = bv_unsigned (0%bv : bv 64%N) -> o6 = true) ∧ (o6 = true -> rlimb = (0%bv : bv 64%N)) -> (∀(o7 : bv 32%N), (if decide (¬ o6 = true) then o7 = (1%bv : bv 32%N) else o7 = (0%bv : bv 32%N)) -> int'32_in_bounds (bv_signed o2 + bv_signed o7) ∧ (∀(o8 : bv 32%N), bv_signed o8 = bv_signed o2 + bv_signed o7 -> (valid rp2 (bv_signed limb_cnt) ∧ writable rp2 = true) ∧ (∀(rp3 : C.ptr (bv 64%N)), length (data rp3) = length (data rp2) ∧ offset rp3 = offset rp2 ∧ min rp3 = min rp2 ∧ C.max rp3 = C.max rp2 ∧ writable rp3 = writable rp2 ∧ zone1 rp3 = zone1 rp2 -> value rp3 (bv_signed limb_cnt) = 0%Z ∧ (∀(j : Z), j < offset rp3 ∨ offset rp3 + bv_signed limb_cnt ≤ j -> pelts rp3 j = pelts rp2 j) -> - 2%Z < readers mpz1 u ∧ (∀(o9 : bv 32%N), bv_signed o9 = sgn mpz1 u * abs_size mpz1 u -> (¬ 0%Z ≤ bv_signed o9 -> int'32_in_bounds (- bv_signed o8)) ∧ ((¬ 0%Z ≤ bv_signed o9 -> (∃(nrn : bv 32%N), bv_signed nrn = - bv_signed o8)) -> - 2%Z < readers mpz1 u ∧ (∀(o10 : bv 32%N), bv_signed o10 = sgn mpz1 u * abs_size mpz1 u -> (¬ 0%Z ≤ bv_signed o10 -> int'32_in_bounds (- bv_signed o8)) ∧ (∀(o11 : bv 32%N), (if decide (0%Z ≤ bv_signed o10) then o11 = o8 else bv_signed o11 = - bv_signed o8) -> (zones mpz1 r = zone1 rp3 ∧ readers mpz1 r = - 1%Z ∧ offset rp3 = 0%Z ∧ min rp3 = 0%Z ∧ C.max rp3 = plength rp3 ∧ Z.abs (bv_signed o11) ≤ plength rp3 ∧ plength rp3 = alloc mpz1 r ∧ (¬ bv_signed o11 = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed o11) - 1%Z) ≤ value rp3 (Z.abs (bv_signed o11)))) ∧ (∀(mpz2 : mpz_memo), alloc mpz2 = alloc mpz1 ∧ readers mpz2 = readers mpz1 ∧ zones mpz2 = zones mpz1 -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz2 mpz1) ∧ (sgn mpz2 r = 1%Z) = (0%Z ≤ bv_signed o11) ∧ (sgn mpz2 r = - 1%Z) = (bv_signed o11 < 0%Z) ∧ abs_size mpz2 r = Z.abs (bv_signed o11) ∧ abs_value_of mpz2 r = value rp3 (Z.abs (bv_signed o11)) -> (zones mpz2 r = zone1 rp3 ∧ readers mpz2 r = - 1%Z ∧ min rp3 = 0%Z ∧ C.max rp3 = plength rp3 ∧ abs_value_of mpz2 r = value rp3 (abs_size mpz2 r)) ∧ (∀(mpz3 : mpz_memo), abs_value_of mpz3 = abs_value_of mpz2 ∧ alloc mpz3 = alloc mpz2 ∧ abs_size mpz3 = abs_size mpz2 ∧ sgn mpz3 = sgn mpz2 ∧ zones mpz3 = zones mpz2 -> readers mpz3 r = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = r -> readers mpz3 y = readers mpz2 y) -> value_of r mpz3 = value_of u mpz * Z.pow 2%Z (bv_unsigned cnt) ∧ (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz3 mpz) ∧ readers mpz3 r = 0%Z ∧ readers mpz3 u = 0%Z)))))))))))))) else (valid rp (bv_signed limb_cnt) ∧ writable rp = true) ∧ (∀(rp1 : C.ptr (bv 64%N)), length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> value rp1 (bv_signed limb_cnt) = 0%Z ∧ (∀(j : Z), j < offset rp1 ∨ offset rp1 + bv_signed limb_cnt ≤ j -> pelts rp1 j = pelts rp j) -> - 2%Z < readers mpz1 u ∧ (∀(o6 : bv 32%N), bv_signed o6 = sgn mpz1 u * abs_size mpz1 u -> (¬ 0%Z ≤ bv_signed o6 -> int'32_in_bounds (- bv_signed o2)) ∧ ((¬ 0%Z ≤ bv_signed o6 -> (∃(nrn : bv 32%N), bv_signed nrn = - bv_signed o2)) -> - 2%Z < readers mpz1 u ∧ (∀(o7 : bv 32%N), bv_signed o7 = sgn mpz1 u * abs_size mpz1 u -> (¬ 0%Z ≤ bv_signed o7 -> int'32_in_bounds (- bv_signed o2)) ∧ (∀(o8 : bv 32%N), (if decide (0%Z ≤ bv_signed o7) then o8 = o2 else bv_signed o8 = - bv_signed o2) -> (zones mpz1 r = zone1 rp1 ∧ readers mpz1 r = - 1%Z ∧ offset rp1 = 0%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ Z.abs (bv_signed o8) ≤ plength rp1 ∧ plength rp1 = alloc mpz1 r ∧ (¬ bv_signed o8 = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed o8) - 1%Z) ≤ value rp1 (Z.abs (bv_signed o8)))) ∧ (∀(mpz2 : mpz_memo), alloc mpz2 = alloc mpz1 ∧ readers mpz2 = readers mpz1 ∧ zones mpz2 = zones mpz1 -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz2 mpz1) ∧ (sgn mpz2 r = 1%Z) = (0%Z ≤ bv_signed o8) ∧ (sgn mpz2 r = - 1%Z) = (bv_signed o8 < 0%Z) ∧ abs_size mpz2 r = Z.abs (bv_signed o8) ∧ abs_value_of mpz2 r = value rp1 (Z.abs (bv_signed o8)) -> (zones mpz2 r = zone1 rp1 ∧ readers mpz2 r = - 1%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ abs_value_of mpz2 r = value rp1 (abs_size mpz2 r)) ∧ (∀(mpz3 : mpz_memo), abs_value_of mpz3 = abs_value_of mpz2 ∧ alloc mpz3 = alloc mpz2 ∧ abs_size mpz3 = abs_size mpz2 ∧ sgn mpz3 = sgn mpz2 ∧ zones mpz3 = zones mpz2 -> readers mpz3 r = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = r -> readers mpz3 y = readers mpz2 y) -> value_of r mpz3 = value_of u mpz * Z.pow 2%Z (bv_unsigned cnt) ∧ (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz3 mpz) ∧ readers mpz3 r = 0%Z ∧ readers mpz3 u = 0%Z)))))))) else mpz_unchanged u mpz1 mpz ∧ (readers mpz1 u = readers mpz u ∧ (- 2%Z < readers mpz1 u -> abs_value_of mpz1 u = abs_value_of mpz u ∧ alloc mpz1 u = alloc mpz u ∧ abs_size mpz1 u = abs_size mpz u ∧ sgn mpz1 u = sgn mpz u ∧ readers mpz1 u = readers mpz u ∧ zones mpz1 u = zones mpz u) -> 0%Z ≤ readers mpz1 u ∧ (∀(mpz2 : mpz_memo), abs_value_of mpz2 = abs_value_of mpz1 ∧ alloc mpz2 = alloc mpz1 ∧ abs_size mpz2 = abs_size mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ zones mpz2 = zones mpz1 -> (∀(up : C.ptr (bv 64%N)), readers mpz2 u = readers mpz1 u + 1%Z ∧ (∀(y : mpz_ptr), ¬ u = y -> readers mpz2 y = readers mpz1 y) ∧ value up (abs_size mpz2 u) = abs_value_of mpz2 u ∧ plength up = alloc mpz2 u ∧ offset up = 0%Z ∧ min up = 0%Z ∧ C.max up = plength up ∧ zone1 up = zones mpz2 u -> (∀(o5 : bool), (bv_unsigned c = bv_unsigned (0%bv : bv 64%N) -> o5 = true) ∧ (o5 = true -> c = (0%bv : bv 64%N)) -> (if decide (¬ o5 = true) then (min rp ≤ offset rp + bv_signed limb_cnt ∧ offset rp + bv_signed limb_cnt ≤ C.max rp) ∧ (∀(rl : C.ptr (bv 64%N)), offset rl = offset rp + bv_signed limb_cnt ∧ plength rl = plength rp ∧ pelts rl = pelts rp ∧ data rl = data rp ∧ min rl = min rp ∧ C.max rl = C.max rp ∧ zone1 rl = zone1 rp ∧ writable rl = writable rp -> ((0%Z < bv_unsigned c ∧ bv_unsigned c < 64%Z) ∧ valid rl (bv_signed un) ∧ valid up (bv_signed un) ∧ writable rl = true ∧ 0%Z < bv_signed un) ∧ (∀(rl1 : C.ptr (bv 64%N)) (rp1 : C.ptr (bv 64%N)), data rl1 = data rp1 ∧ length (data rp1) = length (data rl) ∧ offset rl1 = offset rl ∧ min rl1 = min rl ∧ C.max rl1 = C.max rl ∧ writable rl1 = writable rl ∧ zone1 rl1 = zone1 rl -> length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> (∀(rlimb : bv 64%N), value rl1 (bv_signed un) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed un) * bv_unsigned rlimb = value up (bv_signed un) * Z.pow 2%Z (bv_unsigned c) -> ((min rp1 ≤ offset rp1 + bv_signed o2 ∧ offset rp1 + bv_signed o2 < C.max rp1) ∧ writable rp1 = true) ∧ (∀(rp2 : C.ptr (bv 64%N)), length (data rp2) = length (data rp1) ∧ offset rp2 = offset rp1 ∧ min rp2 = min rp1 ∧ C.max rp2 = C.max rp1 ∧ writable rp2 = writable rp1 ∧ zone1 rp2 = zone1 rp1 -> pelts rp2 = fun_updt (pelts rp1) (offset rp2 + bv_signed o2) rlimb ∧ pelts rp2 (offset rp2 + bv_signed o2) = rlimb -> (∀(o6 : bool), (bv_unsigned rlimb = bv_unsigned (0%bv : bv 64%N) -> o6 = true) ∧ (o6 = true -> rlimb = (0%bv : bv 64%N)) -> (∀(o7 : bv 32%N), (if decide (¬ o6 = true) then o7 = (1%bv : bv 32%N) else o7 = (0%bv : bv 32%N)) -> int'32_in_bounds (bv_signed o2 + bv_signed o7) ∧ (∀(o8 : bv 32%N), bv_signed o8 = bv_signed o2 + bv_signed o7 -> (zones mpz2 u = zone1 up ∧ 1%Z ≤ readers mpz2 u ∧ min up = 0%Z ∧ C.max up = plength up) ∧ (∀(mpz3 : mpz_memo), abs_value_of mpz3 = abs_value_of mpz2 ∧ alloc mpz3 = alloc mpz2 ∧ abs_size mpz3 = abs_size mpz2 ∧ sgn mpz3 = sgn mpz2 ∧ zones mpz3 = zones mpz2 -> readers mpz3 u = readers mpz2 u - 1%Z ∧ (∀(y : mpz_ptr), ¬ y = u -> readers mpz3 y = readers mpz2 y) -> (valid rp2 (bv_signed limb_cnt) ∧ writable rp2 = true) ∧ (∀(rp3 : C.ptr (bv 64%N)), length (data rp3) = length (data rp2) ∧ offset rp3 = offset rp2 ∧ min rp3 = min rp2 ∧ C.max rp3 = C.max rp2 ∧ writable rp3 = writable rp2 ∧ zone1 rp3 = zone1 rp2 -> value rp3 (bv_signed limb_cnt) = 0%Z ∧ (∀(j : Z), j < offset rp3 ∨ offset rp3 + bv_signed limb_cnt ≤ j -> pelts rp3 j = pelts rp2 j) -> - 2%Z < readers mpz3 u ∧ (∀(o9 : bv 32%N), bv_signed o9 = sgn mpz3 u * abs_size mpz3 u -> (¬ 0%Z ≤ bv_signed o9 -> int'32_in_bounds (- bv_signed o8)) ∧ ((¬ 0%Z ≤ bv_signed o9 -> (∃(nrn : bv 32%N), bv_signed nrn = - bv_signed o8)) -> - 2%Z < readers mpz3 u ∧ (∀(o10 : bv 32%N), bv_signed o10 = sgn mpz3 u * abs_size mpz3 u -> (¬ 0%Z ≤ bv_signed o10 -> int'32_in_bounds (- bv_signed o8)) ∧ (∀(o11 : bv 32%N), (if decide (0%Z ≤ bv_signed o10) then o11 = o8 else bv_signed o11 = - bv_signed o8) -> (zones mpz3 r = zone1 rp3 ∧ readers mpz3 r = - 1%Z ∧ offset rp3 = 0%Z ∧ min rp3 = 0%Z ∧ C.max rp3 = plength rp3 ∧ Z.abs (bv_signed o11) ≤ plength rp3 ∧ plength rp3 = alloc mpz3 r ∧ (¬ bv_signed o11 = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed o11) - 1%Z) ≤ value rp3 (Z.abs (bv_signed o11)))) ∧ (∀(mpz4 : mpz_memo), alloc mpz4 = alloc mpz3 ∧ readers mpz4 = readers mpz3 ∧ zones mpz4 = zones mpz3 -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz4 mpz3) ∧ (sgn mpz4 r = 1%Z) = (0%Z ≤ bv_signed o11) ∧ (sgn mpz4 r = - 1%Z) = (bv_signed o11 < 0%Z) ∧ abs_size mpz4 r = Z.abs (bv_signed o11) ∧ abs_value_of mpz4 r = value rp3 (Z.abs (bv_signed o11)) -> (zones mpz4 r = zone1 rp3 ∧ readers mpz4 r = - 1%Z ∧ min rp3 = 0%Z ∧ C.max rp3 = plength rp3 ∧ abs_value_of mpz4 r = value rp3 (abs_size mpz4 r)) ∧ (∀(mpz5 : mpz_memo), abs_value_of mpz5 = abs_value_of mpz4 ∧ alloc mpz5 = alloc mpz4 ∧ abs_size mpz5 = abs_size mpz4 ∧ sgn mpz5 = sgn mpz4 ∧ zones mpz5 = zones mpz4 -> readers mpz5 r = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = r -> readers mpz5 y = readers mpz4 y) -> value_of r mpz5 = value_of u mpz * Z.pow 2%Z (bv_unsigned cnt) ∧ (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz5 mpz) ∧ readers mpz5 r = 0%Z ∧ readers mpz5 u = 0%Z))))))))))))))) else (min rp ≤ offset rp + bv_signed limb_cnt ∧ offset rp + bv_signed limb_cnt ≤ C.max rp) ∧ (∀(rl : C.ptr (bv 64%N)), offset rl = offset rp + bv_signed limb_cnt ∧ plength rl = plength rp ∧ pelts rl = pelts rp ∧ data rl = data rp ∧ min rl = min rp ∧ C.max rl = C.max rp ∧ zone1 rl = zone1 rp ∧ writable rl = writable rp -> (valid up (bv_signed un) ∧ valid rl (bv_signed un) ∧ writable rl = true) ∧ (∀(rl1 : C.ptr (bv 64%N)) (rp1 : C.ptr (bv 64%N)), data rl1 = data rp1 ∧ length (data rp1) = length (data rl) ∧ offset rl1 = offset rl ∧ min rl1 = min rl ∧ C.max rl1 = C.max rl ∧ writable rl1 = writable rl ∧ zone1 rl1 = zone1 rl -> length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> map_eq_sub_shift (pelts rl1) (pelts up) (offset rl1) (offset up) (bv_signed un) ∧ (∀(j : Z), j < offset rl1 ∨ offset rl1 + bv_signed un ≤ j -> pelts rl1 j = pelts rl j) -> (zones mpz2 u = zone1 up ∧ 1%Z ≤ readers mpz2 u ∧ min up = 0%Z ∧ C.max up = plength up) ∧ (∀(mpz3 : mpz_memo), abs_value_of mpz3 = abs_value_of mpz2 ∧ alloc mpz3 = alloc mpz2 ∧ abs_size mpz3 = abs_size mpz2 ∧ sgn mpz3 = sgn mpz2 ∧ zones mpz3 = zones mpz2 -> readers mpz3 u = readers mpz2 u - 1%Z ∧ (∀(y : mpz_ptr), ¬ y = u -> readers mpz3 y = readers mpz2 y) -> (valid rp1 (bv_signed limb_cnt) ∧ writable rp1 = true) ∧ (∀(rp2 : C.ptr (bv 64%N)), length (data rp2) = length (data rp1) ∧ offset rp2 = offset rp1 ∧ min rp2 = min rp1 ∧ C.max rp2 = C.max rp1 ∧ writable rp2 = writable rp1 ∧ zone1 rp2 = zone1 rp1 -> value rp2 (bv_signed limb_cnt) = 0%Z ∧ (∀(j : Z), j < offset rp2 ∨ offset rp2 + bv_signed limb_cnt ≤ j -> pelts rp2 j = pelts rp1 j) -> - 2%Z < readers mpz3 u ∧ (∀(o6 : bv 32%N), bv_signed o6 = sgn mpz3 u * abs_size mpz3 u -> (¬ 0%Z ≤ bv_signed o6 -> int'32_in_bounds (- bv_signed o2)) ∧ ((¬ 0%Z ≤ bv_signed o6 -> (∃(nrn : bv 32%N), bv_signed nrn = - bv_signed o2)) -> - 2%Z < readers mpz3 u ∧ (∀(o7 : bv 32%N), bv_signed o7 = sgn mpz3 u * abs_size mpz3 u -> (¬ 0%Z ≤ bv_signed o7 -> int'32_in_bounds (- bv_signed o2)) ∧ (∀(o8 : bv 32%N), (if decide (0%Z ≤ bv_signed o7) then o8 = o2 else bv_signed o8 = - bv_signed o2) -> (zones mpz3 r = zone1 rp2 ∧ readers mpz3 r = - 1%Z ∧ offset rp2 = 0%Z ∧ min rp2 = 0%Z ∧ C.max rp2 = plength rp2 ∧ Z.abs (bv_signed o8) ≤ plength rp2 ∧ plength rp2 = alloc mpz3 r ∧ (¬ bv_signed o8 = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed o8) - 1%Z) ≤ value rp2 (Z.abs (bv_signed o8)))) ∧ (∀(mpz4 : mpz_memo), alloc mpz4 = alloc mpz3 ∧ readers mpz4 = readers mpz3 ∧ zones mpz4 = zones mpz3 -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz4 mpz3) ∧ (sgn mpz4 r = 1%Z) = (0%Z ≤ bv_signed o8) ∧ (sgn mpz4 r = - 1%Z) = (bv_signed o8 < 0%Z) ∧ abs_size mpz4 r = Z.abs (bv_signed o8) ∧ abs_value_of mpz4 r = value rp2 (Z.abs (bv_signed o8)) -> (zones mpz4 r = zone1 rp2 ∧ readers mpz4 r = - 1%Z ∧ min rp2 = 0%Z ∧ C.max rp2 = plength rp2 ∧ abs_value_of mpz4 r = value rp2 (abs_size mpz4 r)) ∧ (∀(mpz5 : mpz_memo), abs_value_of mpz5 = abs_value_of mpz4 ∧ alloc mpz5 = alloc mpz4 ∧ abs_size mpz5 = abs_size mpz4 ∧ sgn mpz5 = sgn mpz4 ∧ zones mpz5 = zones mpz4 -> readers mpz5 r = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = r -> readers mpz5 y = readers mpz4 y) -> value_of r mpz5 = value_of u mpz * Z.pow 2%Z (bv_unsigned cnt) ∧ (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz5 mpz) ∧ readers mpz5 r = 0%Z ∧ readers mpz5 u = 0%Z)))))))))))))))))))))))))).
Proof.
Admitted.
