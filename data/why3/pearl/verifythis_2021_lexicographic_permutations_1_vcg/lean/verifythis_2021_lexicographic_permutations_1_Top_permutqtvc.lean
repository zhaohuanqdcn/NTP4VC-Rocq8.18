import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
open Classical
open Lean4Why3
namespace verifythis_2021_lexicographic_permutations_1_Top_permutqtvc
axiom elt : Type
axiom inhabited_axiom_elt : Inhabited elt
attribute [instance] inhabited_axiom_elt
axiom permutation : Type
axiom inhabited_axiom_permutation : Inhabited permutation
attribute [instance] inhabited_axiom_permutation
noncomputable def lt (p : List ℤ) (q : List ℤ) := (List.length p = List.length q ∧ (0 : ℤ) < Int.ofNat (List.length q)) ∧ (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length p)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → p[Int.toNat j]! = q[Int.toNat j]!) ∧ p[Int.toNat i]! < q[Int.toNat i]!)
axiom iseq :  {α : Type} -> [Inhabited α] -> α -> List α -> ℤ -> Bool
axiom iseq'def {α : Type} [Inhabited α] (x : α) (s : List α) (i : ℤ) : (iseq x s i = true) = (s[Int.toNat i]! = x)
noncomputable def occ {α : Type} [Inhabited α] (x : α) (s : List α) (l : ℤ) (u : ℤ) := NumOf.numof (iseq x s) l u
noncomputable def occ_all {α : Type} [Inhabited α] (x : α) (s : List α) := occ x s (0 : ℤ) (Int.ofNat (List.length s))
noncomputable def is_permutation_of (p : List ℤ) (a : List ℤ) := List.length p = List.length a ∧ (∀(x : ℤ), occ_all x p = occ_all x a)
noncomputable def descending (s : List ℤ) (lo : ℤ) (hi : ℤ) := ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ Int.ofNat (List.length s)) ∧ (∀(i : ℤ) (j : ℤ), lo ≤ i ∧ i ≤ j ∧ j < hi → s[Int.toNat j]! ≤ s[Int.toNat i]!)
noncomputable def ascending (s : List ℤ) (lo : ℤ) (hi : ℤ) := ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ Int.ofNat (List.length s)) ∧ (∀(i : ℤ) (j : ℤ), lo ≤ i ∧ i ≤ j ∧ j < hi → s[Int.toNat i]! ≤ s[Int.toNat j]!)
axiom to_seq : List ℤ -> List ℤ
axiom to_seq'spec'0 (a : List ℤ) : List.length (to_seq a) = List.length a
axiom to_seq'spec (i : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ i) (fact1 : i < Int.ofNat (List.length (to_seq a))) : (to_seq a)[Int.toNat i]! = a[Int.toNat i]!
axiom all_permutations : List ℤ -> Finset (List ℤ)
axiom all_permutations'spec (p : List ℤ) (s : List ℤ) (fact0 : is_permutation_of p s) : p ∈ all_permutations s
theorem permut'vc (a : List ℤ) : let a0 : List ℤ := to_seq a; List.length a0 = List.length a ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a0) → a0[Int.toNat i]! = a[Int.toNat i]!) → (let all1 : Finset (List ℤ) := all_permutations a0; (∀(p : List ℤ), is_permutation_of p a0 → p ∈ all1) → (∀(a1 : List ℤ), List.length a1 = List.length a → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ j ∧ j < Int.ofNat (List.length a1) → a1[Int.toNat i]! ≤ a1[Int.toNat j]!) ∧ is_permutation_of (to_seq a1) (to_seq a) → (let o1 : List ℤ := to_seq a1; List.length o1 = List.length a1 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o1) → o1[Int.toNat i]! = a1[Int.toNat i]!) → (let o2 : List (List ℤ) := ([] : List (List ℤ)); let o3 : List (List ℤ) := o2 ++ [o1]; Int.ofNat (List.length o3) = (1 : ℤ) + Int.ofNat (List.length o2) ∧ o3[List.length o2]! = o1 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o2) → o3[Int.toNat i]! = o2[Int.toNat i]!) → (let o4 : List ℤ := to_seq a1; List.length o4 = List.length a1 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o4) → o4[Int.toNat i]! = a1[Int.toNat i]!) → (let o5 : List ℤ := to_seq a1; List.length o5 = List.length a1 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o5) → o5[Int.toNat i]! = a1[Int.toNat i]!) → (let o6 : Finset (List ℤ) := insert o5 (∅ : Finset (List ℤ)); ((0 : ℤ) < Int.ofNat (List.length o3) ∧ is_permutation_of (to_seq a1) a0 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o3) → is_permutation_of (o3[Int.toNat i]!) a0) ∧ (o4 = o3[Int.toNat (Int.ofNat (List.length o3) - (1 : ℤ))]! ∧ o3[Int.toNat (Int.ofNat (List.length o3) - (1 : ℤ))]! = to_seq a1) ∧ is_permutation_of o4 a0 ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length o3) → lt (o3[Int.toNat i]!) (o3[Int.toNat j]!)) ∧ (∀(p : List ℤ), is_permutation_of p a0 → lt p o4 → (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o3) - (1 : ℤ)) ∧ o3[Int.toNat i]! = p)) ∧ (∀(p : List ℤ), (p ∈ o6) = (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o3)) ∧ o3[Int.toNat i]! = p)) ∧ o6 ⊆ all1) ∧ (∀(sresult : Finset (List ℤ)) (result : List (List ℤ)) (a2 : List ℤ), List.length a2 = List.length a1 → (0 : ℤ) < Int.ofNat (List.length result) ∧ is_permutation_of (to_seq a2) a0 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length result) → is_permutation_of (result[Int.toNat i]!) a0) ∧ result[Int.toNat (Int.ofNat (List.length result) - (1 : ℤ))]! = to_seq a2 ∧ is_permutation_of (result[Int.toNat (Int.ofNat (List.length result) - (1 : ℤ))]!) a0 ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length result) → lt (result[Int.toNat i]!) (result[Int.toNat j]!)) ∧ (∀(p : List ℤ), is_permutation_of p a0 → lt p (result[Int.toNat (Int.ofNat (List.length result) - (1 : ℤ))]!) → (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length result) - (1 : ℤ)) ∧ result[Int.toNat i]! = p)) ∧ (∀(p : List ℤ), (p ∈ sresult) = (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length result)) ∧ result[Int.toNat i]! = p)) ∧ sresult ⊆ all1 → (List.length a2 = List.length a0 ∧ is_permutation_of (to_seq a2) a0) ∧ (∀(a3 : List ℤ), List.length a3 = List.length a2 → (∀(o7 : Bool), is_permutation_of (to_seq a3) a0 ∧ (¬o7 = true → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a3) → a3[Int.toNat i]! = a2[Int.toNat i]!)) ∧ (¬o7 = true → (∀(p : List ℤ), is_permutation_of p a0 → ¬lt (to_seq a3) p)) ∧ (o7 = true → lt (to_seq a2) (to_seq a3)) ∧ (o7 = true → (∀(p : List ℤ), is_permutation_of p a0 → ¬(lt (to_seq a2) p ∧ lt p (to_seq a3)))) → (if o7 = true then let o8 : List ℤ := to_seq a3; List.length o8 = List.length a3 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o8) → o8[Int.toNat i]! = a3[Int.toNat i]!) → (let o9 : List (List ℤ) := result ++ [o8]; Int.ofNat (List.length o9) = (1 : ℤ) + Int.ofNat (List.length result) ∧ o9[List.length result]! = o8 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length result) → o9[Int.toNat i]! = result[Int.toNat i]!) → (let o10 : List ℤ := to_seq a3; List.length o10 = List.length a3 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o10) → o10[Int.toNat i]! = a3[Int.toNat i]!) → (let o11 : List ℤ := to_seq a3; List.length o11 = List.length a3 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o11) → o11[Int.toNat i]! = a3[Int.toNat i]!) → ((0 : ℤ) ≤ Int.ofNat (Finset.card all1) - Int.ofNat (Finset.card sresult) ∧ Int.ofNat (Finset.card all1) - Int.ofNat (Finset.card (insert o11 sresult)) < Int.ofNat (Finset.card all1) - Int.ofNat (Finset.card sresult)) ∧ (0 : ℤ) < Int.ofNat (List.length o9) ∧ is_permutation_of (to_seq a3) a0 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o9) → is_permutation_of (o9[Int.toNat i]!) a0) ∧ (o10 = o9[Int.toNat (Int.ofNat (List.length o9) - (1 : ℤ))]! ∧ o9[Int.toNat (Int.ofNat (List.length o9) - (1 : ℤ))]! = to_seq a3) ∧ is_permutation_of o10 a0 ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length o9) → lt (o9[Int.toNat i]!) (o9[Int.toNat j]!)) ∧ (∀(p : List ℤ), is_permutation_of p a0 → lt p o10 → (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o9) - (1 : ℤ)) ∧ o9[Int.toNat i]! = p)) ∧ (∀(p : List ℤ), (p ∈ insert o11 sresult) = (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o9)) ∧ o9[Int.toNat i]! = p)) ∧ insert o11 sresult ⊆ all1))) else (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length result) → is_permutation_of (result[Int.toNat i]!) (to_seq a)) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length result) → lt (result[Int.toNat i]!) (result[Int.toNat j]!)) ∧ (∀(p : List ℤ), is_permutation_of p (to_seq a) → (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length result)) ∧ result[Int.toNat i]! = p)))))))))))))
  := sorry
end verifythis_2021_lexicographic_permutations_1_Top_permutqtvc
