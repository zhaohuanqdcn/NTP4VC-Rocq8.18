import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace space_saving_Top_space_saving_2qtvc
axiom elt : Type
axiom inhabited_axiom_elt : Inhabited elt
attribute [instance] inhabited_axiom_elt
axiom dummy : elt
theorem space_saving_2'vc (s : ℤ -> elt) : (0 : ℤ) + (0 : ℤ) = (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ dummy s (0 : ℤ) (0 : ℤ)) ∧ Int.ofNat (Lean4Why3.map_occ dummy s (0 : ℤ) (0 : ℤ)) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ dummy s (0 : ℤ) (0 : ℤ)) ∧ Int.ofNat (Lean4Why3.map_occ dummy s (0 : ℤ) (0 : ℤ)) ≤ (0 : ℤ) ∧ ((0 : ℤ) < (0 : ℤ) → ¬(0 : ℤ) < (0 : ℤ)) ∧ (∀(y : elt), ¬y = dummy → ¬y = dummy → Int.ofNat (Lean4Why3.map_occ y s (0 : ℤ) (0 : ℤ)) ≤ min (0 : ℤ) (0 : ℤ)) ∧ (∀(n2 : ℤ) (x2 : elt) (n1 : ℤ) (x1 : elt), (0 : ℤ) ≤ n1 + n2 ∧ ((0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ x1 s (0 : ℤ) (n1 + n2)) ∧ Int.ofNat (Lean4Why3.map_occ x1 s (0 : ℤ) (n1 + n2)) ≤ n1) ∧ ((0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ x2 s (0 : ℤ) (n1 + n2)) ∧ Int.ofNat (Lean4Why3.map_occ x2 s (0 : ℤ) (n1 + n2)) ≤ n2) ∧ (if n1 = (0 : ℤ) then x1 = dummy else ¬x1 = dummy) ∧ (if n2 = (0 : ℤ) then x2 = dummy else ¬x2 = dummy) ∧ ((0 : ℤ) < n1 → (0 : ℤ) < n2 → ¬x1 = x2) ∧ (∀(y : elt), ¬y = x1 → ¬y = x2 → Int.ofNat (Lean4Why3.map_occ y s (0 : ℤ) (n1 + n2)) ≤ min n1 n2) → (0 : ℤ) ≤ n1 + n2 ∧ (¬s (n1 + n2) = dummy → (if s (n1 + n2) = x1 then (n1 + (1 : ℤ) + n2 = n1 + n2 + (1 : ℤ) ∧ (0 : ℤ) ≤ n1 + n2 + (1 : ℤ)) ∧ ((0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ x1 s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ∧ Int.ofNat (Lean4Why3.map_occ x1 s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ≤ n1 + (1 : ℤ)) ∧ ((0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ x2 s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ∧ Int.ofNat (Lean4Why3.map_occ x2 s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ≤ n2) ∧ (if n1 + (1 : ℤ) = (0 : ℤ) then x1 = dummy else ¬x1 = dummy) ∧ (if n2 = (0 : ℤ) then x2 = dummy else ¬x2 = dummy) ∧ ((0 : ℤ) < n1 + (1 : ℤ) → (0 : ℤ) < n2 → ¬x1 = x2) ∧ (∀(y : elt), ¬y = x1 → ¬y = x2 → Int.ofNat (Lean4Why3.map_occ y s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ≤ min (n1 + (1 : ℤ)) n2) else if s (n1 + n2) = x2 then (n1 + (n2 + (1 : ℤ)) = n1 + n2 + (1 : ℤ) ∧ (0 : ℤ) ≤ n1 + n2 + (1 : ℤ)) ∧ ((0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ x1 s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ∧ Int.ofNat (Lean4Why3.map_occ x1 s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ≤ n1) ∧ ((0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ x2 s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ∧ Int.ofNat (Lean4Why3.map_occ x2 s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ≤ n2 + (1 : ℤ)) ∧ (if n1 = (0 : ℤ) then x1 = dummy else ¬x1 = dummy) ∧ (if n2 + (1 : ℤ) = (0 : ℤ) then x2 = dummy else ¬x2 = dummy) ∧ ((0 : ℤ) < n1 → (0 : ℤ) < n2 + (1 : ℤ) → ¬x1 = x2) ∧ (∀(y : elt), ¬y = x1 → ¬y = x2 → Int.ofNat (Lean4Why3.map_occ y s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ≤ min n1 (n2 + (1 : ℤ))) else if n1 ≤ n2 then (n1 + (1 : ℤ) + n2 = n1 + n2 + (1 : ℤ) ∧ (0 : ℤ) ≤ n1 + n2 + (1 : ℤ)) ∧ ((0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ (s (n1 + n2)) s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ∧ Int.ofNat (Lean4Why3.map_occ (s (n1 + n2)) s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ≤ n1 + (1 : ℤ)) ∧ ((0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ x2 s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ∧ Int.ofNat (Lean4Why3.map_occ x2 s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ≤ n2) ∧ (if n1 + (1 : ℤ) = (0 : ℤ) then s (n1 + n2) = dummy else ¬s (n1 + n2) = dummy) ∧ (if n2 = (0 : ℤ) then x2 = dummy else ¬x2 = dummy) ∧ ((0 : ℤ) < n1 + (1 : ℤ) → (0 : ℤ) < n2 → ¬s (n1 + n2) = x2) ∧ (∀(y : elt), ¬y = s (n1 + n2) → ¬y = x2 → Int.ofNat (Lean4Why3.map_occ y s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ≤ min (n1 + (1 : ℤ)) n2) else (n1 + (n2 + (1 : ℤ)) = n1 + n2 + (1 : ℤ) ∧ (0 : ℤ) ≤ n1 + n2 + (1 : ℤ)) ∧ ((0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ x1 s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ∧ Int.ofNat (Lean4Why3.map_occ x1 s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ≤ n1) ∧ ((0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ (s (n1 + n2)) s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ∧ Int.ofNat (Lean4Why3.map_occ (s (n1 + n2)) s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ≤ n2 + (1 : ℤ)) ∧ (if n1 = (0 : ℤ) then x1 = dummy else ¬x1 = dummy) ∧ (if n2 + (1 : ℤ) = (0 : ℤ) then s (n1 + n2) = dummy else ¬s (n1 + n2) = dummy) ∧ ((0 : ℤ) < n1 → (0 : ℤ) < n2 + (1 : ℤ) → ¬x1 = s (n1 + n2)) ∧ (∀(y : elt), ¬y = x1 → ¬y = s (n1 + n2) → Int.ofNat (Lean4Why3.map_occ y s (0 : ℤ) (n1 + n2 + (1 : ℤ))) ≤ min n1 (n2 + (1 : ℤ))))))
  := sorry
end space_saving_Top_space_saving_2qtvc
