theory verifythis_2017_odd_even_transposition_sort_Challenge3_odd_even_transposition_sortqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_NumOf" "Why3STD.int_Sum" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut" "Why3STD.array_IntArraySorted" "Why3STD.array_Inversions"
begin
definition odd_sorted :: "int list \<Rightarrow> int \<Rightarrow> _"
  where "odd_sorted a n \<longleftrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<longrightarrow> (2 :: int) * i + (2 :: int) < n \<longrightarrow> a ! nat ((2 :: int) * i + (1 :: int)) \<le> a ! nat ((2 :: int) * i + (2 :: int)))" for a n
definition even_sorted :: "int list \<Rightarrow> int \<Rightarrow> _"
  where "even_sorted a n \<longleftrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<longrightarrow> (2 :: int) * i + (1 :: int) < n \<longrightarrow> a ! nat ((2 :: int) * i) \<le> a ! nat ((2 :: int) * i + (1 :: int)))" for a n
theorem odd_even_transposition_sort'vc:
  fixes a :: "int list"
  shows "a <~~> a"
  and "\<forall>(is_sorted :: bool) (a1 :: int list). length a1 = length a \<longrightarrow> a <~~> a1 \<and> (is_sorted = True \<longrightarrow> array_IntArraySorted.sorted a1) \<longrightarrow> (if \<not>is_sorted = True then (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (1 :: int) \<and> (1 :: int) = (2 :: int) * (0 :: int) + (1 :: int)) \<and> a <~~> a1 \<and> odd_sorted a1 (1 :: int) \<and> (\<not>True \<longrightarrow> inversions a1 < inversions a1)) \<and> (\<forall>(half_i :: int) (is_sorted1 :: bool) (a2 :: int list). length a2 = length a1 \<longrightarrow> ((0 :: int) \<le> half_i \<and> (0 :: int) \<le> (2 :: int) * half_i + (1 :: int)) \<and> a <~~> a2 \<and> odd_sorted a2 ((2 :: int) * half_i + (1 :: int)) \<and> (if is_sorted1 = True then inversions a2 = inversions a1 else inversions a2 < inversions a1) \<longrightarrow> (if (2 :: int) * half_i + (1 :: int) < int (length a2) - (1 :: int) then let o1 :: int = (2 :: int) * half_i + (1 :: int) + (1 :: int) in ((0 :: int) \<le> o1 \<and> o1 < int (length a2)) \<and> ((0 :: int) \<le> (2 :: int) * half_i + (1 :: int) \<and> (2 :: int) * half_i + (1 :: int) < int (length a2)) \<and> (if a2 ! nat o1 < a2 ! nat ((2 :: int) * half_i + (1 :: int)) then let o2 :: int = (2 :: int) * half_i + (1 :: int) + (1 :: int) in (((0 :: int) \<le> (2 :: int) * half_i + (1 :: int) \<and> (2 :: int) * half_i + (1 :: int) < int (length a2)) \<and> (0 :: int) \<le> o2 \<and> o2 < int (length a2)) \<and> (\<forall>(a3 :: int list). length a3 = length a2 \<longrightarrow> list_exchange a2 a3 ((2 :: int) * half_i + (1 :: int)) o2 \<longrightarrow> ((0 :: int) \<le> int (length a2) - ((2 :: int) * half_i + (1 :: int)) \<and> int (length a3) - ((2 :: int) * half_i + (1 :: int) + (2 :: int)) < int (length a2) - ((2 :: int) * half_i + (1 :: int))) \<and> ((0 :: int) \<le> half_i + (1 :: int) \<and> (0 :: int) \<le> (2 :: int) * half_i + (1 :: int) + (2 :: int) \<and> (2 :: int) * half_i + (1 :: int) + (2 :: int) = (2 :: int) * (half_i + (1 :: int)) + (1 :: int)) \<and> a <~~> a3 \<and> odd_sorted a3 ((2 :: int) * half_i + (1 :: int) + (2 :: int)) \<and> (if False = True then inversions a3 = inversions a1 else inversions a3 < inversions a1)) else ((0 :: int) \<le> int (length a2) - ((2 :: int) * half_i + (1 :: int)) \<and> int (length a2) - ((2 :: int) * half_i + (1 :: int) + (2 :: int)) < int (length a2) - ((2 :: int) * half_i + (1 :: int))) \<and> ((0 :: int) \<le> half_i + (1 :: int) \<and> (0 :: int) \<le> (2 :: int) * half_i + (1 :: int) + (2 :: int) \<and> (2 :: int) * half_i + (1 :: int) + (2 :: int) = (2 :: int) * (half_i + (1 :: int)) + (1 :: int)) \<and> a <~~> a2 \<and> odd_sorted a2 ((2 :: int) * half_i + (1 :: int) + (2 :: int)) \<and> (if is_sorted1 = True then inversions a2 = inversions a1 else inversions a2 < inversions a1)) else (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) = (2 :: int) * (0 :: int)) \<and> (0 :: int) \<le> (0 :: int) \<and> a <~~> a2 \<and> (is_sorted1 = True \<longrightarrow> odd_sorted a2 (int (length a2))) \<and> even_sorted a2 (0 :: int) \<and> (if is_sorted1 = True then inversions a2 = inversions a1 else inversions a2 < inversions a1) \<and> (is_sorted1 = True \<or> inversions a2 < inversions a1)) \<and> (\<forall>(half_i1 :: int) (is_sorted2 :: bool) (a3 :: int list). length a3 = length a2 \<longrightarrow> ((0 :: int) \<le> half_i1 \<and> (0 :: int) \<le> (2 :: int) * half_i1) \<and> (0 :: int) \<le> (2 :: int) * half_i1 \<and> a <~~> a3 \<and> (is_sorted2 = True \<longrightarrow> odd_sorted a3 (int (length a3))) \<and> even_sorted a3 ((2 :: int) * half_i1) \<and> (if is_sorted2 = True then inversions a3 = inversions a1 else inversions a3 < inversions a1) \<and> (is_sorted2 = True \<or> inversions a3 < inversions a1) \<longrightarrow> (if (2 :: int) * half_i1 < int (length a3) - (1 :: int) then let o1 :: int = (2 :: int) * half_i1 + (1 :: int) in ((0 :: int) \<le> o1 \<and> o1 < int (length a3)) \<and> ((0 :: int) \<le> (2 :: int) * half_i1 \<and> (2 :: int) * half_i1 < int (length a3)) \<and> (if a3 ! nat o1 < a3 ! nat ((2 :: int) * half_i1) then let o2 :: int = (2 :: int) * half_i1 + (1 :: int) in (((0 :: int) \<le> (2 :: int) * half_i1 \<and> (2 :: int) * half_i1 < int (length a3)) \<and> (0 :: int) \<le> o2 \<and> o2 < int (length a3)) \<and> (\<forall>(a4 :: int list). length a4 = length a3 \<longrightarrow> list_exchange a3 a4 ((2 :: int) * half_i1) o2 \<longrightarrow> ((0 :: int) \<le> int (length a3) - (2 :: int) * half_i1 \<and> int (length a4) - ((2 :: int) * half_i1 + (2 :: int)) < int (length a3) - (2 :: int) * half_i1) \<and> ((0 :: int) \<le> half_i1 + (1 :: int) \<and> (0 :: int) \<le> (2 :: int) * half_i1 + (2 :: int) \<and> (2 :: int) * half_i1 + (2 :: int) = (2 :: int) * (half_i1 + (1 :: int))) \<and> (0 :: int) \<le> (2 :: int) * half_i1 + (2 :: int) \<and> a <~~> a4 \<and> (False = True \<longrightarrow> odd_sorted a4 (int (length a4))) \<and> even_sorted a4 ((2 :: int) * half_i1 + (2 :: int)) \<and> (if False = True then inversions a4 = inversions a1 else inversions a4 < inversions a1) \<and> (False = True \<or> inversions a4 < inversions a1)) else ((0 :: int) \<le> int (length a3) - (2 :: int) * half_i1 \<and> int (length a3) - ((2 :: int) * half_i1 + (2 :: int)) < int (length a3) - (2 :: int) * half_i1) \<and> ((0 :: int) \<le> half_i1 + (1 :: int) \<and> (0 :: int) \<le> (2 :: int) * half_i1 + (2 :: int) \<and> (2 :: int) * half_i1 + (2 :: int) = (2 :: int) * (half_i1 + (1 :: int))) \<and> (0 :: int) \<le> (2 :: int) * half_i1 + (2 :: int) \<and> a <~~> a3 \<and> (is_sorted2 = True \<longrightarrow> odd_sorted a3 (int (length a3))) \<and> even_sorted a3 ((2 :: int) * half_i1 + (2 :: int)) \<and> (if is_sorted2 = True then inversions a3 = inversions a1 else inversions a3 < inversions a1) \<and> (is_sorted2 = True \<or> inversions a3 < inversions a1)) else ((0 :: int) \<le> (if is_sorted = True then 0 :: int else (1 :: int)) \<and> (if is_sorted2 = True then 0 :: int else (1 :: int)) < (if is_sorted = True then 0 :: int else (1 :: int)) \<or> (if is_sorted = True then 0 :: int else (1 :: int)) = (if is_sorted2 = True then 0 :: int else (1 :: int)) \<and> (0 :: int) \<le> inversions a1 \<and> inversions a3 < inversions a1) \<and> a <~~> a3 \<and> (is_sorted2 = True \<longrightarrow> array_IntArraySorted.sorted a3))))) else array_IntArraySorted.sorted a1 \<and> a <~~> a1)"
  sorry
end
