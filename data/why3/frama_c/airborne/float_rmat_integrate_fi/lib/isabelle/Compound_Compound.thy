theory Compound_Compound
  imports "NTP4Verif.NTP4Verif" "Why3STD.Qed_Qed" "Why3STD.Memory_Memory" "../../lib/isabelle/S5_FloatRMat_S5_FloatRMat"
begin
consts array1_float :: "addr \<Rightarrow> int \<Rightarrow> (addr \<Rightarrow> real) \<Rightarrow> int \<Rightarrow> real"
definition load_s5_floatrmat :: "addr \<Rightarrow> (addr \<Rightarrow> real) \<Rightarrow> s5_floatrmat"
  where "load_s5_floatrmat p mflt_0 = s5_floatrmat'mk (array1_float (shift p (0 :: int)) (9 :: int) mflt_0)" for p mflt_0
axiomatization where Q_Array1_float_access:   "array1_float p n mflt_0 i = mflt_0 (shift p i)"
 if "(0 :: int) \<le> i"
 and "i < n"
  for i :: "int"
  and n :: "int"
  and p :: "addr"
  and mflt_0 :: "addr \<Rightarrow> real"
axiomatization where Q_Array1_float_update_Mflt:   "array1_float p n (mflt_0(q := v)) = array1_float p n mflt_0"
 if "separated p n q (1 :: int)"
  for p :: "addr"
  and n :: "int"
  and q :: "addr"
  and mflt_0 :: "addr \<Rightarrow> real"
  and v :: "real"
axiomatization where Q_Array1_float_eqmem_Mflt:   "array1_float p n mflt_1 = array1_float p n mflt_0"
 if "included p n q k"
 and "eqmem mflt_0 mflt_1 q k"
  for p :: "addr"
  and n :: "int"
  and q :: "addr"
  and k :: "int"
  and mflt_0 :: "addr \<Rightarrow> real"
  and mflt_1 :: "addr \<Rightarrow> real"
axiomatization where Q_Array1_float_havoc_Mflt:   "array1_float p n mflt_1 = array1_float p n mflt_0"
 if "havoc mflt_2 mflt_0 q k = mflt_1"
 and "separated p n q k"
  for mflt_2 :: "addr \<Rightarrow> real"
  and mflt_0 :: "addr \<Rightarrow> real"
  and q :: "addr"
  and k :: "int"
  and mflt_1 :: "addr \<Rightarrow> real"
  and p :: "addr"
  and n :: "int"
axiomatization where Q_Load_S5_FloatRMat_update_Mflt:   "load_s5_floatrmat p (mflt_0(q := v)) = load_s5_floatrmat p mflt_0"
 if "separated p (9 :: int) q (1 :: int)"
  for p :: "addr"
  and q :: "addr"
  and mflt_0 :: "addr \<Rightarrow> real"
  and v :: "real"
axiomatization where Q_Load_S5_FloatRMat_eqmem_Mflt:   "load_s5_floatrmat p mflt_1 = load_s5_floatrmat p mflt_0"
 if "included p (9 :: int) q k"
 and "eqmem mflt_0 mflt_1 q k"
  for p :: "addr"
  and q :: "addr"
  and k :: "int"
  and mflt_0 :: "addr \<Rightarrow> real"
  and mflt_1 :: "addr \<Rightarrow> real"
axiomatization where Q_Load_S5_FloatRMat_havoc_Mflt:   "load_s5_floatrmat p mflt_1 = load_s5_floatrmat p mflt_0"
 if "havoc mflt_2 mflt_0 q k = mflt_1"
 and "separated p (9 :: int) q k"
  for mflt_2 :: "addr \<Rightarrow> real"
  and mflt_0 :: "addr \<Rightarrow> real"
  and q :: "addr"
  and k :: "int"
  and mflt_1 :: "addr \<Rightarrow> real"
  and p :: "addr"
end
