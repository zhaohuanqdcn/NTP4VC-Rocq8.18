theory powm_Powm_redcifyqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.c_C" "mach.int_Unsigned" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/sub_1_Sub_1"
begin
definition redc :: "int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "redc ur u n m \<longleftrightarrow> ur emod m = ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i n * u emod m" for ur u n m
theorem redcify'vc:
  fixes rp :: "64 word ptr"
  fixes n :: "32 word"
  fixes up :: "64 word ptr"
  fixes un :: "32 word"
  fixes mp :: "64 word ptr"
  assumes fact0: "valid rp (sint n)"
  assumes fact1: "valid up (sint un)"
  assumes fact2: "valid mp (sint n)"
  assumes fact3: "(1 :: int) \<le> sint n"
  assumes fact4: "(1 :: int) \<le> sint un"
  assumes fact5: "sint un + sint n < (2147483647 :: int)"
  assumes fact6: "(0 :: int) < uint (pelts mp (offset mp + sint n - (1 :: int)))"
  assumes fact7: "writable rp = True"
  shows "int'32_in_bounds (sint un + sint n)"
  and "\<forall>(o1 :: 32 word). sint o1 = sint un + sint n \<longrightarrow> (0 :: int) \<le> sint o1 \<and> (\<forall>(o2 :: 32 word). uint o2 = sint o1 \<longrightarrow> (0 :: int) \<le> uint o2 \<and> (\<forall>(tp :: 64 word ptr). plength tp = uint o2 \<and> offset tp = (0 :: int) \<and> c_C.min tp = (0 :: int) \<and> c_C.max tp = uint o2 \<and> writable tp = True \<longrightarrow> int'32_in_bounds (sint un + (1 :: int)) \<and> (\<forall>(o3 :: 32 word). sint o3 = sint un + (1 :: int) \<longrightarrow> (0 :: int) \<le> sint o3 \<and> (\<forall>(o4 :: 32 word). uint o4 = sint o3 \<longrightarrow> (0 :: int) \<le> uint o4 \<and> (\<forall>(qp :: 64 word ptr). plength qp = uint o4 \<and> offset qp = (0 :: int) \<and> c_C.min qp = (0 :: int) \<and> c_C.max qp = uint o4 \<and> writable qp = True \<longrightarrow> (valid tp (sint n) \<and> writable tp = True) \<and> (\<forall>(tp1 :: 64 word ptr). length (data tp1) = length (data tp) \<and> offset tp1 = offset tp \<and> c_C.min tp1 = c_C.min tp \<and> c_C.max tp1 = c_C.max tp \<and> writable tp1 = writable tp \<and> zone1 tp1 = zone1 tp \<longrightarrow> value tp1 (sint n) = (0 :: int) \<and> (\<forall>(j :: int). j < offset tp1 \<or> offset tp1 + sint n \<le> j \<longrightarrow> pelts tp1 j = pelts tp j) \<longrightarrow> (c_C.min tp1 \<le> offset tp1 + sint n \<and> offset tp1 + sint n \<le> c_C.max tp1) \<and> (\<forall>(o5 :: 64 word ptr). offset o5 = offset tp1 + sint n \<and> plength o5 = plength tp1 \<and> pelts o5 = pelts tp1 \<and> data o5 = data tp1 \<and> c_C.min o5 = c_C.min tp1 \<and> c_C.max o5 = c_C.max tp1 \<and> zone1 o5 = zone1 tp1 \<and> writable o5 = writable tp1 \<longrightarrow> (valid up (sint un) \<and> valid o5 (sint un) \<and> writable o5 = True) \<and> (\<forall>(o6 :: 64 word ptr) (tp2 :: 64 word ptr). data o6 = data tp2 \<and> length (data tp2) = length (data o5) \<and> offset o6 = offset o5 \<and> c_C.min o6 = c_C.min o5 \<and> c_C.max o6 = c_C.max o5 \<and> writable o6 = writable o5 \<and> zone1 o6 = zone1 o5 \<longrightarrow> length (data tp2) = length (data tp1) \<and> offset tp2 = offset tp1 \<and> c_C.min tp2 = c_C.min tp1 \<and> c_C.max tp2 = c_C.max tp1 \<and> writable tp2 = writable tp1 \<and> zone1 tp2 = zone1 tp1 \<longrightarrow> map_eq_sub_shift (pelts o6) (pelts up) (offset o6) (offset up) (sint un) \<and> (\<forall>(j :: int). j < offset o6 \<or> offset o6 + sint un \<le> j \<longrightarrow> pelts o6 j = pelts o5 j) \<longrightarrow> int'32_in_bounds (sint un + sint n) \<and> (\<forall>(o7 :: 32 word). sint o7 = sint un + sint n \<longrightarrow> (((1 :: int) \<le> sint n \<and> sint n \<le> sint o7 \<and> sint o7 \<le> (2147483647 :: int) - (1 :: int)) \<and> valid tp2 (sint o7) \<and> valid mp (sint n) \<and> valid qp (sint o7 - sint n + (1 :: int)) \<and> valid rp (sint n) \<and> (writable qp = True \<and> writable rp = True) \<and> (0 :: int) < uint (pelts mp (offset mp + sint n - (1 :: int)))) \<and> (\<forall>(qp1 :: 64 word ptr) (rp1 :: 64 word ptr). length (data qp1) = length (data qp) \<and> offset qp1 = offset qp \<and> c_C.min qp1 = c_C.min qp \<and> c_C.max qp1 = c_C.max qp \<and> writable qp1 = writable qp \<and> zone1 qp1 = zone1 qp \<longrightarrow> length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> value tp2 (sint o7) = value qp1 (sint o7 - sint n + (1 :: int)) * value mp (sint n) + value rp1 (sint n) \<and> value rp1 (sint n) < value mp (sint n) \<longrightarrow> value rp1 (sint n) = ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * value up (sint un) emod value mp (sint n) \<and> redc (value rp1 (sint n)) (value up (sint un)) (sint n) (value mp (sint n))))))))))))"
  sorry
end
