(* ---------------------------------------------------------- *)
(* --- Post-condition 'SubArraySwipeLeft' in 'array_pop'  --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_post_SubArraySwipeLeft
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition 'SubArraySwipeLeft' in 'array_pop'":
*)
goal goal0:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let x_1 = 1 + i_3 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_2 = i_2 - i_1 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  (x <= x_1) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_2 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 x_1 (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_2 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_3 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_7 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 (i + i_2 - 1)))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'LinkedNoHead' in 'array_pop'       --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_post_LinkedNoHead
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition 'LinkedNoHead' in 'array_pop'":
*)
goal goal1:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let x = i - 1 in
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) x) in
  let a_6 = t_3[a_1] in
  let x_1 = i + i_2 in
  let x_2 = 1 + i_3 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_3 = i_2 - i_1 in
  let a_9 = a_5[(shiftfield_f1_list_next a)] in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  (x_1 <= x_2) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_3 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 x_2 (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_3 a)) ->
  ((p_linked_n t a_5 a_9 a_4 i_2 (i_3 - i_2) a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x_1)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x_1) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x_1) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_7 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x_1) -> (i_5 < x_1) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x_1) -> (i_5 < x_1) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((p_linked_n t a_5 a_9 a_4 i_2 x a_3))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'NoMoreHere' in 'array_pop'         --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_post_NoMoreHere
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic1.Axiomatic1
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition 'NoMoreHere' in 'array_pop'":
*)
goal goal2:
  forall i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_3 a_2 a_1 a : addr.
  let a_4 = (havoc t_2 t_3 ((shift_ptr a_3 i_2)) (i - 1)) in
  let a_5 = t_3[a] in
  let x = i + i_2 in
  let a_6 = a_4[(shift_ptr a_3 i_3)] in
  let x_1 = 1 + i_4 in
  let a_7 = (shift_ptr a_3 0) in
  let a_8 = t_3[(shift_ptr a_3 i_1)] in
  let x_2 = i_2 - i_1 in
  (a_4[a] = a_5) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_1 <= i_3) ->
  (i_2 <= i_4) ->
  (i_4 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_6.base))) <= 0) ->
  ((2 + i_3) <= x) ->
  (x <= x_1) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_4)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a 1 a_7 2147483646)) ->
  ((separated a_5 4 a_7 2147483646)) ->
  ((p_array_swipe_left a_4 t_3 a_3 i_2 i_4)) ->
  ((p_linked_n t a_4 a_1 a_3 x_1 (i + i_2 - 1 - i_4) a_2)) ->
  ((p_linked_n t t_3 a_8 a_3 i_1 x_2 a_6)) ->
  ((p_linked_n t t_3 a_6 a_3 i_2 i a_2)) ->
  ((p_linked_n t a_4 a_8 a_3 i_1 x_2 a_6)) ->
  ((p_unchanged t a_4 t_1 t t_3 t_1 a_3 i_1 i_2)) ->
  ((p_unchanged t a_4 t_1 t t_3 t_1 a_3 i_4 x)) ->
  ((p_linked_n t a_4 a_4[(shiftfield_f1_list_next a_6)] a_3 i_2 (i_4 - i_2)
     a_1)) ->
  (forall i_5 : int. (i_1 <= i_5) -> (i_5 < x) ->
   ((separated a 1 t_3[(shift_ptr a_3 i_5)] 4))) ->
  (forall i_5 : int. (i_1 <= i_5) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_3 i_5)] 4 a_7 2147483646))) ->
  (forall i_6 i_5 : int. (i_6 <> i_5) -> (i_1 <= i_5) -> (i_1 <= i_6) ->
   (i_5 < x) -> (i_6 < x) ->
   (t_3[(shift_ptr a_3 i_6)] <> t_3[(shift_ptr a_3 i_5)])) ->
  (forall i_6 i_5 : int. (i_6 <> i_5) -> (i_1 <= i_5) -> (i_1 <= i_6) ->
   (i_5 < x) -> (i_6 < x) ->
   ((separated t_3[(shift_ptr a_3 i_6)] 4 t_3[(shift_ptr a_3 i_5)] 4))) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'NoMoreHere' in 'array_pop'         --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_post_NoMoreHere_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition 'NoMoreHere' in 'array_pop'":
*)
goal goal3:
  forall i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let x_1 = 1 + i_4 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_2 = i_2 - i_1 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_1 <= i_3) ->
  (i_2 <= i_4) ->
  (i_4 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((2 + i_3) <= x) ->
  (x <= x_1) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_4)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_2 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_4)) ->
  ((p_linked_n t a_5 a_2 a_4 x_1 (i + i_2 - 1 - i_4) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_2 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_4 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_4 x)) ->
  (forall i_5 : int. (i_1 <= i_5) -> (i_5 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_5)] 4))) ->
  (forall i_5 : int. (i_1 <= i_5) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 a_7 2147483646))) ->
  (forall i_6 i_5 : int. (i_6 <> i_5) -> (i_1 <= i_5) -> (i_1 <= i_6) ->
   (i_5 < x) -> (i_6 < x) ->
   (t_3[(shift_ptr a_4 i_6)] <> t_3[(shift_ptr a_4 i_5)])) ->
  (forall i_6 i_5 : int. (i_6 <> i_5) -> (i_1 <= i_5) -> (i_1 <= i_6) ->
   (i_5 < x) -> (i_6 < x) ->
   ((separated t_3[(shift_ptr a_4 i_6)] 4 t_3[(shift_ptr a_4 i_5)] 4))) ->
  ((separated a 4 a_5[(shift_ptr a_4 i_3)] 4))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'GhostSeparation' in 'array_pop'    --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_post_GhostSeparation_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition 'GhostSeparation' in 'array_pop'":
*)
goal goal4:
  forall i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let x_1 = 1 + i_4 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_2 = i_2 - i_1 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_1 <= i_3) ->
  (i_2 <= i_4) ->
  (i_4 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((2 + i_3) <= x) ->
  (x <= x_1) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_4)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_2 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_4)) ->
  ((p_linked_n t a_5 a_2 a_4 x_1 (i + i_2 - 1 - i_4) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_2 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_4 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_4 x)) ->
  (forall i_5 : int. (i_1 <= i_5) -> (i_5 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_5)] 4))) ->
  (forall i_5 : int. (i_1 <= i_5) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 a_7 2147483646))) ->
  (forall i_6 i_5 : int. (i_6 <> i_5) -> (i_1 <= i_5) -> (i_1 <= i_6) ->
   (i_5 < x) -> (i_6 < x) ->
   (t_3[(shift_ptr a_4 i_6)] <> t_3[(shift_ptr a_4 i_5)])) ->
  (forall i_6 i_5 : int. (i_6 <> i_5) -> (i_1 <= i_5) -> (i_1 <= i_6) ->
   (i_5 < x) -> (i_6 < x) ->
   ((separated t_3[(shift_ptr a_4 i_6)] 4 t_3[(shift_ptr a_4 i_5)] 4))) ->
  ((separated a_1 1 a_5[(shift_ptr a_4 i_3)] 4))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'GhostSeparation' in 'array_pop'    --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_post_GhostSeparation_3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition 'GhostSeparation' in 'array_pop'":
*)
goal goal5:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = a_5[a_1] in
  let a_7 = t_3[a_1] in
  let x = i + i_2 in
  let x_1 = 1 + i_3 in
  let a_8 = (shift_ptr a_4 0) in
  let a_9 = t_3[(shift_ptr a_4 i_1)] in
  let x_2 = i_2 - i_1 in
  (a_6 = a_7) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  (x <= x_1) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rw t a_8 2147483646)) ->
  ((separated a_1 1 a_8 2147483646)) ->
  ((separated a_7 4 a_8 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_9 a_4 i_1 x_2 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 x_1 (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_9 a_4 i_1 x_2 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_3 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_8 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((separated a_6 4 a_8 2147483646))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'Separation' in 'array_pop'         --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_post_Separation
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition 'Separation' in 'array_pop'":
*)
goal goal6:
  forall i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let x_1 = 1 + i_4 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_2 = i_2 - i_1 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_1 <= i_3) ->
  (i_2 <= i_4) ->
  (i_4 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((2 + i_3) <= x) ->
  (x <= x_1) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_4)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_2 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_4)) ->
  ((p_linked_n t a_5 a_2 a_4 x_1 (i + i_2 - 1 - i_4) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_2 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_4 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_4 x)) ->
  (forall i_5 : int. (i_1 <= i_5) -> (i_5 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_5)] 4))) ->
  (forall i_5 : int. (i_1 <= i_5) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 a_7 2147483646))) ->
  (forall i_6 i_5 : int. (i_6 <> i_5) -> (i_1 <= i_5) -> (i_1 <= i_6) ->
   (i_5 < x) -> (i_6 < x) ->
   (t_3[(shift_ptr a_4 i_6)] <> t_3[(shift_ptr a_4 i_5)])) ->
  (forall i_6 i_5 : int. (i_6 <> i_5) -> (i_1 <= i_5) -> (i_1 <= i_6) ->
   (i_5 < x) -> (i_6 < x) ->
   ((separated t_3[(shift_ptr a_4 i_6)] 4 t_3[(shift_ptr a_4 i_5)] 4))) ->
  ((separated a_5[(shift_ptr a_4 i_3)] 4 a_7 2147483646))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'Separation' in 'array_pop'         --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_post_Separation_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition 'Separation' in 'array_pop'":
*)
goal goal7:
  forall i_5 i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let x_1 = 1 + i_5 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_2 = i_2 - i_1 in
  (i_4 <> i_3) ->
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_1 <= i_3) ->
  (i_1 <= i_4) ->
  (i_2 <= i_5) ->
  (i_5 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((2 + i_3) <= x) ->
  ((2 + i_4) <= x) ->
  (x <= x_1) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_5)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_2 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_5)) ->
  ((p_linked_n t a_5 a_2 a_4 x_1 (i + i_2 - 1 - i_5) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_2 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_5 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_5 x)) ->
  (forall i_6 : int. (i_1 <= i_6) -> (i_6 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_6)] 4))) ->
  (forall i_6 : int. (i_1 <= i_6) -> (i_6 < x) ->
   ((separated t_3[(shift_ptr a_4 i_6)] 4 a_7 2147483646))) ->
  (forall i_7 i_6 : int. (i_7 <> i_6) -> (i_1 <= i_6) -> (i_1 <= i_7) ->
   (i_6 < x) -> (i_7 < x) ->
   (t_3[(shift_ptr a_4 i_7)] <> t_3[(shift_ptr a_4 i_6)])) ->
  (forall i_7 i_6 : int. (i_7 <> i_6) -> (i_1 <= i_6) -> (i_1 <= i_7) ->
   (i_6 < x) -> (i_7 < x) ->
   ((separated t_3[(shift_ptr a_4 i_7)] 4 t_3[(shift_ptr a_4 i_6)] 4))) ->
  ((separated a_5[(shift_ptr a_4 i_4)] 4 a_5[(shift_ptr a_4 i_3)] 4))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'Unique' in 'array_pop'             --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_post_Unique
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition 'Unique' in 'array_pop'":
*)
goal goal8:
  forall i_5 i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let x_1 = 1 + i_5 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_2 = i_2 - i_1 in
  (i_4 <> i_3) ->
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_1 <= i_3) ->
  (i_1 <= i_4) ->
  (i_2 <= i_5) ->
  (i_5 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((2 + i_3) <= x) ->
  ((2 + i_4) <= x) ->
  (x <= x_1) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_5)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_2 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_5)) ->
  ((p_linked_n t a_5 a_2 a_4 x_1 (i + i_2 - 1 - i_5) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_2 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_5 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_5 x)) ->
  (forall i_6 : int. (i_1 <= i_6) -> (i_6 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_6)] 4))) ->
  (forall i_6 : int. (i_1 <= i_6) -> (i_6 < x) ->
   ((separated t_3[(shift_ptr a_4 i_6)] 4 a_7 2147483646))) ->
  (forall i_7 i_6 : int. (i_7 <> i_6) -> (i_1 <= i_6) -> (i_1 <= i_7) ->
   (i_6 < x) -> (i_7 < x) ->
   (t_3[(shift_ptr a_4 i_7)] <> t_3[(shift_ptr a_4 i_6)])) ->
  (forall i_7 i_6 : int. (i_7 <> i_6) -> (i_1 <= i_6) -> (i_1 <= i_7) ->
   (i_6 < x) -> (i_7 < x) ->
   ((separated t_3[(shift_ptr a_4 i_7)] 4 t_3[(shift_ptr a_4 i_6)] 4))) ->
  (a_5[(shift_ptr a_4 i_4)] <> a_5[(shift_ptr a_4 i_3)])

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file array_pop.c, line 66) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_assert_rte_mem_access
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Assertion 'rte,mem_access' (file array_pop.c, line 66)":
*)
goal goal9:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_3 a_2 a_1 a : addr.
  let a_4 = (shift_ptr a_3 0) in
  let a_5 = (shift_ptr a_3 i_1) in
  let x = i + i_2 in
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((valid_rw t a_4 2147483646)) ->
  ((separated a_1 1 a_4 2147483646)) ->
  ((separated t_1[a_1] 4 a_4 2147483646)) ->
  ((p_linked_n t t_1 a a_3 i_2 i a_2)) ->
  ((p_linked_n t t_1 t_1[a_5] a_3 i_1 (i_2 - i_1) a)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a_1 1 t_1[(shift_ptr a_3 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_3 i_3)] 4 a_4 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_1[(shift_ptr a_3 i_4)] <> t_1[(shift_ptr a_3 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_3 i_4)] 4 t_1[(shift_ptr a_3 i_3)] 4))) ->
  ((valid_rd t a_5 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file array_pop.c, line 67) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_assert_rte_mem_access_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Assertion 'rte,mem_access' (file array_pop.c, line 67)":
*)
goal goal10:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_3 a_2 a_1 a : addr.
  let a_4 = (shift_ptr a_3 i_1) in
  let a_5 = (shift_ptr a_3 0) in
  let x = i + i_2 in
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((valid_rd t a_4 1)) ->
  ((valid_rw t a_5 2147483646)) ->
  ((separated a_1 1 a_5 2147483646)) ->
  ((separated t_1[a_1] 4 a_5 2147483646)) ->
  ((p_linked_n t t_1 a a_3 i_2 i a_2)) ->
  ((p_linked_n t t_1 t_1[a_4] a_3 i_1 (i_2 - i_1) a)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a_1 1 t_1[(shift_ptr a_3 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_3 i_3)] 4 a_5 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_1[(shift_ptr a_3 i_4)] <> t_1[(shift_ptr a_3 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_3 i_4)] 4 t_1[(shift_ptr a_3 i_3)] 4))) ->
  ((valid_rd t ((shiftfield_f1_list_next a)) 1))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file array_pop.c, line 74) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_inv_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Preservation of Invariant (file array_pop.c, line 74)":
*)
goal goal11:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_1 = i_2 - i_1 in
  let x_2 = 1 + i_3 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((2 + i_3) <= x) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_1 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 x_2 (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_1 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_3 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_7 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (a_5[((shift_ptr a_4 i_3)) <- a_5[(shift_ptr a_4 x_2)]][a_1] = a_6)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant 'BeforeISwipeLeft' (file array_pop.c, line 79) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_inv_BeforeISwipeLeft_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Preservation of Invariant 'BeforeISwipeLeft' (file array_pop.c, line 79)":
*)
goal goal12:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let x_1 = 1 + i_3 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_2 = i_2 - i_1 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((2 + i_3) <= x) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((is_sint32 x_1)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_2 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 x_1 (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_2 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_3 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_7 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((p_array_swipe_left a_5[((shift_ptr a_4 i_3)) <- a_5[(shift_ptr a_4 x_1)]]
     t_3 a_4 i_2 x_1))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant 'BeforeISwipeLeft' (file array_pop.c, line 79) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_inv_BeforeISwipeLeft_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Establishment of Invariant 'BeforeISwipeLeft' (file array_pop.c, line 79)":
*)
goal goal13:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_3 a_2 a_1 a : addr.
  let a_4 = (shift_ptr a_3 0) in
  let x = i + i_2 in
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((valid_rw t a_4 2147483646)) ->
  ((separated a_1 1 a_4 2147483646)) ->
  ((separated t_1[a_1] 4 a_4 2147483646)) ->
  ((p_linked_n t t_1 a a_3 i_2 i a_2)) ->
  ((p_linked_n t t_1 t_1[(shift_ptr a_3 i_1)] a_3 i_1 (i_2 - i_1) a)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a_1 1 t_1[(shift_ptr a_3 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_3 i_3)] 4 a_4 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_1[(shift_ptr a_3 i_4)] <> t_1[(shift_ptr a_3 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_3 i_4)] 4 t_1[(shift_ptr a_3 i_3)] 4))) ->
  ((p_array_swipe_left t_1 t_1 a_3 i_2 i_2))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant 'CenterLinked' (file array_pop.c, line 82) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_inv_CenterLinked_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Preservation of Invariant 'CenterLinked' (file array_pop.c, line 82)":
*)
goal goal14:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let x_1 = 1 + i_3 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_2 = i_2 - i_1 in
  let a_9 = (shiftfield_f1_list_next a) in
  let x_3 = - i_2 in
  let a_10 = a_5[((shift_ptr a_4 i_3)) <- a_5[(shift_ptr a_4 x_1)]] in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((2 + i_3) <= x) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((is_sint32 x_1)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_2 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 x_1 (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_2 a)) ->
  ((p_linked_n t a_5 a_5[a_9] a_4 i_2 (i_3 - i_2) a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_7 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((p_linked_n t a_10 a_10[a_9] a_4 i_2 (1 + i_3 - i_2)
     a_10[(shiftfield_f1_list_next a_2)]))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant 'CenterLinked' (file array_pop.c, line 82) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_inv_CenterLinked_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Establishment of Invariant 'CenterLinked' (file array_pop.c, line 82)":
*)
goal goal15:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_3 a_2 a_1 a : addr.
  let a_4 = (shift_ptr a_3 0) in
  let x = i + i_2 in
  let a_5 = t_1[(shiftfield_f1_list_next a)] in
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((valid_rw t a_4 2147483646)) ->
  ((separated a_1 1 a_4 2147483646)) ->
  ((separated t_1[a_1] 4 a_4 2147483646)) ->
  ((p_linked_n t t_1 a a_3 i_2 i a_2)) ->
  ((p_linked_n t t_1 t_1[(shift_ptr a_3 i_1)] a_3 i_1 (i_2 - i_1) a)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a_1 1 t_1[(shift_ptr a_3 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_3 i_3)] 4 a_4 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_1[(shift_ptr a_3 i_4)] <> t_1[(shift_ptr a_3 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_3 i_4)] 4 t_1[(shift_ptr a_3 i_3)] 4))) ->
  ((p_linked_n t t_1 a_5 a_3 i_2 0 a_5))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant 'IInBounds' (file array_pop.c, line 75) (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_inv_IInBounds_preserved_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Preservation of Invariant 'IInBounds' (file array_pop.c, line 75) (1/2)":
*)
goal goal16:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let x_1 = 1 + i_3 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_2 = i_2 - i_1 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((2 + i_3) <= x) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((is_sint32 x_1)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_2 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 x_1 (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_2 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_3 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_7 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (i_2 <= x_1)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant 'LeftLinked' (file array_pop.c, line 81) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_inv_LeftLinked_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Preservation of Invariant 'LeftLinked' (file array_pop.c, line 81)":
*)
goal goal17:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_1 = i_2 - i_1 in
  let x_2 = 1 + i_3 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((2 + i_3) <= x) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_1 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 x_2 (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_1 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_3 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_7 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((p_linked_n t a_5[((shift_ptr a_4 i_3)) <- a_5[(shift_ptr a_4 x_2)]] a_8
     a_4 i_1 x_1 a))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant 'RightLinked' (file array_pop.c, line 83) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_inv_RightLinked_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Preservation of Invariant 'RightLinked' (file array_pop.c, line 83)":
*)
goal goal18:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let x_1 = 2 + i_3 in
  let x_2 = 1 + i_3 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_3 = i_2 - i_1 in
  let x_4 = - i_3 in
  let a_9 = a_5[((shift_ptr a_4 i_3)) <- a_5[(shift_ptr a_4 x_2)]] in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  (x_1 <= x) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((is_sint32 x_2)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_3 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 x_2 (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_3 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_3 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_7 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((p_linked_n t a_9 a_9[(shiftfield_f1_list_next a_2)] a_4 x_1
     (i + i_2 - 2 - i_3) a_3))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant 'RightLinked' (file array_pop.c, line 83) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_inv_RightLinked_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Establishment of Invariant 'RightLinked' (file array_pop.c, line 83)":
*)
goal goal19:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_3 a_2 a_1 a : addr.
  let a_4 = (shift_ptr a_3 0) in
  let x = i + i_2 in
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((valid_rw t a_4 2147483646)) ->
  ((separated a_1 1 a_4 2147483646)) ->
  ((separated t_1[a_1] 4 a_4 2147483646)) ->
  ((p_linked_n t t_1 a a_3 i_2 i a_2)) ->
  ((p_linked_n t t_1 t_1[(shift_ptr a_3 i_1)] a_3 i_1 (i_2 - i_1) a)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a_1 1 t_1[(shift_ptr a_3 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_3 i_3)] 4 a_4 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_1[(shift_ptr a_3 i_4)] <> t_1[(shift_ptr a_3 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_3 i_4)] 4 t_1[(shift_ptr a_3 i_3)] 4))) ->
  ((p_linked_n t t_1 t_1[(shiftfield_f1_list_next a)] a_3 (1 + i_2) (i - 1)
     a_2))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant 'UnchangedLeft' (file array_pop.c, line 76) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_inv_UnchangedLeft_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Preservation of Invariant 'UnchangedLeft' (file array_pop.c, line 76)":
*)
goal goal20:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_1 = i_2 - i_1 in
  let x_2 = 1 + i_3 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((2 + i_3) <= x) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_1 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 x_2 (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_1 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_3 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_7 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((p_unchanged t a_5[((shift_ptr a_4 i_3)) <- a_5[(shift_ptr a_4 x_2)]] t_1
     t t_3 t_1 a_4 i_1 i_2))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant 'UnchangedLeft' (file array_pop.c, line 76) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_inv_UnchangedLeft_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Establishment of Invariant 'UnchangedLeft' (file array_pop.c, line 76)":
*)
goal goal21:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_2 : map addr addr.
  forall a_3 a_2 a_1 a : addr.
  let a_4 = (shift_ptr a_3 0) in
  let x = i + i_2 in
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  ((framed t_2)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((valid_rw t a_4 2147483646)) ->
  ((separated a_1 1 a_4 2147483646)) ->
  ((separated t_2[a_1] 4 a_4 2147483646)) ->
  ((p_linked_n t t_2 a a_3 i_2 i a_2)) ->
  ((p_linked_n t t_2 t_2[(shift_ptr a_3 i_1)] a_3 i_1 (i_2 - i_1) a)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a_1 1 t_2[(shift_ptr a_3 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_2[(shift_ptr a_3 i_3)] 4 a_4 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_2[(shift_ptr a_3 i_4)] <> t_2[(shift_ptr a_3 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_2[(shift_ptr a_3 i_4)] 4 t_2[(shift_ptr a_3 i_3)] 4))) ->
  ((p_unchanged t t_2 t_1 t t_2 t_1 a_3 i_1 i_2))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant 'UnchangedRight' (file array_pop.c, line 77) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_inv_UnchangedRight_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Preservation of Invariant 'UnchangedRight' (file array_pop.c, line 77)":
*)
goal goal22:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let x_1 = 1 + i_3 in
  let a_7 = (shift_ptr a_4 0) in
  let a_8 = t_3[(shift_ptr a_4 i_1)] in
  let x_2 = i_2 - i_1 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((2 + i_3) <= x) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((is_sint32 x_1)) ->
  ((valid_rw t a_7 2147483646)) ->
  ((separated a_1 1 a_7 2147483646)) ->
  ((separated a_6 4 a_7 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_8 a_4 i_1 x_2 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 x_1 (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_8 a_4 i_1 x_2 a)) ->
  ((p_linked_n t a_5 a_5[(shiftfield_f1_list_next a)] a_4 i_2 (i_3 - i_2)
     a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_7 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((p_unchanged t a_5[((shift_ptr a_4 i_3)) <- a_5[(shift_ptr a_4 x_1)]] t_1
     t t_3 t_1 a_4 x_1 x))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant 'UnchangedRight' (file array_pop.c, line 77) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_inv_UnchangedRight_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Establishment of Invariant 'UnchangedRight' (file array_pop.c, line 77)":
*)
goal goal23:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_2 : map addr addr.
  forall a_3 a_2 a_1 a : addr.
  let a_4 = (shift_ptr a_3 0) in
  let x = i + i_2 in
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  ((framed t_2)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((valid_rw t a_4 2147483646)) ->
  ((separated a_1 1 a_4 2147483646)) ->
  ((separated t_2[a_1] 4 a_4 2147483646)) ->
  ((p_linked_n t t_2 a a_3 i_2 i a_2)) ->
  ((p_linked_n t t_2 t_2[(shift_ptr a_3 i_1)] a_3 i_1 (i_2 - i_1) a)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a_1 1 t_2[(shift_ptr a_3 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_2[(shift_ptr a_3 i_3)] 4 a_4 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_2[(shift_ptr a_3 i_4)] <> t_2[(shift_ptr a_3 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_2[(shift_ptr a_3 i_4)] 4 t_2[(shift_ptr a_3 i_3)] 4))) ->
  ((p_unchanged t t_2 t_1 t t_2 t_1 a_3 i_2 x))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,signed_overflow' (file array_pop.c, line 88) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_assert_rte_signed_overflow
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assertion 'rte,signed_overflow' (file array_pop.c, line 88)":
*)
goal goal24:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let a_7 = (shiftfield_f1_list_next a) in
  let a_8 = (shift_ptr a_4 i_1) in
  let a_9 = (shift_ptr a_4 0) in
  let a_10 = t_3[a_8] in
  let x_1 = i_2 - i_1 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rd t a_7 1)) ->
  ((valid_rd t a_8 1)) ->
  ((valid_rw t a_9 2147483646)) ->
  ((separated a_1 1 a_9 2147483646)) ->
  ((separated a_6 4 a_9 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_10 a_4 i_1 x_1 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 (1 + i_3) (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_10 a_4 i_1 x_1 a)) ->
  ((p_linked_n t a_5 a_5[a_7] a_4 i_2 (i_3 - i_2) a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_9 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((-2147483648) <= x)

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,signed_overflow' (file array_pop.c, line 88) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_assert_rte_signed_overflow_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assertion 'rte,signed_overflow' (file array_pop.c, line 88)":
*)
goal goal25:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let a_7 = (shiftfield_f1_list_next a) in
  let a_8 = (shift_ptr a_4 i_1) in
  let a_9 = (shift_ptr a_4 0) in
  let a_10 = t_3[a_8] in
  let x_1 = i_2 - i_1 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rd t a_7 1)) ->
  ((valid_rd t a_8 1)) ->
  ((valid_rw t a_9 2147483646)) ->
  ((separated a_1 1 a_9 2147483646)) ->
  ((separated a_6 4 a_9 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_10 a_4 i_1 x_1 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 (1 + i_3) (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_10 a_4 i_1 x_1 a)) ->
  ((p_linked_n t a_5 a_5[a_7] a_4 i_2 (i_3 - i_2) a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_9 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (x <= 2147483647)

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,signed_overflow' (file array_pop.c, line 88) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_assert_rte_signed_overflow_3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assertion 'rte,signed_overflow' (file array_pop.c, line 88)":
*)
goal goal26:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let a_7 = (shiftfield_f1_list_next a) in
  let a_8 = (shift_ptr a_4 i_1) in
  let a_9 = (shift_ptr a_4 0) in
  let a_10 = t_3[a_8] in
  let x_1 = i_2 - i_1 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rd t a_7 1)) ->
  ((valid_rd t a_8 1)) ->
  ((valid_rw t a_9 2147483646)) ->
  ((separated a_1 1 a_9 2147483646)) ->
  ((separated a_6 4 a_9 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_10 a_4 i_1 x_1 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 (1 + i_3) (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_10 a_4 i_1 x_1 a)) ->
  ((p_linked_n t a_5 a_5[a_7] a_4 i_2 (i_3 - i_2) a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_9 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((-2147483647) <= ((to_sint32 x)))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file array_pop.c, line 96) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_assert_rte_mem_access_3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assertion 'rte,mem_access' (file array_pop.c, line 96)":
*)
goal goal27:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let a_7 = (shiftfield_f1_list_next a) in
  let a_8 = (shift_ptr a_4 i_1) in
  let a_9 = (shift_ptr a_4 0) in
  let a_10 = t_3[a_8] in
  let x_1 = i_2 - i_1 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((-2147483648) <= x) ->
  (x <= 2147483647) ->
  ((2 + i_3) <= x) ->
  ((-2147483647) <= ((to_sint32 x))) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rd t a_7 1)) ->
  ((valid_rd t a_8 1)) ->
  ((valid_rw t a_9 2147483646)) ->
  ((separated a_1 1 a_9 2147483646)) ->
  ((separated a_6 4 a_9 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_10 a_4 i_1 x_1 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 (1 + i_3) (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_10 a_4 i_1 x_1 a)) ->
  ((p_linked_n t a_5 a_5[a_7] a_4 i_2 (i_3 - i_2) a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_9 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((valid_rw t ((shift_ptr a_4 i_3)) 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file array_pop.c, line 96) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_assert_rte_mem_access_4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assertion 'rte,mem_access' (file array_pop.c, line 96)":
*)
goal goal28:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let a_7 = (shiftfield_f1_list_next a) in
  let a_8 = (shift_ptr a_4 i_1) in
  let a_9 = (shift_ptr a_4 0) in
  let a_10 = t_3[a_8] in
  let x_1 = i_2 - i_1 in
  let x_2 = 1 + i_3 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((-2147483648) <= x) ->
  (x <= 2147483647) ->
  ((2 + i_3) <= x) ->
  ((-2147483647) <= ((to_sint32 x))) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rd t a_7 1)) ->
  ((valid_rd t a_8 1)) ->
  ((valid_rw t a_9 2147483646)) ->
  ((separated a_1 1 a_9 2147483646)) ->
  ((separated a_6 4 a_9 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_10 a_4 i_1 x_1 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 x_2 (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_10 a_4 i_1 x_1 a)) ->
  ((p_linked_n t a_5 a_5[a_7] a_4 i_2 (i_3 - i_2) a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_9 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((valid_rd t ((shift_ptr a_4 ((to_sint32 x_2)))) 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,signed_overflow' (file array_pop.c, line 96) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_assert_rte_signed_overflow_4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assertion 'rte,signed_overflow' (file array_pop.c, line 96)":
*)
goal goal29:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let a_7 = (shiftfield_f1_list_next a) in
  let a_8 = (shift_ptr a_4 i_1) in
  let a_9 = (shift_ptr a_4 0) in
  let a_10 = t_3[a_8] in
  let x_1 = i_2 - i_1 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((-2147483648) <= x) ->
  (x <= 2147483647) ->
  ((2 + i_3) <= x) ->
  ((-2147483647) <= ((to_sint32 x))) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rd t a_7 1)) ->
  ((valid_rd t a_8 1)) ->
  ((valid_rw t a_9 2147483646)) ->
  ((separated a_1 1 a_9 2147483646)) ->
  ((separated a_6 4 a_9 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_10 a_4 i_1 x_1 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 (1 + i_3) (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_10 a_4 i_1 x_1 a)) ->
  ((p_linked_n t a_5 a_5[a_7] a_4 i_2 (i_3 - i_2) a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_9 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (i_3 <= 2147483646)

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file array_pop.c, line 113) --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_assert_rte_mem_access_5
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assertion 'rte,mem_access' (file array_pop.c, line 113)":
*)
goal goal30:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (havoc t_2 t_3 ((shift_ptr a_4 i_2)) (i - 1)) in
  let a_6 = t_3[a_1] in
  let x = i + i_2 in
  let a_7 = (shiftfield_f1_list_next a) in
  let a_8 = (shift_ptr a_4 i_1) in
  let a_9 = (shift_ptr a_4 0) in
  let x_1 = 1 + i_3 in
  let a_10 = t_3[a_8] in
  let x_2 = i_2 - i_1 in
  (a_5[a_1] = a_6) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  (i_3 <= 2147483646) ->
  ((-2147483648) <= x) ->
  (x <= 2147483647) ->
  ((2 + i_3) <= x) ->
  ((-2147483647) <= ((to_sint32 x))) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rd t a_7 1)) ->
  ((valid_rd t a_8 1)) ->
  ((valid_rw t a_9 2147483646)) ->
  ((valid_rw t ((shift_ptr a_4 i_3)) 1)) ->
  ((separated a_1 1 a_9 2147483646)) ->
  ((separated a_6 4 a_9 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((valid_rd t ((shift_ptr a_4 ((to_sint32 x_1)))) 1)) ->
  ((p_linked_n t t_3 a_10 a_4 i_1 x_2 a)) ->
  ((p_array_swipe_left a_5 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_5 a_2 a_4 x_1 (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_5 a_10 a_4 i_1 x_2 a)) ->
  ((p_linked_n t a_5 a_5[a_7] a_4 i_2 (i_3 - i_2) a_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_5 t_1 t t_3 t_1 a_4 i_3 x)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_9 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((valid_rd t ((shiftfield_f1_list_next a_2)) 1))

end

(* ---------------------------------------------------------- *)
(* --- Loop assigns (file array_pop.c, line 85) (2/2)     --- *)
(* ---------------------------------------------------------- *)
theory VCarray_pop_loop_assign_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Loop assigns (file array_pop.c, line 85) (2/2)":
*)
goal goal31:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_3 t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = (shift_ptr a_4 i_2) in
  let x = i - 1 in
  let a_6 = (havoc t_2 t_3 a_5 x) in
  let a_7 = t_3[a_1] in
  let x_1 = i + i_2 in
  let a_8 = (shift_ptr a_4 0) in
  let a_9 = (shift_ptr a_4 i_3) in
  let a_10 = t_3[(shift_ptr a_4 i_1)] in
  let x_2 = i_2 - i_1 in
  (a_6[a_1] = a_7) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 <= i_3) ->
  (i_3 < x_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  (((region (a_4.base))) <= 0) ->
  ((2 + i_3) <= x_1) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((valid_rw t a_8 2147483646)) ->
  (not (invalid t a_9 1)) ->
  ((separated a_1 1 a_8 2147483646)) ->
  ((separated a_7 4 a_8 2147483646)) ->
  ((p_linked_n t t_3 a a_4 i_2 i a_3)) ->
  ((p_linked_n t t_3 a_10 a_4 i_1 x_2 a)) ->
  ((p_array_swipe_left a_6 t_3 a_4 i_2 i_3)) ->
  ((p_linked_n t a_6 a_2 a_4 (1 + i_3) (i + i_2 - 1 - i_3) a_3)) ->
  ((p_linked_n t a_6 a_10 a_4 i_1 x_2 a)) ->
  ((p_linked_n t a_6 a_6[(shiftfield_f1_list_next a)] a_4 i_2 (i_3 - i_2)
     a_2)) ->
  ((p_unchanged t a_6 t_1 t t_3 t_1 a_4 i_1 i_2)) ->
  ((p_unchanged t a_6 t_1 t t_3 t_1 a_4 i_3 x_1)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x_1) ->
   ((separated a_1 1 t_3[(shift_ptr a_4 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x_1) ->
   ((separated t_3[(shift_ptr a_4 i_4)] 4 a_8 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x_1) -> (i_5 < x_1) ->
   (t_3[(shift_ptr a_4 i_5)] <> t_3[(shift_ptr a_4 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x_1) -> (i_5 < x_1) ->
   ((separated t_3[(shift_ptr a_4 i_5)] 4 t_3[(shift_ptr a_4 i_4)] 4))) ->
  ((included a_9 1 a_5 x))

end

