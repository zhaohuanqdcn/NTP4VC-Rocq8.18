import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Iter
open Classical
open Lean4Why3
namespace mccarthy_vc_sp_McCarthy91Mach_f91_pseudorecqtvc
noncomputable def spec (x : ℤ) := if x ≤ (100 : ℤ) then (91 : ℤ) else x - (10 : ℤ)
theorem f91_pseudorec'vc (n0 : BitVec 63) : (∀(e : ℕ) (n : BitVec 63), (0 : ℤ) ≤ Int.ofNat e → (if ¬(0 : ℕ) < e then Int.ofNat e = (0 : ℤ) else if (100 : ℤ) < BitVec.toInt n then int'63_in_bounds (BitVec.toInt n - (10 : ℤ)) else int'63_in_bounds (BitVec.toInt n + (11 : ℤ))) ∧ (∀(e1 : ℕ) (n1 : BitVec 63), (0 : ℕ) < e ∧ (if (100 : ℤ) < BitVec.toInt n then BitVec.toInt n1 = BitVec.toInt n - (10 : ℤ) ∧ Int.ofNat e1 = Int.ofNat e - (1 : ℤ) else BitVec.toInt n1 = BitVec.toInt n + (11 : ℤ) ∧ Int.ofNat e1 = Int.ofNat e + (1 : ℤ)) → (0 : ℤ) < Int.ofNat e ∧ (if (100 : ℤ) < BitVec.toInt n then BitVec.toInt n1 = BitVec.toInt n - (10 : ℤ) ∧ Int.ofNat e1 = Int.ofNat e - (1 : ℤ) else BitVec.toInt n1 = BitVec.toInt n + (11 : ℤ) ∧ Int.ofNat e1 = Int.ofNat e + (1 : ℤ)))) ∧ (∀(e : ℕ) (n : BitVec 63), (0 : ℤ) < Int.ofNat e → ((0 : ℤ) ≤ Int.ofNat e ∧ (∀(e1 : ℕ) (n1 : BitVec 63), ((0 : ℤ) < Int.ofNat e ∧ (if (100 : ℤ) < BitVec.toInt n then BitVec.toInt n1 = BitVec.toInt n - (10 : ℤ) ∧ Int.ofNat e1 = Int.ofNat e - (1 : ℤ) else BitVec.toInt n1 = BitVec.toInt n + (11 : ℤ) ∧ Int.ofNat e1 = Int.ofNat e + (1 : ℤ)) → BitVec.toInt n ≤ (100 : ℤ) → (((0 : ℤ) ≤ (101 : ℤ) - BitVec.toInt n ∧ (101 : ℤ) - BitVec.toInt n1 < (101 : ℤ) - BitVec.toInt n) ∧ (0 : ℤ) < Int.ofNat e1) ∧ (∀(e2 : ℕ) (n2 : BitVec 63), Int.ofNat e2 = Int.ofNat e1 - (1 : ℤ) ∧ BitVec.toInt n2 = spec (BitVec.toInt n1) → ((0 : ℤ) ≤ (101 : ℤ) - BitVec.toInt n ∧ (101 : ℤ) - BitVec.toInt n2 < (101 : ℤ) - BitVec.toInt n) ∧ (0 : ℤ) < Int.ofNat e2)) ∧ ¬((e1 = e ∧ Int.ofNat e = (0 : ℤ)) ∧ n1 = n))) ∧ (∀(e1 : ℕ) (n1 : BitVec 63), (∃(e2 : ℕ) (n2 : BitVec 63), ((0 : ℤ) < Int.ofNat e ∧ (if (100 : ℤ) < BitVec.toInt n then BitVec.toInt n2 = BitVec.toInt n - (10 : ℤ) ∧ Int.ofNat e2 = Int.ofNat e - (1 : ℤ) else BitVec.toInt n2 = BitVec.toInt n + (11 : ℤ) ∧ Int.ofNat e2 = Int.ofNat e + (1 : ℤ))) ∧ (if BitVec.toInt n ≤ (100 : ℤ) then ∃(e3 : ℕ) (n3 : BitVec 63), (Int.ofNat e3 = Int.ofNat e2 - (1 : ℤ) ∧ BitVec.toInt n3 = spec (BitVec.toInt n2)) ∧ Int.ofNat e1 = Int.ofNat e3 - (1 : ℤ) ∧ BitVec.toInt n1 = spec (BitVec.toInt n3) else e1 = e2 ∧ n1 = n2)) → Int.ofNat e1 = Int.ofNat e - (1 : ℤ) ∧ BitVec.toInt n1 = spec (BitVec.toInt n))) ∧ (0 : ℤ) < Int.ofNat (1 : ℕ) ∧ (∀(e : ℕ) (n : BitVec 63), Int.ofNat e = Int.ofNat (1 : ℕ) - (1 : ℤ) ∧ BitVec.toInt n = spec (BitVec.toInt n0) → (0 : ℤ) ≤ Int.ofNat e ∧ (∀(e1 : ℕ) (n1 : BitVec 63), ¬((0 : ℤ) < Int.ofNat e ∧ (if (100 : ℤ) < BitVec.toInt n then BitVec.toInt n1 = BitVec.toInt n - (10 : ℤ) ∧ Int.ofNat e1 = Int.ofNat e - (1 : ℤ) else BitVec.toInt n1 = BitVec.toInt n + (11 : ℤ) ∧ Int.ofNat e1 = Int.ofNat e + (1 : ℤ))) ∧ ((e1 = e ∧ Int.ofNat e = (0 : ℤ)) ∧ n1 = n → BitVec.toInt n1 = spec (BitVec.toInt n0))))
  := sorry
end mccarthy_vc_sp_McCarthy91Mach_f91_pseudorecqtvc
