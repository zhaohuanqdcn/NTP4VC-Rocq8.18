From Coq Require Import Strings.String.
From Coq Require Import String Ascii.
From Coq Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Coq Require Classical.
From Coq Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Coq Require Import Sorting.Sorted.
From Coq Require Import Reals.Rbasic_fun.
From Coq Require Import Reals.Abstract.ConstructiveAbs.
From Coq Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Coq Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Coq Require Import ZArith.Zeuclid.
From Coq Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Coq Require Import Reals.
Require Import Why3.Base.
Require Import Why3.why3.Ref.Ref.
Require Import Why3.map.Const.
Require Import Why3.map.MapEq.
Require Import Why3.mach.int.Unsigned.
Require Import Why3.mach.c.C.
Require Import Why3.mach.c.UChar.
Require Import multiprecision.types.Config.
Require Import multiprecision.types.Types.
Require Import multiprecision.types.Int32Eq.
Require Import multiprecision.types.UInt64Eq.
Require Import multiprecision.lemmas.Lemmas.
Require Import multiprecision.powm.Powm.
Require Import multiprecision.compare.Compare.
Require Import multiprecision.valuation.Valuation.
Require Import multiprecision.util.Util.
Require Import multiprecision.ptralias.Alias.
Require Import multiprecision.util.UtilOld.
Require Import multiprecision.add.Add.
Require Import multiprecision.add.AddOld.
Require Import multiprecision.sub.SubOld.
Require Import multiprecision.mul.Mul.
Require Import multiprecision.mul.Mul_basecase.
Require Import multiprecision.logical.LogicalUtil.
Require Import multiprecision.logical.Logical.
Require Import multiprecision.logical.LogicalOld.
Require Import multiprecision.div.Div.
Require Import multiprecision.toom.Toom.
Require Import multiprecision.add_1.Add_1.
Require Import multiprecision.sub_1.Sub_1.
Require Import multiprecision.stringlemmas.String_lemmas.
Require Import multiprecision.base_info.BaseInfo.
Open Scope Z_scope.
Theorem wmpn_set_str_other'vc (sn : bv 32%N) (sz : bv 32%N) (rp : ptr (bv 64%N)) (sp : ptr (bv 8%N)) (b : bv 64%N) (info : wmpn_base_info) (fact0 : 0%Z < bv_unsigned sn) (fact1 : bv_unsigned sn ≤ 2147483647%Z) (fact2 : 0%Z < bv_signed sz) (fact3 : valid rp (bv_signed sz)) (fact4 : valid sp (bv_unsigned sn)) (fact5 : 2%Z ≤ bv_unsigned b) (fact6 : bv_unsigned b ≤ 256%Z) (fact7 : Z.pow (bv_unsigned b) (bv_unsigned sn) ≤ Z.pow (18446744073709551615%Z + 1%Z) (bv_signed sz)) (fact8 : writable rp = true) (fact9 : in_base (bv_unsigned b) (pelts sp) (offset sp) (offset sp + bv_unsigned sn)) (fact10 : BaseInfo.b info = bv_unsigned b) : let o1 : bv 32%N := BaseInfo.exp info in uint'32_in_bounds (bv_unsigned sn - 1%Z) ∧ (∀(o2 : bv 32%N), bv_unsigned o2 = bv_unsigned sn - 1%Z -> (¬ bv_unsigned o1 = 0%Z ∧ uint'32_in_bounds (Z.quot (bv_unsigned o2) (bv_unsigned o1))) ∧ (∀(o3 : bv 32%N), bv_unsigned o3 = Z.quot (bv_unsigned o2) (bv_unsigned o1) -> uint'32_in_bounds (1%Z + bv_unsigned o3) ∧ (∀(o4 : bv 32%N), bv_unsigned o4 = 1%Z + bv_unsigned o3 -> (min sp ≤ offset sp ∧ offset sp < C.max sp) ∧ (∀(o5 : bv 64%N), bv_unsigned o5 = bv_signed (pelts sp (offset sp)) -> ((1%Z ≤ bv_unsigned o4 ∧ bv_unsigned o4 ≤ bv_unsigned sn) ∧ (1%Z ≤ 1%Z ∧ 1%Z ≤ bv_unsigned sn) ∧ bv_unsigned o5 = svalue_sub (bv_unsigned b) (pelts sp) (offset sp) (offset sp + 1%Z) ∧ (0%Z ≤ bv_unsigned o5 ∧ bv_unsigned o5 < Z.pow (bv_unsigned b) 1%Z) ∧ 1%Z + bv_unsigned o4 - 1%Z = 1%Z + ZEuclid.modulo (bv_unsigned sn - 1%Z) (bv_unsigned (BaseInfo.exp info)) ∧ (1%Z = bv_unsigned sn -> bv_unsigned o4 = 1%Z)) ∧ (∀(j : bv 32%N) (w : bv 64%N) (k : bv 32%N), (1%Z ≤ bv_unsigned k ∧ bv_unsigned k ≤ bv_unsigned sn) ∧ (1%Z ≤ bv_signed j ∧ bv_signed j ≤ bv_unsigned sn) ∧ bv_unsigned w = svalue_sub (bv_unsigned b) (pelts sp) (offset sp) (offset sp + bv_signed j) ∧ (0%Z ≤ bv_unsigned w ∧ bv_unsigned w < Z.pow (bv_unsigned b) (bv_signed j)) ∧ bv_signed j + bv_unsigned k - 1%Z = 1%Z + ZEuclid.modulo (bv_unsigned sn - 1%Z) (bv_unsigned (BaseInfo.exp info)) ∧ (bv_signed j = bv_unsigned sn -> bv_unsigned k = 1%Z) -> uint'32_in_bounds (bv_unsigned k - 1%Z) ∧ (∀(o6 : bv 32%N), bv_unsigned o6 = bv_unsigned k - 1%Z -> (if decide (0%Z < bv_unsigned o6) then (min sp ≤ offset sp + bv_signed j ∧ offset sp + bv_signed j < C.max sp) ∧ (∀(sj : bv 64%N), bv_unsigned sj = bv_signed (pelts sp (offset sp + bv_signed j)) -> uint'64_in_bounds (bv_unsigned w * bv_unsigned b) ∧ (∀(o7 : bv 64%N), bv_unsigned o7 = bv_unsigned w * bv_unsigned b -> uint'64_in_bounds (bv_unsigned o7 + bv_unsigned sj) ∧ (∀(o8 : bv 64%N), bv_unsigned o8 = bv_unsigned o7 + bv_unsigned sj -> int'32_in_bounds (bv_signed j + 1%Z) ∧ (∀(o9 : bv 32%N), bv_signed o9 = bv_signed j + 1%Z -> bv_unsigned o6 < bv_unsigned k ∧ (1%Z ≤ bv_unsigned o6 ∧ bv_unsigned o6 ≤ bv_unsigned sn) ∧ (1%Z ≤ bv_signed o9 ∧ bv_signed o9 ≤ bv_unsigned sn) ∧ bv_unsigned o8 = svalue_sub (bv_unsigned b) (pelts sp) (offset sp) (offset sp + bv_signed o9) ∧ (0%Z ≤ bv_unsigned o8 ∧ bv_unsigned o8 < Z.pow (bv_unsigned b) (bv_signed o9)) ∧ bv_signed o9 + bv_unsigned o6 - 1%Z = 1%Z + ZEuclid.modulo (bv_unsigned sn - 1%Z) (bv_unsigned (BaseInfo.exp info)) ∧ (bv_signed o9 = bv_unsigned sn -> bv_unsigned o6 = 1%Z))))) else ((min rp ≤ offset rp ∧ offset rp < C.max rp) ∧ writable rp = true) ∧ (∀(rp1 : ptr (bv 64%N)), length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> pelts rp1 = fun_updt (pelts rp) (offset rp1) w -> ((0%Z ≤ bv_signed j ∧ bv_signed j ≤ bv_unsigned sn) ∧ value rp1 1%Z = svalue_sub (bv_unsigned b) (pelts sp) (offset sp) (offset sp + bv_signed j) ∧ bv_signed j ≤ bv_unsigned sn ∧ (0%Z ≤ 1%Z ∧ 1%Z ≤ bv_signed sz) ∧ (0%Z < svalue (bv_unsigned b) sp (bv_signed j) -> 0%Z < bv_unsigned (pelts rp1 (offset rp1 + 1%Z - 1%Z))) ∧ ZEuclid.modulo (bv_unsigned sn - bv_signed j) (bv_unsigned (BaseInfo.exp info)) = 0%Z) ∧ (∀(rn : bv 32%N) (j1 : bv 32%N) (rp2 : ptr (bv 64%N)), length (data rp2) = length (data rp1) ∧ offset rp2 = offset rp1 ∧ min rp2 = min rp1 ∧ C.max rp2 = C.max rp1 ∧ writable rp2 = writable rp1 ∧ zone1 rp2 = zone1 rp1 -> (0%Z ≤ bv_signed j1 ∧ bv_signed j1 ≤ bv_unsigned sn) ∧ value rp2 (bv_signed rn) = svalue_sub (bv_unsigned b) (pelts sp) (offset sp) (offset sp + bv_signed j1) ∧ bv_signed j1 ≤ bv_unsigned sn ∧ (0%Z ≤ bv_signed rn ∧ bv_signed rn ≤ bv_signed sz) ∧ (0%Z < svalue (bv_unsigned b) sp (bv_signed j1) -> 0%Z < bv_unsigned (pelts rp2 (offset rp2 + bv_signed rn - 1%Z))) ∧ (svalue (bv_unsigned b) sp (bv_signed j1) = 0%Z -> bv_signed rn = 1%Z) ∧ ZEuclid.modulo (bv_unsigned sn - bv_signed j1) (bv_unsigned (BaseInfo.exp info)) = 0%Z -> bv_unsigned sn ≤ 2147483647%Z ∧ (∀(o7 : bv 32%N), bv_signed o7 = bv_unsigned sn -> (if decide (bv_signed j1 < bv_signed o7) then (min sp ≤ offset sp + bv_signed j1 ∧ offset sp + bv_signed j1 < C.max sp) ∧ (∀(o8 : bv 64%N), bv_unsigned o8 = bv_signed (pelts sp (offset sp + bv_signed j1)) -> int'32_in_bounds (bv_signed j1 + 1%Z) ∧ (∀(o9 : bv 32%N), bv_signed o9 = bv_signed j1 + 1%Z -> (let o10 : bv 32%N := BaseInfo.exp info in uint'32_in_bounds (bv_unsigned o10 - 1%Z) ∧ (∀(o11 : bv 32%N), bv_unsigned o11 = bv_unsigned o10 - 1%Z -> (1%Z ≤ bv_unsigned o11 + 1%Z -> (bv_unsigned o8 = svalue_sub (bv_unsigned b) (pelts sp) (offset sp + bv_signed j1) (offset sp + bv_signed o9) ∧ (1%Z ≤ 1%Z ∧ 1%Z ≤ bv_unsigned (BaseInfo.exp info)) ∧ bv_signed o9 = bv_signed j1 + 1%Z) ∧ (∀(j2 : bv 32%N) (w1 : bv 64%N), (∀(k1 : bv 32%N), let k2 : Z := bv_unsigned k1 in (1%Z ≤ k2 ∧ k2 ≤ bv_unsigned o11) ∧ bv_unsigned w1 = svalue_sub (bv_unsigned b) (pelts sp) (offset sp + bv_signed j1) (offset sp + bv_signed j2) ∧ (1%Z ≤ k2 ∧ k2 ≤ bv_unsigned (BaseInfo.exp info)) ∧ bv_signed j2 = bv_signed j1 + k2 -> (min sp ≤ offset sp + bv_signed j2 ∧ offset sp + bv_signed j2 < C.max sp) ∧ (∀(sj : bv 64%N), bv_unsigned sj = bv_signed (pelts sp (offset sp + bv_signed j2)) -> uint'64_in_bounds (bv_unsigned w1 * bv_unsigned b) ∧ (∀(o12 : bv 64%N), bv_unsigned o12 = bv_unsigned w1 * bv_unsigned b -> uint'64_in_bounds (bv_unsigned o12 + bv_unsigned sj) ∧ (∀(o13 : bv 64%N), bv_unsigned o13 = bv_unsigned o12 + bv_unsigned sj -> int'32_in_bounds (bv_signed j2 + 1%Z) ∧ (∀(o14 : bv 32%N), bv_signed o14 = bv_signed j2 + 1%Z -> bv_unsigned o13 = svalue_sub (bv_unsigned b) (pelts sp) (offset sp + bv_signed j1) (offset sp + bv_signed o14) ∧ (1%Z ≤ k2 + 1%Z ∧ k2 + 1%Z ≤ bv_unsigned (BaseInfo.exp info)) ∧ bv_signed o14 = bv_signed j1 + (k2 + 1%Z)))))) ∧ (bv_unsigned w1 = svalue_sub (bv_unsigned b) (pelts sp) (offset sp + bv_signed j1) (offset sp + bv_signed j2) ∧ (1%Z ≤ bv_unsigned o11 + 1%Z ∧ bv_unsigned o11 + 1%Z ≤ bv_unsigned (BaseInfo.exp info)) ∧ bv_signed j2 = bv_signed j1 + (bv_unsigned o11 + 1%Z) -> (valid rp2 (bv_signed rn) ∧ writable rp2 = true) ∧ (∀(rp3 : ptr (bv 64%N)), length (data rp3) = length (data rp2) ∧ offset rp3 = offset rp2 ∧ min rp3 = min rp2 ∧ C.max rp3 = C.max rp2 ∧ writable rp3 = writable rp2 ∧ zone1 rp3 = zone1 rp2 -> (∀(o12 : bv 64%N), value rp3 (bv_signed rn) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed rn) * bv_unsigned o12 = value rp2 (bv_signed rn) * bv_unsigned (bb info) ∧ (∀(j3 : Z), j3 < offset rp3 ∨ offset rp3 + bv_signed rn ≤ j3 -> pelts rp3 j3 = pelts rp2 j3) -> (valid rp3 (bv_signed rn) ∧ 0%Z < bv_signed rn ∧ writable rp3 = true) ∧ (∀(rp4 : ptr (bv 64%N)), length (data rp4) = length (data rp3) ∧ offset rp4 = offset rp3 ∧ min rp4 = min rp3 ∧ C.max rp4 = C.max rp3 ∧ writable rp4 = writable rp3 ∧ zone1 rp4 = zone1 rp3 -> (∀(cy1 : bv 64%N), value rp4 (bv_signed rn) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed rn) * bv_unsigned cy1 = value rp3 (bv_signed rn) + bv_unsigned w1 ∧ (0%Z ≤ bv_unsigned cy1 ∧ bv_unsigned cy1 ≤ 1%Z) ∧ (∀(j3 : Z), j3 < offset rp4 ∨ offset rp4 + bv_signed rn ≤ j3 -> pelts rp4 j3 = pelts rp3 j3) -> uint'64_in_bounds (bv_unsigned o12 + bv_unsigned cy1) ∧ (∀(o13 : bv 64%N), bv_unsigned o13 = bv_unsigned o12 + bv_unsigned cy1 -> (if decide (0%Z < bv_unsigned o13) then ((min rp4 ≤ offset rp4 + bv_signed rn ∧ offset rp4 + bv_signed rn < C.max rp4) ∧ writable rp4 = true) ∧ (∀(rp5 : ptr (bv 64%N)), length (data rp5) = length (data rp4) ∧ offset rp5 = offset rp4 ∧ min rp5 = min rp4 ∧ C.max rp5 = C.max rp4 ∧ writable rp5 = writable rp4 ∧ zone1 rp5 = zone1 rp4 -> pelts rp5 = fun_updt (pelts rp4) (offset rp5 + bv_signed rn) o13 ∧ pelts rp5 (offset rp5 + bv_signed rn) = o13 -> int'32_in_bounds (bv_signed rn + 1%Z) ∧ (∀(o14 : bv 32%N), bv_signed o14 = bv_signed rn + 1%Z -> (0%Z ≤ bv_unsigned sn - bv_signed j1 ∧ bv_unsigned sn - bv_signed j2 < bv_unsigned sn - bv_signed j1) ∧ (0%Z ≤ bv_signed j2 ∧ bv_signed j2 ≤ bv_unsigned sn) ∧ value rp5 (bv_signed o14) = svalue_sub (bv_unsigned b) (pelts sp) (offset sp) (offset sp + bv_signed j2) ∧ bv_signed j2 ≤ bv_unsigned sn ∧ (0%Z ≤ bv_signed o14 ∧ bv_signed o14 ≤ bv_signed sz) ∧ (0%Z < svalue (bv_unsigned b) sp (bv_signed j2) -> 0%Z < bv_unsigned (pelts rp5 (offset rp5 + bv_signed o14 - 1%Z))) ∧ (svalue (bv_unsigned b) sp (bv_signed j2) = 0%Z -> bv_signed o14 = 1%Z) ∧ ZEuclid.modulo (bv_unsigned sn - bv_signed j2) (bv_unsigned (BaseInfo.exp info)) = 0%Z)) else (0%Z ≤ bv_unsigned sn - bv_signed j1 ∧ bv_unsigned sn - bv_signed j2 < bv_unsigned sn - bv_signed j1) ∧ (0%Z ≤ bv_signed j2 ∧ bv_signed j2 ≤ bv_unsigned sn) ∧ value rp4 (bv_signed rn) = svalue_sub (bv_unsigned b) (pelts sp) (offset sp) (offset sp + bv_signed j2) ∧ bv_signed j2 ≤ bv_unsigned sn ∧ (0%Z ≤ bv_signed rn ∧ bv_signed rn ≤ bv_signed sz) ∧ (0%Z < svalue (bv_unsigned b) sp (bv_signed j2) -> 0%Z < bv_unsigned (pelts rp4 (offset rp4 + bv_signed rn - 1%Z))) ∧ (svalue (bv_unsigned b) sp (bv_signed j2) = 0%Z -> bv_signed rn = 1%Z) ∧ ZEuclid.modulo (bv_unsigned sn - bv_signed j2) (bv_unsigned (BaseInfo.exp info)) = 0%Z))))))))) ∧ (bv_unsigned o11 + 1%Z < 1%Z -> (valid rp2 (bv_signed rn) ∧ writable rp2 = true) ∧ (∀(rp3 : ptr (bv 64%N)), length (data rp3) = length (data rp2) ∧ offset rp3 = offset rp2 ∧ min rp3 = min rp2 ∧ C.max rp3 = C.max rp2 ∧ writable rp3 = writable rp2 ∧ zone1 rp3 = zone1 rp2 -> (∀(o12 : bv 64%N), value rp3 (bv_signed rn) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed rn) * bv_unsigned o12 = value rp2 (bv_signed rn) * bv_unsigned (bb info) ∧ (∀(j2 : Z), j2 < offset rp3 ∨ offset rp3 + bv_signed rn ≤ j2 -> pelts rp3 j2 = pelts rp2 j2) -> (valid rp3 (bv_signed rn) ∧ 0%Z < bv_signed rn ∧ writable rp3 = true) ∧ (∀(rp4 : ptr (bv 64%N)), length (data rp4) = length (data rp3) ∧ offset rp4 = offset rp3 ∧ min rp4 = min rp3 ∧ C.max rp4 = C.max rp3 ∧ writable rp4 = writable rp3 ∧ zone1 rp4 = zone1 rp3 -> (∀(cy1 : bv 64%N), value rp4 (bv_signed rn) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed rn) * bv_unsigned cy1 = value rp3 (bv_signed rn) + bv_unsigned o8 ∧ (0%Z ≤ bv_unsigned cy1 ∧ bv_unsigned cy1 ≤ 1%Z) ∧ (∀(j2 : Z), j2 < offset rp4 ∨ offset rp4 + bv_signed rn ≤ j2 -> pelts rp4 j2 = pelts rp3 j2) -> uint'64_in_bounds (bv_unsigned o12 + bv_unsigned cy1) ∧ (∀(o13 : bv 64%N), bv_unsigned o13 = bv_unsigned o12 + bv_unsigned cy1 -> (if decide (0%Z < bv_unsigned o13) then ((min rp4 ≤ offset rp4 + bv_signed rn ∧ offset rp4 + bv_signed rn < C.max rp4) ∧ writable rp4 = true) ∧ (∀(rp5 : ptr (bv 64%N)), length (data rp5) = length (data rp4) ∧ offset rp5 = offset rp4 ∧ min rp5 = min rp4 ∧ C.max rp5 = C.max rp4 ∧ writable rp5 = writable rp4 ∧ zone1 rp5 = zone1 rp4 -> pelts rp5 = fun_updt (pelts rp4) (offset rp5 + bv_signed rn) o13 ∧ pelts rp5 (offset rp5 + bv_signed rn) = o13 -> int'32_in_bounds (bv_signed rn + 1%Z) ∧ (∀(o14 : bv 32%N), bv_signed o14 = bv_signed rn + 1%Z -> (0%Z ≤ bv_unsigned sn - bv_signed j1 ∧ bv_unsigned sn - bv_signed o9 < bv_unsigned sn - bv_signed j1) ∧ (0%Z ≤ bv_signed o9 ∧ bv_signed o9 ≤ bv_unsigned sn) ∧ value rp5 (bv_signed o14) = svalue_sub (bv_unsigned b) (pelts sp) (offset sp) (offset sp + bv_signed o9) ∧ bv_signed o9 ≤ bv_unsigned sn ∧ (0%Z ≤ bv_signed o14 ∧ bv_signed o14 ≤ bv_signed sz) ∧ (0%Z < svalue (bv_unsigned b) sp (bv_signed o9) -> 0%Z < bv_unsigned (pelts rp5 (offset rp5 + bv_signed o14 - 1%Z))) ∧ (svalue (bv_unsigned b) sp (bv_signed o9) = 0%Z -> bv_signed o14 = 1%Z) ∧ ZEuclid.modulo (bv_unsigned sn - bv_signed o9) (bv_unsigned (BaseInfo.exp info)) = 0%Z)) else (0%Z ≤ bv_unsigned sn - bv_signed j1 ∧ bv_unsigned sn - bv_signed o9 < bv_unsigned sn - bv_signed j1) ∧ (0%Z ≤ bv_signed o9 ∧ bv_signed o9 ≤ bv_unsigned sn) ∧ value rp4 (bv_signed rn) = svalue_sub (bv_unsigned b) (pelts sp) (offset sp) (offset sp + bv_signed o9) ∧ bv_signed o9 ≤ bv_unsigned sn ∧ (0%Z ≤ bv_signed rn ∧ bv_signed rn ≤ bv_signed sz) ∧ (0%Z < svalue (bv_unsigned b) sp (bv_signed o9) -> 0%Z < bv_unsigned (pelts rp4 (offset rp4 + bv_signed rn - 1%Z))) ∧ (svalue (bv_unsigned b) sp (bv_signed o9) = 0%Z -> bv_signed rn = 1%Z) ∧ ZEuclid.modulo (bv_unsigned sn - bv_signed o9) (bv_unsigned (BaseInfo.exp info)) = 0%Z))))))))))) else (0%Z < svalue (bv_unsigned b) sp (bv_unsigned sn) -> 1%Z ≤ bv_signed rn ∧ bv_signed rn ≤ bv_signed sz) ∧ value rp2 (bv_signed rn) = svalue (bv_unsigned b) sp (bv_unsigned sn) ∧ (0%Z < svalue (bv_unsigned b) sp (bv_unsigned sn) -> 0%Z < bv_unsigned (pelts rp2 (offset rp2 + bv_signed rn - 1%Z))) ∧ (svalue (bv_unsigned b) sp (bv_unsigned sn) = 0%Z -> bv_signed rn = 1%Z) ∧ 0%Z < bv_signed rn))))))))))).
Proof.
Admitted.
