(* ---------------------------------------------------------- *)
(* --- Complete behaviors 'a22_max', 'a11_max', 'a00_max', 'trace_pos' --- *)
(* ---------------------------------------------------------- *)
theory VCfloat_quat_of_rmat_complete_a22_max_a11_max_a00_max_trace___
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic15.Axiomatic15
use import Axiomatic17.Axiomatic17
use import Qed.Qed
use import int.Abs as IAbs
use import Cmath.Cmath
use import real.Abs as RAbs
use import Cfloat.Cfloat
use import Compound.Compound
use import Axiomatic19.Axiomatic19

(*
goal WP "expl:Complete behaviors 'a22_max', 'a11_max', 'a00_max', 'trace_pos'":
*)
goal goal0:
  forall t : map int int.
  forall t_1 : map addr real.
  forall a_1 a : addr.
  let a_2 = (l_l_rmat_of_floatrmat t_1 a) in
  let a_3 = (shiftfield_f5_floatrmat_m a) in
  let r = t_1[(shift_float32 a_3 0)] in
  let r_1 = t_1[(shift_float32 a_3 4)] in
  let r_2 = t_1[(shift_float32 a_3 8)] in
  let r_3 = (l_trace_2_ t_1 a) in
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((valid_rw t a_1 4)) ->
  ((p_rvalid_floatrmat t t_1 a)) ->
  ((separated a 9 a_1 4)) ->
  ((p_rotation_matrix a_2)) ->
  ((p_special_orthogonal a_2)) ->
  ((is_float32 r)) ->
  ((is_float32 r_1)) ->
  ((is_float32 r_2)) ->
  ((0.0 <. r_3) \/ ((r_3 <=. 0.0) /\ (r_1 <. r) /\ (r_2 <. r)) \/
   ((r_3 <=. 0.0) /\ (r <=. r_1) /\ (r_2 <. r_1)) \/
   ((r_3 <=. 0.0) /\ (r <=. r_2) /\ (r_1 <=. r_2)))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition 'finite_arg' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qi' (file math/pprz_algebra_float.c, line 619)
 --- *)
(* ---------------------------------------------------------- *)
theory VCfloat_quat_of_rmat_call_sqrtf_pre_finite_arg
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Qed.Qed
use import int.Abs as IAbs
use import Cmath.Cmath
use import real.Abs as RAbs
use import Cfloat.Cfloat
use import Compound.Compound
use import Axiomatic15.Axiomatic15
use import Axiomatic17.Axiomatic17

(*
goal WP "expl:Instance of 'Pre-condition 'finite_arg' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qi' (file math/pprz_algebra_float.c, line 619)
":
*)
goal goal1:
  forall t : map int int.
  forall t_1 : map addr real.
  forall a_1 a : addr.
  let a_2 = (shiftfield_f5_floatrmat_m a) in
  let r = t_1[(shift_float32 a_2 0)] in
  let r_1 = t_1[(shift_float32 a_2 4)] in
  let r_2 = t_1[(shift_float32 a_2 8)] in
  let r_3 = (add_float32 ((add_float32 r r_1)) r_2) in
  let a_3 = (l_l_rmat_of_floatrmat t_1 a) in
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (0.0 <. r_3) ->
  ((linked t)) ->
  ((valid_rw t a_1 4)) ->
  ((p_rvalid_floatrmat t t_1 a)) ->
  ((separated a 9 a_1 4)) ->
  ((p_rotation_matrix a_3)) ->
  ((p_special_orthogonal a_3)) ->
  ((is_float32 r)) ->
  ((is_float32 r_1)) ->
  ((is_float32 r_2)) ->
  ((is_float32 r_3)) ->
  ((is_finite32 ((to_float32 ((add_float64 1.0 ((to_float64 r_3))))))))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition 'arg_positive' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qi' (file math/pprz_algebra_float.c, line 619)
 --- *)
(* ---------------------------------------------------------- *)
theory VCfloat_quat_of_rmat_call_sqrtf_pre_arg_positive
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Qed.Qed
use import int.Abs as IAbs
use import Cmath.Cmath
use import real.Abs as RAbs
use import Cfloat.Cfloat
use import Compound.Compound
use import Axiomatic15.Axiomatic15
use import Axiomatic17.Axiomatic17

(*
goal WP "expl:Instance of 'Pre-condition 'arg_positive' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qi' (file math/pprz_algebra_float.c, line 619)
":
*)
goal goal2:
  forall t : map int int.
  forall t_1 : map addr real.
  forall a_1 a : addr.
  let a_2 = (shiftfield_f5_floatrmat_m a) in
  let r = t_1[(shift_float32 a_2 0)] in
  let r_1 = t_1[(shift_float32 a_2 4)] in
  let r_2 = t_1[(shift_float32 a_2 8)] in
  let r_3 = (add_float32 ((add_float32 r r_1)) r_2) in
  let a_3 = (l_l_rmat_of_floatrmat t_1 a) in
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (0.0 <. r_3) ->
  ((linked t)) ->
  ((valid_rw t a_1 4)) ->
  ((p_rvalid_floatrmat t t_1 a)) ->
  ((separated a 9 a_1 4)) ->
  ((p_rotation_matrix a_3)) ->
  ((p_special_orthogonal a_3)) ->
  ((is_float32 r)) ->
  ((is_float32 r_1)) ->
  ((is_float32 r_2)) ->
  ((is_float32 r_3)) ->
  (0.0 <=. ((to_float32 ((add_float64 1.0 ((to_float64 r_3)))))))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition 'finite_arg' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qx' (file math/pprz_algebra_float.c, line 629)
 --- *)
(* ---------------------------------------------------------- *)
theory VCfloat_quat_of_rmat_call_sqrtf_pre_finite_arg_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Qed.Qed
use import int.Abs as IAbs
use import Cmath.Cmath
use import real.Abs as RAbs
use import Cfloat.Cfloat
use import Axiomatic15.Axiomatic15
use import Axiomatic17.Axiomatic17

(*
goal WP "expl:Instance of 'Pre-condition 'finite_arg' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qx' (file math/pprz_algebra_float.c, line 629)
":
*)
goal goal3:
  forall t : map int int.
  forall t_1 : map addr real.
  forall a_1 a : addr.
  let a_2 = (shiftfield_f5_floatrmat_m a) in
  let r = t_1[(shift_float32 a_2 4)] in
  let r_1 = t_1[(shift_float32 a_2 0)] in
  let r_2 = t_1[(shift_float32 a_2 8)] in
  let r_3 = (add_float32 ((add_float32 r_1 r)) r_2) in
  let a_3 = (l_l_rmat_of_floatrmat t_1 a) in
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (r <. r_1) ->
  (r_2 <. r_1) ->
  (r_3 <=. 0.0) ->
  ((linked t)) ->
  ((valid_rw t a_1 4)) ->
  ((p_rvalid_floatrmat t t_1 a)) ->
  ((separated a 9 a_1 4)) ->
  ((p_rotation_matrix a_3)) ->
  ((p_special_orthogonal a_3)) ->
  ((is_float32 r_1)) ->
  ((is_float32 r)) ->
  ((is_float32 t_1[(shift_float32 a_2 5)])) ->
  ((is_float32 t_1[(shift_float32 a_2 7)])) ->
  ((is_float32 r_2)) ->
  ((is_float32 r_3)) ->
  ((is_finite32
     ((add_float32 ((add_float32 ((add_float32 r_1 (-. r))) (-. r_2))) 1.0))))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition 'arg_positive' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qx' (file math/pprz_algebra_float.c, line 629)
 --- *)
(* ---------------------------------------------------------- *)
theory VCfloat_quat_of_rmat_call_sqrtf_pre_arg_positive_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Qed.Qed
use import int.Abs as IAbs
use import Cmath.Cmath
use import real.Abs as RAbs
use import Cfloat.Cfloat
use import Axiomatic15.Axiomatic15
use import Axiomatic17.Axiomatic17

(*
goal WP "expl:Instance of 'Pre-condition 'arg_positive' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qx' (file math/pprz_algebra_float.c, line 629)
":
*)
goal goal4:
  forall t : map int int.
  forall t_1 : map addr real.
  forall a_1 a : addr.
  let a_2 = (shiftfield_f5_floatrmat_m a) in
  let r = t_1[(shift_float32 a_2 4)] in
  let r_1 = t_1[(shift_float32 a_2 0)] in
  let r_2 = t_1[(shift_float32 a_2 8)] in
  let r_3 = (add_float32 ((add_float32 r_1 r)) r_2) in
  let a_3 = (l_l_rmat_of_floatrmat t_1 a) in
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (r <. r_1) ->
  (r_2 <. r_1) ->
  (r_3 <=. 0.0) ->
  ((linked t)) ->
  ((valid_rw t a_1 4)) ->
  ((p_rvalid_floatrmat t t_1 a)) ->
  ((separated a 9 a_1 4)) ->
  ((p_rotation_matrix a_3)) ->
  ((p_special_orthogonal a_3)) ->
  ((is_float32 r_1)) ->
  ((is_float32 r)) ->
  ((is_float32 t_1[(shift_float32 a_2 5)])) ->
  ((is_float32 t_1[(shift_float32 a_2 7)])) ->
  ((is_float32 r_2)) ->
  ((is_float32 r_3)) ->
  (0.0
     <=. ((add_float32 ((add_float32 ((add_float32 r_1 (-. r))) (-. r_2)))
            1.0)))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition 'finite_arg' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qy' (file math/pprz_algebra_float.c, line 639)
 --- *)
(* ---------------------------------------------------------- *)
theory VCfloat_quat_of_rmat_call_sqrtf_pre_finite_arg_3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Qed.Qed
use import int.Abs as IAbs
use import Cmath.Cmath
use import real.Abs as RAbs
use import Cfloat.Cfloat
use import Axiomatic15.Axiomatic15
use import Axiomatic17.Axiomatic17

(*
goal WP "expl:Instance of 'Pre-condition 'finite_arg' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qy' (file math/pprz_algebra_float.c, line 639)
":
*)
goal goal5:
  forall t : map int int.
  forall t_1 : map addr real.
  forall a_1 a : addr.
  let a_2 = (shiftfield_f5_floatrmat_m a) in
  let r = t_1[(shift_float32 a_2 8)] in
  let r_1 = t_1[(shift_float32 a_2 4)] in
  let r_2 = t_1[(shift_float32 a_2 0)] in
  let r_3 = (add_float32 ((add_float32 r_2 r_1)) r) in
  let a_3 = (l_l_rmat_of_floatrmat t_1 a) in
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (r <. r_1) ->
  (r_3 <=. 0.0) ->
  ((linked t)) ->
  ((valid_rw t a_1 4)) ->
  ((p_rvalid_floatrmat t t_1 a)) ->
  ((separated a 9 a_1 4)) ->
  ((p_rotation_matrix a_3)) ->
  ((p_special_orthogonal a_3)) ->
  ((is_float32 r_2)) ->
  ((is_float32 t_1[(shift_float32 a_2 2)])) ->
  ((is_float32 r_1)) ->
  ((is_float32 t_1[(shift_float32 a_2 6)])) ->
  ((is_float32 r)) ->
  ((is_float32 r_3)) ->
  ((r_2 <=. r_1) \/ (r_2 <=. r)) ->
  ((is_finite32
     ((add_float32 ((add_float32 ((add_float32 r_1 (-. r_2))) (-. r))) 1.0))))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition 'arg_positive' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qy' (file math/pprz_algebra_float.c, line 639)
 --- *)
(* ---------------------------------------------------------- *)
theory VCfloat_quat_of_rmat_call_sqrtf_pre_arg_positive_3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Qed.Qed
use import int.Abs as IAbs
use import Cmath.Cmath
use import real.Abs as RAbs
use import Cfloat.Cfloat
use import Axiomatic15.Axiomatic15
use import Axiomatic17.Axiomatic17

(*
goal WP "expl:Instance of 'Pre-condition 'arg_positive' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qy' (file math/pprz_algebra_float.c, line 639)
":
*)
goal goal6:
  forall t : map int int.
  forall t_1 : map addr real.
  forall a_1 a : addr.
  let a_2 = (shiftfield_f5_floatrmat_m a) in
  let r = t_1[(shift_float32 a_2 8)] in
  let r_1 = t_1[(shift_float32 a_2 4)] in
  let r_2 = t_1[(shift_float32 a_2 0)] in
  let r_3 = (add_float32 ((add_float32 r_2 r_1)) r) in
  let a_3 = (l_l_rmat_of_floatrmat t_1 a) in
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (r <. r_1) ->
  (r_3 <=. 0.0) ->
  ((linked t)) ->
  ((valid_rw t a_1 4)) ->
  ((p_rvalid_floatrmat t t_1 a)) ->
  ((separated a 9 a_1 4)) ->
  ((p_rotation_matrix a_3)) ->
  ((p_special_orthogonal a_3)) ->
  ((is_float32 r_2)) ->
  ((is_float32 t_1[(shift_float32 a_2 2)])) ->
  ((is_float32 r_1)) ->
  ((is_float32 t_1[(shift_float32 a_2 6)])) ->
  ((is_float32 r)) ->
  ((is_float32 r_3)) ->
  ((r_2 <=. r_1) \/ (r_2 <=. r)) ->
  (0.0
     <=. ((add_float32 ((add_float32 ((add_float32 r_1 (-. r_2))) (-. r)))
            1.0)))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition 'finite_arg' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qz' (file math/pprz_algebra_float.c, line 648)
 --- *)
(* ---------------------------------------------------------- *)
theory VCfloat_quat_of_rmat_call_sqrtf_pre_finite_arg_4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Qed.Qed
use import int.Abs as IAbs
use import Cmath.Cmath
use import real.Abs as RAbs
use import Cfloat.Cfloat
use import Axiomatic15.Axiomatic15
use import Axiomatic17.Axiomatic17

(*
goal WP "expl:Instance of 'Pre-condition 'finite_arg' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qz' (file math/pprz_algebra_float.c, line 648)
":
*)
goal goal7:
  forall t : map int int.
  forall t_1 : map addr real.
  forall a_1 a : addr.
  let a_2 = (shiftfield_f5_floatrmat_m a) in
  let r = t_1[(shift_float32 a_2 4)] in
  let r_1 = t_1[(shift_float32 a_2 8)] in
  let r_2 = t_1[(shift_float32 a_2 0)] in
  let r_3 = (add_float32 ((add_float32 r_2 r)) r_1) in
  let a_3 = (l_l_rmat_of_floatrmat t_1 a) in
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (r <=. r_1) ->
  (r_3 <=. 0.0) ->
  ((linked t)) ->
  ((valid_rw t a_1 4)) ->
  ((p_rvalid_floatrmat t t_1 a)) ->
  ((separated a 9 a_1 4)) ->
  ((p_rotation_matrix a_3)) ->
  ((p_special_orthogonal a_3)) ->
  ((is_float32 r_2)) ->
  ((is_float32 t_1[(shift_float32 a_2 1)])) ->
  ((is_float32 t_1[(shift_float32 a_2 3)])) ->
  ((is_float32 r)) ->
  ((is_float32 r_1)) ->
  ((is_float32 r_3)) ->
  ((r_2 <=. r) \/ (r_2 <=. r_1)) ->
  ((is_finite32
     ((add_float32 ((add_float32 ((add_float32 r_1 (-. r_2))) (-. r))) 1.0))))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition 'arg_positive' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qz' (file math/pprz_algebra_float.c, line 648)
 --- *)
(* ---------------------------------------------------------- *)
theory VCfloat_quat_of_rmat_call_sqrtf_pre_arg_positive_4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Qed.Qed
use import int.Abs as IAbs
use import Cmath.Cmath
use import real.Abs as RAbs
use import Cfloat.Cfloat
use import Axiomatic15.Axiomatic15
use import Axiomatic17.Axiomatic17

(*
goal WP "expl:Instance of 'Pre-condition 'arg_positive' in 'sqrtf'' in 'float_quat_of_rmat' at initialization of 'two_qz' (file math/pprz_algebra_float.c, line 648)
":
*)
goal goal8:
  forall t : map int int.
  forall t_1 : map addr real.
  forall a_1 a : addr.
  let a_2 = (shiftfield_f5_floatrmat_m a) in
  let r = t_1[(shift_float32 a_2 4)] in
  let r_1 = t_1[(shift_float32 a_2 8)] in
  let r_2 = t_1[(shift_float32 a_2 0)] in
  let r_3 = (add_float32 ((add_float32 r_2 r)) r_1) in
  let a_3 = (l_l_rmat_of_floatrmat t_1 a) in
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (r <=. r_1) ->
  (r_3 <=. 0.0) ->
  ((linked t)) ->
  ((valid_rw t a_1 4)) ->
  ((p_rvalid_floatrmat t t_1 a)) ->
  ((separated a 9 a_1 4)) ->
  ((p_rotation_matrix a_3)) ->
  ((p_special_orthogonal a_3)) ->
  ((is_float32 r_2)) ->
  ((is_float32 t_1[(shift_float32 a_2 1)])) ->
  ((is_float32 t_1[(shift_float32 a_2 3)])) ->
  ((is_float32 r)) ->
  ((is_float32 r_1)) ->
  ((is_float32 r_3)) ->
  ((r_2 <=. r) \/ (r_2 <=. r_1)) ->
  (0.0
     <=. ((add_float32 ((add_float32 ((add_float32 r_1 (-. r_2))) (-. r)))
            1.0)))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'a00_max' (file math/pprz_algebra_float.h, line 948) in 'float_quat_of_rmat' --- *)
(* ---------------------------------------------------------- *)
theory VCfloat_quat_of_rmat_a00_max_post
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic19.Axiomatic19
use import Compound.Compound
use import Qed.Qed
use import int.Abs as IAbs
use import Cmath.Cmath
use import real.Abs as RAbs
use import Cfloat.Cfloat
use import Axiomatic15.Axiomatic15
use import Axiomatic17.Axiomatic17
use import S11_RealQuat_s.S11_RealQuat_s
use import Axiomatic18.Axiomatic18

(*
goal WP "expl:Post-condition for 'a00_max' (file math/pprz_algebra_float.h, line 948) in 'float_quat_of_rmat'":
*)
goal goal9:
  forall r_7 r_6 r_5 r_4 r_3 r_2 r_1 r : real.
  forall t : map int int.
  forall t_9 t_8 t_7 t_6 t_5 t_4 t_3 t_2 t_1 : map addr real.
  forall a_1 a : addr.
  let a_2 = (shiftfield_f5_floatrmat_m a) in
  let a_3 = (shift_float32 a_2 4) in
  let r_8 = t_1[a_3] in
  let a_4 = (shift_float32 a_2 0) in
  let r_9 = t_1[a_4] in
  let a_5 = (shift_float32 a_2 8) in
  let r_10 = t_1[a_5] in
  let a_6 = (l_l_rmat_of_floatrmat t_1 a) in
  let r_11 = (add_float32 ((add_float32 r_9 r_8)) r_10) in
  let r_12 = (to_float64 r_3) in
  let a_7 = (shiftfield_f3_floatquat_qi a_1) in
  let m = t_8[a_7 <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_12)))] in
  let a_8 = (shiftfield_f3_floatquat_qx a_1) in
  let a_9 = (shift_float32 a_2 5) in
  let a_10 = (shift_float32 a_2 7) in
  let m_1 = m[a_8 <- (div_float32 ((add_float32 m[a_9] (-. m[a_10]))) r_7)] in
  let a_11 = (shiftfield_f3_floatquat_qy a_1) in
  let a_12 = (shift_float32 a_2 6) in
  let a_13 = (shift_float32 a_2 2) in
  let m_2 = m_1[a_11
              <- (div_float32 ((add_float32 m_1[a_12] (-. m_1[a_13]))) r_7)] in
  let a_14 = (shiftfield_f3_floatquat_qz a_1) in
  let a_15 = (shift_float32 a_2 1) in
  let a_16 = (shift_float32 a_2 3) in
  let r_13 = (to_float32
               ((add_float64 1.0
                  ((to_float64
                     ((add_float32 ((add_float32 t_8[a_4] t_8[a_3]))
                        t_8[a_5]))))))) in
  let r_14 = (to_float64 r_2) in
  let m_3 = t_7[a_7
              <- (div_float32 ((add_float32 t_7[a_9] (-. t_7[a_10]))) r_6)][a_8
              <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_14)))] in
  let m_4 = m_3[a_11
              <- (div_float32 ((add_float32 m_3[a_15] m_3[a_16])) r_6)] in
  let r_15 = (add_float32
               ((add_float32 ((add_float32 t_7[a_4] (-. t_7[a_3])))
                  (-. t_7[a_5]))) 1.0) in
  let r_16 = t_4[a_5] in
  let r_17 = t_4[a_3] in
  let r_18 = (to_float64 r_1) in
  let r_19 = (to_float32 ((mul_float64 2.0 r_18))) in
  let m_5 = t_6[a_7
              <- (div_float32 ((add_float32 t_6[a_12] (-. t_6[a_13]))) r_5)] in
  let m_6 = m_5[a_8 <- (div_float32 ((add_float32 m_5[a_15] m_5[a_16])) r_5)][a_11
              <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_18)))] in
  let m_7 = m_6[a_14 <- (div_float32 ((add_float32 m_6[a_9] m_6[a_10])) r_5)] in
  let r_20 = (add_float32
               ((add_float32 ((add_float32 t_6[a_3] (-. t_6[a_4])))
                  (-. t_6[a_5]))) 1.0) in
  let r_21 = (to_float64 r) in
  let r_22 = (to_float32 ((mul_float64 2.0 r_21))) in
  let m_8 = t_5[a_7
              <- (div_float32 ((add_float32 t_5[a_15] (-. t_5[a_16]))) r_4)] in
  let m_9 = m_8[a_8 <- (div_float32 ((add_float32 m_8[a_12] m_8[a_13])) r_4)] in
  let m_10 = m_9[a_11
               <- (div_float32 ((add_float32 m_9[a_9] m_9[a_10])) r_4)][a_14
               <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_21)))] in
  let r_23 = (add_float32
               ((add_float32 ((add_float32 t_5[a_5] (-. t_5[a_4])))
                  (-. t_5[a_3]))) 1.0) in
  (((l_trace_2_ t_1 a)) <=. 0.0) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (r_8 <. r_9) ->
  (r_10 <. r_9) ->
  ((linked t)) ->
  ((is_float32 r)) ->
  ((is_float32 r_1)) ->
  ((is_float32 r_2)) ->
  ((is_float32 r_3)) ->
  ((is_float32 r_4)) ->
  ((is_float32 r_5)) ->
  ((is_float32 r_6)) ->
  ((is_float32 r_7)) ->
  ((valid_rw t a_1 4)) ->
  ((p_rvalid_floatrmat t t_1 a)) ->
  ((separated a 9 a_1 4)) ->
  ((p_rotation_matrix a_6)) ->
  ((p_special_orthogonal a_6)) ->
  ((is_float32 r_9)) ->
  ((is_float32 r_8)) ->
  ((is_float32 r_10)) ->
  ((is_float32 r_11)) ->
  (if (0.0 <. r_11)
   then ((t_8 = t_1) /\ (((to_float32 ((mul_float64 2.0 r_12)))) = r_7) /\
         (m_2[a_14
            <- (div_float32 ((add_float32 m_2[a_15] (-. m_2[a_16]))) r_7)] =
          t_9) /\ (0.0 <=. r_3) /\ (0.0 <=. r_13) /\ ((is_finite32 r_3)) /\
         ((is_finite32 r_13)))
   else ((t_2 = t_1) /\
         (if (t_2[a_3] <. t_2[a_4])
          then ((t_3 = t_2) /\
                (if (t_3[a_5] <. t_3[a_4])
                 then ((t_7 = t_3) /\
                       (((to_float32 ((mul_float64 2.0 r_14)))) = r_6) /\
                       (m_4[a_14
                          <- (div_float32 ((add_float32 m_4[a_12] m_4[a_13]))
                               r_6)] = t_9) /\ (0.0 <=. r_2) /\
                       (0.0 <=. r_15) /\ ((is_finite32 r_2)) /\
                       ((is_finite32 r_15)))
                 else ((t_4 = t_3) /\
                       (if (r_16 <. r_17)
                        then ((t_6 = t_4) /\ (r_19 = r_5) /\ (m_7 = t_9) /\
                              (0.0 <=. r_1) /\ (0.0 <=. r_20) /\
                              ((is_finite32 r_1)) /\ ((is_finite32 r_20)))
                        else ((t_5 = t_4) /\ (r_22 = r_4) /\ (m_10 = t_9) /\
                              (0.0 <=. r) /\ (0.0 <=. r_23) /\
                              ((is_finite32 r)) /\ ((is_finite32 r_23)))))))
          else ((t_4 = t_2) /\
                (if (r_16 <. r_17)
                 then ((t_6 = t_4) /\ (r_19 = r_5) /\ (m_7 = t_9) /\
                       (0.0 <=. r_1) /\ (0.0 <=. r_20) /\
                       ((is_finite32 r_1)) /\ ((is_finite32 r_20)))
                 else ((t_5 = t_4) /\ (r_22 = r_4) /\ (m_10 = t_9) /\
                       (0.0 <=. r) /\ (0.0 <=. r_23) /\ ((is_finite32 r)) /\
                       ((is_finite32 r_23)))))))) ->
  ((eqs11_realquat_s ((l_l_floatquat_of_rmat_0_max_t t_9 a))
     ((l_l_quat_of_floatquat t_9 a_1))))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'a11_max' (file math/pprz_algebra_float.h, line 954) in 'float_quat_of_rmat' --- *)
(* ---------------------------------------------------------- *)
theory VCfloat_quat_of_rmat_a11_max_post
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic19.Axiomatic19
use import Compound.Compound
use import Qed.Qed
use import int.Abs as IAbs
use import Cmath.Cmath
use import real.Abs as RAbs
use import Cfloat.Cfloat
use import Axiomatic15.Axiomatic15
use import Axiomatic17.Axiomatic17
use import S11_RealQuat_s.S11_RealQuat_s
use import Axiomatic18.Axiomatic18

(*
goal WP "expl:Post-condition for 'a11_max' (file math/pprz_algebra_float.h, line 954) in 'float_quat_of_rmat'":
*)
goal goal10:
  forall r_7 r_6 r_5 r_4 r_3 r_2 r_1 r : real.
  forall t : map int int.
  forall t_9 t_8 t_7 t_6 t_5 t_4 t_3 t_2 t_1 : map addr real.
  forall a_1 a : addr.
  let a_2 = (shiftfield_f5_floatrmat_m a) in
  let a_3 = (shift_float32 a_2 0) in
  let r_8 = t_1[a_3] in
  let a_4 = (shift_float32 a_2 4) in
  let r_9 = t_1[a_4] in
  let a_5 = (shift_float32 a_2 8) in
  let r_10 = t_1[a_5] in
  let a_6 = (l_l_rmat_of_floatrmat t_1 a) in
  let r_11 = (add_float32 ((add_float32 r_8 r_9)) r_10) in
  let r_12 = (to_float64 r_3) in
  let a_7 = (shiftfield_f3_floatquat_qi a_1) in
  let m = t_8[a_7 <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_12)))] in
  let a_8 = (shiftfield_f3_floatquat_qx a_1) in
  let a_9 = (shift_float32 a_2 5) in
  let a_10 = (shift_float32 a_2 7) in
  let m_1 = m[a_8 <- (div_float32 ((add_float32 m[a_9] (-. m[a_10]))) r_7)] in
  let a_11 = (shiftfield_f3_floatquat_qy a_1) in
  let a_12 = (shift_float32 a_2 6) in
  let a_13 = (shift_float32 a_2 2) in
  let m_2 = m_1[a_11
              <- (div_float32 ((add_float32 m_1[a_12] (-. m_1[a_13]))) r_7)] in
  let a_14 = (shiftfield_f3_floatquat_qz a_1) in
  let a_15 = (shift_float32 a_2 1) in
  let a_16 = (shift_float32 a_2 3) in
  let r_13 = (to_float32
               ((add_float64 1.0
                  ((to_float64
                     ((add_float32 ((add_float32 t_8[a_3] t_8[a_4]))
                        t_8[a_5]))))))) in
  let r_14 = (to_float64 r_2) in
  let m_3 = t_7[a_7
              <- (div_float32 ((add_float32 t_7[a_9] (-. t_7[a_10]))) r_6)][a_8
              <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_14)))] in
  let m_4 = m_3[a_11
              <- (div_float32 ((add_float32 m_3[a_15] m_3[a_16])) r_6)] in
  let r_15 = (add_float32
               ((add_float32 ((add_float32 t_7[a_3] (-. t_7[a_4])))
                  (-. t_7[a_5]))) 1.0) in
  let r_16 = t_4[a_5] in
  let r_17 = t_4[a_4] in
  let r_18 = (to_float64 r_1) in
  let r_19 = (to_float32 ((mul_float64 2.0 r_18))) in
  let m_5 = t_6[a_7
              <- (div_float32 ((add_float32 t_6[a_12] (-. t_6[a_13]))) r_5)] in
  let m_6 = m_5[a_8 <- (div_float32 ((add_float32 m_5[a_15] m_5[a_16])) r_5)][a_11
              <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_18)))] in
  let m_7 = m_6[a_14 <- (div_float32 ((add_float32 m_6[a_9] m_6[a_10])) r_5)] in
  let r_20 = (add_float32
               ((add_float32 ((add_float32 t_6[a_4] (-. t_6[a_3])))
                  (-. t_6[a_5]))) 1.0) in
  let r_21 = (to_float64 r) in
  let r_22 = (to_float32 ((mul_float64 2.0 r_21))) in
  let m_8 = t_5[a_7
              <- (div_float32 ((add_float32 t_5[a_15] (-. t_5[a_16]))) r_4)] in
  let m_9 = m_8[a_8 <- (div_float32 ((add_float32 m_8[a_12] m_8[a_13])) r_4)] in
  let m_10 = m_9[a_11
               <- (div_float32 ((add_float32 m_9[a_9] m_9[a_10])) r_4)][a_14
               <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_21)))] in
  let r_23 = (add_float32
               ((add_float32 ((add_float32 t_5[a_5] (-. t_5[a_3])))
                  (-. t_5[a_4]))) 1.0) in
  (((l_trace_2_ t_1 a)) <=. 0.0) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (r_8 <=. r_9) ->
  (r_10 <. r_9) ->
  ((linked t)) ->
  ((is_float32 r)) ->
  ((is_float32 r_1)) ->
  ((is_float32 r_2)) ->
  ((is_float32 r_3)) ->
  ((is_float32 r_4)) ->
  ((is_float32 r_5)) ->
  ((is_float32 r_6)) ->
  ((is_float32 r_7)) ->
  ((valid_rw t a_1 4)) ->
  ((p_rvalid_floatrmat t t_1 a)) ->
  ((separated a 9 a_1 4)) ->
  ((p_rotation_matrix a_6)) ->
  ((p_special_orthogonal a_6)) ->
  ((is_float32 r_8)) ->
  ((is_float32 r_9)) ->
  ((is_float32 r_10)) ->
  ((is_float32 r_11)) ->
  (if (0.0 <. r_11)
   then ((t_8 = t_1) /\ (((to_float32 ((mul_float64 2.0 r_12)))) = r_7) /\
         (m_2[a_14
            <- (div_float32 ((add_float32 m_2[a_15] (-. m_2[a_16]))) r_7)] =
          t_9) /\ (0.0 <=. r_3) /\ (0.0 <=. r_13) /\ ((is_finite32 r_3)) /\
         ((is_finite32 r_13)))
   else ((t_2 = t_1) /\
         (if (t_2[a_4] <. t_2[a_3])
          then ((t_3 = t_2) /\
                (if (t_3[a_5] <. t_3[a_3])
                 then ((t_7 = t_3) /\
                       (((to_float32 ((mul_float64 2.0 r_14)))) = r_6) /\
                       (m_4[a_14
                          <- (div_float32 ((add_float32 m_4[a_12] m_4[a_13]))
                               r_6)] = t_9) /\ (0.0 <=. r_2) /\
                       (0.0 <=. r_15) /\ ((is_finite32 r_2)) /\
                       ((is_finite32 r_15)))
                 else ((t_4 = t_3) /\
                       (if (r_16 <. r_17)
                        then ((t_6 = t_4) /\ (r_19 = r_5) /\ (m_7 = t_9) /\
                              (0.0 <=. r_1) /\ (0.0 <=. r_20) /\
                              ((is_finite32 r_1)) /\ ((is_finite32 r_20)))
                        else ((t_5 = t_4) /\ (r_22 = r_4) /\ (m_10 = t_9) /\
                              (0.0 <=. r) /\ (0.0 <=. r_23) /\
                              ((is_finite32 r)) /\ ((is_finite32 r_23)))))))
          else ((t_4 = t_2) /\
                (if (r_16 <. r_17)
                 then ((t_6 = t_4) /\ (r_19 = r_5) /\ (m_7 = t_9) /\
                       (0.0 <=. r_1) /\ (0.0 <=. r_20) /\
                       ((is_finite32 r_1)) /\ ((is_finite32 r_20)))
                 else ((t_5 = t_4) /\ (r_22 = r_4) /\ (m_10 = t_9) /\
                       (0.0 <=. r) /\ (0.0 <=. r_23) /\ ((is_finite32 r)) /\
                       ((is_finite32 r_23)))))))) ->
  ((eqs11_realquat_s ((l_l_floatquat_of_rmat_1_max_t t_9 a))
     ((l_l_quat_of_floatquat t_9 a_1))))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'a22_max' (file math/pprz_algebra_float.h, line 960) in 'float_quat_of_rmat' --- *)
(* ---------------------------------------------------------- *)
theory VCfloat_quat_of_rmat_a22_max_post
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic19.Axiomatic19
use import Compound.Compound
use import Qed.Qed
use import int.Abs as IAbs
use import Cmath.Cmath
use import real.Abs as RAbs
use import Cfloat.Cfloat
use import Axiomatic15.Axiomatic15
use import Axiomatic17.Axiomatic17
use import S11_RealQuat_s.S11_RealQuat_s
use import Axiomatic18.Axiomatic18

(*
goal WP "expl:Post-condition for 'a22_max' (file math/pprz_algebra_float.h, line 960) in 'float_quat_of_rmat'":
*)
goal goal11:
  forall r_7 r_6 r_5 r_4 r_3 r_2 r_1 r : real.
  forall t : map int int.
  forall t_9 t_8 t_7 t_6 t_5 t_4 t_3 t_2 t_1 : map addr real.
  forall a_1 a : addr.
  let a_2 = (shiftfield_f5_floatrmat_m a) in
  let a_3 = (shift_float32 a_2 0) in
  let r_8 = t_1[a_3] in
  let a_4 = (shift_float32 a_2 8) in
  let r_9 = t_1[a_4] in
  let a_5 = (shift_float32 a_2 4) in
  let r_10 = t_1[a_5] in
  let a_6 = (l_l_rmat_of_floatrmat t_1 a) in
  let r_11 = (add_float32 ((add_float32 r_8 r_10)) r_9) in
  let r_12 = (to_float64 r_3) in
  let a_7 = (shiftfield_f3_floatquat_qi a_1) in
  let m = t_8[a_7 <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_12)))] in
  let a_8 = (shiftfield_f3_floatquat_qx a_1) in
  let a_9 = (shift_float32 a_2 5) in
  let a_10 = (shift_float32 a_2 7) in
  let m_1 = m[a_8 <- (div_float32 ((add_float32 m[a_9] (-. m[a_10]))) r_7)] in
  let a_11 = (shiftfield_f3_floatquat_qy a_1) in
  let a_12 = (shift_float32 a_2 6) in
  let a_13 = (shift_float32 a_2 2) in
  let m_2 = m_1[a_11
              <- (div_float32 ((add_float32 m_1[a_12] (-. m_1[a_13]))) r_7)] in
  let a_14 = (shiftfield_f3_floatquat_qz a_1) in
  let a_15 = (shift_float32 a_2 1) in
  let a_16 = (shift_float32 a_2 3) in
  let r_13 = (to_float32
               ((add_float64 1.0
                  ((to_float64
                     ((add_float32 ((add_float32 t_8[a_3] t_8[a_5]))
                        t_8[a_4]))))))) in
  let r_14 = (to_float64 r_2) in
  let m_3 = t_7[a_7
              <- (div_float32 ((add_float32 t_7[a_9] (-. t_7[a_10]))) r_6)][a_8
              <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_14)))] in
  let m_4 = m_3[a_11
              <- (div_float32 ((add_float32 m_3[a_15] m_3[a_16])) r_6)] in
  let r_15 = (add_float32
               ((add_float32 ((add_float32 t_7[a_3] (-. t_7[a_5])))
                  (-. t_7[a_4]))) 1.0) in
  let r_16 = t_4[a_4] in
  let r_17 = t_4[a_5] in
  let r_18 = (to_float64 r_1) in
  let r_19 = (to_float32 ((mul_float64 2.0 r_18))) in
  let m_5 = t_6[a_7
              <- (div_float32 ((add_float32 t_6[a_12] (-. t_6[a_13]))) r_5)] in
  let m_6 = m_5[a_8 <- (div_float32 ((add_float32 m_5[a_15] m_5[a_16])) r_5)][a_11
              <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_18)))] in
  let m_7 = m_6[a_14 <- (div_float32 ((add_float32 m_6[a_9] m_6[a_10])) r_5)] in
  let r_20 = (add_float32
               ((add_float32 ((add_float32 t_6[a_5] (-. t_6[a_3])))
                  (-. t_6[a_4]))) 1.0) in
  let r_21 = (to_float64 r) in
  let r_22 = (to_float32 ((mul_float64 2.0 r_21))) in
  let m_8 = t_5[a_7
              <- (div_float32 ((add_float32 t_5[a_15] (-. t_5[a_16]))) r_4)] in
  let m_9 = m_8[a_8 <- (div_float32 ((add_float32 m_8[a_12] m_8[a_13])) r_4)] in
  let m_10 = m_9[a_11
               <- (div_float32 ((add_float32 m_9[a_9] m_9[a_10])) r_4)][a_14
               <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_21)))] in
  let r_23 = (add_float32
               ((add_float32 ((add_float32 t_5[a_4] (-. t_5[a_3])))
                  (-. t_5[a_5]))) 1.0) in
  (((l_trace_2_ t_1 a)) <=. 0.0) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (r_8 <=. r_9) ->
  (r_10 <=. r_9) ->
  ((linked t)) ->
  ((is_float32 r)) ->
  ((is_float32 r_1)) ->
  ((is_float32 r_2)) ->
  ((is_float32 r_3)) ->
  ((is_float32 r_4)) ->
  ((is_float32 r_5)) ->
  ((is_float32 r_6)) ->
  ((is_float32 r_7)) ->
  ((valid_rw t a_1 4)) ->
  ((p_rvalid_floatrmat t t_1 a)) ->
  ((separated a 9 a_1 4)) ->
  ((p_rotation_matrix a_6)) ->
  ((p_special_orthogonal a_6)) ->
  ((is_float32 r_8)) ->
  ((is_float32 r_10)) ->
  ((is_float32 r_9)) ->
  ((is_float32 r_11)) ->
  (if (0.0 <. r_11)
   then ((t_8 = t_1) /\ (((to_float32 ((mul_float64 2.0 r_12)))) = r_7) /\
         (m_2[a_14
            <- (div_float32 ((add_float32 m_2[a_15] (-. m_2[a_16]))) r_7)] =
          t_9) /\ (0.0 <=. r_3) /\ (0.0 <=. r_13) /\ ((is_finite32 r_3)) /\
         ((is_finite32 r_13)))
   else ((t_2 = t_1) /\
         (if (t_2[a_5] <. t_2[a_3])
          then ((t_3 = t_2) /\
                (if (t_3[a_4] <. t_3[a_3])
                 then ((t_7 = t_3) /\
                       (((to_float32 ((mul_float64 2.0 r_14)))) = r_6) /\
                       (m_4[a_14
                          <- (div_float32 ((add_float32 m_4[a_12] m_4[a_13]))
                               r_6)] = t_9) /\ (0.0 <=. r_2) /\
                       (0.0 <=. r_15) /\ ((is_finite32 r_2)) /\
                       ((is_finite32 r_15)))
                 else ((t_4 = t_3) /\
                       (if (r_16 <. r_17)
                        then ((t_6 = t_4) /\ (r_19 = r_5) /\ (m_7 = t_9) /\
                              (0.0 <=. r_1) /\ (0.0 <=. r_20) /\
                              ((is_finite32 r_1)) /\ ((is_finite32 r_20)))
                        else ((t_5 = t_4) /\ (r_22 = r_4) /\ (m_10 = t_9) /\
                              (0.0 <=. r) /\ (0.0 <=. r_23) /\
                              ((is_finite32 r)) /\ ((is_finite32 r_23)))))))
          else ((t_4 = t_2) /\
                (if (r_16 <. r_17)
                 then ((t_6 = t_4) /\ (r_19 = r_5) /\ (m_7 = t_9) /\
                       (0.0 <=. r_1) /\ (0.0 <=. r_20) /\
                       ((is_finite32 r_1)) /\ ((is_finite32 r_20)))
                 else ((t_5 = t_4) /\ (r_22 = r_4) /\ (m_10 = t_9) /\
                       (0.0 <=. r) /\ (0.0 <=. r_23) /\ ((is_finite32 r)) /\
                       ((is_finite32 r_23)))))))) ->
  ((eqs11_realquat_s ((l_l_floatquat_of_rmat_2_max_t t_9 a))
     ((l_l_quat_of_floatquat t_9 a_1))))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'trace_pos' (file math/pprz_algebra_float.h, line 942) in 'float_quat_of_rmat' --- *)
(* ---------------------------------------------------------- *)
theory VCfloat_quat_of_rmat_trace_pos_post
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic19.Axiomatic19
use import Qed.Qed
use import int.Abs as IAbs
use import Cmath.Cmath
use import real.Abs as RAbs
use import Cfloat.Cfloat
use import Axiomatic15.Axiomatic15
use import Axiomatic17.Axiomatic17
use import Compound.Compound
use import S11_RealQuat_s.S11_RealQuat_s
use import Axiomatic18.Axiomatic18

(*
goal WP "expl:Post-condition for 'trace_pos' (file math/pprz_algebra_float.h, line 942) in 'float_quat_of_rmat'":
*)
goal goal12:
  forall r_7 r_6 r_5 r_4 r_3 r_2 r_1 r : real.
  forall t : map int int.
  forall t_9 t_8 t_7 t_6 t_5 t_4 t_3 t_2 t_1 : map addr real.
  forall a_1 a : addr.
  let a_2 = (l_l_rmat_of_floatrmat t_1 a) in
  let a_3 = (shiftfield_f5_floatrmat_m a) in
  let a_4 = (shift_float32 a_3 0) in
  let r_8 = t_1[a_4] in
  let a_5 = (shift_float32 a_3 4) in
  let r_9 = t_1[a_5] in
  let a_6 = (shift_float32 a_3 8) in
  let r_10 = t_1[a_6] in
  let r_11 = (add_float32 ((add_float32 r_8 r_9)) r_10) in
  let r_12 = (to_float64 r_3) in
  let a_7 = (shiftfield_f3_floatquat_qi a_1) in
  let m = t_8[a_7 <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_12)))] in
  let a_8 = (shiftfield_f3_floatquat_qx a_1) in
  let a_9 = (shift_float32 a_3 5) in
  let a_10 = (shift_float32 a_3 7) in
  let m_1 = m[a_8 <- (div_float32 ((add_float32 m[a_9] (-. m[a_10]))) r_7)] in
  let a_11 = (shiftfield_f3_floatquat_qy a_1) in
  let a_12 = (shift_float32 a_3 6) in
  let a_13 = (shift_float32 a_3 2) in
  let m_2 = m_1[a_11
              <- (div_float32 ((add_float32 m_1[a_12] (-. m_1[a_13]))) r_7)] in
  let a_14 = (shiftfield_f3_floatquat_qz a_1) in
  let a_15 = (shift_float32 a_3 1) in
  let a_16 = (shift_float32 a_3 3) in
  let r_13 = (to_float32
               ((add_float64 1.0
                  ((to_float64
                     ((add_float32 ((add_float32 t_8[a_4] t_8[a_5]))
                        t_8[a_6]))))))) in
  let r_14 = (to_float64 r_2) in
  let m_3 = t_7[a_7
              <- (div_float32 ((add_float32 t_7[a_9] (-. t_7[a_10]))) r_6)][a_8
              <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_14)))] in
  let m_4 = m_3[a_11
              <- (div_float32 ((add_float32 m_3[a_15] m_3[a_16])) r_6)] in
  let r_15 = (add_float32
               ((add_float32 ((add_float32 t_7[a_4] (-. t_7[a_5])))
                  (-. t_7[a_6]))) 1.0) in
  let r_16 = t_4[a_6] in
  let r_17 = t_4[a_5] in
  let r_18 = (to_float64 r_1) in
  let r_19 = (to_float32 ((mul_float64 2.0 r_18))) in
  let m_5 = t_6[a_7
              <- (div_float32 ((add_float32 t_6[a_12] (-. t_6[a_13]))) r_5)] in
  let m_6 = m_5[a_8 <- (div_float32 ((add_float32 m_5[a_15] m_5[a_16])) r_5)][a_11
              <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_18)))] in
  let m_7 = m_6[a_14 <- (div_float32 ((add_float32 m_6[a_9] m_6[a_10])) r_5)] in
  let r_20 = (add_float32
               ((add_float32 ((add_float32 t_6[a_5] (-. t_6[a_4])))
                  (-. t_6[a_6]))) 1.0) in
  let r_21 = (to_float64 r) in
  let r_22 = (to_float32 ((mul_float64 2.0 r_21))) in
  let m_8 = t_5[a_7
              <- (div_float32 ((add_float32 t_5[a_15] (-. t_5[a_16]))) r_4)] in
  let m_9 = m_8[a_8 <- (div_float32 ((add_float32 m_8[a_12] m_8[a_13])) r_4)] in
  let m_10 = m_9[a_11
               <- (div_float32 ((add_float32 m_9[a_9] m_9[a_10])) r_4)][a_14
               <- (to_float32 ((mul_float64 (1.0 /. 2.0) r_21)))] in
  let r_23 = (add_float32
               ((add_float32 ((add_float32 t_5[a_6] (-. t_5[a_4])))
                  (-. t_5[a_5]))) 1.0) in
  (0.0 <. ((l_trace_2_ t_1 a))) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((is_float32 r)) ->
  ((is_float32 r_1)) ->
  ((is_float32 r_2)) ->
  ((is_float32 r_3)) ->
  ((is_float32 r_4)) ->
  ((is_float32 r_5)) ->
  ((is_float32 r_6)) ->
  ((is_float32 r_7)) ->
  ((valid_rw t a_1 4)) ->
  ((p_rvalid_floatrmat t t_1 a)) ->
  ((separated a 9 a_1 4)) ->
  ((p_rotation_matrix a_2)) ->
  ((p_special_orthogonal a_2)) ->
  ((is_float32 r_8)) ->
  ((is_float32 r_9)) ->
  ((is_float32 r_10)) ->
  ((is_float32 r_11)) ->
  (if (0.0 <. r_11)
   then ((t_8 = t_1) /\ (((to_float32 ((mul_float64 2.0 r_12)))) = r_7) /\
         (m_2[a_14
            <- (div_float32 ((add_float32 m_2[a_15] (-. m_2[a_16]))) r_7)] =
          t_9) /\ (0.0 <=. r_3) /\ (0.0 <=. r_13) /\ ((is_finite32 r_3)) /\
         ((is_finite32 r_13)))
   else ((t_2 = t_1) /\
         (if (t_2[a_5] <. t_2[a_4])
          then ((t_3 = t_2) /\
                (if (t_3[a_6] <. t_3[a_4])
                 then ((t_7 = t_3) /\
                       (((to_float32 ((mul_float64 2.0 r_14)))) = r_6) /\
                       (m_4[a_14
                          <- (div_float32 ((add_float32 m_4[a_12] m_4[a_13]))
                               r_6)] = t_9) /\ (0.0 <=. r_2) /\
                       (0.0 <=. r_15) /\ ((is_finite32 r_2)) /\
                       ((is_finite32 r_15)))
                 else ((t_4 = t_3) /\
                       (if (r_16 <. r_17)
                        then ((t_6 = t_4) /\ (r_19 = r_5) /\ (m_7 = t_9) /\
                              (0.0 <=. r_1) /\ (0.0 <=. r_20) /\
                              ((is_finite32 r_1)) /\ ((is_finite32 r_20)))
                        else ((t_5 = t_4) /\ (r_22 = r_4) /\ (m_10 = t_9) /\
                              (0.0 <=. r) /\ (0.0 <=. r_23) /\
                              ((is_finite32 r)) /\ ((is_finite32 r_23)))))))
          else ((t_4 = t_2) /\
                (if (r_16 <. r_17)
                 then ((t_6 = t_4) /\ (r_19 = r_5) /\ (m_7 = t_9) /\
                       (0.0 <=. r_1) /\ (0.0 <=. r_20) /\
                       ((is_finite32 r_1)) /\ ((is_finite32 r_20)))
                 else ((t_5 = t_4) /\ (r_22 = r_4) /\ (m_10 = t_9) /\
                       (0.0 <=. r) /\ (0.0 <=. r_23) /\ ((is_finite32 r)) /\
                       ((is_finite32 r_23)))))))) ->
  ((eqs11_realquat_s ((l_l_floatquat_of_rmat_trace_pos_t t_9 a))
     ((l_l_quat_of_floatquat t_9 a_1))))

end

