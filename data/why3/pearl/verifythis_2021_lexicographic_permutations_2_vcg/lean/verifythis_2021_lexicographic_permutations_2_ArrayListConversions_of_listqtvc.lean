import Why3.Base
import Why3.map.MapEq
open Classical
open Lean4Why3
namespace verifythis_2021_lexicographic_permutations_2_ArrayListConversions_of_listqtvc
axiom to_list_from : ℤ -> List ℤ -> List ℤ
axiom to_list_from'def (i : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ i) (fact1 : i ≤ Int.ofNat (List.length a)) : if i = Int.ofNat (List.length a) then to_list_from i a = ([] : List ℤ) else to_list_from i a = List.cons (a[Int.toNat i]!) (to_list_from (i + (1 : ℤ)) a)
axiom to_list_from'spec'0 (i : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ i) (fact1 : i ≤ Int.ofNat (List.length a)) : Int.ofNat (List.length (to_list_from i a)) = Int.ofNat (List.length a) - i
axiom to_list_from'spec (i : ℤ) (a : List ℤ) (k : ℤ) (fact0 : (0 : ℤ) ≤ i) (fact1 : i ≤ Int.ofNat (List.length a)) (fact2 : (0 : ℤ) ≤ k) (fact3 : k < Int.ofNat (List.length a) - i) : getElem_i? (to_list_from i a) k = Option.some (a[Int.toNat (k + i)]!)
theorem of_list'vc (l : List ℤ) : let o1 : ℤ := Int.ofNat (List.length l); (0 : ℤ) ≤ o1 ∧ (∀(a : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o1 → a[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length a) = o1 → (∀(a1 : List ℤ), List.length a1 = List.length a → (∀(l' : List ℤ) (i : ℤ), (0 : ℤ) ≤ i ∧ Int.ofNat (List.length l') = Int.ofNat (List.length l) - i ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length l') → getElem_i? l (k + i) = getElem_i? l' k) → (match l' with | ([] : List ℤ) => (∀(k : ℤ), i ≤ k ∧ k < Int.ofNat (List.length l) → getElem_i? l k = Option.some (a1[Int.toNat k]!)) | List.cons v t => ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (List.length (List.set a1 (Int.toNat i) v) = List.length a1 → getElem! (List.set a1 (Int.toNat i) v) ∘ Int.toNat = Function.update (getElem! a1 ∘ Int.toNat) i v → (let o2 : ℤ := i + (1 : ℤ); ((match l' with | ([] : List ℤ) => False | List.cons _ f => f = t) ∧ (0 : ℤ) ≤ o2 ∧ Int.ofNat (List.length t) = Int.ofNat (List.length l) - o2 ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length t) → getElem_i? l (k + o2) = getElem_i? t k)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length (List.set a1 (Int.toNat i) v) → (∀(k : ℤ), o2 ≤ k ∧ k < Int.ofNat (List.length l) → getElem_i? l k = Option.some (a2[Int.toNat k]!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < o2 → a2[Int.toNat k]! = (List.set a1 (Int.toNat i) v)[Int.toNat k]!) → (∀(k : ℤ), i ≤ k ∧ k < Int.ofNat (List.length l) → getElem_i? l k = Option.some (a2[Int.toNat k]!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i → a2[Int.toNat k]! = a1[Int.toNat k]!))))))) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ Int.ofNat (List.length l) = Int.ofNat (List.length l) - (0 : ℤ) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length l) → getElem_i? l (k + (0 : ℤ)) = getElem_i? l k)) ∧ (∀(a1 : List ℤ), List.length a1 = List.length a → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length l) → getElem_i? l k = Option.some (a1[Int.toNat k]!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < (0 : ℤ) → a1[Int.toNat k]! = a[Int.toNat k]!) → List.length a1 = List.length l ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length l) → getElem_i? l k = Option.some (a1[Int.toNat k]!))))
  := sorry
end verifythis_2021_lexicographic_permutations_2_ArrayListConversions_of_listqtvc
