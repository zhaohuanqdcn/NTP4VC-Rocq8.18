import Why3.Base
import Why3.bintree.Tree
import Why3.bintree.Size
import Why3.bintree.Height
import Why3.bintree.Inorder
open Classical
open Lean4Why3
namespace tree_of_array_TreeOfArray_tree_of_array_auxqtvc
theorem tree_of_array_aux'vc {α : Type} [Inhabited α] (lo : ℤ) (hi : ℤ) (a : List α) (fact0 : (0 : ℤ) ≤ lo) (fact1 : lo ≤ hi) (fact2 : hi ≤ Int.ofNat (List.length a)) : (¬hi = lo → ¬(2 : ℤ) = (0 : ℤ) ∧ (let mid : ℤ := lo + Int.tdiv (hi - lo) (2 : ℤ); (((0 : ℤ) ≤ hi - lo ∧ mid - lo < hi - lo) ∧ (0 : ℤ) ≤ lo ∧ lo ≤ mid ∧ mid ≤ Int.ofNat (List.length a)) ∧ (∀(left1 : Tree.tree α), (let n : ℤ := mid - lo; Size.size left1 = n ∧ Inorder.inorder left1 = List.drop (Int.toNat lo) (List.take (Int.toNat mid - Int.toNat lo) a) ∧ ((0 : ℤ) < n → (let h : ℤ := Height.height left1; HPow.hPow (2 : ℤ) (Int.toNat (h - (1 : ℤ))) ≤ n ∧ n < HPow.hPow (2 : ℤ) (Int.toNat h)))) → (let o1 : ℤ := mid + (1 : ℤ); (((0 : ℤ) ≤ hi - lo ∧ hi - o1 < hi - lo) ∧ (0 : ℤ) ≤ o1 ∧ o1 ≤ hi ∧ hi ≤ Int.ofNat (List.length a)) ∧ (∀(right1 : Tree.tree α), (let n : ℤ := hi - o1; Size.size right1 = n ∧ Inorder.inorder right1 = List.drop (Int.toNat o1) (List.take (Int.toNat hi - Int.toNat o1) a) ∧ ((0 : ℤ) < n → (let h : ℤ := Height.height right1; HPow.hPow (2 : ℤ) (Int.toNat (h - (1 : ℤ))) ≤ n ∧ n < HPow.hPow (2 : ℤ) (Int.toNat h)))) → (0 : ℤ) ≤ mid ∧ mid < Int.ofNat (List.length a)))))) ∧ (∀(result : Tree.tree α), (if hi = lo then result = (Tree.tree.Empty : Tree.tree α) else let mid : ℤ := lo + Int.tdiv (hi - lo) (2 : ℤ); ∃(left1 : Tree.tree α), (let n : ℤ := mid - lo; Size.size left1 = n ∧ Inorder.inorder left1 = List.drop (Int.toNat lo) (List.take (Int.toNat mid - Int.toNat lo) a) ∧ ((0 : ℤ) < n → (let h : ℤ := Height.height left1; HPow.hPow (2 : ℤ) (Int.toNat (h - (1 : ℤ))) ≤ n ∧ n < HPow.hPow (2 : ℤ) (Int.toNat h)))) ∧ (let o1 : ℤ := mid + (1 : ℤ); ∃(right1 : Tree.tree α), (let n : ℤ := hi - o1; Size.size right1 = n ∧ Inorder.inorder right1 = List.drop (Int.toNat o1) (List.take (Int.toNat hi - Int.toNat o1) a) ∧ ((0 : ℤ) < n → (let h : ℤ := Height.height right1; HPow.hPow (2 : ℤ) (Int.toNat (h - (1 : ℤ))) ≤ n ∧ n < HPow.hPow (2 : ℤ) (Int.toNat h)))) ∧ result = Tree.tree.Node left1 (a[Int.toNat mid]!) right1)) → (let n : ℤ := hi - lo; Size.size result = n ∧ Inorder.inorder result = List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a) ∧ ((0 : ℤ) < n → (let h : ℤ := Height.height result; HPow.hPow (2 : ℤ) (Int.toNat (h - (1 : ℤ))) ≤ n ∧ n < HPow.hPow (2 : ℤ) (Int.toNat h)))))
  := sorry
end tree_of_array_TreeOfArray_tree_of_array_auxqtvc
