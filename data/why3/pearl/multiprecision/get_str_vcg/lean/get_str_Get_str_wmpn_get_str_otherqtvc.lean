import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import Why3.mach.c.UChar
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.powm.Powm
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.valuation.Valuation
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.sub_1.Sub_1
import pearl.multiprecision.lib.lean.stringlemmas.String_lemmas
import pearl.multiprecision.lib.lean.base_info.BaseInfo
open Classical
open Lean4Why3
namespace get_str_Get_str_wmpn_get_str_otherqtvc
theorem wmpn_get_str_other'vc (up : C.ptr (BitVec 64)) (un : BitVec 32) (info : BaseInfo.wmpn_base_info) (base : BitVec 32) (sp : C.ptr (BitVec 8)) (sz : BitVec 32) (fact0 : C.valid up (BitVec.toInt un)) (fact1 : (1 : ℤ) ≤ BitVec.toInt un) (fact2 : BaseInfo.b info = BitVec.toInt base) (fact3 : C.writable up = true) (fact4 : C.writable sp = true) (fact5 : (0 : ℤ) < BitVec.toUInt (C.pelts up (C.offset up + BitVec.toInt un - (1 : ℤ)))) (fact6 : (0 : ℤ) < BitVec.toInt sz) (fact7 : C.valid sp (BitVec.toInt sz)) (fact8 : Lemmas.value up (BitVec.toInt un) < HPow.hPow (BitVec.toInt base) (Int.toNat (BitVec.toInt sz - (1 : ℤ)))) : (0 : ℤ) ≤ BitVec.toInt base ∧ (∀(o1 : BitVec 64), BitVec.toUInt o1 = BitVec.toInt base → (0 : ℤ) < BitVec.toUInt o1 ∧ (∀(o2 : BitVec 32), HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt o2)) * BitVec.toUInt o1 ≤ (18446744073709551615 : ℤ) ∧ (18446744073709551615 : ℤ) < (2 : ℤ) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt o2)) * BitVec.toUInt o1 ∧ (0 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 < (64 : ℤ) → (0 : ℤ) ≤ BitVec.toInt o2 ∧ (∀(shift : BitVec 64), BitVec.toUInt shift = BitVec.toInt o2 → (0 : ℤ) ≤ BitVec.toInt base ∧ (∀(o3 : BitVec 64), BitVec.toUInt o3 = BitVec.toInt base → (((0 : ℤ) ≤ BitVec.toUInt shift ∧ BitVec.toUInt shift < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt shift)) * BitVec.toUInt o3 ≤ (18446744073709551615 : ℤ)) ∧ (∀(d1 : BitVec 64), BitVec.toUInt d1 = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt shift)) * BitVec.toUInt o3 → ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt d1 ∧ (∀(di : BitVec 64), Div.reciprocal di d1 → (let vu : ℤ := Lemmas.value up (BitVec.toInt un); (if (1 : ℤ) < BitVec.toInt un then (0 : ℤ) ≤ BitVec.toInt un ∧ (∀(o4 : BitVec 32), BitVec.toUInt o4 = BitVec.toInt un → (0 : ℤ) ≤ BitVec.toUInt o4 ∧ (∀(tp : C.ptr (BitVec 64)), C.plength tp = BitVec.toUInt o4 ∧ C.offset tp = (0 : ℤ) ∧ C.min tp = (0 : ℤ) ∧ C.max tp = BitVec.toUInt o4 ∧ C.writable tp = true → (String_lemmas.svalue_le (BitVec.toInt base) sp (0 : ℤ) + HPow.hPow (BitVec.toInt base) (0 : ℕ) * Lemmas.value up (BitVec.toInt un) = vu ∧ ((1 : ℤ) ≤ BitVec.toInt un ∧ BitVec.toInt un ≤ BitVec.toInt un) ∧ BitVec.toInt un - BitVec.toInt un ≤ (0 : ℤ) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < BitVec.toInt sz) ∧ (0 : ℤ) = (0 : ℤ) * BitVec.toUInt (BaseInfo.exp info) ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp) (C.offset sp + (0 : ℤ)) ∧ (0 : ℤ) < BitVec.toUInt (C.pelts up (C.offset up + BitVec.toInt un - (1 : ℤ)))) ∧ (∀(loopi : ℤ) (tp1 : C.ptr (BitVec 64)) (n : BitVec 32) (sn : BitVec 32) (up1 : C.ptr (BitVec 64)) (sp1 : C.ptr (BitVec 8)), List.length (C.data tp1) = List.length (C.data tp) ∧ C.offset tp1 = C.offset tp ∧ C.min tp1 = C.min tp ∧ C.max tp1 = C.max tp ∧ C.writable tp1 = C.writable tp ∧ C.zone1 tp1 = C.zone1 tp → List.length (C.data up1) = List.length (C.data up) ∧ C.offset up1 = C.offset up ∧ C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → List.length (C.data sp1) = List.length (C.data sp) ∧ C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.max sp1 = C.max sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → String_lemmas.svalue_le (BitVec.toInt base) sp1 (BitVec.toInt sn) + HPow.hPow (BitVec.toInt base) (Int.toNat (BitVec.toInt sn)) * Lemmas.value up1 (BitVec.toInt n) = vu ∧ ((1 : ℤ) ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ BitVec.toInt un) ∧ BitVec.toInt un - BitVec.toInt n ≤ loopi ∧ ((0 : ℤ) ≤ BitVec.toInt sn ∧ BitVec.toInt sn < BitVec.toInt sz) ∧ BitVec.toInt sn = loopi * BitVec.toUInt (BaseInfo.exp info) ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp1) (C.offset sp1) (C.offset sp1 + BitVec.toInt sn) ∧ (0 : ℤ) < BitVec.toUInt (C.pelts up1 (C.offset up1 + BitVec.toInt n - (1 : ℤ))) ∧ (∀(j : ℤ), j < C.offset sp1 ∨ C.offset sp1 + BitVec.toInt sz ≤ j → C.pelts sp1 j = C.pelts sp j) → (if (1 : ℤ) < BitVec.toInt n then let o5 : BitVec 64 := BaseInfo.bb info; (C.valid up1 (BitVec.toInt n) ∧ C.valid tp1 (BitVec.toInt n) ∧ C.writable tp1 = true ∧ (0 : ℤ) < BitVec.toInt n ∧ (0 : ℤ) < BitVec.toUInt o5) ∧ (∀(tp2 : C.ptr (BitVec 64)), List.length (C.data tp2) = List.length (C.data tp1) ∧ C.offset tp2 = C.offset tp1 ∧ C.min tp2 = C.min tp1 ∧ C.max tp2 = C.max tp1 ∧ C.writable tp2 = C.writable tp1 ∧ C.zone1 tp2 = C.zone1 tp1 → (∀(o6 : BitVec 64), Lemmas.value up1 (BitVec.toInt n) = Lemmas.value tp2 (BitVec.toInt n) * BitVec.toUInt o5 + BitVec.toUInt o6 ∧ BitVec.toUInt o6 < BitVec.toUInt o5 → (C.valid tp2 (BitVec.toInt n) ∧ C.valid up1 (BitVec.toInt n) ∧ C.writable up1 = true) ∧ (∀(up2 : C.ptr (BitVec 64)), List.length (C.data up2) = List.length (C.data up1) ∧ C.offset up2 = C.offset up1 ∧ C.min up2 = C.min up1 ∧ C.max up2 = C.max up1 ∧ C.writable up2 = C.writable up1 ∧ C.zone1 up2 = C.zone1 up1 → Lemmas.map_eq_sub_shift (C.pelts up2) (C.pelts tp2) (C.offset up2) (C.offset tp2) (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset up2 ∨ C.offset up2 + BitVec.toInt n ≤ j → C.pelts up2 j = C.pelts up1 j) → int'32_in_bounds (BitVec.toInt n - (1 : ℤ)) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt n - (1 : ℤ) → (C.min up2 ≤ C.offset up2 + BitVec.toInt o7 ∧ C.offset up2 + BitVec.toInt o7 < C.max up2) ∧ (let o8 : BitVec 64 := C.pelts up2 (C.offset up2 + BitVec.toInt o7); ∀(o9 : Bool), (BitVec.toUInt o8 = BitVec.toUInt (0 : BitVec 64) → o9 = true) ∧ (o9 = true → o8 = (0 : BitVec 64)) → (∀(o10 : BitVec 32), (if o9 = true then o10 = (1 : BitVec 32) else o10 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt n - BitVec.toInt o10) ∧ (∀(o11 : BitVec 32), BitVec.toInt o11 = BitVec.toInt n - BitVec.toInt o10 → (C.min sp1 ≤ C.offset sp1 + BitVec.toInt sn ∧ C.offset sp1 + BitVec.toInt sn ≤ C.max sp1) ∧ (∀(spn : C.ptr (BitVec 8)), C.offset spn = C.offset sp1 + BitVec.toInt sn ∧ C.plength spn = C.plength sp1 ∧ C.pelts spn = C.pelts sp1 ∧ C.data spn = C.data sp1 ∧ C.min spn = C.min sp1 ∧ C.max spn = C.max sp1 ∧ C.zone1 spn = C.zone1 sp1 ∧ C.writable spn = C.writable sp1 → (let o12 : BitVec 32 := BaseInfo.exp info; BitVec.toUInt o12 ≤ (2147483647 : ℤ) ∧ (∀(o13 : BitVec 32), BitVec.toInt o13 = BitVec.toUInt o12 → int'32_in_bounds (BitVec.toInt o13 + (1 : ℤ)) ∧ (∀(o14 : BitVec 32), BitVec.toInt o14 = BitVec.toInt o13 + (1 : ℤ) → (((2 : ℤ) ≤ BaseInfo.b info ∧ BaseInfo.b info ≤ (256 : ℤ)) ∧ C.writable spn = true ∧ ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt d1 ∧ ((0 : ℤ) ≤ BitVec.toUInt shift ∧ BitVec.toUInt shift ≤ (63 : ℤ)) ∧ BaseInfo.b info * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt shift)) = BitVec.toUInt d1 ∧ Div.reciprocal di d1 ∧ C.valid spn (BitVec.toInt o14) ∧ (0 : ℤ) < BitVec.toInt o14 ∧ BitVec.toUInt o6 < HPow.hPow (BaseInfo.b info) (Int.toNat (BitVec.toInt o14))) ∧ (∀(spn1 : C.ptr (BitVec 8)) (sp2 : C.ptr (BitVec 8)), C.data spn1 = C.data sp2 ∧ List.length (C.data sp2) = List.length (C.data spn) ∧ C.offset spn1 = C.offset spn ∧ C.min spn1 = C.min spn ∧ C.max spn1 = C.max spn ∧ C.writable spn1 = C.writable spn ∧ C.zone1 spn1 = C.zone1 spn → List.length (C.data sp2) = List.length (C.data sp1) ∧ C.offset sp2 = C.offset sp1 ∧ C.min sp2 = C.min sp1 ∧ C.max sp2 = C.max sp1 ∧ C.writable sp2 = C.writable sp1 ∧ C.zone1 sp2 = C.zone1 sp1 → (∀(o15 : BitVec 32), String_lemmas.svalue_le (BaseInfo.b info) spn1 (BitVec.toUInt o15) = BitVec.toUInt o6 ∧ ((0 : ℤ) ≤ BitVec.toUInt o15 ∧ BitVec.toUInt o15 ≤ BitVec.toInt o14) ∧ ((0 : ℤ) < BitVec.toUInt o15 → (0 : ℤ) < BitVec.toInt (C.pelts spn1 (C.offset spn1 + BitVec.toUInt o15 - (1 : ℤ)))) ∧ (∀(i : ℤ), i < C.offset spn1 ∨ C.offset spn1 + BitVec.toUInt o15 ≤ i → C.pelts spn1 i = C.pelts spn i) ∧ String_lemmas.in_base (BaseInfo.b info) (C.pelts spn1) (C.offset spn1) (C.offset spn1 + BitVec.toUInt o15) → BitVec.toUInt o15 ≤ (2147483647 : ℤ) ∧ (∀(o16 : BitVec 32), BitVec.toInt o16 = BitVec.toUInt o15 → int'32_in_bounds (BitVec.toInt sn + BitVec.toInt o16) ∧ (∀(o17 : BitVec 32), BitVec.toInt o17 = BitVec.toInt sn + BitVec.toInt o16 → (BitVec.toUInt o15 ≤ BitVec.toUInt (BaseInfo.exp info) ∧ BitVec.toInt o17 = BitVec.toInt sn + BitVec.toUInt o15 ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp2) (C.offset sp2) (C.offset sp2 + BitVec.toInt o17) ∧ String_lemmas.svalue_le (BitVec.toInt base) sp2 (BitVec.toInt o17) + HPow.hPow (BitVec.toInt base) (Int.toNat (BitVec.toInt o17 - BitVec.toUInt o15 + BitVec.toUInt (BaseInfo.exp info))) * Lemmas.value up2 (BitVec.toInt o11) = vu ∧ (∀(j : ℤ), j < C.offset sp2 ∨ C.offset sp2 + BitVec.toInt sz ≤ j → C.pelts sp2 j = C.pelts sp j)) ∧ (∀(sdone : BitVec 32) (sn1 : BitVec 32) (sp3 : C.ptr (BitVec 8)), List.length (C.data sp3) = List.length (C.data sp2) ∧ C.offset sp3 = C.offset sp2 ∧ C.min sp3 = C.min sp2 ∧ C.max sp3 = C.max sp2 ∧ C.writable sp3 = C.writable sp2 ∧ C.zone1 sp3 = C.zone1 sp2 → BitVec.toUInt sdone ≤ BitVec.toUInt (BaseInfo.exp info) ∧ BitVec.toInt sn1 = BitVec.toInt sn + BitVec.toUInt sdone ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + BitVec.toInt sn1) ∧ String_lemmas.svalue_le (BitVec.toInt base) sp3 (BitVec.toInt sn1) + HPow.hPow (BitVec.toInt base) (Int.toNat (BitVec.toInt sn1 - BitVec.toUInt sdone + BitVec.toUInt (BaseInfo.exp info))) * Lemmas.value up2 (BitVec.toInt o11) = vu ∧ (∀(j : ℤ), j < C.offset sp3 ∨ C.offset sp3 + BitVec.toInt sz ≤ j → C.pelts sp3 j = C.pelts sp j) → (if BitVec.toUInt sdone < BitVec.toUInt (BaseInfo.exp info) then ((C.min sp3 ≤ C.offset sp3 + BitVec.toInt sn1 ∧ C.offset sp3 + BitVec.toInt sn1 < C.max sp3) ∧ C.writable sp3 = true) ∧ (∀(sp4 : C.ptr (BitVec 8)), List.length (C.data sp4) = List.length (C.data sp3) ∧ C.offset sp4 = C.offset sp3 ∧ C.min sp4 = C.min sp3 ∧ C.max sp4 = C.max sp3 ∧ C.writable sp4 = C.writable sp3 ∧ C.zone1 sp4 = C.zone1 sp3 → C.pelts sp4 = Function.update (C.pelts sp3) (C.offset sp4 + BitVec.toInt sn1) (0 : BitVec 8) ∧ C.pelts sp4 (C.offset sp4 + BitVec.toInt sn1) = (0 : BitVec 8) → int'32_in_bounds (BitVec.toInt sn1 + (1 : ℤ)) ∧ (∀(o18 : BitVec 32), BitVec.toInt o18 = BitVec.toInt sn1 + (1 : ℤ) → uint'32_in_bounds (BitVec.toUInt sdone + (1 : ℤ)) ∧ (∀(o19 : BitVec 32), BitVec.toUInt o19 = BitVec.toUInt sdone + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt (BaseInfo.exp info) - BitVec.toUInt sdone ∧ BitVec.toUInt (BaseInfo.exp info) - BitVec.toUInt o19 < BitVec.toUInt (BaseInfo.exp info) - BitVec.toUInt sdone) ∧ BitVec.toUInt o19 ≤ BitVec.toUInt (BaseInfo.exp info) ∧ BitVec.toInt o18 = BitVec.toInt sn + BitVec.toUInt o19 ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + BitVec.toInt o18) ∧ String_lemmas.svalue_le (BitVec.toInt base) sp4 (BitVec.toInt o18) + HPow.hPow (BitVec.toInt base) (Int.toNat (BitVec.toInt o18 - BitVec.toUInt o19 + BitVec.toUInt (BaseInfo.exp info))) * Lemmas.value up2 (BitVec.toInt o11) = vu ∧ (∀(j : ℤ), j < C.offset sp4 ∨ C.offset sp4 + BitVec.toInt sz ≤ j → C.pelts sp4 j = C.pelts sp j)))) else ((0 : ℤ) ≤ Lemmas.value up1 (BitVec.toInt n) ∧ Lemmas.value up2 (BitVec.toInt o11) < Lemmas.value up1 (BitVec.toInt n)) ∧ String_lemmas.svalue_le (BitVec.toInt base) sp3 (BitVec.toInt sn1) + HPow.hPow (BitVec.toInt base) (Int.toNat (BitVec.toInt sn1)) * Lemmas.value up2 (BitVec.toInt o11) = vu ∧ ((1 : ℤ) ≤ BitVec.toInt o11 ∧ BitVec.toInt o11 ≤ BitVec.toInt un) ∧ BitVec.toInt un - BitVec.toInt o11 ≤ loopi + (1 : ℤ) ∧ ((0 : ℤ) ≤ BitVec.toInt sn1 ∧ BitVec.toInt sn1 < BitVec.toInt sz) ∧ BitVec.toInt sn1 = (loopi + (1 : ℤ)) * BitVec.toUInt (BaseInfo.exp info) ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + BitVec.toInt sn1) ∧ (0 : ℤ) < BitVec.toUInt (C.pelts up2 (C.offset up2 + BitVec.toInt o11 - (1 : ℤ))) ∧ (∀(j : ℤ), j < C.offset sp3 ∨ C.offset sp3 + BitVec.toInt sz ≤ j → C.pelts sp3 j = C.pelts sp j)))))))))))))))))) else String_lemmas.svalue_le (BitVec.toInt base) sp1 (BitVec.toInt sn) + HPow.hPow (BitVec.toInt base) (Int.toNat (BitVec.toInt sn)) * Lemmas.value up1 (1 : ℤ) = vu ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp1) (C.offset sp1) (C.offset sp1 + BitVec.toInt sn) ∧ ((0 : ℤ) ≤ BitVec.toInt sn ∧ BitVec.toInt sn < BitVec.toInt sz) ∧ (0 : ℤ) < Lemmas.value up1 (1 : ℤ) ∧ (∀(j : ℤ), j < C.offset sp1 ∨ C.offset sp1 + BitVec.toInt sz ≤ j → C.pelts sp1 j = C.pelts sp j))))) else String_lemmas.svalue_le (BitVec.toInt base) sp (0 : ℤ) + HPow.hPow (BitVec.toInt base) (0 : ℕ) * Lemmas.value up (1 : ℤ) = vu ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp) (C.offset sp + (0 : ℤ)) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < BitVec.toInt sz) ∧ (0 : ℤ) < Lemmas.value up (1 : ℤ)) ∧ (∀(sn : BitVec 32) (up1 : C.ptr (BitVec 64)) (sp1 : C.ptr (BitVec 8)), List.length (C.data up1) = List.length (C.data up) ∧ C.offset up1 = C.offset up ∧ C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → List.length (C.data sp1) = List.length (C.data sp) ∧ C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.max sp1 = C.max sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → String_lemmas.svalue_le (BitVec.toInt base) sp1 (BitVec.toInt sn) + HPow.hPow (BitVec.toInt base) (Int.toNat (BitVec.toInt sn)) * Lemmas.value up1 (1 : ℤ) = vu ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp1) (C.offset sp1) (C.offset sp1 + BitVec.toInt sn) ∧ ((0 : ℤ) ≤ BitVec.toInt sn ∧ BitVec.toInt sn < BitVec.toInt sz) ∧ (0 : ℤ) < Lemmas.value up1 (1 : ℤ) ∧ (∀(j : ℤ), j < C.offset sp1 ∨ C.offset sp1 + BitVec.toInt sz ≤ j → C.pelts sp1 j = C.pelts sp j) → (C.min up1 ≤ C.offset up1 ∧ C.offset up1 < C.max up1) ∧ (let o4 : BitVec 64 := C.pelts up1 (C.offset up1); (C.min sp1 ≤ C.offset sp1 + BitVec.toInt sn ∧ C.offset sp1 + BitVec.toInt sn ≤ C.max sp1) ∧ (∀(spn : C.ptr (BitVec 8)), C.offset spn = C.offset sp1 + BitVec.toInt sn ∧ C.plength spn = C.plength sp1 ∧ C.pelts spn = C.pelts sp1 ∧ C.data spn = C.data sp1 ∧ C.min spn = C.min sp1 ∧ C.max spn = C.max sp1 ∧ C.zone1 spn = C.zone1 sp1 ∧ C.writable spn = C.writable sp1 → int'32_in_bounds (BitVec.toInt sz - (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt sz - (1 : ℤ) → int'32_in_bounds (BitVec.toInt o5 - BitVec.toInt sn) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt o5 - BitVec.toInt sn → (((2 : ℤ) ≤ BaseInfo.b info ∧ BaseInfo.b info ≤ (256 : ℤ)) ∧ C.writable spn = true ∧ ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt d1 ∧ ((0 : ℤ) ≤ BitVec.toUInt shift ∧ BitVec.toUInt shift ≤ (63 : ℤ)) ∧ BaseInfo.b info * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt shift)) = BitVec.toUInt d1 ∧ Div.reciprocal di d1 ∧ C.valid spn (BitVec.toInt o6) ∧ (0 : ℤ) < BitVec.toInt o6 ∧ BitVec.toUInt o4 < HPow.hPow (BaseInfo.b info) (Int.toNat (BitVec.toInt o6))) ∧ (∀(spn1 : C.ptr (BitVec 8)) (sp2 : C.ptr (BitVec 8)), C.data spn1 = C.data sp2 ∧ List.length (C.data sp2) = List.length (C.data spn) ∧ C.offset spn1 = C.offset spn ∧ C.min spn1 = C.min spn ∧ C.max spn1 = C.max spn ∧ C.writable spn1 = C.writable spn ∧ C.zone1 spn1 = C.zone1 spn → List.length (C.data sp2) = List.length (C.data sp1) ∧ C.offset sp2 = C.offset sp1 ∧ C.min sp2 = C.min sp1 ∧ C.max sp2 = C.max sp1 ∧ C.writable sp2 = C.writable sp1 ∧ C.zone1 sp2 = C.zone1 sp1 → (∀(sdone : BitVec 32), String_lemmas.svalue_le (BaseInfo.b info) spn1 (BitVec.toUInt sdone) = BitVec.toUInt o4 ∧ ((0 : ℤ) ≤ BitVec.toUInt sdone ∧ BitVec.toUInt sdone ≤ BitVec.toInt o6) ∧ ((0 : ℤ) < BitVec.toUInt sdone → (0 : ℤ) < BitVec.toInt (C.pelts spn1 (C.offset spn1 + BitVec.toUInt sdone - (1 : ℤ)))) ∧ (∀(i : ℤ), i < C.offset spn1 ∨ C.offset spn1 + BitVec.toUInt sdone ≤ i → C.pelts spn1 i = C.pelts spn i) ∧ String_lemmas.in_base (BaseInfo.b info) (C.pelts spn1) (C.offset spn1) (C.offset spn1 + BitVec.toUInt sdone) → BitVec.toUInt sdone ≤ (2147483647 : ℤ) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toUInt sdone → int'32_in_bounds (BitVec.toInt sn + BitVec.toInt o7) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt sn + BitVec.toInt o7 → (((0 : ℤ) ≤ (2 : ℤ) * (0 : ℤ) + (1 : ℤ) ∧ (2 : ℤ) * (0 : ℤ) + (1 : ℤ) ≤ BitVec.toInt o8 + (1 : ℤ)) ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp2) (C.offset sp2) (C.offset sp2 + BitVec.toInt o8) ∧ String_lemmas.svalue_sub (BitVec.toInt base) (C.pelts sp2) (C.offset sp2) (C.offset sp2 + (0 : ℤ)) = String_lemmas.svalue_le_sub (BitVec.toInt base) (C.pelts sp2) (C.offset sp2 + BitVec.toInt o8 - (0 : ℤ)) (C.offset sp2 + BitVec.toInt o8) ∧ String_lemmas.svalue_sub (BitVec.toInt base) (C.pelts sp2) (C.offset sp2 + BitVec.toInt o8 - (0 : ℤ)) (C.offset sp2 + BitVec.toInt o8) = String_lemmas.svalue_le_sub (BitVec.toInt base) (C.pelts sp2) (C.offset sp2) (C.offset sp2 + (0 : ℤ)) ∧ ((0 : ℤ) < (0 : ℤ) → (0 : ℤ) < BitVec.toInt (C.pelts sp2 (C.offset sp2))) ∧ (∀(j : ℤ), j < C.offset sp2 ∨ C.offset sp2 + BitVec.toInt sz ≤ j → C.pelts sp2 j = C.pelts sp j)) ∧ (∀(i : BitVec 32) (sp3 : C.ptr (BitVec 8)), List.length (C.data sp3) = List.length (C.data sp2) ∧ C.offset sp3 = C.offset sp2 ∧ C.min sp3 = C.min sp2 ∧ C.max sp3 = C.max sp2 ∧ C.writable sp3 = C.writable sp2 ∧ C.zone1 sp3 = C.zone1 sp2 → ((0 : ℤ) ≤ (2 : ℤ) * BitVec.toInt i + (1 : ℤ) ∧ (2 : ℤ) * BitVec.toInt i + (1 : ℤ) ≤ BitVec.toInt o8 + (1 : ℤ)) ∧ (∀(j : ℤ), C.offset sp3 + BitVec.toInt i ≤ j ∧ j < C.offset sp3 + BitVec.toInt o8 - BitVec.toInt i → C.pelts sp3 j = C.pelts sp2 j) ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + BitVec.toInt o8) ∧ String_lemmas.svalue_sub (BitVec.toInt base) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + BitVec.toInt i) = String_lemmas.svalue_le_sub (BitVec.toInt base) (C.pelts sp2) (C.offset sp3 + BitVec.toInt o8 - BitVec.toInt i) (C.offset sp3 + BitVec.toInt o8) ∧ String_lemmas.svalue_sub (BitVec.toInt base) (C.pelts sp3) (C.offset sp3 + BitVec.toInt o8 - BitVec.toInt i) (C.offset sp3 + BitVec.toInt o8) = String_lemmas.svalue_le_sub (BitVec.toInt base) (C.pelts sp2) (C.offset sp3) (C.offset sp3 + BitVec.toInt i) ∧ String_lemmas.svalue_le_sub (BitVec.toInt base) (C.pelts sp3) (C.offset sp3 + BitVec.toInt i) (C.offset sp3 + BitVec.toInt o8 - BitVec.toInt i) = String_lemmas.svalue_le_sub (BitVec.toInt base) (C.pelts sp2) (C.offset sp3 + BitVec.toInt i) (C.offset sp3 + BitVec.toInt o8 - BitVec.toInt i) ∧ ((0 : ℤ) < BitVec.toInt i → (0 : ℤ) < BitVec.toInt (C.pelts sp3 (C.offset sp3))) ∧ (∀(j : ℤ), j < C.offset sp3 ∨ C.offset sp3 + BitVec.toInt sz ≤ j → C.pelts sp3 j = C.pelts sp j) → int'32_in_bounds ((2 : ℤ) * BitVec.toInt i) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = (2 : ℤ) * BitVec.toInt i → int'32_in_bounds (BitVec.toInt o9 + (1 : ℤ)) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt o9 + (1 : ℤ) → (if BitVec.toInt o10 < BitVec.toInt o8 then (C.min sp3 ≤ C.offset sp3 + BitVec.toInt i ∧ C.offset sp3 + BitVec.toInt i < C.max sp3) ∧ (let t : BitVec 8 := C.pelts sp3 (C.offset sp3 + BitVec.toInt i); int'32_in_bounds (BitVec.toInt o8 - BitVec.toInt i) ∧ (∀(o11 : BitVec 32), BitVec.toInt o11 = BitVec.toInt o8 - BitVec.toInt i → int'32_in_bounds (BitVec.toInt o11 - (1 : ℤ)) ∧ (∀(o12 : BitVec 32), BitVec.toInt o12 = BitVec.toInt o11 - (1 : ℤ) → (C.min sp3 ≤ C.offset sp3 + BitVec.toInt o12 ∧ C.offset sp3 + BitVec.toInt o12 < C.max sp3) ∧ (let o13 : BitVec 8 := C.pelts sp3 (C.offset sp3 + BitVec.toInt o12); ((C.min sp3 ≤ C.offset sp3 + BitVec.toInt i ∧ C.offset sp3 + BitVec.toInt i < C.max sp3) ∧ C.writable sp3 = true) ∧ (∀(sp4 : C.ptr (BitVec 8)), List.length (C.data sp4) = List.length (C.data sp3) ∧ C.offset sp4 = C.offset sp3 ∧ C.min sp4 = C.min sp3 ∧ C.max sp4 = C.max sp3 ∧ C.writable sp4 = C.writable sp3 ∧ C.zone1 sp4 = C.zone1 sp3 → C.pelts sp4 = Function.update (C.pelts sp3) (C.offset sp4 + BitVec.toInt i) o13 ∧ C.pelts sp4 (C.offset sp4 + BitVec.toInt i) = o13 → int'32_in_bounds (BitVec.toInt o8 - BitVec.toInt i) ∧ (∀(o14 : BitVec 32), BitVec.toInt o14 = BitVec.toInt o8 - BitVec.toInt i → int'32_in_bounds (BitVec.toInt o14 - (1 : ℤ)) ∧ (∀(o15 : BitVec 32), BitVec.toInt o15 = BitVec.toInt o14 - (1 : ℤ) → ((C.min sp4 ≤ C.offset sp4 + BitVec.toInt o15 ∧ C.offset sp4 + BitVec.toInt o15 < C.max sp4) ∧ C.writable sp4 = true) ∧ (∀(sp5 : C.ptr (BitVec 8)), List.length (C.data sp5) = List.length (C.data sp4) ∧ C.offset sp5 = C.offset sp4 ∧ C.min sp5 = C.min sp4 ∧ C.max sp5 = C.max sp4 ∧ C.writable sp5 = C.writable sp4 ∧ C.zone1 sp5 = C.zone1 sp4 → C.pelts sp5 = Function.update (C.pelts sp4) (C.offset sp5 + BitVec.toInt o15) t ∧ C.pelts sp5 (C.offset sp5 + BitVec.toInt o15) = t → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o16 : BitVec 32), BitVec.toInt o16 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o8 - BitVec.toInt i ∧ BitVec.toInt o8 - BitVec.toInt o16 < BitVec.toInt o8 - BitVec.toInt i) ∧ ((0 : ℤ) ≤ (2 : ℤ) * BitVec.toInt o16 + (1 : ℤ) ∧ (2 : ℤ) * BitVec.toInt o16 + (1 : ℤ) ≤ BitVec.toInt o8 + (1 : ℤ)) ∧ (∀(j : ℤ), C.offset sp5 + BitVec.toInt o16 ≤ j ∧ j < C.offset sp5 + BitVec.toInt o8 - BitVec.toInt o16 → C.pelts sp5 j = C.pelts sp2 j) ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp5) (C.offset sp5) (C.offset sp5 + BitVec.toInt o8) ∧ String_lemmas.svalue_sub (BitVec.toInt base) (C.pelts sp5) (C.offset sp5) (C.offset sp5 + BitVec.toInt o16) = String_lemmas.svalue_le_sub (BitVec.toInt base) (C.pelts sp2) (C.offset sp5 + BitVec.toInt o8 - BitVec.toInt o16) (C.offset sp5 + BitVec.toInt o8) ∧ String_lemmas.svalue_sub (BitVec.toInt base) (C.pelts sp5) (C.offset sp5 + BitVec.toInt o8 - BitVec.toInt o16) (C.offset sp5 + BitVec.toInt o8) = String_lemmas.svalue_le_sub (BitVec.toInt base) (C.pelts sp2) (C.offset sp5) (C.offset sp5 + BitVec.toInt o16) ∧ String_lemmas.svalue_le_sub (BitVec.toInt base) (C.pelts sp5) (C.offset sp5 + BitVec.toInt o16) (C.offset sp5 + BitVec.toInt o8 - BitVec.toInt o16) = String_lemmas.svalue_le_sub (BitVec.toInt base) (C.pelts sp2) (C.offset sp5 + BitVec.toInt o16) (C.offset sp5 + BitVec.toInt o8 - BitVec.toInt o16) ∧ ((0 : ℤ) < BitVec.toInt o16 → (0 : ℤ) < BitVec.toInt (C.pelts sp5 (C.offset sp5))) ∧ (∀(j : ℤ), j < C.offset sp5 ∨ C.offset sp5 + BitVec.toInt sz ≤ j → C.pelts sp5 j = C.pelts sp j)))))))))) else (0 : ℤ) ≤ BitVec.toInt o8 ∧ (∀(result : BitVec 32), BitVec.toUInt result = BitVec.toInt o8 → ((0 : ℤ) ≤ BitVec.toUInt result ∧ BitVec.toUInt result < BitVec.toInt sz) ∧ String_lemmas.svalue (BitVec.toInt base) sp3 (BitVec.toUInt result) = Lemmas.value up (BitVec.toInt un) ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + BitVec.toUInt result) ∧ (0 : ℤ) < BitVec.toInt (C.pelts sp3 (C.offset sp3)) ∧ (∀(j : ℤ), j < C.offset sp3 ∨ C.offset sp3 + BitVec.toInt sz ≤ j → C.pelts sp3 j = C.pelts sp j))))))))))))))))))))))
  := sorry
end get_str_Get_str_wmpn_get_str_otherqtvc
