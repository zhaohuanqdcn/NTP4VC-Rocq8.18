(* ---------------------------------------------------------- *)
(* --- Complete behaviors 'not_exists', 'found'           --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_complete_not_exists_found
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Complete behaviors 'not_exists', 'found'":
*)
goal goal0:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = (to_uint8 i_1) in
  (((region (a_6.base))) <= 0) ->
  ((linked t)) ->
  ((is_sint32 i_1)) ->
  ((is_uint64 i)) ->
  ((valid_rd t ((shift_uint8 a 0)) i)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) i)) ->
  ((forall a_7 : addr. ((addr_le a_2 a_7)) ->
    ((addr_lt a_7 ((shift_uint8 a_3 i)))) -> (t_1[a_7] <> x)) \/
   (exists a_7 : addr. (t_1[a_7] = x) /\ ((addr_le a_4 a_7)) /\
    ((addr_lt a_7 ((shift_uint8 a_5 i))))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'not_exists', 'found'           --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_disjoint_not_exists_found
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Disjoint behaviors 'not_exists', 'found'":
*)
goal goal1:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = (to_uint8 i_1) in
  (((region (a_6.base))) <= 0) ->
  ((linked t)) ->
  ((is_sint32 i_1)) ->
  ((is_uint64 i)) ->
  ((valid_rd t ((shift_uint8 a 0)) i)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) i)) ->
  ((exists a_7 : addr. (t_1[a_7] = x) /\ ((addr_le a_2 a_7)) /\
    ((addr_lt a_7 ((shift_uint8 a_3 i))))) \/
   (forall a_7 : addr. (t_1[a_7] <> x) \/ (not (addr_le a_4 a_7)) \/
    (not (addr_lt a_7 ((shift_uint8 a_5 i))))))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file src/memchr.c, line 6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_loop_inv_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Preservation of Invariant (file src/memchr.c, line 6)":
*)
goal goal2:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = t_1[a_7] in
  let x_1 = (to_uint8 i_1) in
  let x_2 = a_3.offset in
  let x_3 = a_7.offset in
  let x_4 = i + x_3 - x_2 in
  (i <> 0) ->
  (x <> x_1) ->
  (0 <= i) ->
  (x_2 <= x_3) ->
  (((region (a_6.base))) <= 0) ->
  ((linked t)) ->
  ((is_sint32 i_1)) ->
  ((is_uint64 i)) ->
  ((addr_le a_4 a_7)) ->
  ((is_uint8 x)) ->
  ((is_uint64 x_4)) ->
  ((valid_rd t ((shift_uint8 a 0)) x_4)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) x_4)) ->
  ((addr_le a_7 ((shift_uint8 a_5 x_4)))) ->
  (forall a_8 : addr. ((addr_lt a_8 a_7)) -> ((addr_le a_2 a_8)) ->
   (t_1[a_8] <> x_1)) ->
  ((x_2 + ((to_uint64 (i - 1)))) <= (i + x_3))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file src/memchr.c, line 6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_loop_inv_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Establishment of Invariant (file src/memchr.c, line 6)":
*)
goal goal3:
  forall i : int.
  forall t : map int int.
  forall a_2 a_1 a : addr.
  (((region (a_2.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint64 i)) ->
  ((valid_rd t ((shift_uint8 a 0)) i)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) i)) ->
  (0 <= i)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file src/memchr.c, line 7) --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_loop_inv_2_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Preservation of Invariant (file src/memchr.c, line 7)":
*)
goal goal4:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = t_1[a_9] in
  let x_1 = (to_uint8 i_1) in
  let x_2 = a_3.offset in
  let x_3 = a_9.offset in
  let x_4 = i + x_3 - x_2 in
  let a_10 = (shift_uint8 a_9 1) in
  (i <> 0) ->
  (x <> x_1) ->
  (0 <= i) ->
  (x_2 <= x_3) ->
  (((region (a_8.base))) <= 0) ->
  ((linked t)) ->
  ((is_sint32 i_1)) ->
  ((is_uint64 i)) ->
  ((addr_le a_4 a_9)) ->
  ((is_uint8 x)) ->
  ((is_uint64 x_4)) ->
  ((valid_rd t ((shift_uint8 a 0)) x_4)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) x_4)) ->
  ((addr_le a_9 ((shift_uint8 a_5 x_4)))) ->
  (forall a_11 : addr. ((addr_lt a_11 a_9)) -> ((addr_le a_2 a_11)) ->
   (t_1[a_11] <> x_1)) ->
  (((addr_le a_6 a_10)) /\ ((addr_le a_10 ((shift_uint8 a_7 x_4)))))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file src/memchr.c, line 7) --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_loop_inv_2_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Establishment of Invariant (file src/memchr.c, line 7)":
*)
goal goal5:
  forall i : int.
  forall t : map int int.
  forall a_5 a_4 a_3 a_2 a_1 a : addr.
  (((region (a_4.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint64 i)) ->
  ((valid_rd t ((shift_uint8 a 0)) i)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) i)) ->
  (((addr_le a_2 a_5)) /\ ((addr_le a_5 ((shift_uint8 a_3 i)))))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file src/memchr.c, line 8) --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_loop_inv_3_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Preservation of Invariant (file src/memchr.c, line 8)":
*)
goal goal6:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = t_1[a_8] in
  let x_1 = (to_uint8 i_1) in
  let x_2 = a_3.offset in
  let x_3 = a_8.offset in
  let x_4 = i + x_3 - x_2 in
  (i <> 0) ->
  (x <> x_1) ->
  (0 <= i) ->
  (x_2 <= x_3) ->
  (((region (a_7.base))) <= 0) ->
  ((linked t)) ->
  ((is_sint32 i_1)) ->
  ((is_uint64 i)) ->
  ((addr_le a_4 a_8)) ->
  ((is_uint8 x)) ->
  ((is_uint64 x_4)) ->
  ((valid_rd t ((shift_uint8 a 0)) x_4)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) x_4)) ->
  ((addr_le a_8 ((shift_uint8 a_5 x_4)))) ->
  (forall a_9 : addr. ((addr_lt a_9 a_8)) -> ((addr_le a_2 a_9)) ->
   (t_1[a_9] <> x_1)) ->
  ((1 + x_2 + ((to_uint64 (i - 1)))) = (i + (a_6.offset)))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file src/memchr.c, line 8) --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_loop_inv_3_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Establishment of Invariant (file src/memchr.c, line 8)":
*)
goal goal7:
  forall i : int.
  forall t : map int int.
  forall a_4 a_3 a_2 a_1 a : addr.
  (((region (a_3.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint64 i)) ->
  ((valid_rd t ((shift_uint8 a 0)) i)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) i)) ->
  ((a_4.offset) = (a_2.offset))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file src/memchr.c, line 9) --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_loop_inv_4_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Preservation of Invariant (file src/memchr.c, line 9)":
*)
goal goal8:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = t_1[a_8] in
  let x_1 = (to_uint8 i_1) in
  let x_2 = a_3.offset in
  let x_3 = a_8.offset in
  let x_4 = i + x_3 - x_2 in
  (i <> 0) ->
  (x <> x_1) ->
  (0 <= i) ->
  (x_2 <= x_3) ->
  (((region (a_7.base))) <= 0) ->
  ((linked t)) ->
  ((is_sint32 i_1)) ->
  ((is_uint64 i)) ->
  ((addr_le a_4 a_8)) ->
  ((addr_le a_6 a_9)) ->
  ((is_uint8 x)) ->
  ((addr_lt a_9 ((shift_uint8 a_8 1)))) ->
  ((is_uint64 x_4)) ->
  ((valid_rd t ((shift_uint8 a 0)) x_4)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) x_4)) ->
  ((addr_le a_8 ((shift_uint8 a_5 x_4)))) ->
  (forall a_10 : addr. ((addr_lt a_10 a_8)) -> ((addr_le a_2 a_10)) ->
   (t_1[a_10] <> x_1)) ->
  (t_1[a_9] <> x_1)

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file src/memchr.c, line 9) --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_loop_inv_4_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Establishment of Invariant (file src/memchr.c, line 9)":
*)
goal goal9:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_5 a_4 a_3 a_2 a_1 a : addr.
  (((region (a_3.base))) <= 0) ->
  ((linked t)) ->
  ((is_sint32 i_1)) ->
  ((is_uint64 i)) ->
  ((addr_lt a_5 a_4)) ->
  ((addr_le a_2 a_5)) ->
  ((valid_rd t ((shift_uint8 a 0)) i)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) i)) ->
  (t_1[a_5] <> ((to_uint8 i_1)))

end

(* ---------------------------------------------------------- *)
(* --- Decreasing of Loop variant at loop (file src/memchr.c, line 13) --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_loop_term_decrease
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Decreasing of Loop variant at loop (file src/memchr.c, line 13)":
*)
goal goal10:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = t_1[a_7] in
  let x_1 = (to_uint8 i_1) in
  let x_2 = a_3.offset in
  let x_3 = a_7.offset in
  let x_4 = i + x_3 - x_2 in
  (i <> 0) ->
  (x <> x_1) ->
  (0 <= i) ->
  (x_2 <= x_3) ->
  (((region (a_6.base))) <= 0) ->
  ((linked t)) ->
  ((is_sint32 i_1)) ->
  ((is_uint64 i)) ->
  ((addr_le a_4 a_7)) ->
  ((is_uint8 x)) ->
  ((is_uint64 x_4)) ->
  ((valid_rd t ((shift_uint8 a 0)) x_4)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) x_4)) ->
  ((addr_le a_7 ((shift_uint8 a_5 x_4)))) ->
  (forall a_8 : addr. ((addr_lt a_8 a_7)) -> ((addr_le a_2 a_8)) ->
   (t_1[a_8] <> x_1)) ->
  (((to_uint64 (i - 1))) < i)

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'found' (file src/memchr.h, line 21) in 'memchr' --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_found_post
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Post-condition for 'found' (file src/memchr.h, line 21) in 'memchr'":
*)
goal goal11:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_11 a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = t_1[a_11] in
  let x_1 = a_5.offset in
  let x_2 = a_9.offset in
  let x_3 = i + x_2 - x_1 in
  (x = ((to_uint8 i_1))) ->
  (0 <= i) ->
  (x_1 <= x_2) ->
  (((region (a_8.base))) <= 0) ->
  ((linked t)) ->
  ((is_sint32 i_1)) ->
  ((is_uint64 i)) ->
  ((addr_le a_2 a_11)) ->
  ((addr_le a_6 a_9)) ->
  ((is_uint64 x_3)) ->
  ((valid_rd t ((shift_uint8 a 0)) x_3)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) x_3)) ->
  ((addr_lt a_11 ((shift_uint8 a_3 x_3)))) ->
  ((addr_le a_9 ((shift_uint8 a_7 x_3)))) ->
  (if (i = 0) then (null = a_10) else (x = t_1[a_9])) ->
  (forall a_12 : addr. ((addr_lt a_12 a_9)) -> ((addr_le a_4 a_12)) ->
   (x <> t_1[a_12])) ->
  (((addr_le a_8 a_10)) /\ ((addr_le a_10 ((shift_sint32 a_8 x_3)))))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'found' (file src/memchr.h, line 22) in 'memchr' --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_found_post_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Post-condition for 'found' (file src/memchr.h, line 22) in 'memchr'":
*)
goal goal12:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_13 a_12 a_11 a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = t_1[a_12] in
  let x_1 = a_5.offset in
  let x_2 = a_11.offset in
  let x_3 = i + x_2 - x_1 in
  (x = ((to_uint8 i_1))) ->
  (0 <= i) ->
  (x_1 <= x_2) ->
  (((region (a_10.base))) <= 0) ->
  ((linked t)) ->
  ((is_sint32 i_1)) ->
  ((is_uint64 i)) ->
  ((addr_lt a_13 a_9)) ->
  ((addr_le a_2 a_12)) ->
  ((addr_le a_6 a_11)) ->
  ((addr_le a_8 a_13)) ->
  ((is_uint64 x_3)) ->
  ((valid_rd t ((shift_uint8 a 0)) x_3)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) x_3)) ->
  ((addr_lt a_12 ((shift_uint8 a_3 x_3)))) ->
  ((addr_le a_11 ((shift_uint8 a_7 x_3)))) ->
  ((i = 0) \/ (x = t_1[a_11])) ->
  (forall a_14 : addr. ((addr_lt a_14 a_11)) -> ((addr_le a_4 a_14)) ->
   (x <> t_1[a_14])) ->
  (t_1[a_13] <> x)

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'found' (file src/memchr.h, line 23) in 'memchr' --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_found_post_3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Post-condition for 'found' (file src/memchr.h, line 23) in 'memchr'":
*)
goal goal13:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_11 a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = t_1[a_11] in
  let x_1 = a_5.offset in
  let x_2 = a_10.offset in
  let x_3 = t_1[a_8] in
  let x_4 = i + x_2 - x_1 in
  (x = ((to_uint8 i_1))) ->
  (0 <= i) ->
  (x_1 <= x_2) ->
  (((region (a_9.base))) <= 0) ->
  ((linked t)) ->
  ((is_sint32 i_1)) ->
  ((is_uint64 i)) ->
  ((addr_le a_2 a_11)) ->
  ((addr_le a_6 a_10)) ->
  ((is_uint8 x_3)) ->
  ((is_uint64 x_4)) ->
  ((valid_rd t ((shift_uint8 a 0)) x_4)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) x_4)) ->
  ((addr_lt a_11 ((shift_uint8 a_3 x_4)))) ->
  ((addr_le a_10 ((shift_uint8 a_7 x_4)))) ->
  ((i = 0) \/ (x = t_1[a_10])) ->
  (forall a_12 : addr. ((addr_lt a_12 a_10)) -> ((addr_le a_4 a_12)) ->
   (x <> t_1[a_12])) ->
  (x = x_3)

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'not_exists' (file src/memchr.h, line 26) in 'memchr' --- *)
(* ---------------------------------------------------------- *)
theory VCmemchr_not_exists_post
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Post-condition for 'not_exists' (file src/memchr.h, line 26) in 'memchr'":
*)
goal goal14:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_5.offset in
  let x_1 = a_9.offset in
  let x_2 = i + x in
  let x_3 = (to_uint8 i_1) in
  (x <= x_1) ->
  (((region (a_8.base))) <= 0) ->
  (x_1 <= x_2) ->
  ((linked t)) ->
  ((is_sint32 i_1)) ->
  ((is_uint64 i)) ->
  ((addr_le a_6 a_9)) ->
  ((addr_le a_9 ((shift_uint8 a_7 i)))) ->
  ((valid_rd t ((shift_uint8 a 0)) i)) ->
  ((valid_rd t ((shift_uint8 a_1 0)) i)) ->
  ((is_uint64 (i + x - x_1))) ->
  (if (x_2 = x_1) then (null = a_10) else (t_1[a_9] = x_3)) ->
  (forall a_11 : addr. ((addr_lt a_11 a_9)) -> ((addr_le a_4 a_11)) ->
   (t_1[a_11] <> x_3)) ->
  (forall a_11 : addr. ((addr_le a_2 a_11)) ->
   ((addr_lt a_11 ((shift_uint8 a_3 i)))) -> (t_1[a_11] <> x_3)) ->
  (null = a_10)

end

