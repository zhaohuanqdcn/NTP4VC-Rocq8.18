import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Sum
open Classical
open Lean4Why3
namespace space_saving_Top_space_saving_kqtvc
axiom elt : Type
axiom inhabited_axiom_elt : Inhabited elt
attribute [instance] inhabited_axiom_elt
axiom dummy : elt
axiom minimum : List ℤ -> ℤ
axiom minimum'spec'0 (a : List ℤ) (fact0 : (0 : ℤ) < Int.ofNat (List.length a)) : (0 : ℤ) ≤ minimum a ∧ minimum a < Int.ofNat (List.length a)
axiom minimum'spec (a : List ℤ) (i : ℤ) (fact0 : (0 : ℤ) < Int.ofNat (List.length a)) (fact1 : (0 : ℤ) ≤ i) (fact2 : i < Int.ofNat (List.length a)) : a[Int.toNat (minimum a)]! ≤ a[Int.toNat i]!
noncomputable def occurs (v : elt) (a : List elt) := ∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ v = a[Int.toNat i]!
theorem space_saving_k'vc (k : ℤ) (s : ℤ -> elt) (fact0 : (2 : ℤ) ≤ k) : (0 : ℤ) ≤ k ∧ (∀(o1 : List elt), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < k → o1[Int.toNat i]! = dummy) ∧ Int.ofNat (List.length o1) = k → (0 : ℤ) ≤ k ∧ (∀(o2 : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < k → o2[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length o2) = k → ((List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) o2)) = (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < k → (0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ (o1[Int.toNat i]!) s (0 : ℤ) (0 : ℤ)) ∧ Int.ofNat (Lean4Why3.map_occ (o1[Int.toNat i]!) s (0 : ℤ) (0 : ℤ)) ≤ o2[Int.toNat i]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < k → (if o2[Int.toNat i]! = (0 : ℤ) then o1[Int.toNat i]! = dummy else ¬o1[Int.toNat i]! = dummy)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < k → (0 : ℤ) < o2[Int.toNat i]! → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k → (0 : ℤ) < o2[Int.toNat j]! → ¬i = j → ¬o1[Int.toNat i]! = o1[Int.toNat j]!)) ∧ (∀(y : elt), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < k → ¬y = o1[Int.toNat i]!) → Int.ofNat (Lean4Why3.map_occ y s (0 : ℤ) (0 : ℤ)) ≤ o2[Int.toNat (minimum o2)]!)) ∧ (∀(c : List ℤ) (e : List elt), List.length c = List.length o2 → List.length e = List.length o1 → (0 : ℤ) ≤ List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < k → (0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ (e[Int.toNat i]!) s (0 : ℤ) (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)))) ∧ Int.ofNat (Lean4Why3.map_occ (e[Int.toNat i]!) s (0 : ℤ) (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)))) ≤ getElem! c (Int.toNat i)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < k → (if getElem! c (Int.toNat i) = (0 : ℤ) then e[Int.toNat i]! = dummy else ¬e[Int.toNat i]! = dummy)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < k → (0 : ℤ) < getElem! c (Int.toNat i) → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k → (0 : ℤ) < getElem! c (Int.toNat j) → ¬i = j → ¬e[Int.toNat i]! = e[Int.toNat j]!)) ∧ (∀(y : elt), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < k → ¬y = e[Int.toNat i]!) → Int.ofNat (Lean4Why3.map_occ y s (0 : ℤ) (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)))) ≤ getElem! c (Int.toNat (minimum c))) → (0 : ℤ) ≤ List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) ∧ (¬s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c))) = dummy → Int.ofNat (List.length e) = k ∧ (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ k) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → ¬e[Int.toNat j]! = s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)))) ∧ (i < k → e[Int.toNat i]! = s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)))) → (if i < k then (((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length c) ∧ Int.ofNat (List.length c) = k) ∧ List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ) - (1 : ℤ)) ∧ (∀(c1 : List ℤ), List.length c1 = List.length c → List.length c1 = List.length c → c1[Int.toNat i]! = getElem! c (Int.toNat i) + (1 : ℤ) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k → ¬j = i → c1[Int.toNat j]! = getElem! c (Int.toNat j)) ∧ List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c1)) = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ) → (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c1)) = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ) ∧ (0 : ℤ) ≤ List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ)) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < k → (0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ (e[Int.toNat i1]!) s (0 : ℤ) (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ))) ∧ Int.ofNat (Lean4Why3.map_occ (e[Int.toNat i1]!) s (0 : ℤ) (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ))) ≤ c1[Int.toNat i1]!) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < k → (if c1[Int.toNat i1]! = (0 : ℤ) then e[Int.toNat i1]! = dummy else ¬e[Int.toNat i1]! = dummy)) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < k → (0 : ℤ) < c1[Int.toNat i1]! → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k → (0 : ℤ) < c1[Int.toNat j]! → ¬i1 = j → ¬e[Int.toNat i1]! = e[Int.toNat j]!)) ∧ (∀(y : elt), (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < k → ¬y = e[Int.toNat i1]!) → Int.ofNat (Lean4Why3.map_occ y s (0 : ℤ) (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ))) ≤ c1[Int.toNat (minimum c1)]!)) else (0 : ℤ) < Int.ofNat (List.length c) ∧ (let m : ℤ := minimum c; ((0 : ℤ) ≤ m ∧ m < Int.ofNat (List.length c)) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length c) → getElem! c (Int.toNat m) ≤ getElem! c (Int.toNat i1)) → ((0 : ℤ) ≤ m ∧ m < Int.ofNat (List.length e)) ∧ (List.length (List.set e (Int.toNat m) (s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c))))) = List.length e → List.length (List.set e (Int.toNat m) (s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c))))) = List.length e → getElem! (List.set e (Int.toNat m) (s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c))))) ∘ Int.toNat = Function.update (getElem! e ∘ Int.toNat) m (s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)))) → (((0 : ℤ) ≤ m ∧ m < Int.ofNat (List.length c) ∧ Int.ofNat (List.length c) = k) ∧ List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ) - (1 : ℤ)) ∧ (∀(c1 : List ℤ), List.length c1 = List.length c → List.length c1 = List.length c → c1[Int.toNat m]! = getElem! c (Int.toNat m) + (1 : ℤ) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k → ¬j = m → c1[Int.toNat j]! = getElem! c (Int.toNat j)) ∧ List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c1)) = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ) → (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c1)) = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ) ∧ (0 : ℤ) ≤ List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ)) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < k → (0 : ℤ) ≤ Int.ofNat (Lean4Why3.map_occ ((List.set e (Int.toNat m) (s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)))))[Int.toNat i1]!) s (0 : ℤ) (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ))) ∧ Int.ofNat (Lean4Why3.map_occ ((List.set e (Int.toNat m) (s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)))))[Int.toNat i1]!) s (0 : ℤ) (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ))) ≤ c1[Int.toNat i1]!) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < k → (if c1[Int.toNat i1]! = (0 : ℤ) then (List.set e (Int.toNat m) (s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)))))[Int.toNat i1]! = dummy else ¬(List.set e (Int.toNat m) (s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)))))[Int.toNat i1]! = dummy)) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < k → (0 : ℤ) < c1[Int.toNat i1]! → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k → (0 : ℤ) < c1[Int.toNat j]! → ¬i1 = j → ¬(List.set e (Int.toNat m) (s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)))))[Int.toNat i1]! = (List.set e (Int.toNat m) (s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)))))[Int.toNat j]!)) ∧ (∀(y : elt), (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < k → ¬y = (List.set e (Int.toNat m) (s (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)))))[Int.toNat i1]!) → Int.ofNat (Lean4Why3.map_occ y s (0 : ℤ) (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat k - (0 : ℕ)) c)) + (1 : ℤ))) ≤ c1[Int.toNat (minimum c1)]!))))))))))
  := sorry
end space_saving_Top_space_saving_kqtvc
