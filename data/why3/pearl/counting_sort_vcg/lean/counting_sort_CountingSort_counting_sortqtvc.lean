import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
import pearl.counting_sort_vcg.lean.counting_sort.Spec
import Why3.array.IntArraySorted
open Classical
open Lean4Why3
namespace counting_sort_CountingSort_counting_sortqtvc
theorem counting_sort'vc (a : List ℤ) (b : List ℤ) (fact0 : Spec.k_values a) (fact1 : List.length a = List.length b) : let o1 : ℤ := Spec.k; (0 : ℤ) ≤ o1 ∧ (∀(c : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o1 → getElem! c (Int.toNat i) = (0 : ℤ)) ∧ Int.ofNat (List.length c) = o1 → (let o2 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → (∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < Spec.k → getElem! c (Int.toNat v) = Spec.numeq a v (0 : ℤ) (0 : ℤ)) ∧ (∀(c1 : List ℤ), List.length c1 = List.length c → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o2) ∧ (∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < Spec.k → c1[Int.toNat v]! = Spec.numeq a v (0 : ℤ) i) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let v : ℤ := a[Int.toNat i]!; ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length c1)) ∧ (let o3 : ℤ := c1[Int.toNat v]! + (1 : ℤ); ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length c1)) ∧ (List.length (List.set c1 (Int.toNat v) o3) = List.length c1 → getElem! (List.set c1 (Int.toNat v) o3) ∘ Int.toNat = Function.update (getElem! c1 ∘ Int.toNat) v o3 → (∀(v1 : ℤ), (0 : ℤ) ≤ v1 ∧ v1 < Spec.k → (List.set c1 (Int.toNat v) o3)[Int.toNat v1]! = Spec.numeq a v1 (0 : ℤ) (i + (1 : ℤ))))))) ∧ ((∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < Spec.k → c1[Int.toNat v]! = Spec.numeq a v (0 : ℤ) (o2 + (1 : ℤ))) → (let o3 : ℤ := Spec.k - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → ((0 : ℤ) = Spec.numlt a (0 : ℤ) (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b (0 : ℤ) (0 : ℤ) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < (0 : ℤ) → (0 : ℤ) ≤ b[Int.toNat e]! ∧ b[Int.toNat e]! < (0 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < (0 : ℤ) → Spec.numeq b f (0 : ℤ) (0 : ℤ) = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a)))) ∧ (∀(j : ℤ) (b1 : List ℤ), List.length b1 = List.length b → (∀(v : ℤ), ((0 : ℤ) ≤ v ∧ v ≤ o3) ∧ j = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ b1[Int.toNat e]! ∧ b1[Int.toNat e]! < v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq b1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a))) → ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length c1)) ∧ (let o4 : ℤ := c1[Int.toNat v]!; ((1 : ℤ) ≤ o4 + (1 : ℤ) → (j - (1 : ℤ) + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ b1[Int.toNat e]! ∧ b1[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq b1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a))) ∧ Spec.numeq b1 v (0 : ℤ) j = (1 : ℤ) - (1 : ℤ)) ∧ (∀(j1 : ℤ) (b2 : List ℤ), List.length b2 = List.length b1 → (∀(i : ℤ), ((1 : ℤ) ≤ i ∧ i ≤ o4) ∧ j1 - i + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b2 (0 : ℤ) j1 ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 → (0 : ℤ) ≤ b2[Int.toNat e]! ∧ b2[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq b2 f (0 : ℤ) j1 = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a))) ∧ Spec.numeq b2 v (0 : ℤ) j1 = i - (1 : ℤ) → ((0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length b2)) ∧ (List.length (List.set b2 (Int.toNat j1) v) = List.length b2 → getElem! (List.set b2 (Int.toNat j1) v) ∘ Int.toNat = Function.update (getElem! b2 ∘ Int.toNat) j1 v → j1 + (1 : ℤ) - (i + (1 : ℤ)) + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 (List.set b2 (Int.toNat j1) v) (0 : ℤ) (j1 + (1 : ℤ)) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 + (1 : ℤ) → (0 : ℤ) ≤ (List.set b2 (Int.toNat j1) v)[Int.toNat e]! ∧ (List.set b2 (Int.toNat j1) v)[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq (List.set b2 (Int.toNat j1) v) f (0 : ℤ) (j1 + (1 : ℤ)) = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a))) ∧ Spec.numeq (List.set b2 (Int.toNat j1) v) v (0 : ℤ) (j1 + (1 : ℤ)) = i + (1 : ℤ) - (1 : ℤ))) ∧ (j1 - (o4 + (1 : ℤ)) + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b2 (0 : ℤ) j1 ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 → (0 : ℤ) ≤ b2[Int.toNat e]! ∧ b2[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq b2 f (0 : ℤ) j1 = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a))) ∧ Spec.numeq b2 v (0 : ℤ) j1 = o4 + (1 : ℤ) - (1 : ℤ) → j1 = Spec.numlt a (v + (1 : ℤ)) (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b2 (0 : ℤ) j1 ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 → (0 : ℤ) ≤ b2[Int.toNat e]! ∧ b2[Int.toNat e]! < v + (1 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v + (1 : ℤ) → Spec.numeq b2 f (0 : ℤ) j1 = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a)))))) ∧ (o4 + (1 : ℤ) < (1 : ℤ) → j = Spec.numlt a (v + (1 : ℤ)) (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ b1[Int.toNat e]! ∧ b1[Int.toNat e]! < v + (1 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v + (1 : ℤ) → Spec.numeq b1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a)))))) ∧ (j = Spec.numlt a (o3 + (1 : ℤ)) (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ b1[Int.toNat e]! ∧ b1[Int.toNat e]! < o3 + (1 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < o3 + (1 : ℤ) → Spec.numeq b1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a))) → IntArraySorted.sorted b1 ∧ Spec.permut a b1))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → IntArraySorted.sorted b ∧ Spec.permut a b))))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → (let o3 : ℤ := Spec.k - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → ((0 : ℤ) = Spec.numlt a (0 : ℤ) (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b (0 : ℤ) (0 : ℤ) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < (0 : ℤ) → (0 : ℤ) ≤ b[Int.toNat e]! ∧ b[Int.toNat e]! < (0 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < (0 : ℤ) → Spec.numeq b f (0 : ℤ) (0 : ℤ) = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a)))) ∧ (∀(j : ℤ) (b1 : List ℤ), List.length b1 = List.length b → (∀(v : ℤ), ((0 : ℤ) ≤ v ∧ v ≤ o3) ∧ j = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ b1[Int.toNat e]! ∧ b1[Int.toNat e]! < v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq b1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a))) → ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length c)) ∧ (let o4 : ℤ := getElem! c (Int.toNat v); ((1 : ℤ) ≤ o4 + (1 : ℤ) → (j - (1 : ℤ) + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ b1[Int.toNat e]! ∧ b1[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq b1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a))) ∧ Spec.numeq b1 v (0 : ℤ) j = (1 : ℤ) - (1 : ℤ)) ∧ (∀(j1 : ℤ) (b2 : List ℤ), List.length b2 = List.length b1 → (∀(i : ℤ), ((1 : ℤ) ≤ i ∧ i ≤ o4) ∧ j1 - i + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b2 (0 : ℤ) j1 ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 → (0 : ℤ) ≤ b2[Int.toNat e]! ∧ b2[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq b2 f (0 : ℤ) j1 = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a))) ∧ Spec.numeq b2 v (0 : ℤ) j1 = i - (1 : ℤ) → ((0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length b2)) ∧ (List.length (List.set b2 (Int.toNat j1) v) = List.length b2 → getElem! (List.set b2 (Int.toNat j1) v) ∘ Int.toNat = Function.update (getElem! b2 ∘ Int.toNat) j1 v → j1 + (1 : ℤ) - (i + (1 : ℤ)) + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 (List.set b2 (Int.toNat j1) v) (0 : ℤ) (j1 + (1 : ℤ)) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 + (1 : ℤ) → (0 : ℤ) ≤ (List.set b2 (Int.toNat j1) v)[Int.toNat e]! ∧ (List.set b2 (Int.toNat j1) v)[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq (List.set b2 (Int.toNat j1) v) f (0 : ℤ) (j1 + (1 : ℤ)) = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a))) ∧ Spec.numeq (List.set b2 (Int.toNat j1) v) v (0 : ℤ) (j1 + (1 : ℤ)) = i + (1 : ℤ) - (1 : ℤ))) ∧ (j1 - (o4 + (1 : ℤ)) + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b2 (0 : ℤ) j1 ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 → (0 : ℤ) ≤ b2[Int.toNat e]! ∧ b2[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq b2 f (0 : ℤ) j1 = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a))) ∧ Spec.numeq b2 v (0 : ℤ) j1 = o4 + (1 : ℤ) - (1 : ℤ) → j1 = Spec.numlt a (v + (1 : ℤ)) (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b2 (0 : ℤ) j1 ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 → (0 : ℤ) ≤ b2[Int.toNat e]! ∧ b2[Int.toNat e]! < v + (1 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v + (1 : ℤ) → Spec.numeq b2 f (0 : ℤ) j1 = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a)))))) ∧ (o4 + (1 : ℤ) < (1 : ℤ) → j = Spec.numlt a (v + (1 : ℤ)) (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ b1[Int.toNat e]! ∧ b1[Int.toNat e]! < v + (1 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v + (1 : ℤ) → Spec.numeq b1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a)))))) ∧ (j = Spec.numlt a (o3 + (1 : ℤ)) (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 b1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ b1[Int.toNat e]! ∧ b1[Int.toNat e]! < o3 + (1 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < o3 + (1 : ℤ) → Spec.numeq b1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a))) → IntArraySorted.sorted b1 ∧ Spec.permut a b1))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → IntArraySorted.sorted b ∧ Spec.permut a b)))))
  := sorry
end counting_sort_CountingSort_counting_sortqtvc
