theory search_Bfs_bfsqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "./search_Path"
begin
theorem bfs'vc:
  shows "let o1 :: state list = []; o2 :: state = start; o3 :: state list = Cons o2 o1 in int (length o3) = (1 :: int) + int (length o1) \<and> o3 ! (0 :: nat) = o2 \<and> (\<forall>(i :: int). (0 :: int) < i \<and> i \<le> int (length o1) \<longrightarrow> o3 ! nat i = o1 ! nat (i - (1 :: int))) \<longrightarrow> ((0 :: int) \<le> (0 :: int) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length o3) \<longrightarrow> path start (o3 ! nat i) (0 :: int)) \<and> (\<forall>(t :: state). path start t (0 :: int) \<longrightarrow> t \<in> set o3) \<and> (\<forall>(t :: state) (n :: int). path start t n \<longrightarrow> success t \<longrightarrow> (0 :: int) \<le> n)) \<and> (\<forall>(p :: int) (cur :: state list). (0 :: int) \<le> p \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length cur) \<longrightarrow> path start (cur ! nat i) p) \<and> (\<forall>(t :: state). path start t p \<longrightarrow> t \<in> set cur) \<and> (\<forall>(t :: state) (n :: int). path start t n \<longrightarrow> success t \<longrightarrow> p \<le> n) \<longrightarrow> (if (0 :: int) < int (length cur) then let o4 :: int = int (length cur) - (1 :: int) in ((0 :: int) \<le> o4 + (1 :: int) \<longrightarrow> ((\<forall>(l :: int). (0 :: int) \<le> l \<and> l < int (length []) \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < (0 :: int)) \<and> move (cur ! nat j) ([] ! nat l))) \<and> (\<forall>(j :: int) (k :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> (0 :: int) \<le> k \<and> k < int (length (moves (cur ! nat j))) \<longrightarrow> moves (cur ! nat j) ! nat k \<in> set []) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> \<not>success (cur ! nat j))) \<and> (\<forall>(nxt :: state list). (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o4) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l < int (length nxt) \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < i) \<and> move (cur ! nat j) (nxt ! nat l))) \<and> (\<forall>(j :: int) (k :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> (0 :: int) \<le> k \<and> k < int (length (moves (cur ! nat j))) \<longrightarrow> moves (cur ! nat j) ! nat k \<in> set nxt) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> \<not>success (cur ! nat j)) \<longrightarrow> (let s :: state = cur ! nat i in if success s then path start s p else let o5 :: state list = moves s; o6 :: state list = o5 @ nxt in int (length o6) = int (length o5) + int (length nxt) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < int (length o5) \<longrightarrow> o6 ! nat i1 = o5 ! nat i1) \<and> (\<forall>(i1 :: int). int (length o5) \<le> i1 \<and> i1 < int (length o6) \<longrightarrow> o6 ! nat i1 = nxt ! nat (i1 - int (length o5))) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l < int (length o6) \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < i + (1 :: int)) \<and> move (cur ! nat j) (o6 ! nat l))) \<and> (\<forall>(j :: int) (k :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> (0 :: int) \<le> k \<and> k < int (length (moves (cur ! nat j))) \<longrightarrow> moves (cur ! nat j) ! nat k \<in> set o6) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> \<not>success (cur ! nat j)))) \<and> ((\<forall>(l :: int). (0 :: int) \<le> l \<and> l < int (length nxt) \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < o4 + (1 :: int)) \<and> move (cur ! nat j) (nxt ! nat l))) \<and> (\<forall>(j :: int) (k :: int). (0 :: int) \<le> j \<and> j < o4 + (1 :: int) \<longrightarrow> (0 :: int) \<le> k \<and> k < int (length (moves (cur ! nat j))) \<longrightarrow> moves (cur ! nat j) ! nat k \<in> set nxt) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < o4 + (1 :: int) \<longrightarrow> \<not>success (cur ! nat j)) \<longrightarrow> (0 :: int) \<le> p + (1 :: int) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length nxt) \<longrightarrow> path start (nxt ! nat i) (p + (1 :: int))) \<and> (\<forall>(t :: state). path start t (p + (1 :: int)) \<longrightarrow> t \<in> set nxt) \<and> (\<forall>(t :: state) (n :: int). path start t n \<longrightarrow> success t \<longrightarrow> p + (1 :: int) \<le> n)))) \<and> (o4 + (1 :: int) < (0 :: int) \<longrightarrow> (0 :: int) \<le> p + (1 :: int) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length []) \<longrightarrow> path start ([] ! nat i) (p + (1 :: int))) \<and> (\<forall>(t :: state). path start t (p + (1 :: int)) \<longrightarrow> t \<in> set []) \<and> (\<forall>(t :: state) (n :: int). path start t n \<longrightarrow> success t \<longrightarrow> p + (1 :: int) \<le> n)) else \<forall>(t :: state) (n :: int). success t \<longrightarrow> \<not>path start t n))"
  sorry
end
