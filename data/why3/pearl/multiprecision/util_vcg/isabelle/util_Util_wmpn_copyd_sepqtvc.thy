theory util_Util_wmpn_copyd_sepqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/ptralias_Alias"
begin
theorem wmpn_copyd_sep'vc:
  fixes up :: "64 word ptr"
  fixes n :: "32 word"
  fixes rp :: "64 word ptr"
  assumes fact0: "valid up (sint n)"
  assumes fact1: "valid rp (sint n)"
  assumes fact2: "writable rp = True"
  shows "valid rp (sint n)"
  and "valid up (sint n)"
  and "(0 :: int) \<le> sint n"
  and "writable rp = True"
  and "\<forall>(up1 :: 64 word ptr) (rp1 :: 64 word ptr). offset up1 = offset up \<and> writable up1 = writable up \<and> zone1 up1 = zone1 up \<longrightarrow> offset rp1 = offset rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(nr :: 64 word ptr) (nx :: 64 word ptr) (m :: mem). writable nr = True \<and> value nx (sint n) = value up (sint n) \<and> (valid nr (sint n) \<and> valid nx (sint n)) \<and> ((0 :: int) \<le> offset nx \<and> offset nx + sint n \<le> offset nr) \<and> (zr m = zone1 rp1 \<and> zx m = zone1 up1) \<and> (sint (mr m) = c_C.max rp \<and> sint (mx m) = c_C.max up) \<and> (lr m = lx m \<and> lx m = n) \<and> ok m = True \<and> map_eq_sub_shift (pelts nx) (pelts up1) (offset nx) (offset up1) (sint n) \<and> map_eq_sub_shift (pelts nr) (pelts rp1) (offset nr) (offset rp1) (sint n) \<and> (pelts rp1 = pelts rp \<and> pelts up1 = pelts up) \<and> (plength rp1 = plength rp \<and> plength up1 = plength up) \<and> (c_C.min rp1 = c_C.min rp \<and> c_C.min up1 = c_C.min up) \<and> data nr = data nx \<longrightarrow> (valid nx (sint n) \<and> valid nr (sint n) \<and> writable nr = True \<and> (offset nx \<le> offset nr \<or> offset nr + sint n \<le> offset nx)) \<and> (\<forall>(nx1 :: 64 word ptr) (nr1 :: 64 word ptr). data nx1 = data nr1 \<and> length (data nr1) = length (data nx) \<and> offset nx1 = offset nx \<and> c_C.min nx1 = c_C.min nx \<and> c_C.max nx1 = c_C.max nx \<and> writable nx1 = writable nx \<and> zone1 nx1 = zone1 nx \<longrightarrow> length (data nr1) = length (data nr) \<and> offset nr1 = offset nr \<and> c_C.min nr1 = c_C.min nr \<and> c_C.max nr1 = c_C.max nr \<and> writable nr1 = writable nr \<and> zone1 nr1 = zone1 nr \<longrightarrow> map_eq_sub_shift (pelts nr1) (pelts nx) (offset nr1) (offset nx1) (sint n) \<and> (\<forall>(j :: int). j < offset nr1 \<or> offset nr1 + sint n \<le> j \<longrightarrow> pelts nr1 j = pelts nr j) \<longrightarrow> ((writable rp1 = True \<and> writable nr1 = True) \<and> ok m = True \<and> (0 :: int) \<le> sint n \<and> ((0 :: int) \<le> offset nx1 \<and> offset nx1 + sint n \<le> offset nr1) \<and> (zx m = zone1 up1 \<and> zr m = zone1 rp1) \<and> lx m = lr m \<and> lr m = n) \<and> (\<forall>(m1 :: mem) (nx2 :: 64 word ptr) (nr2 :: 64 word ptr) (up2 :: 64 word ptr) (rp2 :: 64 word ptr). zr m1 = zr m \<and> zx m1 = zx m \<and> zy m1 = zy m \<and> mr m1 = mr m \<and> mx m1 = mx m \<and> my m1 = my m \<and> lr m1 = lr m \<and> lx m1 = lx m \<and> ly m1 = ly m \<longrightarrow> offset nx2 = offset nx1 \<and> writable nx2 = writable nx1 \<and> zone1 nx2 = zone1 nx1 \<longrightarrow> offset nr2 = offset nr1 \<and> writable nr2 = writable nr1 \<and> zone1 nr2 = zone1 nr1 \<longrightarrow> offset up2 = offset up1 \<and> c_C.min up2 = c_C.min up1 \<and> writable up2 = writable up1 \<and> zone1 up2 = zone1 up1 \<longrightarrow> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> (c_C.max up2 = sint (mx m1) \<and> c_C.max rp2 = sint (mr m1)) \<and> map_eq_sub_shift (pelts nx1) (pelts up2) (offset nx2) (offset up2) (sint n) \<and> map_eq_sub_shift (pelts nr1) (pelts rp2) (offset nr2) (offset rp2) (sint n) \<and> (\<forall>(j :: int). j < offset up2 \<or> offset up2 + sint n \<le> j \<longrightarrow> pelts up2 j = pelts up1 j) \<and> (\<forall>(j :: int). j < offset rp2 \<or> offset rp2 + sint n \<le> j \<longrightarrow> pelts rp2 j = pelts rp1 j) \<and> (plength up2 = plength up1 \<and> plength rp2 = plength rp1) \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.min up2 = c_C.min up1 \<longrightarrow> map_eq_sub_shift (pelts rp2) (pelts up) (offset rp2) (offset up) (sint n) \<and> (\<forall>(j :: int). j < offset rp2 \<or> offset rp2 + sint n \<le> j \<longrightarrow> pelts rp2 j = pelts rp j) \<and> (\<forall>(j :: int). pelts up2 j = pelts up j) \<and> (c_C.min up2 = c_C.min up \<and> c_C.max up2 = c_C.max up \<and> plength up2 = plength up) \<and> c_C.min rp2 = c_C.min rp \<and> c_C.max rp2 = c_C.max rp \<and> plength rp2 = plength rp)))"
  sorry
end
