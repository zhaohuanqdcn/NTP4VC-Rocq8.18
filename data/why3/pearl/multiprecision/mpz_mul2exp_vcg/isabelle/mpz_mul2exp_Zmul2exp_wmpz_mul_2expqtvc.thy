theory mpz_mul2exp_Zmul2exp_wmpz_mul_2expqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/mpz_Z" "../../lib/isabelle/mpz_Zutil"
begin
theorem wmpz_mul_2exp'vc:
  fixes mpz :: "mpz_memo"
  fixes r :: "mpz_ptr"
  fixes u :: "mpz_ptr"
  fixes cnt :: "64 word"
  assumes fact0: "(1 :: int) \<le> alloc mpz r"
  assumes fact1: "(1 :: int) \<le> alloc mpz u"
  assumes fact2: "readers mpz r = (0 :: int)"
  assumes fact3: "readers mpz u = (0 :: int)"
  assumes fact4: "abs_size mpz u + uint cnt ediv (64 :: int) + (1 :: int) \<le> (2147483647 :: int)"
  shows "-(2 :: int) < readers mpz u"
  and "\<forall>(un :: 32 word). sint un = abs_size mpz u \<longrightarrow> (\<not>(64 :: int) = (0 :: int) \<and> uint'64_in_bounds (uint cnt cdiv (64 :: int))) \<and> (\<forall>(o1 :: 64 word). uint o1 = uint cnt cdiv (64 :: int) \<longrightarrow> uint o1 \<le> (2147483647 :: int) \<and> (\<forall>(limb_cnt :: 32 word). sint limb_cnt = uint o1 \<longrightarrow> int'32_in_bounds (sint un + sint limb_cnt) \<and> (\<forall>(o2 :: 32 word). sint o2 = sint un + sint limb_cnt \<longrightarrow> (\<forall>(o3 :: bool). (sint un = sint (0 :: 32 word) \<longrightarrow> o3 = True) \<and> (o3 = True \<longrightarrow> un = (0 :: 32 word)) \<longrightarrow> (if o3 = True then (-(1 :: int) \<le> readers mpz r \<and> readers mpz r \<le> (0 :: int)) \<and> (\<forall>(mpz1 :: mpz_memo). alloc mpz1 = alloc mpz \<and> sgn mpz1 = sgn mpz \<and> readers mpz1 = readers mpz \<and> zones mpz1 = zones mpz \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> mpz_unchanged y mpz1 mpz) \<and> abs_size mpz1 r = (0 :: int) \<and> abs_value_of mpz1 r = (0 :: int) \<longrightarrow> value_of r mpz1 = value_of u mpz * (2 :: int) ^\<^sub>i uint cnt \<and> (\<forall>(x :: mpz_ptr). \<not>x = r \<longrightarrow> mpz_unchanged x mpz1 mpz) \<and> readers mpz1 r = (0 :: int) \<and> readers mpz1 u = (0 :: int)) else int'32_in_bounds (sint o2 + (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint o2 + (1 :: int) \<longrightarrow> (readers mpz r = (0 :: int) \<and> (1 :: int) \<le> alloc mpz r) \<and> (\<forall>(mpz1 :: mpz_memo). sgn mpz1 = sgn mpz \<longrightarrow> (\<forall>(rp :: 64 word ptr). (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> mpz_unchanged y mpz1 mpz) \<and> readers mpz1 r = -(1 :: int) \<and> abs_value_of mpz1 r = value rp (abs_size mpz1 r) \<and> zones mpz1 r = zone1 rp \<and> offset rp = (0 :: int) \<and> plength rp = alloc mpz1 r \<and> c_C.min rp = (0 :: int) \<and> c_C.max rp = plength rp \<and> writable rp = True \<and> abs_size mpz1 r = abs_size mpz r \<and> value rp (abs_size mpz r) = abs_value_of mpz r \<and> (if alloc mpz r < sint o4 then alloc mpz1 r = sint o4 else alloc mpz1 r = alloc mpz r) \<longrightarrow> (\<not>(64 :: int) = (0 :: int) \<and> uint'64_in_bounds (uint cnt cmod (64 :: int))) \<and> (\<forall>(c :: 64 word). uint c = uint cnt cmod (64 :: int) \<longrightarrow> (mpz_eq u r \<longleftrightarrow> u = r) \<longrightarrow> (if mpz_eq u r then \<forall>(o5 :: bool). (uint c = uint (0 :: 64 word) \<longrightarrow> o5 = True) \<and> (o5 = True \<longrightarrow> c = (0 :: 64 word)) \<longrightarrow> (if \<not>o5 = True then (c_C.min rp \<le> offset rp + sint limb_cnt \<and> offset rp + sint limb_cnt \<le> c_C.max rp) \<and> (\<forall>(rl :: 64 word ptr). offset rl = offset rp + sint limb_cnt \<and> plength rl = plength rp \<and> pelts rl = pelts rp \<and> data rl = data rp \<and> c_C.min rl = c_C.min rp \<and> c_C.max rl = c_C.max rp \<and> zone1 rl = zone1 rp \<and> writable rl = writable rp \<longrightarrow> (((0 :: int) < uint c \<and> uint c < (64 :: int)) \<and> valid rl (sint un) \<and> valid rp (sint un) \<and> writable rl = True \<and> (0 :: int) < sint un \<and> (offset rp \<le> offset rl \<or> offset rl + sint un \<le> offset rp)) \<and> (\<forall>(rl1 :: 64 word ptr) (rp1 :: 64 word ptr). data rl1 = data rp1 \<and> length (data rp1) = length (data rl) \<and> offset rl1 = offset rl \<and> c_C.min rl1 = c_C.min rl \<and> c_C.max rl1 = c_C.max rl \<and> writable rl1 = writable rl \<and> zone1 rl1 = zone1 rl \<longrightarrow> length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(rlimb :: 64 word). value rl1 (sint un) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint un * uint rlimb = value rp (sint un) * (2 :: int) ^\<^sub>i uint c \<and> (\<forall>(j :: int). j < offset rl1 \<or> offset rl1 + sint un \<le> j \<longrightarrow> pelts rl1 j = pelts rl j) \<and> (c_C.min rl1 = c_C.min rl \<and> c_C.max rl1 = c_C.max rl \<and> plength rl1 = plength rl) \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> plength rp1 = plength rp \<longrightarrow> ((c_C.min rp1 \<le> offset rp1 + sint o2 \<and> offset rp1 + sint o2 < c_C.max rp1) \<and> writable rp1 = True) \<and> (\<forall>(rp2 :: 64 word ptr). length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> pelts rp2 = (pelts rp1)(offset rp2 + sint o2 := rlimb) \<and> pelts rp2 (offset rp2 + sint o2) = rlimb \<longrightarrow> (\<forall>(o6 :: bool). (uint rlimb = uint (0 :: 64 word) \<longrightarrow> o6 = True) \<and> (o6 = True \<longrightarrow> rlimb = (0 :: 64 word)) \<longrightarrow> (\<forall>(o7 :: 32 word). (if \<not>o6 = True then o7 = (1 :: 32 word) else o7 = (0 :: 32 word)) \<longrightarrow> int'32_in_bounds (sint o2 + sint o7) \<and> (\<forall>(o8 :: 32 word). sint o8 = sint o2 + sint o7 \<longrightarrow> (valid rp2 (sint limb_cnt) \<and> writable rp2 = True) \<and> (\<forall>(rp3 :: 64 word ptr). length (data rp3) = length (data rp2) \<and> offset rp3 = offset rp2 \<and> c_C.min rp3 = c_C.min rp2 \<and> c_C.max rp3 = c_C.max rp2 \<and> writable rp3 = writable rp2 \<and> zone1 rp3 = zone1 rp2 \<longrightarrow> value rp3 (sint limb_cnt) = (0 :: int) \<and> (\<forall>(j :: int). j < offset rp3 \<or> offset rp3 + sint limb_cnt \<le> j \<longrightarrow> pelts rp3 j = pelts rp2 j) \<longrightarrow> -(2 :: int) < readers mpz1 u \<and> (\<forall>(o9 :: 32 word). sint o9 = sgn mpz1 u * abs_size mpz1 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o9 \<longrightarrow> int'32_in_bounds (-sint o8)) \<and> ((\<not>(0 :: int) \<le> sint o9 \<longrightarrow> (\<exists>(nrn :: 32 word). sint nrn = -sint o8)) \<longrightarrow> -(2 :: int) < readers mpz1 u \<and> (\<forall>(o10 :: 32 word). sint o10 = sgn mpz1 u * abs_size mpz1 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o10 \<longrightarrow> int'32_in_bounds (-sint o8)) \<and> (\<forall>(o11 :: 32 word). (if (0 :: int) \<le> sint o10 then o11 = o8 else sint o11 = -sint o8) \<longrightarrow> (zones mpz1 r = zone1 rp3 \<and> readers mpz1 r = -(1 :: int) \<and> offset rp3 = (0 :: int) \<and> c_C.min rp3 = (0 :: int) \<and> c_C.max rp3 = plength rp3 \<and> abs (sint o11) \<le> plength rp3 \<and> plength rp3 = alloc mpz1 r \<and> (\<not>sint o11 = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint o11) - (1 :: int)) \<le> value rp3 (abs (sint o11)))) \<and> (\<forall>(mpz2 :: mpz_memo). alloc mpz2 = alloc mpz1 \<and> readers mpz2 = readers mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> mpz_unchanged y mpz2 mpz1) \<and> (sgn mpz2 r = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint o11) \<and> (sgn mpz2 r = -(1 :: int) \<longleftrightarrow> sint o11 < (0 :: int)) \<and> abs_size mpz2 r = abs (sint o11) \<and> abs_value_of mpz2 r = value rp3 (abs (sint o11)) \<longrightarrow> (zones mpz2 r = zone1 rp3 \<and> readers mpz2 r = -(1 :: int) \<and> c_C.min rp3 = (0 :: int) \<and> c_C.max rp3 = plength rp3 \<and> abs_value_of mpz2 r = value rp3 (abs_size mpz2 r)) \<and> (\<forall>(mpz3 :: mpz_memo). abs_value_of mpz3 = abs_value_of mpz2 \<and> alloc mpz3 = alloc mpz2 \<and> abs_size mpz3 = abs_size mpz2 \<and> sgn mpz3 = sgn mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> readers mpz3 r = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> readers mpz3 y = readers mpz2 y) \<longrightarrow> value_of r mpz3 = value_of u mpz * (2 :: int) ^\<^sub>i uint cnt \<and> (\<forall>(x :: mpz_ptr). \<not>x = r \<longrightarrow> mpz_unchanged x mpz3 mpz) \<and> readers mpz3 r = (0 :: int) \<and> readers mpz3 u = (0 :: int))))))))))))))) else (valid rp (sint limb_cnt) \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> value rp1 (sint limb_cnt) = (0 :: int) \<and> (\<forall>(j :: int). j < offset rp1 \<or> offset rp1 + sint limb_cnt \<le> j \<longrightarrow> pelts rp1 j = pelts rp j) \<longrightarrow> -(2 :: int) < readers mpz1 u \<and> (\<forall>(o6 :: 32 word). sint o6 = sgn mpz1 u * abs_size mpz1 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o6 \<longrightarrow> int'32_in_bounds (-sint o2)) \<and> ((\<not>(0 :: int) \<le> sint o6 \<longrightarrow> (\<exists>(nrn :: 32 word). sint nrn = -sint o2)) \<longrightarrow> -(2 :: int) < readers mpz1 u \<and> (\<forall>(o7 :: 32 word). sint o7 = sgn mpz1 u * abs_size mpz1 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o7 \<longrightarrow> int'32_in_bounds (-sint o2)) \<and> (\<forall>(o8 :: 32 word). (if (0 :: int) \<le> sint o7 then o8 = o2 else sint o8 = -sint o2) \<longrightarrow> (zones mpz1 r = zone1 rp1 \<and> readers mpz1 r = -(1 :: int) \<and> offset rp1 = (0 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs (sint o8) \<le> plength rp1 \<and> plength rp1 = alloc mpz1 r \<and> (\<not>sint o8 = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint o8) - (1 :: int)) \<le> value rp1 (abs (sint o8)))) \<and> (\<forall>(mpz2 :: mpz_memo). alloc mpz2 = alloc mpz1 \<and> readers mpz2 = readers mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> mpz_unchanged y mpz2 mpz1) \<and> (sgn mpz2 r = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint o8) \<and> (sgn mpz2 r = -(1 :: int) \<longleftrightarrow> sint o8 < (0 :: int)) \<and> abs_size mpz2 r = abs (sint o8) \<and> abs_value_of mpz2 r = value rp1 (abs (sint o8)) \<longrightarrow> (zones mpz2 r = zone1 rp1 \<and> readers mpz2 r = -(1 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs_value_of mpz2 r = value rp1 (abs_size mpz2 r)) \<and> (\<forall>(mpz3 :: mpz_memo). abs_value_of mpz3 = abs_value_of mpz2 \<and> alloc mpz3 = alloc mpz2 \<and> abs_size mpz3 = abs_size mpz2 \<and> sgn mpz3 = sgn mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> readers mpz3 r = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> readers mpz3 y = readers mpz2 y) \<longrightarrow> value_of r mpz3 = value_of u mpz * (2 :: int) ^\<^sub>i uint cnt \<and> (\<forall>(x :: mpz_ptr). \<not>x = r \<longrightarrow> mpz_unchanged x mpz3 mpz) \<and> readers mpz3 r = (0 :: int) \<and> readers mpz3 u = (0 :: int))))))))) else mpz_unchanged u mpz1 mpz \<and> (readers mpz1 u = readers mpz u \<and> (-(2 :: int) < readers mpz1 u \<longrightarrow> abs_value_of mpz1 u = abs_value_of mpz u \<and> alloc mpz1 u = alloc mpz u \<and> abs_size mpz1 u = abs_size mpz u \<and> sgn mpz1 u = sgn mpz u \<and> readers mpz1 u = readers mpz u \<and> zones mpz1 u = zones mpz u) \<longrightarrow> (0 :: int) \<le> readers mpz1 u \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> (\<forall>(up :: 64 word ptr). readers mpz2 u = readers mpz1 u + (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>u = y \<longrightarrow> readers mpz2 y = readers mpz1 y) \<and> value up (abs_size mpz2 u) = abs_value_of mpz2 u \<and> plength up = alloc mpz2 u \<and> offset up = (0 :: int) \<and> c_C.min up = (0 :: int) \<and> c_C.max up = plength up \<and> zone1 up = zones mpz2 u \<longrightarrow> (\<forall>(o5 :: bool). (uint c = uint (0 :: 64 word) \<longrightarrow> o5 = True) \<and> (o5 = True \<longrightarrow> c = (0 :: 64 word)) \<longrightarrow> (if \<not>o5 = True then (c_C.min rp \<le> offset rp + sint limb_cnt \<and> offset rp + sint limb_cnt \<le> c_C.max rp) \<and> (\<forall>(rl :: 64 word ptr). offset rl = offset rp + sint limb_cnt \<and> plength rl = plength rp \<and> pelts rl = pelts rp \<and> data rl = data rp \<and> c_C.min rl = c_C.min rp \<and> c_C.max rl = c_C.max rp \<and> zone1 rl = zone1 rp \<and> writable rl = writable rp \<longrightarrow> (((0 :: int) < uint c \<and> uint c < (64 :: int)) \<and> valid rl (sint un) \<and> valid up (sint un) \<and> writable rl = True \<and> (0 :: int) < sint un) \<and> (\<forall>(rl1 :: 64 word ptr) (rp1 :: 64 word ptr). data rl1 = data rp1 \<and> length (data rp1) = length (data rl) \<and> offset rl1 = offset rl \<and> c_C.min rl1 = c_C.min rl \<and> c_C.max rl1 = c_C.max rl \<and> writable rl1 = writable rl \<and> zone1 rl1 = zone1 rl \<longrightarrow> length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(rlimb :: 64 word). value rl1 (sint un) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint un * uint rlimb = value up (sint un) * (2 :: int) ^\<^sub>i uint c \<longrightarrow> ((c_C.min rp1 \<le> offset rp1 + sint o2 \<and> offset rp1 + sint o2 < c_C.max rp1) \<and> writable rp1 = True) \<and> (\<forall>(rp2 :: 64 word ptr). length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> pelts rp2 = (pelts rp1)(offset rp2 + sint o2 := rlimb) \<and> pelts rp2 (offset rp2 + sint o2) = rlimb \<longrightarrow> (\<forall>(o6 :: bool). (uint rlimb = uint (0 :: 64 word) \<longrightarrow> o6 = True) \<and> (o6 = True \<longrightarrow> rlimb = (0 :: 64 word)) \<longrightarrow> (\<forall>(o7 :: 32 word). (if \<not>o6 = True then o7 = (1 :: 32 word) else o7 = (0 :: 32 word)) \<longrightarrow> int'32_in_bounds (sint o2 + sint o7) \<and> (\<forall>(o8 :: 32 word). sint o8 = sint o2 + sint o7 \<longrightarrow> (zones mpz2 u = zone1 up \<and> (1 :: int) \<le> readers mpz2 u \<and> c_C.min up = (0 :: int) \<and> c_C.max up = plength up) \<and> (\<forall>(mpz3 :: mpz_memo). abs_value_of mpz3 = abs_value_of mpz2 \<and> alloc mpz3 = alloc mpz2 \<and> abs_size mpz3 = abs_size mpz2 \<and> sgn mpz3 = sgn mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> readers mpz3 u = readers mpz2 u - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = u \<longrightarrow> readers mpz3 y = readers mpz2 y) \<longrightarrow> (valid rp2 (sint limb_cnt) \<and> writable rp2 = True) \<and> (\<forall>(rp3 :: 64 word ptr). length (data rp3) = length (data rp2) \<and> offset rp3 = offset rp2 \<and> c_C.min rp3 = c_C.min rp2 \<and> c_C.max rp3 = c_C.max rp2 \<and> writable rp3 = writable rp2 \<and> zone1 rp3 = zone1 rp2 \<longrightarrow> value rp3 (sint limb_cnt) = (0 :: int) \<and> (\<forall>(j :: int). j < offset rp3 \<or> offset rp3 + sint limb_cnt \<le> j \<longrightarrow> pelts rp3 j = pelts rp2 j) \<longrightarrow> -(2 :: int) < readers mpz3 u \<and> (\<forall>(o9 :: 32 word). sint o9 = sgn mpz3 u * abs_size mpz3 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o9 \<longrightarrow> int'32_in_bounds (-sint o8)) \<and> ((\<not>(0 :: int) \<le> sint o9 \<longrightarrow> (\<exists>(nrn :: 32 word). sint nrn = -sint o8)) \<longrightarrow> -(2 :: int) < readers mpz3 u \<and> (\<forall>(o10 :: 32 word). sint o10 = sgn mpz3 u * abs_size mpz3 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o10 \<longrightarrow> int'32_in_bounds (-sint o8)) \<and> (\<forall>(o11 :: 32 word). (if (0 :: int) \<le> sint o10 then o11 = o8 else sint o11 = -sint o8) \<longrightarrow> (zones mpz3 r = zone1 rp3 \<and> readers mpz3 r = -(1 :: int) \<and> offset rp3 = (0 :: int) \<and> c_C.min rp3 = (0 :: int) \<and> c_C.max rp3 = plength rp3 \<and> abs (sint o11) \<le> plength rp3 \<and> plength rp3 = alloc mpz3 r \<and> (\<not>sint o11 = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint o11) - (1 :: int)) \<le> value rp3 (abs (sint o11)))) \<and> (\<forall>(mpz4 :: mpz_memo). alloc mpz4 = alloc mpz3 \<and> readers mpz4 = readers mpz3 \<and> zones mpz4 = zones mpz3 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> mpz_unchanged y mpz4 mpz3) \<and> (sgn mpz4 r = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint o11) \<and> (sgn mpz4 r = -(1 :: int) \<longleftrightarrow> sint o11 < (0 :: int)) \<and> abs_size mpz4 r = abs (sint o11) \<and> abs_value_of mpz4 r = value rp3 (abs (sint o11)) \<longrightarrow> (zones mpz4 r = zone1 rp3 \<and> readers mpz4 r = -(1 :: int) \<and> c_C.min rp3 = (0 :: int) \<and> c_C.max rp3 = plength rp3 \<and> abs_value_of mpz4 r = value rp3 (abs_size mpz4 r)) \<and> (\<forall>(mpz5 :: mpz_memo). abs_value_of mpz5 = abs_value_of mpz4 \<and> alloc mpz5 = alloc mpz4 \<and> abs_size mpz5 = abs_size mpz4 \<and> sgn mpz5 = sgn mpz4 \<and> zones mpz5 = zones mpz4 \<longrightarrow> readers mpz5 r = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> readers mpz5 y = readers mpz4 y) \<longrightarrow> value_of r mpz5 = value_of u mpz * (2 :: int) ^\<^sub>i uint cnt \<and> (\<forall>(x :: mpz_ptr). \<not>x = r \<longrightarrow> mpz_unchanged x mpz5 mpz) \<and> readers mpz5 r = (0 :: int) \<and> readers mpz5 u = (0 :: int)))))))))))))))) else (c_C.min rp \<le> offset rp + sint limb_cnt \<and> offset rp + sint limb_cnt \<le> c_C.max rp) \<and> (\<forall>(rl :: 64 word ptr). offset rl = offset rp + sint limb_cnt \<and> plength rl = plength rp \<and> pelts rl = pelts rp \<and> data rl = data rp \<and> c_C.min rl = c_C.min rp \<and> c_C.max rl = c_C.max rp \<and> zone1 rl = zone1 rp \<and> writable rl = writable rp \<longrightarrow> (valid up (sint un) \<and> valid rl (sint un) \<and> writable rl = True) \<and> (\<forall>(rl1 :: 64 word ptr) (rp1 :: 64 word ptr). data rl1 = data rp1 \<and> length (data rp1) = length (data rl) \<and> offset rl1 = offset rl \<and> c_C.min rl1 = c_C.min rl \<and> c_C.max rl1 = c_C.max rl \<and> writable rl1 = writable rl \<and> zone1 rl1 = zone1 rl \<longrightarrow> length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> map_eq_sub_shift (pelts rl1) (pelts up) (offset rl1) (offset up) (sint un) \<and> (\<forall>(j :: int). j < offset rl1 \<or> offset rl1 + sint un \<le> j \<longrightarrow> pelts rl1 j = pelts rl j) \<longrightarrow> (zones mpz2 u = zone1 up \<and> (1 :: int) \<le> readers mpz2 u \<and> c_C.min up = (0 :: int) \<and> c_C.max up = plength up) \<and> (\<forall>(mpz3 :: mpz_memo). abs_value_of mpz3 = abs_value_of mpz2 \<and> alloc mpz3 = alloc mpz2 \<and> abs_size mpz3 = abs_size mpz2 \<and> sgn mpz3 = sgn mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> readers mpz3 u = readers mpz2 u - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = u \<longrightarrow> readers mpz3 y = readers mpz2 y) \<longrightarrow> (valid rp1 (sint limb_cnt) \<and> writable rp1 = True) \<and> (\<forall>(rp2 :: 64 word ptr). length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> value rp2 (sint limb_cnt) = (0 :: int) \<and> (\<forall>(j :: int). j < offset rp2 \<or> offset rp2 + sint limb_cnt \<le> j \<longrightarrow> pelts rp2 j = pelts rp1 j) \<longrightarrow> -(2 :: int) < readers mpz3 u \<and> (\<forall>(o6 :: 32 word). sint o6 = sgn mpz3 u * abs_size mpz3 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o6 \<longrightarrow> int'32_in_bounds (-sint o2)) \<and> ((\<not>(0 :: int) \<le> sint o6 \<longrightarrow> (\<exists>(nrn :: 32 word). sint nrn = -sint o2)) \<longrightarrow> -(2 :: int) < readers mpz3 u \<and> (\<forall>(o7 :: 32 word). sint o7 = sgn mpz3 u * abs_size mpz3 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o7 \<longrightarrow> int'32_in_bounds (-sint o2)) \<and> (\<forall>(o8 :: 32 word). (if (0 :: int) \<le> sint o7 then o8 = o2 else sint o8 = -sint o2) \<longrightarrow> (zones mpz3 r = zone1 rp2 \<and> readers mpz3 r = -(1 :: int) \<and> offset rp2 = (0 :: int) \<and> c_C.min rp2 = (0 :: int) \<and> c_C.max rp2 = plength rp2 \<and> abs (sint o8) \<le> plength rp2 \<and> plength rp2 = alloc mpz3 r \<and> (\<not>sint o8 = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint o8) - (1 :: int)) \<le> value rp2 (abs (sint o8)))) \<and> (\<forall>(mpz4 :: mpz_memo). alloc mpz4 = alloc mpz3 \<and> readers mpz4 = readers mpz3 \<and> zones mpz4 = zones mpz3 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> mpz_unchanged y mpz4 mpz3) \<and> (sgn mpz4 r = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint o8) \<and> (sgn mpz4 r = -(1 :: int) \<longleftrightarrow> sint o8 < (0 :: int)) \<and> abs_size mpz4 r = abs (sint o8) \<and> abs_value_of mpz4 r = value rp2 (abs (sint o8)) \<longrightarrow> (zones mpz4 r = zone1 rp2 \<and> readers mpz4 r = -(1 :: int) \<and> c_C.min rp2 = (0 :: int) \<and> c_C.max rp2 = plength rp2 \<and> abs_value_of mpz4 r = value rp2 (abs_size mpz4 r)) \<and> (\<forall>(mpz5 :: mpz_memo). abs_value_of mpz5 = abs_value_of mpz4 \<and> alloc mpz5 = alloc mpz4 \<and> abs_size mpz5 = abs_size mpz4 \<and> sgn mpz5 = sgn mpz4 \<and> zones mpz5 = zones mpz4 \<longrightarrow> readers mpz5 r = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> readers mpz5 y = readers mpz4 y) \<longrightarrow> value_of r mpz5 = value_of u mpz * (2 :: int) ^\<^sub>i uint cnt \<and> (\<forall>(x :: mpz_ptr). \<not>x = r \<longrightarrow> mpz_unchanged x mpz5 mpz) \<and> readers mpz5 r = (0 :: int) \<and> readers mpz5 u = (0 :: int))))))))))))))))))))))))))"
  sorry
end
