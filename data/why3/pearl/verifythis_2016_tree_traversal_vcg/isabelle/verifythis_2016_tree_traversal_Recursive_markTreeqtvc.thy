theory verifythis_2016_tree_traversal_Recursive_markTreeqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapExt" "./verifythis_2016_tree_traversal_Memory" "./verifythis_2016_tree_traversal_TreeShape" "Why3STD.bintree_Tree" "Why3STD.bintree_Size"
begin
theorem markTree'vc:
  fixes memo :: "memory"
  fixes t :: "loc tree"
  fixes root :: "loc"
  assumes fact0: "is_tree (accessor memo) t root null"
  assumes fact1: "\<not>root = null"
  shows "let o1 :: loc = null in (\<forall>(entered :: bool) (x :: loc) (memo1 :: memory) (mem0 :: kind \<Rightarrow> loc \<Rightarrow> loc) (ph :: phase). rotated mem0 (accessor memo1) ph x \<and> (ph = Finish \<longrightarrow> entered = True) \<longrightarrow> (\<forall>(o2 :: bool). (if entered = True then o2 = (if x = null then True else False) else o2 = False) \<longrightarrow> (if o2 = True then ph = Finish else \<not>x = null \<and> (\<forall>(memo2 :: memory). accessor memo2 = accessor memo1 \<longrightarrow> mark memo2 = (mark memo1)(x := True) \<longrightarrow> \<not>x = null \<and> (let o3 :: loc = accessor memo2 Left x in (o3 = null \<longrightarrow> \<not>x = null) \<and> (\<forall>(o4 :: bool). (if o3 = null then o4 = (if accessor memo2 Right x = null then True else False) else o4 = False) \<longrightarrow> (if o4 = True then \<not>x = null \<and> \<not>ph = Finish \<and> mark memo2 x = True \<and> (\<forall>(l :: loc). \<not>l = x \<longrightarrow> mark memo2 l = mark memo1 l) \<and> (if accessor memo1 Left x = null \<and> null = accessor memo1 Right x then accessor memo2 = accessor memo1 else rotated mem0 (accessor memo2) (next_phase ph) x) else \<not>x = null \<and> \<not>x = null \<and> (let o5 :: kind = Left in \<not>x = null \<and> (\<forall>(memo3 :: memory). mark memo3 = mark memo2 \<longrightarrow> accessor memo3 = (accessor memo2)(o5 := (accessor memo2 o5)(x := accessor memo2 Right x)) \<longrightarrow> \<not>x = null \<and> (let o6 :: kind = Right in \<not>x = null \<and> (\<forall>(memo4 :: memory). mark memo4 = mark memo3 \<longrightarrow> accessor memo4 = (accessor memo3)(o6 := (accessor memo3 o6)(x := accessor memo3 Parent x)) \<longrightarrow> (let o7 :: kind = Parent in \<not>x = null \<and> (\<forall>(memo5 :: memory). mark memo5 = mark memo4 \<longrightarrow> accessor memo5 = (accessor memo4)(o7 := (accessor memo4 o7)(x := accessor memo2 Left x)) \<longrightarrow> accessor memo2 Left x = accessor memo5 Parent x \<and> \<not>ph = Finish \<and> mark memo5 x = True \<and> (\<forall>(l :: loc). \<not>l = x \<longrightarrow> mark memo5 l = mark memo1 l) \<and> (if accessor memo1 Left x = null \<and> null = accessor memo1 Right x then accessor memo5 = accessor memo1 else rotated mem0 (accessor memo5) (next_phase ph) x)))))))))))))) \<and> (\<forall>(z :: loc) (x :: loc) (memo1 :: memory) (t1 :: loc tree). \<not>x = null \<and> is_tree (accessor memo1) t1 x z \<longrightarrow> (let mem0 :: kind \<Rightarrow> loc \<Rightarrow> loc = accessor memo1 in \<not>x = null \<and> (let x_lf :: loc = accessor memo1 Left x in \<not>x = null \<and> (let x_rg :: loc = accessor memo1 Right x in (case t1 of (Empty :: loc tree) \<Rightarrow> False | Node l _ r \<Rightarrow> True) \<and> (\<forall>(lf :: loc tree) (rg :: loc tree). (case t1 of (Empty :: loc tree) \<Rightarrow> False | Node l _ r \<Rightarrow> lf = l \<and> rg = r) \<longrightarrow> is_tree mem0 (Node lf x rg) x z \<and> (\<not>x \<in> footprint lf \<and> \<not>x \<in> footprint rg \<longrightarrow> (let o2 :: phase = GoLeft in rotated mem0 (accessor memo1) o2 x \<and> (\<forall>(memo2 :: memory). mark memo2 x = True \<and> (\<forall>(l :: loc). \<not>l = x \<longrightarrow> mark memo2 l = mark memo1 l) \<and> (if accessor memo1 Left x = null \<and> null = accessor memo1 Right x then accessor memo2 = accessor memo1 else rotated mem0 (accessor memo2) (next_phase o2) x) \<longrightarrow> (\<forall>(result :: bool). (if x_lf = null then result = (if x_rg = null then True else False) else result = False) \<longrightarrow> (result = True \<longleftrightarrow> x_lf = null \<and> x_rg = null) \<and> (result = True \<longrightarrow> lf = (Empty :: loc tree) \<and> rg = (Empty :: loc tree))) \<and> ((x_lf = null \<and> x_rg = null \<longrightarrow> lf = (Empty :: loc tree) \<and> rg = (Empty :: loc tree)) \<longrightarrow> (if \<not>(x_lf = null \<and> x_rg = null) then (ext (footprint lf) mem0 (accessor memo2) \<and> is_tree mem0 lf x_lf x) \<and> (is_tree (accessor memo2) lf x_lf x \<longrightarrow> ((case t1 of (Empty :: loc tree) \<Rightarrow> False | Node f _ f1 \<Rightarrow> f = lf \<or> f1 = lf) \<and> \<not>accessor memo2 Parent x = null \<and> is_tree (accessor memo2) lf (accessor memo2 Parent x) x) \<and> (\<forall>(memo3 :: memory). unchanged (accessor memo2) (accessor memo3) \<and> was_marked lf (mark memo2) (mark memo3) \<longrightarrow> (let o3 :: phase = GoRight in rotated mem0 (accessor memo3) o3 x \<and> (\<forall>(memo4 :: memory). mark memo4 x = True \<and> (\<forall>(l :: loc). \<not>l = x \<longrightarrow> mark memo4 l = mark memo3 l) \<and> (if accessor memo3 Left x = null \<and> null = accessor memo3 Right x then accessor memo4 = accessor memo3 else rotated mem0 (accessor memo4) (next_phase o3) x) \<longrightarrow> (ext (footprint rg) mem0 (accessor memo4) \<and> is_tree mem0 rg x_rg x) \<and> (is_tree (accessor memo4) rg x_rg x \<longrightarrow> ((case t1 of (Empty :: loc tree) \<Rightarrow> False | Node f _ f1 \<Rightarrow> f = rg \<or> f1 = rg) \<and> \<not>accessor memo4 Parent x = null \<and> is_tree (accessor memo4) rg (accessor memo4 Parent x) x) \<and> (\<forall>(memo5 :: memory). unchanged (accessor memo4) (accessor memo5) \<and> was_marked rg (mark memo4) (mark memo5) \<longrightarrow> (let o4 :: phase = GoBack in rotated mem0 (accessor memo5) o4 x \<and> (\<forall>(memo6 :: memory). mark memo6 x = True \<and> (\<forall>(l :: loc). \<not>l = x \<longrightarrow> mark memo6 l = mark memo5 l) \<and> (if accessor memo5 Left x = null \<and> null = accessor memo5 Right x then accessor memo6 = accessor memo5 else rotated mem0 (accessor memo6) (next_phase o4) x) \<longrightarrow> unchanged (accessor memo1) (accessor memo6) \<and> accessor memo6 Parent x = z \<and> was_marked t1 (mark memo1) (mark memo6))))))))) else unchanged (accessor memo1) (accessor memo2) \<and> accessor memo2 Parent x = z \<and> was_marked t1 (mark memo1) (mark memo2))))))))))) \<and> (let mem0 :: kind \<Rightarrow> loc \<Rightarrow> loc = accessor memo in (\<not>root = null \<and> is_tree (accessor memo) t root o1) \<and> (\<forall>(memo1 :: memory). unchanged (accessor memo) (accessor memo1) \<and> was_marked t (mark memo) (mark memo1) \<longrightarrow> rotated mem0 (accessor memo1) Finish o1 \<and> (\<forall>(x :: loc). rotated mem0 (accessor memo1) Finish x \<longrightarrow> rotated mem0 (accessor memo1) Finish x \<and> (let o2 :: loc = null in (ext (footprint t) mem0 (accessor memo1) \<and> is_tree mem0 t root o2) \<and> (is_tree (accessor memo1) t root o2 \<longrightarrow> is_tree (accessor memo1) t root null \<and> unchanged (accessor memo) (accessor memo1) \<and> was_marked t (mark memo) (mark memo1))))))"
  sorry
end
