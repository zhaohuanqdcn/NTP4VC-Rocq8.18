import Why3.Base
import Why3.int.NumOf
import Why3.queue.Queue
open Classical
open Lean4Why3
namespace mergesort_queue_MergesortQueue_mergeqtvc
axiom elt : Type
axiom inhabited_axiom_elt : Inhabited elt
attribute [instance] inhabited_axiom_elt
axiom le : elt -> elt -> Prop
axiom Refl (x : elt) : le x x
axiom Trans (x : elt) (y : elt) (z : elt) (fact0 : le x y) (fact1 : le y z) : le x z
axiom Total (x : elt) (y : elt) : le x y ∨ le y x
noncomputable def sorted_sub (s : List elt) (l : ℤ) (u : ℤ) := ∀(i1 : ℤ) (i2 : ℤ), l ≤ i1 ∧ i1 ≤ i2 ∧ i2 < u → le (s[Int.toNat i1]!) (s[Int.toNat i2]!)
noncomputable def sorted (s : List elt) := sorted_sub s (0 : ℤ) (Int.ofNat (List.length s))
axiom sorted_cons (s : List elt) (x : elt) : ((∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s) → le x (s[Int.toNat i]!)) ∧ sorted s) = sorted (List.cons x s)
axiom sorted_append (s1 : List elt) (s2 : List elt) : (sorted s1 ∧ sorted s2 ∧ (∀(i : ℤ) (j : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s1)) ∧ (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length s2) → le (s1[Int.toNat i]!) (s2[Int.toNat j]!))) = sorted (s1 ++ s2)
axiom sorted_snoc (s : List elt) (x : elt) : ((∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s) → le (s[Int.toNat i]!) x) ∧ sorted s) = sorted (s ++ [x])
theorem merge'vc (q : Queue.t elt) (q1 : Queue.t elt) (q2 : Queue.t elt) (fact0 : Queue.seq q = ([] : List elt)) (fact1 : sorted (Queue.seq q1)) (fact2 : sorted (Queue.seq q2)) : sorted (Queue.seq q1) ∧ sorted (Queue.seq q2) ∧ sorted (Queue.seq q) ∧ (∀(x : elt) (y : elt), x ∈ Queue.seq q → y ∈ Queue.seq q1 → le x y) ∧ (∀(x : elt) (y : elt), x ∈ Queue.seq q → y ∈ Queue.seq q2 → le x y) ∧ Int.ofNat (List.length (Queue.seq q)) + Int.ofNat (List.length (Queue.seq q1)) + Int.ofNat (List.length (Queue.seq q2)) = Int.ofNat (List.length (Queue.seq q1)) + Int.ofNat (List.length (Queue.seq q2)) ∧ (∀(x : elt), Int.ofNat (List.count x (Queue.seq q)) + Int.ofNat (List.count x (Queue.seq q1)) + Int.ofNat (List.count x (Queue.seq q2)) = Int.ofNat (List.count x (Queue.seq q1)) + Int.ofNat (List.count x (Queue.seq q2))) ∧ (∀(q3 : Queue.t elt) (q21 : Queue.t elt) (q11 : Queue.t elt), (sorted (Queue.seq q11) ∧ sorted (Queue.seq q21) ∧ sorted (Queue.seq q3)) ∧ (∀(x : elt) (y : elt), x ∈ Queue.seq q3 → y ∈ Queue.seq q11 → le x y) ∧ (∀(x : elt) (y : elt), x ∈ Queue.seq q3 → y ∈ Queue.seq q21 → le x y) ∧ Int.ofNat (List.length (Queue.seq q3)) + Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q21)) = Int.ofNat (List.length (Queue.seq q1)) + Int.ofNat (List.length (Queue.seq q2)) ∧ (∀(x : elt), Int.ofNat (List.count x (Queue.seq q3)) + Int.ofNat (List.count x (Queue.seq q11)) + Int.ofNat (List.count x (Queue.seq q21)) = Int.ofNat (List.count x (Queue.seq q1)) + Int.ofNat (List.count x (Queue.seq q2))) → (∀(o1 : Bool), (if Queue.seq q11 = ([] : List elt) then o1 = (if Queue.seq q21 = ([] : List elt) then true else false) else o1 = false) → (if ¬o1 = true then if Queue.seq q11 = ([] : List elt) then ¬Queue.seq q21 = ([] : List elt) ∧ (∀(q22 : Queue.t elt), Queue.seq q22 = List.drop (1 : ℕ) (Queue.seq q21) → (∀(q4 : Queue.t elt), Queue.seq q4 = Queue.seq q3 ++ [(Queue.seq q21)[(0 : ℕ)]!] → ((0 : ℤ) ≤ Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q21)) ∧ Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q22)) < Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q21))) ∧ (sorted (Queue.seq q11) ∧ sorted (Queue.seq q22) ∧ sorted (Queue.seq q4)) ∧ (∀(x : elt) (y : elt), x ∈ Queue.seq q4 → y ∈ Queue.seq q11 → le x y) ∧ (∀(x : elt) (y : elt), x ∈ Queue.seq q4 → y ∈ Queue.seq q22 → le x y) ∧ Int.ofNat (List.length (Queue.seq q4)) + Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q22)) = Int.ofNat (List.length (Queue.seq q1)) + Int.ofNat (List.length (Queue.seq q2)) ∧ (∀(x : elt), Int.ofNat (List.count x (Queue.seq q4)) + Int.ofNat (List.count x (Queue.seq q11)) + Int.ofNat (List.count x (Queue.seq q22)) = Int.ofNat (List.count x (Queue.seq q1)) + Int.ofNat (List.count x (Queue.seq q2))))) else if Queue.seq q21 = ([] : List elt) then ¬Queue.seq q11 = ([] : List elt) ∧ (∀(q12 : Queue.t elt), Queue.seq q12 = List.drop (1 : ℕ) (Queue.seq q11) → (∀(q4 : Queue.t elt), Queue.seq q4 = Queue.seq q3 ++ [(Queue.seq q11)[(0 : ℕ)]!] → ((0 : ℤ) ≤ Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q21)) ∧ Int.ofNat (List.length (Queue.seq q12)) + Int.ofNat (List.length (Queue.seq q21)) < Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q21))) ∧ (sorted (Queue.seq q12) ∧ sorted (Queue.seq q21) ∧ sorted (Queue.seq q4)) ∧ (∀(x : elt) (y : elt), x ∈ Queue.seq q4 → y ∈ Queue.seq q12 → le x y) ∧ (∀(x : elt) (y : elt), x ∈ Queue.seq q4 → y ∈ Queue.seq q21 → le x y) ∧ Int.ofNat (List.length (Queue.seq q4)) + Int.ofNat (List.length (Queue.seq q12)) + Int.ofNat (List.length (Queue.seq q21)) = Int.ofNat (List.length (Queue.seq q1)) + Int.ofNat (List.length (Queue.seq q2)) ∧ (∀(x : elt), Int.ofNat (List.count x (Queue.seq q4)) + Int.ofNat (List.count x (Queue.seq q12)) + Int.ofNat (List.count x (Queue.seq q21)) = Int.ofNat (List.count x (Queue.seq q1)) + Int.ofNat (List.count x (Queue.seq q2))))) else ¬Queue.seq q11 = ([] : List elt) ∧ ¬Queue.seq q21 = ([] : List elt) ∧ (if le ((Queue.seq q11)[(0 : ℕ)]!) ((Queue.seq q21)[(0 : ℕ)]!) then ¬Queue.seq q11 = ([] : List elt) ∧ (∀(q12 : Queue.t elt), Queue.seq q12 = List.drop (1 : ℕ) (Queue.seq q11) → (∀(q4 : Queue.t elt), Queue.seq q4 = Queue.seq q3 ++ [(Queue.seq q11)[(0 : ℕ)]!] → ((0 : ℤ) ≤ Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q21)) ∧ Int.ofNat (List.length (Queue.seq q12)) + Int.ofNat (List.length (Queue.seq q21)) < Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q21))) ∧ (sorted (Queue.seq q12) ∧ sorted (Queue.seq q21) ∧ sorted (Queue.seq q4)) ∧ (∀(x : elt) (y : elt), x ∈ Queue.seq q4 → y ∈ Queue.seq q12 → le x y) ∧ (∀(x : elt) (y : elt), x ∈ Queue.seq q4 → y ∈ Queue.seq q21 → le x y) ∧ Int.ofNat (List.length (Queue.seq q4)) + Int.ofNat (List.length (Queue.seq q12)) + Int.ofNat (List.length (Queue.seq q21)) = Int.ofNat (List.length (Queue.seq q1)) + Int.ofNat (List.length (Queue.seq q2)) ∧ (∀(x : elt), Int.ofNat (List.count x (Queue.seq q4)) + Int.ofNat (List.count x (Queue.seq q12)) + Int.ofNat (List.count x (Queue.seq q21)) = Int.ofNat (List.count x (Queue.seq q1)) + Int.ofNat (List.count x (Queue.seq q2))))) else ¬Queue.seq q21 = ([] : List elt) ∧ (∀(q22 : Queue.t elt), Queue.seq q22 = List.drop (1 : ℕ) (Queue.seq q21) → (∀(q4 : Queue.t elt), Queue.seq q4 = Queue.seq q3 ++ [(Queue.seq q21)[(0 : ℕ)]!] → ((0 : ℤ) ≤ Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q21)) ∧ Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q22)) < Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q21))) ∧ (sorted (Queue.seq q11) ∧ sorted (Queue.seq q22) ∧ sorted (Queue.seq q4)) ∧ (∀(x : elt) (y : elt), x ∈ Queue.seq q4 → y ∈ Queue.seq q11 → le x y) ∧ (∀(x : elt) (y : elt), x ∈ Queue.seq q4 → y ∈ Queue.seq q22 → le x y) ∧ Int.ofNat (List.length (Queue.seq q4)) + Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q22)) = Int.ofNat (List.length (Queue.seq q1)) + Int.ofNat (List.length (Queue.seq q2)) ∧ (∀(x : elt), Int.ofNat (List.count x (Queue.seq q4)) + Int.ofNat (List.count x (Queue.seq q11)) + Int.ofNat (List.count x (Queue.seq q22)) = Int.ofNat (List.count x (Queue.seq q1)) + Int.ofNat (List.count x (Queue.seq q2)))))) else sorted (Queue.seq q3) ∧ Int.ofNat (List.length (Queue.seq q3)) = Int.ofNat (List.length (Queue.seq q1)) + Int.ofNat (List.length (Queue.seq q2)) ∧ (∀(x : elt), Int.ofNat (List.count x (Queue.seq q3)) = Int.ofNat (List.count x (Queue.seq q1)) + Int.ofNat (List.count x (Queue.seq q2))))))
  := sorry
end mergesort_queue_MergesortQueue_mergeqtvc
