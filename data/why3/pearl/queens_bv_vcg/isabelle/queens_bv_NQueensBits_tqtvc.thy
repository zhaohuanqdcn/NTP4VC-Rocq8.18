theory queens_bv_NQueensBits_tqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.WellFounded_WellFounded" "Why3STD.Ref_Ref" "./queens_bv_S" "./queens_bv_Solution" "./queens_bv_BitsSpec"
begin
theorem t'vc:
  fixes k :: "int"
  fixes a :: "t"
  fixes s :: "int"
  fixes col :: "int \<Rightarrow> int"
  fixes b :: "t"
  fixes c :: "t"
  fixes sol :: "int \<Rightarrow> int \<Rightarrow> int"
  assumes fact0: "n \<le> (32 :: int)"
  assumes fact1: "(0 :: int) \<le> k"
  assumes fact2: "k + int (fcard (mdl a)) = n"
  assumes fact3: "(0 :: int) \<le> s"
  assumes fact4: "\<forall>(i :: int). i |\<in>| mdl a \<longleftrightarrow> ((0 :: int) \<le> i \<and> i < n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k \<longrightarrow> \<not>col j = i)"
  assumes fact5: "\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (32 :: int) \<longrightarrow> \<not>i |\<in>| mdl b \<longleftrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k \<longrightarrow> \<not>i - col j = k - j)"
  assumes fact6: "\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (32 :: int) \<longrightarrow> \<not>i |\<in>| mdl c \<longleftrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k \<longrightarrow> \<not>i - col j = j - k)"
  assumes fact7: "partial_solution k col"
  shows "if \<not>mdl a = fempty then \<forall>(o1 :: t). mdl o1 = mdl a |-| mdl b \<longrightarrow> (\<forall>(o2 :: t). mdl o2 = mdl o1 |-| mdl c \<longrightarrow> ((\<not>mdl o2 = fempty \<longrightarrow> -(1 :: int) < Min (fset (mdl o2))) \<and> ((0 :: int) = s - s \<and> (0 :: int) \<le> s - s) \<and> mdl o2 |\<subseteq>| mdl a |-| mdl b |-| mdl c \<and> partial_solution k col \<and> queens_bv_Solution.sorted sol s s \<and> (\<forall>(i :: int). i |\<in>| mdl o2 \<and> \<not>i |\<in>| mdl o2 \<longrightarrow> i \<le> -(1 :: int)) \<and> (\<forall>(i :: int). s \<le> i \<and> i < s \<longrightarrow> partial_solution n (sol i) \<and> eq_prefix col (sol i) k \<and> (0 :: int) \<le> sol i k \<and> sol i k \<le> -(1 :: int)) \<and> (\<forall>(u :: int \<Rightarrow> int). partial_solution n u \<and> eq_prefix col u k \<and> (0 :: int) \<le> u k \<and> u k \<le> -(1 :: int) \<longrightarrow> u k |\<in>| mdl o2 \<and> \<not>u k |\<in>| mdl o2 \<and> (\<exists>(i :: int). (s \<le> i \<and> i < s) \<and> eq_prefix u (sol i) n)) \<and> eq_prefix col col k \<and> eq_prefix sol sol s) \<and> (\<forall>(min :: int) (e :: t) (s1 :: int) (sol1 :: int \<Rightarrow> int \<Rightarrow> int) (col1 :: int \<Rightarrow> int). (\<not>mdl e = fempty \<longrightarrow> min < Min (fset (mdl e))) \<and> (0 :: int) \<le> s1 - s \<and> mdl e |\<subseteq>| mdl a |-| mdl b |-| mdl c \<and> partial_solution k col1 \<and> queens_bv_Solution.sorted sol1 s s1 \<and> (\<forall>(i :: int). i |\<in>| mdl o2 \<and> \<not>i |\<in>| mdl e \<longrightarrow> i \<le> min) \<and> (\<forall>(i :: int). s \<le> i \<and> i < s1 \<longrightarrow> partial_solution n (sol1 i) \<and> eq_prefix col1 (sol1 i) k \<and> (0 :: int) \<le> sol1 i k \<and> sol1 i k \<le> min) \<and> (\<forall>(u :: int \<Rightarrow> int). partial_solution n u \<and> eq_prefix col1 u k \<and> (0 :: int) \<le> u k \<and> u k \<le> min \<longrightarrow> u k |\<in>| mdl o2 \<and> \<not>u k |\<in>| mdl e \<and> (\<exists>(i :: int). (s \<le> i \<and> i < s1) \<and> eq_prefix u (sol1 i) n)) \<and> eq_prefix col col1 k \<and> eq_prefix sol sol1 s \<longrightarrow> (if \<not>mdl e = fempty then \<not>mdl e = fempty \<and> (\<forall>(d :: t). mdl d = finsert (Min (fset (mdl e))) fempty \<longrightarrow> mdl d = finsert (Min (fset (mdl d))) fempty \<and> (\<forall>(o3 :: t). mdl o3 = finsert (Min (fset (mdl d))) (mdl b) \<longrightarrow> (\<forall>(b' :: t). mdl b' = fset_remove (32 :: int) (succ (mdl o3)) \<longrightarrow> mdl d = finsert (Min (fset (mdl d))) fempty \<and> (\<forall>(o4 :: t). mdl o4 = finsert (Min (fset (mdl d))) (mdl c) \<longrightarrow> (\<forall>(c' :: t). mdl c' = pred (mdl o4) \<longrightarrow> (let o5 :: int = k + (1 :: int) in mdl d = finsert (Min (fset (mdl d))) fempty \<and> (\<forall>(o6 :: t). mdl o6 = finsert (Min (fset (mdl d))) (mdl c) \<longrightarrow> (\<forall>(o7 :: t). mdl o7 = pred (mdl o6) \<longrightarrow> mdl d = finsert (Min (fset (mdl d))) fempty \<and> (\<forall>(o8 :: t). mdl o8 = finsert (Min (fset (mdl d))) (mdl b) \<longrightarrow> (\<forall>(o9 :: t). mdl o9 = fset_remove (32 :: int) (succ (mdl o8)) \<longrightarrow> (mdl d = finsert (Min (fset (mdl d))) fempty \<and> Min (fset (mdl d)) |\<in>| mdl a) \<and> (\<forall>(o10 :: t). mdl o10 = fset_remove (Min (fset (mdl d))) (mdl a) \<longrightarrow> (((0 :: int) \<le> int (fcard (mdl a)) \<and> fcard (mdl o10) < fcard (mdl a)) \<and> n \<le> (32 :: int) \<and> (0 :: int) \<le> o5 \<and> o5 + int (fcard (mdl o10)) = n \<and> (0 :: int) \<le> s1 \<and> (\<forall>(i :: int). i |\<in>| mdl o10 \<longleftrightarrow> ((0 :: int) \<le> i \<and> i < n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < o5 \<longrightarrow> \<not>(col1(k := Min (fset (mdl e)))) j = i)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (32 :: int) \<longrightarrow> \<not>i |\<in>| mdl o9 \<longleftrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < o5 \<longrightarrow> \<not>i - (col1(k := Min (fset (mdl e)))) j = o5 - j)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (32 :: int) \<longrightarrow> \<not>i |\<in>| mdl o7 \<longleftrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < o5 \<longrightarrow> \<not>i - (col1(k := Min (fset (mdl e)))) j = j - o5)) \<and> partial_solution o5 (col1(k := Min (fset (mdl e))))) \<and> (\<forall>(s2 :: int) (sol2 :: int \<Rightarrow> int \<Rightarrow> int) (col2 :: int \<Rightarrow> int). (0 :: int) \<le> s2 - s1 \<and> queens_bv_Solution.sorted sol2 s1 s2 \<and> (\<forall>(i :: int). s1 \<le> i \<and> i < s2 \<longrightarrow> partial_solution n (sol2 i) \<and> eq_prefix col2 (sol2 i) o5) \<and> (\<forall>(u :: int \<Rightarrow> int). partial_solution n u \<and> eq_prefix col2 u o5 \<longrightarrow> (\<exists>(i :: int). (s1 \<le> i \<and> i < s2) \<and> eq_prefix u (sol2 i) n)) \<and> eq_prefix (col1(k := Min (fset (mdl e)))) col2 o5 \<and> eq_prefix sol1 sol2 s1 \<longrightarrow> (mdl d = finsert (Min (fset (mdl d))) fempty \<and> Min (fset (mdl d)) |\<in>| mdl e) \<and> (\<forall>(o11 :: t). mdl o11 = fset_remove (Min (fset (mdl d))) (mdl e) \<longrightarrow> ((0 :: int) \<le> int (fcard (mdl e)) \<and> fcard (mdl o11) < fcard (mdl e)) \<and> (\<not>mdl o11 = fempty \<longrightarrow> Min (fset (mdl e)) < Min (fset (mdl o11))) \<and> (s1 - s + (s2 - s1) = s2 - s \<and> (0 :: int) \<le> s2 - s) \<and> mdl o11 |\<subseteq>| mdl a |-| mdl b |-| mdl c \<and> partial_solution k col2 \<and> queens_bv_Solution.sorted sol2 s s2 \<and> (\<forall>(i :: int). i |\<in>| mdl o2 \<and> \<not>i |\<in>| mdl o11 \<longrightarrow> i \<le> Min (fset (mdl e))) \<and> (\<forall>(i :: int). s \<le> i \<and> i < s2 \<longrightarrow> partial_solution n (sol2 i) \<and> eq_prefix col2 (sol2 i) k \<and> (0 :: int) \<le> sol2 i k \<and> sol2 i k \<le> Min (fset (mdl e))) \<and> (\<forall>(u :: int \<Rightarrow> int). partial_solution n u \<and> eq_prefix col2 u k \<and> (0 :: int) \<le> u k \<and> u k \<le> Min (fset (mdl e)) \<longrightarrow> u k |\<in>| mdl o2 \<and> \<not>u k |\<in>| mdl o11 \<and> (\<exists>(i :: int). (s \<le> i \<and> i < s2) \<and> eq_prefix u (sol2 i) n)) \<and> eq_prefix col col2 k \<and> eq_prefix sol sol2 s))))))))))))) else (0 :: int) \<le> s1 - s \<and> queens_bv_Solution.sorted sol1 s s1 \<and> (\<forall>(i :: int). s \<le> i \<and> i < s1 \<longrightarrow> partial_solution n (sol1 i) \<and> eq_prefix col1 (sol1 i) k) \<and> (\<forall>(u :: int \<Rightarrow> int). partial_solution n u \<and> eq_prefix col1 u k \<longrightarrow> (\<exists>(i :: int). (s \<le> i \<and> i < s1) \<and> eq_prefix u (sol1 i) n)) \<and> eq_prefix col col1 k \<and> eq_prefix sol sol1 s))) else ((1 :: int) = s + (1 :: int) - s \<and> (0 :: int) \<le> s + (1 :: int) - s) \<and> queens_bv_Solution.sorted (sol(s := col)) s (s + (1 :: int)) \<and> (\<forall>(i :: int). s \<le> i \<and> i < s + (1 :: int) \<longrightarrow> partial_solution n ((sol(s := col)) i) \<and> eq_prefix col ((sol(s := col)) i) k) \<and> (\<forall>(u :: int \<Rightarrow> int). partial_solution n u \<and> eq_prefix col u k \<longrightarrow> (\<exists>(i :: int). (s \<le> i \<and> i < s + (1 :: int)) \<and> eq_prefix u ((sol(s := col)) i) n)) \<and> eq_prefix col col k \<and> eq_prefix sol (sol(s := col)) s"
  sorry
end
