import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.LogicalOld
open Classical
open Lean4Why3
namespace div_Div_wmpn_divrem_1qtvc
noncomputable def reciprocal (v : BitVec 64) (d : BitVec 64) := BitVec.toUInt v = (((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) - (1 : ℤ)) / BitVec.toUInt d - ((18446744073709551615 : ℤ) + (1 : ℤ))
theorem wmpn_divrem_1'vc (x : C.ptr (BitVec 64)) (sz : BitVec 32) (q : C.ptr (BitVec 64)) (y : BitVec 64) (fact0 : C.valid x (BitVec.toInt sz)) (fact1 : C.valid q (BitVec.toInt sz)) (fact2 : C.writable q = true) (fact3 : (0 : ℤ) < BitVec.toInt sz) (fact4 : (0 : ℤ) < BitVec.toUInt y) : int'32_in_bounds (BitVec.toInt sz - (1 : ℤ)) ∧ (∀(msb : BitVec 32), BitVec.toInt msb = BitVec.toInt sz - (1 : ℤ) → (0 : ℤ) < BitVec.toUInt y ∧ (∀(clz : BitVec 32), HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)) * BitVec.toUInt y ≤ (18446744073709551615 : ℤ) ∧ (18446744073709551615 : ℤ) < (2 : ℤ) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)) * BitVec.toUInt y ∧ (0 : ℤ) ≤ BitVec.toInt clz ∧ BitVec.toInt clz < (64 : ℤ) → (if (0 : ℤ) < BitVec.toInt clz then let mult : ℤ := HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)); (0 : ℤ) ≤ BitVec.toInt clz ∧ (∀(o1 : BitVec 64), BitVec.toUInt o1 = BitVec.toInt clz → (((0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o1)) * BitVec.toUInt y ≤ (18446744073709551615 : ℤ)) ∧ (∀(ry : BitVec 64), BitVec.toUInt ry = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o1)) * BitVec.toUInt y → ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt ry ∧ (∀(v : BitVec 64), reciprocal v ry → ((-(1 : ℤ) ≤ BitVec.toInt msb ∧ BitVec.toInt msb ≤ BitVec.toInt msb) ∧ (0 : ℤ) < BitVec.toUInt ry ∧ mult * Lemmas.value_sub (C.pelts x) (C.offset x + BitVec.toInt msb + (1 : ℤ)) (C.offset x + BitVec.toInt sz) = Lemmas.value_sub (C.pelts q) (C.offset q + BitVec.toInt msb + (1 : ℤ)) (C.offset q + BitVec.toInt sz) * BitVec.toUInt ry + (0 : ℤ) ∧ (0 : ℤ) ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - mult ∧ (0 : ℤ) % mult = (0 : ℤ)) ∧ (∀(r : BitVec 64) (i : BitVec 32) (q1 : C.ptr (BitVec 64)), List.length (C.data q1) = List.length (C.data q) ∧ C.offset q1 = C.offset q ∧ C.min q1 = C.min q ∧ C.max q1 = C.max q ∧ C.writable q1 = C.writable q ∧ C.zone1 q1 = C.zone1 q → (-(1 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt msb) ∧ BitVec.toUInt r < BitVec.toUInt ry ∧ mult * Lemmas.value_sub (C.pelts x) (C.offset x + BitVec.toInt i + (1 : ℤ)) (C.offset x + BitVec.toInt sz) = Lemmas.value_sub (C.pelts q1) (C.offset q1 + BitVec.toInt i + (1 : ℤ)) (C.offset q1 + BitVec.toInt sz) * BitVec.toUInt ry + BitVec.toUInt r ∧ BitVec.toUInt r ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - mult ∧ BitVec.toUInt r % mult = (0 : ℤ) → (if (0 : ℤ) ≤ BitVec.toInt i then (C.min x ≤ C.offset x + BitVec.toInt i ∧ C.offset x + BitVec.toInt i < C.max x) ∧ (0 : ℤ) ≤ BitVec.toInt clz ∧ (∀(o2 : BitVec 64), BitVec.toUInt o2 = BitVec.toInt clz → ((0 : ℤ) < BitVec.toUInt o2 ∧ BitVec.toUInt o2 < (64 : ℤ)) ∧ (∀(l : BitVec 64) (h : BitVec 64), BitVec.toUInt l + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt h = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o2)) * BitVec.toUInt (C.pelts x (C.offset x + BitVec.toInt i)) ∧ BitVec.toUInt l % HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o2)) = (0 : ℤ) ∧ BitVec.toUInt l ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o2)) ∧ BitVec.toUInt h < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o2)) → uint'64_in_bounds (BitVec.toUInt r + BitVec.toUInt h) ∧ (∀(o3 : BitVec 64), BitVec.toUInt o3 = BitVec.toUInt r + BitVec.toUInt h → (((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt ry ∧ BitVec.toUInt o3 < BitVec.toUInt ry ∧ reciprocal v ry) ∧ (∀(qu : BitVec 64) (rem : BitVec 64), BitVec.toUInt qu * BitVec.toUInt ry + BitVec.toUInt rem = BitVec.toUInt l + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt o3 ∧ (0 : ℤ) ≤ BitVec.toUInt rem ∧ BitVec.toUInt rem < BitVec.toUInt ry → ¬mult = (0 : ℤ) ∧ (let o4 : ℤ := C.offset q1 + BitVec.toInt sz; let o5 : ℤ := C.offset q1 + (1 : ℤ) + BitVec.toInt i; let o6 : ℤ := C.offset q1 + BitVec.toInt i; let o7 : ℤ -> BitVec 64 := C.pelts q1; (o5 ≤ o4 ∧ (o6 < o5 ∨ o4 ≤ o6)) ∧ (Lemmas.value_sub o7 o5 o4 = Lemmas.value_sub (Function.update o7 o6 qu) o5 o4 → ((C.min q1 ≤ C.offset q1 + BitVec.toInt i ∧ C.offset q1 + BitVec.toInt i < C.max q1) ∧ C.writable q1 = true) ∧ (∀(q2 : C.ptr (BitVec 64)), List.length (C.data q2) = List.length (C.data q1) ∧ C.offset q2 = C.offset q1 ∧ C.min q2 = C.min q1 ∧ C.max q2 = C.max q1 ∧ C.writable q2 = C.writable q1 ∧ C.zone1 q2 = C.zone1 q1 → C.pelts q2 = Function.update (C.pelts q1) (C.offset q2 + BitVec.toInt i) qu ∧ C.pelts q2 (C.offset q2 + BitVec.toInt i) = qu → int'32_in_bounds (BitVec.toInt i - (1 : ℤ)) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt i - (1 : ℤ) → BitVec.toInt o8 < BitVec.toInt i ∧ (-(1 : ℤ) ≤ BitVec.toInt o8 ∧ BitVec.toInt o8 ≤ BitVec.toInt msb) ∧ BitVec.toUInt rem < BitVec.toUInt ry ∧ mult * Lemmas.value_sub (C.pelts x) (C.offset x + BitVec.toInt o8 + (1 : ℤ)) (C.offset x + BitVec.toInt sz) = Lemmas.value_sub (C.pelts q2) (C.offset q2 + BitVec.toInt o8 + (1 : ℤ)) (C.offset q2 + BitVec.toInt sz) * BitVec.toUInt ry + BitVec.toUInt rem ∧ BitVec.toUInt rem ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - mult ∧ BitVec.toUInt rem % mult = (0 : ℤ))))))))) else (0 : ℤ) ≤ BitVec.toInt clz ∧ (∀(o2 : BitVec 64), BitVec.toUInt o2 = BitVec.toInt clz → (((0 : ℤ) ≤ BitVec.toUInt o2 ∧ BitVec.toUInt o2 < (64 : ℤ)) ∧ BitVec.toUInt r % HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o2)) = (0 : ℤ)) ∧ (∀(res : BitVec 64), BitVec.toUInt r = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o2)) * BitVec.toUInt res → (0 : ℤ) ≤ BitVec.toInt clz ∧ (∀(o3 : BitVec 64), BitVec.toUInt o3 = BitVec.toInt clz → (((0 : ℤ) ≤ BitVec.toUInt o3 ∧ BitVec.toUInt o3 < (64 : ℤ)) ∧ BitVec.toUInt r % HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o3)) = (0 : ℤ)) ∧ (∀(result : BitVec 64), BitVec.toUInt r = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o3)) * BitVec.toUInt result → Lemmas.value x (BitVec.toInt sz) = Lemmas.value q1 (BitVec.toInt sz) * BitVec.toUInt y + BitVec.toUInt result ∧ BitVec.toUInt result < BitVec.toUInt y))))))))) else ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt y ∧ (∀(v : BitVec 64), reciprocal v y → ((-(1 : ℤ) ≤ BitVec.toInt msb ∧ BitVec.toInt msb ≤ BitVec.toInt msb) ∧ (0 : ℤ) < BitVec.toUInt y ∧ Lemmas.value_sub (C.pelts x) (C.offset x + BitVec.toInt msb + (1 : ℤ)) (C.offset x + BitVec.toInt sz) = Lemmas.value_sub (C.pelts q) (C.offset q + BitVec.toInt msb + (1 : ℤ)) (C.offset q + BitVec.toInt sz) * BitVec.toUInt y + (0 : ℤ)) ∧ (∀(r : BitVec 64) (i : BitVec 32) (q1 : C.ptr (BitVec 64)), List.length (C.data q1) = List.length (C.data q) ∧ C.offset q1 = C.offset q ∧ C.min q1 = C.min q ∧ C.max q1 = C.max q ∧ C.writable q1 = C.writable q ∧ C.zone1 q1 = C.zone1 q → (-(1 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt msb) ∧ BitVec.toUInt r < BitVec.toUInt y ∧ Lemmas.value_sub (C.pelts x) (C.offset x + BitVec.toInt i + (1 : ℤ)) (C.offset x + BitVec.toInt sz) = Lemmas.value_sub (C.pelts q1) (C.offset q1 + BitVec.toInt i + (1 : ℤ)) (C.offset q1 + BitVec.toInt sz) * BitVec.toUInt y + BitVec.toUInt r → (if (0 : ℤ) ≤ BitVec.toInt i then (C.min x ≤ C.offset x + BitVec.toInt i ∧ C.offset x + BitVec.toInt i < C.max x) ∧ (((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt y ∧ BitVec.toUInt r < BitVec.toUInt y ∧ reciprocal v y) ∧ (∀(qu : BitVec 64) (rem : BitVec 64), BitVec.toUInt qu * BitVec.toUInt y + BitVec.toUInt rem = BitVec.toUInt (C.pelts x (C.offset x + BitVec.toInt i)) + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt r ∧ (0 : ℤ) ≤ BitVec.toUInt rem ∧ BitVec.toUInt rem < BitVec.toUInt y → (let o1 : ℤ := C.offset q1 + BitVec.toInt sz; let o2 : ℤ := C.offset q1 + (1 : ℤ) + BitVec.toInt i; let o3 : ℤ := C.offset q1 + BitVec.toInt i; let o4 : ℤ -> BitVec 64 := C.pelts q1; (o2 ≤ o1 ∧ (o3 < o2 ∨ o1 ≤ o3)) ∧ (Lemmas.value_sub o4 o2 o1 = Lemmas.value_sub (Function.update o4 o3 qu) o2 o1 → ((C.min q1 ≤ C.offset q1 + BitVec.toInt i ∧ C.offset q1 + BitVec.toInt i < C.max q1) ∧ C.writable q1 = true) ∧ (∀(q2 : C.ptr (BitVec 64)), List.length (C.data q2) = List.length (C.data q1) ∧ C.offset q2 = C.offset q1 ∧ C.min q2 = C.min q1 ∧ C.max q2 = C.max q1 ∧ C.writable q2 = C.writable q1 ∧ C.zone1 q2 = C.zone1 q1 → C.pelts q2 = Function.update (C.pelts q1) (C.offset q2 + BitVec.toInt i) qu ∧ C.pelts q2 (C.offset q2 + BitVec.toInt i) = qu → int'32_in_bounds (BitVec.toInt i - (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt i - (1 : ℤ) → BitVec.toInt o5 < BitVec.toInt i ∧ (-(1 : ℤ) ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 ≤ BitVec.toInt msb) ∧ BitVec.toUInt rem < BitVec.toUInt y ∧ Lemmas.value_sub (C.pelts x) (C.offset x + BitVec.toInt o5 + (1 : ℤ)) (C.offset x + BitVec.toInt sz) = Lemmas.value_sub (C.pelts q2) (C.offset q2 + BitVec.toInt o5 + (1 : ℤ)) (C.offset q2 + BitVec.toInt sz) * BitVec.toUInt y + BitVec.toUInt rem))))) else Lemmas.value x (BitVec.toInt sz) = Lemmas.value q1 (BitVec.toInt sz) * BitVec.toUInt y + BitVec.toUInt r ∧ BitVec.toUInt r < BitVec.toUInt y))))))
  := sorry
end div_Div_wmpn_divrem_1qtvc
