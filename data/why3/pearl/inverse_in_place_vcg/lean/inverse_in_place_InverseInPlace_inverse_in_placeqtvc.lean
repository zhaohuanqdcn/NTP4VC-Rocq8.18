import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
open Classical
open Lean4Why3
namespace inverse_in_place_InverseInPlace_inverse_in_placeqtvc
noncomputable def prefix_tl (x : ℤ) := -x - (1 : ℤ)
axiom fc : (ℤ -> ℤ) -> ℤ -> Bool
axiom fc'def (m : ℤ -> ℤ) (n : ℤ) : (fc m n = true) = ((0 : ℤ) ≤ m n)
noncomputable def numof (m : ℤ -> ℤ) (l : ℤ) (r : ℤ) := NumOf.numof (fc m) l r
noncomputable def is_permutation (a : List ℤ) := ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → ((0 : ℤ) ≤ a[Int.toNat i]! ∧ a[Int.toNat i]! < Int.ofNat (List.length a)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a) → ¬i = j → ¬a[Int.toNat i]! = a[Int.toNat j]!)
noncomputable def loopinvariant (olda : List ℤ) (a : List ℤ) (m : ℤ) (m' : ℤ) (n : ℤ) := (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < n → -n ≤ a[Int.toNat e]! ∧ a[Int.toNat e]! < n) ∧ (∀(e : ℤ), m < e ∧ e < n → (0 : ℤ) ≤ a[Int.toNat e]!) ∧ (∀(e : ℤ), m < e ∧ e < n → olda[Int.toNat (a[Int.toNat e]!)]! = e) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e ≤ m' → (0 : ℤ) ≤ a[Int.toNat e]! → olda[Int.toNat e]! = a[Int.toNat e]!) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e ≤ m → a[Int.toNat e]! ≤ m) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e ≤ m' → a[Int.toNat e]! < (0 : ℤ) → olda[Int.toNat (prefix_tl (a[Int.toNat e]!))]! = e ∧ (prefix_tl (a[Int.toNat e]!) ≤ m → a[Int.toNat (prefix_tl (a[Int.toNat e]!))]! < (0 : ℤ)))
theorem inverse_in_place'vc (a : List ℤ) (fact0 : is_permutation a) : let n : ℤ := Int.ofNat (List.length a); let o1 : ℤ := n - (1 : ℤ); ((0 : ℤ) - (1 : ℤ) ≤ o1 → loopinvariant a a o1 o1 n ∧ (∀(a1 : List ℤ), List.length a1 = List.length a → (∀(m : ℤ), (m ≤ o1 ∧ (0 : ℤ) ≤ m) ∧ loopinvariant a a1 m m n → ((0 : ℤ) ≤ m ∧ m < Int.ofNat (List.length a1)) ∧ (let o2 : ℤ := a1[Int.toNat m]!; if (0 : ℤ) ≤ o2 then ((0 : ℤ) ≤ m ∧ m < Int.ofNat (List.length a1)) ∧ (List.length (List.set a1 (Int.toNat m) (-(1 : ℤ))) = List.length a1 → getElem! (List.set a1 (Int.toNat m) (-(1 : ℤ))) ∘ Int.toNat = Function.update (getElem! a1 ∘ Int.toNat) m (-(1 : ℤ)) → (let o3 : ℤ := prefix_tl m; ((0 : ℤ) ≤ o2 ∧ o2 < Int.ofNat (List.length (List.set a1 (Int.toNat m) (-(1 : ℤ))))) ∧ (((List.set a1 (Int.toNat m) (-(1 : ℤ)))[Int.toNat o2]! ≤ m ∧ ((0 : ℤ) ≤ o2 ∧ o2 ≤ m) ∧ (prefix_tl m ≤ o3 ∧ o3 < (0 : ℤ)) ∧ a[Int.toNat (prefix_tl o3)]! = o2 ∧ (List.set a1 (Int.toNat m) (-(1 : ℤ)))[Int.toNat (prefix_tl o3)]! < (0 : ℤ) ∧ (List.set a1 (Int.toNat m) (-(1 : ℤ)))[Int.toNat m]! < (0 : ℤ)) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < m → (List.set a1 (Int.toNat m) (-(1 : ℤ)))[Int.toNat e]! < (0 : ℤ) → ¬(List.set a1 (Int.toNat m) (-(1 : ℤ)))[Int.toNat e]! = o3) ∧ loopinvariant a (List.set a1 (Int.toNat m) (-(1 : ℤ))) m (m - (1 : ℤ)) n) ∧ (∀(j : ℤ) (a2 : List ℤ), List.length a2 = List.length (List.set a1 (Int.toNat m) (-(1 : ℤ))) → (a2[Int.toNat (a[Int.toNat (prefix_tl j)]!)]! ≤ m ∧ ((0 : ℤ) ≤ a[Int.toNat (prefix_tl j)]! ∧ a[Int.toNat (prefix_tl j)]! ≤ m) ∧ (prefix_tl m ≤ j ∧ j < (0 : ℤ)) ∧ a2[Int.toNat (prefix_tl j)]! < (0 : ℤ) ∧ a2[Int.toNat m]! < (0 : ℤ)) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < m → a2[Int.toNat e]! < (0 : ℤ) → ¬a2[Int.toNat e]! = j) ∧ loopinvariant a a2 m (m - (1 : ℤ)) n → (if (0 : ℤ) ≤ a2[Int.toNat (a[Int.toNat (prefix_tl j)]!)]! then ((0 : ℤ) ≤ a[Int.toNat (prefix_tl j)]! ∧ a[Int.toNat (prefix_tl j)]! < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat (a[Int.toNat (prefix_tl j)]!)) j) = List.length a2 → getElem! (List.set a2 (Int.toNat (a[Int.toNat (prefix_tl j)]!)) j) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) (a[Int.toNat (prefix_tl j)]!) j → ((0 : ℤ) ≤ a2[Int.toNat (a[Int.toNat (prefix_tl j)]!)]! ∧ a2[Int.toNat (a[Int.toNat (prefix_tl j)]!)]! < Int.ofNat (List.length (List.set a2 (Int.toNat (a[Int.toNat (prefix_tl j)]!)) j))) ∧ ((0 : ℤ) ≤ numof (getElem! a2 ∘ Int.toNat) (0 : ℤ) n ∧ numof (getElem! (List.set a2 (Int.toNat (a[Int.toNat (prefix_tl j)]!)) j) ∘ Int.toNat) (0 : ℤ) n < numof (getElem! a2 ∘ Int.toNat) (0 : ℤ) n) ∧ ((List.set a2 (Int.toNat (a[Int.toNat (prefix_tl j)]!)) j)[Int.toNat (a2[Int.toNat (a[Int.toNat (prefix_tl j)]!)]!)]! ≤ m ∧ ((0 : ℤ) ≤ a2[Int.toNat (a[Int.toNat (prefix_tl j)]!)]! ∧ a2[Int.toNat (a[Int.toNat (prefix_tl j)]!)]! ≤ m) ∧ (prefix_tl m ≤ prefix_tl (a[Int.toNat (prefix_tl j)]!) ∧ prefix_tl (a[Int.toNat (prefix_tl j)]!) < (0 : ℤ)) ∧ a[Int.toNat (prefix_tl (prefix_tl (a[Int.toNat (prefix_tl j)]!)))]! = a2[Int.toNat (a[Int.toNat (prefix_tl j)]!)]! ∧ (List.set a2 (Int.toNat (a[Int.toNat (prefix_tl j)]!)) j)[Int.toNat (prefix_tl (prefix_tl (a[Int.toNat (prefix_tl j)]!)))]! < (0 : ℤ) ∧ (List.set a2 (Int.toNat (a[Int.toNat (prefix_tl j)]!)) j)[Int.toNat m]! < (0 : ℤ)) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < m → (List.set a2 (Int.toNat (a[Int.toNat (prefix_tl j)]!)) j)[Int.toNat e]! < (0 : ℤ) → ¬(List.set a2 (Int.toNat (a[Int.toNat (prefix_tl j)]!)) j)[Int.toNat e]! = prefix_tl (a[Int.toNat (prefix_tl j)]!)) ∧ loopinvariant a (List.set a2 (Int.toNat (a[Int.toNat (prefix_tl j)]!)) j) m (m - (1 : ℤ)) n) else let o4 : ℤ := prefix_tl j; ((0 : ℤ) ≤ m ∧ m < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat m) o4) = List.length a2 → getElem! (List.set a2 (Int.toNat m) o4) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) m o4 → loopinvariant a (List.set a2 (Int.toNat m) o4) (m - (1 : ℤ)) (m - (1 : ℤ)) n))))) else let o3 : ℤ := prefix_tl o2; ((0 : ℤ) ≤ m ∧ m < Int.ofNat (List.length a1)) ∧ (List.length (List.set a1 (Int.toNat m) o3) = List.length a1 → getElem! (List.set a1 (Int.toNat m) o3) ∘ Int.toNat = Function.update (getElem! a1 ∘ Int.toNat) m o3 → loopinvariant a (List.set a1 (Int.toNat m) o3) (m - (1 : ℤ)) (m - (1 : ℤ)) n))) ∧ (loopinvariant a a1 ((0 : ℤ) - (1 : ℤ)) ((0 : ℤ) - (1 : ℤ)) n → is_permutation a1 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1) → a[Int.toNat (a1[Int.toNat i]!)]! = i)))) ∧ (o1 < (0 : ℤ) - (1 : ℤ) → is_permutation a ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → a[Int.toNat (a[Int.toNat i]!)]! = i))
  := sorry
end inverse_in_place_InverseInPlace_inverse_in_placeqtvc
