theory patience_PatienceAbstract_testqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "./patience_PigeonHole"
begin
typedecl  card
datatype  state = state'mk (num_stacks: "int") (num_elts: "int") ("values": "int \<Rightarrow> int") (stack_sizes: "int \<Rightarrow> int") (stacks1: "int \<Rightarrow> int \<Rightarrow> int") (positions: "int \<Rightarrow> int \<times> int") (preds: "int \<Rightarrow> int")
definition inv :: "state \<Rightarrow> _"
  where "inv s \<longleftrightarrow> ((0 :: int) \<le> num_stacks s \<and> num_stacks s \<le> num_elts s) \<and> ((0 :: int) < num_elts s \<longrightarrow> (0 :: int) < num_stacks s) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_stacks s \<longrightarrow> (1 :: int) \<le> stack_sizes s i \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < stack_sizes s i \<longrightarrow> (0 :: int) \<le> stacks1 s i j \<and> stacks1 s i j < num_elts s)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_elts s \<longrightarrow> (case positions s i of (is, ip) \<Rightarrow> ((0 :: int) \<le> is \<and> is < num_stacks s) \<and> ((0 :: int) \<le> ip \<and> ip < stack_sizes s is) \<and> stacks1 s is ip = i)) \<and> (\<forall>(is :: int). (0 :: int) \<le> is \<and> is < num_stacks s \<longrightarrow> (\<forall>(ip :: int). (0 :: int) \<le> ip \<and> ip < stack_sizes s is \<longrightarrow> (is, ip) = positions s (stacks1 s is ip))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_stacks s \<longrightarrow> (let stack_i :: int \<Rightarrow> int = stacks1 s i in \<forall>(j :: int) (k :: int). (0 :: int) \<le> j \<and> j < k \<and> k < stack_sizes s i \<longrightarrow> stack_i j < stack_i k)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_stacks s \<longrightarrow> (let stack_i :: int \<Rightarrow> int = stacks1 s i in \<forall>(j :: int) (k :: int). (0 :: int) \<le> j \<and> j \<le> k \<and> k < stack_sizes s i \<longrightarrow> values s (stack_i k) \<le> values s (stack_i j))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_elts s \<longrightarrow> (let pred :: int = preds s i in (-(1 :: int) \<le> pred \<and> pred < num_elts s) \<and> pred < i \<and> (case positions s i of (is, x_ip) \<Rightarrow> (if pred < (0 :: int) then is = (0 :: int) else values s pred < values s i \<and> (0 :: int) < is \<and> (case positions s pred of (ps, x_pp) \<Rightarrow> ps = is - (1 :: int))))))" for s
datatype 'a seq = seq'mk (seqlen: "int") (seqval: "int \<Rightarrow> 'a")
definition increasing_subsequence :: "int seq \<Rightarrow> int list \<Rightarrow> _"
  where "increasing_subsequence s l \<longleftrightarrow> ((0 :: int) \<le> seqlen s \<and> seqlen s \<le> int (length l)) \<and> ((\<forall>(i :: int). (0 :: int) \<le> i \<and> i < seqlen s \<longrightarrow> (0 :: int) \<le> seqval s i \<and> seqval s i < int (length l)) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < j \<and> j < seqlen s \<longrightarrow> seqval s i < seqval s j)) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < j \<and> j < seqlen s \<longrightarrow> l ! nat (seqval s i) < l ! nat (seqval s j))" for s l
theorem test'vc:
  shows "True"
  sorry
end
