From Coq Require Import Strings.String.
From Coq Require Import String Ascii.
From Coq Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Coq Require Classical.
From Coq Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Coq Require Import Sorting.Sorted.
From Coq Require Import Reals.Rbasic_fun.
From Coq Require Import Reals.Abstract.ConstructiveAbs.
From Coq Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Coq Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Coq Require Import ZArith.Zeuclid.
From Coq Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Coq Require Import Reals.
Require Import Why3.Base.
Require Import Why3.why3.Ref.Ref.
Require Import Why3.map.Const.
Require Import Why3.map.MapEq.
Require Import Why3.mach.int.Unsigned.
Require Import Why3.mach.c.C.
Require Import multiprecision.lemmas.Lemmas.
Require Import multiprecision.types.Config.
Require Import multiprecision.types.Types.
Require Import multiprecision.types.Int32Eq.
Require Import multiprecision.types.UInt64Eq.
Require Import multiprecision.util.Util.
Require Import multiprecision.ptralias.Alias.
Require Import multiprecision.util.UtilOld.
Require Import multiprecision.compare.Compare.
Require Import multiprecision.div.Div.
Require Import multiprecision.add.Add.
Require Import multiprecision.add.AddOld.
Require Import multiprecision.sub.SubOld.
Require Import multiprecision.logical.LogicalUtil.
Require Import multiprecision.logical.LogicalOld.
Require Import multiprecision.mul.Mul.
Require Import multiprecision.mpz.Z.
Require Import multiprecision.mpz.Zutil.
Open Scope Z_scope.
Theorem wmpz_tdiv_qr_ui'vc (mpz : mpz_memo) (dividend : mpz_ptr) (quot : mpz_ptr) (rem : mpz_ptr) (divisor : bv 64%N) (fact0 : 0%Z < alloc mpz dividend) (fact1 : 0%Z < alloc mpz quot) (fact2 : 0%Z < alloc mpz rem) (fact3 : readers mpz dividend = 0%Z) (fact4 : readers mpz quot = 0%Z) (fact5 : readers mpz rem = 0%Z) (fact6 : ¬ quot = rem) (fact7 : 0%Z < bv_unsigned divisor) : - 2%Z < readers mpz dividend ∧ (∀(ns : bv 32%N), bv_signed ns = sgn mpz dividend * abs_size mpz dividend -> (∀(o1 : bool), (bv_signed ns = bv_signed (0%bv : bv 32%N) -> o1 = true) ∧ (o1 = true -> ns = (0%bv : bv 32%N)) -> (if decide (o1 = true) then (- 1%Z ≤ readers mpz quot ∧ readers mpz quot ≤ 0%Z) ∧ (∀(mpz1 : mpz_memo), alloc mpz1 = alloc mpz ∧ sgn mpz1 = sgn mpz ∧ readers mpz1 = readers mpz ∧ zones mpz1 = zones mpz -> (∀(y : mpz_ptr), ¬ y = quot -> mpz_unchanged y mpz1 mpz) ∧ abs_size mpz1 quot = 0%Z ∧ abs_value_of mpz1 quot = 0%Z -> (- 1%Z ≤ readers mpz1 rem ∧ readers mpz1 rem ≤ 0%Z) ∧ (∀(mpz2 : mpz_memo), alloc mpz2 = alloc mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ readers mpz2 = readers mpz1 ∧ zones mpz2 = zones mpz1 -> (∀(y : mpz_ptr), ¬ y = rem -> mpz_unchanged y mpz2 mpz1) ∧ abs_size mpz2 rem = 0%Z ∧ abs_value_of mpz2 rem = 0%Z -> value_of quot mpz2 * bv_unsigned divisor + value_of rem mpz2 = value_of dividend mpz ∧ 0%Z = abs_value_of mpz2 rem ∧ (0%Z ≤ abs_value_of mpz2 rem ∧ abs_value_of mpz2 rem < bv_unsigned divisor) ∧ (∀(x : mpz_ptr), ¬ x = quot -> ¬ x = rem -> mpz_unchanged x mpz2 mpz) ∧ readers mpz2 dividend = 0%Z ∧ readers mpz2 quot = 0%Z ∧ readers mpz2 rem = 0%Z)) else - 2147483648%Z < bv_signed ns ∧ (∀(nn : bv 32%N), bv_signed nn = Z.abs (bv_signed ns) -> (readers mpz quot = 0%Z ∧ 1%Z ≤ alloc mpz quot) ∧ (∀(mpz1 : mpz_memo), sgn mpz1 = sgn mpz -> (∀(qp : C.ptr (bv 64%N)), (∀(y : mpz_ptr), ¬ y = quot -> mpz_unchanged y mpz1 mpz) ∧ readers mpz1 quot = - 1%Z ∧ abs_value_of mpz1 quot = value qp (abs_size mpz1 quot) ∧ zones mpz1 quot = zone1 qp ∧ offset qp = 0%Z ∧ plength qp = alloc mpz1 quot ∧ min qp = 0%Z ∧ C.max qp = plength qp ∧ writable qp = true ∧ abs_size mpz1 quot = abs_size mpz quot ∧ value qp (abs_size mpz quot) = abs_value_of mpz quot ∧ (if decide (alloc mpz quot < bv_signed nn) then alloc mpz1 quot = bv_signed nn else alloc mpz1 quot = alloc mpz quot) -> mpz_eq quot dividend = (quot = dividend) -> (¬ mpz_eq quot dividend -> mpz_unchanged dividend mpz1 mpz) ∧ ((¬ mpz_eq quot dividend -> readers mpz1 dividend = readers mpz dividend ∧ (- 2%Z < readers mpz1 dividend -> abs_value_of mpz1 dividend = abs_value_of mpz dividend ∧ alloc mpz1 dividend = alloc mpz dividend ∧ abs_size mpz1 dividend = abs_size mpz dividend ∧ sgn mpz1 dividend = sgn mpz dividend ∧ readers mpz1 dividend = readers mpz dividend ∧ zones mpz1 dividend = zones mpz dividend)) -> mpz_unchanged rem mpz1 mpz ∧ (readers mpz1 rem = readers mpz rem ∧ (- 2%Z < readers mpz1 rem -> abs_value_of mpz1 rem = abs_value_of mpz rem ∧ alloc mpz1 rem = alloc mpz rem ∧ abs_size mpz1 rem = abs_size mpz rem ∧ sgn mpz1 rem = sgn mpz rem ∧ readers mpz1 rem = readers mpz rem ∧ zones mpz1 rem = zones mpz rem) -> mpz_eq quot dividend = (quot = dividend) -> (if decide (mpz_eq quot dividend) then 0%Z ≤ bv_signed nn ∧ (∀(o2 : bv 32%N), bv_unsigned o2 = bv_signed nn -> 0%Z ≤ bv_unsigned o2 ∧ (∀(np : C.ptr (bv 64%N)), plength np = bv_unsigned o2 ∧ offset np = 0%Z ∧ min np = 0%Z ∧ C.max np = bv_unsigned o2 ∧ writable np = true -> (valid qp (bv_signed nn) ∧ valid np (bv_signed nn) ∧ writable np = true) ∧ (∀(np1 : C.ptr (bv 64%N)) (qp1 : C.ptr (bv 64%N)), offset np1 = offset np ∧ writable np1 = writable np ∧ zone1 np1 = zone1 np -> offset qp1 = offset qp ∧ writable qp1 = writable qp ∧ zone1 qp1 = zone1 qp -> map_eq_sub_shift (pelts np1) (pelts qp) (offset np1) (offset qp) (bv_signed nn) ∧ (∀(j : Z), j < offset np1 ∨ offset np1 + bv_signed nn ≤ j -> pelts np1 j = pelts np j) ∧ (∀(j : Z), pelts qp1 j = pelts qp j) ∧ (min qp1 = min qp ∧ C.max qp1 = C.max qp ∧ plength qp1 = plength qp) ∧ min np1 = min np ∧ C.max np1 = C.max np ∧ plength np1 = plength np -> (valid np1 (bv_signed nn) ∧ valid qp1 (bv_signed nn) ∧ writable qp1 = true ∧ 0%Z < bv_signed nn ∧ 0%Z < bv_unsigned divisor) ∧ (∀(qp2 : C.ptr (bv 64%N)), length (data qp2) = length (data qp1) ∧ offset qp2 = offset qp1 ∧ min qp2 = min qp1 ∧ C.max qp2 = C.max qp1 ∧ writable qp2 = writable qp1 ∧ zone1 qp2 = zone1 qp1 -> (∀(o3 : bv 64%N), value np1 (bv_signed nn) = value qp2 (bv_signed nn) * bv_unsigned divisor + bv_unsigned o3 ∧ bv_unsigned o3 < bv_unsigned divisor -> (∀(o4 : bool), (bv_unsigned o3 = bv_unsigned (0%bv : bv 64%N) -> o4 = true) ∧ (o4 = true -> o3 = (0%bv : bv 64%N)) -> (if decide (o4 = true) then (- 1%Z ≤ readers mpz1 rem ∧ readers mpz1 rem ≤ 0%Z) ∧ (∀(mpz2 : mpz_memo), alloc mpz2 = alloc mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ readers mpz2 = readers mpz1 ∧ zones mpz2 = zones mpz1 -> (∀(y : mpz_ptr), ¬ y = rem -> mpz_unchanged y mpz2 mpz1) ∧ abs_size mpz2 rem = 0%Z ∧ abs_value_of mpz2 rem = 0%Z -> int'32_in_bounds (bv_signed nn - 1%Z) ∧ (∀(o5 : bv 32%N), bv_signed o5 = bv_signed nn - 1%Z -> (min qp2 ≤ offset qp2 + bv_signed o5 ∧ offset qp2 + bv_signed o5 < C.max qp2) ∧ (let qh : bv 64%N := pelts qp2 (offset qp2 + bv_signed o5) in ∀(o6 : bool), (bv_unsigned qh = bv_unsigned (0%bv : bv 64%N) -> o6 = true) ∧ (o6 = true -> qh = (0%bv : bv 64%N)) -> (∀(o7 : bv 32%N), (if decide (o6 = true) then o7 = (1%bv : bv 32%N) else o7 = (0%bv : bv 32%N)) -> int'32_in_bounds (bv_signed nn - bv_signed o7) ∧ (∀(o8 : bv 32%N), bv_signed o8 = bv_signed nn - bv_signed o7 -> (¬ 0%Z ≤ bv_signed ns -> int'32_in_bounds (- bv_signed o8)) ∧ (∀(qs : bv 32%N), (if decide (0%Z ≤ bv_signed ns) then qs = o8 else bv_signed qs = - bv_signed o8) -> (zones mpz2 quot = zone1 qp2 ∧ readers mpz2 quot = - 1%Z ∧ offset qp2 = 0%Z ∧ min qp2 = 0%Z ∧ C.max qp2 = plength qp2 ∧ Z.abs (bv_signed qs) ≤ plength qp2 ∧ plength qp2 = alloc mpz2 quot ∧ (¬ bv_signed qs = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed qs) - 1%Z) ≤ value qp2 (Z.abs (bv_signed qs)))) ∧ (∀(mpz3 : mpz_memo), alloc mpz3 = alloc mpz2 ∧ readers mpz3 = readers mpz2 ∧ zones mpz3 = zones mpz2 -> (∀(y : mpz_ptr), ¬ y = quot -> mpz_unchanged y mpz3 mpz2) ∧ (sgn mpz3 quot = 1%Z) = (0%Z ≤ bv_signed qs) ∧ (sgn mpz3 quot = - 1%Z) = (bv_signed qs < 0%Z) ∧ abs_size mpz3 quot = Z.abs (bv_signed qs) ∧ abs_value_of mpz3 quot = value qp2 (Z.abs (bv_signed qs)) -> (zones mpz3 quot = zone1 qp2 ∧ readers mpz3 quot = - 1%Z ∧ min qp2 = 0%Z ∧ C.max qp2 = plength qp2 ∧ abs_value_of mpz3 quot = value qp2 (abs_size mpz3 quot)) ∧ (∀(mpz4 : mpz_memo), abs_value_of mpz4 = abs_value_of mpz3 ∧ alloc mpz4 = alloc mpz3 ∧ abs_size mpz4 = abs_size mpz3 ∧ sgn mpz4 = sgn mpz3 ∧ zones mpz4 = zones mpz3 -> readers mpz4 quot = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = quot -> readers mpz4 y = readers mpz3 y) -> mpz_unchanged rem mpz4 mpz2 ∧ (readers mpz4 rem = readers mpz2 rem ∧ (- 2%Z < readers mpz4 rem -> abs_value_of mpz4 rem = abs_value_of mpz2 rem ∧ alloc mpz4 rem = alloc mpz2 rem ∧ abs_size mpz4 rem = abs_size mpz2 rem ∧ sgn mpz4 rem = sgn mpz2 rem ∧ readers mpz4 rem = readers mpz2 rem ∧ zones mpz4 rem = zones mpz2 rem) -> value_of quot mpz4 * bv_unsigned divisor + value_of rem mpz4 = value_of dividend mpz ∧ bv_unsigned o3 = abs_value_of mpz4 rem ∧ (0%Z ≤ abs_value_of mpz4 rem ∧ abs_value_of mpz4 rem < bv_unsigned divisor) ∧ (∀(x : mpz_ptr), ¬ x = quot -> ¬ x = rem -> mpz_unchanged x mpz4 mpz) ∧ readers mpz4 dividend = 0%Z ∧ readers mpz4 quot = 0%Z ∧ readers mpz4 rem = 0%Z))))))))) else ∀(rs : bv 32%N), (if decide (0%Z ≤ bv_signed ns) then rs = (1%bv : bv 32%N) else rs = ((-1)%bv : bv 32%N)) -> readers mpz1 rem = 0%Z ∧ (∀(mpz2 : mpz_memo), abs_value_of mpz2 = abs_value_of mpz1 ∧ alloc mpz2 = alloc mpz1 ∧ abs_size mpz2 = abs_size mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ zones mpz2 = zones mpz1 -> (∀(rp : C.ptr (bv 64%N)), readers mpz2 rem = - 1%Z ∧ (∀(y : mpz_ptr), ¬ rem = y -> readers mpz2 y = readers mpz1 y) ∧ value rp (abs_size mpz2 rem) = abs_value_of mpz2 rem ∧ plength rp = alloc mpz2 rem ∧ offset rp = 0%Z ∧ min rp = 0%Z ∧ C.max rp = plength rp ∧ writable rp = true ∧ zone1 rp = zones mpz2 rem -> ((min rp ≤ offset rp ∧ offset rp < C.max rp) ∧ writable rp = true) ∧ (∀(rp1 : C.ptr (bv 64%N)), length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> pelts rp1 = fun_updt (pelts rp) (offset rp1) o3 -> (zones mpz2 rem = zone1 rp1 ∧ readers mpz2 rem = - 1%Z ∧ offset rp1 = 0%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ Z.abs (bv_signed rs) ≤ plength rp1 ∧ plength rp1 = alloc mpz2 rem ∧ (¬ bv_signed rs = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed rs) - 1%Z) ≤ value rp1 (Z.abs (bv_signed rs)))) ∧ (∀(mpz3 : mpz_memo), alloc mpz3 = alloc mpz2 ∧ readers mpz3 = readers mpz2 ∧ zones mpz3 = zones mpz2 -> (∀(y : mpz_ptr), ¬ y = rem -> mpz_unchanged y mpz3 mpz2) ∧ (sgn mpz3 rem = 1%Z) = (0%Z ≤ bv_signed rs) ∧ (sgn mpz3 rem = - 1%Z) = (bv_signed rs < 0%Z) ∧ abs_size mpz3 rem = Z.abs (bv_signed rs) ∧ abs_value_of mpz3 rem = value rp1 (Z.abs (bv_signed rs)) -> (zones mpz3 rem = zone1 rp1 ∧ readers mpz3 rem = - 1%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ abs_value_of mpz3 rem = value rp1 (abs_size mpz3 rem)) ∧ (∀(mpz4 : mpz_memo), abs_value_of mpz4 = abs_value_of mpz3 ∧ alloc mpz4 = alloc mpz3 ∧ abs_size mpz4 = abs_size mpz3 ∧ sgn mpz4 = sgn mpz3 ∧ zones mpz4 = zones mpz3 -> readers mpz4 rem = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = rem -> readers mpz4 y = readers mpz3 y) -> int'32_in_bounds (bv_signed nn - 1%Z) ∧ (∀(o5 : bv 32%N), bv_signed o5 = bv_signed nn - 1%Z -> (min qp2 ≤ offset qp2 + bv_signed o5 ∧ offset qp2 + bv_signed o5 < C.max qp2) ∧ (let qh : bv 64%N := pelts qp2 (offset qp2 + bv_signed o5) in ∀(o6 : bool), (bv_unsigned qh = bv_unsigned (0%bv : bv 64%N) -> o6 = true) ∧ (o6 = true -> qh = (0%bv : bv 64%N)) -> (∀(o7 : bv 32%N), (if decide (o6 = true) then o7 = (1%bv : bv 32%N) else o7 = (0%bv : bv 32%N)) -> int'32_in_bounds (bv_signed nn - bv_signed o7) ∧ (∀(o8 : bv 32%N), bv_signed o8 = bv_signed nn - bv_signed o7 -> (¬ 0%Z ≤ bv_signed ns -> int'32_in_bounds (- bv_signed o8)) ∧ (∀(qs : bv 32%N), (if decide (0%Z ≤ bv_signed ns) then qs = o8 else bv_signed qs = - bv_signed o8) -> (zones mpz4 quot = zone1 qp2 ∧ readers mpz4 quot = - 1%Z ∧ offset qp2 = 0%Z ∧ min qp2 = 0%Z ∧ C.max qp2 = plength qp2 ∧ Z.abs (bv_signed qs) ≤ plength qp2 ∧ plength qp2 = alloc mpz4 quot ∧ (¬ bv_signed qs = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed qs) - 1%Z) ≤ value qp2 (Z.abs (bv_signed qs)))) ∧ (∀(mpz5 : mpz_memo), alloc mpz5 = alloc mpz4 ∧ readers mpz5 = readers mpz4 ∧ zones mpz5 = zones mpz4 -> (∀(y : mpz_ptr), ¬ y = quot -> mpz_unchanged y mpz5 mpz4) ∧ (sgn mpz5 quot = 1%Z) = (0%Z ≤ bv_signed qs) ∧ (sgn mpz5 quot = - 1%Z) = (bv_signed qs < 0%Z) ∧ abs_size mpz5 quot = Z.abs (bv_signed qs) ∧ abs_value_of mpz5 quot = value qp2 (Z.abs (bv_signed qs)) -> (zones mpz5 quot = zone1 qp2 ∧ readers mpz5 quot = - 1%Z ∧ min qp2 = 0%Z ∧ C.max qp2 = plength qp2 ∧ abs_value_of mpz5 quot = value qp2 (abs_size mpz5 quot)) ∧ (∀(mpz6 : mpz_memo), abs_value_of mpz6 = abs_value_of mpz5 ∧ alloc mpz6 = alloc mpz5 ∧ abs_size mpz6 = abs_size mpz5 ∧ sgn mpz6 = sgn mpz5 ∧ zones mpz6 = zones mpz5 -> readers mpz6 quot = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = quot -> readers mpz6 y = readers mpz5 y) -> mpz_unchanged rem mpz6 mpz4 ∧ (readers mpz6 rem = readers mpz4 rem ∧ (- 2%Z < readers mpz6 rem -> abs_value_of mpz6 rem = abs_value_of mpz4 rem ∧ alloc mpz6 rem = alloc mpz4 rem ∧ abs_size mpz6 rem = abs_size mpz4 rem ∧ sgn mpz6 rem = sgn mpz4 rem ∧ readers mpz6 rem = readers mpz4 rem ∧ zones mpz6 rem = zones mpz4 rem) -> value_of quot mpz6 * bv_unsigned divisor + value_of rem mpz6 = value_of dividend mpz ∧ bv_unsigned o3 = abs_value_of mpz6 rem ∧ (0%Z ≤ abs_value_of mpz6 rem ∧ abs_value_of mpz6 rem < bv_unsigned divisor) ∧ (∀(x : mpz_ptr), ¬ x = quot -> ¬ x = rem -> mpz_unchanged x mpz6 mpz) ∧ readers mpz6 dividend = 0%Z ∧ readers mpz6 quot = 0%Z ∧ readers mpz6 rem = 0%Z)))))))))))))))))))) else 0%Z ≤ readers mpz1 dividend ∧ (∀(mpz2 : mpz_memo), abs_value_of mpz2 = abs_value_of mpz1 ∧ alloc mpz2 = alloc mpz1 ∧ abs_size mpz2 = abs_size mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ zones mpz2 = zones mpz1 -> (∀(np : C.ptr (bv 64%N)), readers mpz2 dividend = readers mpz1 dividend + 1%Z ∧ (∀(y : mpz_ptr), ¬ dividend = y -> readers mpz2 y = readers mpz1 y) ∧ value np (abs_size mpz2 dividend) = abs_value_of mpz2 dividend ∧ plength np = alloc mpz2 dividend ∧ offset np = 0%Z ∧ min np = 0%Z ∧ C.max np = plength np ∧ zone1 np = zones mpz2 dividend -> (valid np (bv_signed nn) ∧ valid qp (bv_signed nn) ∧ writable qp = true ∧ 0%Z < bv_signed nn ∧ 0%Z < bv_unsigned divisor) ∧ (∀(qp1 : C.ptr (bv 64%N)), length (data qp1) = length (data qp) ∧ offset qp1 = offset qp ∧ min qp1 = min qp ∧ C.max qp1 = C.max qp ∧ writable qp1 = writable qp ∧ zone1 qp1 = zone1 qp -> (∀(o2 : bv 64%N), value np (bv_signed nn) = value qp1 (bv_signed nn) * bv_unsigned divisor + bv_unsigned o2 ∧ bv_unsigned o2 < bv_unsigned divisor -> (zones mpz2 dividend = zone1 np ∧ 1%Z ≤ readers mpz2 dividend ∧ min np = 0%Z ∧ C.max np = plength np) ∧ (∀(mpz3 : mpz_memo), abs_value_of mpz3 = abs_value_of mpz2 ∧ alloc mpz3 = alloc mpz2 ∧ abs_size mpz3 = abs_size mpz2 ∧ sgn mpz3 = sgn mpz2 ∧ zones mpz3 = zones mpz2 -> readers mpz3 dividend = readers mpz2 dividend - 1%Z ∧ (∀(y : mpz_ptr), ¬ y = dividend -> readers mpz3 y = readers mpz2 y) -> mpz_eq rem dividend = (rem = dividend) -> (¬ mpz_eq rem dividend -> mpz_unchanged rem mpz3 mpz) ∧ ((¬ mpz_eq rem dividend -> readers mpz3 rem = readers mpz rem ∧ (- 2%Z < readers mpz3 rem -> abs_value_of mpz3 rem = abs_value_of mpz rem ∧ alloc mpz3 rem = alloc mpz rem ∧ abs_size mpz3 rem = abs_size mpz rem ∧ sgn mpz3 rem = sgn mpz rem ∧ readers mpz3 rem = readers mpz rem ∧ zones mpz3 rem = zones mpz rem)) -> (∀(o3 : bool), (bv_unsigned o2 = bv_unsigned (0%bv : bv 64%N) -> o3 = true) ∧ (o3 = true -> o2 = (0%bv : bv 64%N)) -> (if decide (o3 = true) then (- 1%Z ≤ readers mpz3 rem ∧ readers mpz3 rem ≤ 0%Z) ∧ (∀(mpz4 : mpz_memo), alloc mpz4 = alloc mpz3 ∧ sgn mpz4 = sgn mpz3 ∧ readers mpz4 = readers mpz3 ∧ zones mpz4 = zones mpz3 -> (∀(y : mpz_ptr), ¬ y = rem -> mpz_unchanged y mpz4 mpz3) ∧ abs_size mpz4 rem = 0%Z ∧ abs_value_of mpz4 rem = 0%Z -> int'32_in_bounds (bv_signed nn - 1%Z) ∧ (∀(o4 : bv 32%N), bv_signed o4 = bv_signed nn - 1%Z -> (min qp1 ≤ offset qp1 + bv_signed o4 ∧ offset qp1 + bv_signed o4 < C.max qp1) ∧ (let qh : bv 64%N := pelts qp1 (offset qp1 + bv_signed o4) in ∀(o5 : bool), (bv_unsigned qh = bv_unsigned (0%bv : bv 64%N) -> o5 = true) ∧ (o5 = true -> qh = (0%bv : bv 64%N)) -> (∀(o6 : bv 32%N), (if decide (o5 = true) then o6 = (1%bv : bv 32%N) else o6 = (0%bv : bv 32%N)) -> int'32_in_bounds (bv_signed nn - bv_signed o6) ∧ (∀(o7 : bv 32%N), bv_signed o7 = bv_signed nn - bv_signed o6 -> (¬ 0%Z ≤ bv_signed ns -> int'32_in_bounds (- bv_signed o7)) ∧ (∀(qs : bv 32%N), (if decide (0%Z ≤ bv_signed ns) then qs = o7 else bv_signed qs = - bv_signed o7) -> (zones mpz4 quot = zone1 qp1 ∧ readers mpz4 quot = - 1%Z ∧ offset qp1 = 0%Z ∧ min qp1 = 0%Z ∧ C.max qp1 = plength qp1 ∧ Z.abs (bv_signed qs) ≤ plength qp1 ∧ plength qp1 = alloc mpz4 quot ∧ (¬ bv_signed qs = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed qs) - 1%Z) ≤ value qp1 (Z.abs (bv_signed qs)))) ∧ (∀(mpz5 : mpz_memo), alloc mpz5 = alloc mpz4 ∧ readers mpz5 = readers mpz4 ∧ zones mpz5 = zones mpz4 -> (∀(y : mpz_ptr), ¬ y = quot -> mpz_unchanged y mpz5 mpz4) ∧ (sgn mpz5 quot = 1%Z) = (0%Z ≤ bv_signed qs) ∧ (sgn mpz5 quot = - 1%Z) = (bv_signed qs < 0%Z) ∧ abs_size mpz5 quot = Z.abs (bv_signed qs) ∧ abs_value_of mpz5 quot = value qp1 (Z.abs (bv_signed qs)) -> (zones mpz5 quot = zone1 qp1 ∧ readers mpz5 quot = - 1%Z ∧ min qp1 = 0%Z ∧ C.max qp1 = plength qp1 ∧ abs_value_of mpz5 quot = value qp1 (abs_size mpz5 quot)) ∧ (∀(mpz6 : mpz_memo), abs_value_of mpz6 = abs_value_of mpz5 ∧ alloc mpz6 = alloc mpz5 ∧ abs_size mpz6 = abs_size mpz5 ∧ sgn mpz6 = sgn mpz5 ∧ zones mpz6 = zones mpz5 -> readers mpz6 quot = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = quot -> readers mpz6 y = readers mpz5 y) -> mpz_unchanged rem mpz6 mpz4 ∧ (readers mpz6 rem = readers mpz4 rem ∧ (- 2%Z < readers mpz6 rem -> abs_value_of mpz6 rem = abs_value_of mpz4 rem ∧ alloc mpz6 rem = alloc mpz4 rem ∧ abs_size mpz6 rem = abs_size mpz4 rem ∧ sgn mpz6 rem = sgn mpz4 rem ∧ readers mpz6 rem = readers mpz4 rem ∧ zones mpz6 rem = zones mpz4 rem) -> value_of quot mpz6 * bv_unsigned divisor + value_of rem mpz6 = value_of dividend mpz ∧ bv_unsigned o2 = abs_value_of mpz6 rem ∧ (0%Z ≤ abs_value_of mpz6 rem ∧ abs_value_of mpz6 rem < bv_unsigned divisor) ∧ (∀(x : mpz_ptr), ¬ x = quot -> ¬ x = rem -> mpz_unchanged x mpz6 mpz) ∧ readers mpz6 dividend = 0%Z ∧ readers mpz6 quot = 0%Z ∧ readers mpz6 rem = 0%Z))))))))) else ∀(rs : bv 32%N), (if decide (0%Z ≤ bv_signed ns) then rs = (1%bv : bv 32%N) else rs = ((-1)%bv : bv 32%N)) -> readers mpz3 rem = 0%Z ∧ (∀(mpz4 : mpz_memo), abs_value_of mpz4 = abs_value_of mpz3 ∧ alloc mpz4 = alloc mpz3 ∧ abs_size mpz4 = abs_size mpz3 ∧ sgn mpz4 = sgn mpz3 ∧ zones mpz4 = zones mpz3 -> (∀(rp : C.ptr (bv 64%N)), readers mpz4 rem = - 1%Z ∧ (∀(y : mpz_ptr), ¬ rem = y -> readers mpz4 y = readers mpz3 y) ∧ value rp (abs_size mpz4 rem) = abs_value_of mpz4 rem ∧ plength rp = alloc mpz4 rem ∧ offset rp = 0%Z ∧ min rp = 0%Z ∧ C.max rp = plength rp ∧ writable rp = true ∧ zone1 rp = zones mpz4 rem -> ((min rp ≤ offset rp ∧ offset rp < C.max rp) ∧ writable rp = true) ∧ (∀(rp1 : C.ptr (bv 64%N)), length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> pelts rp1 = fun_updt (pelts rp) (offset rp1) o2 -> (zones mpz4 rem = zone1 rp1 ∧ readers mpz4 rem = - 1%Z ∧ offset rp1 = 0%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ Z.abs (bv_signed rs) ≤ plength rp1 ∧ plength rp1 = alloc mpz4 rem ∧ (¬ bv_signed rs = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed rs) - 1%Z) ≤ value rp1 (Z.abs (bv_signed rs)))) ∧ (∀(mpz5 : mpz_memo), alloc mpz5 = alloc mpz4 ∧ readers mpz5 = readers mpz4 ∧ zones mpz5 = zones mpz4 -> (∀(y : mpz_ptr), ¬ y = rem -> mpz_unchanged y mpz5 mpz4) ∧ (sgn mpz5 rem = 1%Z) = (0%Z ≤ bv_signed rs) ∧ (sgn mpz5 rem = - 1%Z) = (bv_signed rs < 0%Z) ∧ abs_size mpz5 rem = Z.abs (bv_signed rs) ∧ abs_value_of mpz5 rem = value rp1 (Z.abs (bv_signed rs)) -> (zones mpz5 rem = zone1 rp1 ∧ readers mpz5 rem = - 1%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ abs_value_of mpz5 rem = value rp1 (abs_size mpz5 rem)) ∧ (∀(mpz6 : mpz_memo), abs_value_of mpz6 = abs_value_of mpz5 ∧ alloc mpz6 = alloc mpz5 ∧ abs_size mpz6 = abs_size mpz5 ∧ sgn mpz6 = sgn mpz5 ∧ zones mpz6 = zones mpz5 -> readers mpz6 rem = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = rem -> readers mpz6 y = readers mpz5 y) -> int'32_in_bounds (bv_signed nn - 1%Z) ∧ (∀(o4 : bv 32%N), bv_signed o4 = bv_signed nn - 1%Z -> (min qp1 ≤ offset qp1 + bv_signed o4 ∧ offset qp1 + bv_signed o4 < C.max qp1) ∧ (let qh : bv 64%N := pelts qp1 (offset qp1 + bv_signed o4) in ∀(o5 : bool), (bv_unsigned qh = bv_unsigned (0%bv : bv 64%N) -> o5 = true) ∧ (o5 = true -> qh = (0%bv : bv 64%N)) -> (∀(o6 : bv 32%N), (if decide (o5 = true) then o6 = (1%bv : bv 32%N) else o6 = (0%bv : bv 32%N)) -> int'32_in_bounds (bv_signed nn - bv_signed o6) ∧ (∀(o7 : bv 32%N), bv_signed o7 = bv_signed nn - bv_signed o6 -> (¬ 0%Z ≤ bv_signed ns -> int'32_in_bounds (- bv_signed o7)) ∧ (∀(qs : bv 32%N), (if decide (0%Z ≤ bv_signed ns) then qs = o7 else bv_signed qs = - bv_signed o7) -> (zones mpz6 quot = zone1 qp1 ∧ readers mpz6 quot = - 1%Z ∧ offset qp1 = 0%Z ∧ min qp1 = 0%Z ∧ C.max qp1 = plength qp1 ∧ Z.abs (bv_signed qs) ≤ plength qp1 ∧ plength qp1 = alloc mpz6 quot ∧ (¬ bv_signed qs = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed qs) - 1%Z) ≤ value qp1 (Z.abs (bv_signed qs)))) ∧ (∀(mpz7 : mpz_memo), alloc mpz7 = alloc mpz6 ∧ readers mpz7 = readers mpz6 ∧ zones mpz7 = zones mpz6 -> (∀(y : mpz_ptr), ¬ y = quot -> mpz_unchanged y mpz7 mpz6) ∧ (sgn mpz7 quot = 1%Z) = (0%Z ≤ bv_signed qs) ∧ (sgn mpz7 quot = - 1%Z) = (bv_signed qs < 0%Z) ∧ abs_size mpz7 quot = Z.abs (bv_signed qs) ∧ abs_value_of mpz7 quot = value qp1 (Z.abs (bv_signed qs)) -> (zones mpz7 quot = zone1 qp1 ∧ readers mpz7 quot = - 1%Z ∧ min qp1 = 0%Z ∧ C.max qp1 = plength qp1 ∧ abs_value_of mpz7 quot = value qp1 (abs_size mpz7 quot)) ∧ (∀(mpz8 : mpz_memo), abs_value_of mpz8 = abs_value_of mpz7 ∧ alloc mpz8 = alloc mpz7 ∧ abs_size mpz8 = abs_size mpz7 ∧ sgn mpz8 = sgn mpz7 ∧ zones mpz8 = zones mpz7 -> readers mpz8 quot = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = quot -> readers mpz8 y = readers mpz7 y) -> mpz_unchanged rem mpz8 mpz6 ∧ (readers mpz8 rem = readers mpz6 rem ∧ (- 2%Z < readers mpz8 rem -> abs_value_of mpz8 rem = abs_value_of mpz6 rem ∧ alloc mpz8 rem = alloc mpz6 rem ∧ abs_size mpz8 rem = abs_size mpz6 rem ∧ sgn mpz8 rem = sgn mpz6 rem ∧ readers mpz8 rem = readers mpz6 rem ∧ zones mpz8 rem = zones mpz6 rem) -> value_of quot mpz8 * bv_unsigned divisor + value_of rem mpz8 = value_of dividend mpz ∧ bv_unsigned o2 = abs_value_of mpz8 rem ∧ (0%Z ≤ abs_value_of mpz8 rem ∧ abs_value_of mpz8 rem < bv_unsigned divisor) ∧ (∀(x : mpz_ptr), ¬ x = quot -> ¬ x = rem -> mpz_unchanged x mpz8 mpz) ∧ readers mpz8 dividend = 0%Z ∧ readers mpz8 quot = 0%Z ∧ readers mpz8 rem = 0%Z)))))))))))))))))))))))))))))).
Proof.
Admitted.
