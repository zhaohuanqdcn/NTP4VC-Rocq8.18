import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Sum
open Classical
open Lean4Why3
namespace hillel_challenge_Fulcrum_fulcrumqtvc
noncomputable def diff (a : List ℤ) (i : ℤ) := abs (List.sum (List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a)) - List.sum (List.drop (Int.toNat i) (List.take (List.length a - Int.toNat i) a)))
theorem fulcrum'vc (a : List ℤ) : let n : ℤ := Int.ofNat (List.length a); let o1 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → (0 : ℤ) = List.sum (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a)) ∧ (∀(right1 : ℤ), (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ right1 = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a)) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ right1 + a[Int.toNat i]! = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ∧ (right1 = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat (o1 + (1 : ℤ)) - (0 : ℕ)) a)) → (let o2 : ℤ := abs right1; let o3 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → ((0 : ℤ) = List.sum (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a)) ∧ right1 = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat n - (0 : ℕ)) a)) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ o2 = diff a (0 : ℤ) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ (0 : ℤ) → o2 ≤ diff a j)) ∧ (∀(bestd : ℤ) (besti : ℤ) (left1 : ℤ) (right2 : ℤ), (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o3) ∧ left1 = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a)) ∧ right2 = List.sum (List.drop (Int.toNat i) (List.take (Int.toNat n - Int.toNat i) a)) ∧ ((0 : ℤ) ≤ besti ∧ besti ≤ i) ∧ bestd = diff a besti ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ i → bestd ≤ diff a j) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let d : ℤ := abs (left1 + a[Int.toNat i]! - (right2 - a[Int.toNat i]!)); if d < bestd then left1 + a[Int.toNat i]! = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a)) ∧ right2 - a[Int.toNat i]! = List.sum (List.drop (Int.toNat (i + (1 : ℤ))) (List.take (Int.toNat n - Int.toNat (i + (1 : ℤ))) a)) ∧ ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ d = diff a (i + (1 : ℤ)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ i + (1 : ℤ) → d ≤ diff a j) else left1 + a[Int.toNat i]! = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a)) ∧ right2 - a[Int.toNat i]! = List.sum (List.drop (Int.toNat (i + (1 : ℤ))) (List.take (Int.toNat n - Int.toNat (i + (1 : ℤ))) a)) ∧ ((0 : ℤ) ≤ besti ∧ besti ≤ i + (1 : ℤ)) ∧ bestd = diff a besti ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ i + (1 : ℤ) → bestd ≤ diff a j))) ∧ (left1 = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat (o3 + (1 : ℤ)) - (0 : ℕ)) a)) ∧ right2 = List.sum (List.drop (Int.toNat (o3 + (1 : ℤ))) (List.take (Int.toNat n - Int.toNat (o3 + (1 : ℤ))) a)) ∧ ((0 : ℤ) ≤ besti ∧ besti ≤ o3 + (1 : ℤ)) ∧ bestd = diff a besti ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ o3 + (1 : ℤ) → bestd ≤ diff a j) → ((0 : ℤ) ≤ besti ∧ besti ≤ Int.ofNat (List.length a)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ Int.ofNat (List.length a) → diff a besti ≤ diff a i)))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length a)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ Int.ofNat (List.length a) → diff a (0 : ℤ) ≤ diff a i)))))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (let o2 : ℤ := abs (0 : ℤ); let o3 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → ((0 : ℤ) = List.sum (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a)) ∧ (0 : ℤ) = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat n - (0 : ℕ)) a)) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ o2 = diff a (0 : ℤ) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ (0 : ℤ) → o2 ≤ diff a j)) ∧ (∀(bestd : ℤ) (besti : ℤ) (left1 : ℤ) (right1 : ℤ), (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o3) ∧ left1 = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a)) ∧ right1 = List.sum (List.drop (Int.toNat i) (List.take (Int.toNat n - Int.toNat i) a)) ∧ ((0 : ℤ) ≤ besti ∧ besti ≤ i) ∧ bestd = diff a besti ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ i → bestd ≤ diff a j) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let d : ℤ := abs (left1 + a[Int.toNat i]! - (right1 - a[Int.toNat i]!)); if d < bestd then left1 + a[Int.toNat i]! = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a)) ∧ right1 - a[Int.toNat i]! = List.sum (List.drop (Int.toNat (i + (1 : ℤ))) (List.take (Int.toNat n - Int.toNat (i + (1 : ℤ))) a)) ∧ ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ d = diff a (i + (1 : ℤ)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ i + (1 : ℤ) → d ≤ diff a j) else left1 + a[Int.toNat i]! = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a)) ∧ right1 - a[Int.toNat i]! = List.sum (List.drop (Int.toNat (i + (1 : ℤ))) (List.take (Int.toNat n - Int.toNat (i + (1 : ℤ))) a)) ∧ ((0 : ℤ) ≤ besti ∧ besti ≤ i + (1 : ℤ)) ∧ bestd = diff a besti ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ i + (1 : ℤ) → bestd ≤ diff a j))) ∧ (left1 = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat (o3 + (1 : ℤ)) - (0 : ℕ)) a)) ∧ right1 = List.sum (List.drop (Int.toNat (o3 + (1 : ℤ))) (List.take (Int.toNat n - Int.toNat (o3 + (1 : ℤ))) a)) ∧ ((0 : ℤ) ≤ besti ∧ besti ≤ o3 + (1 : ℤ)) ∧ bestd = diff a besti ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ o3 + (1 : ℤ) → bestd ≤ diff a j) → ((0 : ℤ) ≤ besti ∧ besti ≤ Int.ofNat (List.length a)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ Int.ofNat (List.length a) → diff a besti ≤ diff a i)))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length a)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ Int.ofNat (List.length a) → diff a (0 : ℤ) ≤ diff a i))))
  := sorry
end hillel_challenge_Fulcrum_fulcrumqtvc
