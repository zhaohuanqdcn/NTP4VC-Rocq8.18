theory real_Truncate
  imports "NTP4Verif.NTP4Verif"
begin
consts truncate :: "real \<Rightarrow> int"
axiomatization where Truncate_int:   "truncate (real_of_int i) = i"
  for i :: "int"
axiomatization where Truncate_down_pos'0:   "real_of_int (truncate x) \<le> x"
 if "(0 :: Real.real) \<le> x"
  for x :: "real"
axiomatization where Truncate_down_pos'1:   "x < real_of_int (truncate x + (1 :: int))"
 if "(0 :: Real.real) \<le> x"
  for x :: "real"
axiomatization where Truncate_up_neg'0:   "real_of_int (truncate x - (1 :: int)) < x"
 if "x \<le> (0 :: Real.real)"
  for x :: "real"
axiomatization where Truncate_up_neg'1:   "x \<le> real_of_int (truncate x)"
 if "x \<le> (0 :: Real.real)"
  for x :: "real"
axiomatization where Real_of_truncate'0:   "x - (1 :: Real.real) \<le> real_of_int (truncate x)"
  for x :: "real"
axiomatization where Real_of_truncate'1:   "real_of_int (truncate x) \<le> x + (1 :: Real.real)"
  for x :: "real"
axiomatization where Truncate_monotonic:   "truncate x \<le> truncate y"
 if "x \<le> y"
  for x :: "real"
  and y :: "real"
axiomatization where Truncate_monotonic_int1:   "truncate x \<le> i"
 if "x \<le> real_of_int i"
  for x :: "real"
  and i :: "int"
axiomatization where Truncate_monotonic_int2:   "i \<le> truncate x"
 if "real_of_int i \<le> x"
  for i :: "int"
  and x :: "real"
consts floor :: "real \<Rightarrow> int"
axiomatization where Floor_int:   "floor (real_of_int i) = i"
  for i :: "int"
consts ceil :: "real \<Rightarrow> int"
axiomatization where Ceil_int:   "ceil (real_of_int i) = i"
  for i :: "int"
axiomatization where Floor_down'0:   "real_of_int (floor x) \<le> x"
  for x :: "real"
axiomatization where Floor_down'1:   "x < real_of_int (floor x + (1 :: int))"
  for x :: "real"
axiomatization where Ceil_up'0:   "real_of_int (ceil x - (1 :: int)) < x"
  for x :: "real"
axiomatization where Ceil_up'1:   "x \<le> real_of_int (ceil x)"
  for x :: "real"
axiomatization where Floor_monotonic:   "floor x \<le> floor y"
 if "x \<le> y"
  for x :: "real"
  and y :: "real"
axiomatization where Ceil_monotonic:   "ceil x \<le> ceil y"
 if "x \<le> y"
  for x :: "real"
  and y :: "real"
end
