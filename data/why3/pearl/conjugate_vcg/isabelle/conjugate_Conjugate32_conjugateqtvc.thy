theory conjugate_Conjugate32_conjugateqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref"
begin
definition is_partition :: "32 word array32 \<Rightarrow> _"
  where "is_partition a \<longleftrightarrow> (0 :: int) < sint (array32_length a) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> j \<and> j < sint (array32_length a) \<longrightarrow> sint (array32_elts a j) \<le> sint (array32_elts a i)) \<and> sint (array32_elts a (sint (array32_length a) - (1 :: int))) = (0 :: int)" for a
definition numofgt :: "32 word array32 \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "numofgt a n v \<longleftrightarrow> ((0 :: int) \<le> n \<and> n < sint (array32_length a)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < n \<longrightarrow> v < sint (array32_elts a j)) \<and> sint (array32_elts a n) \<le> v" for a n v
definition is_conjugate :: "32 word array32 \<Rightarrow> 32 word array32 \<Rightarrow> _"
  where "is_conjugate a b \<longleftrightarrow> sint (array32_elts a (0 :: int)) < sint (array32_length b) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < sint (array32_length b) \<longrightarrow> numofgt a (sint (array32_elts b j)) j)" for a b
theorem conjugate'vc:
  fixes a :: "32 word array32"
  fixes b :: "32 word array32"
  assumes fact0: "is_partition a"
  assumes fact1: "sint (array32_length b) = sint (array32_elts a (0 :: int)) + (1 :: int)"
  assumes fact2: "\<forall>(i :: int). (0 :: int) \<le> i \<and> i < sint (array32_length b) \<longrightarrow> sint (array32_elts b i) = (0 :: int)"
  shows "(0 :: int) \<le> (0 :: int)"
  and "(0 :: int) < sint (array32_length a)"
  and "\<forall>(j :: int). sint (array32_elts a (0 :: int)) \<le> j \<and> j < sint (array32_length b) \<longrightarrow> numofgt a (sint (array32_elts b j)) j"
  and "\<forall>(partc :: 32 word) (b1 :: 32 word array32). array32_length b1 = array32_length b \<longrightarrow> ((0 :: int) \<le> sint partc \<and> sint partc < sint (array32_length a)) \<and> (\<forall>(j :: int). sint (array32_elts a (sint partc)) \<le> j \<and> j < sint (array32_length b1) \<longrightarrow> numofgt a (sint (array32_elts b1 j)) j) \<longrightarrow> ((0 :: int) \<le> sint partc \<and> sint partc < sint (array32_length a)) \<and> (let o1 :: 32 word = array32_elts a (sint partc) in (sint o1 = (0 :: int) \<longrightarrow> o1 = (0 :: 32 word)) \<longrightarrow> (if \<not>o1 = (0 :: 32 word) then ((0 :: int) \<le> sint partc \<and> sint partc < sint (array32_length a)) \<and> (let edge :: 32 word = array32_elts a (sint partc) in int'32_in_bounds (sint partc + (1 :: int)) \<and> (\<forall>(o2 :: 32 word). sint o2 = sint partc + (1 :: int) \<longrightarrow> ((sint partc \<le> sint o2 \<and> sint o2 < sint (array32_length a)) \<and> (\<forall>(j :: int). sint partc \<le> j \<and> j < sint o2 \<longrightarrow> array32_elts a j = edge)) \<and> (\<forall>(partc1 :: 32 word). (sint partc \<le> sint partc1 \<and> sint partc1 < sint (array32_length a)) \<and> (\<forall>(j :: int). sint partc \<le> j \<and> j < sint partc1 \<longrightarrow> array32_elts a j = edge) \<longrightarrow> ((0 :: int) \<le> sint partc1 \<and> sint partc1 < sint (array32_length a)) \<and> (let o3 :: 32 word = array32_elts a (sint partc1) in (sint o3 = sint edge \<longrightarrow> o3 = edge) \<longrightarrow> (if o3 = edge then int'32_in_bounds (sint partc1 + (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint partc1 + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint (array32_length a) - sint partc1 \<and> sint (array32_length a) - sint o4 < sint (array32_length a) - sint partc1) \<and> (sint partc \<le> sint o4 \<and> sint o4 < sint (array32_length a)) \<and> (\<forall>(j :: int). sint partc \<le> j \<and> j < sint o4 \<longrightarrow> array32_elts a j = edge)) else int'32_in_bounds (sint edge - (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint edge - (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint partc1 \<and> sint partc1 < sint (array32_length a)) \<and> (let o5 :: 32 word = array32_elts a (sint partc1) in (sint o5 \<le> sint o4 + (1 :: int) \<longrightarrow> (\<forall>(j :: int). sint (array32_elts a (sint partc1)) \<le> j \<and> j < sint o5 \<longrightarrow> array32_elts b1 j = partc1) \<and> (\<forall>(b2 :: 32 word array32). array32_length b2 = array32_length b1 \<longrightarrow> (\<forall>(i :: 32 word). let i1 :: int = sint i in (sint o5 \<le> i1 \<and> i1 \<le> sint o4) \<and> (\<forall>(j :: int). sint edge \<le> j \<and> j < sint (array32_length b2) \<longrightarrow> array32_elts b2 j = array32_elts b1 j) \<and> (\<forall>(j :: int). sint (array32_elts a (sint partc1)) \<le> j \<and> j < i1 \<longrightarrow> array32_elts b2 j = partc1) \<longrightarrow> ((0 :: int) \<le> sint i \<and> sint i < sint (array32_length b2)) \<and> (\<forall>(b3 :: 32 word array32). array32_length b3 = array32_length b2 \<longrightarrow> array32_elts b3 = (array32_elts b2)(sint i := partc1) \<longrightarrow> (\<forall>(j :: int). sint edge \<le> j \<and> j < sint (array32_length b3) \<longrightarrow> array32_elts b3 j = array32_elts b1 j) \<and> (\<forall>(j :: int). sint (array32_elts a (sint partc1)) \<le> j \<and> j < i1 + (1 :: int) \<longrightarrow> array32_elts b3 j = partc1))) \<and> ((\<forall>(j :: int). sint edge \<le> j \<and> j < sint (array32_length b2) \<longrightarrow> array32_elts b2 j = array32_elts b1 j) \<and> (\<forall>(j :: int). sint (array32_elts a (sint partc1)) \<le> j \<and> j < sint o4 + (1 :: int) \<longrightarrow> array32_elts b2 j = partc1) \<longrightarrow> ((0 :: int) \<le> sint (array32_length a) - sint partc \<and> sint (array32_length a) - sint partc1 < sint (array32_length a) - sint partc) \<and> ((0 :: int) \<le> sint partc1 \<and> sint partc1 < sint (array32_length a)) \<and> (\<forall>(j :: int). sint (array32_elts a (sint partc1)) \<le> j \<and> j < sint (array32_length b2) \<longrightarrow> numofgt a (sint (array32_elts b2 j)) j)))) \<and> (sint o4 + (1 :: int) < sint o5 \<longrightarrow> ((0 :: int) \<le> sint (array32_length a) - sint partc \<and> sint (array32_length a) - sint partc1 < sint (array32_length a) - sint partc) \<and> ((0 :: int) \<le> sint partc1 \<and> sint partc1 < sint (array32_length a)) \<and> (\<forall>(j :: int). sint (array32_elts a (sint partc1)) \<le> j \<and> j < sint (array32_length b1) \<longrightarrow> numofgt a (sint (array32_elts b1 j)) j))))))))) else is_conjugate a b1))"
  sorry
end
