theory mpz_div_Zdiv_wmpz_tdiv_qr_uiqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/div_Div" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mpz_Z" "../../lib/isabelle/mpz_Zutil"
begin
theorem wmpz_tdiv_qr_ui'vc:
  fixes mpz :: "mpz_memo"
  fixes dividend :: "mpz_ptr"
  fixes quot :: "mpz_ptr"
  fixes rem :: "mpz_ptr"
  fixes divisor :: "64 word"
  assumes fact0: "(0 :: int) < alloc mpz dividend"
  assumes fact1: "(0 :: int) < alloc mpz quot"
  assumes fact2: "(0 :: int) < alloc mpz rem"
  assumes fact3: "readers mpz dividend = (0 :: int)"
  assumes fact4: "readers mpz quot = (0 :: int)"
  assumes fact5: "readers mpz rem = (0 :: int)"
  assumes fact6: "\<not>quot = rem"
  assumes fact7: "(0 :: int) < uint divisor"
  shows "-(2 :: int) < readers mpz dividend"
  and "\<forall>(ns :: 32 word). sint ns = sgn mpz dividend * abs_size mpz dividend \<longrightarrow> (\<forall>(o1 :: bool). (sint ns = sint (0 :: 32 word) \<longrightarrow> o1 = True) \<and> (o1 = True \<longrightarrow> ns = (0 :: 32 word)) \<longrightarrow> (if o1 = True then (-(1 :: int) \<le> readers mpz quot \<and> readers mpz quot \<le> (0 :: int)) \<and> (\<forall>(mpz1 :: mpz_memo). alloc mpz1 = alloc mpz \<and> sgn mpz1 = sgn mpz \<and> readers mpz1 = readers mpz \<and> zones mpz1 = zones mpz \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = quot \<longrightarrow> mpz_unchanged y mpz1 mpz) \<and> abs_size mpz1 quot = (0 :: int) \<and> abs_value_of mpz1 quot = (0 :: int) \<longrightarrow> (-(1 :: int) \<le> readers mpz1 rem \<and> readers mpz1 rem \<le> (0 :: int)) \<and> (\<forall>(mpz2 :: mpz_memo). alloc mpz2 = alloc mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> readers mpz2 = readers mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = rem \<longrightarrow> mpz_unchanged y mpz2 mpz1) \<and> abs_size mpz2 rem = (0 :: int) \<and> abs_value_of mpz2 rem = (0 :: int) \<longrightarrow> value_of quot mpz2 * uint divisor + value_of rem mpz2 = value_of dividend mpz \<and> (0 :: int) = abs_value_of mpz2 rem \<and> ((0 :: int) \<le> abs_value_of mpz2 rem \<and> abs_value_of mpz2 rem < uint divisor) \<and> (\<forall>(x :: mpz_ptr). \<not>x = quot \<longrightarrow> \<not>x = rem \<longrightarrow> mpz_unchanged x mpz2 mpz) \<and> readers mpz2 dividend = (0 :: int) \<and> readers mpz2 quot = (0 :: int) \<and> readers mpz2 rem = (0 :: int))) else -(2147483648 :: int) < sint ns \<and> (\<forall>(nn :: 32 word). sint nn = abs (sint ns) \<longrightarrow> (readers mpz quot = (0 :: int) \<and> (1 :: int) \<le> alloc mpz quot) \<and> (\<forall>(mpz1 :: mpz_memo). sgn mpz1 = sgn mpz \<longrightarrow> (\<forall>(qp :: 64 word ptr). (\<forall>(y :: mpz_ptr). \<not>y = quot \<longrightarrow> mpz_unchanged y mpz1 mpz) \<and> readers mpz1 quot = -(1 :: int) \<and> abs_value_of mpz1 quot = value qp (abs_size mpz1 quot) \<and> zones mpz1 quot = zone1 qp \<and> offset qp = (0 :: int) \<and> plength qp = alloc mpz1 quot \<and> c_C.min qp = (0 :: int) \<and> c_C.max qp = plength qp \<and> writable qp = True \<and> abs_size mpz1 quot = abs_size mpz quot \<and> value qp (abs_size mpz quot) = abs_value_of mpz quot \<and> (if alloc mpz quot < sint nn then alloc mpz1 quot = sint nn else alloc mpz1 quot = alloc mpz quot) \<longrightarrow> (mpz_eq quot dividend \<longleftrightarrow> quot = dividend) \<longrightarrow> (\<not>mpz_eq quot dividend \<longrightarrow> mpz_unchanged dividend mpz1 mpz) \<and> ((\<not>mpz_eq quot dividend \<longrightarrow> readers mpz1 dividend = readers mpz dividend \<and> (-(2 :: int) < readers mpz1 dividend \<longrightarrow> abs_value_of mpz1 dividend = abs_value_of mpz dividend \<and> alloc mpz1 dividend = alloc mpz dividend \<and> abs_size mpz1 dividend = abs_size mpz dividend \<and> sgn mpz1 dividend = sgn mpz dividend \<and> readers mpz1 dividend = readers mpz dividend \<and> zones mpz1 dividend = zones mpz dividend)) \<longrightarrow> mpz_unchanged rem mpz1 mpz \<and> (readers mpz1 rem = readers mpz rem \<and> (-(2 :: int) < readers mpz1 rem \<longrightarrow> abs_value_of mpz1 rem = abs_value_of mpz rem \<and> alloc mpz1 rem = alloc mpz rem \<and> abs_size mpz1 rem = abs_size mpz rem \<and> sgn mpz1 rem = sgn mpz rem \<and> readers mpz1 rem = readers mpz rem \<and> zones mpz1 rem = zones mpz rem) \<longrightarrow> (mpz_eq quot dividend \<longleftrightarrow> quot = dividend) \<longrightarrow> (if mpz_eq quot dividend then (0 :: int) \<le> sint nn \<and> (\<forall>(o2 :: 32 word). uint o2 = sint nn \<longrightarrow> (0 :: int) \<le> uint o2 \<and> (\<forall>(np :: 64 word ptr). plength np = uint o2 \<and> offset np = (0 :: int) \<and> c_C.min np = (0 :: int) \<and> c_C.max np = uint o2 \<and> writable np = True \<longrightarrow> (valid qp (sint nn) \<and> valid np (sint nn) \<and> writable np = True) \<and> (\<forall>(np1 :: 64 word ptr) (qp1 :: 64 word ptr). offset np1 = offset np \<and> writable np1 = writable np \<and> zone1 np1 = zone1 np \<longrightarrow> offset qp1 = offset qp \<and> writable qp1 = writable qp \<and> zone1 qp1 = zone1 qp \<longrightarrow> map_eq_sub_shift (pelts np1) (pelts qp) (offset np1) (offset qp) (sint nn) \<and> (\<forall>(j :: int). j < offset np1 \<or> offset np1 + sint nn \<le> j \<longrightarrow> pelts np1 j = pelts np j) \<and> (\<forall>(j :: int). pelts qp1 j = pelts qp j) \<and> (c_C.min qp1 = c_C.min qp \<and> c_C.max qp1 = c_C.max qp \<and> plength qp1 = plength qp) \<and> c_C.min np1 = c_C.min np \<and> c_C.max np1 = c_C.max np \<and> plength np1 = plength np \<longrightarrow> (valid np1 (sint nn) \<and> valid qp1 (sint nn) \<and> writable qp1 = True \<and> (0 :: int) < sint nn \<and> (0 :: int) < uint divisor) \<and> (\<forall>(qp2 :: 64 word ptr). length (data qp2) = length (data qp1) \<and> offset qp2 = offset qp1 \<and> c_C.min qp2 = c_C.min qp1 \<and> c_C.max qp2 = c_C.max qp1 \<and> writable qp2 = writable qp1 \<and> zone1 qp2 = zone1 qp1 \<longrightarrow> (\<forall>(o3 :: 64 word). value np1 (sint nn) = value qp2 (sint nn) * uint divisor + uint o3 \<and> uint o3 < uint divisor \<longrightarrow> (\<forall>(o4 :: bool). (uint o3 = uint (0 :: 64 word) \<longrightarrow> o4 = True) \<and> (o4 = True \<longrightarrow> o3 = (0 :: 64 word)) \<longrightarrow> (if o4 = True then (-(1 :: int) \<le> readers mpz1 rem \<and> readers mpz1 rem \<le> (0 :: int)) \<and> (\<forall>(mpz2 :: mpz_memo). alloc mpz2 = alloc mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> readers mpz2 = readers mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = rem \<longrightarrow> mpz_unchanged y mpz2 mpz1) \<and> abs_size mpz2 rem = (0 :: int) \<and> abs_value_of mpz2 rem = (0 :: int) \<longrightarrow> int'32_in_bounds (sint nn - (1 :: int)) \<and> (\<forall>(o5 :: 32 word). sint o5 = sint nn - (1 :: int) \<longrightarrow> (c_C.min qp2 \<le> offset qp2 + sint o5 \<and> offset qp2 + sint o5 < c_C.max qp2) \<and> (let qh :: 64 word = pelts qp2 (offset qp2 + sint o5) in \<forall>(o6 :: bool). (uint qh = uint (0 :: 64 word) \<longrightarrow> o6 = True) \<and> (o6 = True \<longrightarrow> qh = (0 :: 64 word)) \<longrightarrow> (\<forall>(o7 :: 32 word). (if o6 = True then o7 = (1 :: 32 word) else o7 = (0 :: 32 word)) \<longrightarrow> int'32_in_bounds (sint nn - sint o7) \<and> (\<forall>(o8 :: 32 word). sint o8 = sint nn - sint o7 \<longrightarrow> (\<not>(0 :: int) \<le> sint ns \<longrightarrow> int'32_in_bounds (-sint o8)) \<and> (\<forall>(qs :: 32 word). (if (0 :: int) \<le> sint ns then qs = o8 else sint qs = -sint o8) \<longrightarrow> (zones mpz2 quot = zone1 qp2 \<and> readers mpz2 quot = -(1 :: int) \<and> offset qp2 = (0 :: int) \<and> c_C.min qp2 = (0 :: int) \<and> c_C.max qp2 = plength qp2 \<and> abs (sint qs) \<le> plength qp2 \<and> plength qp2 = alloc mpz2 quot \<and> (\<not>sint qs = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint qs) - (1 :: int)) \<le> value qp2 (abs (sint qs)))) \<and> (\<forall>(mpz3 :: mpz_memo). alloc mpz3 = alloc mpz2 \<and> readers mpz3 = readers mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = quot \<longrightarrow> mpz_unchanged y mpz3 mpz2) \<and> (sgn mpz3 quot = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint qs) \<and> (sgn mpz3 quot = -(1 :: int) \<longleftrightarrow> sint qs < (0 :: int)) \<and> abs_size mpz3 quot = abs (sint qs) \<and> abs_value_of mpz3 quot = value qp2 (abs (sint qs)) \<longrightarrow> (zones mpz3 quot = zone1 qp2 \<and> readers mpz3 quot = -(1 :: int) \<and> c_C.min qp2 = (0 :: int) \<and> c_C.max qp2 = plength qp2 \<and> abs_value_of mpz3 quot = value qp2 (abs_size mpz3 quot)) \<and> (\<forall>(mpz4 :: mpz_memo). abs_value_of mpz4 = abs_value_of mpz3 \<and> alloc mpz4 = alloc mpz3 \<and> abs_size mpz4 = abs_size mpz3 \<and> sgn mpz4 = sgn mpz3 \<and> zones mpz4 = zones mpz3 \<longrightarrow> readers mpz4 quot = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = quot \<longrightarrow> readers mpz4 y = readers mpz3 y) \<longrightarrow> mpz_unchanged rem mpz4 mpz2 \<and> (readers mpz4 rem = readers mpz2 rem \<and> (-(2 :: int) < readers mpz4 rem \<longrightarrow> abs_value_of mpz4 rem = abs_value_of mpz2 rem \<and> alloc mpz4 rem = alloc mpz2 rem \<and> abs_size mpz4 rem = abs_size mpz2 rem \<and> sgn mpz4 rem = sgn mpz2 rem \<and> readers mpz4 rem = readers mpz2 rem \<and> zones mpz4 rem = zones mpz2 rem) \<longrightarrow> value_of quot mpz4 * uint divisor + value_of rem mpz4 = value_of dividend mpz \<and> uint o3 = abs_value_of mpz4 rem \<and> ((0 :: int) \<le> abs_value_of mpz4 rem \<and> abs_value_of mpz4 rem < uint divisor) \<and> (\<forall>(x :: mpz_ptr). \<not>x = quot \<longrightarrow> \<not>x = rem \<longrightarrow> mpz_unchanged x mpz4 mpz) \<and> readers mpz4 dividend = (0 :: int) \<and> readers mpz4 quot = (0 :: int) \<and> readers mpz4 rem = (0 :: int)))))))))) else \<forall>(rs :: 32 word). (if (0 :: int) \<le> sint ns then rs = (1 :: 32 word) else rs = Groups.uminus_class.uminus (1 :: 32 word)) \<longrightarrow> readers mpz1 rem = (0 :: int) \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> (\<forall>(rp :: 64 word ptr). readers mpz2 rem = -(1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>rem = y \<longrightarrow> readers mpz2 y = readers mpz1 y) \<and> value rp (abs_size mpz2 rem) = abs_value_of mpz2 rem \<and> plength rp = alloc mpz2 rem \<and> offset rp = (0 :: int) \<and> c_C.min rp = (0 :: int) \<and> c_C.max rp = plength rp \<and> writable rp = True \<and> zone1 rp = zones mpz2 rem \<longrightarrow> ((c_C.min rp \<le> offset rp \<and> offset rp < c_C.max rp) \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> pelts rp1 = (pelts rp)(offset rp1 := o3) \<longrightarrow> (zones mpz2 rem = zone1 rp1 \<and> readers mpz2 rem = -(1 :: int) \<and> offset rp1 = (0 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs (sint rs) \<le> plength rp1 \<and> plength rp1 = alloc mpz2 rem \<and> (\<not>sint rs = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint rs) - (1 :: int)) \<le> value rp1 (abs (sint rs)))) \<and> (\<forall>(mpz3 :: mpz_memo). alloc mpz3 = alloc mpz2 \<and> readers mpz3 = readers mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = rem \<longrightarrow> mpz_unchanged y mpz3 mpz2) \<and> (sgn mpz3 rem = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint rs) \<and> (sgn mpz3 rem = -(1 :: int) \<longleftrightarrow> sint rs < (0 :: int)) \<and> abs_size mpz3 rem = abs (sint rs) \<and> abs_value_of mpz3 rem = value rp1 (abs (sint rs)) \<longrightarrow> (zones mpz3 rem = zone1 rp1 \<and> readers mpz3 rem = -(1 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs_value_of mpz3 rem = value rp1 (abs_size mpz3 rem)) \<and> (\<forall>(mpz4 :: mpz_memo). abs_value_of mpz4 = abs_value_of mpz3 \<and> alloc mpz4 = alloc mpz3 \<and> abs_size mpz4 = abs_size mpz3 \<and> sgn mpz4 = sgn mpz3 \<and> zones mpz4 = zones mpz3 \<longrightarrow> readers mpz4 rem = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = rem \<longrightarrow> readers mpz4 y = readers mpz3 y) \<longrightarrow> int'32_in_bounds (sint nn - (1 :: int)) \<and> (\<forall>(o5 :: 32 word). sint o5 = sint nn - (1 :: int) \<longrightarrow> (c_C.min qp2 \<le> offset qp2 + sint o5 \<and> offset qp2 + sint o5 < c_C.max qp2) \<and> (let qh :: 64 word = pelts qp2 (offset qp2 + sint o5) in \<forall>(o6 :: bool). (uint qh = uint (0 :: 64 word) \<longrightarrow> o6 = True) \<and> (o6 = True \<longrightarrow> qh = (0 :: 64 word)) \<longrightarrow> (\<forall>(o7 :: 32 word). (if o6 = True then o7 = (1 :: 32 word) else o7 = (0 :: 32 word)) \<longrightarrow> int'32_in_bounds (sint nn - sint o7) \<and> (\<forall>(o8 :: 32 word). sint o8 = sint nn - sint o7 \<longrightarrow> (\<not>(0 :: int) \<le> sint ns \<longrightarrow> int'32_in_bounds (-sint o8)) \<and> (\<forall>(qs :: 32 word). (if (0 :: int) \<le> sint ns then qs = o8 else sint qs = -sint o8) \<longrightarrow> (zones mpz4 quot = zone1 qp2 \<and> readers mpz4 quot = -(1 :: int) \<and> offset qp2 = (0 :: int) \<and> c_C.min qp2 = (0 :: int) \<and> c_C.max qp2 = plength qp2 \<and> abs (sint qs) \<le> plength qp2 \<and> plength qp2 = alloc mpz4 quot \<and> (\<not>sint qs = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint qs) - (1 :: int)) \<le> value qp2 (abs (sint qs)))) \<and> (\<forall>(mpz5 :: mpz_memo). alloc mpz5 = alloc mpz4 \<and> readers mpz5 = readers mpz4 \<and> zones mpz5 = zones mpz4 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = quot \<longrightarrow> mpz_unchanged y mpz5 mpz4) \<and> (sgn mpz5 quot = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint qs) \<and> (sgn mpz5 quot = -(1 :: int) \<longleftrightarrow> sint qs < (0 :: int)) \<and> abs_size mpz5 quot = abs (sint qs) \<and> abs_value_of mpz5 quot = value qp2 (abs (sint qs)) \<longrightarrow> (zones mpz5 quot = zone1 qp2 \<and> readers mpz5 quot = -(1 :: int) \<and> c_C.min qp2 = (0 :: int) \<and> c_C.max qp2 = plength qp2 \<and> abs_value_of mpz5 quot = value qp2 (abs_size mpz5 quot)) \<and> (\<forall>(mpz6 :: mpz_memo). abs_value_of mpz6 = abs_value_of mpz5 \<and> alloc mpz6 = alloc mpz5 \<and> abs_size mpz6 = abs_size mpz5 \<and> sgn mpz6 = sgn mpz5 \<and> zones mpz6 = zones mpz5 \<longrightarrow> readers mpz6 quot = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = quot \<longrightarrow> readers mpz6 y = readers mpz5 y) \<longrightarrow> mpz_unchanged rem mpz6 mpz4 \<and> (readers mpz6 rem = readers mpz4 rem \<and> (-(2 :: int) < readers mpz6 rem \<longrightarrow> abs_value_of mpz6 rem = abs_value_of mpz4 rem \<and> alloc mpz6 rem = alloc mpz4 rem \<and> abs_size mpz6 rem = abs_size mpz4 rem \<and> sgn mpz6 rem = sgn mpz4 rem \<and> readers mpz6 rem = readers mpz4 rem \<and> zones mpz6 rem = zones mpz4 rem) \<longrightarrow> value_of quot mpz6 * uint divisor + value_of rem mpz6 = value_of dividend mpz \<and> uint o3 = abs_value_of mpz6 rem \<and> ((0 :: int) \<le> abs_value_of mpz6 rem \<and> abs_value_of mpz6 rem < uint divisor) \<and> (\<forall>(x :: mpz_ptr). \<not>x = quot \<longrightarrow> \<not>x = rem \<longrightarrow> mpz_unchanged x mpz6 mpz) \<and> readers mpz6 dividend = (0 :: int) \<and> readers mpz6 quot = (0 :: int) \<and> readers mpz6 rem = (0 :: int))))))))))))))))))))) else (0 :: int) \<le> readers mpz1 dividend \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> (\<forall>(np :: 64 word ptr). readers mpz2 dividend = readers mpz1 dividend + (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>dividend = y \<longrightarrow> readers mpz2 y = readers mpz1 y) \<and> value np (abs_size mpz2 dividend) = abs_value_of mpz2 dividend \<and> plength np = alloc mpz2 dividend \<and> offset np = (0 :: int) \<and> c_C.min np = (0 :: int) \<and> c_C.max np = plength np \<and> zone1 np = zones mpz2 dividend \<longrightarrow> (valid np (sint nn) \<and> valid qp (sint nn) \<and> writable qp = True \<and> (0 :: int) < sint nn \<and> (0 :: int) < uint divisor) \<and> (\<forall>(qp1 :: 64 word ptr). length (data qp1) = length (data qp) \<and> offset qp1 = offset qp \<and> c_C.min qp1 = c_C.min qp \<and> c_C.max qp1 = c_C.max qp \<and> writable qp1 = writable qp \<and> zone1 qp1 = zone1 qp \<longrightarrow> (\<forall>(o2 :: 64 word). value np (sint nn) = value qp1 (sint nn) * uint divisor + uint o2 \<and> uint o2 < uint divisor \<longrightarrow> (zones mpz2 dividend = zone1 np \<and> (1 :: int) \<le> readers mpz2 dividend \<and> c_C.min np = (0 :: int) \<and> c_C.max np = plength np) \<and> (\<forall>(mpz3 :: mpz_memo). abs_value_of mpz3 = abs_value_of mpz2 \<and> alloc mpz3 = alloc mpz2 \<and> abs_size mpz3 = abs_size mpz2 \<and> sgn mpz3 = sgn mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> readers mpz3 dividend = readers mpz2 dividend - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = dividend \<longrightarrow> readers mpz3 y = readers mpz2 y) \<longrightarrow> (mpz_eq rem dividend \<longleftrightarrow> rem = dividend) \<longrightarrow> (\<not>mpz_eq rem dividend \<longrightarrow> mpz_unchanged rem mpz3 mpz) \<and> ((\<not>mpz_eq rem dividend \<longrightarrow> readers mpz3 rem = readers mpz rem \<and> (-(2 :: int) < readers mpz3 rem \<longrightarrow> abs_value_of mpz3 rem = abs_value_of mpz rem \<and> alloc mpz3 rem = alloc mpz rem \<and> abs_size mpz3 rem = abs_size mpz rem \<and> sgn mpz3 rem = sgn mpz rem \<and> readers mpz3 rem = readers mpz rem \<and> zones mpz3 rem = zones mpz rem)) \<longrightarrow> (\<forall>(o3 :: bool). (uint o2 = uint (0 :: 64 word) \<longrightarrow> o3 = True) \<and> (o3 = True \<longrightarrow> o2 = (0 :: 64 word)) \<longrightarrow> (if o3 = True then (-(1 :: int) \<le> readers mpz3 rem \<and> readers mpz3 rem \<le> (0 :: int)) \<and> (\<forall>(mpz4 :: mpz_memo). alloc mpz4 = alloc mpz3 \<and> sgn mpz4 = sgn mpz3 \<and> readers mpz4 = readers mpz3 \<and> zones mpz4 = zones mpz3 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = rem \<longrightarrow> mpz_unchanged y mpz4 mpz3) \<and> abs_size mpz4 rem = (0 :: int) \<and> abs_value_of mpz4 rem = (0 :: int) \<longrightarrow> int'32_in_bounds (sint nn - (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint nn - (1 :: int) \<longrightarrow> (c_C.min qp1 \<le> offset qp1 + sint o4 \<and> offset qp1 + sint o4 < c_C.max qp1) \<and> (let qh :: 64 word = pelts qp1 (offset qp1 + sint o4) in \<forall>(o5 :: bool). (uint qh = uint (0 :: 64 word) \<longrightarrow> o5 = True) \<and> (o5 = True \<longrightarrow> qh = (0 :: 64 word)) \<longrightarrow> (\<forall>(o6 :: 32 word). (if o5 = True then o6 = (1 :: 32 word) else o6 = (0 :: 32 word)) \<longrightarrow> int'32_in_bounds (sint nn - sint o6) \<and> (\<forall>(o7 :: 32 word). sint o7 = sint nn - sint o6 \<longrightarrow> (\<not>(0 :: int) \<le> sint ns \<longrightarrow> int'32_in_bounds (-sint o7)) \<and> (\<forall>(qs :: 32 word). (if (0 :: int) \<le> sint ns then qs = o7 else sint qs = -sint o7) \<longrightarrow> (zones mpz4 quot = zone1 qp1 \<and> readers mpz4 quot = -(1 :: int) \<and> offset qp1 = (0 :: int) \<and> c_C.min qp1 = (0 :: int) \<and> c_C.max qp1 = plength qp1 \<and> abs (sint qs) \<le> plength qp1 \<and> plength qp1 = alloc mpz4 quot \<and> (\<not>sint qs = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint qs) - (1 :: int)) \<le> value qp1 (abs (sint qs)))) \<and> (\<forall>(mpz5 :: mpz_memo). alloc mpz5 = alloc mpz4 \<and> readers mpz5 = readers mpz4 \<and> zones mpz5 = zones mpz4 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = quot \<longrightarrow> mpz_unchanged y mpz5 mpz4) \<and> (sgn mpz5 quot = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint qs) \<and> (sgn mpz5 quot = -(1 :: int) \<longleftrightarrow> sint qs < (0 :: int)) \<and> abs_size mpz5 quot = abs (sint qs) \<and> abs_value_of mpz5 quot = value qp1 (abs (sint qs)) \<longrightarrow> (zones mpz5 quot = zone1 qp1 \<and> readers mpz5 quot = -(1 :: int) \<and> c_C.min qp1 = (0 :: int) \<and> c_C.max qp1 = plength qp1 \<and> abs_value_of mpz5 quot = value qp1 (abs_size mpz5 quot)) \<and> (\<forall>(mpz6 :: mpz_memo). abs_value_of mpz6 = abs_value_of mpz5 \<and> alloc mpz6 = alloc mpz5 \<and> abs_size mpz6 = abs_size mpz5 \<and> sgn mpz6 = sgn mpz5 \<and> zones mpz6 = zones mpz5 \<longrightarrow> readers mpz6 quot = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = quot \<longrightarrow> readers mpz6 y = readers mpz5 y) \<longrightarrow> mpz_unchanged rem mpz6 mpz4 \<and> (readers mpz6 rem = readers mpz4 rem \<and> (-(2 :: int) < readers mpz6 rem \<longrightarrow> abs_value_of mpz6 rem = abs_value_of mpz4 rem \<and> alloc mpz6 rem = alloc mpz4 rem \<and> abs_size mpz6 rem = abs_size mpz4 rem \<and> sgn mpz6 rem = sgn mpz4 rem \<and> readers mpz6 rem = readers mpz4 rem \<and> zones mpz6 rem = zones mpz4 rem) \<longrightarrow> value_of quot mpz6 * uint divisor + value_of rem mpz6 = value_of dividend mpz \<and> uint o2 = abs_value_of mpz6 rem \<and> ((0 :: int) \<le> abs_value_of mpz6 rem \<and> abs_value_of mpz6 rem < uint divisor) \<and> (\<forall>(x :: mpz_ptr). \<not>x = quot \<longrightarrow> \<not>x = rem \<longrightarrow> mpz_unchanged x mpz6 mpz) \<and> readers mpz6 dividend = (0 :: int) \<and> readers mpz6 quot = (0 :: int) \<and> readers mpz6 rem = (0 :: int)))))))))) else \<forall>(rs :: 32 word). (if (0 :: int) \<le> sint ns then rs = (1 :: 32 word) else rs = Groups.uminus_class.uminus (1 :: 32 word)) \<longrightarrow> readers mpz3 rem = (0 :: int) \<and> (\<forall>(mpz4 :: mpz_memo). abs_value_of mpz4 = abs_value_of mpz3 \<and> alloc mpz4 = alloc mpz3 \<and> abs_size mpz4 = abs_size mpz3 \<and> sgn mpz4 = sgn mpz3 \<and> zones mpz4 = zones mpz3 \<longrightarrow> (\<forall>(rp :: 64 word ptr). readers mpz4 rem = -(1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>rem = y \<longrightarrow> readers mpz4 y = readers mpz3 y) \<and> value rp (abs_size mpz4 rem) = abs_value_of mpz4 rem \<and> plength rp = alloc mpz4 rem \<and> offset rp = (0 :: int) \<and> c_C.min rp = (0 :: int) \<and> c_C.max rp = plength rp \<and> writable rp = True \<and> zone1 rp = zones mpz4 rem \<longrightarrow> ((c_C.min rp \<le> offset rp \<and> offset rp < c_C.max rp) \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> pelts rp1 = (pelts rp)(offset rp1 := o2) \<longrightarrow> (zones mpz4 rem = zone1 rp1 \<and> readers mpz4 rem = -(1 :: int) \<and> offset rp1 = (0 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs (sint rs) \<le> plength rp1 \<and> plength rp1 = alloc mpz4 rem \<and> (\<not>sint rs = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint rs) - (1 :: int)) \<le> value rp1 (abs (sint rs)))) \<and> (\<forall>(mpz5 :: mpz_memo). alloc mpz5 = alloc mpz4 \<and> readers mpz5 = readers mpz4 \<and> zones mpz5 = zones mpz4 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = rem \<longrightarrow> mpz_unchanged y mpz5 mpz4) \<and> (sgn mpz5 rem = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint rs) \<and> (sgn mpz5 rem = -(1 :: int) \<longleftrightarrow> sint rs < (0 :: int)) \<and> abs_size mpz5 rem = abs (sint rs) \<and> abs_value_of mpz5 rem = value rp1 (abs (sint rs)) \<longrightarrow> (zones mpz5 rem = zone1 rp1 \<and> readers mpz5 rem = -(1 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs_value_of mpz5 rem = value rp1 (abs_size mpz5 rem)) \<and> (\<forall>(mpz6 :: mpz_memo). abs_value_of mpz6 = abs_value_of mpz5 \<and> alloc mpz6 = alloc mpz5 \<and> abs_size mpz6 = abs_size mpz5 \<and> sgn mpz6 = sgn mpz5 \<and> zones mpz6 = zones mpz5 \<longrightarrow> readers mpz6 rem = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = rem \<longrightarrow> readers mpz6 y = readers mpz5 y) \<longrightarrow> int'32_in_bounds (sint nn - (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint nn - (1 :: int) \<longrightarrow> (c_C.min qp1 \<le> offset qp1 + sint o4 \<and> offset qp1 + sint o4 < c_C.max qp1) \<and> (let qh :: 64 word = pelts qp1 (offset qp1 + sint o4) in \<forall>(o5 :: bool). (uint qh = uint (0 :: 64 word) \<longrightarrow> o5 = True) \<and> (o5 = True \<longrightarrow> qh = (0 :: 64 word)) \<longrightarrow> (\<forall>(o6 :: 32 word). (if o5 = True then o6 = (1 :: 32 word) else o6 = (0 :: 32 word)) \<longrightarrow> int'32_in_bounds (sint nn - sint o6) \<and> (\<forall>(o7 :: 32 word). sint o7 = sint nn - sint o6 \<longrightarrow> (\<not>(0 :: int) \<le> sint ns \<longrightarrow> int'32_in_bounds (-sint o7)) \<and> (\<forall>(qs :: 32 word). (if (0 :: int) \<le> sint ns then qs = o7 else sint qs = -sint o7) \<longrightarrow> (zones mpz6 quot = zone1 qp1 \<and> readers mpz6 quot = -(1 :: int) \<and> offset qp1 = (0 :: int) \<and> c_C.min qp1 = (0 :: int) \<and> c_C.max qp1 = plength qp1 \<and> abs (sint qs) \<le> plength qp1 \<and> plength qp1 = alloc mpz6 quot \<and> (\<not>sint qs = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint qs) - (1 :: int)) \<le> value qp1 (abs (sint qs)))) \<and> (\<forall>(mpz7 :: mpz_memo). alloc mpz7 = alloc mpz6 \<and> readers mpz7 = readers mpz6 \<and> zones mpz7 = zones mpz6 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = quot \<longrightarrow> mpz_unchanged y mpz7 mpz6) \<and> (sgn mpz7 quot = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint qs) \<and> (sgn mpz7 quot = -(1 :: int) \<longleftrightarrow> sint qs < (0 :: int)) \<and> abs_size mpz7 quot = abs (sint qs) \<and> abs_value_of mpz7 quot = value qp1 (abs (sint qs)) \<longrightarrow> (zones mpz7 quot = zone1 qp1 \<and> readers mpz7 quot = -(1 :: int) \<and> c_C.min qp1 = (0 :: int) \<and> c_C.max qp1 = plength qp1 \<and> abs_value_of mpz7 quot = value qp1 (abs_size mpz7 quot)) \<and> (\<forall>(mpz8 :: mpz_memo). abs_value_of mpz8 = abs_value_of mpz7 \<and> alloc mpz8 = alloc mpz7 \<and> abs_size mpz8 = abs_size mpz7 \<and> sgn mpz8 = sgn mpz7 \<and> zones mpz8 = zones mpz7 \<longrightarrow> readers mpz8 quot = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = quot \<longrightarrow> readers mpz8 y = readers mpz7 y) \<longrightarrow> mpz_unchanged rem mpz8 mpz6 \<and> (readers mpz8 rem = readers mpz6 rem \<and> (-(2 :: int) < readers mpz8 rem \<longrightarrow> abs_value_of mpz8 rem = abs_value_of mpz6 rem \<and> alloc mpz8 rem = alloc mpz6 rem \<and> abs_size mpz8 rem = abs_size mpz6 rem \<and> sgn mpz8 rem = sgn mpz6 rem \<and> readers mpz8 rem = readers mpz6 rem \<and> zones mpz8 rem = zones mpz6 rem) \<longrightarrow> value_of quot mpz8 * uint divisor + value_of rem mpz8 = value_of dividend mpz \<and> uint o2 = abs_value_of mpz8 rem \<and> ((0 :: int) \<le> abs_value_of mpz8 rem \<and> abs_value_of mpz8 rem < uint divisor) \<and> (\<forall>(x :: mpz_ptr). \<not>x = quot \<longrightarrow> \<not>x = rem \<longrightarrow> mpz_unchanged x mpz8 mpz) \<and> readers mpz8 dividend = (0 :: int) \<and> readers mpz8 quot = (0 :: int) \<and> readers mpz8 rem = (0 :: int))))))))))))))))))))))))))))))"
  sorry
end
