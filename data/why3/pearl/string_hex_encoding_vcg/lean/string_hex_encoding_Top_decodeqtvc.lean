import Why3.Base
import Why3.why3.Ref.Ref
import Why3.string.StringBuffer
open Classical
open Lean4Why3
namespace string_hex_encoding_Top_decodeqtvc
noncomputable def valid_hex_char (c : BitVec 8) := (48 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c < (58 : ℤ) ∨ (65 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c < (71 : ℤ)
noncomputable def hex (i : ℤ) := if (0 : ℤ) ≤ i ∧ i < (10 : ℤ) then BitVec.ofNat 8 (Int.toNat (i + (48 : ℤ))) else if (10 : ℤ) ≤ i ∧ i < (16 : ℤ) then BitVec.ofNat 8 (Int.toNat (i + (55 : ℤ))) else ([0] : List (BitVec 8))[(0 : ℕ)]!
noncomputable def xeh (c : BitVec 8) := if (48 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c < (58 : ℤ) then BitVec.toInt c - (48 : ℤ) else if (65 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c < (71 : ℤ) then BitVec.toInt c - (55 : ℤ) else -(1 : ℤ)
noncomputable def valid_hex (s : List (BitVec 8)) := Int.tmod (Int.ofNat (List.length s)) (2 : ℤ) = (0 : ℤ) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s) → valid_hex_char (s[Int.toNat i]!))
noncomputable def encoding (s1 : List (BitVec 8)) (s2 : List (BitVec 8)) := Int.ofNat (List.length s2) = (2 : ℤ) * Int.ofNat (List.length s1) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s1) → s1[Int.toNat i]! = BitVec.ofNat 8 (Int.toNat (xeh (s2[Int.toNat ((2 : ℤ) * i)]!) * (16 : ℤ) + xeh (s2[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]!)))) ∧ valid_hex s2
theorem decode'vc (s : List (BitVec 8)) (o1 : BitVec 63) (fact0 : valid_hex s) (fact1 : BitVec.toInt o1 = Int.ofNat (List.length s)) (fact2 : (0 : ℤ) ≤ Int.ofNat (List.length s)) : ¬(2 : ℤ) = (0 : ℤ) ∧ int'63_in_bounds (Int.tdiv (BitVec.toInt o1) (2 : ℤ)) ∧ (∀(o2 : BitVec 63), BitVec.toInt o2 = Int.tdiv (BitVec.toInt o1) (2 : ℤ) → (∀(r : StringBuffer.buffer), StringBuffer.str r = ([] : List (BitVec 8)) → (Int.tmod (0 : ℤ) (2 : ℤ) = (0 : ℤ) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length s)) ∧ Int.ofNat (List.length (StringBuffer.str r)) = Int.tdiv (0 : ℤ) (2 : ℤ) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.tdiv (0 : ℤ) (2 : ℤ) → (StringBuffer.str r)[Int.toNat j]! = BitVec.ofNat 8 (Int.toNat (xeh (s[Int.toNat ((2 : ℤ) * j)]!) * (16 : ℤ) + xeh (s[Int.toNat ((2 : ℤ) * j + (1 : ℤ))]!))))) ∧ (∀(r1 : StringBuffer.buffer) (i : BitVec 63), Int.tmod (BitVec.toInt i) (2 : ℤ) = (0 : ℤ) ∧ ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ Int.ofNat (List.length s)) ∧ Int.ofNat (List.length (StringBuffer.str r1)) = Int.tdiv (BitVec.toInt i) (2 : ℤ) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.tdiv (BitVec.toInt i) (2 : ℤ) → (StringBuffer.str r1)[Int.toNat j]! = BitVec.ofNat 8 (Int.toNat (xeh (s[Int.toNat ((2 : ℤ) * j)]!) * (16 : ℤ) + xeh (s[Int.toNat ((2 : ℤ) * j + (1 : ℤ))]!)))) → (∀(o3 : BitVec 63), BitVec.toInt o3 = Int.ofNat (List.length s) ∧ (0 : ℤ) ≤ Int.ofNat (List.length s) → (if BitVec.toInt i < BitVec.toInt o3 then ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i < Int.ofNat (List.length s)) ∧ (let o4 : BitVec 8 := s[Int.toNat (BitVec.toInt i)]!; valid_hex_char o4 ∧ (∀(v_i : BitVec 63), BitVec.toInt v_i = xeh o4 → int'63_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o5 : BitVec 63), BitVec.toInt o5 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 < Int.ofNat (List.length s)) ∧ (let o6 : BitVec 8 := s[Int.toNat (BitVec.toInt o5)]!; valid_hex_char o6 ∧ (∀(v_ii : BitVec 63), BitVec.toInt v_ii = xeh o6 → int'63_in_bounds (BitVec.toInt v_i * (16 : ℤ)) ∧ (∀(o7 : BitVec 63), BitVec.toInt o7 = BitVec.toInt v_i * (16 : ℤ) → int'63_in_bounds (BitVec.toInt o7 + BitVec.toInt v_ii) ∧ (∀(o8 : BitVec 63), BitVec.toInt o8 = BitVec.toInt o7 + BitVec.toInt v_ii → ((0 : ℤ) ≤ BitVec.toInt o8 ∧ BitVec.toInt o8 < (256 : ℤ)) ∧ (∀(r2 : StringBuffer.buffer), StringBuffer.str r2 = StringBuffer.str r1 ++ [BitVec.ofNat 8 (Int.toNat (BitVec.toInt o8))] → int'63_in_bounds (BitVec.toInt i + (2 : ℤ)) ∧ (∀(o9 : BitVec 63), BitVec.toInt o9 = BitVec.toInt i + (2 : ℤ) → ((0 : ℤ) ≤ Int.ofNat (List.length s) - BitVec.toInt i ∧ Int.ofNat (List.length s) - BitVec.toInt o9 < Int.ofNat (List.length s) - BitVec.toInt i) ∧ Int.tmod (BitVec.toInt o9) (2 : ℤ) = (0 : ℤ) ∧ ((0 : ℤ) ≤ BitVec.toInt o9 ∧ BitVec.toInt o9 ≤ Int.ofNat (List.length s)) ∧ Int.ofNat (List.length (StringBuffer.str r2)) = Int.tdiv (BitVec.toInt o9) (2 : ℤ) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.tdiv (BitVec.toInt o9) (2 : ℤ) → (StringBuffer.str r2)[Int.toNat j]! = BitVec.ofNat 8 (Int.toNat (xeh (s[Int.toNat ((2 : ℤ) * j)]!) * (16 : ℤ) + xeh (s[Int.toNat ((2 : ℤ) * j + (1 : ℤ))]!))))))))))))) else encoding (StringBuffer.str r1) s)))))
  := sorry
end string_hex_encoding_Top_decodeqtvc
