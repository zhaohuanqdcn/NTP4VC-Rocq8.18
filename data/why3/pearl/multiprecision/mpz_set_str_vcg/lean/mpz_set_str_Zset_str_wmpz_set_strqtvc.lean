import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import Why3.mach.c.String
import Why3.mach.c.StrlenLemmas
import Why3.mach.c.UChar
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.mpz.Z
import pearl.multiprecision.lib.lean.mpz.Zutil
import pearl.multiprecision.lib.lean.base_info.BaseInfo
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.stringlemmas.String_lemmas
import pearl.multiprecision.lib.lean.stringlemmas.Conversions
import pearl.multiprecision.lib.lean.stringlemmas.String_value
import pearl.multiprecision.lib.lean.set_str.Set_str
import pearl.multiprecision.lib.lean.powm.Powm
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.valuation.Valuation
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.sub_1.Sub_1
open Classical
open Lean4Why3
namespace mpz_set_str_Zset_str_wmpz_set_strqtvc
theorem wmpz_set_str'vc (sp : C.ptr (BitVec 8)) (mpz : Z.mpz_memo) (r : Z.mpz_ptr) (base : BitVec 32) (fact0 : String.valid_string sp) (fact1 : String.strlen (C.pelts sp) (C.offset sp) * (8 : ℤ) + (63 : ℤ) ≤ (2147483647 : ℤ)) (fact2 : Z.readers mpz r = (0 : ℤ)) (fact3 : (1 : ℤ) ≤ Z.alloc mpz r) (fact4 : (2 : ℤ) ≤ BitVec.toInt base) (fact5 : BitVec.toInt base ≤ (62 : ℤ)) : C.min sp ≤ C.offset sp ∧ C.offset sp < C.max sp ∧ (∀(sign : BitVec 32), (if C.pelts sp (C.offset sp) = ([45] : List (BitVec 8))[(0 : ℕ)]! then sign = (1 : BitVec 32) else sign = (0 : BitVec 32)) → String.valid_string sp ∧ (∀(slen : BitVec 32), BitVec.toUInt slen = String.strlen (C.pelts sp) (C.offset sp) → (C.min sp ≤ C.offset sp + BitVec.toInt sign ∧ C.offset sp + BitVec.toInt sign ≤ C.max sp) ∧ (∀(o1 : C.ptr (BitVec 8)), C.offset o1 = C.offset sp + BitVec.toInt sign ∧ C.plength o1 = C.plength sp ∧ C.pelts o1 = C.pelts sp ∧ C.data o1 = C.data sp ∧ C.min o1 = C.min sp ∧ C.max o1 = C.max sp ∧ C.zone1 o1 = C.zone1 sp ∧ C.writable o1 = C.writable sp → (C.min o1 ≤ C.offset o1 ∧ C.offset o1 < C.max o1) ∧ (if C.pelts o1 (C.offset o1) = String.zero_char then (-(1 : ℤ) ≤ Z.readers mpz r ∧ Z.readers mpz r ≤ (0 : ℤ)) ∧ (∀(mpz1 : Z.mpz_memo), Z.alloc mpz1 = Z.alloc mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.readers mpz1 = Z.readers mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz1 mpz) ∧ Z.abs_size mpz1 r = (0 : ℤ) ∧ Z.abs_value_of mpz1 r = (0 : ℤ) → (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz1 mpz) ∧ Z.readers mpz1 r = (0 : ℤ) ∧ (-(1 : ℤ) = (0 : ℤ) → Z.value_of r mpz1 = String_value.value_text (BitVec.toInt base) (C.pelts sp) (C.offset sp)) ∧ (-(1 : ℤ) ≤ -(1 : ℤ) ∧ -(1 : ℤ) ≤ (0 : ℤ)) ∧ (-(1 : ℤ) = (0 : ℤ)) = String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp)) else String.valid_string sp ∧ (∀(o2 : BitVec 32), BitVec.toUInt o2 = String.strlen (C.pelts sp) (C.offset sp) → (0 : ℤ) ≤ BitVec.toUInt o2 ∧ (∀(dp : C.ptr (BitVec 8)), C.plength dp = BitVec.toUInt o2 ∧ C.offset dp = (0 : ℤ) ∧ C.min dp = (0 : ℤ) ∧ C.max dp = BitVec.toUInt o2 ∧ C.writable dp = true → (C.offset o1 = C.offset sp + BitVec.toInt sign + (0 : ℤ) ∧ (C.offset sp + BitVec.toInt sign ≤ C.offset o1 ∧ C.offset o1 ≤ C.offset sp + String.strlen (C.pelts sp) (C.offset sp)) ∧ (C.min sp ≤ C.offset o1 ∧ C.offset o1 ≤ C.max sp) ∧ String_value.abs_value_sub_text (BitVec.toInt base) (C.pelts sp) (C.offset sp + BitVec.toInt sign) (C.offset o1) = String_lemmas.svalue_sub (BitVec.toInt base) (C.pelts dp) (0 : ℤ) (0 : ℤ) ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts dp) (0 : ℤ) (0 : ℤ) ∧ (¬BitVec.toInt (C.pelts o1 (C.offset o1)) = (0 : ℤ)) = (C.offset o1 < C.offset sp + String.strlen (C.pelts sp) (C.offset sp)) ∧ (C.min o1 = C.min sp ∧ C.max o1 = C.max sp) ∧ C.plength o1 = C.plength sp ∧ C.pelts o1 = C.pelts sp ∧ String_value.text_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp + BitVec.toInt sign) (C.offset o1)) ∧ (∀(dn : BitVec 32) (dp1 : C.ptr (BitVec 8)) (spi : C.ptr (BitVec 8)), List.length (C.data dp1) = List.length (C.data dp) ∧ C.offset dp1 = C.offset dp ∧ C.min dp1 = C.min dp ∧ C.max dp1 = C.max dp ∧ C.writable dp1 = C.writable dp ∧ C.zone1 dp1 = C.zone1 dp → C.offset spi = C.offset sp + BitVec.toInt sign + BitVec.toInt dn ∧ (C.offset sp + BitVec.toInt sign ≤ C.offset spi ∧ C.offset spi ≤ C.offset sp + String.strlen (C.pelts sp) (C.offset sp)) ∧ (C.min sp ≤ C.offset spi ∧ C.offset spi ≤ C.max sp) ∧ String_value.abs_value_sub_text (BitVec.toInt base) (C.pelts sp) (C.offset sp + BitVec.toInt sign) (C.offset spi) = String_lemmas.svalue_sub (BitVec.toInt base) (C.pelts dp1) (0 : ℤ) (BitVec.toInt dn) ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts dp1) (0 : ℤ) (BitVec.toInt dn) ∧ (¬BitVec.toInt (C.pelts spi (C.offset spi)) = (0 : ℤ)) = (C.offset spi < C.offset sp + String.strlen (C.pelts sp) (C.offset sp)) ∧ (C.min spi = C.min sp ∧ C.max spi = C.max sp) ∧ C.plength spi = C.plength sp ∧ C.pelts spi = C.pelts sp ∧ String_value.text_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp + BitVec.toInt sign) (C.offset spi) → (C.min spi ≤ C.offset spi ∧ C.offset spi < C.max spi) ∧ (if ¬C.pelts spi (C.offset spi) = String.zero_char then (C.min spi ≤ C.offset spi ∧ C.offset spi < C.max spi) ∧ (let c : BitVec 8 := C.pelts spi (C.offset spi); (if (36 : ℤ) < BitVec.toInt base then ∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt c → (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt (([48] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o5 : Bool), (if BitVec.toInt o4 ≤ BitVec.toInt o3 then ∃(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt (([57] : List (BitVec 8))[(0 : ℕ)]!) ∧ (∃(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt c ∧ o5 = (if BitVec.toInt o7 ≤ BitVec.toInt o6 then true else false)) else o5 = false) → (if o5 = true then ∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt (([48] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt c → int'32_in_bounds (BitVec.toInt o7 - BitVec.toInt o6) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt o7 - BitVec.toInt o6 → ((0 : ℤ) ≤ BitVec.toInt o8 ∧ BitVec.toInt o8 ≤ (255 : ℤ)) ∧ (∀(o9 : BitVec 8), BitVec.toInt o9 = BitVec.toInt o8 → ((0 : ℤ) ≤ BitVec.toInt o9 ∧ BitVec.toInt o9 < BitVec.toInt base → BitVec.toInt o9 = Conversions.text_to_num (BitVec.toInt base) c) ∧ (BitVec.toInt base ≤ BitVec.toInt o9 → ¬String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp)) ∧ (0 : ℤ) ≤ BitVec.toInt o9))) else ∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt c → (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt (([97] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o8 : Bool), (if BitVec.toInt o7 ≤ BitVec.toInt o6 then ∃(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt (([122] : List (BitVec 8))[(0 : ℕ)]!) ∧ (∃(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt c ∧ o8 = (if BitVec.toInt o10 ≤ BitVec.toInt o9 then true else false)) else o8 = false) → (if o8 = true then ∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt (([97] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt c → int'32_in_bounds (BitVec.toInt o10 - BitVec.toInt o9) ∧ (∀(o11 : BitVec 32), BitVec.toInt o11 = BitVec.toInt o10 - BitVec.toInt o9 → int'32_in_bounds (BitVec.toInt o11 + (36 : ℤ)) ∧ (∀(d : BitVec 32), BitVec.toInt d = BitVec.toInt o11 + (36 : ℤ) → (∀(o12 : BitVec 32), BitVec.toInt o12 = BitVec.toInt (([97] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o13 : BitVec 32), BitVec.toInt o13 = BitVec.toInt c → int'32_in_bounds (BitVec.toInt o13 - BitVec.toInt o12) ∧ (∀(o14 : BitVec 32), BitVec.toInt o14 = BitVec.toInt o13 - BitVec.toInt o12 → int'32_in_bounds (BitVec.toInt o14 + (36 : ℤ)) ∧ (∀(o15 : BitVec 32), BitVec.toInt o15 = BitVec.toInt o14 + (36 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o15 ∧ BitVec.toInt o15 ≤ (255 : ℤ)) ∧ (∀(o16 : BitVec 8), BitVec.toInt o16 = BitVec.toInt o15 → ((0 : ℤ) ≤ BitVec.toInt o16 ∧ BitVec.toInt o16 < BitVec.toInt base → BitVec.toInt o16 = Conversions.text_to_num (BitVec.toInt base) c) ∧ (BitVec.toInt base ≤ BitVec.toInt o16 → ¬String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp)) ∧ (0 : ℤ) ≤ BitVec.toInt o16)))))))) else ∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt c → (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt (([65] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o11 : Bool), (if BitVec.toInt o10 ≤ BitVec.toInt o9 then ∃(o12 : BitVec 32), BitVec.toInt o12 = BitVec.toInt (([90] : List (BitVec 8))[(0 : ℕ)]!) ∧ (∃(o13 : BitVec 32), BitVec.toInt o13 = BitVec.toInt c ∧ o11 = (if BitVec.toInt o13 ≤ BitVec.toInt o12 then true else false)) else o11 = false) → (if o11 = true then ∀(o12 : BitVec 32), BitVec.toInt o12 = BitVec.toInt (([65] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o13 : BitVec 32), BitVec.toInt o13 = BitVec.toInt c → int'32_in_bounds (BitVec.toInt o13 - BitVec.toInt o12) ∧ (∀(o14 : BitVec 32), BitVec.toInt o14 = BitVec.toInt o13 - BitVec.toInt o12 → int'32_in_bounds (BitVec.toInt o14 + (10 : ℤ)) ∧ (∀(o15 : BitVec 32), BitVec.toInt o15 = BitVec.toInt o14 + (10 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o15 ∧ BitVec.toInt o15 ≤ (255 : ℤ)) ∧ (∀(o16 : BitVec 8), BitVec.toInt o16 = BitVec.toInt o15 → ((0 : ℤ) ≤ BitVec.toInt o16 ∧ BitVec.toInt o16 < BitVec.toInt base → BitVec.toInt o16 = Conversions.text_to_num (BitVec.toInt base) c) ∧ (BitVec.toInt base ≤ BitVec.toInt o16 → ¬String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp)) ∧ (0 : ℤ) ≤ BitVec.toInt o16)))) else ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (255 : ℤ)) ∧ (∀(o12 : BitVec 8), BitVec.toInt o12 = BitVec.toInt base → ((0 : ℤ) ≤ BitVec.toInt o12 ∧ BitVec.toInt o12 < BitVec.toInt base → BitVec.toInt o12 = Conversions.text_to_num (BitVec.toInt base) c) ∧ (BitVec.toInt base ≤ BitVec.toInt o12 → ¬String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp)) ∧ (0 : ℤ) ≤ BitVec.toInt o12)))))))))) else ∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt c → (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt (([48] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o5 : Bool), (if BitVec.toInt o4 ≤ BitVec.toInt o3 then ∃(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt (([57] : List (BitVec 8))[(0 : ℕ)]!) ∧ (∃(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt c ∧ o5 = (if BitVec.toInt o7 ≤ BitVec.toInt o6 then true else false)) else o5 = false) → (if o5 = true then ∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt (([48] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt c → int'32_in_bounds (BitVec.toInt o7 - BitVec.toInt o6) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt o7 - BitVec.toInt o6 → ((0 : ℤ) ≤ BitVec.toInt o8 ∧ BitVec.toInt o8 ≤ (255 : ℤ)) ∧ (∀(o9 : BitVec 8), BitVec.toInt o9 = BitVec.toInt o8 → ((0 : ℤ) ≤ BitVec.toInt o9 ∧ BitVec.toInt o9 < BitVec.toInt base → BitVec.toInt o9 = Conversions.text_to_num (BitVec.toInt base) c) ∧ (BitVec.toInt base ≤ BitVec.toInt o9 → ¬String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp)) ∧ (0 : ℤ) ≤ BitVec.toInt o9))) else ∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt c → (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt (([97] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o8 : Bool), (if BitVec.toInt o7 ≤ BitVec.toInt o6 then ∃(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt (([122] : List (BitVec 8))[(0 : ℕ)]!) ∧ (∃(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt c ∧ o8 = (if BitVec.toInt o10 ≤ BitVec.toInt o9 then true else false)) else o8 = false) → (if o8 = true then ∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt (([97] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt c → int'32_in_bounds (BitVec.toInt o10 - BitVec.toInt o9) ∧ (∀(o11 : BitVec 32), BitVec.toInt o11 = BitVec.toInt o10 - BitVec.toInt o9 → int'32_in_bounds (BitVec.toInt o11 + (10 : ℤ)) ∧ (∀(d : BitVec 32), BitVec.toInt d = BitVec.toInt o11 + (10 : ℤ) → (∀(o12 : BitVec 32), BitVec.toInt o12 = BitVec.toInt (([97] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o13 : BitVec 32), BitVec.toInt o13 = BitVec.toInt c → int'32_in_bounds (BitVec.toInt o13 - BitVec.toInt o12) ∧ (∀(o14 : BitVec 32), BitVec.toInt o14 = BitVec.toInt o13 - BitVec.toInt o12 → int'32_in_bounds (BitVec.toInt o14 + (10 : ℤ)) ∧ (∀(o15 : BitVec 32), BitVec.toInt o15 = BitVec.toInt o14 + (10 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o15 ∧ BitVec.toInt o15 ≤ (255 : ℤ)) ∧ (∀(o16 : BitVec 8), BitVec.toInt o16 = BitVec.toInt o15 → ((0 : ℤ) ≤ BitVec.toInt o16 ∧ BitVec.toInt o16 < BitVec.toInt base → BitVec.toInt o16 = Conversions.text_to_num (BitVec.toInt base) c) ∧ (BitVec.toInt base ≤ BitVec.toInt o16 → ¬String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp)) ∧ (0 : ℤ) ≤ BitVec.toInt o16)))))))) else ∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt c → (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt (([65] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o11 : Bool), (if BitVec.toInt o10 ≤ BitVec.toInt o9 then ∃(o12 : BitVec 32), BitVec.toInt o12 = BitVec.toInt (([90] : List (BitVec 8))[(0 : ℕ)]!) ∧ (∃(o13 : BitVec 32), BitVec.toInt o13 = BitVec.toInt c ∧ o11 = (if BitVec.toInt o13 ≤ BitVec.toInt o12 then true else false)) else o11 = false) → (if o11 = true then ∀(o12 : BitVec 32), BitVec.toInt o12 = BitVec.toInt (([65] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o13 : BitVec 32), BitVec.toInt o13 = BitVec.toInt c → int'32_in_bounds (BitVec.toInt o13 - BitVec.toInt o12) ∧ (∀(o14 : BitVec 32), BitVec.toInt o14 = BitVec.toInt o13 - BitVec.toInt o12 → int'32_in_bounds (BitVec.toInt o14 + (10 : ℤ)) ∧ (∀(d : BitVec 32), BitVec.toInt d = BitVec.toInt o14 + (10 : ℤ) → (∀(o15 : BitVec 32), BitVec.toInt o15 = BitVec.toInt (([65] : List (BitVec 8))[(0 : ℕ)]!) → (∀(o16 : BitVec 32), BitVec.toInt o16 = BitVec.toInt c → int'32_in_bounds (BitVec.toInt o16 - BitVec.toInt o15) ∧ (∀(o17 : BitVec 32), BitVec.toInt o17 = BitVec.toInt o16 - BitVec.toInt o15 → int'32_in_bounds (BitVec.toInt o17 + (10 : ℤ)) ∧ (∀(o18 : BitVec 32), BitVec.toInt o18 = BitVec.toInt o17 + (10 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o18 ∧ BitVec.toInt o18 ≤ (255 : ℤ)) ∧ (∀(o19 : BitVec 8), BitVec.toInt o19 = BitVec.toInt o18 → ((0 : ℤ) ≤ BitVec.toInt o19 ∧ BitVec.toInt o19 < BitVec.toInt base → BitVec.toInt o19 = Conversions.text_to_num (BitVec.toInt base) c) ∧ (BitVec.toInt base ≤ BitVec.toInt o19 → ¬String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp)) ∧ (0 : ℤ) ≤ BitVec.toInt o19)))))))) else ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (255 : ℤ)) ∧ (∀(o12 : BitVec 8), BitVec.toInt o12 = BitVec.toInt base → ((0 : ℤ) ≤ BitVec.toInt o12 ∧ BitVec.toInt o12 < BitVec.toInt base → BitVec.toInt o12 = Conversions.text_to_num (BitVec.toInt base) c) ∧ (BitVec.toInt base ≤ BitVec.toInt o12 → ¬String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp)) ∧ (0 : ℤ) ≤ BitVec.toInt o12))))))))))) ∧ (∀(digit : BitVec 8), ((0 : ℤ) ≤ BitVec.toInt digit ∧ BitVec.toInt digit < BitVec.toInt base → BitVec.toInt digit = Conversions.text_to_num (BitVec.toInt base) c) ∧ (BitVec.toInt base ≤ BitVec.toInt digit → ¬String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp)) ∧ (0 : ℤ) ≤ BitVec.toInt digit → ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (255 : ℤ)) ∧ (∀(o3 : BitVec 8), BitVec.toInt o3 = BitVec.toInt base → (if BitVec.toInt o3 ≤ BitVec.toInt digit then (-(1 : ℤ) ≤ Z.readers mpz r ∧ Z.readers mpz r ≤ (0 : ℤ)) ∧ (∀(mpz1 : Z.mpz_memo), Z.alloc mpz1 = Z.alloc mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.readers mpz1 = Z.readers mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz1 mpz) ∧ Z.abs_size mpz1 r = (0 : ℤ) ∧ Z.abs_value_of mpz1 r = (0 : ℤ) → (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz1 mpz) ∧ Z.readers mpz1 r = (0 : ℤ) ∧ (-(1 : ℤ) = (0 : ℤ) → Z.value_of r mpz1 = String_value.value_text (BitVec.toInt base) (C.pelts sp) (C.offset sp)) ∧ (-(1 : ℤ) ≤ -(1 : ℤ) ∧ -(1 : ℤ) ≤ (0 : ℤ)) ∧ (-(1 : ℤ) = (0 : ℤ)) = String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp)) else ((C.min dp1 ≤ C.offset dp1 + BitVec.toInt dn ∧ C.offset dp1 + BitVec.toInt dn < C.max dp1) ∧ C.writable dp1 = true) ∧ (∀(dp2 : C.ptr (BitVec 8)), List.length (C.data dp2) = List.length (C.data dp1) ∧ C.offset dp2 = C.offset dp1 ∧ C.min dp2 = C.min dp1 ∧ C.max dp2 = C.max dp1 ∧ C.writable dp2 = C.writable dp1 ∧ C.zone1 dp2 = C.zone1 dp1 → C.pelts dp2 = Function.update (C.pelts dp1) (C.offset dp2 + BitVec.toInt dn) digit ∧ C.pelts dp2 (C.offset dp2 + BitVec.toInt dn) = digit → int'32_in_bounds (BitVec.toInt dn + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt dn + (1 : ℤ) → (C.min spi ≤ C.offset spi + (1 : ℤ) ∧ C.offset spi + (1 : ℤ) ≤ C.max spi) ∧ (∀(o5 : C.ptr (BitVec 8)), C.offset o5 = C.offset spi + (1 : ℤ) ∧ C.plength o5 = C.plength spi ∧ C.pelts o5 = C.pelts spi ∧ C.data o5 = C.data spi ∧ C.min o5 = C.min spi ∧ C.max o5 = C.max spi ∧ C.zone1 o5 = C.zone1 spi ∧ C.writable o5 = C.writable spi → ((0 : ℤ) ≤ C.offset sp + String.strlen (C.pelts sp) (C.offset sp) - C.offset spi ∧ C.offset sp + String.strlen (C.pelts sp) (C.offset sp) - C.offset o5 < C.offset sp + String.strlen (C.pelts sp) (C.offset sp) - C.offset spi) ∧ C.offset o5 = C.offset sp + BitVec.toInt sign + BitVec.toInt o4 ∧ (C.offset sp + BitVec.toInt sign ≤ C.offset o5 ∧ C.offset o5 ≤ C.offset sp + String.strlen (C.pelts sp) (C.offset sp)) ∧ (C.min sp ≤ C.offset o5 ∧ C.offset o5 ≤ C.max sp) ∧ String_value.abs_value_sub_text (BitVec.toInt base) (C.pelts sp) (C.offset sp + BitVec.toInt sign) (C.offset o5) = String_lemmas.svalue_sub (BitVec.toInt base) (C.pelts dp2) (0 : ℤ) (BitVec.toInt o4) ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts dp2) (0 : ℤ) (BitVec.toInt o4) ∧ (¬BitVec.toInt (C.pelts o5 (C.offset o5)) = (0 : ℤ)) = (C.offset o5 < C.offset sp + String.strlen (C.pelts sp) (C.offset sp)) ∧ (C.min o5 = C.min sp ∧ C.max o5 = C.max sp) ∧ C.plength o5 = C.plength sp ∧ C.pelts o5 = C.pelts sp ∧ String_value.text_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp + BitVec.toInt sign) (C.offset o5)))))))) else ∀(o3 : Bool), (BitVec.toInt dn = BitVec.toInt (0 : BitVec 32) → o3 = true) ∧ (o3 = true → dn = (0 : BitVec 32)) → (if o3 = true then (-(1 : ℤ) ≤ Z.readers mpz r ∧ Z.readers mpz r ≤ (0 : ℤ)) ∧ (∀(mpz1 : Z.mpz_memo), Z.alloc mpz1 = Z.alloc mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.readers mpz1 = Z.readers mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz1 mpz) ∧ Z.abs_size mpz1 r = (0 : ℤ) ∧ Z.abs_value_of mpz1 r = (0 : ℤ) → (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz1 mpz) ∧ Z.readers mpz1 r = (0 : ℤ) ∧ (-(1 : ℤ) = (0 : ℤ) → Z.value_of r mpz1 = String_value.value_text (BitVec.toInt base) (C.pelts sp) (C.offset sp)) ∧ (-(1 : ℤ) ≤ -(1 : ℤ) ∧ -(1 : ℤ) ≤ (0 : ℤ)) ∧ (-(1 : ℤ) = (0 : ℤ)) = String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp)) else (0 : ℤ) ≤ BitVec.toInt base ∧ (∀(o4 : BitVec 64), BitVec.toUInt o4 = BitVec.toInt base → ((2 : ℤ) ≤ BitVec.toUInt o4 ∧ BitVec.toUInt o4 ≤ (256 : ℤ)) ∧ (∀(bits : BitVec 32), ((0 : ℤ) ≤ BitVec.toUInt bits ∧ BitVec.toUInt bits ≤ (8 : ℤ)) ∧ (¬BitVec.toUInt bits = (0 : ℤ) → HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits)) = BitVec.toUInt o4) ∧ (BitVec.toUInt bits = (0 : ℤ) → (∀(n : ℤ), (0 : ℤ) ≤ n → ¬HPow.hPow (2 : ℤ) (Int.toNat n) = BitVec.toUInt o4)) → (if (0 : ℤ) < BitVec.toUInt bits then BitVec.toUInt bits ≤ (2147483647 : ℤ) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toUInt bits → int'32_in_bounds (BitVec.toInt dn * BitVec.toInt o5) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt dn * BitVec.toInt o5 → int'32_in_bounds (BitVec.toInt o6 + (63 : ℤ)) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt o6 + (63 : ℤ) → (¬(64 : ℤ) = (0 : ℤ) ∧ int'32_in_bounds (Int.tdiv (BitVec.toInt o7) (64 : ℤ))) ∧ (∀(alloc : BitVec 32), BitVec.toInt alloc = Int.tdiv (BitVec.toInt o7) (64 : ℤ) → (Z.readers mpz r = (0 : ℤ) ∧ (1 : ℤ) ≤ Z.alloc mpz r) ∧ (∀(mpz1 : Z.mpz_memo), Z.sgn mpz1 = Z.sgn mpz → (∀(rp : C.ptr (BitVec 64)), (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz1 mpz) ∧ Z.readers mpz1 r = -(1 : ℤ) ∧ Z.abs_value_of mpz1 r = Lemmas.value rp (Z.abs_size mpz1 r) ∧ Z.zones mpz1 r = C.zone1 rp ∧ C.offset rp = (0 : ℤ) ∧ C.plength rp = Z.alloc mpz1 r ∧ C.min rp = (0 : ℤ) ∧ C.max rp = C.plength rp ∧ C.writable rp = true ∧ Z.abs_size mpz1 r = Z.abs_size mpz r ∧ Lemmas.value rp (Z.abs_size mpz r) = Z.abs_value_of mpz r ∧ (if Z.alloc mpz r < BitVec.toInt alloc then Z.alloc mpz1 r = BitVec.toInt alloc else Z.alloc mpz1 r = Z.alloc mpz r) → (0 : ℤ) ≤ BitVec.toInt dn ∧ (∀(o8 : BitVec 32), BitVec.toUInt o8 = BitVec.toInt dn → (((0 : ℤ) < BitVec.toUInt o8 ∧ BitVec.toUInt o8 ≤ (2147483647 : ℤ)) ∧ (0 : ℤ) < BitVec.toInt alloc ∧ C.valid rp (BitVec.toInt alloc) ∧ C.valid dp1 (BitVec.toUInt o8) ∧ ((1 : ℤ) ≤ BitVec.toUInt bits ∧ BitVec.toUInt bits ≤ (8 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits * BitVec.toUInt o8)) ≤ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt alloc)) ∧ C.writable rp = true ∧ String_lemmas.in_base (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) (C.pelts dp1) (C.offset dp1) (C.offset dp1 + BitVec.toUInt o8)) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(rn : BitVec 32), ((0 : ℤ) ≤ BitVec.toInt rn ∧ BitVec.toInt rn ≤ BitVec.toInt alloc) ∧ Lemmas.value rp1 (BitVec.toInt rn) = String_lemmas.svalue (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) dp1 (BitVec.toUInt o8) ∧ ((0 : ℤ) < BitVec.toInt rn → (0 : ℤ) < BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt rn - (1 : ℤ)))) → (∀(o9 : Bool), (BitVec.toInt sign = BitVec.toInt (0 : BitVec 32) → o9 = true) ∧ (o9 = true → sign = (0 : BitVec 32)) → (¬o9 = true → int'32_in_bounds (-BitVec.toInt rn)) ∧ (∀(rn1 : BitVec 32), (if ¬o9 = true then BitVec.toInt rn1 = -BitVec.toInt rn else rn1 = rn) → (Z.zones mpz1 r = C.zone1 rp1 ∧ Z.readers mpz1 r = -(1 : ℤ) ∧ C.offset rp1 = (0 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ abs (BitVec.toInt rn1) ≤ C.plength rp1 ∧ C.plength rp1 = Z.alloc mpz1 r ∧ (¬BitVec.toInt rn1 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt rn1) - (1 : ℤ))) ≤ Lemmas.value rp1 (abs (BitVec.toInt rn1)))) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz2 mpz1) ∧ (Z.sgn mpz2 r = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt rn1) ∧ (Z.sgn mpz2 r = -(1 : ℤ)) = (BitVec.toInt rn1 < (0 : ℤ)) ∧ Z.abs_size mpz2 r = abs (BitVec.toInt rn1) ∧ Z.abs_value_of mpz2 r = Lemmas.value rp1 (abs (BitVec.toInt rn1)) → (Z.zones mpz2 r = C.zone1 rp1 ∧ Z.readers mpz2 r = -(1 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ Z.abs_value_of mpz2 r = Lemmas.value rp1 (Z.abs_size mpz2 r)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 r = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = r → Z.readers mpz3 y = Z.readers mpz2 y) → (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz3 mpz) ∧ Z.readers mpz3 r = (0 : ℤ) ∧ Z.value_of r mpz3 = String_value.value_text (BitVec.toInt base) (C.pelts sp) (C.offset sp) ∧ (-(1 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ)) ∧ String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp)))))))))))))) else (0 : ℤ) ≤ BitVec.toInt base ∧ (∀(o5 : BitVec 64), BitVec.toUInt o5 = BitVec.toInt base → ((2 : ℤ) ≤ BitVec.toUInt o5 ∧ BitVec.toUInt o5 ≤ (256 : ℤ)) ∧ (∀(info : BaseInfo.wmpn_base_info), BaseInfo.b info = BitVec.toUInt o5 → (let o6 : BitVec 32 := BaseInfo.exp info; BitVec.toUInt o6 ≤ (2147483647 : ℤ) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toUInt o6 → (let o8 : BitVec 32 := BaseInfo.exp info; BitVec.toUInt o8 ≤ (2147483647 : ℤ) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toUInt o8 → int'32_in_bounds (BitVec.toInt dn + BitVec.toInt o9) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt dn + BitVec.toInt o9 → int'32_in_bounds (BitVec.toInt o10 - (1 : ℤ)) ∧ (∀(o11 : BitVec 32), BitVec.toInt o11 = BitVec.toInt o10 - (1 : ℤ) → (¬BitVec.toInt o7 = (0 : ℤ) ∧ int'32_in_bounds (Int.tdiv (BitVec.toInt o11) (BitVec.toInt o7))) ∧ (∀(alloc : BitVec 32), BitVec.toInt alloc = Int.tdiv (BitVec.toInt o11) (BitVec.toInt o7) → (Z.readers mpz r = (0 : ℤ) ∧ (1 : ℤ) ≤ Z.alloc mpz r) ∧ (∀(mpz1 : Z.mpz_memo), Z.sgn mpz1 = Z.sgn mpz → (∀(rp : C.ptr (BitVec 64)), (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz1 mpz) ∧ Z.readers mpz1 r = -(1 : ℤ) ∧ Z.abs_value_of mpz1 r = Lemmas.value rp (Z.abs_size mpz1 r) ∧ Z.zones mpz1 r = C.zone1 rp ∧ C.offset rp = (0 : ℤ) ∧ C.plength rp = Z.alloc mpz1 r ∧ C.min rp = (0 : ℤ) ∧ C.max rp = C.plength rp ∧ C.writable rp = true ∧ Z.abs_size mpz1 r = Z.abs_size mpz r ∧ Lemmas.value rp (Z.abs_size mpz r) = Z.abs_value_of mpz r ∧ (if Z.alloc mpz r < BitVec.toInt alloc then Z.alloc mpz1 r = BitVec.toInt alloc else Z.alloc mpz1 r = Z.alloc mpz r) → (0 : ℤ) ≤ BitVec.toInt base ∧ (∀(o12 : BitVec 64), BitVec.toUInt o12 = BitVec.toInt base → (0 : ℤ) ≤ BitVec.toInt dn ∧ (∀(o13 : BitVec 32), BitVec.toUInt o13 = BitVec.toInt dn → (((0 : ℤ) < BitVec.toUInt o13 ∧ BitVec.toUInt o13 ≤ (2147483647 : ℤ)) ∧ (0 : ℤ) < BitVec.toInt alloc ∧ C.valid rp (BitVec.toInt alloc) ∧ C.valid dp1 (BitVec.toUInt o13) ∧ ((2 : ℤ) ≤ BitVec.toUInt o12 ∧ BitVec.toUInt o12 ≤ (256 : ℤ)) ∧ HPow.hPow (BitVec.toUInt o12) (Int.toNat (BitVec.toUInt o13)) ≤ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt alloc)) ∧ C.writable rp = true ∧ String_lemmas.in_base (BitVec.toUInt o12) (C.pelts dp1) (C.offset dp1) (C.offset dp1 + BitVec.toUInt o13) ∧ BaseInfo.b info = BitVec.toUInt o12) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(rn : BitVec 32), ((0 : ℤ) < String_lemmas.svalue (BitVec.toUInt o12) dp1 (BitVec.toUInt o13) → (1 : ℤ) ≤ BitVec.toInt rn ∧ BitVec.toInt rn ≤ BitVec.toInt alloc) ∧ Lemmas.value rp1 (BitVec.toInt rn) = String_lemmas.svalue (BitVec.toUInt o12) dp1 (BitVec.toUInt o13) ∧ ((0 : ℤ) < String_lemmas.svalue (BitVec.toUInt o12) dp1 (BitVec.toUInt o13) → (0 : ℤ) < BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt rn - (1 : ℤ)))) ∧ (String_lemmas.svalue (BitVec.toUInt o12) dp1 (BitVec.toUInt o13) = (0 : ℤ) → BitVec.toInt rn = (1 : ℤ)) ∧ (0 : ℤ) < BitVec.toInt rn → int'32_in_bounds (BitVec.toInt rn - (1 : ℤ)) ∧ (∀(o14 : BitVec 32), BitVec.toInt o14 = BitVec.toInt rn - (1 : ℤ) → (C.min rp1 ≤ C.offset rp1 + BitVec.toInt o14 ∧ C.offset rp1 + BitVec.toInt o14 < C.max rp1) ∧ (let o15 : BitVec 64 := C.pelts rp1 (C.offset rp1 + BitVec.toInt o14); ∀(o16 : Bool), (BitVec.toUInt o15 = BitVec.toUInt (0 : BitVec 64) → o16 = true) ∧ (o16 = true → o15 = (0 : BitVec 64)) → (∀(o17 : BitVec 32), (if o16 = true then o17 = (1 : BitVec 32) else o17 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt rn - BitVec.toInt o17) ∧ (∀(rn1 : BitVec 32), BitVec.toInt rn1 = BitVec.toInt rn - BitVec.toInt o17 → (∀(o18 : Bool), (BitVec.toInt sign = BitVec.toInt (0 : BitVec 32) → o18 = true) ∧ (o18 = true → sign = (0 : BitVec 32)) → (¬o18 = true → int'32_in_bounds (-BitVec.toInt rn1)) ∧ (∀(rn2 : BitVec 32), (if ¬o18 = true then BitVec.toInt rn2 = -BitVec.toInt rn1 else rn2 = rn1) → (Z.zones mpz1 r = C.zone1 rp1 ∧ Z.readers mpz1 r = -(1 : ℤ) ∧ C.offset rp1 = (0 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ abs (BitVec.toInt rn2) ≤ C.plength rp1 ∧ C.plength rp1 = Z.alloc mpz1 r ∧ (¬BitVec.toInt rn2 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt rn2) - (1 : ℤ))) ≤ Lemmas.value rp1 (abs (BitVec.toInt rn2)))) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz2 mpz1) ∧ (Z.sgn mpz2 r = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt rn2) ∧ (Z.sgn mpz2 r = -(1 : ℤ)) = (BitVec.toInt rn2 < (0 : ℤ)) ∧ Z.abs_size mpz2 r = abs (BitVec.toInt rn2) ∧ Z.abs_value_of mpz2 r = Lemmas.value rp1 (abs (BitVec.toInt rn2)) → (Z.zones mpz2 r = C.zone1 rp1 ∧ Z.readers mpz2 r = -(1 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ Z.abs_value_of mpz2 r = Lemmas.value rp1 (Z.abs_size mpz2 r)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 r = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = r → Z.readers mpz3 y = Z.readers mpz2 y) → (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz3 mpz) ∧ Z.readers mpz3 r = (0 : ℤ) ∧ Z.value_of r mpz3 = String_value.value_text (BitVec.toInt base) (C.pelts sp) (C.offset sp) ∧ (-(1 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ)) ∧ String_value.string_in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp))))))))))))))))))))))))))))))))))))
  := sorry
end mpz_set_str_Zset_str_wmpz_set_strqtvc
