import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace min_max_Top_divide_and_conquerqtvc
noncomputable def is_min (m : ℤ) (a : List ℤ) (lo : ℤ) (hi : ℤ) := (∃(i : ℤ), (lo ≤ i ∧ i < hi ∧ hi ≤ Int.ofNat (List.length a)) ∧ a[Int.toNat i]! = m) ∧ (∀(i : ℤ), lo ≤ i ∧ i < hi → m ≤ a[Int.toNat i]!)
noncomputable def is_max (m : ℤ) (a : List ℤ) (lo : ℤ) (hi : ℤ) := (∃(i : ℤ), (lo ≤ i ∧ i < hi ∧ hi ≤ Int.ofNat (List.length a)) ∧ a[Int.toNat i]! = m) ∧ (∀(i : ℤ), lo ≤ i ∧ i < hi → a[Int.toNat i]! ≤ m)
theorem divide_and_conquer'vc (lo : ℤ) (hi : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ lo) (fact1 : lo < hi) (fact2 : hi ≤ Int.ofNat (List.length a)) : let o1 : ℤ := hi - lo; (if o1 = (1 : ℤ) then (0 : ℤ) ≤ lo ∧ lo < Int.ofNat (List.length a) else if hi - lo = (2 : ℤ) then let o2 : ℤ := lo + (1 : ℤ); ((0 : ℤ) ≤ o2 ∧ o2 < Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ lo ∧ lo < Int.ofNat (List.length a)) ∧ (if a[Int.toNat lo]! < a[Int.toNat o2]! then let o3 : ℤ := lo + (1 : ℤ); ((0 : ℤ) ≤ o3 ∧ o3 < Int.ofNat (List.length a)) ∧ (0 : ℤ) ≤ lo ∧ lo < Int.ofNat (List.length a) else ((0 : ℤ) ≤ lo ∧ lo < Int.ofNat (List.length a)) ∧ (let o3 : ℤ := lo + (1 : ℤ); (0 : ℤ) ≤ o3 ∧ o3 < Int.ofNat (List.length a))) else ¬(2 : ℤ) = (0 : ℤ) ∧ (let mid : ℤ := lo + Int.tdiv (hi - lo) (2 : ℤ); (((0 : ℤ) ≤ hi - lo ∧ mid - lo < hi - lo) ∧ (0 : ℤ) ≤ lo ∧ lo < mid ∧ mid ≤ Int.ofNat (List.length a)) ∧ (∀(x1 : ℤ) (y1 : ℤ), is_min x1 a lo mid ∧ is_max y1 a lo mid → ((0 : ℤ) ≤ hi - lo ∧ hi - mid < hi - lo) ∧ (0 : ℤ) ≤ mid ∧ mid < hi ∧ hi ≤ Int.ofNat (List.length a)))) ∧ (∀(x : ℤ) (y : ℤ), (if o1 = (1 : ℤ) then x = a[Int.toNat lo]! ∧ y = a[Int.toNat lo]! else if hi - lo = (2 : ℤ) then if a[Int.toNat lo]! < a[Int.toNat (lo + (1 : ℤ))]! then x = a[Int.toNat lo]! ∧ y = a[Int.toNat (lo + (1 : ℤ))]! else x = a[Int.toNat (lo + (1 : ℤ))]! ∧ y = a[Int.toNat lo]! else let mid : ℤ := lo + Int.tdiv (hi - lo) (2 : ℤ); ∃(x1 : ℤ) (y1 : ℤ), (is_min x1 a lo mid ∧ is_max y1 a lo mid) ∧ (∃(x2 : ℤ) (y2 : ℤ), (is_min x2 a mid hi ∧ is_max y2 a mid hi) ∧ (if y2 < y1 then y = y1 else y = y2) ∧ (if x1 < x2 then x = x1 else x = x2))) → is_min x a lo hi ∧ is_max y a lo hi)
  := sorry
end min_max_Top_divide_and_conquerqtvc
