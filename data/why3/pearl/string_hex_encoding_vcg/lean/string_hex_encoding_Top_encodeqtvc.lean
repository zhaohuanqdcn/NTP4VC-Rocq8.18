import Why3.Base
import Why3.why3.Ref.Ref
import Why3.string.StringBuffer
open Classical
open Lean4Why3
namespace string_hex_encoding_Top_encodeqtvc
noncomputable def valid_hex_char (c : BitVec 8) := (48 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c < (58 : ℤ) ∨ (65 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c < (71 : ℤ)
noncomputable def hex (i : ℤ) := if (0 : ℤ) ≤ i ∧ i < (10 : ℤ) then BitVec.ofNat 8 (Int.toNat (i + (48 : ℤ))) else if (10 : ℤ) ≤ i ∧ i < (16 : ℤ) then BitVec.ofNat 8 (Int.toNat (i + (55 : ℤ))) else ([0] : List (BitVec 8))[(0 : ℕ)]!
noncomputable def xeh (c : BitVec 8) := if (48 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c < (58 : ℤ) then BitVec.toInt c - (48 : ℤ) else if (65 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c < (71 : ℤ) then BitVec.toInt c - (55 : ℤ) else -(1 : ℤ)
noncomputable def valid_hex (s : List (BitVec 8)) := Int.tmod (Int.ofNat (List.length s)) (2 : ℤ) = (0 : ℤ) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s) → valid_hex_char (s[Int.toNat i]!))
noncomputable def encoding (s1 : List (BitVec 8)) (s2 : List (BitVec 8)) := Int.ofNat (List.length s2) = (2 : ℤ) * Int.ofNat (List.length s1) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s1) → s1[Int.toNat i]! = BitVec.ofNat 8 (Int.toNat (xeh (s2[Int.toNat ((2 : ℤ) * i)]!) * (16 : ℤ) + xeh (s2[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]!)))) ∧ valid_hex s2
theorem encode'vc (o1 : BitVec 63) (s : List (BitVec 8)) (r : StringBuffer.buffer) (fact0 : BitVec.toInt o1 = Int.ofNat (List.length s)) (fact1 : (0 : ℤ) ≤ Int.ofNat (List.length s)) (fact2 : StringBuffer.str r = ([] : List (BitVec 8))) : (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length s) ∧ Int.ofNat (List.length (StringBuffer.str r)) = (2 : ℤ) * (0 : ℤ) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → (StringBuffer.str r)[Int.toNat ((2 : ℤ) * j)]! = hex (Int.tdiv (BitVec.toInt (s[Int.toNat j]!)) (16 : ℤ)) ∧ (StringBuffer.str r)[Int.toNat ((2 : ℤ) * j + (1 : ℤ))]! = hex (Int.tmod (BitVec.toInt (s[Int.toNat j]!)) (16 : ℤ))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (2 : ℤ) * (0 : ℤ) → valid_hex_char ((StringBuffer.str r)[Int.toNat j]!)) ∧ (∀(r1 : StringBuffer.buffer) (i : BitVec 63), ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ Int.ofNat (List.length s)) ∧ Int.ofNat (List.length (StringBuffer.str r1)) = (2 : ℤ) * BitVec.toInt i ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toInt i → (StringBuffer.str r1)[Int.toNat ((2 : ℤ) * j)]! = hex (Int.tdiv (BitVec.toInt (s[Int.toNat j]!)) (16 : ℤ)) ∧ (StringBuffer.str r1)[Int.toNat ((2 : ℤ) * j + (1 : ℤ))]! = hex (Int.tmod (BitVec.toInt (s[Int.toNat j]!)) (16 : ℤ))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (2 : ℤ) * BitVec.toInt i → valid_hex_char ((StringBuffer.str r1)[Int.toNat j]!)) → (∀(o2 : BitVec 63), BitVec.toInt o2 = Int.ofNat (List.length s) ∧ (0 : ℤ) ≤ Int.ofNat (List.length s) → (if BitVec.toInt i < BitVec.toInt o2 then ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i < Int.ofNat (List.length s)) ∧ (∀(v : BitVec 63), BitVec.toInt v = BitVec.toInt (s[Int.toNat (BitVec.toInt i)]!) → (¬(16 : ℤ) = (0 : ℤ) ∧ int'63_in_bounds (Int.tdiv (BitVec.toInt v) (16 : ℤ))) ∧ (∀(o3 : BitVec 63), BitVec.toInt o3 = Int.tdiv (BitVec.toInt v) (16 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 < (16 : ℤ)) ∧ (∀(r2 : StringBuffer.buffer), StringBuffer.str r2 = StringBuffer.str r1 ++ [hex (BitVec.toInt o3)] → (¬(16 : ℤ) = (0 : ℤ) ∧ int'63_in_bounds (Int.tmod (BitVec.toInt v) (16 : ℤ))) ∧ (∀(o4 : BitVec 63), BitVec.toInt o4 = Int.tmod (BitVec.toInt v) (16 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 < (16 : ℤ)) ∧ (∀(r3 : StringBuffer.buffer), StringBuffer.str r3 = StringBuffer.str r2 ++ [hex (BitVec.toInt o4)] → int'63_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o5 : BitVec 63), BitVec.toInt o5 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ Int.ofNat (List.length s) - BitVec.toInt i ∧ Int.ofNat (List.length s) - BitVec.toInt o5 < Int.ofNat (List.length s) - BitVec.toInt i) ∧ ((0 : ℤ) ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 ≤ Int.ofNat (List.length s)) ∧ Int.ofNat (List.length (StringBuffer.str r3)) = (2 : ℤ) * BitVec.toInt o5 ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toInt o5 → (StringBuffer.str r3)[Int.toNat ((2 : ℤ) * j)]! = hex (Int.tdiv (BitVec.toInt (s[Int.toNat j]!)) (16 : ℤ)) ∧ (StringBuffer.str r3)[Int.toNat ((2 : ℤ) * j + (1 : ℤ))]! = hex (Int.tmod (BitVec.toInt (s[Int.toNat j]!)) (16 : ℤ))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (2 : ℤ) * BitVec.toInt o5 → valid_hex_char ((StringBuffer.str r3)[Int.toNat j]!)))))))) else encoding s (StringBuffer.str r1))))
  := sorry
end string_hex_encoding_Top_encodeqtvc
