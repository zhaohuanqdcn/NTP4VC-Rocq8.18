theory tree_height_HeightSmallSpace_height_limitedqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.bintree_Tree" "Why3STD.bintree_Size" "Why3STD.bintree_Height"
begin
definition leaves :: "'a tree \<Rightarrow> int"
  where "leaves t = (1 :: int) + bintree_Size.size t" for t
theorem height_limited'vc:
  fixes lim :: "int"
  fixes acc :: "int"
  fixes t :: "'a tree"
  fixes s :: "(int \<times> int \<times> 'a tree) option"
  fixes depth :: "int"
  assumes fact0: "(0 :: int) < lim"
  assumes fact1: "(0 :: int) \<le> acc"
  shows "case t of (Empty :: 'a tree) \<Rightarrow> True | Node l _ r \<Rightarrow> (\<forall>(limc :: int). (0 :: int) \<le> limc \<and> limc < lim \<longrightarrow> (\<not>limc = (0 :: int) \<longrightarrow> \<not>(2 :: int) = (0 :: int) \<and> (let o1 :: int = limc cdiv (2 :: int) in (((0 :: int) \<le> limc \<and> o1 < limc) \<and> (0 :: int) \<le> o1 \<and> o1 < lim) \<and> (\<forall>(o2 :: (int \<times> int \<times> 'a tree) option). (case o2 of (None :: (int \<times> int \<times> 'a tree) option) \<Rightarrow> o1 < leaves l \<and> o1 < leaves r | Some (h, sz, rm) \<Rightarrow> height t = (1 :: int) + max h (height rm) \<and> leaves t = leaves rm + sz \<and> (0 :: int) < sz \<and> sz \<le> o1) \<longrightarrow> (case o2 of Some x \<Rightarrow> (let s = Some x in True) | (None :: (int \<times> int \<times> 'a tree) option) \<Rightarrow> (((0 :: int) \<le> lim \<and> limc < lim) \<and> (0 :: int) < limc \<and> (0 :: int) \<le> (0 :: int)) \<and> (\<forall>(o3 :: (int \<times> int) option). (case o3 of None \<Rightarrow> limc < leaves l | Some (res, dl) \<Rightarrow> res = max (0 :: int) ((0 :: int) + height l) \<and> limc = leaves l + dl \<and> (0 :: int) \<le> dl) \<longrightarrow> (case o3 of Some (h, dl) \<Rightarrow> True | None \<Rightarrow> (((0 :: int) \<le> lim \<and> limc < lim) \<and> (0 :: int) < limc \<and> (0 :: int) \<le> (0 :: int)) \<and> (\<forall>(o4 :: (int \<times> int) option). (case o4 of None \<Rightarrow> limc < leaves r | Some (res, dl) \<Rightarrow> res = max (0 :: int) ((0 :: int) + height r) \<and> limc = leaves r + dl \<and> (0 :: int) \<le> dl) \<longrightarrow> (case o4 of Some (h, dl) \<Rightarrow> True | None \<Rightarrow> True)))))))) \<and> (\<forall>(result :: (int \<times> int \<times> 'a tree) option). (if limc = (0 :: int) then result = (None :: (int \<times> int \<times> 'a tree) option) else let o1 :: int = limc cdiv (2 :: int) in \<exists>(o2 :: (int \<times> int \<times> 'a tree) option). (case o2 of (None :: (int \<times> int \<times> 'a tree) option) \<Rightarrow> o1 < leaves l \<and> o1 < leaves r | Some (h, sz, rm) \<Rightarrow> height t = (1 :: int) + max h (height rm) \<and> leaves t = leaves rm + sz \<and> (0 :: int) < sz \<and> sz \<le> o1) \<and> (case o2 of Some x \<Rightarrow> (let s = Some x in result = s) | (None :: (int \<times> int \<times> 'a tree) option) \<Rightarrow> (\<exists>(o3 :: (int \<times> int) option). (case o3 of None \<Rightarrow> limc < leaves l | Some (res, dl) \<Rightarrow> res = max (0 :: int) ((0 :: int) + height l) \<and> limc = leaves l + dl \<and> (0 :: int) \<le> dl) \<and> (case o3 of Some (h, dl) \<Rightarrow> result = Some (h, limc - dl, r) | None \<Rightarrow> (\<exists>(o4 :: (int \<times> int) option). (case o4 of None \<Rightarrow> limc < leaves r | Some (res, dl) \<Rightarrow> res = max (0 :: int) ((0 :: int) + height r) \<and> limc = leaves r + dl \<and> (0 :: int) \<le> dl) \<and> (case o4 of Some (h, dl) \<Rightarrow> result = Some (h, limc - dl, l) | None \<Rightarrow> result = (None :: (int \<times> int \<times> 'a tree) option))))))) \<longrightarrow> (case result of (None :: (int \<times> int \<times> 'a tree) option) \<Rightarrow> limc < leaves l \<and> limc < leaves r | Some (h, sz, rm) \<Rightarrow> height t = (1 :: int) + max h (height rm) \<and> leaves t = leaves rm + sz \<and> (0 :: int) < sz \<and> sz \<le> limc))) \<and> \<not>(2 :: int) = (0 :: int) \<and> (let limc :: int = lim cdiv (2 :: int) in ((0 :: int) \<le> limc \<and> limc < lim) \<and> (\<forall>(o1 :: (int \<times> int \<times> 'a tree) option). (case o1 of (None :: (int \<times> int \<times> 'a tree) option) \<Rightarrow> limc < leaves l \<and> limc < leaves r | Some (h, sz, rm) \<Rightarrow> height t = (1 :: int) + max h (height rm) \<and> leaves t = leaves rm + sz \<and> (0 :: int) < sz \<and> sz \<le> limc) \<longrightarrow> (case o1 of (None :: (int \<times> int \<times> 'a tree) option) \<Rightarrow> True | Some (h, sz, rm) \<Rightarrow> (let o2 :: int = lim - sz in ((0 :: int) \<le> lim \<and> o2 < lim) \<and> (0 :: int) < o2 \<and> (0 :: int) \<le> max acc (depth + h + (1 :: int))))))"
  and "\<forall>(result :: (int \<times> int) option). (case t of (Empty :: 'a tree) \<Rightarrow> result = Some (max acc depth, lim - (1 :: int)) | Node l _ r \<Rightarrow> (let limc :: int = lim cdiv (2 :: int) in \<exists>(o1 :: (int \<times> int \<times> 'a tree) option). (case o1 of (None :: (int \<times> int \<times> 'a tree) option) \<Rightarrow> limc < leaves l \<and> limc < leaves r | Some (h, sz, rm) \<Rightarrow> height t = (1 :: int) + max h (height rm) \<and> leaves t = leaves rm + sz \<and> (0 :: int) < sz \<and> sz \<le> limc) \<and> (case o1 of (None :: (int \<times> int \<times> 'a tree) option) \<Rightarrow> result = None | Some (h, sz, rm) \<Rightarrow> (let o2 :: int = lim - sz in (case result of None \<Rightarrow> o2 < leaves rm | Some (res, dl) \<Rightarrow> res = max (max acc (depth + h + (1 :: int))) (depth + (1 :: int) + height rm) \<and> o2 = leaves rm + dl \<and> (0 :: int) \<le> dl))))) \<longrightarrow> (case result of None \<Rightarrow> lim < leaves t | Some (res, dl) \<Rightarrow> res = max acc (depth + height t) \<and> lim = leaves t + dl \<and> (0 :: int) \<le> dl)"
  sorry
end
