theory vacid_0_build_maze_BuildMaze_build_mazeqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "./vacid_0_build_maze_UnionFind_pure" "./vacid_0_build_maze_UnionFind_sig" "./vacid_0_build_maze_Graph_sig"
begin
theorem build_maze'vc:
  fixes n :: "int"
  fixes graph :: "graph"
  assumes fact0: "(1 :: int) \<le> n"
  assumes fact1: "\<forall>(x :: int) (y :: int). x = y \<longleftrightarrow> path graph x y"
  shows "let o1 :: int = n * n in (0 :: int) \<le> o1 \<and> (\<forall>(u :: uf). num (state u) = o1 \<and> vacid_0_build_maze_UnionFind_pure.size (state u) = o1 \<and> (\<forall>(x :: int). (0 :: int) \<le> x \<and> x < o1 \<longrightarrow> repr (state u) x x) \<longrightarrow> ((1 :: int) \<le> num (state u) \<and> (num (state u) + (0 :: int) = vacid_0_build_maze_UnionFind_pure.size (state u) \<and> vacid_0_build_maze_UnionFind_pure.size (state u) = n * n) \<and> (\<forall>(x :: int) (y :: int). (0 :: int) \<le> x \<and> x < n * n \<longrightarrow> (0 :: int) \<le> y \<and> y < n * n \<longrightarrow> same (state u) x y \<longleftrightarrow> path graph x y)) \<and> (\<forall>(u1 :: uf) (num_edges :: int) (graph1 :: graph). (1 :: int) \<le> num (state u1) \<and> (num (state u1) + num_edges = vacid_0_build_maze_UnionFind_pure.size (state u1) \<and> vacid_0_build_maze_UnionFind_pure.size (state u1) = n * n) \<and> (\<forall>(x :: int) (y :: int). (0 :: int) \<le> x \<and> x < n * n \<longrightarrow> (0 :: int) \<le> y \<and> y < n * n \<longrightarrow> same (state u1) x y \<longleftrightarrow> path graph1 x y) \<longrightarrow> (if (1 :: int) < num (state u1) then (0 :: int) < n \<and> (\<forall>(x :: int). (0 :: int) \<le> x \<and> x < n \<longrightarrow> (0 :: int) < n \<and> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < n \<longrightarrow> (0 :: int) < (2 :: int) \<and> (\<forall>(d :: int). (0 :: int) \<le> d \<and> d < (2 :: int) \<longrightarrow> (\<forall>(w :: int). (if d = (0 :: int) then w = x + (1 :: int) else w = x) \<longrightarrow> (\<forall>(z :: int). (if d = (0 :: int) then z = y else z = y + (1 :: int)) \<longrightarrow> (\<forall>(o2 :: bool). (if w < n then o2 = (if z < n then True else False) else o2 = False) \<longrightarrow> (if o2 = True then let a :: int = y * n + x; b :: int = w * n + z in ((0 :: int) \<le> b \<and> b < vacid_0_build_maze_UnionFind_pure.size (state u1)) \<and> (\<forall>(u2 :: uf) (o3 :: int). repr (state u2) b o3 \<and> vacid_0_build_maze_UnionFind_pure.size (state u2) = vacid_0_build_maze_UnionFind_pure.size (state u1) \<and> num (state u2) = num (state u1) \<and> same_reprs (state u2) (state u1) \<longrightarrow> ((0 :: int) \<le> a \<and> a < vacid_0_build_maze_UnionFind_pure.size (state u2)) \<and> (\<forall>(u3 :: uf) (o4 :: int). repr (state u3) a o4 \<and> vacid_0_build_maze_UnionFind_pure.size (state u3) = vacid_0_build_maze_UnionFind_pure.size (state u2) \<and> num (state u3) = num (state u2) \<and> same_reprs (state u3) (state u2) \<longrightarrow> (if \<not>o4 = o3 then (((0 :: int) \<le> a \<and> a < vacid_0_build_maze_UnionFind_pure.size (state u3)) \<and> ((0 :: int) \<le> b \<and> b < vacid_0_build_maze_UnionFind_pure.size (state u3)) \<and> \<not>same (state u3) a b \<and> \<not>path graph1 a b \<and> (\<forall>(x1 :: int) (y1 :: int). (0 :: int) \<le> x1 \<and> x1 < vacid_0_build_maze_UnionFind_pure.size (state u3) \<longrightarrow> (0 :: int) \<le> y1 \<and> y1 < vacid_0_build_maze_UnionFind_pure.size (state u3) \<longrightarrow> same (state u3) x1 y1 \<longleftrightarrow> path graph1 x1 y1)) \<and> (\<forall>(u4 :: uf) (graph2 :: graph). same (state u4) a b \<and> vacid_0_build_maze_UnionFind_pure.size (state u4) = vacid_0_build_maze_UnionFind_pure.size (state u3) \<and> num (state u4) = num (state u3) - (1 :: int) \<and> (\<forall>(x1 :: int) (y1 :: int). (0 :: int) \<le> x1 \<and> x1 < vacid_0_build_maze_UnionFind_pure.size (state u4) \<longrightarrow> (0 :: int) \<le> y1 \<and> y1 < vacid_0_build_maze_UnionFind_pure.size (state u4) \<longrightarrow> same (state u4) x1 y1 \<longleftrightarrow> path graph2 x1 y1) \<longrightarrow> (1 :: int) \<le> num (state u4) \<and> (num (state u4) + (num_edges + (1 :: int)) = vacid_0_build_maze_UnionFind_pure.size (state u4) \<and> vacid_0_build_maze_UnionFind_pure.size (state u4) = n * n) \<and> (\<forall>(x1 :: int) (y1 :: int). (0 :: int) \<le> x1 \<and> x1 < n * n \<longrightarrow> (0 :: int) \<le> y1 \<and> y1 < n * n \<longrightarrow> same (state u4) x1 y1 \<longleftrightarrow> path graph2 x1 y1)) else (1 :: int) \<le> num (state u3) \<and> (num (state u3) + num_edges = vacid_0_build_maze_UnionFind_pure.size (state u3) \<and> vacid_0_build_maze_UnionFind_pure.size (state u3) = n * n) \<and> (\<forall>(x1 :: int) (y1 :: int). (0 :: int) \<le> x1 \<and> x1 < n * n \<longrightarrow> (0 :: int) \<le> y1 \<and> y1 < n * n \<longrightarrow> same (state u3) x1 y1 \<longleftrightarrow> path graph1 x1 y1)))) else (1 :: int) \<le> num (state u1) \<and> (num (state u1) + num_edges = vacid_0_build_maze_UnionFind_pure.size (state u1) \<and> vacid_0_build_maze_UnionFind_pure.size (state u1) = n * n) \<and> (\<forall>(x1 :: int) (y1 :: int). (0 :: int) \<le> x1 \<and> x1 < n * n \<longrightarrow> (0 :: int) \<le> y1 \<and> y1 < n * n \<longrightarrow> same (state u1) x1 y1 \<longleftrightarrow> path graph1 x1 y1)))))))) else num_edges = n * n - (1 :: int) \<and> (\<forall>(x :: int) (y :: int). (0 :: int) \<le> x \<and> x < n * n \<longrightarrow> (0 :: int) \<le> y \<and> y < n * n \<longrightarrow> path graph1 x y))))"
  sorry
end
