(* ---------------------------------------------------------- *)
(* --- Post-condition (file lemma_functions_index_of.c, line 41) in 'index_of_up_unexisting_item' --- *)
(* ---------------------------------------------------------- *)
theory VCindex_of_up_unexisting_item_post
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import A_Index_of_item.A_Index_of_item
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Post-condition (file lemma_functions_index_of.c, line 41) in 'index_of_up_unexisting_item'":
*)
goal goal0:
  forall i_3 i_2 i_1 i : int.
  forall t : map addr addr.
  forall a : addr.
  let a_1 = t[(shift_ptr a i_1)] in
  (((l_index_of t a_1 a i_3 i)) = i) ->
  (i_2 <= i) ->
  (i_3 <= i) ->
  (i_1 < i) ->
  (i_3 <= i_1) ->
  (i <= i_2) ->
  (i_3 <= i_2) ->
  (0 <= i_3) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  (forall i_4 : int. (i_4 < i_2) -> (i_3 <= i_4) ->
   (a_1 <> t[(shift_ptr a i_4)])) ->
  (forall i_4 : int. (i_4 < i_2) -> (i_3 <= i_4) ->
   (((l_index_of t a_1 a i_2 i)) = i)) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file lemma_functions_index_of.c, line 47) (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCindex_of_up_unexisting_item_loop_inv_preserved_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import A_Index_of_item.A_Index_of_item
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Preservation of Invariant (file lemma_functions_index_of.c, line 47) (1/2)":
*)
goal goal1:
  forall i_2 i_1 i : int.
  forall t : map addr addr.
  forall a_1 a : addr.
  let x = 1 + i_1 in
  (((l_index_of t a a_1 i_2 i)) = i) ->
  (i_1 <= i) ->
  (i_2 <= i) ->
  (i_1 < i) ->
  (i_2 <= i_1) ->
  (0 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 x)) ->
  (forall i_3 : int. (i_3 < i_1) -> (i_2 <= i_3) ->
   (t[(shift_ptr a_1 i_3)] <> a)) ->
  (forall i_3 : int. (i_3 < i_1) -> (i_2 <= i_3) ->
   (((l_index_of t a a_1 i_1 i)) = i)) ->
  (i_2 <= x)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file lemma_functions_index_of.c, line 48) --- *)
(* ---------------------------------------------------------- *)
theory VCindex_of_up_unexisting_item_loop_inv_2_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import A_Index_of_item.A_Index_of_item
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file lemma_functions_index_of.c, line 48)":
*)
goal goal2:
  forall i_3 i_2 i_1 i : int.
  forall t : map addr addr.
  forall a : addr.
  let a_1 = t[(shift_ptr a i_2)] in
  (((l_index_of t a_1 a i_3 i)) = i) ->
  (i_1 <= i) ->
  (i_3 <= i) ->
  (i_1 < i) ->
  (i_2 <= i_1) ->
  (i_3 <= i_1) ->
  (i_3 <= i_2) ->
  (0 <= i_3) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((is_sint32 (1 + i_1))) ->
  (forall i_4 : int. (i_4 < i_1) -> (i_3 <= i_4) ->
   (a_1 <> t[(shift_ptr a i_4)])) ->
  (forall i_4 : int. (i_4 < i_1) -> (i_3 <= i_4) ->
   (((l_index_of t a_1 a i_1 i)) = i)) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file lemma_functions_index_of.c, line 49) --- *)
(* ---------------------------------------------------------- *)
theory VCindex_of_up_unexisting_item_loop_inv_3_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import A_Index_of_item.A_Index_of_item
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Preservation of Invariant (file lemma_functions_index_of.c, line 49)":
*)
goal goal3:
  forall i_3 i_2 i_1 i : int.
  forall t : map addr addr.
  forall a_1 a : addr.
  let x = 1 + i_1 in
  (((l_index_of t a a_1 i_3 i)) = i) ->
  (i_1 <= i) ->
  (i_3 <= i) ->
  (i_1 < i) ->
  (i_2 <= i_1) ->
  (i_3 <= i_1) ->
  (i_3 <= i_2) ->
  (0 <= i_3) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  ((is_sint32 i_3)) ->
  ((is_sint32 x)) ->
  (forall i_4 : int. (i_4 < i_1) -> (i_3 <= i_4) ->
   (t[(shift_ptr a_1 i_4)] <> a)) ->
  (forall i_4 : int. (i_4 < i_1) -> (i_3 <= i_4) ->
   (((l_index_of t a a_1 i_1 i)) = i)) ->
  (((l_index_of t a a_1 x i)) = i)

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,signed_overflow' (file lemma_functions_index_of.c, line 55) --- *)
(* ---------------------------------------------------------- *)
theory VCindex_of_up_unexisting_item_assert_rte_signed_overflow
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import A_Index_of_item.A_Index_of_item
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Assertion 'rte,signed_overflow' (file lemma_functions_index_of.c, line 55)":
*)
goal goal4:
  forall i_2 i_1 i : int.
  forall t : map addr addr.
  forall a_1 a : addr.
  (((l_index_of t a a_1 i_2 i)) = i) ->
  (i_1 <= i) ->
  (i_2 <= i) ->
  (i_1 < i) ->
  (i_2 <= i_1) ->
  (0 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((is_sint32 i_2)) ->
  (forall i_3 : int. (i_3 < i_1) -> (i_2 <= i_3) ->
   (t[(shift_ptr a_1 i_3)] <> a)) ->
  (forall i_3 : int. (i_3 < i_1) -> (i_2 <= i_3) ->
   (((l_index_of t a a_1 i_1 i)) = i)) ->
  (i_1 <= 2147483646)

end

