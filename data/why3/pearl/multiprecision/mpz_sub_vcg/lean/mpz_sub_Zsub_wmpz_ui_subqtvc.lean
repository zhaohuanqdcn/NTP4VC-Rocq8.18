import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.sub.Sub
import pearl.multiprecision.lib.lean.mpz.Z
import pearl.multiprecision.lib.lean.mpz.Zutil
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.sub_1.Sub_1
open Classical
open Lean4Why3
namespace mpz_sub_Zsub_wmpz_ui_subqtvc
theorem wmpz_ui_sub'vc (mpz : Z.mpz_memo) (w : Z.mpz_ptr) (v : Z.mpz_ptr) (uval : BitVec 64) (fact0 : (1 : ℤ) ≤ Z.alloc mpz w) (fact1 : (1 : ℤ) ≤ Z.alloc mpz v) (fact2 : Z.readers mpz w = (0 : ℤ)) (fact3 : Z.readers mpz v = (0 : ℤ)) (fact4 : Z.abs_size mpz v < (2147483647 : ℤ)) : -(2 : ℤ) < Z.readers mpz v ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = Z.sgn mpz v * Z.abs_size mpz v → Z.mpz_eq v w = (v = w) → (if (1 : ℤ) < BitVec.toInt o1 then (Z.readers mpz w = (0 : ℤ) ∧ (1 : ℤ) ≤ Z.alloc mpz w) ∧ (∀(mpz1 : Z.mpz_memo), Z.sgn mpz1 = Z.sgn mpz → (∀(wp : C.ptr (BitVec 64)), (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz1 mpz) ∧ Z.readers mpz1 w = -(1 : ℤ) ∧ Z.abs_value_of mpz1 w = Lemmas.value wp (Z.abs_size mpz1 w) ∧ Z.zones mpz1 w = C.zone1 wp ∧ C.offset wp = (0 : ℤ) ∧ C.plength wp = Z.alloc mpz1 w ∧ C.min wp = (0 : ℤ) ∧ C.max wp = C.plength wp ∧ C.writable wp = true ∧ Z.abs_size mpz1 w = Z.abs_size mpz w ∧ Lemmas.value wp (Z.abs_size mpz w) = Z.abs_value_of mpz w ∧ (if Z.alloc mpz w < BitVec.toInt o1 then Z.alloc mpz1 w = BitVec.toInt o1 else Z.alloc mpz1 w = Z.alloc mpz w) → (if Z.mpz_eq v w then (C.valid wp (BitVec.toInt o1) ∧ (0 : ℤ) < BitVec.toInt o1 ∧ C.writable wp = true) ∧ (∀(wp1 : C.ptr (BitVec 64)), List.length (C.data wp1) = List.length (C.data wp) ∧ C.offset wp1 = C.offset wp ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(x_b : BitVec 64), Lemmas.value wp1 (BitVec.toInt o1) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o1)) * BitVec.toUInt x_b = Lemmas.value wp (BitVec.toInt o1) - BitVec.toUInt uval ∧ ((0 : ℤ) ≤ BitVec.toUInt x_b ∧ BitVec.toUInt x_b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt o1 ≤ j → C.pelts wp1 j = C.pelts wp j) → int'32_in_bounds (BitVec.toInt o1 - (1 : ℤ)) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toInt o1 - (1 : ℤ) → (C.min wp1 ≤ C.offset wp1 + BitVec.toInt o2 ∧ C.offset wp1 + BitVec.toInt o2 < C.max wp1) ∧ (let o3 : BitVec 64 := C.pelts wp1 (C.offset wp1 + BitVec.toInt o2); ∀(o4 : Bool), (BitVec.toUInt o3 = BitVec.toUInt (0 : BitVec 64) → o4 = true) ∧ (o4 = true → o3 = (0 : BitVec 64)) → (∀(o5 : BitVec 32), (if o4 = true then o5 = (1 : BitVec 32) else o5 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt o1 - BitVec.toInt o5) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt o1 - BitVec.toInt o5 → int'32_in_bounds (-BitVec.toInt o6) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = -BitVec.toInt o6 → (Z.zones mpz1 w = C.zone1 wp1 ∧ Z.readers mpz1 w = -(1 : ℤ) ∧ C.offset wp1 = (0 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ abs (BitVec.toInt o7) ≤ C.plength wp1 ∧ C.plength wp1 = Z.alloc mpz1 w ∧ (¬BitVec.toInt o7 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o7) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt o7)))) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz2 mpz1) ∧ (Z.sgn mpz2 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o7) ∧ (Z.sgn mpz2 w = -(1 : ℤ)) = (BitVec.toInt o7 < (0 : ℤ)) ∧ Z.abs_size mpz2 w = abs (BitVec.toInt o7) ∧ Z.abs_value_of mpz2 w = Lemmas.value wp1 (abs (BitVec.toInt o7)) → (Z.zones mpz2 w = C.zone1 wp1 ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ Z.abs_value_of mpz2 w = Lemmas.value wp1 (Z.abs_size mpz2 w)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz3 y = Z.readers mpz2 y) → Z.value_of w mpz3 = BitVec.toUInt uval - Z.value_of v mpz ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ Z.readers mpz3 w = (0 : ℤ) ∧ Z.readers mpz3 v = (0 : ℤ)))))))))) else Z.mpz_unchanged v mpz1 mpz ∧ (Z.readers mpz1 v = Z.readers mpz v ∧ (-(2 : ℤ) < Z.readers mpz1 v → Z.abs_value_of mpz1 v = Z.abs_value_of mpz v ∧ Z.alloc mpz1 v = Z.alloc mpz v ∧ Z.abs_size mpz1 v = Z.abs_size mpz v ∧ Z.sgn mpz1 v = Z.sgn mpz v ∧ Z.readers mpz1 v = Z.readers mpz v ∧ Z.zones mpz1 v = Z.zones mpz v) → (0 : ℤ) ≤ Z.readers mpz1 v ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(vp : C.ptr (BitVec 64)), Z.readers mpz2 v = Z.readers mpz1 v + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬v = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value vp (Z.abs_size mpz2 v) = Z.abs_value_of mpz2 v ∧ C.plength vp = Z.alloc mpz2 v ∧ C.offset vp = (0 : ℤ) ∧ C.min vp = (0 : ℤ) ∧ C.max vp = C.plength vp ∧ C.zone1 vp = Z.zones mpz2 v → (C.valid vp (BitVec.toInt o1) ∧ C.valid wp (BitVec.toInt o1) ∧ (0 : ℤ) < BitVec.toInt o1 ∧ C.writable wp = true) ∧ (∀(wp1 : C.ptr (BitVec 64)), List.length (C.data wp1) = List.length (C.data wp) ∧ C.offset wp1 = C.offset wp ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(x_b : BitVec 64), Lemmas.value wp1 (BitVec.toInt o1) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o1)) * BitVec.toUInt x_b = Lemmas.value vp (BitVec.toInt o1) - BitVec.toUInt uval ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt o1 ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (0 : ℤ) ≤ BitVec.toUInt x_b ∧ BitVec.toUInt x_b ≤ (1 : ℤ) → (Z.zones mpz2 v = C.zone1 vp ∧ (1 : ℤ) ≤ Z.readers mpz2 v ∧ C.min vp = (0 : ℤ) ∧ C.max vp = C.plength vp) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 v = Z.readers mpz2 v - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v → Z.readers mpz3 y = Z.readers mpz2 y) → int'32_in_bounds (BitVec.toInt o1 - (1 : ℤ)) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toInt o1 - (1 : ℤ) → (C.min wp1 ≤ C.offset wp1 + BitVec.toInt o2 ∧ C.offset wp1 + BitVec.toInt o2 < C.max wp1) ∧ (let o3 : BitVec 64 := C.pelts wp1 (C.offset wp1 + BitVec.toInt o2); ∀(o4 : Bool), (BitVec.toUInt o3 = BitVec.toUInt (0 : BitVec 64) → o4 = true) ∧ (o4 = true → o3 = (0 : BitVec 64)) → (∀(o5 : BitVec 32), (if o4 = true then o5 = (1 : BitVec 32) else o5 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt o1 - BitVec.toInt o5) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt o1 - BitVec.toInt o5 → int'32_in_bounds (-BitVec.toInt o6) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = -BitVec.toInt o6 → (Z.zones mpz3 w = C.zone1 wp1 ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ C.offset wp1 = (0 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ abs (BitVec.toInt o7) ≤ C.plength wp1 ∧ C.plength wp1 = Z.alloc mpz3 w ∧ (¬BitVec.toInt o7 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o7) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt o7)))) ∧ (∀(mpz4 : Z.mpz_memo), Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.readers mpz4 = Z.readers mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz4 mpz3) ∧ (Z.sgn mpz4 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o7) ∧ (Z.sgn mpz4 w = -(1 : ℤ)) = (BitVec.toInt o7 < (0 : ℤ)) ∧ Z.abs_size mpz4 w = abs (BitVec.toInt o7) ∧ Z.abs_value_of mpz4 w = Lemmas.value wp1 (abs (BitVec.toInt o7)) → (Z.zones mpz4 w = C.zone1 wp1 ∧ Z.readers mpz4 w = -(1 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ Z.abs_value_of mpz4 w = Lemmas.value wp1 (Z.abs_size mpz4 w)) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz5 y = Z.readers mpz4 y) → Z.value_of w mpz5 = BitVec.toUInt uval - Z.value_of v mpz ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz5 mpz) ∧ Z.readers mpz5 w = (0 : ℤ) ∧ Z.readers mpz5 v = (0 : ℤ))))))))))))))))) else ∀(o2 : Bool), (BitVec.toInt o1 = BitVec.toInt (1 : BitVec 32) → o2 = true) ∧ (o2 = true → o1 = (1 : BitVec 32)) → (if o2 = true then Z.readers mpz w = (0 : ℤ) ∧ (∀(mpz1 : Z.mpz_memo), Z.abs_value_of mpz1 = Z.abs_value_of mpz ∧ Z.alloc mpz1 = Z.alloc mpz ∧ Z.abs_size mpz1 = Z.abs_size mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(wp : C.ptr (BitVec 64)), Z.readers mpz1 w = -(1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬w = y → Z.readers mpz1 y = Z.readers mpz y) ∧ Lemmas.value wp (Z.abs_size mpz1 w) = Z.abs_value_of mpz1 w ∧ C.plength wp = Z.alloc mpz1 w ∧ C.offset wp = (0 : ℤ) ∧ C.min wp = (0 : ℤ) ∧ C.max wp = C.plength wp ∧ C.writable wp = true ∧ C.zone1 wp = Z.zones mpz1 w → (if Z.mpz_eq v w then (C.min wp ≤ C.offset wp ∧ C.offset wp < C.max wp) ∧ (if BitVec.toUInt (C.pelts wp (C.offset wp)) ≤ BitVec.toUInt uval then (C.min wp ≤ C.offset wp ∧ C.offset wp < C.max wp) ∧ (let o3 : BitVec 64 := C.pelts wp (C.offset wp); uint'64_in_bounds (BitVec.toUInt uval - BitVec.toUInt o3) ∧ (∀(o4 : BitVec 64), BitVec.toUInt o4 = BitVec.toUInt uval - BitVec.toUInt o3 → ((C.min wp ≤ C.offset wp ∧ C.offset wp < C.max wp) ∧ C.writable wp = true) ∧ (∀(wp1 : C.ptr (BitVec 64)), List.length (C.data wp1) = List.length (C.data wp) ∧ C.offset wp1 = C.offset wp ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → C.pelts wp1 = Function.update (C.pelts wp) (C.offset wp1) o4 → (C.min wp1 ≤ C.offset wp1 ∧ C.offset wp1 < C.max wp1) ∧ (let o5 : BitVec 64 := C.pelts wp1 (C.offset wp1); ∀(o6 : Bool), (BitVec.toUInt o5 = BitVec.toUInt (0 : BitVec 64) → o6 = true) ∧ (o6 = true → o5 = (0 : BitVec 64)) → (∀(o7 : BitVec 32), (if ¬o6 = true then o7 = (1 : BitVec 32) else o7 = (0 : BitVec 32)) → (Z.zones mpz1 w = C.zone1 wp1 ∧ Z.readers mpz1 w = -(1 : ℤ) ∧ C.offset wp1 = (0 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ abs (BitVec.toInt o7) ≤ C.plength wp1 ∧ C.plength wp1 = Z.alloc mpz1 w ∧ (¬BitVec.toInt o7 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o7) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt o7)))) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz2 mpz1) ∧ (Z.sgn mpz2 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o7) ∧ (Z.sgn mpz2 w = -(1 : ℤ)) = (BitVec.toInt o7 < (0 : ℤ)) ∧ Z.abs_size mpz2 w = abs (BitVec.toInt o7) ∧ Z.abs_value_of mpz2 w = Lemmas.value wp1 (abs (BitVec.toInt o7)) → (Z.zones mpz2 w = C.zone1 wp1 ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ Z.abs_value_of mpz2 w = Lemmas.value wp1 (Z.abs_size mpz2 w)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz3 y = Z.readers mpz2 y) → Z.value_of w mpz3 = BitVec.toUInt uval - Z.value_of v mpz ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ Z.readers mpz3 w = (0 : ℤ) ∧ Z.readers mpz3 v = (0 : ℤ)))))))) else (C.min wp ≤ C.offset wp ∧ C.offset wp < C.max wp) ∧ (let o3 : BitVec 64 := C.pelts wp (C.offset wp); uint'64_in_bounds (BitVec.toUInt o3 - BitVec.toUInt uval) ∧ (∀(o4 : BitVec 64), BitVec.toUInt o4 = BitVec.toUInt o3 - BitVec.toUInt uval → ((C.min wp ≤ C.offset wp ∧ C.offset wp < C.max wp) ∧ C.writable wp = true) ∧ (∀(wp1 : C.ptr (BitVec 64)), List.length (C.data wp1) = List.length (C.data wp) ∧ C.offset wp1 = C.offset wp ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → C.pelts wp1 = Function.update (C.pelts wp) (C.offset wp1) o4 → (Z.zones mpz1 w = C.zone1 wp1 ∧ Z.readers mpz1 w = -(1 : ℤ) ∧ C.offset wp1 = (0 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ abs (BitVec.toInt (-(1 : BitVec 32))) ≤ C.plength wp1 ∧ C.plength wp1 = Z.alloc mpz1 w ∧ (¬BitVec.toInt (-(1 : BitVec 32)) = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt (-(1 : BitVec 32))) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt (-(1 : BitVec 32)))))) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz2 mpz1) ∧ (Z.sgn mpz2 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt (-(1 : BitVec 32))) ∧ (Z.sgn mpz2 w = -(1 : ℤ)) = (BitVec.toInt (-(1 : BitVec 32)) < (0 : ℤ)) ∧ Z.abs_size mpz2 w = abs (BitVec.toInt (-(1 : BitVec 32))) ∧ Z.abs_value_of mpz2 w = Lemmas.value wp1 (abs (BitVec.toInt (-(1 : BitVec 32)))) → (Z.zones mpz2 w = C.zone1 wp1 ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ Z.abs_value_of mpz2 w = Lemmas.value wp1 (Z.abs_size mpz2 w)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz3 y = Z.readers mpz2 y) → Z.value_of w mpz3 = BitVec.toUInt uval - Z.value_of v mpz ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ Z.readers mpz3 w = (0 : ℤ) ∧ Z.readers mpz3 v = (0 : ℤ))))))) else (0 : ℤ) ≤ Z.readers mpz1 v ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(vp : C.ptr (BitVec 64)), Z.readers mpz2 v = Z.readers mpz1 v + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬v = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value vp (Z.abs_size mpz2 v) = Z.abs_value_of mpz2 v ∧ C.plength vp = Z.alloc mpz2 v ∧ C.offset vp = (0 : ℤ) ∧ C.min vp = (0 : ℤ) ∧ C.max vp = C.plength vp ∧ C.zone1 vp = Z.zones mpz2 v → (C.min vp ≤ C.offset vp ∧ C.offset vp < C.max vp) ∧ (if BitVec.toUInt (C.pelts vp (C.offset vp)) ≤ BitVec.toUInt uval then (C.min vp ≤ C.offset vp ∧ C.offset vp < C.max vp) ∧ (let o3 : BitVec 64 := C.pelts vp (C.offset vp); uint'64_in_bounds (BitVec.toUInt uval - BitVec.toUInt o3) ∧ (∀(o4 : BitVec 64), BitVec.toUInt o4 = BitVec.toUInt uval - BitVec.toUInt o3 → ((C.min wp ≤ C.offset wp ∧ C.offset wp < C.max wp) ∧ C.writable wp = true) ∧ (∀(wp1 : C.ptr (BitVec 64)), List.length (C.data wp1) = List.length (C.data wp) ∧ C.offset wp1 = C.offset wp ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → C.pelts wp1 = Function.update (C.pelts wp) (C.offset wp1) o4 → (C.min wp1 ≤ C.offset wp1 ∧ C.offset wp1 < C.max wp1) ∧ (let o5 : BitVec 64 := C.pelts wp1 (C.offset wp1); ∀(o6 : Bool), (BitVec.toUInt o5 = BitVec.toUInt (0 : BitVec 64) → o6 = true) ∧ (o6 = true → o5 = (0 : BitVec 64)) → (∀(o7 : BitVec 32), (if ¬o6 = true then o7 = (1 : BitVec 32) else o7 = (0 : BitVec 32)) → (Z.zones mpz2 v = C.zone1 vp ∧ (1 : ℤ) ≤ Z.readers mpz2 v ∧ C.min vp = (0 : ℤ) ∧ C.max vp = C.plength vp) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 v = Z.readers mpz2 v - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v → Z.readers mpz3 y = Z.readers mpz2 y) → (Z.zones mpz3 w = C.zone1 wp1 ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ C.offset wp1 = (0 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ abs (BitVec.toInt o7) ≤ C.plength wp1 ∧ C.plength wp1 = Z.alloc mpz3 w ∧ (¬BitVec.toInt o7 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o7) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt o7)))) ∧ (∀(mpz4 : Z.mpz_memo), Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.readers mpz4 = Z.readers mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz4 mpz3) ∧ (Z.sgn mpz4 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o7) ∧ (Z.sgn mpz4 w = -(1 : ℤ)) = (BitVec.toInt o7 < (0 : ℤ)) ∧ Z.abs_size mpz4 w = abs (BitVec.toInt o7) ∧ Z.abs_value_of mpz4 w = Lemmas.value wp1 (abs (BitVec.toInt o7)) → (Z.zones mpz4 w = C.zone1 wp1 ∧ Z.readers mpz4 w = -(1 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ Z.abs_value_of mpz4 w = Lemmas.value wp1 (Z.abs_size mpz4 w)) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz5 y = Z.readers mpz4 y) → Z.value_of w mpz5 = BitVec.toUInt uval - Z.value_of v mpz ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz5 mpz) ∧ Z.readers mpz5 w = (0 : ℤ) ∧ Z.readers mpz5 v = (0 : ℤ))))))))) else (C.min vp ≤ C.offset vp ∧ C.offset vp < C.max vp) ∧ (let o3 : BitVec 64 := C.pelts vp (C.offset vp); uint'64_in_bounds (BitVec.toUInt o3 - BitVec.toUInt uval) ∧ (∀(o4 : BitVec 64), BitVec.toUInt o4 = BitVec.toUInt o3 - BitVec.toUInt uval → ((C.min wp ≤ C.offset wp ∧ C.offset wp < C.max wp) ∧ C.writable wp = true) ∧ (∀(wp1 : C.ptr (BitVec 64)), List.length (C.data wp1) = List.length (C.data wp) ∧ C.offset wp1 = C.offset wp ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → C.pelts wp1 = Function.update (C.pelts wp) (C.offset wp1) o4 → (Z.zones mpz2 v = C.zone1 vp ∧ (1 : ℤ) ≤ Z.readers mpz2 v ∧ C.min vp = (0 : ℤ) ∧ C.max vp = C.plength vp) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 v = Z.readers mpz2 v - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v → Z.readers mpz3 y = Z.readers mpz2 y) → (Z.zones mpz3 w = C.zone1 wp1 ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ C.offset wp1 = (0 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ abs (BitVec.toInt (-(1 : BitVec 32))) ≤ C.plength wp1 ∧ C.plength wp1 = Z.alloc mpz3 w ∧ (¬BitVec.toInt (-(1 : BitVec 32)) = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt (-(1 : BitVec 32))) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt (-(1 : BitVec 32)))))) ∧ (∀(mpz4 : Z.mpz_memo), Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.readers mpz4 = Z.readers mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz4 mpz3) ∧ (Z.sgn mpz4 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt (-(1 : BitVec 32))) ∧ (Z.sgn mpz4 w = -(1 : ℤ)) = (BitVec.toInt (-(1 : BitVec 32)) < (0 : ℤ)) ∧ Z.abs_size mpz4 w = abs (BitVec.toInt (-(1 : BitVec 32))) ∧ Z.abs_value_of mpz4 w = Lemmas.value wp1 (abs (BitVec.toInt (-(1 : BitVec 32)))) → (Z.zones mpz4 w = C.zone1 wp1 ∧ Z.readers mpz4 w = -(1 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ Z.abs_value_of mpz4 w = Lemmas.value wp1 (Z.abs_size mpz4 w)) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz5 y = Z.readers mpz4 y) → Z.value_of w mpz5 = BitVec.toUInt uval - Z.value_of v mpz ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz5 mpz) ∧ Z.readers mpz5 w = (0 : ℤ) ∧ Z.readers mpz5 v = (0 : ℤ))))))))))))) else ∀(o3 : Bool), (BitVec.toInt o1 = BitVec.toInt (0 : BitVec 32) → o3 = true) ∧ (o3 = true → o1 = (0 : BitVec 32)) → (if o3 = true then Z.readers mpz w = (0 : ℤ) ∧ (∀(mpz1 : Z.mpz_memo), Z.abs_value_of mpz1 = Z.abs_value_of mpz ∧ Z.alloc mpz1 = Z.alloc mpz ∧ Z.abs_size mpz1 = Z.abs_size mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(wp : C.ptr (BitVec 64)), Z.readers mpz1 w = -(1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬w = y → Z.readers mpz1 y = Z.readers mpz y) ∧ Lemmas.value wp (Z.abs_size mpz1 w) = Z.abs_value_of mpz1 w ∧ C.plength wp = Z.alloc mpz1 w ∧ C.offset wp = (0 : ℤ) ∧ C.min wp = (0 : ℤ) ∧ C.max wp = C.plength wp ∧ C.writable wp = true ∧ C.zone1 wp = Z.zones mpz1 w → ((C.min wp ≤ C.offset wp ∧ C.offset wp < C.max wp) ∧ C.writable wp = true) ∧ (∀(wp1 : C.ptr (BitVec 64)), List.length (C.data wp1) = List.length (C.data wp) ∧ C.offset wp1 = C.offset wp ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → C.pelts wp1 = Function.update (C.pelts wp) (C.offset wp1) uval → (∀(o4 : Bool), (BitVec.toUInt uval = BitVec.toUInt (0 : BitVec 64) → o4 = true) ∧ (o4 = true → uval = (0 : BitVec 64)) → (∀(o5 : BitVec 32), (if ¬o4 = true then o5 = (1 : BitVec 32) else o5 = (0 : BitVec 32)) → (Z.zones mpz1 w = C.zone1 wp1 ∧ Z.readers mpz1 w = -(1 : ℤ) ∧ C.offset wp1 = (0 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ abs (BitVec.toInt o5) ≤ C.plength wp1 ∧ C.plength wp1 = Z.alloc mpz1 w ∧ (¬BitVec.toInt o5 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o5) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt o5)))) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz2 mpz1) ∧ (Z.sgn mpz2 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o5) ∧ (Z.sgn mpz2 w = -(1 : ℤ)) = (BitVec.toInt o5 < (0 : ℤ)) ∧ Z.abs_size mpz2 w = abs (BitVec.toInt o5) ∧ Z.abs_value_of mpz2 w = Lemmas.value wp1 (abs (BitVec.toInt o5)) → (Z.zones mpz2 w = C.zone1 wp1 ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ Z.abs_value_of mpz2 w = Lemmas.value wp1 (Z.abs_size mpz2 w)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz3 y = Z.readers mpz2 y) → Z.value_of w mpz3 = BitVec.toUInt uval - Z.value_of v mpz ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ Z.readers mpz3 w = (0 : ℤ) ∧ Z.readers mpz3 v = (0 : ℤ)))))))) else int'32_in_bounds (-BitVec.toInt o1) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = -BitVec.toInt o1 → int'32_in_bounds (BitVec.toInt o4 + (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt o4 + (1 : ℤ) → (Z.readers mpz w = (0 : ℤ) ∧ (1 : ℤ) ≤ Z.alloc mpz w) ∧ (∀(mpz1 : Z.mpz_memo), Z.sgn mpz1 = Z.sgn mpz → (∀(wp : C.ptr (BitVec 64)), (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz1 mpz) ∧ Z.readers mpz1 w = -(1 : ℤ) ∧ Z.abs_value_of mpz1 w = Lemmas.value wp (Z.abs_size mpz1 w) ∧ Z.zones mpz1 w = C.zone1 wp ∧ C.offset wp = (0 : ℤ) ∧ C.plength wp = Z.alloc mpz1 w ∧ C.min wp = (0 : ℤ) ∧ C.max wp = C.plength wp ∧ C.writable wp = true ∧ Z.abs_size mpz1 w = Z.abs_size mpz w ∧ Lemmas.value wp (Z.abs_size mpz w) = Z.abs_value_of mpz w ∧ (if Z.alloc mpz w < BitVec.toInt o5 then Z.alloc mpz1 w = BitVec.toInt o5 else Z.alloc mpz1 w = Z.alloc mpz w) → (if Z.mpz_eq v w then (C.valid wp (BitVec.toInt o4) ∧ (0 : ℤ) < BitVec.toInt o4 ∧ C.writable wp = true) ∧ (∀(wp1 : C.ptr (BitVec 64)), List.length (C.data wp1) = List.length (C.data wp) ∧ C.offset wp1 = C.offset wp ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(cy : BitVec 64), Lemmas.value wp1 (BitVec.toInt o4) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o4)) * BitVec.toUInt cy = Lemmas.value wp (BitVec.toInt o4) + BitVec.toUInt uval ∧ ((0 : ℤ) ≤ BitVec.toUInt cy ∧ BitVec.toUInt cy ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt o4 ≤ j → C.pelts wp1 j = C.pelts wp j) → ((C.min wp1 ≤ C.offset wp1 + BitVec.toInt o4 ∧ C.offset wp1 + BitVec.toInt o4 < C.max wp1) ∧ C.writable wp1 = true) ∧ (∀(wp2 : C.ptr (BitVec 64)), List.length (C.data wp2) = List.length (C.data wp1) ∧ C.offset wp2 = C.offset wp1 ∧ C.min wp2 = C.min wp1 ∧ C.max wp2 = C.max wp1 ∧ C.writable wp2 = C.writable wp1 ∧ C.zone1 wp2 = C.zone1 wp1 → C.pelts wp2 = Function.update (C.pelts wp1) (C.offset wp2 + BitVec.toInt o4) cy ∧ C.pelts wp2 (C.offset wp2 + BitVec.toInt o4) = cy → (∀(o6 : Bool), (BitVec.toUInt cy = BitVec.toUInt (0 : BitVec 64) → o6 = true) ∧ (o6 = true → cy = (0 : BitVec 64)) → (∀(o7 : BitVec 32), (if ¬o6 = true then o7 = (1 : BitVec 32) else o7 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt o4 + BitVec.toInt o7) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt o4 + BitVec.toInt o7 → (Z.zones mpz1 w = C.zone1 wp2 ∧ Z.readers mpz1 w = -(1 : ℤ) ∧ C.offset wp2 = (0 : ℤ) ∧ C.min wp2 = (0 : ℤ) ∧ C.max wp2 = C.plength wp2 ∧ abs (BitVec.toInt o8) ≤ C.plength wp2 ∧ C.plength wp2 = Z.alloc mpz1 w ∧ (¬BitVec.toInt o8 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o8) - (1 : ℤ))) ≤ Lemmas.value wp2 (abs (BitVec.toInt o8)))) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz2 mpz1) ∧ (Z.sgn mpz2 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o8) ∧ (Z.sgn mpz2 w = -(1 : ℤ)) = (BitVec.toInt o8 < (0 : ℤ)) ∧ Z.abs_size mpz2 w = abs (BitVec.toInt o8) ∧ Z.abs_value_of mpz2 w = Lemmas.value wp2 (abs (BitVec.toInt o8)) → (Z.zones mpz2 w = C.zone1 wp2 ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ C.min wp2 = (0 : ℤ) ∧ C.max wp2 = C.plength wp2 ∧ Z.abs_value_of mpz2 w = Lemmas.value wp2 (Z.abs_size mpz2 w)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz3 y = Z.readers mpz2 y) → Z.value_of w mpz3 = BitVec.toUInt uval - Z.value_of v mpz ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ Z.readers mpz3 w = (0 : ℤ) ∧ Z.readers mpz3 v = (0 : ℤ))))))))) else Z.mpz_unchanged v mpz1 mpz ∧ (Z.readers mpz1 v = Z.readers mpz v ∧ (-(2 : ℤ) < Z.readers mpz1 v → Z.abs_value_of mpz1 v = Z.abs_value_of mpz v ∧ Z.alloc mpz1 v = Z.alloc mpz v ∧ Z.abs_size mpz1 v = Z.abs_size mpz v ∧ Z.sgn mpz1 v = Z.sgn mpz v ∧ Z.readers mpz1 v = Z.readers mpz v ∧ Z.zones mpz1 v = Z.zones mpz v) → (0 : ℤ) ≤ Z.readers mpz1 v ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(vp : C.ptr (BitVec 64)), Z.readers mpz2 v = Z.readers mpz1 v + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬v = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value vp (Z.abs_size mpz2 v) = Z.abs_value_of mpz2 v ∧ C.plength vp = Z.alloc mpz2 v ∧ C.offset vp = (0 : ℤ) ∧ C.min vp = (0 : ℤ) ∧ C.max vp = C.plength vp ∧ C.zone1 vp = Z.zones mpz2 v → (C.valid vp (BitVec.toInt o4) ∧ C.valid wp (BitVec.toInt o4) ∧ (0 : ℤ) < BitVec.toInt o4 ∧ C.writable wp = true) ∧ (∀(wp1 : C.ptr (BitVec 64)), List.length (C.data wp1) = List.length (C.data wp) ∧ C.offset wp1 = C.offset wp ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(cy : BitVec 64), Lemmas.value wp1 (BitVec.toInt o4) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o4)) * BitVec.toUInt cy = Lemmas.value vp (BitVec.toInt o4) + BitVec.toUInt uval ∧ ((0 : ℤ) ≤ BitVec.toUInt cy ∧ BitVec.toUInt cy ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt o4 ≤ j → C.pelts wp1 j = C.pelts wp j) → ((C.min wp1 ≤ C.offset wp1 + BitVec.toInt o4 ∧ C.offset wp1 + BitVec.toInt o4 < C.max wp1) ∧ C.writable wp1 = true) ∧ (∀(wp2 : C.ptr (BitVec 64)), List.length (C.data wp2) = List.length (C.data wp1) ∧ C.offset wp2 = C.offset wp1 ∧ C.min wp2 = C.min wp1 ∧ C.max wp2 = C.max wp1 ∧ C.writable wp2 = C.writable wp1 ∧ C.zone1 wp2 = C.zone1 wp1 → C.pelts wp2 = Function.update (C.pelts wp1) (C.offset wp2 + BitVec.toInt o4) cy ∧ C.pelts wp2 (C.offset wp2 + BitVec.toInt o4) = cy → (∀(o6 : Bool), (BitVec.toUInt cy = BitVec.toUInt (0 : BitVec 64) → o6 = true) ∧ (o6 = true → cy = (0 : BitVec 64)) → (∀(o7 : BitVec 32), (if ¬o6 = true then o7 = (1 : BitVec 32) else o7 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt o4 + BitVec.toInt o7) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt o4 + BitVec.toInt o7 → (Z.zones mpz2 v = C.zone1 vp ∧ (1 : ℤ) ≤ Z.readers mpz2 v ∧ C.min vp = (0 : ℤ) ∧ C.max vp = C.plength vp) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 v = Z.readers mpz2 v - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v → Z.readers mpz3 y = Z.readers mpz2 y) → (Z.zones mpz3 w = C.zone1 wp2 ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ C.offset wp2 = (0 : ℤ) ∧ C.min wp2 = (0 : ℤ) ∧ C.max wp2 = C.plength wp2 ∧ abs (BitVec.toInt o8) ≤ C.plength wp2 ∧ C.plength wp2 = Z.alloc mpz3 w ∧ (¬BitVec.toInt o8 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o8) - (1 : ℤ))) ≤ Lemmas.value wp2 (abs (BitVec.toInt o8)))) ∧ (∀(mpz4 : Z.mpz_memo), Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.readers mpz4 = Z.readers mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz4 mpz3) ∧ (Z.sgn mpz4 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o8) ∧ (Z.sgn mpz4 w = -(1 : ℤ)) = (BitVec.toInt o8 < (0 : ℤ)) ∧ Z.abs_size mpz4 w = abs (BitVec.toInt o8) ∧ Z.abs_value_of mpz4 w = Lemmas.value wp2 (abs (BitVec.toInt o8)) → (Z.zones mpz4 w = C.zone1 wp2 ∧ Z.readers mpz4 w = -(1 : ℤ) ∧ C.min wp2 = (0 : ℤ) ∧ C.max wp2 = C.plength wp2 ∧ Z.abs_value_of mpz4 w = Lemmas.value wp2 (Z.abs_size mpz4 w)) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz5 y = Z.readers mpz4 y) → Z.value_of w mpz5 = BitVec.toUInt uval - Z.value_of v mpz ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz5 mpz) ∧ Z.readers mpz5 w = (0 : ℤ) ∧ Z.readers mpz5 v = (0 : ℤ))))))))))))))))))))))
  := sorry
end mpz_sub_Zsub_wmpz_ui_subqtvc
