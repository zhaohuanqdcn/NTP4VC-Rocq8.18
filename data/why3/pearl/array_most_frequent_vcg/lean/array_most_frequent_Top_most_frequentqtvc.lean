import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
open Classical
open Lean4Why3
namespace array_most_frequent_Top_most_frequentqtvc
axiom fc :  {α : Type} -> [Inhabited α] -> List α -> α -> ℤ -> Bool
axiom fc'def {α : Type} [Inhabited α] (a : List α) (v : α) (i : ℤ) : (fc a v i = true) = (a[Int.toNat i]! = v)
theorem most_frequent'vc (a : List ℤ) (fact0 : (0 : ℤ) < Int.ofNat (List.length a)) (fact1 : ∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ j ∧ j < Int.ofNat (List.length a) → a[Int.toNat i]! ≤ a[Int.toNat j]!) : (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length a) ∧ (let o1 : ℤ := a[(0 : ℕ)]!; let o2 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((1 : ℤ) ≤ o2 + (1 : ℤ) → ((1 : ℤ) = Int.ofNat (List.count (a[Int.toNat ((1 : ℤ) - (1 : ℤ))]!) (List.drop (0 : ℕ) (List.take ((1 : ℕ) - (0 : ℕ)) a))) ∧ (1 : ℤ) = Int.ofNat (List.count o1 (List.drop (0 : ℕ) (List.take ((1 : ℕ) - (0 : ℕ)) a))) ∧ (∀(x : ℤ), Int.ofNat (List.count x (List.drop (0 : ℕ) (List.take ((1 : ℕ) - (0 : ℕ)) a))) ≤ (1 : ℤ))) ∧ (∀(m : ℤ) (c : ℤ) (r : ℤ), (∀(i : ℤ), ((1 : ℤ) ≤ i ∧ i ≤ o2) ∧ c = Int.ofNat (List.count (a[Int.toNat (i - (1 : ℤ))]!) (List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a))) ∧ m = Int.ofNat (List.count r (List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a))) ∧ (∀(x : ℤ), Int.ofNat (List.count x (List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a))) ≤ m) → (let o3 : ℤ := i - (1 : ℤ); ((0 : ℤ) ≤ o3 ∧ o3 < Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if a[Int.toNat i]! = a[Int.toNat o3]! then if m < c + (1 : ℤ) then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ c + (1 : ℤ) = Int.ofNat (List.count (a[Int.toNat (i + (1 : ℤ) - (1 : ℤ))]!) (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ∧ c + (1 : ℤ) = Int.ofNat (List.count (a[Int.toNat i]!) (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ∧ (∀(x : ℤ), Int.ofNat (List.count x (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ≤ c + (1 : ℤ)) else c + (1 : ℤ) = Int.ofNat (List.count (a[Int.toNat (i + (1 : ℤ) - (1 : ℤ))]!) (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ∧ m = Int.ofNat (List.count r (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ∧ (∀(x : ℤ), Int.ofNat (List.count x (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ≤ m) else (1 : ℤ) = Int.ofNat (List.count (a[Int.toNat (i + (1 : ℤ) - (1 : ℤ))]!) (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ∧ m = Int.ofNat (List.count r (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ∧ (∀(x : ℤ), Int.ofNat (List.count x (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ≤ m)))) ∧ (c = Int.ofNat (List.count (a[Int.toNat (o2 + (1 : ℤ) - (1 : ℤ))]!) (List.drop (0 : ℕ) (List.take (Int.toNat (o2 + (1 : ℤ)) - (0 : ℕ)) a))) ∧ m = Int.ofNat (List.count r (List.drop (0 : ℕ) (List.take (Int.toNat (o2 + (1 : ℤ)) - (0 : ℕ)) a))) ∧ (∀(x : ℤ), Int.ofNat (List.count x (List.drop (0 : ℕ) (List.take (Int.toNat (o2 + (1 : ℤ)) - (0 : ℕ)) a))) ≤ m) → (0 : ℤ) < Int.ofNat (List.count r (List.drop (0 : ℕ) (List.take (List.length a - (0 : ℕ)) a))) ∧ (∀(x : ℤ), List.count x (List.drop (0 : ℕ) (List.take (List.length a - (0 : ℕ)) a)) ≤ List.count r (List.drop (0 : ℕ) (List.take (List.length a - (0 : ℕ)) a)))))) ∧ (o2 + (1 : ℤ) < (1 : ℤ) → (0 : ℤ) < Int.ofNat (List.count o1 (List.drop (0 : ℕ) (List.take (List.length a - (0 : ℕ)) a))) ∧ (∀(x : ℤ), List.count x (List.drop (0 : ℕ) (List.take (List.length a - (0 : ℕ)) a)) ≤ List.count o1 (List.drop (0 : ℕ) (List.take (List.length a - (0 : ℕ)) a)))))
  := sorry
end array_most_frequent_Top_most_frequentqtvc
