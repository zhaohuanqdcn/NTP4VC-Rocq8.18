theory string_base64_encoding_Base64_encodeqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.string_StringBuffer"
begin
definition int2b64 :: "int \<Rightarrow> char"
  where "int2b64 i = (if (0 :: int) \<le> i \<and> i \<le> (25 :: int) then char_of (i + (65 :: int)) else if (26 :: int) \<le> i \<and> i \<le> (51 :: int) then char_of (i - (26 :: int) + (97 :: int)) else if (52 :: int) \<le> i \<and> i \<le> (61 :: int) then char_of (i - (52 :: int) + (48 :: int)) else if i = (62 :: int) then char_of (43 :: int) else if i = (63 :: int) then char_of (47 :: int) else char_of (0 :: int))" for i
definition valid_b64_char :: "char \<Rightarrow> _"
  where "valid_b64_char c \<longleftrightarrow> (65 :: int) \<le> of_char c \<and> of_char c \<le> (90 :: int) \<or> (97 :: int) \<le> of_char c \<and> of_char c \<le> (122 :: int) \<or> (48 :: int) \<le> of_char c \<and> of_char c \<le> (57 :: int) \<or> of_char c = (43 :: int) \<or> of_char c = (47 :: int)" for c
definition b642int :: "char \<Rightarrow> int"
  where "b642int c = (if (65 :: int) \<le> of_char c \<and> of_char c \<le> (90 :: int) then of_char c - (65 :: int) else if (97 :: int) \<le> of_char c \<and> of_char c \<le> (122 :: int) then of_char c - (97 :: int) + (26 :: int) else if (48 :: int) \<le> of_char c \<and> of_char c \<le> (57 :: int) then of_char c - (48 :: int) + (52 :: int) else if of_char c = (43 :: int) then 62 :: int else if of_char c = (47 :: int) then 63 :: int else if c = char_of (sint (61 :: 63 word)) then 0 :: int else (64 :: int))" for c
definition get_pad :: "string \<Rightarrow> int"
  where "get_pad s = (if (1 :: int) \<le> int (length s) \<and> s ! nat (int (length s) - (1 :: int)) = char_of (sint (61 :: 63 word)) then if (2 :: int) \<le> int (length s) \<and> s ! nat (int (length s) - (2 :: int)) = char_of (sint (61 :: 63 word)) then 2 :: int else (1 :: int) else (0 :: int))" for s
definition calc_pad :: "string \<Rightarrow> int"
  where "calc_pad s = (if int (length s) cmod (3 :: int) = (1 :: int) then 2 :: int else if int (length s) cmod (3 :: int) = (2 :: int) then 1 :: int else (0 :: int))" for s
definition encoding :: "string \<Rightarrow> string \<Rightarrow> _"
  where "encoding s1 s2 \<longleftrightarrow> int (length s2) = (int (length s1) + calc_pad s1) cdiv (3 :: int) * (4 :: int) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length s2) cdiv (4 :: int) \<longrightarrow> (case (s2 ! nat ((4 :: int) * i), s2 ! nat ((4 :: int) * i + (1 :: int)), s2 ! nat ((4 :: int) * i + (2 :: int)), s2 ! nat ((4 :: int) * i + (3 :: int))) of (b1, b2, b3, b4) \<Rightarrow> s1 ! nat (i * (3 :: int)) = char_of (b642int b1 * (4 :: int) + b642int b2 cdiv (16 :: int)) \<and> (i * (3 :: int) + (1 :: int) < int (length s1) \<longrightarrow> s1 ! nat (i * (3 :: int) + (1 :: int)) = char_of (b642int b2 cmod (16 :: int) * (16 :: int) + b642int b3 cdiv (4 :: int))) \<and> (i * (3 :: int) + (2 :: int) < int (length s1) \<longrightarrow> s1 ! nat (i * (3 :: int) + (2 :: int)) = char_of (b642int b3 cmod (4 :: int) * (64 :: int) + b642int b4)))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length s2) - get_pad s2 \<longrightarrow> valid_b64_char (s2 ! nat i)) \<and> (get_pad s2 = (1 :: int) \<longrightarrow> b642int (s2 ! nat (int (length s2) - (2 :: int))) cmod (4 :: int) = (0 :: int) \<and> s2 ! nat (int (length s2) - (1 :: int)) = char_of (sint (61 :: 63 word))) \<and> (get_pad s2 = (2 :: int) \<longrightarrow> b642int (s2 ! nat (int (length s2) - (3 :: int))) cmod (16 :: int) = (0 :: int) \<and> s2 ! nat (int (length s2) - (2 :: int)) = s2 ! nat (int (length s2) - (1 :: int)) \<and> s2 ! nat (int (length s2) - (1 :: int)) = char_of (sint (61 :: 63 word))) \<and> calc_pad s1 = get_pad s2" for s1 s2
definition valid_b64 :: "string \<Rightarrow> _"
  where "valid_b64 s \<longleftrightarrow> int (length s) cmod (4 :: int) = (0 :: int) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length s) - get_pad s \<longrightarrow> valid_b64_char (s ! nat i)) \<and> (get_pad s = (1 :: int) \<longrightarrow> b642int (s ! nat (int (length s) - (2 :: int))) cmod (4 :: int) = (0 :: int) \<and> s ! nat (int (length s) - (1 :: int)) = char_of (sint (61 :: 63 word))) \<and> (get_pad s = (2 :: int) \<longrightarrow> b642int (s ! nat (int (length s) - (3 :: int))) cmod (16 :: int) = (0 :: int) \<and> s ! nat (int (length s) - (2 :: int)) = char_of (sint (61 :: 63 word)) \<and> s ! nat (int (length s) - (1 :: int)) = char_of (sint (61 :: 63 word)))" for s
theorem encode'vc:
  fixes padding :: "63 word"
  fixes s :: "string"
  assumes fact0: "sint padding = calc_pad s"
  shows "(0 :: int) \<le> (0 :: int)"
  and "(0 :: int) < (256 :: int)"
  and "(0 :: int) \<le> sint padding"
  and "let sp :: string = s @ replicate (nat (sint padding)) (char_of (0 :: int)) in \<forall>(r :: buffer). str r = '''' \<longrightarrow> ((0 :: int) = (0 :: int) * (3 :: int) \<and> int (length (str r)) = (0 :: int) * (4 :: int) \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> int (length sp)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> (let a1 :: char = sp ! nat (j * (3 :: int)); a2 :: char = sp ! nat (j * (3 :: int) + (1 :: int)); a3 :: char = sp ! nat (j * (3 :: int) + (2 :: int)) in str r ! nat (j * (4 :: int)) = int2b64 (of_char a1 cdiv (4 :: int)) \<and> str r ! nat (j * (4 :: int) + (1 :: int)) = int2b64 (of_char a1 cmod (4 :: int) * (16 :: int) + of_char a2 cdiv (16 :: int)) \<and> str r ! nat (j * (4 :: int) + (2 :: int)) = int2b64 (of_char a2 cmod (16 :: int) * (4 :: int) + of_char a3 cdiv (64 :: int)) \<and> str r ! nat (j * (4 :: int) + (3 :: int)) = int2b64 (of_char a3 cmod (64 :: int))))) \<and> (\<forall>(b :: int) (r1 :: buffer) (i :: 63 word). sint i = b * (3 :: int) \<and> int (length (str r1)) = b * (4 :: int) \<and> ((0 :: int) \<le> sint i \<and> sint i \<le> int (length sp)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < b \<longrightarrow> (let a1 :: char = sp ! nat (j * (3 :: int)); a2 :: char = sp ! nat (j * (3 :: int) + (1 :: int)); a3 :: char = sp ! nat (j * (3 :: int) + (2 :: int)) in str r1 ! nat (j * (4 :: int)) = int2b64 (of_char a1 cdiv (4 :: int)) \<and> str r1 ! nat (j * (4 :: int) + (1 :: int)) = int2b64 (of_char a1 cmod (4 :: int) * (16 :: int) + of_char a2 cdiv (16 :: int)) \<and> str r1 ! nat (j * (4 :: int) + (2 :: int)) = int2b64 (of_char a2 cmod (16 :: int) * (4 :: int) + of_char a3 cdiv (64 :: int)) \<and> str r1 ! nat (j * (4 :: int) + (3 :: int)) = int2b64 (of_char a3 cmod (64 :: int)))) \<longrightarrow> (\<forall>(o1 :: 63 word). sint o1 = int (length sp) \<and> (0 :: int) \<le> int (length sp) \<longrightarrow> (if sint i < sint o1 then int'63_in_bounds (sint i + (2 :: int)) \<and> (\<forall>(o2 :: 63 word). sint o2 = sint i + (2 :: int) \<longrightarrow> ((0 :: int) \<le> sint o2 \<and> sint o2 < int (length sp)) \<and> (let o3 :: char = sp ! nat (sint o2) in int'63_in_bounds (sint i + (1 :: int)) \<and> (\<forall>(o4 :: 63 word). sint o4 = sint i + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint o4 \<and> sint o4 < int (length sp)) \<and> (let o5 :: char = sp ! nat (sint o4) in ((0 :: int) \<le> sint i \<and> sint i < int (length sp)) \<and> (let o6 :: char = sp ! nat (sint i) in \<forall>(o7 :: 63 word). sint o7 = of_char o6 \<longrightarrow> (\<not>(4 :: int) = (0 :: int) \<and> int'63_in_bounds (sint o7 cdiv (4 :: int))) \<and> (\<forall>(b1 :: 63 word). sint b1 = sint o7 cdiv (4 :: int) \<longrightarrow> (\<forall>(o8 :: 63 word). sint o8 = of_char o5 \<longrightarrow> (\<not>(16 :: int) = (0 :: int) \<and> int'63_in_bounds (sint o8 cdiv (16 :: int))) \<and> (\<forall>(o9 :: 63 word). sint o9 = sint o8 cdiv (16 :: int) \<longrightarrow> (\<forall>(o10 :: 63 word). sint o10 = of_char o6 \<longrightarrow> (\<not>(4 :: int) = (0 :: int) \<and> int'63_in_bounds (sint o10 cmod (4 :: int))) \<and> (\<forall>(o11 :: 63 word). sint o11 = sint o10 cmod (4 :: int) \<longrightarrow> int'63_in_bounds (sint o11 * (16 :: int)) \<and> (\<forall>(o12 :: 63 word). sint o12 = sint o11 * (16 :: int) \<longrightarrow> int'63_in_bounds (sint o12 + sint o9) \<and> (\<forall>(b2 :: 63 word). sint b2 = sint o12 + sint o9 \<longrightarrow> (\<forall>(o13 :: 63 word). sint o13 = of_char o3 \<longrightarrow> (\<not>(64 :: int) = (0 :: int) \<and> int'63_in_bounds (sint o13 cdiv (64 :: int))) \<and> (\<forall>(o14 :: 63 word). sint o14 = sint o13 cdiv (64 :: int) \<longrightarrow> (\<forall>(o15 :: 63 word). sint o15 = of_char o5 \<longrightarrow> (\<not>(16 :: int) = (0 :: int) \<and> int'63_in_bounds (sint o15 cmod (16 :: int))) \<and> (\<forall>(o16 :: 63 word). sint o16 = sint o15 cmod (16 :: int) \<longrightarrow> int'63_in_bounds (sint o16 * (4 :: int)) \<and> (\<forall>(o17 :: 63 word). sint o17 = sint o16 * (4 :: int) \<longrightarrow> int'63_in_bounds (sint o17 + sint o14) \<and> (\<forall>(b3 :: 63 word). sint b3 = sint o17 + sint o14 \<longrightarrow> (\<forall>(o18 :: 63 word). sint o18 = of_char o3 \<longrightarrow> (\<not>(64 :: int) = (0 :: int) \<and> int'63_in_bounds (sint o18 cmod (64 :: int))) \<and> (\<forall>(b4 :: 63 word). sint b4 = sint o18 cmod (64 :: int) \<longrightarrow> ((0 :: int) \<le> sint b1 \<and> sint b1 < (64 :: int)) \<and> (\<forall>(r2 :: buffer). str r2 = str r1 @ [int2b64 (sint b1)] \<longrightarrow> ((0 :: int) \<le> sint b2 \<and> sint b2 < (64 :: int)) \<and> (\<forall>(r3 :: buffer). str r3 = str r2 @ [int2b64 (sint b2)] \<longrightarrow> ((0 :: int) \<le> sint b3 \<and> sint b3 < (64 :: int)) \<and> (\<forall>(r4 :: buffer). str r4 = str r3 @ [int2b64 (sint b3)] \<longrightarrow> ((0 :: int) \<le> sint b4 \<and> sint b4 < (64 :: int)) \<and> (\<forall>(r5 :: buffer). str r5 = str r4 @ [int2b64 (sint b4)] \<longrightarrow> int'63_in_bounds (sint i + (3 :: int)) \<and> (\<forall>(o19 :: 63 word). sint o19 = sint i + (3 :: int) \<longrightarrow> ((0 :: int) \<le> int (length sp) - sint i \<and> int (length sp) - sint o19 < int (length sp) - sint i) \<and> sint o19 = (b + (1 :: int)) * (3 :: int) \<and> int (length (str r5)) = (b + (1 :: int)) * (4 :: int) \<and> ((0 :: int) \<le> sint o19 \<and> sint o19 \<le> int (length sp)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < b + (1 :: int) \<longrightarrow> (let a1 :: char = sp ! nat (j * (3 :: int)); a2 :: char = sp ! nat (j * (3 :: int) + (1 :: int)); a3 :: char = sp ! nat (j * (3 :: int) + (2 :: int)) in str r5 ! nat (j * (4 :: int)) = int2b64 (of_char a1 cdiv (4 :: int)) \<and> str r5 ! nat (j * (4 :: int) + (1 :: int)) = int2b64 (of_char a1 cmod (4 :: int) * (16 :: int) + of_char a2 cdiv (16 :: int)) \<and> str r5 ! nat (j * (4 :: int) + (2 :: int)) = int2b64 (of_char a2 cmod (16 :: int) * (4 :: int) + of_char a3 cdiv (64 :: int)) \<and> str r5 ! nat (j * (4 :: int) + (3 :: int)) = int2b64 (of_char a3 cmod (64 :: int))))))))))))))))))))))))))))) else \<forall>(o2 :: 63 word). sint o2 = int (length (str r1)) \<longrightarrow> int'63_in_bounds (sint o2 - sint padding) \<and> (\<forall>(o3 :: 63 word). sint o3 = sint o2 - sint padding \<longrightarrow> ((0 :: int) \<le> sint o3 \<and> sint o3 \<le> int (length (str r1))) \<and> (\<forall>(r2 :: buffer). str r2 = drop (0 :: nat) (take (nat (sint o3) - (0 :: nat)) (str r1)) \<longrightarrow> (0 :: int) \<le> sint padding \<and> (\<forall>(r3 :: buffer). str r3 = str r2 @ replicate (nat (sint padding)) (char_of (sint (61 :: 63 word))) \<longrightarrow> encoding s (str r3)))))))"
  sorry
end
