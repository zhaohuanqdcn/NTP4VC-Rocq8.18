import Why3.Base
import pearl.euler_sieve_vcg.lean.euler_sieve.ArithmeticResults
import pearl.euler_sieve_vcg.lean.euler_sieve.DivisibilityResults
import pearl.euler_sieve_vcg.lean.euler_sieve.EulerSieveSpec
open Classical
open Lean4Why3
namespace euler_sieve_EulerSieve_remove_productsqtvc
axiom t : Type
axiom inhabited_axiom_t : Inhabited t
attribute [instance] inhabited_axiom_t
axiom nexts : t -> List ℤ
axiom marked : t -> List Bool
axiom max : t -> BitVec 63
axiom t'invariant (self : t) : BitVec.toInt (max self) < BitVec.toInt int'63_max ∧ (3 : ℤ) ≤ BitVec.toInt (max self) ∧ List.length (nexts self) = List.length (marked self) ∧ Int.ofNat (List.length (marked self)) = BitVec.toInt (max self) + (1 : ℤ) ∧ EulerSieveSpec.inv_nexts (nexts self) (Int.ofNat (List.length (nexts self))) ∧ EulerSieveSpec.all_eliminated_marked (marked self) (nexts self) ∧ (∀(i : ℤ), (3 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max self) → i % (2 : ℤ) = (0 : ℤ) → (marked self)[Int.toNat i]! = true) ∧ (∀(i : ℤ), (3 : ℤ) ≤ i ∧ i < BitVec.toInt (max self) - (1 : ℤ) → i % (2 : ℤ) = (1 : ℤ) → (nexts self)[Int.toNat i]! % (2 : ℤ) = (1 : ℤ) ∨ (nexts self)[Int.toNat i]! = BitVec.toInt (max self) + (1 : ℤ)) ∧ (nexts self)[Int.toNat (BitVec.toInt (max self))]! = BitVec.toInt (max self) + (1 : ℤ) ∧ ((BitVec.toInt (max self) - (1 : ℤ)) % (2 : ℤ) = (0 : ℤ) → (nexts self)[Int.toNat (BitVec.toInt (max self) - (1 : ℤ))]! = BitVec.toInt (max self)) ∧ ((BitVec.toInt (max self) - (1 : ℤ)) % (2 : ℤ) = (1 : ℤ) → (nexts self)[Int.toNat (BitVec.toInt (max self) - (1 : ℤ))]! = BitVec.toInt (max self) + (1 : ℤ))
theorem remove_products'vc (n : BitVec 63) (t1 : t) (fact0 : (3 : ℤ) ≤ BitVec.toInt n) (fact1 : BitVec.toInt n ≤ BitVec.toInt (max t1)) (fact2 : BitVec.toInt n * BitVec.toInt n ≤ BitVec.toInt (max t1)) (fact3 : EulerSieveSpec.inv_remove_products (nexts t1) (marked t1) (BitVec.toInt n)) (fact4 : EulerSieveSpec.previously_marked_multiples (marked t1) (BitVec.toInt n)) (fact5 : EulerSieveSpec.only_multiples_marked (marked t1) (BitVec.toInt n)) (fact6 : EulerSieveSpec.not_marked_impl_next_not_marked (marked t1) (nexts t1) (BitVec.toInt n)) : let o1 : BitVec 63 := max t1; (2 : ℤ) ≤ BitVec.toInt o1 → (¬BitVec.toInt n = (0 : ℤ) ∧ int'63_in_bounds (Int.tdiv (BitVec.toInt o1) (BitVec.toInt n))) ∧ (∀(d : BitVec 63), BitVec.toInt d = Int.tdiv (BitVec.toInt o1) (BitVec.toInt n) → (let max1 : BitVec 63 := max t1; let marked_old : List Bool := marked t1; (∀(t2 : t), max t2 = max t1 → (∀(p : BitVec 63) (x : ℤ), ((BitVec.toInt n ≤ BitVec.toInt p ∧ BitVec.toInt p ≤ BitVec.toInt max1) ∧ ((3 : ℤ) ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ BitVec.toInt max1) ∧ BitVec.toInt p % (2 : ℤ) = (1 : ℤ) ∧ (BitVec.toInt p ≤ x ∧ x < (nexts t2)[Int.toNat (BitVec.toInt p)]!) ∧ (nexts t2)[Int.toNat x]! = (nexts t2)[Int.toNat (BitVec.toInt p)]! ∧ (marked t2)[Int.toNat (BitVec.toInt n * BitVec.toInt n)]! = true) ∧ EulerSieveSpec.inv_remove_products (nexts t2) (marked t2) (BitVec.toInt n) ∧ EulerSieveSpec.previously_marked_multiples (marked t2) (BitVec.toInt n) ∧ ¬(marked t2)[Int.toNat (BitVec.toInt p)]! = true ∧ EulerSieveSpec.is_copy (marked t2) marked_old ∧ EulerSieveSpec.all_eliminated_marked_partial marked_old (nexts t2) x ∧ EulerSieveSpec.not_marked_impl_next_not_marked marked_old (nexts t2) (BitVec.toInt n) ∧ EulerSieveSpec.prime_multiples_marked marked_old (marked t2) (BitVec.toInt n) ((nexts t2)[Int.toNat x]!) ∧ EulerSieveSpec.not_marked_impl_next_not_marked_partial (marked t2) (nexts t2) (BitVec.toInt n) (BitVec.toInt p) ∧ EulerSieveSpec.only_multiples_marked (marked t2) (BitVec.toInt n + (1 : ℤ)) → (((3 : ℤ) ≤ BitVec.toInt p ∧ BitVec.toInt p ≤ BitVec.toInt (max t2)) ∧ BitVec.toInt p % (2 : ℤ) = (1 : ℤ)) ∧ (∀(next : BitVec 63), ((3 : ℤ) ≤ BitVec.toInt next ∧ BitVec.toInt next ≤ BitVec.toInt (max t2) + (1 : ℤ)) ∧ BitVec.toInt next = (nexts t2)[Int.toNat (BitVec.toInt p)]! ∧ (BitVec.toInt next % (2 : ℤ) = (1 : ℤ) ∨ BitVec.toInt next = BitVec.toInt (max t2) + (1 : ℤ)) → (∀(o2 : Bool), (if (0 : ℤ) ≤ BitVec.toInt next then let o3 : BitVec 63 := max t2; (2 : ℤ) ≤ BitVec.toInt o3 ∧ o2 = (if BitVec.toInt next ≤ BitVec.toInt o3 then true else false) else o2 = false) → (if o2 = true then if BitVec.toInt next ≤ BitVec.toInt d then int'63_in_bounds (BitVec.toInt n * BitVec.toInt next) ∧ (∀(o3 : BitVec 63), BitVec.toInt o3 = BitVec.toInt n * BitVec.toInt next → (((0 : ℤ) ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ BitVec.toInt (max t2)) ∧ BitVec.toInt o3 % (2 : ℤ) = (1 : ℤ)) ∧ (∀(t3 : t), nexts t3 = nexts t2 ∧ max t3 = max t2 → marked t3 = List.set (marked t2) (Int.toNat (BitVec.toInt o3)) true → (((0 : ℤ) ≤ BitVec.toInt next ∧ BitVec.toInt next ≤ BitVec.toInt (max t3)) ∧ BitVec.toInt next % (2 : ℤ) = (1 : ℤ)) ∧ (if (marked t3)[Int.toNat (BitVec.toInt next)]! = true then (((3 : ℤ) ≤ BitVec.toInt next ∧ BitVec.toInt next ≤ BitVec.toInt (max t3)) ∧ BitVec.toInt next % (2 : ℤ) = (1 : ℤ)) ∧ (∀(o4 : BitVec 63), ((3 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ BitVec.toInt (max t3) + (1 : ℤ)) ∧ BitVec.toInt o4 = (nexts t3)[Int.toNat (BitVec.toInt next)]! ∧ (BitVec.toInt o4 % (2 : ℤ) = (1 : ℤ) ∨ BitVec.toInt o4 = BitVec.toInt (max t3) + (1 : ℤ)) → ((((0 : ℤ) ≤ BitVec.toInt p ∧ BitVec.toInt p ≤ BitVec.toInt (max t3)) ∧ BitVec.toInt p < BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ BitVec.toInt (max t3) + (1 : ℤ)) ∧ BitVec.toInt p % (2 : ℤ) = (1 : ℤ) ∧ (∀(j : ℤ), BitVec.toInt p < j ∧ j < BitVec.toInt o4 → (marked t3)[Int.toNat j]! = true) ∧ ¬(marked t3)[Int.toNat (BitVec.toInt p)]! = true ∧ (BitVec.toInt o4 % (2 : ℤ) = (1 : ℤ) ∨ BitVec.toInt o4 = BitVec.toInt (max t3) + (1 : ℤ))) ∧ (∀(t4 : t), marked t4 = marked t3 ∧ max t4 = max t3 → nexts t4 = List.set (nexts t3) (Int.toNat (BitVec.toInt p)) (BitVec.toInt o4) → (let o5 : ℤ := BitVec.toInt next; ((0 : ℤ) ≤ BitVec.toInt max1 - (nexts t2)[Int.toNat (BitVec.toInt p)]! ∧ BitVec.toInt max1 - (nexts t4)[Int.toNat (BitVec.toInt p)]! < BitVec.toInt max1 - (nexts t2)[Int.toNat (BitVec.toInt p)]!) ∧ ((BitVec.toInt n ≤ BitVec.toInt p ∧ BitVec.toInt p ≤ BitVec.toInt max1) ∧ ((3 : ℤ) ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ BitVec.toInt max1) ∧ BitVec.toInt p % (2 : ℤ) = (1 : ℤ) ∧ (BitVec.toInt p ≤ o5 ∧ o5 < (nexts t4)[Int.toNat (BitVec.toInt p)]!) ∧ (nexts t4)[Int.toNat o5]! = (nexts t4)[Int.toNat (BitVec.toInt p)]! ∧ (marked t4)[Int.toNat (BitVec.toInt n * BitVec.toInt n)]! = true) ∧ EulerSieveSpec.inv_remove_products (nexts t4) (marked t4) (BitVec.toInt n) ∧ EulerSieveSpec.previously_marked_multiples (marked t4) (BitVec.toInt n) ∧ ¬(marked t4)[Int.toNat (BitVec.toInt p)]! = true ∧ EulerSieveSpec.is_copy (marked t4) marked_old ∧ EulerSieveSpec.all_eliminated_marked_partial marked_old (nexts t4) o5 ∧ EulerSieveSpec.not_marked_impl_next_not_marked marked_old (nexts t4) (BitVec.toInt n) ∧ EulerSieveSpec.prime_multiples_marked marked_old (marked t4) (BitVec.toInt n) ((nexts t4)[Int.toNat o5]!) ∧ EulerSieveSpec.not_marked_impl_next_not_marked_partial (marked t4) (nexts t4) (BitVec.toInt n) (BitVec.toInt p) ∧ EulerSieveSpec.only_multiples_marked (marked t4) (BitVec.toInt n + (1 : ℤ))))) else let o4 : ℤ := BitVec.toInt next; ((0 : ℤ) ≤ BitVec.toInt max1 - (nexts t2)[Int.toNat (BitVec.toInt p)]! ∧ BitVec.toInt max1 - (nexts t3)[Int.toNat (BitVec.toInt next)]! < BitVec.toInt max1 - (nexts t2)[Int.toNat (BitVec.toInt p)]!) ∧ ((BitVec.toInt n ≤ BitVec.toInt next ∧ BitVec.toInt next ≤ BitVec.toInt max1) ∧ ((3 : ℤ) ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ BitVec.toInt max1) ∧ BitVec.toInt next % (2 : ℤ) = (1 : ℤ) ∧ (BitVec.toInt next ≤ o4 ∧ o4 < (nexts t3)[Int.toNat (BitVec.toInt next)]!) ∧ (nexts t3)[Int.toNat o4]! = (nexts t3)[Int.toNat (BitVec.toInt next)]! ∧ (marked t3)[Int.toNat (BitVec.toInt n * BitVec.toInt n)]! = true) ∧ EulerSieveSpec.inv_remove_products (nexts t3) (marked t3) (BitVec.toInt n) ∧ EulerSieveSpec.previously_marked_multiples (marked t3) (BitVec.toInt n) ∧ ¬(marked t3)[Int.toNat (BitVec.toInt next)]! = true ∧ EulerSieveSpec.is_copy (marked t3) marked_old ∧ EulerSieveSpec.all_eliminated_marked_partial marked_old (nexts t3) o4 ∧ EulerSieveSpec.not_marked_impl_next_not_marked marked_old (nexts t3) (BitVec.toInt n) ∧ EulerSieveSpec.prime_multiples_marked marked_old (marked t3) (BitVec.toInt n) ((nexts t3)[Int.toNat o4]!) ∧ EulerSieveSpec.not_marked_impl_next_not_marked_partial (marked t3) (nexts t3) (BitVec.toInt n) (BitVec.toInt next) ∧ EulerSieveSpec.only_multiples_marked (marked t3) (BitVec.toInt n + (1 : ℤ))))) else EulerSieveSpec.inv_remove_products (nexts t2) (marked t2) (BitVec.toInt n) ∧ EulerSieveSpec.not_marked_impl_next_not_marked (marked t2) (nexts t2) ((nexts t2)[Int.toNat (BitVec.toInt n)]!) ∧ EulerSieveSpec.is_copy (marked t2) marked_old ∧ EulerSieveSpec.previously_marked_multiples (marked t2) (BitVec.toInt n) ∧ EulerSieveSpec.prime_multiples_marked marked_old (marked t2) (BitVec.toInt n) (Int.ofNat (List.length (marked t2))) ∧ EulerSieveSpec.only_multiples_marked (marked t2) (BitVec.toInt n + (1 : ℤ)) else EulerSieveSpec.inv_remove_products (nexts t2) (marked t2) (BitVec.toInt n) ∧ EulerSieveSpec.not_marked_impl_next_not_marked (marked t2) (nexts t2) ((nexts t2)[Int.toNat (BitVec.toInt n)]!) ∧ EulerSieveSpec.is_copy (marked t2) marked_old ∧ EulerSieveSpec.previously_marked_multiples (marked t2) (BitVec.toInt n) ∧ EulerSieveSpec.prime_multiples_marked marked_old (marked t2) (BitVec.toInt n) (Int.ofNat (List.length (marked t2))) ∧ EulerSieveSpec.only_multiples_marked (marked t2) (BitVec.toInt n + (1 : ℤ))))))) ∧ int'63_in_bounds (BitVec.toInt n * BitVec.toInt n) ∧ (∀(o2 : BitVec 63), BitVec.toInt o2 = BitVec.toInt n * BitVec.toInt n → (((0 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 ≤ BitVec.toInt (max t1)) ∧ BitVec.toInt o2 % (2 : ℤ) = (1 : ℤ)) ∧ (∀(t2 : t), nexts t2 = nexts t1 ∧ max t2 = max t1 → marked t2 = List.set (marked t1) (Int.toNat (BitVec.toInt o2)) true → (let o3 : ℤ := BitVec.toInt n; (((BitVec.toInt n ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ BitVec.toInt max1) ∧ ((3 : ℤ) ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ BitVec.toInt max1) ∧ BitVec.toInt n % (2 : ℤ) = (1 : ℤ) ∧ (BitVec.toInt n ≤ o3 ∧ o3 < (nexts t2)[Int.toNat (BitVec.toInt n)]!) ∧ (nexts t2)[Int.toNat o3]! = (nexts t2)[Int.toNat (BitVec.toInt n)]! ∧ (marked t2)[Int.toNat (BitVec.toInt n * BitVec.toInt n)]! = true) ∧ EulerSieveSpec.inv_remove_products (nexts t2) (marked t2) (BitVec.toInt n) ∧ EulerSieveSpec.previously_marked_multiples (marked t2) (BitVec.toInt n) ∧ ¬(marked t2)[Int.toNat (BitVec.toInt n)]! = true ∧ EulerSieveSpec.is_copy (marked t2) marked_old ∧ EulerSieveSpec.all_eliminated_marked_partial marked_old (nexts t2) o3 ∧ EulerSieveSpec.not_marked_impl_next_not_marked marked_old (nexts t2) (BitVec.toInt n) ∧ EulerSieveSpec.prime_multiples_marked marked_old (marked t2) (BitVec.toInt n) ((nexts t2)[Int.toNat o3]!) ∧ EulerSieveSpec.not_marked_impl_next_not_marked_partial (marked t2) (nexts t2) (BitVec.toInt n) (BitVec.toInt n) ∧ EulerSieveSpec.only_multiples_marked (marked t2) (BitVec.toInt n + (1 : ℤ))) ∧ (∀(t3 : t), max t3 = max t2 → EulerSieveSpec.inv_remove_products (nexts t3) (marked t3) (BitVec.toInt n) ∧ EulerSieveSpec.not_marked_impl_next_not_marked (marked t3) (nexts t3) ((nexts t3)[Int.toNat (BitVec.toInt n)]!) ∧ EulerSieveSpec.is_copy (marked t3) marked_old ∧ EulerSieveSpec.previously_marked_multiples (marked t3) (BitVec.toInt n) ∧ EulerSieveSpec.prime_multiples_marked marked_old (marked t3) (BitVec.toInt n) (Int.ofNat (List.length (marked t3))) ∧ EulerSieveSpec.only_multiples_marked (marked t3) (BitVec.toInt n + (1 : ℤ)) → EulerSieveSpec.inv_remove_products (nexts t3) (marked t3) (BitVec.toInt n) ∧ EulerSieveSpec.not_marked_impl_next_not_marked (marked t3) (nexts t3) ((nexts t3)[Int.toNat (BitVec.toInt n)]!) ∧ EulerSieveSpec.previously_marked_multiples (marked t3) ((nexts t3)[Int.toNat (BitVec.toInt n)]!) ∧ EulerSieveSpec.only_multiples_marked (marked t3) ((nexts t3)[Int.toNat (BitVec.toInt n)]!)))))))
  := sorry
end euler_sieve_EulerSieve_remove_productsqtvc
