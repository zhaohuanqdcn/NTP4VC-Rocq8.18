theory Unification_Impl_unification_termqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "../../lib/isabelle/Unification_Types" "../../lib/isabelle/Functions_Config" "../../lib/isabelle/Functions_Func" "../../lib/isabelle/BacktrackArray_Types" "../../lib/isabelle/Predicates_Pred" "../../lib/isabelle/BacktrackArray_Logic" "../../lib/isabelle/Choice_Choice" "../../lib/isabelle/BacktrackArray_Impl" "../../lib/isabelle/Firstorder_symbol_spec_Spec" "../../lib/isabelle/Nat_Nat" "../../lib/isabelle/OptionFuncs_Funcs" "../../lib/isabelle/Sum_Sum" "../../lib/isabelle/Firstorder_symbol_impl_Types" "../../lib/isabelle/Firstorder_symbol_impl_Logic" "../../lib/isabelle/Firstorder_symbol_impl_Impl" "../../lib/isabelle/Firstorder_term_spec_Spec" "../../lib/isabelle/Firstorder_term_impl_Types" "../../lib/isabelle/Firstorder_term_impl_Logic" "../../lib/isabelle/Firstorder_term_impl_Impl" "../../lib/isabelle/Unification_Logic"
begin
theorem unification_term'vc:
  fixes t1 :: "nlimpl_fo_term"
  fixes t2 :: "nlimpl_fo_term"
  fixes rhob :: "sdata t"
  fixes rho :: "unifier_subst"
  fixes lv :: "int list"
  fixes lp :: "int \<Rightarrow> bool"
  assumes fact0: "nlimpl_fo_term_ok t1"
  assumes fact1: "nlimpl_fo_term_ok t2"
  assumes fact2: "unifier_subst_ok rhob rho"
  assumes fact3: "\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field t1) \<longrightarrow> (0 :: int) \<le> y"
  assumes fact4: "\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field t2) \<longrightarrow> (0 :: int) \<le> y"
  assumes fact5: "\<forall>(x :: int). x \<in> set lv \<longrightarrow> lp x = True \<and> (0 :: int) \<le> x"
  assumes fact6: "\<forall>(x :: int). unassigned (current_timestamp rhob) x \<longrightarrow> lp x = True"
  shows "nlimpl_fo_term_ok t2"
  and "\<forall>(o1 :: cons_fo_term). cons_ok_fo_term o1 \<and> cons_rel_fo_term o1 t2 \<and> cons_open_rel_fo_term o1 t2 \<longrightarrow> nlimpl_fo_term_ok t1 \<and> (\<forall>(o2 :: cons_fo_term). cons_ok_fo_term o2 \<and> cons_rel_fo_term o2 t1 \<and> cons_open_rel_fo_term o2 t1 \<longrightarrow> (case o1 of NLCVar_fo_term x \<Rightarrow> (case o2 of NLCVar_fo_term x1 \<Rightarrow> (if x1 = x then unifier_subst_ok rhob rho \<and> precede rhob rhob \<and> (\<forall>(x2 :: int). x2 \<in> set lv \<longrightarrow> lp x2 = True \<and> (0 :: int) \<le> x2) \<and> (\<forall>(x2 :: int). unassigned (current_timestamp rhob) x2 \<longrightarrow> lp x2 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (subst_id_fo_term :: int \<Rightarrow> (int, int) fo_term) = unifier rho \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier rho) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier rho; s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier rho; s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) else (correct rhob \<and> (0 :: int) \<le> x1) \<and> (let bx :: sdata list = table (current_timestamp rhob) x1 in list_forall (inv rhob) bx \<longrightarrow> (case bx of Cons (Assign bx1) _ \<Rightarrow> (nlimpl_fo_term_ok bx1 \<and> nlimpl_fo_term_ok t2 \<and> unifier_subst_ok rhob rho \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field bx1) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field t2) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(x2 :: int). x2 \<in> set lv \<longrightarrow> lp x2 = True \<and> (0 :: int) \<le> x2) \<and> (\<forall>(x2 :: int). unassigned (current_timestamp rhob) x2 \<longrightarrow> lp x2 = True)) \<and> (\<forall>(rhob1 :: sdata t) (lv1 :: int list). inv rhob1 = inv rhob \<longrightarrow> (\<forall>(res :: unification_return). unifier_subst_ok rhob1 (final_unifier res) \<and> precede rhob rhob1 \<and> (\<forall>(x2 :: int). x2 \<in> set lv1 \<longrightarrow> lp x2 = True \<and> (0 :: int) \<le> x2) \<and> (\<forall>(x2 :: int). unassigned (current_timestamp rhob1) x2 \<longrightarrow> lp x2 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field bx1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res) in subst_fo_term (model_fo_term_field bx1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<longrightarrow> unifier_subst_ok rhob1 (final_unifier res) \<and> precede rhob rhob1 \<and> (\<forall>(x2 :: int). x2 \<in> set lv1 \<longrightarrow> lp x2 = True \<and> (0 :: int) \<le> x2) \<and> (\<forall>(x2 :: int). unassigned (current_timestamp rhob1) x2 \<longrightarrow> lp x2 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0))) | _ \<Rightarrow> (correct rhob \<and> (0 :: int) \<le> x) \<and> (let by' :: sdata list = table (current_timestamp rhob) x in list_forall (inv rhob) by' \<longrightarrow> (case by' of Cons (Assign by'1) _ \<Rightarrow> (nlimpl_fo_term_ok t1 \<and> nlimpl_fo_term_ok by'1 \<and> unifier_subst_ok rhob rho \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field t1) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field by'1) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(x2 :: int). x2 \<in> set lv \<longrightarrow> lp x2 = True \<and> (0 :: int) \<le> x2) \<and> (\<forall>(x2 :: int). unassigned (current_timestamp rhob) x2 \<longrightarrow> lp x2 = True)) \<and> (\<forall>(rhob1 :: sdata t) (lv1 :: int list). inv rhob1 = inv rhob \<longrightarrow> (\<forall>(res :: unification_return). unifier_subst_ok rhob1 (final_unifier res) \<and> precede rhob rhob1 \<and> (\<forall>(x2 :: int). x2 \<in> set lv1 \<longrightarrow> lp x2 = True \<and> (0 :: int) \<le> x2) \<and> (\<forall>(x2 :: int). unassigned (current_timestamp rhob1) x2 \<longrightarrow> lp x2 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field by'1) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field by'1) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<longrightarrow> unifier_subst_ok rhob1 (final_unifier res) \<and> precede rhob rhob1 \<and> (\<forall>(x2 :: int). x2 \<in> set lv1 \<longrightarrow> lp x2 = True \<and> (0 :: int) \<le> x2) \<and> (\<forall>(x2 :: int). unassigned (current_timestamp rhob1) x2 \<longrightarrow> lp x2 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0))) | _ \<Rightarrow> (unifier_subst_ok rhob rho \<and> unassigned (current_timestamp rhob) x) \<and> ((let tm :: (int, int) fo_term = Var_fo_term x in tm = subst_fo_term tm subst_id_symbol (unifier_base_model rho) \<and> tm = subst_fo_term tm subst_id_symbol (unifier rho)) \<longrightarrow> (unifier_subst_ok rhob rho \<and> unassigned (current_timestamp rhob) x1) \<and> ((let tm :: (int, int) fo_term = Var_fo_term x1 in tm = subst_fo_term tm subst_id_symbol (unifier_base_model rho) \<and> tm = subst_fo_term tm subst_id_symbol (unifier rho)) \<longrightarrow> (if x1 < x then ((0 :: int) \<le> x1 \<and> nlimpl_fo_term_ok t2 \<and> unifier_subst_ok rhob rho \<and> unassigned (current_timestamp rhob) x1 \<and> \<not>subst_fo_term (model_fo_term_field t2) subst_id_symbol (unifier rho) = Var_fo_term x1 \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field t2) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(x2 :: int). x2 \<in> set lv \<longrightarrow> lp x2 = True \<and> (0 :: int) \<le> x2) \<and> (\<forall>(x2 :: int). unassigned (current_timestamp rhob) x2 \<longrightarrow> lp x2 = True)) \<and> (\<forall>(rhob1 :: sdata t) (lv1 :: int list). inv rhob1 = inv rhob \<longrightarrow> (\<forall>(result :: unification_return). (\<forall>(x2 :: int). x2 \<in> set lv1 \<longrightarrow> lp x2 = True \<and> (0 :: int) \<le> x2) \<and> (\<forall>(x2 :: int). unassigned (current_timestamp rhob1) x2 \<longrightarrow> lp x2 = True) \<and> unifier_subst_ok rhob1 (final_unifier result) \<and> precede rhob rhob1 \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in s' x1 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result) in s0 x1 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<longrightarrow> unifier_subst_ok rhob1 (final_unifier result) \<and> precede rhob rhob1 \<and> (\<forall>(x2 :: int). x2 \<in> set lv1 \<longrightarrow> lp x2 = True \<and> (0 :: int) \<le> x2) \<and> (\<forall>(x2 :: int). unassigned (current_timestamp rhob1) x2 \<longrightarrow> lp x2 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0))) else ((0 :: int) \<le> x \<and> nlimpl_fo_term_ok t1 \<and> unifier_subst_ok rhob rho \<and> unassigned (current_timestamp rhob) x \<and> \<not>subst_fo_term (model_fo_term_field t1) subst_id_symbol (unifier rho) = Var_fo_term x \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field t1) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(x2 :: int). x2 \<in> set lv \<longrightarrow> lp x2 = True \<and> (0 :: int) \<le> x2) \<and> (\<forall>(x2 :: int). unassigned (current_timestamp rhob) x2 \<longrightarrow> lp x2 = True)) \<and> (\<forall>(rhob1 :: sdata t) (lv1 :: int list). inv rhob1 = inv rhob \<longrightarrow> (\<forall>(result :: unification_return). (\<forall>(x2 :: int). x2 \<in> set lv1 \<longrightarrow> lp x2 = True \<and> (0 :: int) \<le> x2) \<and> (\<forall>(x2 :: int). unassigned (current_timestamp rhob1) x2 \<longrightarrow> lp x2 = True) \<and> unifier_subst_ok rhob1 (final_unifier result) \<and> precede rhob rhob1 \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in s' x = subst_fo_term (model_fo_term_field t1) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result) in s0 x = subst_fo_term (model_fo_term_field t1) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<longrightarrow> unifier_subst_ok rhob1 (final_unifier result) \<and> precede rhob rhob1 \<and> (\<forall>(x2 :: int). x2 \<in> set lv1 \<longrightarrow> lp x2 = True \<and> (0 :: int) \<le> x2) \<and> (\<forall>(x2 :: int). unassigned (current_timestamp rhob1) x2 \<longrightarrow> lp x2 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0))))))))))) | NLC_App x1 x2 \<Rightarrow> (correct rhob \<and> (0 :: int) \<le> x) \<and> (let bx :: sdata list = table (current_timestamp rhob) x in list_forall (inv rhob) bx \<longrightarrow> (case bx of Cons (Assign bx1) _ \<Rightarrow> (nlimpl_fo_term_ok t1 \<and> nlimpl_fo_term_ok bx1 \<and> unifier_subst_ok rhob rho \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field t1) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field bx1) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(x3 :: int). x3 \<in> set lv \<longrightarrow> lp x3 = True \<and> (0 :: int) \<le> x3) \<and> (\<forall>(x3 :: int). unassigned (current_timestamp rhob) x3 \<longrightarrow> lp x3 = True)) \<and> (\<forall>(rhob1 :: sdata t) (lv1 :: int list). inv rhob1 = inv rhob \<longrightarrow> (\<forall>(res :: unification_return). unifier_subst_ok rhob1 (final_unifier res) \<and> precede rhob rhob1 \<and> (\<forall>(x3 :: int). x3 \<in> set lv1 \<longrightarrow> lp x3 = True \<and> (0 :: int) \<le> x3) \<and> (\<forall>(x3 :: int). unassigned (current_timestamp rhob1) x3 \<longrightarrow> lp x3 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field bx1) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field bx1) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<longrightarrow> unifier_subst_ok rhob1 (final_unifier res) \<and> precede rhob rhob1 \<and> (\<forall>(x3 :: int). x3 \<in> set lv1 \<longrightarrow> lp x3 = True \<and> (0 :: int) \<le> x3) \<and> (\<forall>(x3 :: int). unassigned (current_timestamp rhob1) x3 \<longrightarrow> lp x3 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0))) | _ \<Rightarrow> ((0 :: int) \<le> x \<and> nlimpl_fo_term_ok t1 \<and> unifier_subst_ok rhob rho \<and> unassigned (current_timestamp rhob) x \<and> \<not>subst_fo_term (model_fo_term_field t1) subst_id_symbol (unifier rho) = Var_fo_term x \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field t1) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(x3 :: int). x3 \<in> set lv \<longrightarrow> lp x3 = True \<and> (0 :: int) \<le> x3) \<and> (\<forall>(x3 :: int). unassigned (current_timestamp rhob) x3 \<longrightarrow> lp x3 = True)) \<and> (\<forall>(rhob1 :: sdata t) (lv1 :: int list). inv rhob1 = inv rhob \<longrightarrow> (\<forall>(result :: unification_return). (\<forall>(x3 :: int). x3 \<in> set lv1 \<longrightarrow> lp x3 = True \<and> (0 :: int) \<le> x3) \<and> (\<forall>(x3 :: int). unassigned (current_timestamp rhob1) x3 \<longrightarrow> lp x3 = True) \<and> unifier_subst_ok rhob1 (final_unifier result) \<and> precede rhob rhob1 \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in s' x = subst_fo_term (model_fo_term_field t1) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result) in s0 x = subst_fo_term (model_fo_term_field t1) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<longrightarrow> unifier_subst_ok rhob1 (final_unifier result) \<and> precede rhob rhob1 \<and> (\<forall>(x3 :: int). x3 \<in> set lv1 \<longrightarrow> lp x3 = True \<and> (0 :: int) \<le> x3) \<and> (\<forall>(x3 :: int). unassigned (current_timestamp rhob1) x3 \<longrightarrow> lp x3 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0)))))) | NLC_App x x1 \<Rightarrow> (case o2 of NLC_App x2 x3 \<Rightarrow> nlimpl_symbol_ok x \<and> (\<forall>(o3 :: int). let o4 :: cons_symbol = NLCVar_symbol o3 in cons_ok_symbol o4 \<and> cons_rel_symbol o4 x \<and> cons_open_rel_symbol o4 x \<longrightarrow> nlimpl_symbol_ok x2 \<and> (\<forall>(o5 :: int). let o6 :: cons_symbol = NLCVar_symbol o5 in cons_ok_symbol o6 \<and> cons_rel_symbol o6 x2 \<and> cons_open_rel_symbol o6 x2 \<longrightarrow> (if o5 = o3 then (nlimpl_fo_term_list_ok x3 \<and> nlimpl_fo_term_list_ok x1 \<and> unifier_subst_ok rhob rho \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term_list y (model_fo_term_list_field x3) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term_list y (model_fo_term_list_field x1) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(x4 :: int). x4 \<in> set lv \<longrightarrow> lp x4 = True \<and> (0 :: int) \<le> x4) \<and> (\<forall>(x4 :: int). unassigned (current_timestamp rhob) x4 \<longrightarrow> lp x4 = True)) \<and> (\<forall>(rhob1 :: sdata t) (lv1 :: int list). inv rhob1 = inv rhob \<longrightarrow> (\<forall>(result :: unification_return). unifier_subst_ok rhob1 (final_unifier result) \<and> precede rhob rhob1 \<and> (\<forall>(x4 :: int). x4 \<in> set lv1 \<longrightarrow> lp x4 = True \<and> (0 :: int) \<le> x4) \<and> (\<forall>(x4 :: int). unassigned (current_timestamp rhob1) x4 \<longrightarrow> lp x4 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term_list (model_fo_term_list_field x3) subst_id_symbol s' = subst_fo_term_list (model_fo_term_list_field x1) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result) in subst_fo_term_list (model_fo_term_list_field x3) subst_id_symbol s0 = subst_fo_term_list (model_fo_term_list_field x1) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<longrightarrow> unifier_subst_ok rhob1 (final_unifier result) \<and> precede rhob rhob1 \<and> (\<forall>(x4 :: int). x4 \<in> set lv1 \<longrightarrow> lp x4 = True \<and> (0 :: int) \<le> x4) \<and> (\<forall>(x4 :: int). unassigned (current_timestamp rhob1) x4 \<longrightarrow> lp x4 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0))) else precede rhob rhob \<and> correct rhob))) | NLCVar_fo_term x2 \<Rightarrow> (correct rhob \<and> (0 :: int) \<le> x2) \<and> (let bx :: sdata list = table (current_timestamp rhob) x2 in list_forall (inv rhob) bx \<longrightarrow> (case bx of Cons (Assign bx1) _ \<Rightarrow> (nlimpl_fo_term_ok bx1 \<and> nlimpl_fo_term_ok t2 \<and> unifier_subst_ok rhob rho \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field bx1) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field t2) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(x3 :: int). x3 \<in> set lv \<longrightarrow> lp x3 = True \<and> (0 :: int) \<le> x3) \<and> (\<forall>(x3 :: int). unassigned (current_timestamp rhob) x3 \<longrightarrow> lp x3 = True)) \<and> (\<forall>(rhob1 :: sdata t) (lv1 :: int list). inv rhob1 = inv rhob \<longrightarrow> (\<forall>(res :: unification_return). unifier_subst_ok rhob1 (final_unifier res) \<and> precede rhob rhob1 \<and> (\<forall>(x3 :: int). x3 \<in> set lv1 \<longrightarrow> lp x3 = True \<and> (0 :: int) \<le> x3) \<and> (\<forall>(x3 :: int). unassigned (current_timestamp rhob1) x3 \<longrightarrow> lp x3 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field bx1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res) in subst_fo_term (model_fo_term_field bx1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<longrightarrow> unifier_subst_ok rhob1 (final_unifier res) \<and> precede rhob rhob1 \<and> (\<forall>(x3 :: int). x3 \<in> set lv1 \<longrightarrow> lp x3 = True \<and> (0 :: int) \<le> x3) \<and> (\<forall>(x3 :: int). unassigned (current_timestamp rhob1) x3 \<longrightarrow> lp x3 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier res); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0))) | _ \<Rightarrow> ((0 :: int) \<le> x2 \<and> nlimpl_fo_term_ok t2 \<and> unifier_subst_ok rhob rho \<and> unassigned (current_timestamp rhob) x2 \<and> \<not>subst_fo_term (model_fo_term_field t2) subst_id_symbol (unifier rho) = Var_fo_term x2 \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field t2) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(x3 :: int). x3 \<in> set lv \<longrightarrow> lp x3 = True \<and> (0 :: int) \<le> x3) \<and> (\<forall>(x3 :: int). unassigned (current_timestamp rhob) x3 \<longrightarrow> lp x3 = True)) \<and> (\<forall>(rhob1 :: sdata t) (lv1 :: int list). inv rhob1 = inv rhob \<longrightarrow> (\<forall>(result :: unification_return). (\<forall>(x3 :: int). x3 \<in> set lv1 \<longrightarrow> lp x3 = True \<and> (0 :: int) \<le> x3) \<and> (\<forall>(x3 :: int). unassigned (current_timestamp rhob1) x3 \<longrightarrow> lp x3 = True) \<and> unifier_subst_ok rhob1 (final_unifier result) \<and> precede rhob rhob1 \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in s' x2 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result) in s0 x2 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<longrightarrow> unifier_subst_ok rhob1 (final_unifier result) \<and> precede rhob rhob1 \<and> (\<forall>(x3 :: int). x3 \<in> set lv1 \<longrightarrow> lp x3 = True \<and> (0 :: int) \<le> x3) \<and> (\<forall>(x3 :: int). unassigned (current_timestamp rhob1) x3 \<longrightarrow> lp x3 = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier result); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0))))))))"
  sorry
end
