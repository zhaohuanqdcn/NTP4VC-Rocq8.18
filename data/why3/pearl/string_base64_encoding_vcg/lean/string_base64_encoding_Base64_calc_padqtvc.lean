import Why3.Base
import Why3.string.StringBuffer
open Classical
open Lean4Why3
namespace string_base64_encoding_Base64_calc_padqtvc
noncomputable def int2b64 (i : ℤ) := if (0 : ℤ) ≤ i ∧ i ≤ (25 : ℤ) then BitVec.ofNat 8 (Int.toNat (i + (65 : ℤ))) else if (26 : ℤ) ≤ i ∧ i ≤ (51 : ℤ) then BitVec.ofNat 8 (Int.toNat (i - (26 : ℤ) + (97 : ℤ))) else if (52 : ℤ) ≤ i ∧ i ≤ (61 : ℤ) then BitVec.ofNat 8 (Int.toNat (i - (52 : ℤ) + (48 : ℤ))) else if i = (62 : ℤ) then BitVec.ofNat 8 (43 : ℕ) else if i = (63 : ℤ) then BitVec.ofNat 8 (47 : ℕ) else BitVec.ofNat 8 (0 : ℕ)
noncomputable def valid_b64_char (c : BitVec 8) := (65 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (90 : ℤ) ∨ (97 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (122 : ℤ) ∨ (48 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (57 : ℤ) ∨ BitVec.toInt c = (43 : ℤ) ∨ BitVec.toInt c = (47 : ℤ)
noncomputable def b642int (c : BitVec 8) := if (65 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (90 : ℤ) then BitVec.toInt c - (65 : ℤ) else if (97 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (122 : ℤ) then BitVec.toInt c - (97 : ℤ) + (26 : ℤ) else if (48 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (57 : ℤ) then BitVec.toInt c - (48 : ℤ) + (52 : ℤ) else if BitVec.toInt c = (43 : ℤ) then (62 : ℤ) else if BitVec.toInt c = (47 : ℤ) then (63 : ℤ) else if c = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) then (0 : ℤ) else (64 : ℤ)
noncomputable def get_pad (s : List (BitVec 8)) := if (1 : ℤ) ≤ Int.ofNat (List.length s) ∧ s[Int.toNat (Int.ofNat (List.length s) - (1 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) then if (2 : ℤ) ≤ Int.ofNat (List.length s) ∧ s[Int.toNat (Int.ofNat (List.length s) - (2 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) then (2 : ℤ) else (1 : ℤ) else (0 : ℤ)
noncomputable def calc_pad (s : List (BitVec 8)) := if Int.tmod (Int.ofNat (List.length s)) (3 : ℤ) = (1 : ℤ) then (2 : ℤ) else if Int.tmod (Int.ofNat (List.length s)) (3 : ℤ) = (2 : ℤ) then (1 : ℤ) else (0 : ℤ)
theorem calc_pad'vc (o1 : BitVec 63) (s : List (BitVec 8)) (fact0 : BitVec.toInt o1 = Int.ofNat (List.length s)) (fact1 : (0 : ℤ) ≤ Int.ofNat (List.length s)) : ¬(3 : ℤ) = (0 : ℤ) ∧ int'63_in_bounds (Int.tmod (BitVec.toInt o1) (3 : ℤ)) ∧ (∀(o2 : BitVec 63), BitVec.toInt o2 = Int.tmod (BitVec.toInt o1) (3 : ℤ) → (BitVec.toInt o2 = (1 : ℤ) → o2 = (1 : BitVec 63)) → (if o2 = (1 : BitVec 63) then (2 : ℤ) = calc_pad s else ∀(o3 : BitVec 63), BitVec.toInt o3 = Int.ofNat (List.length s) ∧ (0 : ℤ) ≤ Int.ofNat (List.length s) → (¬(3 : ℤ) = (0 : ℤ) ∧ int'63_in_bounds (Int.tmod (BitVec.toInt o3) (3 : ℤ))) ∧ (∀(o4 : BitVec 63), BitVec.toInt o4 = Int.tmod (BitVec.toInt o3) (3 : ℤ) → (BitVec.toInt o4 = (2 : ℤ) → o4 = (2 : BitVec 63)) → (∀(result : BitVec 63), (if o4 = (2 : BitVec 63) then result = (1 : BitVec 63) else result = (0 : BitVec 63)) → BitVec.toInt result = calc_pad s))))
  := sorry
end string_base64_encoding_Base64_calc_padqtvc
