theory remove_duplicate_RemoveDuplicateQuadratic_remove_duplicateqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "./remove_duplicate_Spec"
begin
typedecl  t
consts eq :: "t \<Rightarrow> t \<Rightarrow> bool"
axiomatization where eq'spec:   "eq x y \<longleftrightarrow> x = y"
  for x :: "t"
  and y :: "t"
theorem remove_duplicate'vc:
  fixes a :: "t list"
  shows "let n :: int = int (length a) in (0 :: int) \<le> n \<and> (\<forall>(from1 :: int list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> from1 ! nat i = (0 :: int)) \<and> int (length from1) = n \<longrightarrow> (0 :: int) \<le> n \<and> (\<forall>(to' :: int list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> to' ! nat i = (0 :: int)) \<and> int (length to') = n \<longrightarrow> (let o1 :: int = n - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((0 :: int) \<le> (0 :: int) \<and> nodup a (0 :: int) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> ((0 :: int) \<le> to' ! nat j \<and> to' ! nat j < (0 :: int)) \<and> a ! nat j = a ! nat (to' ! nat j)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> ((0 :: int) \<le> from1 ! nat j \<and> from1 ! nat j < (0 :: int)) \<and> a ! nat j = a ! nat (from1 ! nat j))) \<and> (\<forall>(to_1 :: int list) (from2 :: int list) (r :: int) (a1 :: t list). length to_1 = length to' \<longrightarrow> length from2 = length from1 \<longrightarrow> length a1 = length a \<longrightarrow> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o1) \<and> ((0 :: int) \<le> r \<and> r \<le> i) \<and> nodup a1 r \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < r \<longrightarrow> ((0 :: int) \<le> to_1 ! nat j \<and> to_1 ! nat j < i) \<and> a1 ! nat j = a ! nat (to_1 ! nat j)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> ((0 :: int) \<le> from2 ! nat j \<and> from2 ! nat j < r) \<and> a ! nat j = a1 ! nat (from2 ! nat j)) \<and> (\<forall>(j :: int). i \<le> j \<and> j < n \<longrightarrow> a1 ! nat j = a ! nat j) \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a1)) \<and> (let o2 :: t = a1 ! nat i in ((0 :: int) \<le> r \<and> r \<le> int (length a1)) \<and> (\<forall>(w :: int). (appears o2 a1 r \<longrightarrow> ((0 :: int) \<le> w \<and> w < r) \<and> a1 ! nat w = o2) \<longrightarrow> (if \<not>appears o2 a1 r then ((0 :: int) \<le> i \<and> i < int (length a1)) \<and> (let o3 :: t = a1 ! nat i in ((0 :: int) \<le> r \<and> r < int (length a1)) \<and> (length (a1[nat r := o3]) = length a1 \<longrightarrow> nth (a1[nat r := o3]) o nat = (nth a1 o nat)(r := o3) \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length from2)) \<and> (length (from2[nat i := r]) = length from2 \<longrightarrow> nth (from2[nat i := r]) o nat = (nth from2 o nat)(i := r) \<longrightarrow> ((0 :: int) \<le> r \<and> r < int (length to_1)) \<and> (length (to_1[nat r := i]) = length to_1 \<longrightarrow> nth (to_1[nat r := i]) o nat = (nth to_1 o nat)(r := i) \<longrightarrow> ((0 :: int) \<le> r + (1 :: int) \<and> r + (1 :: int) \<le> i + (1 :: int)) \<and> nodup (a1[nat r := o3]) (r + (1 :: int)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < r + (1 :: int) \<longrightarrow> ((0 :: int) \<le> to_1[nat r := i] ! nat j \<and> to_1[nat r := i] ! nat j < i + (1 :: int)) \<and> a1[nat r := o3] ! nat j = a ! nat (to_1[nat r := i] ! nat j)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> ((0 :: int) \<le> from2[nat i := r] ! nat j \<and> from2[nat i := r] ! nat j < r + (1 :: int)) \<and> a ! nat j = a1[nat r := o3] ! nat (from2[nat i := r] ! nat j)) \<and> (\<forall>(j :: int). i + (1 :: int) \<le> j \<and> j < n \<longrightarrow> a1[nat r := o3] ! nat j = a ! nat j))))) else ((0 :: int) \<le> i \<and> i < int (length from2)) \<and> (length (from2[nat i := w]) = length from2 \<longrightarrow> nth (from2[nat i := w]) o nat = (nth from2 o nat)(i := w) \<longrightarrow> ((0 :: int) \<le> r \<and> r \<le> i + (1 :: int)) \<and> nodup a1 r \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < r \<longrightarrow> ((0 :: int) \<le> to_1 ! nat j \<and> to_1 ! nat j < i + (1 :: int)) \<and> a1 ! nat j = a ! nat (to_1 ! nat j)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> ((0 :: int) \<le> from2[nat i := w] ! nat j \<and> from2[nat i := w] ! nat j < r) \<and> a ! nat j = a1 ! nat (from2[nat i := w] ! nat j)) \<and> (\<forall>(j :: int). i + (1 :: int) \<le> j \<and> j < n \<longrightarrow> a1 ! nat j = a ! nat j)))))) \<and> (((0 :: int) \<le> r \<and> r \<le> o1 + (1 :: int)) \<and> nodup a1 r \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < r \<longrightarrow> ((0 :: int) \<le> to_1 ! nat j \<and> to_1 ! nat j < o1 + (1 :: int)) \<and> a1 ! nat j = a ! nat (to_1 ! nat j)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < o1 + (1 :: int) \<longrightarrow> ((0 :: int) \<le> from2 ! nat j \<and> from2 ! nat j < r) \<and> a ! nat j = a1 ! nat (from2 ! nat j)) \<and> (\<forall>(j :: int). o1 + (1 :: int) \<le> j \<and> j < n \<longrightarrow> a1 ! nat j = a ! nat j) \<longrightarrow> ((0 :: int) \<le> r \<and> r \<le> int (length a1)) \<and> nodup a1 r \<and> (\<forall>(v :: t). appears v a (int (length a1)) \<longleftrightarrow> appears v a1 r)))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> int (length a)) \<and> nodup a (0 :: int) \<and> (\<forall>(v :: t). appears v a (int (length a)) \<longleftrightarrow> appears v a (0 :: int))))))"
  sorry
end
