import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.mpz.Z
import pearl.multiprecision.lib.lean.mpz.Zutil
open Classical
open Lean4Why3
namespace mpz_realloc2_Zrealloc2_wmpz_realloc2qtvc
noncomputable def alloc_of_bits (bits : ℤ) := if bits ≤ (0 : ℤ) then (1 : ℤ) else (bits + (63 : ℤ)) / (64 : ℤ)
theorem wmpz_realloc2'vc (mpz : Z.mpz_memo) (x : Z.mpz_ptr) (bits : BitVec 64) (o1 : BitVec 64) (fact0 : Z.readers mpz x = (0 : ℤ)) (fact1 : (BitVec.toUInt bits - (1 : ℤ)) / (64 : ℤ) < (2147483647 : ℤ)) (fact2 : (1 : ℤ) ≤ Z.alloc mpz x) (fact3 : BitVec.toUInt bits = (0 : ℤ) → bits = (0 : BitVec 64)) (fact4 : if ¬bits = (0 : BitVec 64) then o1 = (1 : BitVec 64) else o1 = (0 : BitVec 64)) : uint'64_in_bounds (BitVec.toUInt bits - BitVec.toUInt o1) ∧ (∀(bits1 : BitVec 64), BitVec.toUInt bits1 = BitVec.toUInt bits - BitVec.toUInt o1 → (¬(64 : ℤ) = (0 : ℤ) ∧ uint'64_in_bounds (Int.tdiv (BitVec.toUInt bits1) (64 : ℤ))) ∧ (∀(o2 : BitVec 64), BitVec.toUInt o2 = Int.tdiv (BitVec.toUInt bits1) (64 : ℤ) → uint'64_in_bounds ((1 : ℤ) + BitVec.toUInt o2) ∧ (∀(o3 : BitVec 64), BitVec.toUInt o3 = (1 : ℤ) + BitVec.toUInt o2 → BitVec.toUInt o3 ≤ (2147483647 : ℤ) ∧ (∀(new_alloc : BitVec 32), BitVec.toInt new_alloc = BitVec.toUInt o3 → Z.readers mpz x = (0 : ℤ) ∧ (∀(mpz1 : Z.mpz_memo), Z.abs_value_of mpz1 = Z.abs_value_of mpz ∧ Z.alloc mpz1 = Z.alloc mpz ∧ Z.abs_size mpz1 = Z.abs_size mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(p : C.ptr (BitVec 64)), Z.readers mpz1 x = -(1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬x = y → Z.readers mpz1 y = Z.readers mpz y) ∧ Lemmas.value p (Z.abs_size mpz1 x) = Z.abs_value_of mpz1 x ∧ C.plength p = Z.alloc mpz1 x ∧ C.offset p = (0 : ℤ) ∧ C.min p = (0 : ℤ) ∧ C.max p = C.plength p ∧ C.writable p = true ∧ C.zone1 p = Z.zones mpz1 x → -(2 : ℤ) < Z.readers mpz1 x ∧ (∀(os : BitVec 32), BitVec.toInt os = Z.abs_size mpz1 x → ((0 : ℤ) ≤ BitVec.toInt new_alloc ∧ C.offset p = (0 : ℤ) ∧ C.min p = (0 : ℤ) ∧ C.max p = C.plength p ∧ (0 : ℤ) < C.plength p ∧ C.writable p = true) ∧ (∀(p1 : C.ptr (BitVec 64)), C.offset p1 = C.offset p ∧ C.writable p1 = C.writable p ∧ C.zone1 p1 = C.zone1 p → (∀(q : C.ptr (BitVec 64)), C.writable q = true ∧ (¬C.zone1 q = C.null_zone → C.min q = (0 : ℤ)) ∧ (¬C.zone1 q = C.null_zone → C.max q = C.plength q) ∧ C.offset q = (0 : ℤ) ∧ (¬C.zone1 q = C.null_zone → C.plength q = BitVec.toInt new_alloc) ∧ (¬C.zone1 q = C.null_zone → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < C.plength p) ∧ i < BitVec.toInt new_alloc → C.pelts q i = C.pelts p i)) ∧ (C.zone1 q = C.null_zone → p1 = p) → C.is_not_null q = (¬C.zone1 q = C.null_zone) → C.is_not_null q → -(2 : ℤ) < Z.readers mpz1 x ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = Z.abs_size mpz1 x → (if BitVec.toInt new_alloc < BitVec.toInt o4 then (-(1 : ℤ) ≤ Z.readers mpz1 x ∧ Z.readers mpz1 x ≤ (0 : ℤ)) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz2 mpz1) ∧ Z.abs_size mpz2 x = (0 : ℤ) ∧ Z.abs_value_of mpz2 x = (0 : ℤ) → (Z.abs_size mpz2 x ≤ BitVec.toInt new_alloc ∧ -(1 : ℤ) ≤ Z.readers mpz2 x ∧ Z.readers mpz2 x ≤ (0 : ℤ)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.readers mpz3 = Z.readers mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz3 mpz2) ∧ Z.alloc mpz3 x = BitVec.toInt new_alloc → (C.offset q = (0 : ℤ) ∧ C.writable q = true ∧ C.min q = (0 : ℤ) ∧ C.max q = C.plength q ∧ C.plength q = Z.alloc mpz3 x ∧ (Z.readers mpz3 x = (0 : ℤ) ∨ Z.readers mpz3 x = -(1 : ℤ))) ∧ (∀(mpz4 : Z.mpz_memo), Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz4 mpz3) ∧ Z.abs_value_of mpz4 x = Lemmas.value q (Z.abs_size mpz4 x) ∧ Z.readers mpz4 x = -(1 : ℤ) ∧ Z.zones mpz4 x = C.zone1 q → (Z.zones mpz4 x = C.zone1 q ∧ Z.readers mpz4 x = -(1 : ℤ) ∧ C.min q = (0 : ℤ) ∧ C.max q = C.plength q ∧ Z.abs_value_of mpz4 x = Lemmas.value q (Z.abs_size mpz4 x)) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 x = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = x → Z.readers mpz5 y = Z.readers mpz4 y) → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz5 mpz) ∧ Z.readers mpz5 x = (0 : ℤ) ∧ Z.alloc mpz5 x = alloc_of_bits (BitVec.toUInt bits) ∧ (if Z.abs_size mpz x ≤ alloc_of_bits (BitVec.toUInt bits) then Z.abs_size mpz5 x = Z.abs_size mpz x ∧ Z.abs_value_of mpz5 x = Z.abs_value_of mpz x else Z.abs_size mpz5 x = (0 : ℤ)))))) else (Z.abs_size mpz1 x ≤ BitVec.toInt new_alloc ∧ -(1 : ℤ) ≤ Z.readers mpz1 x ∧ Z.readers mpz1 x ≤ (0 : ℤ)) ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz2 mpz1) ∧ Z.alloc mpz2 x = BitVec.toInt new_alloc → (C.offset q = (0 : ℤ) ∧ C.writable q = true ∧ C.min q = (0 : ℤ) ∧ C.max q = C.plength q ∧ C.plength q = Z.alloc mpz2 x ∧ (Z.readers mpz2 x = (0 : ℤ) ∨ Z.readers mpz2 x = -(1 : ℤ))) ∧ (∀(mpz3 : Z.mpz_memo), Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz3 mpz2) ∧ Z.abs_value_of mpz3 x = Lemmas.value q (Z.abs_size mpz3 x) ∧ Z.readers mpz3 x = -(1 : ℤ) ∧ Z.zones mpz3 x = C.zone1 q → (Z.zones mpz3 x = C.zone1 q ∧ Z.readers mpz3 x = -(1 : ℤ) ∧ C.min q = (0 : ℤ) ∧ C.max q = C.plength q ∧ Z.abs_value_of mpz3 x = Lemmas.value q (Z.abs_size mpz3 x)) ∧ (∀(mpz4 : Z.mpz_memo), Z.abs_value_of mpz4 = Z.abs_value_of mpz3 ∧ Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → Z.readers mpz4 x = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = x → Z.readers mpz4 y = Z.readers mpz3 y) → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz4 mpz) ∧ Z.readers mpz4 x = (0 : ℤ) ∧ Z.alloc mpz4 x = alloc_of_bits (BitVec.toUInt bits) ∧ (if Z.abs_size mpz x ≤ alloc_of_bits (BitVec.toUInt bits) then Z.abs_size mpz4 x = Z.abs_size mpz x ∧ Z.abs_value_of mpz4 x = Z.abs_value_of mpz x else Z.abs_size mpz4 x = (0 : ℤ))))))))))))))))
  := sorry
end mpz_realloc2_Zrealloc2_wmpz_realloc2qtvc
