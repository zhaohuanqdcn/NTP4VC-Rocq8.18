module Funcs

  use option.Option
  use Functions.Func

  (* Abstraction definition axiom :
       constant some : 'a -> (option 'a) = (\ x:'a. Some x) *)
  constant some : 'a -> (option 'a)
  axiom some_def : forall x:'a. some x = Some x

  (* Abstraction definition axiom :
       constant ocase (f:'a -> 'b) (d:'b) : (option 'a) -> 'b =
         (\ x:'a. match x with None -> d | Some x -> f x end) *)
  function ocase (f:'a -> 'b) (d:'b) : (option 'a) -> 'b
  axiom ocase_def : forall f:'a -> 'b,d:'b,x:option 'a.
    ocase f d x = match x with None -> d | Some x -> f x end

  let ghost ocase_some (f:'a -> 'b) (d:'b) (x:'a) : unit
    ensures { ocase f d (Some x) = f x }
  = ()
  let ghost ocase_none (f:'a -> 'b) (d:'b) : unit
    ensures { ocase f d None = d }
  = ()
  let ghost compose_ocase_some (f:'a -> 'b) (d:'b) : unit
    ensures { rcompose some (ocase f d) = f }
  = ()

  function omap (f:'a -> 'b) (x:option 'a) : option 'b = match x with
    | None -> None
    | Some x -> Some (f x)
  end
  function olift (f:'a -> 'b) : (option 'a) -> (option 'b) = ocase (compose some f) None
  let ghost olift_def (f:'a -> 'b) (x:option 'a) : unit
    ensures { olift f x = omap f x }
  = ()

  let ghost olift_none (f:'a -> 'b) : unit
    ensures { olift f None = None }
  = ()
  let ghost olift_some (f:'a -> 'b) (x:'a) : unit
    ensures { olift f (Some x) = Some (f x) }
  = ()
  let ghost olift_none_inversion (f:'a -> 'b) (x:option 'a) : unit
    ensures { olift f x = None <-> x = None }
  = ()
  let ghost olift_some_inversion (f:'a -> 'b) (x:option 'a) (y:'b) : unit
    ensures { olift f x = Some y <->
      match x with None -> false | Some x' -> f x' = y end }
  =
    match x with
      | None -> ()
      | Some _x' -> ()
    end

  let ghost olift_identity (_:'a) : unit
    ensures { olift (identity:'a -> 'a) = identity }
  = ()

  let ghost olift_composition (g:'b-> 'c) (f:'a -> 'b) : unit
    ensures { compose (olift g) (olift f) = olift (compose g f) }
  = ()

  let ghost olift_some_commutation (f:'a -> 'b) : unit
    ensures { compose some f = compose (olift f) some }
  = ()

  let ghost olift_update (f:'a -> 'b) (x:'a) (y:'b) : unit
    ensures { olift (f[x<-y]) = (olift f)[Some x <- Some y] }
  = ()

end
