theory patience_PatienceAbstract_play_cardsqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const"
begin
typedecl  card
datatype  state = state'mk (num_stacks: "int") (num_elts: "int") ("values": "int \<Rightarrow> int") (stack_sizes: "int \<Rightarrow> int") (stacks1: "int \<Rightarrow> int \<Rightarrow> int") (positions: "int \<Rightarrow> int \<times> int") (preds: "int \<Rightarrow> int")
definition inv :: "state \<Rightarrow> _"
  where "inv s \<longleftrightarrow> ((0 :: int) \<le> num_stacks s \<and> num_stacks s \<le> num_elts s) \<and> ((0 :: int) < num_elts s \<longrightarrow> (0 :: int) < num_stacks s) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_stacks s \<longrightarrow> (1 :: int) \<le> stack_sizes s i \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < stack_sizes s i \<longrightarrow> (0 :: int) \<le> stacks1 s i j \<and> stacks1 s i j < num_elts s)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_elts s \<longrightarrow> (case positions s i of (is, ip) \<Rightarrow> ((0 :: int) \<le> is \<and> is < num_stacks s) \<and> ((0 :: int) \<le> ip \<and> ip < stack_sizes s is) \<and> stacks1 s is ip = i)) \<and> (\<forall>(is :: int). (0 :: int) \<le> is \<and> is < num_stacks s \<longrightarrow> (\<forall>(ip :: int). (0 :: int) \<le> ip \<and> ip < stack_sizes s is \<longrightarrow> (is, ip) = positions s (stacks1 s is ip))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_stacks s \<longrightarrow> (let stack_i :: int \<Rightarrow> int = stacks1 s i in \<forall>(j :: int) (k :: int). (0 :: int) \<le> j \<and> j < k \<and> k < stack_sizes s i \<longrightarrow> stack_i j < stack_i k)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_stacks s \<longrightarrow> (let stack_i :: int \<Rightarrow> int = stacks1 s i in \<forall>(j :: int) (k :: int). (0 :: int) \<le> j \<and> j \<le> k \<and> k < stack_sizes s i \<longrightarrow> values s (stack_i k) \<le> values s (stack_i j))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_elts s \<longrightarrow> (let pred :: int = preds s i in (-(1 :: int) \<le> pred \<and> pred < num_elts s) \<and> pred < i \<and> (case positions s i of (is, x_ip) \<Rightarrow> (if pred < (0 :: int) then is = (0 :: int) else values s pred < values s i \<and> (0 :: int) < is \<and> (case positions s pred of (ps, x_pp) \<Rightarrow> ps = is - (1 :: int))))))" for s
theorem play_cards'vc:
  fixes s :: "state"
  fixes input :: "int list"
  assumes fact0: "inv s"
  shows "case input of Nil \<Rightarrow> inv s \<and> num_elts s = num_elts s + int (length input) \<and> (\<forall>(i :: int). num_elts s \<le> i \<and> i < num_elts s \<longrightarrow> values s i = input ! nat (i - num_elts s)) | Cons c rem \<Rightarrow> inv s \<and> (\<forall>(s1 :: state). inv s1 \<and> num_elts s1 = num_elts s + (1 :: int) \<and> values s1 = (values s)(num_elts s := c) \<longrightarrow> ((case input of Nil \<Rightarrow> False | Cons _ f \<Rightarrow> f = rem) \<and> inv s1) \<and> (\<forall>(s2 :: state). inv s2 \<and> num_elts s2 = num_elts s1 + int (length rem) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_elts s1 \<longrightarrow> values s2 i = values s1 i) \<and> (\<forall>(i :: int). num_elts s1 \<le> i \<and> i < num_elts s2 \<longrightarrow> values s2 i = rem ! nat (i - num_elts s1)) \<longrightarrow> inv s2 \<and> num_elts s2 = num_elts s + int (length input) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_elts s \<longrightarrow> values s2 i = values s i) \<and> (\<forall>(i :: int). num_elts s \<le> i \<and> i < num_elts s2 \<longrightarrow> values s2 i = input ! nat (i - num_elts s))))"
  sorry
end
