From Stdlib Require Import Strings.String.
From Stdlib Require Import String Ascii.
From Stdlib Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Stdlib Require Classical.
From Stdlib Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Stdlib Require Import Sorting.Sorted.
From Stdlib Require Import Reals.Rbasic_fun.
From Stdlib Require Import Reals.Abstract.ConstructiveAbs.
From Stdlib Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Stdlib Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Stdlib Require Import ZArith.Zeuclid.
From Stdlib Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Stdlib Require Import Reals.
Require Import Why3.Base.
Require Import Why3.why3.Ref.Ref.
Require Import Why3.map.Const.
Require Import Why3.map.MapEq.
Require Import Why3.mach.int.Unsigned.
Require Import Why3.mach.c.C.
Require Import Why3.mach.c.String.
Require Import Why3.mach.c.StrlenLemmas.
Require Import Why3.mach.c.UChar.
Require Import multiprecision.lemmas.Lemmas.
Require Import multiprecision.types.Config.
Require Import multiprecision.types.Types.
Require Import multiprecision.types.Int32Eq.
Require Import multiprecision.types.UInt64Eq.
Require Import multiprecision.util.Util.
Require Import multiprecision.ptralias.Alias.
Require Import multiprecision.util.UtilOld.
Require Import multiprecision.mpz.Z.
Require Import multiprecision.mpz.Zutil.
Require Import multiprecision.base_info.BaseInfo.
Require Import multiprecision.logical.LogicalUtil.
Require Import multiprecision.logical.Logical.
Require Import multiprecision.logical.LogicalOld.
Require Import multiprecision.stringlemmas.String_lemmas.
Require Import multiprecision.stringlemmas.Conversions.
Require Import multiprecision.stringlemmas.String_value.
Require Import multiprecision.set_str.Set_str.
Require Import multiprecision.powm.Powm.
Require Import multiprecision.compare.Compare.
Require Import multiprecision.valuation.Valuation.
Require Import multiprecision.add.Add.
Require Import multiprecision.add.AddOld.
Require Import multiprecision.sub.SubOld.
Require Import multiprecision.mul.Mul.
Require Import multiprecision.mul.Mul_basecase.
Require Import multiprecision.div.Div.
Require Import multiprecision.toom.Toom.
Require Import multiprecision.add_1.Add_1.
Require Import multiprecision.sub_1.Sub_1.
Open Scope Z_scope.
Theorem wmpz_set_str'vc (sp : C.ptr ascii) (mpz : mpz_memo) (r : mpz_ptr) (base : bv 32%N) (fact0 : valid_string sp) (fact1 : strlen (pelts sp) (offset sp) * 8%Z + 63%Z ≤ 2147483647%Z) (fact2 : readers mpz r = 0%Z) (fact3 : 1%Z ≤ Z.alloc mpz r) (fact4 : 2%Z ≤ bv_signed base) (fact5 : bv_signed base ≤ 62%Z) : min sp ≤ offset sp ∧ offset sp < C.max sp ∧ (∀(sign : bv 32%N), (if decide (pelts sp (offset sp) = get_str_i "-"%string 0%Z) then sign = (1%bv : bv 32%N) else sign = (0%bv : bv 32%N)) -> valid_string sp ∧ (∀(slen : bv 32%N), bv_unsigned slen = strlen (pelts sp) (offset sp) -> (min sp ≤ offset sp + bv_signed sign ∧ offset sp + bv_signed sign ≤ C.max sp) ∧ (∀(o1 : C.ptr ascii), offset o1 = offset sp + bv_signed sign ∧ plength o1 = plength sp ∧ pelts o1 = pelts sp ∧ data o1 = data sp ∧ min o1 = min sp ∧ C.max o1 = C.max sp ∧ zone1 o1 = zone1 sp ∧ writable o1 = writable sp -> (min o1 ≤ offset o1 ∧ offset o1 < C.max o1) ∧ (if decide (pelts o1 (offset o1) = zero_char) then (- 1%Z ≤ readers mpz r ∧ readers mpz r ≤ 0%Z) ∧ (∀(mpz1 : mpz_memo), Z.alloc mpz1 = Z.alloc mpz ∧ sgn mpz1 = sgn mpz ∧ readers mpz1 = readers mpz ∧ zones mpz1 = zones mpz -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz1 mpz) ∧ abs_size mpz1 r = 0%Z ∧ abs_value_of mpz1 r = 0%Z -> (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz1 mpz) ∧ readers mpz1 r = 0%Z ∧ (- 1%Z = 0%Z -> value_of r mpz1 = value_text (bv_signed base) (pelts sp) (offset sp)) ∧ (- 1%Z ≤ - 1%Z ∧ - 1%Z ≤ 0%Z) ∧ (- 1%Z = 0%Z) = String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)) else valid_string sp ∧ (∀(o2 : bv 32%N), bv_unsigned o2 = strlen (pelts sp) (offset sp) -> 0%Z ≤ bv_unsigned o2 ∧ (∀(dp : C.ptr (bv 8%N)), plength dp = bv_unsigned o2 ∧ offset dp = 0%Z ∧ min dp = 0%Z ∧ C.max dp = bv_unsigned o2 ∧ writable dp = true -> (offset o1 = offset sp + bv_signed sign + 0%Z ∧ (offset sp + bv_signed sign ≤ offset o1 ∧ offset o1 ≤ offset sp + strlen (pelts sp) (offset sp)) ∧ (min sp ≤ offset o1 ∧ offset o1 ≤ C.max sp) ∧ abs_value_sub_text (bv_signed base) (pelts sp) (offset sp + bv_signed sign) (offset o1) = svalue_sub (bv_signed base) (pelts dp) 0%Z 0%Z ∧ in_base (bv_signed base) (pelts dp) 0%Z 0%Z ∧ (¬ Z.of_nat (Ascii.nat_of_ascii (pelts o1 (offset o1))) = 0%Z) = (offset o1 < offset sp + strlen (pelts sp) (offset sp)) ∧ (min o1 = min sp ∧ C.max o1 = C.max sp) ∧ plength o1 = plength sp ∧ pelts o1 = pelts sp ∧ text_in_base (bv_signed base) (pelts sp) (offset sp + bv_signed sign) (offset o1)) ∧ (∀(dn : bv 32%N) (dp1 : C.ptr (bv 8%N)) (spi : C.ptr ascii), length (data dp1) = length (data dp) ∧ offset dp1 = offset dp ∧ min dp1 = min dp ∧ C.max dp1 = C.max dp ∧ writable dp1 = writable dp ∧ zone1 dp1 = zone1 dp -> offset spi = offset sp + bv_signed sign + bv_signed dn ∧ (offset sp + bv_signed sign ≤ offset spi ∧ offset spi ≤ offset sp + strlen (pelts sp) (offset sp)) ∧ (min sp ≤ offset spi ∧ offset spi ≤ C.max sp) ∧ abs_value_sub_text (bv_signed base) (pelts sp) (offset sp + bv_signed sign) (offset spi) = svalue_sub (bv_signed base) (pelts dp1) 0%Z (bv_signed dn) ∧ in_base (bv_signed base) (pelts dp1) 0%Z (bv_signed dn) ∧ (¬ Z.of_nat (Ascii.nat_of_ascii (pelts spi (offset spi))) = 0%Z) = (offset spi < offset sp + strlen (pelts sp) (offset sp)) ∧ (min spi = min sp ∧ C.max spi = C.max sp) ∧ plength spi = plength sp ∧ pelts spi = pelts sp ∧ text_in_base (bv_signed base) (pelts sp) (offset sp + bv_signed sign) (offset spi) -> (min spi ≤ offset spi ∧ offset spi < C.max spi) ∧ (if decide (¬ pelts spi (offset spi) = zero_char) then (min spi ≤ offset spi ∧ offset spi < C.max spi) ∧ (let c : ascii := pelts spi (offset spi) in (if decide (36%Z < bv_signed base) then ∀(o3 : bv 32%N), bv_signed o3 = Z.of_nat (Ascii.nat_of_ascii c) -> (∀(o4 : bv 32%N), bv_signed o4 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "0"%string 0%Z)) -> (∀(o5 : bool), (if decide (bv_signed o4 ≤ bv_signed o3) then ∃(o6 : bv 32%N), bv_signed o6 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "9"%string 0%Z)) ∧ (∃(o7 : bv 32%N), bv_signed o7 = Z.of_nat (Ascii.nat_of_ascii c) ∧ o5 = (if decide (bv_signed o7 ≤ bv_signed o6) then true else false)) else o5 = false) -> (if decide (o5 = true) then ∀(o6 : bv 32%N), bv_signed o6 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "0"%string 0%Z)) -> (∀(o7 : bv 32%N), bv_signed o7 = Z.of_nat (Ascii.nat_of_ascii c) -> int'32_in_bounds (bv_signed o7 - bv_signed o6) ∧ (∀(o8 : bv 32%N), bv_signed o8 = bv_signed o7 - bv_signed o6 -> (0%Z ≤ bv_signed o8 ∧ bv_signed o8 ≤ 255%Z) ∧ (∀(o9 : bv 8%N), bv_signed o9 = bv_signed o8 -> (0%Z ≤ bv_signed o9 ∧ bv_signed o9 < bv_signed base -> bv_signed o9 = text_to_num (bv_signed base) c) ∧ (bv_signed base ≤ bv_signed o9 -> ¬ String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)) ∧ 0%Z ≤ bv_signed o9))) else ∀(o6 : bv 32%N), bv_signed o6 = Z.of_nat (Ascii.nat_of_ascii c) -> (∀(o7 : bv 32%N), bv_signed o7 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "a"%string 0%Z)) -> (∀(o8 : bool), (if decide (bv_signed o7 ≤ bv_signed o6) then ∃(o9 : bv 32%N), bv_signed o9 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "z"%string 0%Z)) ∧ (∃(o10 : bv 32%N), bv_signed o10 = Z.of_nat (Ascii.nat_of_ascii c) ∧ o8 = (if decide (bv_signed o10 ≤ bv_signed o9) then true else false)) else o8 = false) -> (if decide (o8 = true) then ∀(o9 : bv 32%N), bv_signed o9 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "a"%string 0%Z)) -> (∀(o10 : bv 32%N), bv_signed o10 = Z.of_nat (Ascii.nat_of_ascii c) -> int'32_in_bounds (bv_signed o10 - bv_signed o9) ∧ (∀(o11 : bv 32%N), bv_signed o11 = bv_signed o10 - bv_signed o9 -> int'32_in_bounds (bv_signed o11 + 36%Z) ∧ (∀(d : bv 32%N), bv_signed d = bv_signed o11 + 36%Z -> (∀(o12 : bv 32%N), bv_signed o12 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "a"%string 0%Z)) -> (∀(o13 : bv 32%N), bv_signed o13 = Z.of_nat (Ascii.nat_of_ascii c) -> int'32_in_bounds (bv_signed o13 - bv_signed o12) ∧ (∀(o14 : bv 32%N), bv_signed o14 = bv_signed o13 - bv_signed o12 -> int'32_in_bounds (bv_signed o14 + 36%Z) ∧ (∀(o15 : bv 32%N), bv_signed o15 = bv_signed o14 + 36%Z -> (0%Z ≤ bv_signed o15 ∧ bv_signed o15 ≤ 255%Z) ∧ (∀(o16 : bv 8%N), bv_signed o16 = bv_signed o15 -> (0%Z ≤ bv_signed o16 ∧ bv_signed o16 < bv_signed base -> bv_signed o16 = text_to_num (bv_signed base) c) ∧ (bv_signed base ≤ bv_signed o16 -> ¬ String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)) ∧ 0%Z ≤ bv_signed o16)))))))) else ∀(o9 : bv 32%N), bv_signed o9 = Z.of_nat (Ascii.nat_of_ascii c) -> (∀(o10 : bv 32%N), bv_signed o10 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "A"%string 0%Z)) -> (∀(o11 : bool), (if decide (bv_signed o10 ≤ bv_signed o9) then ∃(o12 : bv 32%N), bv_signed o12 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "Z"%string 0%Z)) ∧ (∃(o13 : bv 32%N), bv_signed o13 = Z.of_nat (Ascii.nat_of_ascii c) ∧ o11 = (if decide (bv_signed o13 ≤ bv_signed o12) then true else false)) else o11 = false) -> (if decide (o11 = true) then ∀(o12 : bv 32%N), bv_signed o12 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "A"%string 0%Z)) -> (∀(o13 : bv 32%N), bv_signed o13 = Z.of_nat (Ascii.nat_of_ascii c) -> int'32_in_bounds (bv_signed o13 - bv_signed o12) ∧ (∀(o14 : bv 32%N), bv_signed o14 = bv_signed o13 - bv_signed o12 -> int'32_in_bounds (bv_signed o14 + 10%Z) ∧ (∀(o15 : bv 32%N), bv_signed o15 = bv_signed o14 + 10%Z -> (0%Z ≤ bv_signed o15 ∧ bv_signed o15 ≤ 255%Z) ∧ (∀(o16 : bv 8%N), bv_signed o16 = bv_signed o15 -> (0%Z ≤ bv_signed o16 ∧ bv_signed o16 < bv_signed base -> bv_signed o16 = text_to_num (bv_signed base) c) ∧ (bv_signed base ≤ bv_signed o16 -> ¬ String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)) ∧ 0%Z ≤ bv_signed o16)))) else (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 255%Z) ∧ (∀(o12 : bv 8%N), bv_signed o12 = bv_signed base -> (0%Z ≤ bv_signed o12 ∧ bv_signed o12 < bv_signed base -> bv_signed o12 = text_to_num (bv_signed base) c) ∧ (bv_signed base ≤ bv_signed o12 -> ¬ String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)) ∧ 0%Z ≤ bv_signed o12)))))))))) else ∀(o3 : bv 32%N), bv_signed o3 = Z.of_nat (Ascii.nat_of_ascii c) -> (∀(o4 : bv 32%N), bv_signed o4 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "0"%string 0%Z)) -> (∀(o5 : bool), (if decide (bv_signed o4 ≤ bv_signed o3) then ∃(o6 : bv 32%N), bv_signed o6 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "9"%string 0%Z)) ∧ (∃(o7 : bv 32%N), bv_signed o7 = Z.of_nat (Ascii.nat_of_ascii c) ∧ o5 = (if decide (bv_signed o7 ≤ bv_signed o6) then true else false)) else o5 = false) -> (if decide (o5 = true) then ∀(o6 : bv 32%N), bv_signed o6 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "0"%string 0%Z)) -> (∀(o7 : bv 32%N), bv_signed o7 = Z.of_nat (Ascii.nat_of_ascii c) -> int'32_in_bounds (bv_signed o7 - bv_signed o6) ∧ (∀(o8 : bv 32%N), bv_signed o8 = bv_signed o7 - bv_signed o6 -> (0%Z ≤ bv_signed o8 ∧ bv_signed o8 ≤ 255%Z) ∧ (∀(o9 : bv 8%N), bv_signed o9 = bv_signed o8 -> (0%Z ≤ bv_signed o9 ∧ bv_signed o9 < bv_signed base -> bv_signed o9 = text_to_num (bv_signed base) c) ∧ (bv_signed base ≤ bv_signed o9 -> ¬ String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)) ∧ 0%Z ≤ bv_signed o9))) else ∀(o6 : bv 32%N), bv_signed o6 = Z.of_nat (Ascii.nat_of_ascii c) -> (∀(o7 : bv 32%N), bv_signed o7 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "a"%string 0%Z)) -> (∀(o8 : bool), (if decide (bv_signed o7 ≤ bv_signed o6) then ∃(o9 : bv 32%N), bv_signed o9 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "z"%string 0%Z)) ∧ (∃(o10 : bv 32%N), bv_signed o10 = Z.of_nat (Ascii.nat_of_ascii c) ∧ o8 = (if decide (bv_signed o10 ≤ bv_signed o9) then true else false)) else o8 = false) -> (if decide (o8 = true) then ∀(o9 : bv 32%N), bv_signed o9 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "a"%string 0%Z)) -> (∀(o10 : bv 32%N), bv_signed o10 = Z.of_nat (Ascii.nat_of_ascii c) -> int'32_in_bounds (bv_signed o10 - bv_signed o9) ∧ (∀(o11 : bv 32%N), bv_signed o11 = bv_signed o10 - bv_signed o9 -> int'32_in_bounds (bv_signed o11 + 10%Z) ∧ (∀(d : bv 32%N), bv_signed d = bv_signed o11 + 10%Z -> (∀(o12 : bv 32%N), bv_signed o12 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "a"%string 0%Z)) -> (∀(o13 : bv 32%N), bv_signed o13 = Z.of_nat (Ascii.nat_of_ascii c) -> int'32_in_bounds (bv_signed o13 - bv_signed o12) ∧ (∀(o14 : bv 32%N), bv_signed o14 = bv_signed o13 - bv_signed o12 -> int'32_in_bounds (bv_signed o14 + 10%Z) ∧ (∀(o15 : bv 32%N), bv_signed o15 = bv_signed o14 + 10%Z -> (0%Z ≤ bv_signed o15 ∧ bv_signed o15 ≤ 255%Z) ∧ (∀(o16 : bv 8%N), bv_signed o16 = bv_signed o15 -> (0%Z ≤ bv_signed o16 ∧ bv_signed o16 < bv_signed base -> bv_signed o16 = text_to_num (bv_signed base) c) ∧ (bv_signed base ≤ bv_signed o16 -> ¬ String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)) ∧ 0%Z ≤ bv_signed o16)))))))) else ∀(o9 : bv 32%N), bv_signed o9 = Z.of_nat (Ascii.nat_of_ascii c) -> (∀(o10 : bv 32%N), bv_signed o10 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "A"%string 0%Z)) -> (∀(o11 : bool), (if decide (bv_signed o10 ≤ bv_signed o9) then ∃(o12 : bv 32%N), bv_signed o12 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "Z"%string 0%Z)) ∧ (∃(o13 : bv 32%N), bv_signed o13 = Z.of_nat (Ascii.nat_of_ascii c) ∧ o11 = (if decide (bv_signed o13 ≤ bv_signed o12) then true else false)) else o11 = false) -> (if decide (o11 = true) then ∀(o12 : bv 32%N), bv_signed o12 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "A"%string 0%Z)) -> (∀(o13 : bv 32%N), bv_signed o13 = Z.of_nat (Ascii.nat_of_ascii c) -> int'32_in_bounds (bv_signed o13 - bv_signed o12) ∧ (∀(o14 : bv 32%N), bv_signed o14 = bv_signed o13 - bv_signed o12 -> int'32_in_bounds (bv_signed o14 + 10%Z) ∧ (∀(d : bv 32%N), bv_signed d = bv_signed o14 + 10%Z -> (∀(o15 : bv 32%N), bv_signed o15 = Z.of_nat (Ascii.nat_of_ascii (get_str_i "A"%string 0%Z)) -> (∀(o16 : bv 32%N), bv_signed o16 = Z.of_nat (Ascii.nat_of_ascii c) -> int'32_in_bounds (bv_signed o16 - bv_signed o15) ∧ (∀(o17 : bv 32%N), bv_signed o17 = bv_signed o16 - bv_signed o15 -> int'32_in_bounds (bv_signed o17 + 10%Z) ∧ (∀(o18 : bv 32%N), bv_signed o18 = bv_signed o17 + 10%Z -> (0%Z ≤ bv_signed o18 ∧ bv_signed o18 ≤ 255%Z) ∧ (∀(o19 : bv 8%N), bv_signed o19 = bv_signed o18 -> (0%Z ≤ bv_signed o19 ∧ bv_signed o19 < bv_signed base -> bv_signed o19 = text_to_num (bv_signed base) c) ∧ (bv_signed base ≤ bv_signed o19 -> ¬ String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)) ∧ 0%Z ≤ bv_signed o19)))))))) else (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 255%Z) ∧ (∀(o12 : bv 8%N), bv_signed o12 = bv_signed base -> (0%Z ≤ bv_signed o12 ∧ bv_signed o12 < bv_signed base -> bv_signed o12 = text_to_num (bv_signed base) c) ∧ (bv_signed base ≤ bv_signed o12 -> ¬ String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)) ∧ 0%Z ≤ bv_signed o12))))))))))) ∧ (∀(digit : bv 8%N), (0%Z ≤ bv_signed digit ∧ bv_signed digit < bv_signed base -> bv_signed digit = text_to_num (bv_signed base) c) ∧ (bv_signed base ≤ bv_signed digit -> ¬ String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)) ∧ 0%Z ≤ bv_signed digit -> (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 255%Z) ∧ (∀(o3 : bv 8%N), bv_signed o3 = bv_signed base -> (if decide (bv_signed o3 ≤ bv_signed digit) then (- 1%Z ≤ readers mpz r ∧ readers mpz r ≤ 0%Z) ∧ (∀(mpz1 : mpz_memo), Z.alloc mpz1 = Z.alloc mpz ∧ sgn mpz1 = sgn mpz ∧ readers mpz1 = readers mpz ∧ zones mpz1 = zones mpz -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz1 mpz) ∧ abs_size mpz1 r = 0%Z ∧ abs_value_of mpz1 r = 0%Z -> (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz1 mpz) ∧ readers mpz1 r = 0%Z ∧ (- 1%Z = 0%Z -> value_of r mpz1 = value_text (bv_signed base) (pelts sp) (offset sp)) ∧ (- 1%Z ≤ - 1%Z ∧ - 1%Z ≤ 0%Z) ∧ (- 1%Z = 0%Z) = String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)) else ((min dp1 ≤ offset dp1 + bv_signed dn ∧ offset dp1 + bv_signed dn < C.max dp1) ∧ writable dp1 = true) ∧ (∀(dp2 : C.ptr (bv 8%N)), length (data dp2) = length (data dp1) ∧ offset dp2 = offset dp1 ∧ min dp2 = min dp1 ∧ C.max dp2 = C.max dp1 ∧ writable dp2 = writable dp1 ∧ zone1 dp2 = zone1 dp1 -> pelts dp2 = fun_updt (pelts dp1) (offset dp2 + bv_signed dn) digit ∧ pelts dp2 (offset dp2 + bv_signed dn) = digit -> int'32_in_bounds (bv_signed dn + 1%Z) ∧ (∀(o4 : bv 32%N), bv_signed o4 = bv_signed dn + 1%Z -> (min spi ≤ offset spi + 1%Z ∧ offset spi + 1%Z ≤ C.max spi) ∧ (∀(o5 : C.ptr ascii), offset o5 = offset spi + 1%Z ∧ plength o5 = plength spi ∧ pelts o5 = pelts spi ∧ data o5 = data spi ∧ min o5 = min spi ∧ C.max o5 = C.max spi ∧ zone1 o5 = zone1 spi ∧ writable o5 = writable spi -> (0%Z ≤ offset sp + strlen (pelts sp) (offset sp) - offset spi ∧ offset sp + strlen (pelts sp) (offset sp) - offset o5 < offset sp + strlen (pelts sp) (offset sp) - offset spi) ∧ offset o5 = offset sp + bv_signed sign + bv_signed o4 ∧ (offset sp + bv_signed sign ≤ offset o5 ∧ offset o5 ≤ offset sp + strlen (pelts sp) (offset sp)) ∧ (min sp ≤ offset o5 ∧ offset o5 ≤ C.max sp) ∧ abs_value_sub_text (bv_signed base) (pelts sp) (offset sp + bv_signed sign) (offset o5) = svalue_sub (bv_signed base) (pelts dp2) 0%Z (bv_signed o4) ∧ in_base (bv_signed base) (pelts dp2) 0%Z (bv_signed o4) ∧ (¬ Z.of_nat (Ascii.nat_of_ascii (pelts o5 (offset o5))) = 0%Z) = (offset o5 < offset sp + strlen (pelts sp) (offset sp)) ∧ (min o5 = min sp ∧ C.max o5 = C.max sp) ∧ plength o5 = plength sp ∧ pelts o5 = pelts sp ∧ text_in_base (bv_signed base) (pelts sp) (offset sp + bv_signed sign) (offset o5)))))))) else ∀(o3 : bool), (bv_signed dn = bv_signed (0%bv : bv 32%N) -> o3 = true) ∧ (o3 = true -> dn = (0%bv : bv 32%N)) -> (if decide (o3 = true) then (- 1%Z ≤ readers mpz r ∧ readers mpz r ≤ 0%Z) ∧ (∀(mpz1 : mpz_memo), Z.alloc mpz1 = Z.alloc mpz ∧ sgn mpz1 = sgn mpz ∧ readers mpz1 = readers mpz ∧ zones mpz1 = zones mpz -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz1 mpz) ∧ abs_size mpz1 r = 0%Z ∧ abs_value_of mpz1 r = 0%Z -> (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz1 mpz) ∧ readers mpz1 r = 0%Z ∧ (- 1%Z = 0%Z -> value_of r mpz1 = value_text (bv_signed base) (pelts sp) (offset sp)) ∧ (- 1%Z ≤ - 1%Z ∧ - 1%Z ≤ 0%Z) ∧ (- 1%Z = 0%Z) = String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)) else 0%Z ≤ bv_signed base ∧ (∀(o4 : bv 64%N), bv_unsigned o4 = bv_signed base -> (2%Z ≤ bv_unsigned o4 ∧ bv_unsigned o4 ≤ 256%Z) ∧ (∀(bits : bv 32%N), (0%Z ≤ bv_unsigned bits ∧ bv_unsigned bits ≤ 8%Z) ∧ (¬ bv_unsigned bits = 0%Z -> Z.pow 2%Z (bv_unsigned bits) = bv_unsigned o4) ∧ (bv_unsigned bits = 0%Z -> (∀(n : Z), 0%Z ≤ n -> ¬ Z.pow 2%Z n = bv_unsigned o4)) -> (if decide (0%Z < bv_unsigned bits) then bv_unsigned bits ≤ 2147483647%Z ∧ (∀(o5 : bv 32%N), bv_signed o5 = bv_unsigned bits -> int'32_in_bounds (bv_signed dn * bv_signed o5) ∧ (∀(o6 : bv 32%N), bv_signed o6 = bv_signed dn * bv_signed o5 -> int'32_in_bounds (bv_signed o6 + 63%Z) ∧ (∀(o7 : bv 32%N), bv_signed o7 = bv_signed o6 + 63%Z -> (¬ 64%Z = 0%Z ∧ int'32_in_bounds (Z.rem (bv_signed o7) 64%Z)) ∧ (∀(alloc : bv 32%N), bv_signed alloc = Z.rem (bv_signed o7) 64%Z -> (readers mpz r = 0%Z ∧ 1%Z ≤ Z.alloc mpz r) ∧ (∀(mpz1 : mpz_memo), sgn mpz1 = sgn mpz -> (∀(rp : C.ptr (bv 64%N)), (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz1 mpz) ∧ readers mpz1 r = - 1%Z ∧ abs_value_of mpz1 r = value rp (abs_size mpz1 r) ∧ zones mpz1 r = zone1 rp ∧ offset rp = 0%Z ∧ plength rp = Z.alloc mpz1 r ∧ min rp = 0%Z ∧ C.max rp = plength rp ∧ writable rp = true ∧ abs_size mpz1 r = abs_size mpz r ∧ value rp (abs_size mpz r) = abs_value_of mpz r ∧ (if decide (Z.alloc mpz r < bv_signed alloc) then Z.alloc mpz1 r = bv_signed alloc else Z.alloc mpz1 r = Z.alloc mpz r) -> 0%Z ≤ bv_signed dn ∧ (∀(o8 : bv 32%N), bv_unsigned o8 = bv_signed dn -> ((0%Z < bv_unsigned o8 ∧ bv_unsigned o8 ≤ 2147483647%Z) ∧ 0%Z < bv_signed alloc ∧ valid rp (bv_signed alloc) ∧ valid dp1 (bv_unsigned o8) ∧ (1%Z ≤ bv_unsigned bits ∧ bv_unsigned bits ≤ 8%Z) ∧ Z.pow 2%Z (bv_unsigned bits * bv_unsigned o8) ≤ Z.pow (18446744073709551615%Z + 1%Z) (bv_signed alloc) ∧ writable rp = true ∧ in_base (Z.pow 2%Z (bv_unsigned bits)) (pelts dp1) (offset dp1) (offset dp1 + bv_unsigned o8)) ∧ (∀(rp1 : C.ptr (bv 64%N)), length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> (∀(rn : bv 32%N), (0%Z ≤ bv_signed rn ∧ bv_signed rn ≤ bv_signed alloc) ∧ value rp1 (bv_signed rn) = svalue (Z.pow 2%Z (bv_unsigned bits)) dp1 (bv_unsigned o8) ∧ (0%Z < bv_signed rn -> 0%Z < bv_unsigned (pelts rp1 (offset rp1 + bv_signed rn - 1%Z))) -> (∀(o9 : bool), (bv_signed sign = bv_signed (0%bv : bv 32%N) -> o9 = true) ∧ (o9 = true -> sign = (0%bv : bv 32%N)) -> (¬ o9 = true -> int'32_in_bounds (- bv_signed rn)) ∧ (∀(rn1 : bv 32%N), (if decide (¬ o9 = true) then bv_signed rn1 = - bv_signed rn else rn1 = rn) -> (zones mpz1 r = zone1 rp1 ∧ readers mpz1 r = - 1%Z ∧ offset rp1 = 0%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ Z.abs (bv_signed rn1) ≤ plength rp1 ∧ plength rp1 = Z.alloc mpz1 r ∧ (¬ bv_signed rn1 = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed rn1) - 1%Z) ≤ value rp1 (Z.abs (bv_signed rn1)))) ∧ (∀(mpz2 : mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ readers mpz2 = readers mpz1 ∧ zones mpz2 = zones mpz1 -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz2 mpz1) ∧ (sgn mpz2 r = 1%Z) = (0%Z ≤ bv_signed rn1) ∧ (sgn mpz2 r = - 1%Z) = (bv_signed rn1 < 0%Z) ∧ abs_size mpz2 r = Z.abs (bv_signed rn1) ∧ abs_value_of mpz2 r = value rp1 (Z.abs (bv_signed rn1)) -> (zones mpz2 r = zone1 rp1 ∧ readers mpz2 r = - 1%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ abs_value_of mpz2 r = value rp1 (abs_size mpz2 r)) ∧ (∀(mpz3 : mpz_memo), abs_value_of mpz3 = abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ abs_size mpz3 = abs_size mpz2 ∧ sgn mpz3 = sgn mpz2 ∧ zones mpz3 = zones mpz2 -> readers mpz3 r = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = r -> readers mpz3 y = readers mpz2 y) -> (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz3 mpz) ∧ readers mpz3 r = 0%Z ∧ value_of r mpz3 = value_text (bv_signed base) (pelts sp) (offset sp) ∧ (- 1%Z ≤ 0%Z ∧ 0%Z ≤ 0%Z) ∧ String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)))))))))))))) else 0%Z ≤ bv_signed base ∧ (∀(o5 : bv 64%N), bv_unsigned o5 = bv_signed base -> (2%Z ≤ bv_unsigned o5 ∧ bv_unsigned o5 ≤ 256%Z) ∧ (∀(info : wmpn_base_info), b info = bv_unsigned o5 -> (let o6 : bv 32%N := BaseInfo.exp info in bv_unsigned o6 ≤ 2147483647%Z ∧ (∀(o7 : bv 32%N), bv_signed o7 = bv_unsigned o6 -> (let o8 : bv 32%N := BaseInfo.exp info in bv_unsigned o8 ≤ 2147483647%Z ∧ (∀(o9 : bv 32%N), bv_signed o9 = bv_unsigned o8 -> int'32_in_bounds (bv_signed dn + bv_signed o9) ∧ (∀(o10 : bv 32%N), bv_signed o10 = bv_signed dn + bv_signed o9 -> int'32_in_bounds (bv_signed o10 - 1%Z) ∧ (∀(o11 : bv 32%N), bv_signed o11 = bv_signed o10 - 1%Z -> (¬ bv_signed o7 = 0%Z ∧ int'32_in_bounds (Z.rem (bv_signed o11) (bv_signed o7))) ∧ (∀(alloc : bv 32%N), bv_signed alloc = Z.rem (bv_signed o11) (bv_signed o7) -> (readers mpz r = 0%Z ∧ 1%Z ≤ Z.alloc mpz r) ∧ (∀(mpz1 : mpz_memo), sgn mpz1 = sgn mpz -> (∀(rp : C.ptr (bv 64%N)), (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz1 mpz) ∧ readers mpz1 r = - 1%Z ∧ abs_value_of mpz1 r = value rp (abs_size mpz1 r) ∧ zones mpz1 r = zone1 rp ∧ offset rp = 0%Z ∧ plength rp = Z.alloc mpz1 r ∧ min rp = 0%Z ∧ C.max rp = plength rp ∧ writable rp = true ∧ abs_size mpz1 r = abs_size mpz r ∧ value rp (abs_size mpz r) = abs_value_of mpz r ∧ (if decide (Z.alloc mpz r < bv_signed alloc) then Z.alloc mpz1 r = bv_signed alloc else Z.alloc mpz1 r = Z.alloc mpz r) -> 0%Z ≤ bv_signed base ∧ (∀(o12 : bv 64%N), bv_unsigned o12 = bv_signed base -> 0%Z ≤ bv_signed dn ∧ (∀(o13 : bv 32%N), bv_unsigned o13 = bv_signed dn -> ((0%Z < bv_unsigned o13 ∧ bv_unsigned o13 ≤ 2147483647%Z) ∧ 0%Z < bv_signed alloc ∧ valid rp (bv_signed alloc) ∧ valid dp1 (bv_unsigned o13) ∧ (2%Z ≤ bv_unsigned o12 ∧ bv_unsigned o12 ≤ 256%Z) ∧ Z.pow (bv_unsigned o12) (bv_unsigned o13) ≤ Z.pow (18446744073709551615%Z + 1%Z) (bv_signed alloc) ∧ writable rp = true ∧ in_base (bv_unsigned o12) (pelts dp1) (offset dp1) (offset dp1 + bv_unsigned o13) ∧ b info = bv_unsigned o12) ∧ (∀(rp1 : C.ptr (bv 64%N)), length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> (∀(rn : bv 32%N), (0%Z < svalue (bv_unsigned o12) dp1 (bv_unsigned o13) -> 1%Z ≤ bv_signed rn ∧ bv_signed rn ≤ bv_signed alloc) ∧ value rp1 (bv_signed rn) = svalue (bv_unsigned o12) dp1 (bv_unsigned o13) ∧ (0%Z < svalue (bv_unsigned o12) dp1 (bv_unsigned o13) -> 0%Z < bv_unsigned (pelts rp1 (offset rp1 + bv_signed rn - 1%Z))) ∧ (svalue (bv_unsigned o12) dp1 (bv_unsigned o13) = 0%Z -> bv_signed rn = 1%Z) ∧ 0%Z < bv_signed rn -> int'32_in_bounds (bv_signed rn - 1%Z) ∧ (∀(o14 : bv 32%N), bv_signed o14 = bv_signed rn - 1%Z -> (min rp1 ≤ offset rp1 + bv_signed o14 ∧ offset rp1 + bv_signed o14 < C.max rp1) ∧ (let o15 : bv 64%N := pelts rp1 (offset rp1 + bv_signed o14) in ∀(o16 : bool), (bv_unsigned o15 = bv_unsigned (0%bv : bv 64%N) -> o16 = true) ∧ (o16 = true -> o15 = (0%bv : bv 64%N)) -> (∀(o17 : bv 32%N), (if decide (o16 = true) then o17 = (1%bv : bv 32%N) else o17 = (0%bv : bv 32%N)) -> int'32_in_bounds (bv_signed rn - bv_signed o17) ∧ (∀(rn1 : bv 32%N), bv_signed rn1 = bv_signed rn - bv_signed o17 -> (∀(o18 : bool), (bv_signed sign = bv_signed (0%bv : bv 32%N) -> o18 = true) ∧ (o18 = true -> sign = (0%bv : bv 32%N)) -> (¬ o18 = true -> int'32_in_bounds (- bv_signed rn1)) ∧ (∀(rn2 : bv 32%N), (if decide (¬ o18 = true) then bv_signed rn2 = - bv_signed rn1 else rn2 = rn1) -> (zones mpz1 r = zone1 rp1 ∧ readers mpz1 r = - 1%Z ∧ offset rp1 = 0%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ Z.abs (bv_signed rn2) ≤ plength rp1 ∧ plength rp1 = Z.alloc mpz1 r ∧ (¬ bv_signed rn2 = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed rn2) - 1%Z) ≤ value rp1 (Z.abs (bv_signed rn2)))) ∧ (∀(mpz2 : mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ readers mpz2 = readers mpz1 ∧ zones mpz2 = zones mpz1 -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz2 mpz1) ∧ (sgn mpz2 r = 1%Z) = (0%Z ≤ bv_signed rn2) ∧ (sgn mpz2 r = - 1%Z) = (bv_signed rn2 < 0%Z) ∧ abs_size mpz2 r = Z.abs (bv_signed rn2) ∧ abs_value_of mpz2 r = value rp1 (Z.abs (bv_signed rn2)) -> (zones mpz2 r = zone1 rp1 ∧ readers mpz2 r = - 1%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ abs_value_of mpz2 r = value rp1 (abs_size mpz2 r)) ∧ (∀(mpz3 : mpz_memo), abs_value_of mpz3 = abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ abs_size mpz3 = abs_size mpz2 ∧ sgn mpz3 = sgn mpz2 ∧ zones mpz3 = zones mpz2 -> readers mpz3 r = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = r -> readers mpz3 y = readers mpz2 y) -> (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz3 mpz) ∧ readers mpz3 r = 0%Z ∧ value_of r mpz3 = value_text (bv_signed base) (pelts sp) (offset sp) ∧ (- 1%Z ≤ 0%Z ∧ 0%Z ≤ 0%Z) ∧ String_value.string_in_base (bv_signed base) (pelts sp) (offset sp)))))))))))))))))))))))))))))))))))).
Admitted.
