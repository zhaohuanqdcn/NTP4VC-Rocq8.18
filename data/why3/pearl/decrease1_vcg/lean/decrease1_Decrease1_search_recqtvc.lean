import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace decrease1_Decrease1_search_recqtvc
noncomputable def decrease1 (a : List ℤ) := ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) - (1 : ℤ) → a[Int.toNat i]! - (1 : ℤ) ≤ a[Int.toNat (i + (1 : ℤ))]!
theorem search_rec'vc (a : List ℤ) (i : ℤ) (fact0 : decrease1 a) (fact1 : (0 : ℤ) ≤ i) : let o1 : ℤ := Int.ofNat (List.length a); (i < o1 → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (¬a[Int.toNat i]! = (0 : ℤ) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if (0 : ℤ) < a[Int.toNat i]! then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let o2 : ℤ := i + a[Int.toNat i]!; ((0 : ℤ) ≤ Int.ofNat (List.length a) - i ∧ Int.ofNat (List.length a) - o2 < Int.ofNat (List.length a) - i) ∧ decrease1 a ∧ (0 : ℤ) ≤ o2) else let o2 : ℤ := i + (1 : ℤ); ((0 : ℤ) ≤ Int.ofNat (List.length a) - i ∧ Int.ofNat (List.length a) - o2 < Int.ofNat (List.length a) - i) ∧ decrease1 a ∧ (0 : ℤ) ≤ o2))) ∧ (∀(result : ℤ), (if i < o1 then if a[Int.toNat i]! = (0 : ℤ) then result = i else if (0 : ℤ) < a[Int.toNat i]! then let o2 : ℤ := i + a[Int.toNat i]!; result = -(1 : ℤ) ∧ (∀(j : ℤ), o2 ≤ j ∧ j < Int.ofNat (List.length a) → ¬a[Int.toNat j]! = (0 : ℤ)) ∨ (o2 ≤ result ∧ result < Int.ofNat (List.length a)) ∧ a[Int.toNat result]! = (0 : ℤ) ∧ (∀(j : ℤ), o2 ≤ j ∧ j < result → ¬a[Int.toNat j]! = (0 : ℤ)) else let o2 : ℤ := i + (1 : ℤ); result = -(1 : ℤ) ∧ (∀(j : ℤ), o2 ≤ j ∧ j < Int.ofNat (List.length a) → ¬a[Int.toNat j]! = (0 : ℤ)) ∨ (o2 ≤ result ∧ result < Int.ofNat (List.length a)) ∧ a[Int.toNat result]! = (0 : ℤ) ∧ (∀(j : ℤ), o2 ≤ j ∧ j < result → ¬a[Int.toNat j]! = (0 : ℤ)) else result = -(1 : ℤ)) → result = -(1 : ℤ) ∧ (∀(j : ℤ), i ≤ j ∧ j < Int.ofNat (List.length a) → ¬a[Int.toNat j]! = (0 : ℤ)) ∨ (i ≤ result ∧ result < Int.ofNat (List.length a)) ∧ a[Int.toNat result]! = (0 : ℤ) ∧ (∀(j : ℤ), i ≤ j ∧ j < result → ¬a[Int.toNat j]! = (0 : ℤ)))
  := sorry
end decrease1_Decrease1_search_recqtvc
