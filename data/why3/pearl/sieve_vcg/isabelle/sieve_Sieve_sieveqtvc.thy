theory sieve_Sieve_sieveqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref"
begin
definition no_factor_lt :: "int \<Rightarrow> int \<Rightarrow> _"
  where "no_factor_lt bnd num \<longleftrightarrow> (1 :: int) < num \<and> (\<forall>(k :: int) (l :: int). ((1 :: int) < l \<and> l < bnd) \<and> (1 :: int) < k \<longrightarrow> \<not>num = k * l)" for bnd num
theorem sieve'vc:
  fixes n :: "int"
  assumes fact0: "(1 :: int) < n"
  shows "(0 :: int) \<le> n"
  and "\<forall>(t :: bool list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> t ! nat i = True) \<and> int (length t) = n \<longrightarrow> (let o1 :: bool = False in ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length t)) \<and> (length (t[nat (0 :: int) := o1]) = length t \<longrightarrow> nth (t[nat (0 :: int) := o1]) o nat = (nth t o nat)(0 :: int := o1) \<longrightarrow> (let o2 :: bool = False in ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) < int (length (t[nat (0 :: int) := o1]))) \<and> (length (t[nat (1 :: int) := o2, nat (0 :: int) := o1]) = length (t[nat (0 :: int) := o1]) \<longrightarrow> nth (t[nat (1 :: int) := o2, nat (0 :: int) := o1]) o nat = (nth (t[nat (0 :: int) := o1]) o nat)(1 :: int := o2) \<longrightarrow> (((1 :: int) < (2 :: int) \<and> (2 :: int) \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < n \<longrightarrow> t[nat (1 :: int) := o2, nat (0 :: int) := o1] ! nat j = True \<longleftrightarrow> no_factor_lt (2 :: int) j)) \<and> (\<forall>(i :: int) (t1 :: bool list). length t1 = length (t[nat (1 :: int) := o2, nat (0 :: int) := o1]) \<longrightarrow> ((1 :: int) < i \<and> i \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < n \<longrightarrow> t1 ! nat j = True \<longleftrightarrow> no_factor_lt i j) \<longrightarrow> (if i < n then ((0 :: int) \<le> i \<and> i < int (length t1)) \<and> (if t1 ! nat i = True then (((1 :: int) < i \<and> i \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < n \<longrightarrow> t1 ! nat j = True \<longleftrightarrow> no_factor_lt i j \<and> (\<forall>(k :: int). (1 :: int) < k \<and> k < i \<longrightarrow> \<not>j = k * i))) \<and> (\<forall>(r :: int) (t2 :: bool list). length t2 = length t1 \<longrightarrow> ((1 :: int) < r \<and> r \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < n \<longrightarrow> t2 ! nat j = True \<longleftrightarrow> no_factor_lt i j \<and> (\<forall>(k :: int). (1 :: int) < k \<and> k < r \<longrightarrow> \<not>j = k * i)) \<longrightarrow> (if r * i < n then let o3 :: bool = False in ((0 :: int) \<le> r * i \<and> r * i < int (length t2)) \<and> (length (t2[nat (r * i) := o3]) = length t2 \<longrightarrow> nth (t2[nat (r * i) := o3]) o nat = (nth t2 o nat)(r * i := o3) \<longrightarrow> ((0 :: int) \<le> n - r \<and> n - (r + (1 :: int)) < n - r) \<and> (((1 :: int) < r + (1 :: int) \<and> r + (1 :: int) \<le> n) \<and> r * i + i = (r + (1 :: int)) * i) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < n \<longrightarrow> t2[nat (r * i) := o3] ! nat j = True \<longleftrightarrow> no_factor_lt i j \<and> (\<forall>(k :: int). (1 :: int) < k \<and> k < r + (1 :: int) \<longrightarrow> \<not>j = k * i))) else ((0 :: int) \<le> n - i \<and> n - (i + (1 :: int)) < n - i) \<and> ((1 :: int) < i + (1 :: int) \<and> i + (1 :: int) \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < n \<longrightarrow> t2 ! nat j = True \<longleftrightarrow> no_factor_lt (i + (1 :: int)) j))) else ((0 :: int) \<le> n - i \<and> n - (i + (1 :: int)) < n - i) \<and> ((1 :: int) < i + (1 :: int) \<and> i + (1 :: int) \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < n \<longrightarrow> t1 ! nat j = True \<longleftrightarrow> no_factor_lt (i + (1 :: int)) j)) else int (length t1) = n \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < n \<longrightarrow> t1 ! nat i1 = True \<longleftrightarrow> prime i1)))))))"
  sorry
end
