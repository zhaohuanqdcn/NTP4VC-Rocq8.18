From Stdlib Require Import Strings.String.
From Stdlib Require Import String Ascii.
From Stdlib Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Stdlib Require Classical.
From Stdlib Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Stdlib Require Import Sorting.Sorted.
From Stdlib Require Import Reals.Rbasic_fun.
From Stdlib Require Import Reals.Abstract.ConstructiveAbs.
From Stdlib Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Stdlib Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Stdlib Require Import ZArith.Zeuclid.
From Stdlib Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Stdlib Require Import Reals.
Require Import Why3.Base.
Require Import Why3.why3.Ref.Ref.
Require Import Why3.map.Const.
Require Import Why3.map.MapEq.
Require Import Why3.mach.int.Unsigned.
Require Import Why3.mach.c.C.
Require Import Why3.mach.c.String.
Require Import Why3.mach.c.UChar.
Require Import multiprecision.lemmas.Lemmas.
Require Import multiprecision.types.Config.
Require Import multiprecision.types.Types.
Require Import multiprecision.types.Int32Eq.
Require Import multiprecision.types.UInt64Eq.
Require Import multiprecision.util.Util.
Require Import multiprecision.ptralias.Alias.
Require Import multiprecision.util.UtilOld.
Require Import multiprecision.mpz.Z.
Require Import multiprecision.mpz.Zutil.
Require Import multiprecision.base_info.BaseInfo.
Require Import multiprecision.logical.LogicalUtil.
Require Import multiprecision.logical.Logical.
Require Import multiprecision.logical.LogicalOld.
Require Import multiprecision.stringlemmas.String_lemmas.
Require Import multiprecision.stringlemmas.Conversions.
Require Import multiprecision.stringlemmas.String_value.
Require Import multiprecision.get_str.Get_str.
Require Import multiprecision.powm.Powm.
Require Import multiprecision.compare.Compare.
Require Import multiprecision.valuation.Valuation.
Require Import multiprecision.add.Add.
Require Import multiprecision.add.AddOld.
Require Import multiprecision.sub.SubOld.
Require Import multiprecision.mul.Mul.
Require Import multiprecision.mul.Mul_basecase.
Require Import multiprecision.div.Div.
Require Import multiprecision.toom.Toom.
Require Import multiprecision.add_1.Add_1.
Require Import multiprecision.sub_1.Sub_1.
Open Scope Z_scope.
Definition effective (b : Z) : Z := if decide (Z.abs b < 2%Z) then 10%Z else Z.abs b.
Theorem wmpz_get_str'vc (sp : C.ptr ascii) (sz : bv 32%N) (mpz : mpz_memo) (u : mpz_ptr) (base : bv 32%N) (fact0 : valid sp (bv_signed sz)) (fact1 : writable sp = true) (fact2 : 2%Z ≤ bv_signed sz) (fact3 : abs_value_of mpz u < Z.pow (effective (bv_signed base)) (bv_signed sz - 2%Z)) (fact4 : readers mpz u = 0%Z) (fact5 : 64%Z * abs_size mpz u + 7%Z ≤ 2147483647%Z) (fact6 : - 36%Z ≤ bv_signed base) (fact7 : bv_signed base ≤ 62%Z) : (∀(result : string), (if decide (36%Z < bv_signed base) then result = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"%string else if decide (0%Z ≤ bv_signed base) then result = "0123456789abcdefghijklmnopqrstuvwxyz"%string else result = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"%string) -> (bv_signed base < 0%Z -> result = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"%string) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> result = "0123456789abcdefghijklmnopqrstuvwxyz"%string) ∧ (36%Z < bv_signed base -> result = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"%string) ∧ effective (bv_signed base) ≤ Z.of_nat (String.length result)) ∧ (∀(digits : string), (bv_signed base < 0%Z -> digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"%string) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> digits = "0123456789abcdefghijklmnopqrstuvwxyz"%string) ∧ (36%Z < bv_signed base -> digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"%string) ∧ effective (bv_signed base) ≤ Z.of_nat (String.length digits) -> (if decide (bv_signed base ≤ 0%Z) then int'32_in_bounds (- bv_signed base) ∧ (∀(o1 : bv 32%N), bv_signed o1 = - bv_signed base -> (if decide (bv_signed o1 ≤ 1%Z) then bv_signed (10%bv : bv 32%N) = effective (bv_signed base) else bv_signed o1 = effective (bv_signed base))) else if decide (bv_signed base ≤ 1%Z) then bv_signed (10%bv : bv 32%N) = effective (bv_signed base) else bv_signed base = effective (bv_signed base)) ∧ (∀(base1 : bv 32%N), bv_signed base1 = effective (bv_signed base) -> - 2%Z < readers mpz u ∧ (∀(un : bv 32%N), bv_signed un = abs_size mpz u -> (∀(o1 : bool), (bv_signed un = bv_signed (0%bv : bv 32%N) -> o1 = true) ∧ (o1 = true -> un = (0%bv : bv 32%N)) -> (if decide (o1 = true) then let o2 : ascii := get_str_i "0"%string 0%Z in ((min sp ≤ offset sp + 0%Z ∧ offset sp + 0%Z < C.max sp) ∧ writable sp = true) ∧ (∀(sp1 : C.ptr ascii), length (data sp1) = length (data sp) ∧ offset sp1 = offset sp ∧ min sp1 = min sp ∧ C.max sp1 = C.max sp ∧ writable sp1 = writable sp ∧ zone1 sp1 = zone1 sp -> pelts sp1 = fun_updt (pelts sp) (offset sp1 + 0%Z) o2 ∧ pelts sp1 (offset sp1 + 0%Z) = o2 -> (let o3 : ascii := zero_char in ((min sp1 ≤ offset sp1 + 1%Z ∧ offset sp1 + 1%Z < C.max sp1) ∧ writable sp1 = true) ∧ (∀(sp2 : C.ptr ascii), length (data sp2) = length (data sp1) ∧ offset sp2 = offset sp1 ∧ min sp2 = min sp1 ∧ C.max sp2 = C.max sp1 ∧ writable sp2 = writable sp1 ∧ zone1 sp2 = zone1 sp1 -> pelts sp2 = fun_updt (pelts sp1) (offset sp2 + 1%Z) o3 ∧ pelts sp2 (offset sp2 + 1%Z) = o3 -> valid_string sp2 ∧ String_value.string_in_base (effective (bv_signed base)) (pelts sp2) (offset sp2) ∧ (∀(x : mpz_ptr), mpz_unchanged x mpz mpz) ∧ value_text (effective (bv_signed base)) (pelts sp2) (offset sp2) = value_of u mpz))) else - 2%Z < readers mpz u ∧ (∀(o2 : bv 32%N), bv_signed o2 = sgn mpz u * abs_size mpz u -> (if decide (bv_signed o2 < 0%Z) then let o3 : ascii := get_str_i "-"%string 0%Z in ((min sp ≤ offset sp + 0%Z ∧ offset sp + 0%Z < C.max sp) ∧ writable sp = true) ∧ (∀(sp1 : C.ptr ascii), length (data sp1) = length (data sp) ∧ offset sp1 = offset sp ∧ min sp1 = min sp ∧ C.max sp1 = C.max sp ∧ writable sp1 = writable sp ∧ zone1 sp1 = zone1 sp -> pelts sp1 = fun_updt (pelts sp) (offset sp1 + 0%Z) o3 ∧ pelts sp1 (offset sp1 + 0%Z) = o3 -> int'32_in_bounds (0%Z + 1%Z) ∧ (∀(o4 : bv 32%N), bv_signed o4 = 0%Z + 1%Z -> 0%Z ≤ bv_signed base1 ∧ (∀(o5 : bv 64%N), bv_unsigned o5 = bv_signed base1 -> (2%Z ≤ bv_unsigned o5 ∧ bv_unsigned o5 ≤ 256%Z) ∧ (∀(bits : bv 32%N), (0%Z ≤ bv_unsigned bits ∧ bv_unsigned bits ≤ 8%Z) ∧ (¬ bv_unsigned bits = 0%Z -> Z.pow 2%Z (bv_unsigned bits) = bv_unsigned o5) ∧ (bv_unsigned bits = 0%Z -> (∀(n : Z), 0%Z ≤ n -> ¬ Z.pow 2%Z n = bv_unsigned o5)) -> 0%Z ≤ readers mpz u ∧ (∀(mpz1 : mpz_memo), abs_value_of mpz1 = abs_value_of mpz ∧ alloc mpz1 = alloc mpz ∧ abs_size mpz1 = abs_size mpz ∧ sgn mpz1 = sgn mpz ∧ zones mpz1 = zones mpz -> (∀(up : C.ptr (bv 64%N)), readers mpz1 u = readers mpz u + 1%Z ∧ (∀(y : mpz_ptr), ¬ u = y -> readers mpz1 y = readers mpz y) ∧ value up (abs_size mpz1 u) = abs_value_of mpz1 u ∧ plength up = alloc mpz1 u ∧ offset up = 0%Z ∧ min up = 0%Z ∧ C.max up = plength up ∧ zone1 up = zones mpz1 u -> writable sp1 = true ∧ (∀(sp2 : C.ptr ascii), offset sp2 = offset sp1 ∧ writable sp2 = writable sp1 ∧ zone1 sp2 = zone1 sp1 -> (∀(usp : C.ptr (bv 8%N)) (mem : UChar.cast_mem), (min usp = min sp1 ∧ min sp1 = UChar.mi mem) ∧ (C.max usp = C.max sp1 ∧ C.max sp1 = UChar.ma mem) ∧ zone1 sp1 = UChar.z mem ∧ (plength usp = plength sp1 ∧ plength sp1 = UChar.l mem) ∧ UChar.ok mem = true ∧ offset usp = offset sp1 ∧ (∀(i : Z), 0%Z ≤ i ∧ i < plength sp1 -> pelts usp i = Z_to_bv 8%N (Z.of_nat (Ascii.nat_of_ascii (pelts sp1 i)))) ∧ writable usp = true -> (min usp ≤ offset usp + bv_signed o4 ∧ offset usp + bv_signed o4 ≤ C.max usp) ∧ (∀(uspi : C.ptr (bv 8%N)), offset uspi = offset usp + bv_signed o4 ∧ plength uspi = plength usp ∧ pelts uspi = pelts usp ∧ data uspi = data usp ∧ min uspi = min usp ∧ C.max uspi = C.max usp ∧ zone1 uspi = zone1 usp ∧ writable uspi = writable usp -> (bv_unsigned bits = 0%Z -> bits = (0%bv : bv 32%N)) -> (if decide (¬ bits = (0%bv : bv 32%N)) then int'32_in_bounds (bv_signed un - 1%Z) ∧ (∀(o6 : bv 32%N), bv_signed o6 = bv_signed un - 1%Z -> (min up ≤ offset up + bv_signed o6 ∧ offset up + bv_signed o6 < C.max up) ∧ (let um : bv 64%N := pelts up (offset up + bv_signed o6) in 0%Z < bv_unsigned um ∧ (∀(sb : bv 64%N), (1%Z ≤ bv_unsigned sb ∧ bv_unsigned sb ≤ 64%Z) ∧ Z.pow 2%Z (bv_unsigned sb - 1%Z) ≤ bv_unsigned um ∧ bv_unsigned um < Z.pow 2%Z (bv_unsigned sb) -> bv_unsigned sb ≤ 2147483647%Z ∧ (∀(o7 : bv 32%N), bv_signed o7 = bv_unsigned sb -> int'32_in_bounds (bv_signed un - 1%Z) ∧ (∀(o8 : bv 32%N), bv_signed o8 = bv_signed un - 1%Z -> int'32_in_bounds (64%Z * bv_signed o8) ∧ (∀(o9 : bv 32%N), bv_signed o9 = 64%Z * bv_signed o8 -> int'32_in_bounds (bv_signed o9 + bv_signed o7) ∧ (∀(ub : bv 32%N), bv_signed ub = bv_signed o9 + bv_signed o7 -> (1%Z ≤ bv_signed un ∧ valid up (bv_signed un) ∧ (1%Z ≤ bv_unsigned bits ∧ bv_unsigned bits ≤ 8%Z) ∧ valid uspi (ZEuclid.div (bv_signed ub + bv_unsigned bits - 1%Z) (bv_unsigned bits)) ∧ 0%Z ≤ bv_signed ub ∧ value up (bv_signed un) < Z.pow 2%Z (bv_signed ub) ∧ 0%Z < bv_unsigned (pelts up (offset up + bv_signed un - 1%Z)) ∧ 64%Z * bv_signed un + 7%Z ≤ 2147483647%Z ∧ writable uspi = true) ∧ (∀(uspi1 : C.ptr (bv 8%N)) (usp1 : C.ptr (bv 8%N)), data uspi1 = data usp1 ∧ length (data usp1) = length (data uspi) ∧ offset uspi1 = offset uspi ∧ min uspi1 = min uspi ∧ C.max uspi1 = C.max uspi ∧ writable uspi1 = writable uspi ∧ zone1 uspi1 = zone1 uspi -> length (data usp1) = length (data usp) ∧ offset usp1 = offset usp ∧ min usp1 = min usp ∧ C.max usp1 = C.max usp ∧ writable usp1 = writable usp ∧ zone1 usp1 = zone1 usp -> (∀(g : bv 32%N), in_base (Z.pow 2%Z (bv_unsigned bits)) (pelts uspi1) (offset uspi1) (offset uspi1 + bv_unsigned g) ∧ svalue (Z.pow 2%Z (bv_unsigned bits)) uspi1 (bv_unsigned g) = value up (bv_signed un) ∧ (0%Z < bv_unsigned g ∧ bv_unsigned g ≤ ZEuclid.div (bv_signed ub + bv_unsigned bits - 1%Z) (bv_unsigned bits)) ∧ 0%Z < bv_signed (pelts uspi1 (offset uspi1)) ∧ (∀(j : Z), j < offset uspi1 ∨ offset uspi1 + ZEuclid.div (bv_signed ub + bv_unsigned bits - 1%Z) (bv_unsigned bits) ≤ j -> pelts uspi1 j = pelts uspi j) -> bv_unsigned g ≤ 2147483647%Z ∧ (∀(o10 : bv 32%N), bv_signed o10 = bv_unsigned g -> int'32_in_bounds (bv_signed o4 + bv_signed o10) ∧ (∀(o11 : bv 32%N), bv_signed o11 = bv_signed o4 + bv_signed o10 -> (UChar.ok mem = true ∧ UChar.z mem = zone1 sp2 ∧ UChar.mi mem = min usp1 ∧ UChar.ma mem = C.max usp1 ∧ offset sp2 = offset usp1 ∧ plength usp1 = UChar.l mem) ∧ (∀(mem1 : UChar.cast_mem) (sp3 : C.ptr ascii), UChar.mi mem1 = UChar.mi mem ∧ UChar.ma mem1 = UChar.ma mem ∧ UChar.z mem1 = UChar.z mem ∧ UChar.l mem1 = UChar.l mem -> offset sp3 = offset sp2 ∧ writable sp3 = writable sp2 ∧ zone1 sp3 = zone1 sp2 -> (min sp3 = UChar.mi mem1 ∧ C.max sp3 = UChar.ma mem1) ∧ (∀(i : Z), 0%Z ≤ i ∧ i < plength sp3 -> pelts sp3 i = Ascii.ascii_of_nat (Z.to_nat (bv_unsigned (pelts usp1 i)))) ∧ plength sp3 = plength usp1 -> int'32_in_bounds (bv_signed o11 - 1%Z) ∧ (∀(o12 : bv 32%N), bv_signed o12 = bv_signed o11 - 1%Z -> (bv_signed o4 ≤ bv_signed o12 + 1%Z -> ((bv_signed o4 ≤ bv_signed o4 ∧ bv_signed o4 ≤ bv_signed o11) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + bv_signed o4)) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + bv_signed o4)) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + bv_signed o4)) ∧ abs_value_sub_text (bv_signed base1) (pelts sp3) (offset sp3 + bv_signed o4) (offset sp3 + bv_signed o4) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + bv_signed o4) (offset usp1 + bv_signed o4) ∧ (∀(k : Z), offset sp3 ≤ k ∧ k < offset sp3 + bv_signed o4 -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp3 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp3) (offset sp3 + bv_signed o4) (offset sp3 + bv_signed o4) ∧ (bv_signed o4 = 1%Z -> pelts sp3 (offset sp3) = get_str_i "-"%string 0%Z) ∧ (bv_signed o4 = 0%Z -> bv_signed o4 < bv_signed o4 -> ¬ pelts sp3 (offset sp3) = get_str_i "-"%string 0%Z)) ∧ (∀(sp4 : C.ptr ascii), length (data sp4) = length (data sp3) ∧ offset sp4 = offset sp3 ∧ min sp4 = min sp3 ∧ C.max sp4 = C.max sp3 ∧ writable sp4 = writable sp3 ∧ zone1 sp4 = zone1 sp3 -> (∀(j : bv 32%N), let j1 : Z := bv_signed j in (bv_signed o4 ≤ j1 ∧ j1 ≤ bv_signed o12) ∧ (bv_signed o4 ≤ j1 ∧ j1 ≤ bv_signed o11) ∧ (∀(k : Z), offset sp4 + j1 ≤ offset sp4 + k ∧ offset sp4 + k < offset sp4 + bv_signed o11 -> pelts sp4 (offset sp4 + k) = pelts sp3 (offset sp4 + k)) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + j1)) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + j1)) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + j1)) ∧ abs_value_sub_text (bv_signed base1) (pelts sp4) (offset sp4 + bv_signed o4) (offset sp4 + j1) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + bv_signed o4) (offset usp1 + j1) ∧ (∀(k : Z), offset sp4 ≤ k ∧ k < offset sp4 + j1 -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp4 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp4) (offset sp4 + bv_signed o4) (offset sp4 + j1) ∧ (bv_signed o4 = 1%Z -> pelts sp4 (offset sp4) = get_str_i "-"%string 0%Z) ∧ (bv_signed o4 = 0%Z -> bv_signed o4 < j1 -> ¬ pelts sp4 (offset sp4) = get_str_i "-"%string 0%Z) -> (min sp4 ≤ offset sp4 + bv_signed j ∧ offset sp4 + bv_signed j < C.max sp4) ∧ (let o13 : ascii := pelts sp4 (offset sp4 + bv_signed j) in let cj : bv 8%N := Z_to_bv 8%N (Z.of_nat (Ascii.nat_of_ascii o13)) in (0%Z ≤ Z.of_nat (Ascii.nat_of_ascii o13) ∧ Z.of_nat (Ascii.nat_of_ascii o13) ≤ 127%Z -> bv_signed cj = Z.of_nat (Ascii.nat_of_ascii o13)) -> (∀(o14 : bv 32%N), bv_signed o14 = bv_signed cj -> (0%Z ≤ bv_signed o14 ∧ bv_signed o14 ≤ Z.of_nat (String.length digits)) ∧ (∀(dc : ascii), (0%Z ≤ bv_signed o14 ∧ bv_signed o14 < Z.of_nat (String.length digits) -> dc = get_str_i digits (bv_signed o14)) ∧ (bv_signed o14 = Z.of_nat (String.length digits) -> dc = Ascii.ascii_of_nat 0%nat) -> ((min sp4 ≤ offset sp4 + bv_signed j ∧ offset sp4 + bv_signed j < C.max sp4) ∧ writable sp4 = true) ∧ (∀(sp5 : C.ptr ascii), length (data sp5) = length (data sp4) ∧ offset sp5 = offset sp4 ∧ min sp5 = min sp4 ∧ C.max sp5 = C.max sp4 ∧ writable sp5 = writable sp4 ∧ zone1 sp5 = zone1 sp4 -> pelts sp5 = fun_updt (pelts sp4) (offset sp5 + bv_signed j) dc ∧ pelts sp5 (offset sp5 + bv_signed j) = dc -> (bv_signed o4 ≤ j1 + 1%Z ∧ j1 + 1%Z ≤ bv_signed o11) ∧ (∀(k : Z), offset sp5 + (j1 + 1%Z) ≤ offset sp5 + k ∧ offset sp5 + k < offset sp5 + bv_signed o11 -> pelts sp5 (offset sp5 + k) = pelts sp3 (offset sp5 + k)) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp5) (offset sp5) (offset sp5 + (j1 + 1%Z))) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp5) (offset sp5) (offset sp5 + (j1 + 1%Z))) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp5) (offset sp5) (offset sp5 + (j1 + 1%Z))) ∧ abs_value_sub_text (bv_signed base1) (pelts sp5) (offset sp5 + bv_signed o4) (offset sp5 + (j1 + 1%Z)) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + bv_signed o4) (offset usp1 + (j1 + 1%Z)) ∧ (∀(k : Z), offset sp5 ≤ k ∧ k < offset sp5 + (j1 + 1%Z) -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp5 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp5) (offset sp5 + bv_signed o4) (offset sp5 + (j1 + 1%Z)) ∧ (bv_signed o4 = 1%Z -> pelts sp5 (offset sp5) = get_str_i "-"%string 0%Z) ∧ (bv_signed o4 = 0%Z -> bv_signed o4 < j1 + 1%Z -> ¬ pelts sp5 (offset sp5) = get_str_i "-"%string 0%Z)))))) ∧ ((bv_signed o4 ≤ bv_signed o12 + 1%Z ∧ bv_signed o12 + 1%Z ≤ bv_signed o11) ∧ (∀(k : Z), offset sp4 + (bv_signed o12 + 1%Z) ≤ offset sp4 + k ∧ offset sp4 + k < offset sp4 + bv_signed o11 -> pelts sp4 (offset sp4 + k) = pelts sp3 (offset sp4 + k)) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (bv_signed o12 + 1%Z))) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (bv_signed o12 + 1%Z))) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (bv_signed o12 + 1%Z))) ∧ abs_value_sub_text (bv_signed base1) (pelts sp4) (offset sp4 + bv_signed o4) (offset sp4 + (bv_signed o12 + 1%Z)) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + bv_signed o4) (offset usp1 + (bv_signed o12 + 1%Z)) ∧ (∀(k : Z), offset sp4 ≤ k ∧ k < offset sp4 + (bv_signed o12 + 1%Z) -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp4 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp4) (offset sp4 + bv_signed o4) (offset sp4 + (bv_signed o12 + 1%Z)) ∧ (bv_signed o4 = 1%Z -> pelts sp4 (offset sp4) = get_str_i "-"%string 0%Z) ∧ (bv_signed o4 = 0%Z -> bv_signed o4 < bv_signed o12 + 1%Z -> ¬ pelts sp4 (offset sp4) = get_str_i "-"%string 0%Z) -> (let o13 : ascii := zero_char in ((min sp4 ≤ offset sp4 + bv_signed o11 ∧ offset sp4 + bv_signed o11 < C.max sp4) ∧ writable sp4 = true) ∧ (∀(sp5 : C.ptr ascii), length (data sp5) = length (data sp4) ∧ offset sp5 = offset sp4 ∧ min sp5 = min sp4 ∧ C.max sp5 = C.max sp4 ∧ writable sp5 = writable sp4 ∧ zone1 sp5 = zone1 sp4 -> pelts sp5 = fun_updt (pelts sp4) (offset sp5 + bv_signed o11) o13 ∧ pelts sp5 (offset sp5 + bv_signed o11) = o13 -> (zones mpz1 u = zone1 up ∧ 1%Z ≤ readers mpz1 u ∧ min up = 0%Z ∧ C.max up = plength up) ∧ (∀(mpz2 : mpz_memo), abs_value_of mpz2 = abs_value_of mpz1 ∧ alloc mpz2 = alloc mpz1 ∧ abs_size mpz2 = abs_size mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ zones mpz2 = zones mpz1 -> readers mpz2 u = readers mpz1 u - 1%Z ∧ (∀(y : mpz_ptr), ¬ y = u -> readers mpz2 y = readers mpz1 y) -> valid_string sp5 ∧ String_value.string_in_base (effective (bv_signed base)) (pelts sp5) (offset sp5) ∧ (∀(x : mpz_ptr), mpz_unchanged x mpz2 mpz) ∧ value_text (effective (bv_signed base)) (pelts sp5) (offset sp5) = value_of u mpz2)))))) ∧ (bv_signed o12 + 1%Z < bv_signed o4 -> (let o13 : ascii := zero_char in ((min sp3 ≤ offset sp3 + bv_signed o11 ∧ offset sp3 + bv_signed o11 < C.max sp3) ∧ writable sp3 = true) ∧ (∀(sp4 : C.ptr ascii), length (data sp4) = length (data sp3) ∧ offset sp4 = offset sp3 ∧ min sp4 = min sp3 ∧ C.max sp4 = C.max sp3 ∧ writable sp4 = writable sp3 ∧ zone1 sp4 = zone1 sp3 -> pelts sp4 = fun_updt (pelts sp3) (offset sp4 + bv_signed o11) o13 ∧ pelts sp4 (offset sp4 + bv_signed o11) = o13 -> (zones mpz1 u = zone1 up ∧ 1%Z ≤ readers mpz1 u ∧ min up = 0%Z ∧ C.max up = plength up) ∧ (∀(mpz2 : mpz_memo), abs_value_of mpz2 = abs_value_of mpz1 ∧ alloc mpz2 = alloc mpz1 ∧ abs_size mpz2 = abs_size mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ zones mpz2 = zones mpz1 -> readers mpz2 u = readers mpz1 u - 1%Z ∧ (∀(y : mpz_ptr), ¬ y = u -> readers mpz2 y = readers mpz1 y) -> valid_string sp4 ∧ String_value.string_in_base (effective (bv_signed base)) (pelts sp4) (offset sp4) ∧ (∀(x : mpz_ptr), mpz_unchanged x mpz2 mpz) ∧ value_text (effective (bv_signed base)) (pelts sp4) (offset sp4) = value_of u mpz2))))))))))))))))) else 0%Z ≤ bv_signed base1 ∧ (∀(o6 : bv 64%N), bv_unsigned o6 = bv_signed base1 -> (2%Z ≤ bv_unsigned o6 ∧ bv_unsigned o6 ≤ 256%Z) ∧ (∀(info : wmpn_base_info), b info = bv_unsigned o6 -> 0%Z ≤ bv_signed un ∧ (∀(o7 : bv 32%N), bv_unsigned o7 = bv_signed un -> 0%Z ≤ bv_unsigned o7 ∧ (∀(tp : C.ptr (bv 64%N)), plength tp = bv_unsigned o7 ∧ offset tp = 0%Z ∧ min tp = 0%Z ∧ C.max tp = bv_unsigned o7 ∧ writable tp = true -> (valid up (bv_signed un) ∧ valid tp (bv_signed un) ∧ writable tp = true) ∧ (∀(tp1 : C.ptr (bv 64%N)) (up1 : C.ptr (bv 64%N)), offset tp1 = offset tp ∧ writable tp1 = writable tp ∧ zone1 tp1 = zone1 tp -> offset up1 = offset up ∧ writable up1 = writable up ∧ zone1 up1 = zone1 up -> map_eq_sub_shift (pelts tp1) (pelts up) (offset tp1) (offset up) (bv_signed un) ∧ (∀(j : Z), j < offset tp1 ∨ offset tp1 + bv_signed un ≤ j -> pelts tp1 j = pelts tp j) ∧ (∀(j : Z), pelts up1 j = pelts up j) ∧ (min up1 = min up ∧ C.max up1 = C.max up ∧ plength up1 = plength up) ∧ min tp1 = min tp ∧ C.max tp1 = C.max tp ∧ plength tp1 = plength tp -> int'32_in_bounds (bv_signed sz - bv_signed o4) ∧ (∀(o8 : bv 32%N), bv_signed o8 = bv_signed sz - bv_signed o4 -> (valid tp1 (bv_signed un) ∧ 1%Z ≤ bv_signed un ∧ b info = bv_signed base1 ∧ writable tp1 = true ∧ writable uspi = true ∧ 0%Z < bv_unsigned (pelts tp1 (offset tp1 + bv_signed un - 1%Z)) ∧ 0%Z < bv_signed o8 ∧ valid uspi (bv_signed o8) ∧ value tp1 (bv_signed un) < Z.pow (bv_signed base1) (bv_signed o8 - 1%Z)) ∧ (∀(uspi1 : C.ptr (bv 8%N)) (usp1 : C.ptr (bv 8%N)), data uspi1 = data usp1 ∧ length (data usp1) = length (data uspi) ∧ offset uspi1 = offset uspi ∧ min uspi1 = min uspi ∧ C.max uspi1 = C.max uspi ∧ writable uspi1 = writable uspi ∧ zone1 uspi1 = zone1 uspi -> length (data usp1) = length (data usp) ∧ offset usp1 = offset usp ∧ min usp1 = min usp ∧ C.max usp1 = C.max usp ∧ writable usp1 = writable usp ∧ zone1 usp1 = zone1 usp -> (∀(g : bv 32%N), (0%Z ≤ bv_unsigned g ∧ bv_unsigned g < bv_signed o8) ∧ svalue (bv_signed base1) uspi1 (bv_unsigned g) = value tp1 (bv_signed un) ∧ in_base (bv_signed base1) (pelts uspi1) (offset uspi1) (offset uspi1 + bv_unsigned g) ∧ 0%Z < bv_signed (pelts uspi1 (offset uspi1)) ∧ (∀(j : Z), j < offset uspi1 ∨ offset uspi1 + bv_signed o8 ≤ j -> pelts uspi1 j = pelts uspi j) -> bv_unsigned g ≤ 2147483647%Z ∧ (∀(o9 : bv 32%N), bv_signed o9 = bv_unsigned g -> int'32_in_bounds (bv_signed o4 + bv_signed o9) ∧ (∀(o10 : bv 32%N), bv_signed o10 = bv_signed o4 + bv_signed o9 -> (UChar.ok mem = true ∧ UChar.z mem = zone1 sp2 ∧ UChar.mi mem = min usp1 ∧ UChar.ma mem = C.max usp1 ∧ offset sp2 = offset usp1 ∧ plength usp1 = UChar.l mem) ∧ (∀(mem1 : UChar.cast_mem) (sp3 : C.ptr ascii), UChar.mi mem1 = UChar.mi mem ∧ UChar.ma mem1 = UChar.ma mem ∧ UChar.z mem1 = UChar.z mem ∧ UChar.l mem1 = UChar.l mem -> offset sp3 = offset sp2 ∧ writable sp3 = writable sp2 ∧ zone1 sp3 = zone1 sp2 -> (min sp3 = UChar.mi mem1 ∧ C.max sp3 = UChar.ma mem1) ∧ (∀(i : Z), 0%Z ≤ i ∧ i < plength sp3 -> pelts sp3 i = Ascii.ascii_of_nat (Z.to_nat (bv_unsigned (pelts usp1 i)))) ∧ plength sp3 = plength usp1 -> int'32_in_bounds (bv_signed o10 - 1%Z) ∧ (∀(o11 : bv 32%N), bv_signed o11 = bv_signed o10 - 1%Z -> (bv_signed o4 ≤ bv_signed o11 + 1%Z -> ((bv_signed o4 ≤ bv_signed o4 ∧ bv_signed o4 ≤ bv_signed o10) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + bv_signed o4)) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + bv_signed o4)) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + bv_signed o4)) ∧ abs_value_sub_text (bv_signed base1) (pelts sp3) (offset sp3 + bv_signed o4) (offset sp3 + bv_signed o4) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + bv_signed o4) (offset usp1 + bv_signed o4) ∧ (∀(k : Z), offset sp3 ≤ k ∧ k < offset sp3 + bv_signed o4 -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp3 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp3) (offset sp3 + bv_signed o4) (offset sp3 + bv_signed o4) ∧ (bv_signed o4 = 1%Z -> pelts sp3 (offset sp3) = get_str_i "-"%string 0%Z) ∧ (bv_signed o4 = 0%Z -> bv_signed o4 < bv_signed o4 -> ¬ pelts sp3 (offset sp3) = get_str_i "-"%string 0%Z)) ∧ (∀(sp4 : C.ptr ascii), length (data sp4) = length (data sp3) ∧ offset sp4 = offset sp3 ∧ min sp4 = min sp3 ∧ C.max sp4 = C.max sp3 ∧ writable sp4 = writable sp3 ∧ zone1 sp4 = zone1 sp3 -> (∀(j : bv 32%N), let j1 : Z := bv_signed j in (bv_signed o4 ≤ j1 ∧ j1 ≤ bv_signed o11) ∧ (bv_signed o4 ≤ j1 ∧ j1 ≤ bv_signed o10) ∧ (∀(k : Z), offset sp4 + j1 ≤ offset sp4 + k ∧ offset sp4 + k < offset sp4 + bv_signed o10 -> pelts sp4 (offset sp4 + k) = pelts sp3 (offset sp4 + k)) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + j1)) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + j1)) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + j1)) ∧ abs_value_sub_text (bv_signed base1) (pelts sp4) (offset sp4 + bv_signed o4) (offset sp4 + j1) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + bv_signed o4) (offset usp1 + j1) ∧ (∀(k : Z), offset sp4 ≤ k ∧ k < offset sp4 + j1 -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp4 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp4) (offset sp4 + bv_signed o4) (offset sp4 + j1) ∧ (bv_signed o4 = 1%Z -> pelts sp4 (offset sp4) = get_str_i "-"%string 0%Z) ∧ (bv_signed o4 = 0%Z -> bv_signed o4 < j1 -> ¬ pelts sp4 (offset sp4) = get_str_i "-"%string 0%Z) -> (min sp4 ≤ offset sp4 + bv_signed j ∧ offset sp4 + bv_signed j < C.max sp4) ∧ (let o12 : ascii := pelts sp4 (offset sp4 + bv_signed j) in let cj : bv 8%N := Z_to_bv 8%N (Z.of_nat (Ascii.nat_of_ascii o12)) in (0%Z ≤ Z.of_nat (Ascii.nat_of_ascii o12) ∧ Z.of_nat (Ascii.nat_of_ascii o12) ≤ 127%Z -> bv_signed cj = Z.of_nat (Ascii.nat_of_ascii o12)) -> (∀(o13 : bv 32%N), bv_signed o13 = bv_signed cj -> (0%Z ≤ bv_signed o13 ∧ bv_signed o13 ≤ Z.of_nat (String.length digits)) ∧ (∀(dc : ascii), (0%Z ≤ bv_signed o13 ∧ bv_signed o13 < Z.of_nat (String.length digits) -> dc = get_str_i digits (bv_signed o13)) ∧ (bv_signed o13 = Z.of_nat (String.length digits) -> dc = Ascii.ascii_of_nat 0%nat) -> ((min sp4 ≤ offset sp4 + bv_signed j ∧ offset sp4 + bv_signed j < C.max sp4) ∧ writable sp4 = true) ∧ (∀(sp5 : C.ptr ascii), length (data sp5) = length (data sp4) ∧ offset sp5 = offset sp4 ∧ min sp5 = min sp4 ∧ C.max sp5 = C.max sp4 ∧ writable sp5 = writable sp4 ∧ zone1 sp5 = zone1 sp4 -> pelts sp5 = fun_updt (pelts sp4) (offset sp5 + bv_signed j) dc ∧ pelts sp5 (offset sp5 + bv_signed j) = dc -> (bv_signed o4 ≤ j1 + 1%Z ∧ j1 + 1%Z ≤ bv_signed o10) ∧ (∀(k : Z), offset sp5 + (j1 + 1%Z) ≤ offset sp5 + k ∧ offset sp5 + k < offset sp5 + bv_signed o10 -> pelts sp5 (offset sp5 + k) = pelts sp3 (offset sp5 + k)) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp5) (offset sp5) (offset sp5 + (j1 + 1%Z))) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp5) (offset sp5) (offset sp5 + (j1 + 1%Z))) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp5) (offset sp5) (offset sp5 + (j1 + 1%Z))) ∧ abs_value_sub_text (bv_signed base1) (pelts sp5) (offset sp5 + bv_signed o4) (offset sp5 + (j1 + 1%Z)) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + bv_signed o4) (offset usp1 + (j1 + 1%Z)) ∧ (∀(k : Z), offset sp5 ≤ k ∧ k < offset sp5 + (j1 + 1%Z) -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp5 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp5) (offset sp5 + bv_signed o4) (offset sp5 + (j1 + 1%Z)) ∧ (bv_signed o4 = 1%Z -> pelts sp5 (offset sp5) = get_str_i "-"%string 0%Z) ∧ (bv_signed o4 = 0%Z -> bv_signed o4 < j1 + 1%Z -> ¬ pelts sp5 (offset sp5) = get_str_i "-"%string 0%Z)))))) ∧ ((bv_signed o4 ≤ bv_signed o11 + 1%Z ∧ bv_signed o11 + 1%Z ≤ bv_signed o10) ∧ (∀(k : Z), offset sp4 + (bv_signed o11 + 1%Z) ≤ offset sp4 + k ∧ offset sp4 + k < offset sp4 + bv_signed o10 -> pelts sp4 (offset sp4 + k) = pelts sp3 (offset sp4 + k)) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (bv_signed o11 + 1%Z))) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (bv_signed o11 + 1%Z))) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (bv_signed o11 + 1%Z))) ∧ abs_value_sub_text (bv_signed base1) (pelts sp4) (offset sp4 + bv_signed o4) (offset sp4 + (bv_signed o11 + 1%Z)) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + bv_signed o4) (offset usp1 + (bv_signed o11 + 1%Z)) ∧ (∀(k : Z), offset sp4 ≤ k ∧ k < offset sp4 + (bv_signed o11 + 1%Z) -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp4 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp4) (offset sp4 + bv_signed o4) (offset sp4 + (bv_signed o11 + 1%Z)) ∧ (bv_signed o4 = 1%Z -> pelts sp4 (offset sp4) = get_str_i "-"%string 0%Z) ∧ (bv_signed o4 = 0%Z -> bv_signed o4 < bv_signed o11 + 1%Z -> ¬ pelts sp4 (offset sp4) = get_str_i "-"%string 0%Z) -> (let o12 : ascii := zero_char in ((min sp4 ≤ offset sp4 + bv_signed o10 ∧ offset sp4 + bv_signed o10 < C.max sp4) ∧ writable sp4 = true) ∧ (∀(sp5 : C.ptr ascii), length (data sp5) = length (data sp4) ∧ offset sp5 = offset sp4 ∧ min sp5 = min sp4 ∧ C.max sp5 = C.max sp4 ∧ writable sp5 = writable sp4 ∧ zone1 sp5 = zone1 sp4 -> pelts sp5 = fun_updt (pelts sp4) (offset sp5 + bv_signed o10) o12 ∧ pelts sp5 (offset sp5 + bv_signed o10) = o12 -> (zones mpz1 u = zone1 up1 ∧ 1%Z ≤ readers mpz1 u ∧ min up1 = 0%Z ∧ C.max up1 = plength up1) ∧ (∀(mpz2 : mpz_memo), abs_value_of mpz2 = abs_value_of mpz1 ∧ alloc mpz2 = alloc mpz1 ∧ abs_size mpz2 = abs_size mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ zones mpz2 = zones mpz1 -> readers mpz2 u = readers mpz1 u - 1%Z ∧ (∀(y : mpz_ptr), ¬ y = u -> readers mpz2 y = readers mpz1 y) -> valid_string sp5 ∧ String_value.string_in_base (effective (bv_signed base)) (pelts sp5) (offset sp5) ∧ (∀(x : mpz_ptr), mpz_unchanged x mpz2 mpz) ∧ value_text (effective (bv_signed base)) (pelts sp5) (offset sp5) = value_of u mpz2)))))) ∧ (bv_signed o11 + 1%Z < bv_signed o4 -> (let o12 : ascii := zero_char in ((min sp3 ≤ offset sp3 + bv_signed o10 ∧ offset sp3 + bv_signed o10 < C.max sp3) ∧ writable sp3 = true) ∧ (∀(sp4 : C.ptr ascii), length (data sp4) = length (data sp3) ∧ offset sp4 = offset sp3 ∧ min sp4 = min sp3 ∧ C.max sp4 = C.max sp3 ∧ writable sp4 = writable sp3 ∧ zone1 sp4 = zone1 sp3 -> pelts sp4 = fun_updt (pelts sp3) (offset sp4 + bv_signed o10) o12 ∧ pelts sp4 (offset sp4 + bv_signed o10) = o12 -> (zones mpz1 u = zone1 up1 ∧ 1%Z ≤ readers mpz1 u ∧ min up1 = 0%Z ∧ C.max up1 = plength up1) ∧ (∀(mpz2 : mpz_memo), abs_value_of mpz2 = abs_value_of mpz1 ∧ alloc mpz2 = alloc mpz1 ∧ abs_size mpz2 = abs_size mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ zones mpz2 = zones mpz1 -> readers mpz2 u = readers mpz1 u - 1%Z ∧ (∀(y : mpz_ptr), ¬ y = u -> readers mpz2 y = readers mpz1 y) -> valid_string sp4 ∧ String_value.string_in_base (effective (bv_signed base)) (pelts sp4) (offset sp4) ∧ (∀(x : mpz_ptr), mpz_unchanged x mpz2 mpz) ∧ value_text (effective (bv_signed base)) (pelts sp4) (offset sp4) = value_of u mpz2)))))))))))))))))))))))))) else 0%Z ≤ bv_signed base1 ∧ (∀(o3 : bv 64%N), bv_unsigned o3 = bv_signed base1 -> (2%Z ≤ bv_unsigned o3 ∧ bv_unsigned o3 ≤ 256%Z) ∧ (∀(bits : bv 32%N), (0%Z ≤ bv_unsigned bits ∧ bv_unsigned bits ≤ 8%Z) ∧ (¬ bv_unsigned bits = 0%Z -> Z.pow 2%Z (bv_unsigned bits) = bv_unsigned o3) ∧ (bv_unsigned bits = 0%Z -> (∀(n : Z), 0%Z ≤ n -> ¬ Z.pow 2%Z n = bv_unsigned o3)) -> 0%Z ≤ readers mpz u ∧ (∀(mpz1 : mpz_memo), abs_value_of mpz1 = abs_value_of mpz ∧ alloc mpz1 = alloc mpz ∧ abs_size mpz1 = abs_size mpz ∧ sgn mpz1 = sgn mpz ∧ zones mpz1 = zones mpz -> (∀(up : C.ptr (bv 64%N)), readers mpz1 u = readers mpz u + 1%Z ∧ (∀(y : mpz_ptr), ¬ u = y -> readers mpz1 y = readers mpz y) ∧ value up (abs_size mpz1 u) = abs_value_of mpz1 u ∧ plength up = alloc mpz1 u ∧ offset up = 0%Z ∧ min up = 0%Z ∧ C.max up = plength up ∧ zone1 up = zones mpz1 u -> writable sp = true ∧ (∀(sp1 : C.ptr ascii), offset sp1 = offset sp ∧ writable sp1 = writable sp ∧ zone1 sp1 = zone1 sp -> (∀(usp : C.ptr (bv 8%N)) (mem : UChar.cast_mem), (min usp = min sp ∧ min sp = UChar.mi mem) ∧ (C.max usp = C.max sp ∧ C.max sp = UChar.ma mem) ∧ zone1 sp = UChar.z mem ∧ (plength usp = plength sp ∧ plength sp = UChar.l mem) ∧ UChar.ok mem = true ∧ offset usp = offset sp ∧ (∀(i : Z), 0%Z ≤ i ∧ i < plength sp -> pelts usp i = Z_to_bv 8%N (Z.of_nat (Ascii.nat_of_ascii (pelts sp i)))) ∧ writable usp = true -> (min usp ≤ offset usp + 0%Z ∧ offset usp + 0%Z ≤ C.max usp) ∧ (∀(uspi : C.ptr (bv 8%N)), offset uspi = offset usp + 0%Z ∧ plength uspi = plength usp ∧ pelts uspi = pelts usp ∧ data uspi = data usp ∧ min uspi = min usp ∧ C.max uspi = C.max usp ∧ zone1 uspi = zone1 usp ∧ writable uspi = writable usp -> (bv_unsigned bits = 0%Z -> bits = (0%bv : bv 32%N)) -> (if decide (¬ bits = (0%bv : bv 32%N)) then int'32_in_bounds (bv_signed un - 1%Z) ∧ (∀(o4 : bv 32%N), bv_signed o4 = bv_signed un - 1%Z -> (min up ≤ offset up + bv_signed o4 ∧ offset up + bv_signed o4 < C.max up) ∧ (let um : bv 64%N := pelts up (offset up + bv_signed o4) in 0%Z < bv_unsigned um ∧ (∀(sb : bv 64%N), (1%Z ≤ bv_unsigned sb ∧ bv_unsigned sb ≤ 64%Z) ∧ Z.pow 2%Z (bv_unsigned sb - 1%Z) ≤ bv_unsigned um ∧ bv_unsigned um < Z.pow 2%Z (bv_unsigned sb) -> bv_unsigned sb ≤ 2147483647%Z ∧ (∀(o5 : bv 32%N), bv_signed o5 = bv_unsigned sb -> int'32_in_bounds (bv_signed un - 1%Z) ∧ (∀(o6 : bv 32%N), bv_signed o6 = bv_signed un - 1%Z -> int'32_in_bounds (64%Z * bv_signed o6) ∧ (∀(o7 : bv 32%N), bv_signed o7 = 64%Z * bv_signed o6 -> int'32_in_bounds (bv_signed o7 + bv_signed o5) ∧ (∀(ub : bv 32%N), bv_signed ub = bv_signed o7 + bv_signed o5 -> (1%Z ≤ bv_signed un ∧ valid up (bv_signed un) ∧ (1%Z ≤ bv_unsigned bits ∧ bv_unsigned bits ≤ 8%Z) ∧ valid uspi (ZEuclid.div (bv_signed ub + bv_unsigned bits - 1%Z) (bv_unsigned bits)) ∧ 0%Z ≤ bv_signed ub ∧ value up (bv_signed un) < Z.pow 2%Z (bv_signed ub) ∧ 0%Z < bv_unsigned (pelts up (offset up + bv_signed un - 1%Z)) ∧ 64%Z * bv_signed un + 7%Z ≤ 2147483647%Z ∧ writable uspi = true) ∧ (∀(uspi1 : C.ptr (bv 8%N)) (usp1 : C.ptr (bv 8%N)), data uspi1 = data usp1 ∧ length (data usp1) = length (data uspi) ∧ offset uspi1 = offset uspi ∧ min uspi1 = min uspi ∧ C.max uspi1 = C.max uspi ∧ writable uspi1 = writable uspi ∧ zone1 uspi1 = zone1 uspi -> length (data usp1) = length (data usp) ∧ offset usp1 = offset usp ∧ min usp1 = min usp ∧ C.max usp1 = C.max usp ∧ writable usp1 = writable usp ∧ zone1 usp1 = zone1 usp -> (∀(g : bv 32%N), in_base (Z.pow 2%Z (bv_unsigned bits)) (pelts uspi1) (offset uspi1) (offset uspi1 + bv_unsigned g) ∧ svalue (Z.pow 2%Z (bv_unsigned bits)) uspi1 (bv_unsigned g) = value up (bv_signed un) ∧ (0%Z < bv_unsigned g ∧ bv_unsigned g ≤ ZEuclid.div (bv_signed ub + bv_unsigned bits - 1%Z) (bv_unsigned bits)) ∧ 0%Z < bv_signed (pelts uspi1 (offset uspi1)) ∧ (∀(j : Z), j < offset uspi1 ∨ offset uspi1 + ZEuclid.div (bv_signed ub + bv_unsigned bits - 1%Z) (bv_unsigned bits) ≤ j -> pelts uspi1 j = pelts uspi j) -> bv_unsigned g ≤ 2147483647%Z ∧ (∀(o8 : bv 32%N), bv_signed o8 = bv_unsigned g -> int'32_in_bounds (0%Z + bv_signed o8) ∧ (∀(o9 : bv 32%N), bv_signed o9 = 0%Z + bv_signed o8 -> (UChar.ok mem = true ∧ UChar.z mem = zone1 sp1 ∧ UChar.mi mem = min usp1 ∧ UChar.ma mem = C.max usp1 ∧ offset sp1 = offset usp1 ∧ plength usp1 = UChar.l mem) ∧ (∀(mem1 : UChar.cast_mem) (sp2 : C.ptr ascii), UChar.mi mem1 = UChar.mi mem ∧ UChar.ma mem1 = UChar.ma mem ∧ UChar.z mem1 = UChar.z mem ∧ UChar.l mem1 = UChar.l mem -> offset sp2 = offset sp1 ∧ writable sp2 = writable sp1 ∧ zone1 sp2 = zone1 sp1 -> (min sp2 = UChar.mi mem1 ∧ C.max sp2 = UChar.ma mem1) ∧ (∀(i : Z), 0%Z ≤ i ∧ i < plength sp2 -> pelts sp2 i = Ascii.ascii_of_nat (Z.to_nat (bv_unsigned (pelts usp1 i)))) ∧ plength sp2 = plength usp1 -> int'32_in_bounds (bv_signed o9 - 1%Z) ∧ (∀(o10 : bv 32%N), bv_signed o10 = bv_signed o9 - 1%Z -> (0%Z ≤ bv_signed o10 + 1%Z -> ((0%Z ≤ 0%Z ∧ 0%Z ≤ bv_signed o9) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp2) (offset sp2) (offset sp2 + 0%Z)) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp2) (offset sp2) (offset sp2 + 0%Z)) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp2) (offset sp2) (offset sp2 + 0%Z)) ∧ abs_value_sub_text (bv_signed base1) (pelts sp2) (offset sp2 + 0%Z) (offset sp2 + 0%Z) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + 0%Z) (offset usp1 + 0%Z) ∧ (∀(k : Z), offset sp2 ≤ k ∧ k < offset sp2 + 0%Z -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp2 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp2) (offset sp2 + 0%Z) (offset sp2 + 0%Z) ∧ (0%Z = 1%Z -> pelts sp2 (offset sp2) = get_str_i "-"%string 0%Z) ∧ (0%Z < 0%Z -> ¬ pelts sp2 (offset sp2) = get_str_i "-"%string 0%Z)) ∧ (∀(sp3 : C.ptr ascii), length (data sp3) = length (data sp2) ∧ offset sp3 = offset sp2 ∧ min sp3 = min sp2 ∧ C.max sp3 = C.max sp2 ∧ writable sp3 = writable sp2 ∧ zone1 sp3 = zone1 sp2 -> (∀(j : bv 32%N), let j1 : Z := bv_signed j in (0%Z ≤ j1 ∧ j1 ≤ bv_signed o10) ∧ (0%Z ≤ j1 ∧ j1 ≤ bv_signed o9) ∧ (∀(k : Z), offset sp3 + j1 ≤ offset sp3 + k ∧ offset sp3 + k < offset sp3 + bv_signed o9 -> pelts sp3 (offset sp3 + k) = pelts sp2 (offset sp3 + k)) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + j1)) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + j1)) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + j1)) ∧ abs_value_sub_text (bv_signed base1) (pelts sp3) (offset sp3 + 0%Z) (offset sp3 + j1) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + 0%Z) (offset usp1 + j1) ∧ (∀(k : Z), offset sp3 ≤ k ∧ k < offset sp3 + j1 -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp3 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp3) (offset sp3 + 0%Z) (offset sp3 + j1) ∧ (0%Z = 1%Z -> pelts sp3 (offset sp3) = get_str_i "-"%string 0%Z) ∧ (0%Z < j1 -> ¬ pelts sp3 (offset sp3) = get_str_i "-"%string 0%Z) -> (min sp3 ≤ offset sp3 + bv_signed j ∧ offset sp3 + bv_signed j < C.max sp3) ∧ (let o11 : ascii := pelts sp3 (offset sp3 + bv_signed j) in let cj : bv 8%N := Z_to_bv 8%N (Z.of_nat (Ascii.nat_of_ascii o11)) in (0%Z ≤ Z.of_nat (Ascii.nat_of_ascii o11) ∧ Z.of_nat (Ascii.nat_of_ascii o11) ≤ 127%Z -> bv_signed cj = Z.of_nat (Ascii.nat_of_ascii o11)) -> (∀(o12 : bv 32%N), bv_signed o12 = bv_signed cj -> (0%Z ≤ bv_signed o12 ∧ bv_signed o12 ≤ Z.of_nat (String.length digits)) ∧ (∀(dc : ascii), (0%Z ≤ bv_signed o12 ∧ bv_signed o12 < Z.of_nat (String.length digits) -> dc = get_str_i digits (bv_signed o12)) ∧ (bv_signed o12 = Z.of_nat (String.length digits) -> dc = Ascii.ascii_of_nat 0%nat) -> ((min sp3 ≤ offset sp3 + bv_signed j ∧ offset sp3 + bv_signed j < C.max sp3) ∧ writable sp3 = true) ∧ (∀(sp4 : C.ptr ascii), length (data sp4) = length (data sp3) ∧ offset sp4 = offset sp3 ∧ min sp4 = min sp3 ∧ C.max sp4 = C.max sp3 ∧ writable sp4 = writable sp3 ∧ zone1 sp4 = zone1 sp3 -> pelts sp4 = fun_updt (pelts sp3) (offset sp4 + bv_signed j) dc ∧ pelts sp4 (offset sp4 + bv_signed j) = dc -> (0%Z ≤ j1 + 1%Z ∧ j1 + 1%Z ≤ bv_signed o9) ∧ (∀(k : Z), offset sp4 + (j1 + 1%Z) ≤ offset sp4 + k ∧ offset sp4 + k < offset sp4 + bv_signed o9 -> pelts sp4 (offset sp4 + k) = pelts sp2 (offset sp4 + k)) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (j1 + 1%Z))) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (j1 + 1%Z))) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (j1 + 1%Z))) ∧ abs_value_sub_text (bv_signed base1) (pelts sp4) (offset sp4 + 0%Z) (offset sp4 + (j1 + 1%Z)) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + 0%Z) (offset usp1 + (j1 + 1%Z)) ∧ (∀(k : Z), offset sp4 ≤ k ∧ k < offset sp4 + (j1 + 1%Z) -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp4 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp4) (offset sp4 + 0%Z) (offset sp4 + (j1 + 1%Z)) ∧ (0%Z = 1%Z -> pelts sp4 (offset sp4) = get_str_i "-"%string 0%Z) ∧ (0%Z < j1 + 1%Z -> ¬ pelts sp4 (offset sp4) = get_str_i "-"%string 0%Z)))))) ∧ ((0%Z ≤ bv_signed o10 + 1%Z ∧ bv_signed o10 + 1%Z ≤ bv_signed o9) ∧ (∀(k : Z), offset sp3 + (bv_signed o10 + 1%Z) ≤ offset sp3 + k ∧ offset sp3 + k < offset sp3 + bv_signed o9 -> pelts sp3 (offset sp3 + k) = pelts sp2 (offset sp3 + k)) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + (bv_signed o10 + 1%Z))) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + (bv_signed o10 + 1%Z))) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + (bv_signed o10 + 1%Z))) ∧ abs_value_sub_text (bv_signed base1) (pelts sp3) (offset sp3 + 0%Z) (offset sp3 + (bv_signed o10 + 1%Z)) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + 0%Z) (offset usp1 + (bv_signed o10 + 1%Z)) ∧ (∀(k : Z), offset sp3 ≤ k ∧ k < offset sp3 + (bv_signed o10 + 1%Z) -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp3 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp3) (offset sp3 + 0%Z) (offset sp3 + (bv_signed o10 + 1%Z)) ∧ (0%Z = 1%Z -> pelts sp3 (offset sp3) = get_str_i "-"%string 0%Z) ∧ (0%Z < bv_signed o10 + 1%Z -> ¬ pelts sp3 (offset sp3) = get_str_i "-"%string 0%Z) -> (let o11 : ascii := zero_char in ((min sp3 ≤ offset sp3 + bv_signed o9 ∧ offset sp3 + bv_signed o9 < C.max sp3) ∧ writable sp3 = true) ∧ (∀(sp4 : C.ptr ascii), length (data sp4) = length (data sp3) ∧ offset sp4 = offset sp3 ∧ min sp4 = min sp3 ∧ C.max sp4 = C.max sp3 ∧ writable sp4 = writable sp3 ∧ zone1 sp4 = zone1 sp3 -> pelts sp4 = fun_updt (pelts sp3) (offset sp4 + bv_signed o9) o11 ∧ pelts sp4 (offset sp4 + bv_signed o9) = o11 -> (zones mpz1 u = zone1 up ∧ 1%Z ≤ readers mpz1 u ∧ min up = 0%Z ∧ C.max up = plength up) ∧ (∀(mpz2 : mpz_memo), abs_value_of mpz2 = abs_value_of mpz1 ∧ alloc mpz2 = alloc mpz1 ∧ abs_size mpz2 = abs_size mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ zones mpz2 = zones mpz1 -> readers mpz2 u = readers mpz1 u - 1%Z ∧ (∀(y : mpz_ptr), ¬ y = u -> readers mpz2 y = readers mpz1 y) -> valid_string sp4 ∧ String_value.string_in_base (effective (bv_signed base)) (pelts sp4) (offset sp4) ∧ (∀(x : mpz_ptr), mpz_unchanged x mpz2 mpz) ∧ value_text (effective (bv_signed base)) (pelts sp4) (offset sp4) = value_of u mpz2)))))) ∧ (bv_signed o10 + 1%Z < 0%Z -> (let o11 : ascii := zero_char in ((min sp2 ≤ offset sp2 + bv_signed o9 ∧ offset sp2 + bv_signed o9 < C.max sp2) ∧ writable sp2 = true) ∧ (∀(sp3 : C.ptr ascii), length (data sp3) = length (data sp2) ∧ offset sp3 = offset sp2 ∧ min sp3 = min sp2 ∧ C.max sp3 = C.max sp2 ∧ writable sp3 = writable sp2 ∧ zone1 sp3 = zone1 sp2 -> pelts sp3 = fun_updt (pelts sp2) (offset sp3 + bv_signed o9) o11 ∧ pelts sp3 (offset sp3 + bv_signed o9) = o11 -> (zones mpz1 u = zone1 up ∧ 1%Z ≤ readers mpz1 u ∧ min up = 0%Z ∧ C.max up = plength up) ∧ (∀(mpz2 : mpz_memo), abs_value_of mpz2 = abs_value_of mpz1 ∧ alloc mpz2 = alloc mpz1 ∧ abs_size mpz2 = abs_size mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ zones mpz2 = zones mpz1 -> readers mpz2 u = readers mpz1 u - 1%Z ∧ (∀(y : mpz_ptr), ¬ y = u -> readers mpz2 y = readers mpz1 y) -> valid_string sp3 ∧ String_value.string_in_base (effective (bv_signed base)) (pelts sp3) (offset sp3) ∧ (∀(x : mpz_ptr), mpz_unchanged x mpz2 mpz) ∧ value_text (effective (bv_signed base)) (pelts sp3) (offset sp3) = value_of u mpz2))))))))))))))))) else 0%Z ≤ bv_signed base1 ∧ (∀(o4 : bv 64%N), bv_unsigned o4 = bv_signed base1 -> (2%Z ≤ bv_unsigned o4 ∧ bv_unsigned o4 ≤ 256%Z) ∧ (∀(info : wmpn_base_info), b info = bv_unsigned o4 -> 0%Z ≤ bv_signed un ∧ (∀(o5 : bv 32%N), bv_unsigned o5 = bv_signed un -> 0%Z ≤ bv_unsigned o5 ∧ (∀(tp : C.ptr (bv 64%N)), plength tp = bv_unsigned o5 ∧ offset tp = 0%Z ∧ min tp = 0%Z ∧ C.max tp = bv_unsigned o5 ∧ writable tp = true -> (valid up (bv_signed un) ∧ valid tp (bv_signed un) ∧ writable tp = true) ∧ (∀(tp1 : C.ptr (bv 64%N)) (up1 : C.ptr (bv 64%N)), offset tp1 = offset tp ∧ writable tp1 = writable tp ∧ zone1 tp1 = zone1 tp -> offset up1 = offset up ∧ writable up1 = writable up ∧ zone1 up1 = zone1 up -> map_eq_sub_shift (pelts tp1) (pelts up) (offset tp1) (offset up) (bv_signed un) ∧ (∀(j : Z), j < offset tp1 ∨ offset tp1 + bv_signed un ≤ j -> pelts tp1 j = pelts tp j) ∧ (∀(j : Z), pelts up1 j = pelts up j) ∧ (min up1 = min up ∧ C.max up1 = C.max up ∧ plength up1 = plength up) ∧ min tp1 = min tp ∧ C.max tp1 = C.max tp ∧ plength tp1 = plength tp -> int'32_in_bounds (bv_signed sz - 0%Z) ∧ (∀(o6 : bv 32%N), bv_signed o6 = bv_signed sz - 0%Z -> (valid tp1 (bv_signed un) ∧ 1%Z ≤ bv_signed un ∧ b info = bv_signed base1 ∧ writable tp1 = true ∧ writable uspi = true ∧ 0%Z < bv_unsigned (pelts tp1 (offset tp1 + bv_signed un - 1%Z)) ∧ 0%Z < bv_signed o6 ∧ valid uspi (bv_signed o6) ∧ value tp1 (bv_signed un) < Z.pow (bv_signed base1) (bv_signed o6 - 1%Z)) ∧ (∀(uspi1 : C.ptr (bv 8%N)) (usp1 : C.ptr (bv 8%N)), data uspi1 = data usp1 ∧ length (data usp1) = length (data uspi) ∧ offset uspi1 = offset uspi ∧ min uspi1 = min uspi ∧ C.max uspi1 = C.max uspi ∧ writable uspi1 = writable uspi ∧ zone1 uspi1 = zone1 uspi -> length (data usp1) = length (data usp) ∧ offset usp1 = offset usp ∧ min usp1 = min usp ∧ C.max usp1 = C.max usp ∧ writable usp1 = writable usp ∧ zone1 usp1 = zone1 usp -> (∀(g : bv 32%N), (0%Z ≤ bv_unsigned g ∧ bv_unsigned g < bv_signed o6) ∧ svalue (bv_signed base1) uspi1 (bv_unsigned g) = value tp1 (bv_signed un) ∧ in_base (bv_signed base1) (pelts uspi1) (offset uspi1) (offset uspi1 + bv_unsigned g) ∧ 0%Z < bv_signed (pelts uspi1 (offset uspi1)) ∧ (∀(j : Z), j < offset uspi1 ∨ offset uspi1 + bv_signed o6 ≤ j -> pelts uspi1 j = pelts uspi j) -> bv_unsigned g ≤ 2147483647%Z ∧ (∀(o7 : bv 32%N), bv_signed o7 = bv_unsigned g -> int'32_in_bounds (0%Z + bv_signed o7) ∧ (∀(o8 : bv 32%N), bv_signed o8 = 0%Z + bv_signed o7 -> (UChar.ok mem = true ∧ UChar.z mem = zone1 sp1 ∧ UChar.mi mem = min usp1 ∧ UChar.ma mem = C.max usp1 ∧ offset sp1 = offset usp1 ∧ plength usp1 = UChar.l mem) ∧ (∀(mem1 : UChar.cast_mem) (sp2 : C.ptr ascii), UChar.mi mem1 = UChar.mi mem ∧ UChar.ma mem1 = UChar.ma mem ∧ UChar.z mem1 = UChar.z mem ∧ UChar.l mem1 = UChar.l mem -> offset sp2 = offset sp1 ∧ writable sp2 = writable sp1 ∧ zone1 sp2 = zone1 sp1 -> (min sp2 = UChar.mi mem1 ∧ C.max sp2 = UChar.ma mem1) ∧ (∀(i : Z), 0%Z ≤ i ∧ i < plength sp2 -> pelts sp2 i = Ascii.ascii_of_nat (Z.to_nat (bv_unsigned (pelts usp1 i)))) ∧ plength sp2 = plength usp1 -> int'32_in_bounds (bv_signed o8 - 1%Z) ∧ (∀(o9 : bv 32%N), bv_signed o9 = bv_signed o8 - 1%Z -> (0%Z ≤ bv_signed o9 + 1%Z -> ((0%Z ≤ 0%Z ∧ 0%Z ≤ bv_signed o8) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp2) (offset sp2) (offset sp2 + 0%Z)) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp2) (offset sp2) (offset sp2 + 0%Z)) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp2) (offset sp2) (offset sp2 + 0%Z)) ∧ abs_value_sub_text (bv_signed base1) (pelts sp2) (offset sp2 + 0%Z) (offset sp2 + 0%Z) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + 0%Z) (offset usp1 + 0%Z) ∧ (∀(k : Z), offset sp2 ≤ k ∧ k < offset sp2 + 0%Z -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp2 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp2) (offset sp2 + 0%Z) (offset sp2 + 0%Z) ∧ (0%Z = 1%Z -> pelts sp2 (offset sp2) = get_str_i "-"%string 0%Z) ∧ (0%Z < 0%Z -> ¬ pelts sp2 (offset sp2) = get_str_i "-"%string 0%Z)) ∧ (∀(sp3 : C.ptr ascii), length (data sp3) = length (data sp2) ∧ offset sp3 = offset sp2 ∧ min sp3 = min sp2 ∧ C.max sp3 = C.max sp2 ∧ writable sp3 = writable sp2 ∧ zone1 sp3 = zone1 sp2 -> (∀(j : bv 32%N), let j1 : Z := bv_signed j in (0%Z ≤ j1 ∧ j1 ≤ bv_signed o9) ∧ (0%Z ≤ j1 ∧ j1 ≤ bv_signed o8) ∧ (∀(k : Z), offset sp3 + j1 ≤ offset sp3 + k ∧ offset sp3 + k < offset sp3 + bv_signed o8 -> pelts sp3 (offset sp3 + k) = pelts sp2 (offset sp3 + k)) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + j1)) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + j1)) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + j1)) ∧ abs_value_sub_text (bv_signed base1) (pelts sp3) (offset sp3 + 0%Z) (offset sp3 + j1) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + 0%Z) (offset usp1 + j1) ∧ (∀(k : Z), offset sp3 ≤ k ∧ k < offset sp3 + j1 -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp3 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp3) (offset sp3 + 0%Z) (offset sp3 + j1) ∧ (0%Z = 1%Z -> pelts sp3 (offset sp3) = get_str_i "-"%string 0%Z) ∧ (0%Z < j1 -> ¬ pelts sp3 (offset sp3) = get_str_i "-"%string 0%Z) -> (min sp3 ≤ offset sp3 + bv_signed j ∧ offset sp3 + bv_signed j < C.max sp3) ∧ (let o10 : ascii := pelts sp3 (offset sp3 + bv_signed j) in let cj : bv 8%N := Z_to_bv 8%N (Z.of_nat (Ascii.nat_of_ascii o10)) in (0%Z ≤ Z.of_nat (Ascii.nat_of_ascii o10) ∧ Z.of_nat (Ascii.nat_of_ascii o10) ≤ 127%Z -> bv_signed cj = Z.of_nat (Ascii.nat_of_ascii o10)) -> (∀(o11 : bv 32%N), bv_signed o11 = bv_signed cj -> (0%Z ≤ bv_signed o11 ∧ bv_signed o11 ≤ Z.of_nat (String.length digits)) ∧ (∀(dc : ascii), (0%Z ≤ bv_signed o11 ∧ bv_signed o11 < Z.of_nat (String.length digits) -> dc = get_str_i digits (bv_signed o11)) ∧ (bv_signed o11 = Z.of_nat (String.length digits) -> dc = Ascii.ascii_of_nat 0%nat) -> ((min sp3 ≤ offset sp3 + bv_signed j ∧ offset sp3 + bv_signed j < C.max sp3) ∧ writable sp3 = true) ∧ (∀(sp4 : C.ptr ascii), length (data sp4) = length (data sp3) ∧ offset sp4 = offset sp3 ∧ min sp4 = min sp3 ∧ C.max sp4 = C.max sp3 ∧ writable sp4 = writable sp3 ∧ zone1 sp4 = zone1 sp3 -> pelts sp4 = fun_updt (pelts sp3) (offset sp4 + bv_signed j) dc ∧ pelts sp4 (offset sp4 + bv_signed j) = dc -> (0%Z ≤ j1 + 1%Z ∧ j1 + 1%Z ≤ bv_signed o8) ∧ (∀(k : Z), offset sp4 + (j1 + 1%Z) ≤ offset sp4 + k ∧ offset sp4 + k < offset sp4 + bv_signed o8 -> pelts sp4 (offset sp4 + k) = pelts sp2 (offset sp4 + k)) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (j1 + 1%Z))) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (j1 + 1%Z))) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (j1 + 1%Z))) ∧ abs_value_sub_text (bv_signed base1) (pelts sp4) (offset sp4 + 0%Z) (offset sp4 + (j1 + 1%Z)) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + 0%Z) (offset usp1 + (j1 + 1%Z)) ∧ (∀(k : Z), offset sp4 ≤ k ∧ k < offset sp4 + (j1 + 1%Z) -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp4 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp4) (offset sp4 + 0%Z) (offset sp4 + (j1 + 1%Z)) ∧ (0%Z = 1%Z -> pelts sp4 (offset sp4) = get_str_i "-"%string 0%Z) ∧ (0%Z < j1 + 1%Z -> ¬ pelts sp4 (offset sp4) = get_str_i "-"%string 0%Z)))))) ∧ ((0%Z ≤ bv_signed o9 + 1%Z ∧ bv_signed o9 + 1%Z ≤ bv_signed o8) ∧ (∀(k : Z), offset sp3 + (bv_signed o9 + 1%Z) ≤ offset sp3 + k ∧ offset sp3 + k < offset sp3 + bv_signed o8 -> pelts sp3 (offset sp3 + k) = pelts sp2 (offset sp3 + k)) ∧ (0%Z ≤ bv_signed base ∧ bv_signed base ≤ 36%Z -> to_lowercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + (bv_signed o9 + 1%Z))) ∧ (36%Z < bv_signed base -> to_bothcase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + (bv_signed o9 + 1%Z))) ∧ (bv_signed base < 0%Z -> to_uppercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + (bv_signed o9 + 1%Z))) ∧ abs_value_sub_text (bv_signed base1) (pelts sp3) (offset sp3 + 0%Z) (offset sp3 + (bv_signed o9 + 1%Z)) = svalue_sub (bv_signed base1) (pelts usp1) (offset usp1 + 0%Z) (offset usp1 + (bv_signed o9 + 1%Z)) ∧ (∀(k : Z), offset sp3 ≤ k ∧ k < offset sp3 + (bv_signed o9 + 1%Z) -> ¬ Z.of_nat (Ascii.nat_of_ascii (pelts sp3 k)) = 0%Z) ∧ text_in_base (bv_signed base1) (pelts sp3) (offset sp3 + 0%Z) (offset sp3 + (bv_signed o9 + 1%Z)) ∧ (0%Z = 1%Z -> pelts sp3 (offset sp3) = get_str_i "-"%string 0%Z) ∧ (0%Z < bv_signed o9 + 1%Z -> ¬ pelts sp3 (offset sp3) = get_str_i "-"%string 0%Z) -> (let o10 : ascii := zero_char in ((min sp3 ≤ offset sp3 + bv_signed o8 ∧ offset sp3 + bv_signed o8 < C.max sp3) ∧ writable sp3 = true) ∧ (∀(sp4 : C.ptr ascii), length (data sp4) = length (data sp3) ∧ offset sp4 = offset sp3 ∧ min sp4 = min sp3 ∧ C.max sp4 = C.max sp3 ∧ writable sp4 = writable sp3 ∧ zone1 sp4 = zone1 sp3 -> pelts sp4 = fun_updt (pelts sp3) (offset sp4 + bv_signed o8) o10 ∧ pelts sp4 (offset sp4 + bv_signed o8) = o10 -> (zones mpz1 u = zone1 up1 ∧ 1%Z ≤ readers mpz1 u ∧ min up1 = 0%Z ∧ C.max up1 = plength up1) ∧ (∀(mpz2 : mpz_memo), abs_value_of mpz2 = abs_value_of mpz1 ∧ alloc mpz2 = alloc mpz1 ∧ abs_size mpz2 = abs_size mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ zones mpz2 = zones mpz1 -> readers mpz2 u = readers mpz1 u - 1%Z ∧ (∀(y : mpz_ptr), ¬ y = u -> readers mpz2 y = readers mpz1 y) -> valid_string sp4 ∧ String_value.string_in_base (effective (bv_signed base)) (pelts sp4) (offset sp4) ∧ (∀(x : mpz_ptr), mpz_unchanged x mpz2 mpz) ∧ value_text (effective (bv_signed base)) (pelts sp4) (offset sp4) = value_of u mpz2)))))) ∧ (bv_signed o9 + 1%Z < 0%Z -> (let o10 : ascii := zero_char in ((min sp2 ≤ offset sp2 + bv_signed o8 ∧ offset sp2 + bv_signed o8 < C.max sp2) ∧ writable sp2 = true) ∧ (∀(sp3 : C.ptr ascii), length (data sp3) = length (data sp2) ∧ offset sp3 = offset sp2 ∧ min sp3 = min sp2 ∧ C.max sp3 = C.max sp2 ∧ writable sp3 = writable sp2 ∧ zone1 sp3 = zone1 sp2 -> pelts sp3 = fun_updt (pelts sp2) (offset sp3 + bv_signed o8) o10 ∧ pelts sp3 (offset sp3 + bv_signed o8) = o10 -> (zones mpz1 u = zone1 up1 ∧ 1%Z ≤ readers mpz1 u ∧ min up1 = 0%Z ∧ C.max up1 = plength up1) ∧ (∀(mpz2 : mpz_memo), abs_value_of mpz2 = abs_value_of mpz1 ∧ alloc mpz2 = alloc mpz1 ∧ abs_size mpz2 = abs_size mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ zones mpz2 = zones mpz1 -> readers mpz2 u = readers mpz1 u - 1%Z ∧ (∀(y : mpz_ptr), ¬ y = u -> readers mpz2 y = readers mpz1 y) -> valid_string sp3 ∧ String_value.string_in_base (effective (bv_signed base)) (pelts sp3) (offset sp3) ∧ (∀(x : mpz_ptr), mpz_unchanged x mpz2 mpz) ∧ value_text (effective (bv_signed base)) (pelts sp3) (offset sp3) = value_of u mpz2))))))))))))))))))))))))))))))).
Admitted.
