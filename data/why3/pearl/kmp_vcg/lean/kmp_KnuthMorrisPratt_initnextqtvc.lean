import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace kmp_KnuthMorrisPratt_initnextqtvc
axiom char : Type
axiom inhabited_axiom_char : Inhabited char
attribute [instance] inhabited_axiom_char
noncomputable def matches1 (a1 : List char) (i1 : ℤ) (a2 : List char) (i2 : ℤ) (n : ℤ) := ((0 : ℤ) ≤ i1 ∧ i1 ≤ Int.ofNat (List.length a1) - n) ∧ ((0 : ℤ) ≤ i2 ∧ i2 ≤ Int.ofNat (List.length a2) - n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → a1[Int.toNat (i1 + i)]! = a2[Int.toNat (i2 + i)]!)
noncomputable def is_next (p : List char) (j : ℤ) (n : ℤ) := ((0 : ℤ) ≤ n ∧ n < j) ∧ matches1 p (j - n) p (0 : ℤ) n ∧ (∀(z : ℤ), n < z ∧ z < j → ¬matches1 p (j - z) p (0 : ℤ) z)
theorem initnext'vc (p : List char) (fact0 : (1 : ℤ) ≤ Int.ofNat (List.length p)) : let m : ℤ := Int.ofNat (List.length p); (0 : ℤ) ≤ m ∧ (∀(next : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < m → next[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length next) = m → (if (1 : ℤ) < m then ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < Int.ofNat (List.length next)) ∧ (List.length (List.set next (1 : ℕ) (0 : ℤ)) = List.length next → getElem! (List.set next (1 : ℕ) (0 : ℤ)) ∘ Int.toNat = Function.update (getElem! next ∘ Int.toNat) (1 : ℤ) (0 : ℤ) → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < (1 : ℤ) ∧ (1 : ℤ) ≤ m) ∧ matches1 p ((1 : ℤ) - (0 : ℤ)) p (0 : ℤ) (0 : ℤ) ∧ (∀(z : ℤ), (0 : ℤ) + (1 : ℤ) < z ∧ z < (1 : ℤ) + (1 : ℤ) → ¬matches1 p ((1 : ℤ) + (1 : ℤ) - z) p (0 : ℤ) z) ∧ (∀(k : ℤ), (0 : ℤ) < k ∧ k ≤ (1 : ℤ) → is_next p k ((List.set next (1 : ℕ) (0 : ℤ))[Int.toNat k]!))) ∧ (∀(j : ℤ) (i : ℤ) (next1 : List ℤ), List.length next1 = List.length (List.set next (1 : ℕ) (0 : ℤ)) → ((0 : ℤ) ≤ j ∧ j < i ∧ i ≤ m) ∧ matches1 p (i - j) p (0 : ℤ) j ∧ (∀(z : ℤ), j + (1 : ℤ) < z ∧ z < i + (1 : ℤ) → ¬matches1 p (i + (1 : ℤ) - z) p (0 : ℤ) z) ∧ (∀(k : ℤ), (0 : ℤ) < k ∧ k ≤ i → is_next p k (next1[Int.toNat k]!)) → (if i < m - (1 : ℤ) then ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length p)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length p)) ∧ (if p[Int.toNat i]! = p[Int.toNat j]! then ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) < Int.ofNat (List.length next1)) ∧ (List.length (List.set next1 (Int.toNat (i + (1 : ℤ))) (j + (1 : ℤ))) = List.length next1 → getElem! (List.set next1 (Int.toNat (i + (1 : ℤ))) (j + (1 : ℤ))) ∘ Int.toNat = Function.update (getElem! next1 ∘ Int.toNat) (i + (1 : ℤ)) (j + (1 : ℤ)) → ((0 : ℤ) ≤ m - i ∧ m - (i + (1 : ℤ)) < m - i ∨ m - i = m - (i + (1 : ℤ)) ∧ (0 : ℤ) ≤ j ∧ j + (1 : ℤ) < j) ∧ ((0 : ℤ) ≤ j + (1 : ℤ) ∧ j + (1 : ℤ) < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ m) ∧ matches1 p (i + (1 : ℤ) - (j + (1 : ℤ))) p (0 : ℤ) (j + (1 : ℤ)) ∧ (∀(z : ℤ), j + (1 : ℤ) + (1 : ℤ) < z ∧ z < i + (1 : ℤ) + (1 : ℤ) → ¬matches1 p (i + (1 : ℤ) + (1 : ℤ) - z) p (0 : ℤ) z) ∧ (∀(k : ℤ), (0 : ℤ) < k ∧ k ≤ i + (1 : ℤ) → is_next p k ((List.set next1 (Int.toNat (i + (1 : ℤ))) (j + (1 : ℤ)))[Int.toNat k]!))) else if j = (0 : ℤ) then ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) < Int.ofNat (List.length next1)) ∧ (List.length (List.set next1 (Int.toNat (i + (1 : ℤ))) (0 : ℤ)) = List.length next1 → getElem! (List.set next1 (Int.toNat (i + (1 : ℤ))) (0 : ℤ)) ∘ Int.toNat = Function.update (getElem! next1 ∘ Int.toNat) (i + (1 : ℤ)) (0 : ℤ) → ((0 : ℤ) ≤ m - i ∧ m - (i + (1 : ℤ)) < m - i ∨ m - i = m - (i + (1 : ℤ)) ∧ (0 : ℤ) ≤ j ∧ j < j) ∧ ((0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ m) ∧ matches1 p (i + (1 : ℤ) - j) p (0 : ℤ) j ∧ (∀(z : ℤ), j + (1 : ℤ) < z ∧ z < i + (1 : ℤ) + (1 : ℤ) → ¬matches1 p (i + (1 : ℤ) + (1 : ℤ) - z) p (0 : ℤ) z) ∧ (∀(k : ℤ), (0 : ℤ) < k ∧ k ≤ i + (1 : ℤ) → is_next p k ((List.set next1 (Int.toNat (i + (1 : ℤ))) (0 : ℤ))[Int.toNat k]!))) else ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length next1)) ∧ ((0 : ℤ) ≤ m - i ∧ m - i < m - i ∨ (0 : ℤ) ≤ j ∧ next1[Int.toNat j]! < j) ∧ ((0 : ℤ) ≤ next1[Int.toNat j]! ∧ next1[Int.toNat j]! < i ∧ i ≤ m) ∧ matches1 p (i - next1[Int.toNat j]!) p (0 : ℤ) (next1[Int.toNat j]!) ∧ (∀(z : ℤ), next1[Int.toNat j]! + (1 : ℤ) < z ∧ z < i + (1 : ℤ) → ¬matches1 p (i + (1 : ℤ) - z) p (0 : ℤ) z) ∧ (∀(k : ℤ), (0 : ℤ) < k ∧ k ≤ i → is_next p k (next1[Int.toNat k]!))) else List.length next1 = List.length p ∧ (∀(j1 : ℤ), (0 : ℤ) < j1 ∧ j1 < Int.ofNat (List.length p) → is_next p j1 (next1[Int.toNat j1]!))))) else List.length next = List.length p ∧ (∀(j : ℤ), (0 : ℤ) < j ∧ j < Int.ofNat (List.length p) → is_next p j (next[Int.toNat j]!))))
  := sorry
end kmp_KnuthMorrisPratt_initnextqtvc
