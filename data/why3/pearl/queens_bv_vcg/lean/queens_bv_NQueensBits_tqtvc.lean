import Why3.Base
import Why3.why3.WellFounded.WellFounded
import Why3.why3.Ref.Ref
import pearl.queens_bv_vcg.lean.queens_bv.S
import pearl.queens_bv_vcg.lean.queens_bv.Solution
import pearl.queens_bv_vcg.lean.queens_bv.BitsSpec
open Classical
open Lean4Why3
namespace queens_bv_NQueensBits_tqtvc
theorem t'vc (k : ℤ) (a : BitsSpec.t) (s : ℤ) (col : ℤ -> ℤ) (b : BitsSpec.t) (c : BitsSpec.t) (sol : ℤ -> ℤ -> ℤ) (fact0 : Solution.n ≤ (32 : ℤ)) (fact1 : (0 : ℤ) ≤ k) (fact2 : k + Int.ofNat (Finset.card (BitsSpec.mdl a)) = Solution.n) (fact3 : (0 : ℤ) ≤ s) (fact4 : ∀(i : ℤ), (i ∈ BitsSpec.mdl a) = (((0 : ℤ) ≤ i ∧ i < Solution.n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k → ¬col j = i))) (fact5 : ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (32 : ℤ) → (¬i ∈ BitsSpec.mdl b) = (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k → ¬i - col j = k - j)) (fact6 : ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (32 : ℤ) → (¬i ∈ BitsSpec.mdl c) = (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k → ¬i - col j = j - k)) (fact7 : Solution.partial_solution k col) : if ¬BitsSpec.mdl a = ∅ then ∀(o1 : BitsSpec.t), BitsSpec.mdl o1 = BitsSpec.mdl a \ BitsSpec.mdl b → (∀(o2 : BitsSpec.t), BitsSpec.mdl o2 = BitsSpec.mdl o1 \ BitsSpec.mdl c → ((¬BitsSpec.mdl o2 = ∅ → -(1 : ℤ) < Finset.min'' (BitsSpec.mdl o2)) ∧ ((0 : ℤ) = s - s ∧ (0 : ℤ) ≤ s - s) ∧ BitsSpec.mdl o2 ⊆ (BitsSpec.mdl a \ BitsSpec.mdl b) \ BitsSpec.mdl c ∧ Solution.partial_solution k col ∧ Solution.sorted sol s s ∧ (∀(i : ℤ), i ∈ BitsSpec.mdl o2 ∧ ¬i ∈ BitsSpec.mdl o2 → i ≤ -(1 : ℤ)) ∧ (∀(i : ℤ), s ≤ i ∧ i < s → Solution.partial_solution Solution.n (sol i) ∧ Solution.eq_prefix col (sol i) k ∧ (0 : ℤ) ≤ sol i k ∧ sol i k ≤ -(1 : ℤ)) ∧ (∀(u : ℤ -> ℤ), Solution.partial_solution Solution.n u ∧ Solution.eq_prefix col u k ∧ (0 : ℤ) ≤ u k ∧ u k ≤ -(1 : ℤ) → u k ∈ BitsSpec.mdl o2 ∧ ¬u k ∈ BitsSpec.mdl o2 ∧ (∃(i : ℤ), (s ≤ i ∧ i < s) ∧ Solution.eq_prefix u (sol i) Solution.n)) ∧ Solution.eq_prefix col col k ∧ Solution.eq_prefix sol sol s) ∧ (∀(min : ℤ) (e : BitsSpec.t) (s1 : ℤ) (sol1 : ℤ -> ℤ -> ℤ) (col1 : ℤ -> ℤ), (¬BitsSpec.mdl e = ∅ → min < Finset.min'' (BitsSpec.mdl e)) ∧ (0 : ℤ) ≤ s1 - s ∧ BitsSpec.mdl e ⊆ (BitsSpec.mdl a \ BitsSpec.mdl b) \ BitsSpec.mdl c ∧ Solution.partial_solution k col1 ∧ Solution.sorted sol1 s s1 ∧ (∀(i : ℤ), i ∈ BitsSpec.mdl o2 ∧ ¬i ∈ BitsSpec.mdl e → i ≤ min) ∧ (∀(i : ℤ), s ≤ i ∧ i < s1 → Solution.partial_solution Solution.n (sol1 i) ∧ Solution.eq_prefix col1 (sol1 i) k ∧ (0 : ℤ) ≤ sol1 i k ∧ sol1 i k ≤ min) ∧ (∀(u : ℤ -> ℤ), Solution.partial_solution Solution.n u ∧ Solution.eq_prefix col1 u k ∧ (0 : ℤ) ≤ u k ∧ u k ≤ min → u k ∈ BitsSpec.mdl o2 ∧ ¬u k ∈ BitsSpec.mdl e ∧ (∃(i : ℤ), (s ≤ i ∧ i < s1) ∧ Solution.eq_prefix u (sol1 i) Solution.n)) ∧ Solution.eq_prefix col col1 k ∧ Solution.eq_prefix sol sol1 s → (if ¬BitsSpec.mdl e = ∅ then ¬BitsSpec.mdl e = ∅ ∧ (∀(d : BitsSpec.t), BitsSpec.mdl d = insert (Finset.min'' (BitsSpec.mdl e)) (∅ : Finset ℤ) → BitsSpec.mdl d = insert (Finset.min'' (BitsSpec.mdl d)) (∅ : Finset ℤ) ∧ (∀(o3 : BitsSpec.t), BitsSpec.mdl o3 = insert (Finset.min'' (BitsSpec.mdl d)) (BitsSpec.mdl b) → (∀(b' : BitsSpec.t), BitsSpec.mdl b' = Finset.erase (S.succ (BitsSpec.mdl o3)) (32 : ℤ) → BitsSpec.mdl d = insert (Finset.min'' (BitsSpec.mdl d)) (∅ : Finset ℤ) ∧ (∀(o4 : BitsSpec.t), BitsSpec.mdl o4 = insert (Finset.min'' (BitsSpec.mdl d)) (BitsSpec.mdl c) → (∀(c' : BitsSpec.t), BitsSpec.mdl c' = S.pred (BitsSpec.mdl o4) → (let o5 : ℤ := k + (1 : ℤ); BitsSpec.mdl d = insert (Finset.min'' (BitsSpec.mdl d)) (∅ : Finset ℤ) ∧ (∀(o6 : BitsSpec.t), BitsSpec.mdl o6 = insert (Finset.min'' (BitsSpec.mdl d)) (BitsSpec.mdl c) → (∀(o7 : BitsSpec.t), BitsSpec.mdl o7 = S.pred (BitsSpec.mdl o6) → BitsSpec.mdl d = insert (Finset.min'' (BitsSpec.mdl d)) (∅ : Finset ℤ) ∧ (∀(o8 : BitsSpec.t), BitsSpec.mdl o8 = insert (Finset.min'' (BitsSpec.mdl d)) (BitsSpec.mdl b) → (∀(o9 : BitsSpec.t), BitsSpec.mdl o9 = Finset.erase (S.succ (BitsSpec.mdl o8)) (32 : ℤ) → (BitsSpec.mdl d = insert (Finset.min'' (BitsSpec.mdl d)) (∅ : Finset ℤ) ∧ Finset.min'' (BitsSpec.mdl d) ∈ BitsSpec.mdl a) ∧ (∀(o10 : BitsSpec.t), BitsSpec.mdl o10 = Finset.erase (BitsSpec.mdl a) (Finset.min'' (BitsSpec.mdl d)) → (((0 : ℤ) ≤ Int.ofNat (Finset.card (BitsSpec.mdl a)) ∧ Finset.card (BitsSpec.mdl o10) < Finset.card (BitsSpec.mdl a)) ∧ Solution.n ≤ (32 : ℤ) ∧ (0 : ℤ) ≤ o5 ∧ o5 + Int.ofNat (Finset.card (BitsSpec.mdl o10)) = Solution.n ∧ (0 : ℤ) ≤ s1 ∧ (∀(i : ℤ), (i ∈ BitsSpec.mdl o10) = (((0 : ℤ) ≤ i ∧ i < Solution.n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < o5 → ¬Function.update col1 k (Finset.min'' (BitsSpec.mdl e)) j = i))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (32 : ℤ) → (¬i ∈ BitsSpec.mdl o9) = (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < o5 → ¬i - Function.update col1 k (Finset.min'' (BitsSpec.mdl e)) j = o5 - j)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (32 : ℤ) → (¬i ∈ BitsSpec.mdl o7) = (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < o5 → ¬i - Function.update col1 k (Finset.min'' (BitsSpec.mdl e)) j = j - o5)) ∧ Solution.partial_solution o5 (Function.update col1 k (Finset.min'' (BitsSpec.mdl e)))) ∧ (∀(s2 : ℤ) (sol2 : ℤ -> ℤ -> ℤ) (col2 : ℤ -> ℤ), (0 : ℤ) ≤ s2 - s1 ∧ Solution.sorted sol2 s1 s2 ∧ (∀(i : ℤ), s1 ≤ i ∧ i < s2 → Solution.partial_solution Solution.n (sol2 i) ∧ Solution.eq_prefix col2 (sol2 i) o5) ∧ (∀(u : ℤ -> ℤ), Solution.partial_solution Solution.n u ∧ Solution.eq_prefix col2 u o5 → (∃(i : ℤ), (s1 ≤ i ∧ i < s2) ∧ Solution.eq_prefix u (sol2 i) Solution.n)) ∧ Solution.eq_prefix (Function.update col1 k (Finset.min'' (BitsSpec.mdl e))) col2 o5 ∧ Solution.eq_prefix sol1 sol2 s1 → (BitsSpec.mdl d = insert (Finset.min'' (BitsSpec.mdl d)) (∅ : Finset ℤ) ∧ Finset.min'' (BitsSpec.mdl d) ∈ BitsSpec.mdl e) ∧ (∀(o11 : BitsSpec.t), BitsSpec.mdl o11 = Finset.erase (BitsSpec.mdl e) (Finset.min'' (BitsSpec.mdl d)) → ((0 : ℤ) ≤ Int.ofNat (Finset.card (BitsSpec.mdl e)) ∧ Finset.card (BitsSpec.mdl o11) < Finset.card (BitsSpec.mdl e)) ∧ (¬BitsSpec.mdl o11 = ∅ → Finset.min'' (BitsSpec.mdl e) < Finset.min'' (BitsSpec.mdl o11)) ∧ (s1 - s + (s2 - s1) = s2 - s ∧ (0 : ℤ) ≤ s2 - s) ∧ BitsSpec.mdl o11 ⊆ (BitsSpec.mdl a \ BitsSpec.mdl b) \ BitsSpec.mdl c ∧ Solution.partial_solution k col2 ∧ Solution.sorted sol2 s s2 ∧ (∀(i : ℤ), i ∈ BitsSpec.mdl o2 ∧ ¬i ∈ BitsSpec.mdl o11 → i ≤ Finset.min'' (BitsSpec.mdl e)) ∧ (∀(i : ℤ), s ≤ i ∧ i < s2 → Solution.partial_solution Solution.n (sol2 i) ∧ Solution.eq_prefix col2 (sol2 i) k ∧ (0 : ℤ) ≤ sol2 i k ∧ sol2 i k ≤ Finset.min'' (BitsSpec.mdl e)) ∧ (∀(u : ℤ -> ℤ), Solution.partial_solution Solution.n u ∧ Solution.eq_prefix col2 u k ∧ (0 : ℤ) ≤ u k ∧ u k ≤ Finset.min'' (BitsSpec.mdl e) → u k ∈ BitsSpec.mdl o2 ∧ ¬u k ∈ BitsSpec.mdl o11 ∧ (∃(i : ℤ), (s ≤ i ∧ i < s2) ∧ Solution.eq_prefix u (sol2 i) Solution.n)) ∧ Solution.eq_prefix col col2 k ∧ Solution.eq_prefix sol sol2 s))))))))))))) else (0 : ℤ) ≤ s1 - s ∧ Solution.sorted sol1 s s1 ∧ (∀(i : ℤ), s ≤ i ∧ i < s1 → Solution.partial_solution Solution.n (sol1 i) ∧ Solution.eq_prefix col1 (sol1 i) k) ∧ (∀(u : ℤ -> ℤ), Solution.partial_solution Solution.n u ∧ Solution.eq_prefix col1 u k → (∃(i : ℤ), (s ≤ i ∧ i < s1) ∧ Solution.eq_prefix u (sol1 i) Solution.n)) ∧ Solution.eq_prefix col col1 k ∧ Solution.eq_prefix sol sol1 s))) else ((1 : ℤ) = s + (1 : ℤ) - s ∧ (0 : ℤ) ≤ s + (1 : ℤ) - s) ∧ Solution.sorted (Function.update sol s col) s (s + (1 : ℤ)) ∧ (∀(i : ℤ), s ≤ i ∧ i < s + (1 : ℤ) → Solution.partial_solution Solution.n (Function.update sol s col i) ∧ Solution.eq_prefix col (Function.update sol s col i) k) ∧ (∀(u : ℤ -> ℤ), Solution.partial_solution Solution.n u ∧ Solution.eq_prefix col u k → (∃(i : ℤ), (s ≤ i ∧ i < s + (1 : ℤ)) ∧ Solution.eq_prefix u (Function.update sol s col i) Solution.n)) ∧ Solution.eq_prefix col col k ∧ Solution.eq_prefix sol (Function.update sol s col) s
  := sorry
end queens_bv_NQueensBits_tqtvc
