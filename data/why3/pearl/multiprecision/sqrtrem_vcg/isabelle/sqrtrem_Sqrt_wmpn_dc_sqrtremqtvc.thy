theory sqrtrem_Sqrt_wmpn_dc_sqrtremqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "Why3STD.real_Truncate" "mach.c_C" "mach.int_Unsigned" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_1_Sub_1" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/sqrt_Sqrt1" "mach.fxp_Fxp" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/valuation_Valuation"
begin
theorem wmpn_dc_sqrtrem'vc:
  fixes np :: "64 word ptr"
  fixes n :: "32 word"
  fixes sp :: "64 word ptr"
  fixes scratch :: "64 word ptr"
  fixes o1 :: "bool"
  assumes fact0: "valid np (sint n + sint n)"
  assumes fact1: "valid sp (sint n)"
  assumes fact2: "(1 :: int) \<le> sint n"
  assumes fact3: "valid scratch ((1 :: int) + sint n ediv (2 :: int))"
  assumes fact4: "(2 :: int) ^\<^sub>i ((64 :: int) - (2 :: int)) \<le> uint (pelts np (offset np + sint n + sint n - (1 :: int)))"
  assumes fact5: "writable sp = True"
  assumes fact6: "writable scratch = True"
  assumes fact7: "writable np = True"
  assumes fact8: "(4 :: int) * sint n < (2147483647 :: int)"
  assumes fact9: "sint n = sint (1 :: 32 word) \<longrightarrow> o1 = True"
  assumes fact10: "o1 = True \<longrightarrow> n = (1 :: 32 word)"
  shows "if o1 = True then (valid scratch (1 :: int) \<and> valid sp (1 :: int) \<and> valid np (2 :: int) \<and> (2 :: int) ^\<^sub>i ((64 :: int) - (2 :: int)) \<le> uint (pelts np (offset np + (1 :: int))) \<and> writable sp = True \<and> writable scratch = True) \<and> (\<forall>(scratch1 :: 64 word ptr) (sp1 :: 64 word ptr). length (data scratch1) = length (data scratch) \<and> offset scratch1 = offset scratch \<and> c_C.min scratch1 = c_C.min scratch \<and> c_C.max scratch1 = c_C.max scratch \<and> writable scratch1 = writable scratch \<and> zone1 scratch1 = zone1 scratch \<longrightarrow> length (data sp1) = length (data sp) \<and> offset sp1 = offset sp \<and> c_C.min sp1 = c_C.min sp \<and> c_C.max sp1 = c_C.max sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> (\<forall>(r :: 64 word). value np (2 :: int) = uint (pelts sp1 (offset sp1)) * uint (pelts sp1 (offset sp1)) + uint r * ((18446744073709551615 :: int) + (1 :: int)) + uint (pelts scratch1 (offset scratch1)) \<and> uint (pelts scratch1 (offset scratch1)) + uint r * ((18446744073709551615 :: int) + (1 :: int)) \<le> (2 :: int) * uint (pelts sp1 (offset sp1)) \<and> (0 :: int) \<le> uint r \<and> uint r \<le> (1 :: int) \<longrightarrow> (c_C.min scratch1 \<le> offset scratch1 \<and> offset scratch1 < c_C.max scratch1) \<and> ((c_C.min np \<le> offset np \<and> offset np < c_C.max np) \<and> writable np = True) \<and> (\<forall>(np1 :: 64 word ptr). length (data np1) = length (data np) \<and> offset np1 = offset np \<and> c_C.min np1 = c_C.min np \<and> c_C.max np1 = c_C.max np \<and> writable np1 = writable np \<and> zone1 np1 = zone1 np \<longrightarrow> pelts np1 = (pelts np)(offset np1 := pelts scratch1 (offset scratch1)) \<longrightarrow> value sp1 (sint n) * value sp1 (sint n) + value np1 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint r = value np (sint n + sint n) \<and> value np1 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint r \<le> (2 :: int) * value sp1 (sint n) \<and> (2 :: int) ^\<^sub>i ((64 :: int) - (1 :: int)) \<le> uint (pelts sp1 (offset sp1 + sint n - (1 :: int))) \<and> ((0 :: int) \<le> uint r \<and> uint r \<le> (1 :: int)) \<and> c_C.max np1 = c_C.max np \<and> c_C.min np1 = c_C.min np \<and> plength np1 = plength np \<and> c_C.max scratch1 = c_C.max scratch \<and> c_C.min scratch1 = c_C.min scratch \<and> plength scratch1 = plength scratch \<and> c_C.max sp1 = c_C.max sp \<and> c_C.min sp1 = c_C.min sp \<and> plength sp1 = plength sp))) else (\<not>(2 :: int) = (0 :: int) \<and> int'32_in_bounds (sint n cdiv (2 :: int))) \<and> (\<forall>(l :: 32 word). sint l = sint n cdiv (2 :: int) \<longrightarrow> int'32_in_bounds (sint n - sint l) \<and> (\<forall>(h :: 32 word). sint h = sint n - sint l \<longrightarrow> (let vn :: int = value np (sint n + sint n) in int'32_in_bounds (sint l + sint l) \<and> (\<forall>(o2 :: 32 word). sint o2 = sint l + sint l \<longrightarrow> ((0 :: int) \<le> sint o2 \<and> (c_C.min np \<le> offset np + sint o2 \<and> offset np + sint o2 \<le> c_C.max np) \<and> writable np = True) \<and> (\<forall>(np1 :: 64 word ptr). offset np1 = offset np \<and> c_C.min np1 = c_C.min np \<and> writable np1 = writable np \<and> zone1 np1 = zone1 np \<longrightarrow> (\<forall>(np' :: 64 word ptr). writable np' = True \<and> offset np' = offset np1 + sint o2 \<and> c_C.max np1 = offset np1 + sint o2 \<and> c_C.min np' = offset np1 + sint o2 \<and> c_C.max np' = c_C.max np \<and> zone1 np' = zone1 np1 \<and> pelts np1 = pelts np \<and> plength np1 = plength np \<and> pelts np' = pelts np \<and> plength np' = plength np \<longrightarrow> (let n0 :: int = value np1 (sint l); n1 :: int = value_sub (pelts np1) (offset np1 + sint l) (offset np1 + sint l + sint l) in ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint n + sint n) \<le> (4 :: int) * vn \<and> (((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint n + sint n) \<le> (4 :: int) * vn \<longrightarrow> ((0 :: int) \<le> sint l \<and> (c_C.min sp \<le> offset sp + sint l \<and> offset sp + sint l \<le> c_C.max sp) \<and> writable sp = True) \<and> (\<forall>(sp1 :: 64 word ptr). offset sp1 = offset sp \<and> c_C.min sp1 = c_C.min sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> (\<forall>(spl :: 64 word ptr). writable spl = True \<and> offset spl = offset sp1 + sint l \<and> c_C.max sp1 = offset sp1 + sint l \<and> c_C.min spl = offset sp1 + sint l \<and> c_C.max spl = c_C.max sp \<and> zone1 spl = zone1 sp1 \<and> pelts sp1 = pelts sp \<and> plength sp1 = plength sp \<and> pelts spl = pelts sp \<and> plength spl = plength sp \<longrightarrow> (sint h < sint n \<and> valid np' (sint h + sint h) \<and> valid spl (sint h) \<and> (1 :: int) \<le> sint h \<and> valid scratch ((1 :: int) + sint h ediv (2 :: int)) \<and> (2 :: int) ^\<^sub>i ((64 :: int) - (2 :: int)) \<le> uint (pelts np' (offset np' + sint h + sint h - (1 :: int))) \<and> (writable spl = True \<and> writable scratch = True \<and> writable np' = True) \<and> (4 :: int) * sint h < (2147483647 :: int)) \<and> (\<forall>(spl1 :: 64 word ptr) (np'1 :: 64 word ptr) (scratch1 :: 64 word ptr). offset spl1 = offset spl \<and> writable spl1 = writable spl \<and> zone1 spl1 = zone1 spl \<longrightarrow> offset np'1 = offset np' \<and> c_C.min np'1 = c_C.min np' \<and> writable np'1 = writable np' \<and> zone1 np'1 = zone1 np' \<longrightarrow> offset scratch1 = offset scratch \<and> writable scratch1 = writable scratch \<and> zone1 scratch1 = zone1 scratch \<longrightarrow> (\<forall>(o3 :: 64 word). value spl1 (sint h) * value spl1 (sint h) + value np'1 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * uint o3 = value np' (sint h + sint h) \<and> value np'1 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * uint o3 \<le> (2 :: int) * value spl1 (sint h) \<and> (2 :: int) ^\<^sub>i ((64 :: int) - (1 :: int)) \<le> uint (pelts spl1 (offset spl1 + sint h - (1 :: int))) \<and> ((0 :: int) \<le> uint o3 \<and> uint o3 \<le> (1 :: int)) \<and> c_C.max np'1 = c_C.max np' \<and> c_C.min np'1 = c_C.min np' \<and> plength np'1 = plength np' \<and> c_C.max scratch1 = c_C.max scratch \<and> c_C.min scratch1 = c_C.min scratch \<and> plength scratch1 = plength scratch \<and> c_C.max spl1 = c_C.max spl \<and> c_C.min spl1 = c_C.min spl \<and> plength spl1 = plength spl \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint l \<le> (2 :: int) * value spl1 (sint h) \<and> (((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint l \<le> (2 :: int) * value spl1 (sint h) \<longrightarrow> (let r' :: int = value np'1 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * uint o3 in (\<forall>(o4 :: bool). (uint o3 = uint (0 :: 64 word) \<longrightarrow> o4 = True) \<and> (o4 = True \<longrightarrow> o3 = (0 :: 64 word)) \<longrightarrow> (if \<not>o4 = True then ((0 :: int) \<le> sint h \<and> valid np'1 (sint h) \<and> valid spl1 (sint h) \<and> writable np'1 = True) \<and> (\<forall>(np'2 :: 64 word ptr). length (data np'2) = length (data np'1) \<and> offset np'2 = offset np'1 \<and> c_C.min np'2 = c_C.min np'1 \<and> c_C.max np'2 = c_C.max np'1 \<and> writable np'2 = writable np'1 \<and> zone1 np'2 = zone1 np'1 \<longrightarrow> (\<forall>(b :: 64 word). value np'2 (sint h) - ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * uint b = value np'1 (sint h) - value spl1 (sint h) \<and> ((0 :: int) \<le> uint b \<and> uint b \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset np'2 \<or> offset np'2 + sint h \<le> j \<longrightarrow> pelts np'2 j = pelts np'1 j) \<longrightarrow> uint o3 = (1 :: int) \<and> value np'2 (sint h) = r' - value spl1 (sint h) \<or> uint o3 = (0 :: int) \<and> value np'2 (sint h) = r')) else uint o3 = (1 :: int) \<and> value np'1 (sint h) = r' - value spl1 (sint h) \<or> uint o3 = (0 :: int) \<and> value np'1 (sint h) = r')) \<and> (\<forall>(np'2 :: 64 word ptr). length (data np'2) = length (data np'1) \<and> offset np'2 = offset np'1 \<and> c_C.min np'2 = c_C.min np'1 \<and> c_C.max np'2 = c_C.max np'1 \<and> writable np'2 = writable np'1 \<and> zone1 np'2 = zone1 np'1 \<longrightarrow> uint o3 = (1 :: int) \<and> value np'2 (sint h) = r' - value spl1 (sint h) \<or> uint o3 = (0 :: int) \<and> value np'2 (sint h) = r' \<longrightarrow> (zone1 np1 = zone1 np'2 \<and> c_C.max np1 = c_C.min np'2 \<and> writable np1 = True \<and> writable np'2 = True) \<and> (\<forall>(np2 :: 64 word ptr). length (data np2) = length (data np1) \<and> offset np2 = offset np1 \<and> c_C.min np2 = c_C.min np1 \<and> writable np2 = writable np1 \<and> zone1 np2 = zone1 np1 \<longrightarrow> c_C.max np2 = c_C.max np'2 \<and> plength np2 = plength np1 \<and> (\<forall>(i :: int). c_C.min np1 \<le> i \<and> i < c_C.max np1 \<longrightarrow> pelts np2 i = pelts np1 i) \<and> (\<forall>(i :: int). c_C.min np'2 \<le> i \<and> i < c_C.max np'2 \<longrightarrow> pelts np2 i = pelts np'2 i) \<longrightarrow> ((0 :: int) \<le> sint l \<and> (c_C.min np2 \<le> offset np2 + sint l \<and> offset np2 + sint l \<le> c_C.max np2) \<and> writable np2 = True) \<and> (\<forall>(np3 :: 64 word ptr). offset np3 = offset np2 \<and> c_C.min np3 = c_C.min np2 \<and> writable np3 = writable np2 \<and> zone1 np3 = zone1 np2 \<longrightarrow> (\<forall>(npl :: 64 word ptr). writable npl = True \<and> offset npl = offset np3 + sint l \<and> c_C.max np3 = offset np3 + sint l \<and> c_C.min npl = offset np3 + sint l \<and> c_C.max npl = c_C.max np2 \<and> zone1 npl = zone1 np3 \<and> pelts np3 = pelts np2 \<and> plength np3 = plength np2 \<and> pelts npl = pelts np2 \<and> plength npl = plength np2 \<longrightarrow> (((1 :: int) \<le> sint h \<and> sint h \<le> sint n \<and> sint n \<le> (2147483647 :: int) - (1 :: int)) \<and> valid npl (sint n) \<and> valid spl1 (sint h) \<and> valid scratch1 (sint n - sint h + (1 :: int)) \<and> (writable npl = True \<and> writable scratch1 = True) \<and> (0 :: int) < uint (pelts spl1 (offset spl1 + sint h - (1 :: int)))) \<and> (\<forall>(npl1 :: 64 word ptr) (scratch2 :: 64 word ptr). length (data npl1) = length (data npl) \<and> offset npl1 = offset npl \<and> c_C.min npl1 = c_C.min npl \<and> c_C.max npl1 = c_C.max npl \<and> writable npl1 = writable npl \<and> zone1 npl1 = zone1 npl \<longrightarrow> length (data scratch2) = length (data scratch1) \<and> offset scratch2 = offset scratch1 \<and> c_C.min scratch2 = c_C.min scratch1 \<and> c_C.max scratch2 = c_C.max scratch1 \<and> writable scratch2 = writable scratch1 \<and> zone1 scratch2 = zone1 scratch1 \<longrightarrow> value npl (sint n) = value scratch2 (sint n - sint h + (1 :: int)) * value spl1 (sint h) + value npl1 (sint h) \<and> value npl1 (sint h) < value spl1 (sint h) \<longrightarrow> (c_C.min scratch2 \<le> offset scratch2 + sint l \<and> offset scratch2 + sint l < c_C.max scratch2) \<and> (let sl :: 64 word = pelts scratch2 (offset scratch2 + sint l) in uint'64_in_bounds (uint o3 + uint sl) \<and> (\<forall>(o4 :: 64 word). uint o4 = uint o3 + uint sl \<longrightarrow> (c_C.min scratch2 \<le> offset scratch2 \<and> offset scratch2 < c_C.max scratch2) \<and> (let sh :: 64 word = pelts scratch2 (offset scratch2) in (\<not>(2 :: int) = (0 :: int) \<and> uint'64_in_bounds (uint sh cmod (2 :: int))) \<and> (\<forall>(o5 :: 64 word). uint o5 = uint sh cmod (2 :: int) \<longrightarrow> uint o5 \<le> (9223372036854775807 :: int) \<and> (\<forall>(o6 :: 64 word). sint o6 = uint o5 \<longrightarrow> (valid scratch2 (sint l) \<and> valid sp1 (sint l) \<and> ((0 :: int) < (1 :: int) \<and> (1 :: int) < (64 :: int)) \<and> (0 :: int) < sint l \<and> writable sp1 = True) \<and> (\<forall>(scratch3 :: 64 word ptr) (sp2 :: 64 word ptr). offset scratch3 = offset scratch2 \<and> writable scratch3 = writable scratch2 \<and> zone1 scratch3 = zone1 scratch2 \<longrightarrow> offset sp2 = offset sp1 \<and> writable sp2 = writable sp1 \<and> zone1 sp2 = zone1 sp1 \<longrightarrow> (\<forall>(r :: 64 word). uint r + ((18446744073709551615 :: int) + (1 :: int)) * value sp2 (sint l) = value scratch3 (sint l) * (2 :: int) ^\<^sub>i ((64 :: int) - (1 :: int)) \<and> (\<forall>(j :: int). j < offset sp2 \<or> offset sp2 + sint l \<le> j \<longrightarrow> pelts sp2 j = pelts sp1 j) \<and> pelts scratch3 = pelts scratch2 \<and> (c_C.min scratch3 = c_C.min scratch2 \<and> c_C.max scratch3 = c_C.max scratch2 \<and> plength scratch3 = plength scratch2) \<and> c_C.min sp2 = c_C.min sp1 \<and> c_C.max sp2 = c_C.max sp1 \<and> plength sp2 = plength sp1 \<longrightarrow> int'32_in_bounds (sint l - (1 :: int)) \<and> (\<forall>(o7 :: 32 word). sint o7 = sint l - (1 :: int) \<longrightarrow> (c_C.min sp2 \<le> offset sp2 + sint o7 \<and> offset sp2 + sint o7 < c_C.max sp2) \<and> (let st :: 64 word = pelts sp2 (offset sp2 + sint o7) in uint'64_in_bounds (64 :: int) \<and> (\<forall>(o8 :: 64 word). uint o8 = (64 :: int) \<longrightarrow> uint'64_in_bounds (uint o8 - (1 :: int)) \<and> (\<forall>(o9 :: 64 word). uint o9 = uint o8 - (1 :: int) \<longrightarrow> ((0 :: int) \<le> uint o9 \<and> uint o9 < (64 :: int)) \<and> (\<forall>(ql :: 64 word). uint ql = uint o4 * (2 :: int) ^\<^sub>i uint o9 emod ((18446744073709551615 :: int) + (1 :: int)) \<and> uint ql \<le> (18446744073709551615 :: int) + (1 :: int) - (2 :: int) ^\<^sub>i uint o9 \<longrightarrow> ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) < (64 :: int)) \<and> (\<forall>(qh :: 64 word). uint qh = uint o4 ediv (2 :: int) ^\<^sub>i (1 :: int) \<longrightarrow> uint'64_in_bounds (uint st + uint ql) \<and> (\<forall>(o10 :: 64 word). uint o10 = uint st + uint ql \<longrightarrow> int'32_in_bounds (sint l - (1 :: int)) \<and> (\<forall>(o11 :: 32 word). sint o11 = sint l - (1 :: int) \<longrightarrow> ((c_C.min sp2 \<le> offset sp2 + sint o11 \<and> offset sp2 + sint o11 < c_C.max sp2) \<and> writable sp2 = True) \<and> (\<forall>(sp3 :: 64 word ptr). length (data sp3) = length (data sp2) \<and> offset sp3 = offset sp2 \<and> c_C.min sp3 = c_C.min sp2 \<and> c_C.max sp3 = c_C.max sp2 \<and> writable sp3 = writable sp2 \<and> zone1 sp3 = zone1 sp2 \<longrightarrow> pelts sp3 = (pelts sp2)(offset sp3 + sint o11 := o10) \<and> pelts sp3 (offset sp3 + sint o11) = o10 \<longrightarrow> ((sint o6 = (0 :: int) \<longrightarrow> o6 = (0 :: 64 word)) \<longrightarrow> (if \<not>o6 = (0 :: 64 word) then (valid npl1 (sint h) \<and> valid spl1 (sint h) \<and> writable npl1 = True) \<and> (\<forall>(npl2 :: 64 word ptr). length (data npl2) = length (data npl1) \<and> offset npl2 = offset npl1 \<and> c_C.min npl2 = c_C.min npl1 \<and> c_C.max npl2 = c_C.max npl1 \<and> writable npl2 = writable npl1 \<and> zone1 npl2 = zone1 npl1 \<longrightarrow> (\<forall>(c' :: 64 word). ((0 :: int) \<le> uint c' \<and> uint c' \<le> (1 :: int)) \<and> value npl2 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * uint c' = value npl1 (sint h) + value spl1 (sint h) \<and> (\<forall>(j :: int). j < offset npl2 \<or> offset npl2 + sint h \<le> j \<longrightarrow> pelts npl2 j = pelts npl1 j) \<longrightarrow> uint c' \<le> (9223372036854775807 :: int) \<and> (\<forall>(o12 :: 64 word). sint o12 = uint c' \<longrightarrow> n1 + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint l * r' = (2 :: int) * value spl1 (sint h) * (value sp3 (sint l) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint l * uint qh) + value npl2 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * sint o12 \<and> ((0 :: int) \<le> sint o12 \<and> sint o12 \<le> (1 :: int)) \<and> (0 :: int) \<le> value npl2 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * sint o12 \<and> value npl2 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * sint o12 < (2 :: int) * value spl1 (sint h)))) else n1 + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint l * r' = (2 :: int) * value spl1 (sint h) * (value sp3 (sint l) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint l * uint qh) + value npl1 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * sint o6 \<and> ((0 :: int) \<le> sint o6 \<and> sint o6 \<le> (1 :: int)) \<and> (0 :: int) \<le> value npl1 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * sint o6 \<and> value npl1 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * sint o6 < (2 :: int) * value spl1 (sint h))) \<and> (\<forall>(c :: 64 word) (npl2 :: 64 word ptr). length (data npl2) = length (data npl1) \<and> offset npl2 = offset npl1 \<and> c_C.min npl2 = c_C.min npl1 \<and> c_C.max npl2 = c_C.max npl1 \<and> writable npl2 = writable npl1 \<and> zone1 npl2 = zone1 npl1 \<longrightarrow> n1 + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint l * r' = (2 :: int) * value spl1 (sint h) * (value sp3 (sint l) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint l * uint qh) + value npl2 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * sint c \<and> ((0 :: int) \<le> sint c \<and> sint c \<le> (1 :: int)) \<and> (0 :: int) \<le> value npl2 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * sint c \<and> value npl2 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * sint c < (2 :: int) * value spl1 (sint h) \<longrightarrow> (let dq :: int = value sp3 (sint l) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint l * uint qh; r'' :: int = value npl2 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * sint c in (zone1 np3 = zone1 npl2 \<and> c_C.max np3 = c_C.min npl2 \<and> writable np3 = True \<and> writable npl2 = True) \<and> (\<forall>(np4 :: 64 word ptr). length (data np4) = length (data np3) \<and> offset np4 = offset np3 \<and> c_C.min np4 = c_C.min np3 \<and> writable np4 = writable np3 \<and> zone1 np4 = zone1 np3 \<longrightarrow> c_C.max np4 = c_C.max npl2 \<and> plength np4 = plength np3 \<and> (\<forall>(i :: int). c_C.min np3 \<le> i \<and> i < c_C.max np3 \<longrightarrow> pelts np4 i = pelts np3 i) \<and> (\<forall>(i :: int). c_C.min npl2 \<le> i \<and> i < c_C.max npl2 \<longrightarrow> pelts np4 i = pelts npl2 i) \<longrightarrow> ((0 :: int) \<le> sint n \<and> (c_C.min np4 \<le> offset np4 + sint n \<and> offset np4 + sint n \<le> c_C.max np4) \<and> writable np4 = True) \<and> (\<forall>(np5 :: 64 word ptr). offset np5 = offset np4 \<and> c_C.min np5 = c_C.min np4 \<and> writable np5 = writable np4 \<and> zone1 np5 = zone1 np4 \<longrightarrow> (\<forall>(npn :: 64 word ptr). writable npn = True \<and> offset npn = offset np5 + sint n \<and> c_C.max np5 = offset np5 + sint n \<and> c_C.min npn = offset np5 + sint n \<and> c_C.max npn = c_C.max np4 \<and> zone1 npn = zone1 np5 \<and> pelts np5 = pelts np4 \<and> plength np5 = plength np4 \<and> pelts npn = pelts np4 \<and> plength npn = plength np4 \<longrightarrow> (valid sp3 (sint l) \<and> valid sp3 (sint l) \<and> valid npn (sint l + sint l) \<and> writable npn = True \<and> ((0 :: int) < sint l \<and> sint l \<le> sint l) \<and> (8 :: int) * sint l < (2147483647 :: int) \<and> sint l \<le> sint (29 :: 32 word) * (2 :: int) ^\<^sub>i (64 :: int) \<and> (0 :: int) \<le> (64 :: int) \<and> (64 :: int) \<le> (64 :: int)) \<and> (\<forall>(npn1 :: 64 word ptr). offset npn1 = offset npn \<and> writable npn1 = writable npn \<and> zone1 npn1 = zone1 npn \<longrightarrow> c_C.min npn1 = c_C.min npn \<and> c_C.max npn1 = c_C.max npn \<and> plength npn1 = plength npn \<and> value npn1 (sint l + sint l) = value sp3 (sint l) * value sp3 (sint l) \<and> (\<forall>(j :: int). c_C.min npn1 \<le> j \<and> j < offset npn1 \<or> offset npn1 + sint l + sint l \<le> j \<and> j < c_C.max npn1 \<longrightarrow> pelts npn1 j = pelts npn j) \<longrightarrow> int'32_in_bounds ((2 :: int) * sint l) \<and> (\<forall>(ll :: 32 word). sint ll = (2 :: int) * sint l \<longrightarrow> ((0 :: int) \<le> sint ll \<and> valid np5 (sint ll) \<and> valid npn1 (sint ll) \<and> writable np5 = True) \<and> (\<forall>(np6 :: 64 word ptr). length (data np6) = length (data np5) \<and> offset np6 = offset np5 \<and> c_C.min np6 = c_C.min np5 \<and> c_C.max np6 = c_C.max np5 \<and> writable np6 = writable np5 \<and> zone1 np6 = zone1 np5 \<longrightarrow> (\<forall>(bo :: 64 word). value np6 (sint ll) - ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint ll * uint bo = value np5 (sint ll) - value npn1 (sint ll) \<and> ((0 :: int) \<le> uint bo \<and> uint bo \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset np6 \<or> offset np6 + sint ll \<le> j \<longrightarrow> pelts np6 j = pelts np5 j) \<longrightarrow> uint'64_in_bounds (uint qh + uint bo) \<and> (\<forall>(b :: 64 word). uint b = uint qh + uint bo \<longrightarrow> (\<forall>(o12 :: bool). (sint l = sint h \<longrightarrow> o12 = True) \<and> (o12 = True \<longrightarrow> l = h) \<longrightarrow> (if o12 = True then uint b \<le> (9223372036854775807 :: int) \<and> (\<forall>(o13 :: 64 word). sint o13 = uint b \<longrightarrow> int'64_in_bounds (sint c - sint o13) \<and> (\<forall>(o14 :: 64 word). sint o14 = sint c - sint o13 \<longrightarrow> value np6 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * sint o14 = n0 + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint l * r'' - dq * dq \<and> -(1 :: int) \<le> sint o14 \<and> sint o14 \<le> (1 :: int))) else (c_C.min np6 \<le> offset np6 + sint ll \<and> offset np6 + sint ll \<le> c_C.max np6) \<and> (\<forall>(nll :: 64 word ptr). offset nll = offset np6 + sint ll \<and> plength nll = plength np6 \<and> pelts nll = pelts np6 \<and> data nll = data np6 \<and> c_C.min nll = c_C.min np6 \<and> c_C.max nll = c_C.max np6 \<and> zone1 nll = zone1 np6 \<and> writable nll = writable np6 \<longrightarrow> (valid nll (1 :: int) \<and> (0 :: int) < (1 :: int) \<and> writable nll = True) \<and> (\<forall>(nll1 :: 64 word ptr) (np7 :: 64 word ptr). data nll1 = data np7 \<and> length (data np7) = length (data nll) \<and> offset nll1 = offset nll \<and> c_C.min nll1 = c_C.min nll \<and> c_C.max nll1 = c_C.max nll \<and> writable nll1 = writable nll \<and> zone1 nll1 = zone1 nll \<longrightarrow> length (data np7) = length (data np6) \<and> offset np7 = offset np6 \<and> c_C.min np7 = c_C.min np6 \<and> c_C.max np7 = c_C.max np6 \<and> writable np7 = writable np6 \<and> zone1 np7 = zone1 np6 \<longrightarrow> (\<forall>(bo1 :: 64 word). value nll1 (1 :: int) - ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (1 :: int) * uint bo1 = value nll (1 :: int) - uint b \<and> ((0 :: int) \<le> uint bo1 \<and> uint bo1 \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset nll1 \<or> offset nll1 + (1 :: int) \<le> j \<longrightarrow> pelts nll1 j = pelts nll j) \<longrightarrow> uint bo1 \<le> (9223372036854775807 :: int) \<and> (\<forall>(o13 :: 64 word). sint o13 = uint bo1 \<longrightarrow> int'64_in_bounds (sint c - sint o13) \<and> (\<forall>(o14 :: 64 word). sint o14 = sint c - sint o13 \<longrightarrow> value np7 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * sint o14 = n0 + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint l * r'' - dq * dq \<and> -(1 :: int) \<le> sint o14 \<and> sint o14 \<le> (1 :: int)))))))) \<and> (\<forall>(c1 :: 64 word) (np7 :: 64 word ptr). length (data np7) = length (data np6) \<and> offset np7 = offset np6 \<and> c_C.min np7 = c_C.min np6 \<and> c_C.max np7 = c_C.max np6 \<and> writable np7 = writable np6 \<and> zone1 np7 = zone1 np6 \<longrightarrow> value np7 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * sint c1 = n0 + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint l * r'' - dq * dq \<and> -(1 :: int) \<le> sint c1 \<and> sint c1 \<le> (1 :: int) \<longrightarrow> (if sint c1 < (0 :: int) then (valid spl1 (sint h) \<and> (0 :: int) < sint h \<and> writable spl1 = True) \<and> (\<forall>(spl2 :: 64 word ptr). length (data spl2) = length (data spl1) \<and> offset spl2 = offset spl1 \<and> c_C.min spl2 = c_C.min spl1 \<and> c_C.max spl2 = c_C.max spl1 \<and> writable spl2 = writable spl1 \<and> zone1 spl2 = zone1 spl1 \<longrightarrow> (\<forall>(o12 :: 64 word). value spl2 (sint h) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint h * uint o12 = value spl1 (sint h) + uint qh \<and> ((0 :: int) \<le> uint o12 \<and> uint o12 \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset spl2 \<or> offset spl2 + sint h \<le> j \<longrightarrow> pelts spl2 j = pelts spl1 j) \<longrightarrow> (zone1 sp3 = zone1 spl2 \<and> c_C.max sp3 = c_C.min spl2 \<and> writable sp3 = True \<and> writable spl2 = True) \<and> (\<forall>(sp4 :: 64 word ptr). length (data sp4) = length (data sp3) \<and> offset sp4 = offset sp3 \<and> c_C.min sp4 = c_C.min sp3 \<and> writable sp4 = writable sp3 \<and> zone1 sp4 = zone1 sp3 \<longrightarrow> c_C.max sp4 = c_C.max spl2 \<and> plength sp4 = plength sp3 \<and> (\<forall>(i :: int). c_C.min sp3 \<le> i \<and> i < c_C.max sp3 \<longrightarrow> pelts sp4 i = pelts sp3 i) \<and> (\<forall>(i :: int). c_C.min spl2 \<le> i \<and> i < c_C.max spl2 \<longrightarrow> pelts sp4 i = pelts spl2 i) \<longrightarrow> (valid sp4 (sint n) \<and> valid np7 (sint n) \<and> writable np7 = True) \<and> (\<forall>(np8 :: 64 word ptr). length (data np8) = length (data np7) \<and> offset np8 = offset np7 \<and> c_C.min np8 = c_C.min np7 \<and> c_C.max np8 = c_C.max np7 \<and> writable np8 = writable np7 \<and> zone1 np8 = zone1 np7 \<longrightarrow> (\<forall>(c' :: 64 word). value np8 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint c' = value np7 (sint n) + value sp4 (sint n) * (2 :: int) \<and> (\<forall>(j :: int). j < offset np8 \<or> offset np8 + sint n \<le> j \<longrightarrow> pelts np8 j = pelts np7 j) \<longrightarrow> uint'64_in_bounds ((2 :: int) * uint o12) \<and> (\<forall>(o13 :: 64 word). uint o13 = (2 :: int) * uint o12 \<longrightarrow> uint'64_in_bounds (uint o13 + uint c') \<and> (\<forall>(o14 :: 64 word). uint o14 = uint o13 + uint c' \<longrightarrow> uint o14 \<le> (9223372036854775807 :: int) \<and> (\<forall>(o15 :: 64 word). sint o15 = uint o14 \<longrightarrow> int'64_in_bounds (sint c1 + sint o15) \<and> (\<forall>(o16 :: 64 word). sint o16 = sint c1 + sint o15 \<longrightarrow> (valid np8 (sint n) \<and> (0 :: int) < sint n \<and> writable np8 = True) \<and> (\<forall>(np9 :: 64 word ptr). length (data np9) = length (data np8) \<and> offset np9 = offset np8 \<and> c_C.min np9 = c_C.min np8 \<and> c_C.max np9 = c_C.max np8 \<and> writable np9 = writable np8 \<and> zone1 np9 = zone1 np8 \<longrightarrow> (\<forall>(o17 :: 64 word). value np9 (sint n) - ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint o17 = value np8 (sint n) - (1 :: int) \<and> ((0 :: int) \<le> uint o17 \<and> uint o17 \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset np9 \<or> offset np9 + sint n \<le> j \<longrightarrow> pelts np9 j = pelts np8 j) \<longrightarrow> uint o17 \<le> (9223372036854775807 :: int) \<and> (\<forall>(o18 :: 64 word). sint o18 = uint o17 \<longrightarrow> int'64_in_bounds (sint o16 - sint o18) \<and> (\<forall>(o19 :: 64 word). sint o19 = sint o16 - sint o18 \<longrightarrow> (valid sp4 (sint n) \<and> (0 :: int) < sint n \<and> writable sp4 = True) \<and> (\<forall>(sp5 :: 64 word ptr). length (data sp5) = length (data sp4) \<and> offset sp5 = offset sp4 \<and> c_C.min sp5 = c_C.min sp4 \<and> c_C.max sp5 = c_C.max sp4 \<and> writable sp5 = writable sp4 \<and> zone1 sp5 = zone1 sp4 \<longrightarrow> (\<forall>(bo1 :: 64 word). value sp5 (sint n) - ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint bo1 = value sp4 (sint n) - (1 :: int) \<and> ((0 :: int) \<le> uint bo1 \<and> uint bo1 \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset sp5 \<or> offset sp5 + sint n \<le> j \<longrightarrow> pelts sp5 j = pelts sp4 j) \<longrightarrow> uint'64_in_bounds (uint o12 - uint bo1) \<and> (\<forall>(o20 :: 64 word). uint o20 = uint o12 - uint bo1 \<longrightarrow> (zone1 np9 = zone1 npn1 \<and> c_C.max np9 = c_C.min npn1 \<and> writable np9 = True \<and> writable npn1 = True) \<and> (\<forall>(np10 :: 64 word ptr). length (data np10) = length (data np9) \<and> offset np10 = offset np9 \<and> c_C.min np10 = c_C.min np9 \<and> writable np10 = writable np9 \<and> zone1 np10 = zone1 np9 \<longrightarrow> c_C.max np10 = c_C.max npn1 \<and> plength np10 = plength np9 \<and> (\<forall>(i :: int). c_C.min np9 \<le> i \<and> i < c_C.max np9 \<longrightarrow> pelts np10 i = pelts np9 i) \<and> (\<forall>(i :: int). c_C.min npn1 \<le> i \<and> i < c_C.max npn1 \<longrightarrow> pelts np10 i = pelts npn1 i) \<longrightarrow> (0 :: int) \<le> sint o19 \<and> (\<forall>(result :: 64 word). uint result = sint o19 \<longrightarrow> value sp5 (sint n) * value sp5 (sint n) + value np10 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint result = value np (sint n + sint n) \<and> value np10 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint result \<le> (2 :: int) * value sp5 (sint n) \<and> (2 :: int) ^\<^sub>i ((64 :: int) - (1 :: int)) \<le> uint (pelts sp5 (offset sp5 + sint n - (1 :: int))) \<and> ((0 :: int) \<le> uint result \<and> uint result \<le> (1 :: int)) \<and> c_C.max np10 = c_C.max np \<and> c_C.min np10 = c_C.min np \<and> plength np10 = plength np \<and> c_C.max scratch3 = c_C.max scratch \<and> c_C.min scratch3 = c_C.min scratch \<and> plength scratch3 = plength scratch \<and> c_C.max sp5 = c_C.max sp \<and> c_C.min sp5 = c_C.min sp \<and> plength sp5 = plength sp)))))))))))))))))) else (zone1 sp3 = zone1 spl1 \<and> c_C.max sp3 = c_C.min spl1 \<and> writable sp3 = True \<and> writable spl1 = True) \<and> (\<forall>(sp4 :: 64 word ptr). length (data sp4) = length (data sp3) \<and> offset sp4 = offset sp3 \<and> c_C.min sp4 = c_C.min sp3 \<and> writable sp4 = writable sp3 \<and> zone1 sp4 = zone1 sp3 \<longrightarrow> c_C.max sp4 = c_C.max spl1 \<and> plength sp4 = plength sp3 \<and> (\<forall>(i :: int). c_C.min sp3 \<le> i \<and> i < c_C.max sp3 \<longrightarrow> pelts sp4 i = pelts sp3 i) \<and> (\<forall>(i :: int). c_C.min spl1 \<le> i \<and> i < c_C.max spl1 \<longrightarrow> pelts sp4 i = pelts spl1 i) \<longrightarrow> (zone1 np7 = zone1 npn1 \<and> c_C.max np7 = c_C.min npn1 \<and> writable np7 = True \<and> writable npn1 = True) \<and> (\<forall>(np8 :: 64 word ptr). length (data np8) = length (data np7) \<and> offset np8 = offset np7 \<and> c_C.min np8 = c_C.min np7 \<and> writable np8 = writable np7 \<and> zone1 np8 = zone1 np7 \<longrightarrow> c_C.max np8 = c_C.max npn1 \<and> plength np8 = plength np7 \<and> (\<forall>(i :: int). c_C.min np7 \<le> i \<and> i < c_C.max np7 \<longrightarrow> pelts np8 i = pelts np7 i) \<and> (\<forall>(i :: int). c_C.min npn1 \<le> i \<and> i < c_C.max npn1 \<longrightarrow> pelts np8 i = pelts npn1 i) \<longrightarrow> (0 :: int) \<le> sint c1 \<and> (\<forall>(result :: 64 word). uint result = sint c1 \<longrightarrow> value sp4 (sint n) * value sp4 (sint n) + value np8 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint result = value np (sint n + sint n) \<and> value np8 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint result \<le> (2 :: int) * value sp4 (sint n) \<and> (2 :: int) ^\<^sub>i ((64 :: int) - (1 :: int)) \<le> uint (pelts sp4 (offset sp4 + sint n - (1 :: int))) \<and> ((0 :: int) \<le> uint result \<and> uint result \<le> (1 :: int)) \<and> c_C.max np8 = c_C.max np \<and> c_C.min np8 = c_C.min np \<and> plength np8 = plength np \<and> c_C.max scratch3 = c_C.max scratch \<and> c_C.min scratch3 = c_C.min scratch \<and> plength scratch3 = plength scratch \<and> c_C.max sp4 = c_C.max sp \<and> c_C.min sp4 = c_C.min sp \<and> plength sp4 = plength sp))))))))))))))))))))))))))))))))))))))))))))))))))"
  sorry
end
