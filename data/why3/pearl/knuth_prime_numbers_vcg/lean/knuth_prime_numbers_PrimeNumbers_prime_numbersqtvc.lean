import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace knuth_prime_numbers_PrimeNumbers_prime_numbersqtvc
noncomputable def no_prime_in (l : ℤ) (u : ℤ) := ∀(x : ℤ), l < x ∧ x < u → ¬Nat.Prime (Int.toNat x)
noncomputable def first_primes (p : ℤ -> ℤ) (u : ℤ) := p (0 : ℤ) = (2 : ℤ) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < u → p i < p j) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < u → Nat.Prime (Int.toNat (p i))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < u - (1 : ℤ) → no_prime_in (p i) (p (i + (1 : ℤ))))
axiom Bertrand_postulate (p : ℤ) (fact0 : Nat.Prime (Int.toNat p)) : ¬no_prime_in p ((2 : ℤ) * p)
theorem prime_numbers'vc (m : ℤ) (fact0 : (2 : ℤ) ≤ m) : (0 : ℤ) ≤ m ∧ (∀(p : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < m → p[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length p) = m → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length p)) ∧ (List.length (List.set p (0 : ℕ) (2 : ℤ)) = List.length p → getElem! (List.set p (0 : ℕ) (2 : ℤ)) ∘ Int.toNat = Function.update (getElem! p ∘ Int.toNat) (0 : ℤ) (2 : ℤ) → ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < Int.ofNat (List.length (List.set p (0 : ℕ) (2 : ℤ)))) ∧ (List.length (List.set (List.set p (0 : ℕ) (2 : ℤ)) (1 : ℕ) (3 : ℤ)) = List.length (List.set p (0 : ℕ) (2 : ℤ)) → getElem! (List.set (List.set p (0 : ℕ) (2 : ℤ)) (1 : ℕ) (3 : ℤ)) ∘ Int.toNat = Function.update (getElem! (List.set p (0 : ℕ) (2 : ℤ)) ∘ Int.toNat) (1 : ℤ) (3 : ℤ) → (let o1 : ℤ := m - (1 : ℤ); ((2 : ℤ) ≤ o1 + (1 : ℤ) → (first_primes (getElem! (List.set (List.set p (0 : ℕ) (2 : ℤ)) (1 : ℕ) (3 : ℤ)) ∘ Int.toNat) (2 : ℤ) ∧ ((List.set (List.set p (0 : ℕ) (2 : ℤ)) (1 : ℕ) (3 : ℤ))[Int.toNat ((2 : ℤ) - (1 : ℤ))]! < (5 : ℤ) ∧ (5 : ℤ) < (2 : ℤ) * (List.set (List.set p (0 : ℕ) (2 : ℤ)) (1 : ℕ) (3 : ℤ))[Int.toNat ((2 : ℤ) - (1 : ℤ))]!) ∧ Odd (5 : ℤ) ∧ no_prime_in ((List.set (List.set p (0 : ℕ) (2 : ℤ)) (1 : ℕ) (3 : ℤ))[Int.toNat ((2 : ℤ) - (1 : ℤ))]!) (5 : ℤ)) ∧ (∀(n : ℤ) (p1 : List ℤ), List.length p1 = List.length (List.set (List.set p (0 : ℕ) (2 : ℤ)) (1 : ℕ) (3 : ℤ)) → (∀(j : ℤ), ((2 : ℤ) ≤ j ∧ j ≤ o1) ∧ first_primes (getElem! p1 ∘ Int.toNat) j ∧ (p1[Int.toNat (j - (1 : ℤ))]! < n ∧ n < (2 : ℤ) * p1[Int.toNat (j - (1 : ℤ))]!) ∧ Odd n ∧ no_prime_in (p1[Int.toNat (j - (1 : ℤ))]!) n → (∀(n1 : ℤ) (p2 : List ℤ), List.length p2 = List.length p1 → (∀(k : ℤ), ((1 : ℤ) ≤ k ∧ k < j) ∧ first_primes (getElem! p2 ∘ Int.toNat) j ∧ (p2[Int.toNat (j - (1 : ℤ))]! < n1 ∧ n1 < (2 : ℤ) * p2[Int.toNat (j - (1 : ℤ))]!) ∧ Odd n1 ∧ no_prime_in (p2[Int.toNat (j - (1 : ℤ))]!) n1 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < k → ¬p2[Int.toNat i]! ∣  n1) → ((0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length p2)) ∧ (let o2 : ℤ := p2[Int.toNat k]!; ¬o2 = (0 : ℤ) ∧ (if Int.tmod n1 o2 = (0 : ℤ) then ((0 : ℤ) ≤ (2 : ℤ) * p2[Int.toNat (j - (1 : ℤ))]! - n1 ∧ (2 : ℤ) * p2[Int.toNat (j - (1 : ℤ))]! - (n1 + (2 : ℤ)) < (2 : ℤ) * p2[Int.toNat (j - (1 : ℤ))]! - n1 ∨ (2 : ℤ) * p2[Int.toNat (j - (1 : ℤ))]! - n1 = (2 : ℤ) * p2[Int.toNat (j - (1 : ℤ))]! - (n1 + (2 : ℤ)) ∧ (0 : ℤ) ≤ j - k ∧ j - (1 : ℤ) < j - k) ∧ ((1 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < j) ∧ first_primes (getElem! p2 ∘ Int.toNat) j ∧ (p2[Int.toNat (j - (1 : ℤ))]! < n1 + (2 : ℤ) ∧ n1 + (2 : ℤ) < (2 : ℤ) * p2[Int.toNat (j - (1 : ℤ))]!) ∧ Odd (n1 + (2 : ℤ)) ∧ no_prime_in (p2[Int.toNat (j - (1 : ℤ))]!) (n1 + (2 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (1 : ℤ) → ¬p2[Int.toNat i]! ∣  n1 + (2 : ℤ)) else ((0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length p2)) ∧ ((0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length p2)) ∧ (let o3 : ℤ := p2[Int.toNat k]!; ¬o3 = (0 : ℤ) ∧ (if p2[Int.toNat k]! < Int.tdiv n1 o3 then let o4 : ℤ := k + (1 : ℤ); ((0 : ℤ) ≤ (2 : ℤ) * p2[Int.toNat (j - (1 : ℤ))]! - n1 ∧ (2 : ℤ) * p2[Int.toNat (j - (1 : ℤ))]! - n1 < (2 : ℤ) * p2[Int.toNat (j - (1 : ℤ))]! - n1 ∨ (0 : ℤ) ≤ j - k ∧ j - o4 < j - k) ∧ ((1 : ℤ) ≤ o4 ∧ o4 < j) ∧ first_primes (getElem! p2 ∘ Int.toNat) j ∧ (p2[Int.toNat (j - (1 : ℤ))]! < n1 ∧ n1 < (2 : ℤ) * p2[Int.toNat (j - (1 : ℤ))]!) ∧ Odd n1 ∧ no_prime_in (p2[Int.toNat (j - (1 : ℤ))]!) n1 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o4 → ¬p2[Int.toNat i]! ∣  n1) else p2[Int.toNat (j - (1 : ℤ))]! < n1 ∧ Nat.Prime (Int.toNat n1) ∧ no_prime_in (p2[Int.toNat (j - (1 : ℤ))]!) n1)))))) ∧ (((1 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < j) ∧ first_primes (getElem! p1 ∘ Int.toNat) j ∧ (p1[Int.toNat (j - (1 : ℤ))]! < n ∧ n < (2 : ℤ) * p1[Int.toNat (j - (1 : ℤ))]!) ∧ Odd n ∧ no_prime_in (p1[Int.toNat (j - (1 : ℤ))]!) n ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (1 : ℤ) → ¬p1[Int.toNat i]! ∣  n)) ∧ (∀(n1 : ℤ), p1[Int.toNat (j - (1 : ℤ))]! < n1 ∧ Nat.Prime (Int.toNat n1) ∧ no_prime_in (p1[Int.toNat (j - (1 : ℤ))]!) n1 → ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length p1)) ∧ (List.length (List.set p1 (Int.toNat j) n1) = List.length p1 → getElem! (List.set p1 (Int.toNat j) n1) ∘ Int.toNat = Function.update (getElem! p1 ∘ Int.toNat) j n1 → first_primes (getElem! (List.set p1 (Int.toNat j) n1) ∘ Int.toNat) (j + (1 : ℤ)) ∧ ((List.set p1 (Int.toNat j) n1)[Int.toNat (j + (1 : ℤ) - (1 : ℤ))]! < n1 + (2 : ℤ) ∧ n1 + (2 : ℤ) < (2 : ℤ) * (List.set p1 (Int.toNat j) n1)[Int.toNat (j + (1 : ℤ) - (1 : ℤ))]!) ∧ Odd (n1 + (2 : ℤ)) ∧ no_prime_in ((List.set p1 (Int.toNat j) n1)[Int.toNat (j + (1 : ℤ) - (1 : ℤ))]!) (n1 + (2 : ℤ))))) ∧ (first_primes (getElem! p1 ∘ Int.toNat) (o1 + (1 : ℤ)) ∧ (p1[Int.toNat (o1 + (1 : ℤ) - (1 : ℤ))]! < n ∧ n < (2 : ℤ) * p1[Int.toNat (o1 + (1 : ℤ) - (1 : ℤ))]!) ∧ Odd n ∧ no_prime_in (p1[Int.toNat (o1 + (1 : ℤ) - (1 : ℤ))]!) n → Int.ofNat (List.length p1) = m ∧ first_primes (getElem! p1 ∘ Int.toNat) m))) ∧ (o1 + (1 : ℤ) < (2 : ℤ) → Int.ofNat (List.length (List.set (List.set p (0 : ℕ) (2 : ℤ)) (1 : ℕ) (3 : ℤ))) = m ∧ first_primes (getElem! (List.set (List.set p (0 : ℕ) (2 : ℤ)) (1 : ℕ) (3 : ℤ)) ∘ Int.toNat) m)))))
  := sorry
end knuth_prime_numbers_PrimeNumbers_prime_numbersqtvc
