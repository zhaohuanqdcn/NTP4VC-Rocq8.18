import Why3.Base
open Classical
open Lean4Why3
namespace array_of_list_Top_array_of_listqtvc
theorem array_of_list'vc {α : Type} [Inhabited α] (l : List α) (o1 : ℕ) (n : BitVec 63) (fact0 : ¬l = ([] : List α)) (fact1 : o1 = List.length l) (fact2 : BitVec.toInt n = Int.ofNat o1) : match l with | ([] : List α) => False | List.cons x ll => (0 : ℤ) ≤ BitVec.toInt n ∧ (∀(a : array63 α), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt n → (array63_elts a)[Int.toNat i]! = x) ∧ array63_length a = n → (∀(a1 : array63 α), array63_length a1 = array63_length a → (∀(i : BitVec 63) (ll1 : List α), ((1 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt n - BitVec.toInt i = Int.ofNat (List.length ll1)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toInt i → Option.some ((array63_elts a1)[Int.toNat j]!) = getElem_i? l j) ∧ (∀(j : ℤ), BitVec.toInt i ≤ j ∧ j < BitVec.toInt n → getElem_i? ll1 (j - BitVec.toInt i) = getElem_i? l j) → (match ll1 with | ([] : List α) => (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toInt n → Option.some ((array63_elts a1)[Int.toNat j]!) = getElem_i? l j) | List.cons x1 ll2 => ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i < BitVec.toInt (array63_length a1)) ∧ (∀(a2 : array63 α), array63_length a2 = array63_length a1 → array63_elts a2 = List.set (array63_elts a1) (Int.toNat (BitVec.toInt i)) x1 → int'63_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o2 : BitVec 63), BitVec.toInt o2 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt n - BitVec.toInt i ∧ BitVec.toInt n - BitVec.toInt o2 < BitVec.toInt n - BitVec.toInt i) ∧ ((1 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt n - BitVec.toInt o2 = Int.ofNat (List.length ll2)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toInt o2 → Option.some ((array63_elts a2)[Int.toNat j]!) = getElem_i? l j) ∧ (∀(j : ℤ), BitVec.toInt o2 ≤ j ∧ j < BitVec.toInt n → getElem_i? ll2 (j - BitVec.toInt o2) = getElem_i? l j)))))) ∧ (((1 : ℤ) ≤ (1 : ℤ) ∧ BitVec.toInt n - (1 : ℤ) = Int.ofNat (List.length ll)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (1 : ℤ) → Option.some ((array63_elts a)[Int.toNat j]!) = getElem_i? l j) ∧ (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j < BitVec.toInt n → getElem_i? ll (j - (1 : ℤ)) = getElem_i? l j)) ∧ (∀(a1 : array63 α), array63_length a1 = array63_length a → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toInt n → Option.some ((array63_elts a1)[Int.toNat j]!) = getElem_i? l j) → BitVec.toInt (array63_length a1) = Int.ofNat (List.length l) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length l) → Option.some ((array63_elts a1)[Int.toNat i]!) = getElem_i? l i)))
  := sorry
end array_of_list_Top_array_of_listqtvc
