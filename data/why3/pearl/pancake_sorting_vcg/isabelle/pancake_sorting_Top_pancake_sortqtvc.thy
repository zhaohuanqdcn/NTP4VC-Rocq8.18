theory pancake_sorting_Top_pancake_sortqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut"
begin
definition sorted :: "int list \<Rightarrow> int \<Rightarrow> _"
  where "sorted a hi \<longleftrightarrow> (\<forall>(j1 :: int) (j2 :: int). (0 :: int) \<le> j1 \<and> j1 \<le> j2 \<and> j2 < hi \<longrightarrow> a ! nat j2 \<le> a ! nat j1)" for a hi
theorem pancake_sort'vc:
  fixes a :: "int list"
  shows "let o1 :: int = int (length a) - (2 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> (sorted a (0 :: int) \<and> (\<forall>(j1 :: int) (j2 :: int). (0 :: int) \<le> j1 \<and> j1 < (0 :: int) \<and> (0 :: int) \<le> j2 \<and> j2 < int (length a) \<longrightarrow> a ! nat j2 \<le> a ! nat j1) \<and> a <~~> a) \<and> (\<forall>(a1 :: int list). length a1 = length a \<longrightarrow> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o1) \<and> sorted a1 i \<and> (\<forall>(j1 :: int) (j2 :: int). (0 :: int) \<le> j1 \<and> j1 < i \<and> i \<le> j2 \<and> j2 < int (length a1) \<longrightarrow> a1 ! nat j2 \<le> a1 ! nat j1) \<and> a <~~> a1 \<longrightarrow> (let o2 :: int = int (length a1) - (1 :: int); o3 :: int = i + (1 :: int) in (o3 \<le> o2 + (1 :: int) \<longrightarrow> ((i \<le> i \<and> i < int (length a1)) \<and> (\<forall>(j :: int). i \<le> j \<and> j < o3 \<longrightarrow> a1 ! nat j \<le> a1 ! nat i)) \<and> (\<forall>(m :: int). (\<forall>(k :: int). (o3 \<le> k \<and> k \<le> o2) \<and> (i \<le> m \<and> m < int (length a1)) \<and> (\<forall>(j :: int). i \<le> j \<and> j < k \<longrightarrow> a1 ! nat j \<le> a1 ! nat m) \<longrightarrow> ((0 :: int) \<le> m \<and> m < int (length a1)) \<and> ((0 :: int) \<le> k \<and> k < int (length a1)) \<and> (if a1 ! nat m < a1 ! nat k then (i \<le> k \<and> k < int (length a1)) \<and> (\<forall>(j :: int). i \<le> j \<and> j < k + (1 :: int) \<longrightarrow> a1 ! nat j \<le> a1 ! nat k) else (i \<le> m \<and> m < int (length a1)) \<and> (\<forall>(j :: int). i \<le> j \<and> j < k + (1 :: int) \<longrightarrow> a1 ! nat j \<le> a1 ! nat m))) \<and> ((i \<le> m \<and> m < int (length a1)) \<and> (\<forall>(j :: int). i \<le> j \<and> j < o2 + (1 :: int) \<longrightarrow> a1 ! nat j \<le> a1 ! nat m) \<longrightarrow> (if m = i then sorted a1 (i + (1 :: int)) \<and> (\<forall>(j1 :: int) (j2 :: int). (0 :: int) \<le> j1 \<and> j1 < i + (1 :: int) \<and> i + (1 :: int) \<le> j2 \<and> j2 < int (length a1) \<longrightarrow> a1 ! nat j2 \<le> a1 ! nat j1) \<and> a <~~> a1 else if m < int (length a1) - (1 :: int) then ((0 :: int) \<le> m \<and> m < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < m \<longrightarrow> a2 ! nat j = a1 ! nat j) \<and> (\<forall>(j :: int). m \<le> j \<and> j < int (length a2) \<longrightarrow> a2 ! nat j = a1 ! nat (int (length a2) - (1 :: int) - (j - m))) \<and> a1 <~~> a2 \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a2)) \<and> (\<forall>(a3 :: int list). length a3 = length a2 \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> a3 ! nat j = a2 ! nat j) \<and> (\<forall>(j :: int). i \<le> j \<and> j < int (length a3) \<longrightarrow> a3 ! nat j = a2 ! nat (int (length a3) - (1 :: int) - (j - i))) \<and> a2 <~~> a3 \<longrightarrow> sorted a3 (i + (1 :: int)) \<and> (\<forall>(j1 :: int) (j2 :: int). (0 :: int) \<le> j1 \<and> j1 < i + (1 :: int) \<and> i + (1 :: int) \<le> j2 \<and> j2 < int (length a3) \<longrightarrow> a3 ! nat j2 \<le> a3 ! nat j1) \<and> a <~~> a3)) else ((0 :: int) \<le> i \<and> i < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> a2 ! nat j = a1 ! nat j) \<and> (\<forall>(j :: int). i \<le> j \<and> j < int (length a2) \<longrightarrow> a2 ! nat j = a1 ! nat (int (length a2) - (1 :: int) - (j - i))) \<and> a1 <~~> a2 \<longrightarrow> sorted a2 (i + (1 :: int)) \<and> (\<forall>(j1 :: int) (j2 :: int). (0 :: int) \<le> j1 \<and> j1 < i + (1 :: int) \<and> i + (1 :: int) \<le> j2 \<and> j2 < int (length a2) \<longrightarrow> a2 ! nat j2 \<le> a2 ! nat j1) \<and> a <~~> a2))))) \<and> (o2 + (1 :: int) < o3 \<longrightarrow> sorted a1 (i + (1 :: int)) \<and> (\<forall>(j1 :: int) (j2 :: int). (0 :: int) \<le> j1 \<and> j1 < i + (1 :: int) \<and> i + (1 :: int) \<le> j2 \<and> j2 < int (length a1) \<longrightarrow> a1 ! nat j2 \<le> a1 ! nat j1) \<and> a <~~> a1))) \<and> (sorted a1 (o1 + (1 :: int)) \<and> (\<forall>(j1 :: int) (j2 :: int). (0 :: int) \<le> j1 \<and> j1 < o1 + (1 :: int) \<and> o1 + (1 :: int) \<le> j2 \<and> j2 < int (length a1) \<longrightarrow> a1 ! nat j2 \<le> a1 ! nat j1) \<and> a <~~> a1 \<longrightarrow> sorted a1 (int (length a1)) \<and> a <~~> a1))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> sorted a (int (length a)) \<and> a <~~> a)"
  sorry
end
