theory A_AccumulateAxiomatic_A_AccumulateAxiomatic
  imports "NTP4Verif.NTP4Verif" "Why3STD.Qed_Qed" "Why3STD.Memory_Memory" "Why3STD.Cint_Cint" "../../lib/isabelle/Compound_Compound" "../../lib/isabelle/Axiomatic_Axiomatic"
begin
consts l_accumulate_1' :: "(addr \<Rightarrow> int) \<Rightarrow> addr \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int"
axiomatization where Q_TL_Accumulate_1':   "is_sint32 (l_accumulate_1' mint_0 a n init_0)"
  for mint_0 :: "addr \<Rightarrow> int"
  and a :: "addr"
  and n :: "int"
  and init_0 :: "int"
axiomatization where Q_AccumulateEmpty:   "l_accumulate_1' mint_0 a n init_0 = init_0"
 if "n \<le> (0 :: int)"
 and "is_sint32 init_0"
  for n :: "int"
  and init_0 :: "int"
  and mint_0 :: "addr \<Rightarrow> int"
  and a :: "addr"
axiomatization where Q_AccumulateNext:   "(0 :: int) < n \<longrightarrow> is_sint32 init_0 \<longrightarrow> mint_0 (shift a (n - (1 :: int))) + l_accumulate_1' mint_0 a (n - (1 :: int)) init_0 = l_accumulate_1' mint_0 a n init_0"
  for n :: "int"
  and init_0 :: "int"
  and mint_0 :: "addr \<Rightarrow> int"
  and a :: "addr"
axiomatization where Q_AccumulateRead:   "l_accumulate_1' mint_1 a n init_0 = l_accumulate_1' mint_0 a n init_0"
 if "is_sint32 init_0"
 and "p_unchanged_1' mint_0 mint_1 a (0 :: int) n"
  for init_0 :: "int"
  and mint_0 :: "addr \<Rightarrow> int"
  and mint_1 :: "addr \<Rightarrow> int"
  and a :: "addr"
  and n :: "int"
end
