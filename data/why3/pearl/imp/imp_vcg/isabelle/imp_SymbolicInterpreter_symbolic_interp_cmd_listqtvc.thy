theory imp_SymbolicInterpreter_symbolic_interp_cmd_listqtvc
  imports "NTP4Verif.NTP4Verif" "../../lib/isabelle/imp_Syntax" "../../lib/isabelle/imp_ConcreteSemantics" "../../lib/isabelle/imp_Svar" "../../lib/isabelle/imp_Constraint" "../../lib/isabelle/imp_SymState" "../../lib/isabelle/imp_FreshSvar" "../../lib/isabelle/imp_SymStateSet"
begin
consts compose :: "(svar \<Rightarrow> int) \<Rightarrow> t \<Rightarrow> program_var \<Rightarrow> int option"
axiomatization where compose'def:   "compose rho sigma x = (case get sigma x of Some v \<Rightarrow> Some (rho v) | None \<Rightarrow> None)"
  for rho :: "svar \<Rightarrow> int"
  and sigma :: "t"
  and x :: "program_var"
definition state_extends :: "sym_state \<Rightarrow> sym_state \<Rightarrow> _"
  where "state_extends s s' \<longleftrightarrow> imp_Svar.to_fset (vars s) |\<subseteq>| imp_Svar.to_fset (vars s') \<and> (\<forall>(v :: svar). v |\<in>| imp_Svar.to_fset (vars s) \<longrightarrow> rho s v = rho s' v)" for s s'
consts svar_set_add :: "svar \<Rightarrow> imp_Svar.set \<Rightarrow> imp_Svar.set"
axiomatization where svar_set_add'def'0:   "imp_Svar.to_fset (svar_set_add v vs) = finsert v (imp_Svar.to_fset vs)"
  for v :: "svar"
  and vs :: "imp_Svar.set"
axiomatization where svar_set_add'def'1:   "if v |\<in>| imp_Svar.to_fset vs then fcard (imp_Svar.to_fset (svar_set_add v vs)) = fcard (imp_Svar.to_fset vs) else int (fcard (imp_Svar.to_fset (svar_set_add v vs))) = int (fcard (imp_Svar.to_fset vs)) + (1 :: int)"
  for v :: "svar"
  and vs :: "imp_Svar.set"
definition results_extend :: "sym_state \<Rightarrow> sym_state fset \<Rightarrow> sym_state fset \<Rightarrow> sym_state fset \<Rightarrow> _"
  where "results_extend s normals unbounds limits \<longleftrightarrow> (\<forall>(s' :: sym_state). s' |\<in>| normals \<or> s' |\<in>| unbounds \<or> s' |\<in>| limits \<longrightarrow> state_extends s s')" for s normals unbounds limits
theorem symbolic_interp_cmd_list'vc:
  fixes n :: "int"
  fixes ss :: "sym_state list"
  fixes c :: "cmd"
  assumes fact0: "(0 :: int) \<le> n"
  shows "case ss of Nil \<Rightarrow> True | Cons s ss' \<Rightarrow> (((0 :: int) \<le> int (length ss) \<and> (0 :: int) < int (length ss)) \<and> (0 :: int) \<le> n) \<and> (\<forall>(normals1 :: imp_SymStateSet.set) (unbounds1 :: imp_SymStateSet.set) (limits1 :: imp_SymStateSet.set). results_extend s (imp_SymStateSet.to_fset normals1) (imp_SymStateSet.to_fset unbounds1) (imp_SymStateSet.to_fset limits1) \<and> (is_solution (rho s) (constr s) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_cmd (mk_loop_cnf n) (compose (rho s) (sigma s)) c gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<and> is_solution (rho s') (constr s') \<and> gamma' = compose (rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<longrightarrow> is_solution (rho s') (constr s') \<longrightarrow> is_solution (rho s) (constr s) \<and> exec_cmd (mk_loop_cnf n) (compose (rho s) (sigma s)) c (compose (rho s') (sigma s')) bhv) \<longrightarrow> ((0 :: int) \<le> int (length ss) \<and> length ss' < length ss) \<and> (0 :: int) \<le> n)"
  and "\<forall>(normals :: imp_SymStateSet.set) (unbounds :: imp_SymStateSet.set) (limits :: imp_SymStateSet.set). (case ss of Nil \<Rightarrow> (imp_SymStateSet.to_fset limits = fempty \<and> int (fcard (imp_SymStateSet.to_fset limits)) = (0 :: int)) \<and> (imp_SymStateSet.to_fset unbounds = fempty \<and> int (fcard (imp_SymStateSet.to_fset unbounds)) = (0 :: int)) \<and> imp_SymStateSet.to_fset normals = fempty \<and> int (fcard (imp_SymStateSet.to_fset normals)) = (0 :: int) | Cons s ss' \<Rightarrow> (\<exists>(normals1 :: imp_SymStateSet.set) (unbounds1 :: imp_SymStateSet.set) (limits1 :: imp_SymStateSet.set). (results_extend s (imp_SymStateSet.to_fset normals1) (imp_SymStateSet.to_fset unbounds1) (imp_SymStateSet.to_fset limits1) \<and> (is_solution (rho s) (constr s) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_cmd (mk_loop_cnf n) (compose (rho s) (sigma s)) c gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<and> is_solution (rho s') (constr s') \<and> gamma' = compose (rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<longrightarrow> is_solution (rho s') (constr s') \<longrightarrow> is_solution (rho s) (constr s) \<and> exec_cmd (mk_loop_cnf n) (compose (rho s) (sigma s)) c (compose (rho s') (sigma s')) bhv)) \<and> (\<exists>(normals2 :: imp_SymStateSet.set) (unbounds2 :: imp_SymStateSet.set) (limits2 :: imp_SymStateSet.set). ((\<forall>(s' :: sym_state). s' |\<in>| imp_SymStateSet.to_fset normals2 \<or> s' |\<in>| imp_SymStateSet.to_fset unbounds2 \<or> s' |\<in>| imp_SymStateSet.to_fset limits2 \<longrightarrow> (\<exists>(s1 :: sym_state). s1 |\<in>| imp_SymStateSet.to_fset (of_list ss') \<and> state_extends s1 s')) \<and> (\<forall>(s1 :: sym_state). s1 |\<in>| imp_SymStateSet.to_fset (of_list ss') \<longrightarrow> is_solution (rho s1) (constr s1) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_cmd (mk_loop_cnf n) (compose (rho s1) (sigma s1)) c gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals2 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds2 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits2) \<and> is_solution (rho s') (constr s') \<and> gamma' = compose (rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals2 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds2 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits2) \<longrightarrow> is_solution (rho s') (constr s') \<longrightarrow> (\<exists>(s1 :: sym_state). s1 |\<in>| imp_SymStateSet.to_fset (of_list ss') \<and> is_solution (rho s1) (constr s1) \<and> exec_cmd (mk_loop_cnf n) (compose (rho s1) (sigma s1)) c (compose (rho s') (sigma s')) bhv))) \<and> imp_SymStateSet.to_fset limits = imp_SymStateSet.to_fset limits1 |\<union>| imp_SymStateSet.to_fset limits2 \<and> imp_SymStateSet.to_fset unbounds = imp_SymStateSet.to_fset unbounds1 |\<union>| imp_SymStateSet.to_fset unbounds2 \<and> imp_SymStateSet.to_fset normals = imp_SymStateSet.to_fset normals1 |\<union>| imp_SymStateSet.to_fset normals2))) \<longrightarrow> (\<forall>(s' :: sym_state). s' |\<in>| imp_SymStateSet.to_fset normals \<or> s' |\<in>| imp_SymStateSet.to_fset unbounds \<or> s' |\<in>| imp_SymStateSet.to_fset limits \<longrightarrow> (\<exists>(s :: sym_state). s |\<in>| imp_SymStateSet.to_fset (of_list ss) \<and> state_extends s s')) \<and> (\<forall>(s :: sym_state). s |\<in>| imp_SymStateSet.to_fset (of_list ss) \<longrightarrow> is_solution (rho s) (constr s) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_cmd (mk_loop_cnf n) (compose (rho s) (sigma s)) c gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits) \<and> is_solution (rho s') (constr s') \<and> gamma' = compose (rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits) \<longrightarrow> is_solution (rho s') (constr s') \<longrightarrow> (\<exists>(s :: sym_state). s |\<in>| imp_SymStateSet.to_fset (of_list ss) \<and> is_solution (rho s) (constr s) \<and> exec_cmd (mk_loop_cnf n) (compose (rho s) (sigma s)) c (compose (rho s') (sigma s')) bhv))"
  sorry
end
