import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import pearl.multiprecision.lib.lean.mpz.Z
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
open Classical
open Lean4Why3
namespace mpz_Zutil_wmpz_do_reallocqtvc
axiom mpz_mem : Type
axiom inhabited_axiom_mpz_mem : Inhabited mpz_mem
attribute [instance] inhabited_axiom_mpz_mem
axiom ptr : mpz_mem -> Z.mpz_ptr
axiom ok : mpz_mem -> Bool
theorem wmpz_do_realloc'vc (sz : BitVec 32) (mpz : Z.mpz_memo) (x : Z.mpz_ptr) (fact0 : (1 : ℤ) ≤ BitVec.toInt sz) (fact1 : Z.readers mpz x = (0 : ℤ)) (fact2 : (1 : ℤ) ≤ Z.alloc mpz x) : Z.readers mpz x = (0 : ℤ) ∧ (∀(mpz1 : Z.mpz_memo), Z.abs_value_of mpz1 = Z.abs_value_of mpz ∧ Z.alloc mpz1 = Z.alloc mpz ∧ Z.abs_size mpz1 = Z.abs_size mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(p : C.ptr (BitVec 64)), Z.readers mpz1 x = -(1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬x = y → Z.readers mpz1 y = Z.readers mpz y) ∧ Lemmas.value p (Z.abs_size mpz1 x) = Z.abs_value_of mpz1 x ∧ C.plength p = Z.alloc mpz1 x ∧ C.offset p = (0 : ℤ) ∧ C.min p = (0 : ℤ) ∧ C.max p = C.plength p ∧ C.writable p = true ∧ C.zone1 p = Z.zones mpz1 x → -(2 : ℤ) < Z.readers mpz1 x ∧ (∀(os : BitVec 32), BitVec.toInt os = Z.abs_size mpz1 x → ((0 : ℤ) ≤ BitVec.toInt sz ∧ C.offset p = (0 : ℤ) ∧ C.min p = (0 : ℤ) ∧ C.max p = C.plength p ∧ (0 : ℤ) < C.plength p ∧ C.writable p = true) ∧ (∀(p1 : C.ptr (BitVec 64)), C.offset p1 = C.offset p ∧ C.writable p1 = C.writable p ∧ C.zone1 p1 = C.zone1 p → (∀(q : C.ptr (BitVec 64)), C.writable q = true ∧ (¬C.zone1 q = C.null_zone → C.min q = (0 : ℤ)) ∧ (¬C.zone1 q = C.null_zone → C.max q = C.plength q) ∧ C.offset q = (0 : ℤ) ∧ (¬C.zone1 q = C.null_zone → C.plength q = BitVec.toInt sz) ∧ (¬C.zone1 q = C.null_zone → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < C.plength p) ∧ i < BitVec.toInt sz → C.pelts q i = C.pelts p i)) ∧ (C.zone1 q = C.null_zone → p1 = p) → C.is_not_null q = (¬C.zone1 q = C.null_zone) → C.is_not_null q → -(2 : ℤ) < Z.readers mpz1 x ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = Z.abs_size mpz1 x → (if BitVec.toInt sz < BitVec.toInt o1 then (-(1 : ℤ) ≤ Z.readers mpz1 x ∧ Z.readers mpz1 x ≤ (0 : ℤ)) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz2 mpz1) ∧ Z.abs_size mpz2 x = (0 : ℤ) ∧ Z.abs_value_of mpz2 x = (0 : ℤ) → (Z.abs_size mpz2 x ≤ BitVec.toInt sz ∧ -(1 : ℤ) ≤ Z.readers mpz2 x ∧ Z.readers mpz2 x ≤ (0 : ℤ)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.readers mpz3 = Z.readers mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz3 mpz2) ∧ Z.alloc mpz3 x = BitVec.toInt sz → (C.offset q = (0 : ℤ) ∧ C.writable q = true ∧ C.min q = (0 : ℤ) ∧ C.max q = C.plength q ∧ C.plength q = Z.alloc mpz3 x ∧ (Z.readers mpz3 x = (0 : ℤ) ∨ Z.readers mpz3 x = -(1 : ℤ))) ∧ (∀(mpz4 : Z.mpz_memo), Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz4 mpz3) ∧ Z.abs_value_of mpz4 x = Lemmas.value q (Z.abs_size mpz4 x) ∧ Z.readers mpz4 x = -(1 : ℤ) ∧ Z.zones mpz4 x = C.zone1 q → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz4 mpz) ∧ Z.readers mpz4 x = -(1 : ℤ) ∧ Z.alloc mpz4 x = BitVec.toInt sz ∧ Z.abs_value_of mpz4 x = Lemmas.value q (Z.abs_size mpz4 x) ∧ Z.zones mpz4 x = C.zone1 q ∧ C.offset q = (0 : ℤ) ∧ C.plength q = BitVec.toInt sz ∧ C.min q = (0 : ℤ) ∧ C.max q = BitVec.toInt sz ∧ C.writable q = true ∧ (if Z.abs_size mpz x ≤ BitVec.toInt sz then Z.abs_size mpz4 x = Z.abs_size mpz x ∧ Lemmas.value q (Z.abs_size mpz x) = Z.abs_value_of mpz x else Z.abs_size mpz4 x = (0 : ℤ))))) else (Z.abs_size mpz1 x ≤ BitVec.toInt sz ∧ -(1 : ℤ) ≤ Z.readers mpz1 x ∧ Z.readers mpz1 x ≤ (0 : ℤ)) ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz2 mpz1) ∧ Z.alloc mpz2 x = BitVec.toInt sz → (C.offset q = (0 : ℤ) ∧ C.writable q = true ∧ C.min q = (0 : ℤ) ∧ C.max q = C.plength q ∧ C.plength q = Z.alloc mpz2 x ∧ (Z.readers mpz2 x = (0 : ℤ) ∨ Z.readers mpz2 x = -(1 : ℤ))) ∧ (∀(mpz3 : Z.mpz_memo), Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz3 mpz2) ∧ Z.abs_value_of mpz3 x = Lemmas.value q (Z.abs_size mpz3 x) ∧ Z.readers mpz3 x = -(1 : ℤ) ∧ Z.zones mpz3 x = C.zone1 q → (∀(y : Z.mpz_ptr), ¬y = x → Z.mpz_unchanged y mpz3 mpz) ∧ Z.readers mpz3 x = -(1 : ℤ) ∧ Z.alloc mpz3 x = BitVec.toInt sz ∧ Z.abs_value_of mpz3 x = Lemmas.value q (Z.abs_size mpz3 x) ∧ Z.zones mpz3 x = C.zone1 q ∧ C.offset q = (0 : ℤ) ∧ C.plength q = BitVec.toInt sz ∧ C.min q = (0 : ℤ) ∧ C.max q = BitVec.toInt sz ∧ C.writable q = true ∧ (if Z.abs_size mpz x ≤ BitVec.toInt sz then Z.abs_size mpz3 x = Z.abs_size mpz x ∧ Lemmas.value q (Z.abs_size mpz x) = Z.abs_value_of mpz x else Z.abs_size mpz3 x = (0 : ℤ)))))))))))
  := sorry
end mpz_Zutil_wmpz_do_reallocqtvc
