import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.c.C
import Why3.mach.int.Unsigned
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.ptralias.Alias
open Classical
open Lean4Why3
namespace add_Add_add_n_rxqtvc
theorem add_n_rx'vc (sz : BitVec 32) (x : C.ptr (BitVec 64)) (y : C.ptr (BitVec 64)) (fact0 : (0 : ℤ) ≤ BitVec.toInt sz) (fact1 : C.valid x (BitVec.toInt sz)) (fact2 : C.valid y (BitVec.toInt sz)) (fact3 : C.writable x = true) : C.valid x (BitVec.toInt sz) ∧ C.valid y (BitVec.toInt sz) ∧ (0 : ℤ) ≤ BitVec.toInt sz ∧ BitVec.toInt sz ≤ BitVec.toInt sz ∧ C.writable x = true ∧ (∀(y1 : C.ptr (BitVec 64)) (x1 : C.ptr (BitVec 64)), C.offset y1 = C.offset y ∧ C.writable y1 = C.writable y ∧ C.zone1 y1 = C.zone1 y → C.offset x1 = C.offset x ∧ C.writable x1 = C.writable x ∧ C.zone1 x1 = C.zone1 x → (∀(nr : C.ptr (BitVec 64)) (nx : C.ptr (BitVec 64)) (ny : C.ptr (BitVec 64)) (m : Alias.mem), C.writable nr = true ∧ (Lemmas.value nx (BitVec.toInt sz) = Lemmas.value x (BitVec.toInt sz) ∧ Lemmas.value ny (BitVec.toInt sz) = Lemmas.value y (BitVec.toInt sz)) ∧ (C.valid nx (BitVec.toInt sz) ∧ C.valid ny (BitVec.toInt sz)) ∧ Alias.identical nr nx ∧ ((0 : ℤ) ≤ C.offset nx ∧ C.offset nx + BitVec.toInt sz ≤ C.offset ny ∨ (0 : ℤ) ≤ C.offset ny ∧ C.offset ny + BitVec.toInt sz ≤ C.offset nx) ∧ (Alias.zx m = C.zone1 x1 ∧ Alias.zy m = C.zone1 y1) ∧ (BitVec.toInt (Alias.mx m) = C.max x ∧ BitVec.toInt (Alias.my m) = C.max y) ∧ (Alias.lx m = sz ∧ Alias.ly m = sz) ∧ Alias.ok m = true ∧ Lemmas.map_eq_sub_shift (C.pelts nx) (C.pelts x1) (C.offset nx) (C.offset x1) (BitVec.toInt sz) ∧ Lemmas.map_eq_sub_shift (C.pelts ny) (C.pelts y1) (C.offset ny) (C.offset y1) (BitVec.toInt sz) ∧ (C.pelts x1 = C.pelts x ∧ C.pelts y1 = C.pelts y) ∧ (C.plength x1 = C.plength x ∧ C.plength y1 = C.plength y) ∧ (C.min x1 = C.min x ∧ C.min y1 = C.min y) ∧ C.data nr = C.data nx ∧ C.data nx = C.data ny → ((0 : ℤ) ≤ BitVec.toInt sz ∧ (C.valid nr (BitVec.toInt sz) ∧ C.valid nx (BitVec.toInt sz) ∧ C.valid ny (BitVec.toInt sz)) ∧ (C.offset nr = C.offset nx ∨ C.offset nr + BitVec.toInt sz ≤ C.offset nx ∨ C.offset nx + BitVec.toInt sz ≤ C.offset nr) ∧ (C.offset nr = C.offset ny ∨ C.offset nr + BitVec.toInt sz ≤ C.offset ny ∨ C.offset ny + BitVec.toInt sz ≤ C.offset nr) ∧ (C.data nr = C.data nx ∧ C.data nx = C.data ny) ∧ C.writable nr = true) ∧ (∀(ny1 : C.ptr (BitVec 64)) (nx1 : C.ptr (BitVec 64)) (nr1 : C.ptr (BitVec 64)), C.data ny1 = C.data nr1 ∧ List.length (C.data nr1) = List.length (C.data ny) ∧ C.offset ny1 = C.offset ny ∧ C.min ny1 = C.min ny ∧ C.max ny1 = C.max ny ∧ C.writable ny1 = C.writable ny ∧ C.zone1 ny1 = C.zone1 ny → C.data nx1 = C.data nr1 ∧ List.length (C.data nr1) = List.length (C.data nx) ∧ C.offset nx1 = C.offset nx ∧ C.min nx1 = C.min nx ∧ C.max nx1 = C.max nx ∧ C.writable nx1 = C.writable nx ∧ C.zone1 nx1 = C.zone1 nx → List.length (C.data nr1) = List.length (C.data nr) ∧ C.offset nr1 = C.offset nr ∧ C.min nr1 = C.min nr ∧ C.max nr1 = C.max nr ∧ C.writable nr1 = C.writable nr ∧ C.zone1 nr1 = C.zone1 nr → (∀(res : BitVec 64), Lemmas.value nr1 (BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz)) * BitVec.toUInt res = Lemmas.value nx (BitVec.toInt sz) + Lemmas.value ny (BitVec.toInt sz) ∧ ((0 : ℤ) ≤ BitVec.toUInt res ∧ BitVec.toUInt res ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset nr1 ∨ C.offset nr1 + BitVec.toInt sz ≤ j → C.pelts nr1 j = C.pelts nr j) ∧ (C.offset nr1 = C.offset nx1 ∨ MapEq.map_eq_sub (C.pelts nx1) (C.pelts nx) (C.offset nx1) (C.offset nx1 + BitVec.toInt sz)) ∧ (C.offset nr1 = C.offset ny1 ∨ MapEq.map_eq_sub (C.pelts ny1) (C.pelts ny) (C.offset ny1) (C.offset ny1 + BitVec.toInt sz)) → ((C.writable x1 = true ∧ C.writable nr1 = true) ∧ Alias.ok m = true ∧ ((0 : ℤ) ≤ BitVec.toInt sz ∧ BitVec.toInt sz ≤ BitVec.toInt sz) ∧ Alias.identical nr1 nx1 ∧ ((0 : ℤ) ≤ C.offset nx1 ∧ C.offset nx1 + BitVec.toInt sz ≤ C.offset ny1 ∨ (0 : ℤ) ≤ C.offset ny1 ∧ C.offset ny1 + BitVec.toInt sz ≤ C.offset nx1) ∧ (Alias.zx m = C.zone1 x1 ∧ Alias.zy m = C.zone1 y1) ∧ Alias.lx m = sz ∧ Alias.ly m = sz) ∧ (∀(m1 : Alias.mem) (ny2 : C.ptr (BitVec 64)) (nx2 : C.ptr (BitVec 64)) (y2 : C.ptr (BitVec 64)) (x2 : C.ptr (BitVec 64)), Alias.zr m1 = Alias.zr m ∧ Alias.zx m1 = Alias.zx m ∧ Alias.zy m1 = Alias.zy m ∧ Alias.mr m1 = Alias.mr m ∧ Alias.mx m1 = Alias.mx m ∧ Alias.my m1 = Alias.my m ∧ Alias.lr m1 = Alias.lr m ∧ Alias.lx m1 = Alias.lx m ∧ Alias.ly m1 = Alias.ly m → C.offset ny2 = C.offset ny1 ∧ C.writable ny2 = C.writable ny1 ∧ C.zone1 ny2 = C.zone1 ny1 → C.offset nx2 = C.offset nx1 ∧ C.writable nx2 = C.writable nx1 ∧ C.zone1 nx2 = C.zone1 nx1 → C.offset y2 = C.offset y1 ∧ C.min y2 = C.min y1 ∧ C.writable y2 = C.writable y1 ∧ C.zone1 y2 = C.zone1 y1 → C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → (C.max x2 = BitVec.toInt (Alias.mx m1) ∧ C.max y2 = BitVec.toInt (Alias.my m1)) ∧ Lemmas.map_eq_sub_shift (C.pelts nx1) (C.pelts x2) (C.offset nx2) (C.offset x2) (BitVec.toInt sz) ∧ Lemmas.map_eq_sub_shift (C.pelts ny1) (C.pelts y2) (C.offset ny2) (C.offset y2) (BitVec.toInt sz) ∧ (∀(j : ℤ), j < C.offset x2 ∨ C.offset x2 + BitVec.toInt sz ≤ j → C.pelts x2 j = C.pelts x1 j) ∧ (∀(j : ℤ), j < C.offset y2 ∨ C.offset y2 + BitVec.toInt sz ≤ j → C.pelts y2 j = C.pelts y1 j) ∧ (C.plength x2 = C.plength x1 ∧ C.plength y2 = C.plength y1) ∧ C.min x2 = C.min x1 ∧ C.min y2 = C.min y1 → Lemmas.value x2 (BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz)) * BitVec.toUInt res = Lemmas.value x (BitVec.toInt sz) + Lemmas.value y (BitVec.toInt sz) ∧ ((0 : ℤ) ≤ BitVec.toUInt res ∧ BitVec.toUInt res ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset x2 ∨ C.offset x2 + BitVec.toInt sz ≤ j → C.pelts x2 j = C.pelts x j) ∧ (∀(j : ℤ), C.pelts y2 j = C.pelts y j) ∧ Lemmas.value y2 (BitVec.toInt sz) = Lemmas.value y (BitVec.toInt sz) ∧ (C.min x2 = C.min x ∧ C.max x2 = C.max x ∧ C.plength x2 = C.plength x) ∧ C.min y2 = C.min y ∧ C.max y2 = C.max y ∧ C.plength y2 = C.plength y)))))
  := sorry
end add_Add_add_n_rxqtvc
