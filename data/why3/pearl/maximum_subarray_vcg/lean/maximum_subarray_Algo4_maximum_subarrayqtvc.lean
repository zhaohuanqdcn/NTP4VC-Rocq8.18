import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Sum
import pearl.maximum_subarray_vcg.lean.maximum_subarray.Spec
open Classical
open Lean4Why3
namespace maximum_subarray_Algo4_maximum_subarrayqtvc
theorem maximum_subarray'vc (a : List ℤ) : let o1 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → ((((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ)) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) = List.sum (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a))) ∧ (∀(l' : ℤ) (h' : ℤ), (0 : ℤ) ≤ l' ∧ l' ≤ h' ∧ h' ≤ (0 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ (0 : ℤ)) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) = List.sum (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a))) ∧ (∀(l' : ℤ), (0 : ℤ) ≤ l' ∧ l' < (0 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take ((0 : ℕ) - Int.toNat l') a)) ≤ (0 : ℤ))) ∧ (∀(s : ℤ) (l : ℤ) (ms : ℤ) (hi : ℤ) (lo : ℤ), (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ (((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ i) ∧ (0 : ℤ) ≤ ms ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ (∀(l' : ℤ) (h' : ℤ), (0 : ℤ) ≤ l' ∧ l' ≤ h' ∧ h' ≤ i → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms) ∧ (((0 : ℤ) ≤ l ∧ l ≤ i) ∧ s = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat i - Int.toNat l) a))) ∧ (∀(l' : ℤ), (0 : ℤ) ≤ l' ∧ l' < i → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat i - Int.toNat l') a)) ≤ s) → (if s < (0 : ℤ) then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if ms < a[Int.toNat i]! then (((0 : ℤ) ≤ i ∧ i ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ (0 : ℤ) ≤ a[Int.toNat i]! ∧ a[Int.toNat i]! = List.sum (List.drop (Int.toNat i) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat i) a))) ∧ (∀(l' : ℤ) (h' : ℤ), (0 : ℤ) ≤ l' ∧ l' ≤ h' ∧ h' ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ a[Int.toNat i]!) ∧ (((0 : ℤ) ≤ i ∧ i ≤ i + (1 : ℤ)) ∧ a[Int.toNat i]! = List.sum (List.drop (Int.toNat i) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat i) a))) ∧ (∀(l' : ℤ), (0 : ℤ) ≤ l' ∧ l' < i + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat l') a)) ≤ a[Int.toNat i]!) else (((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ i + (1 : ℤ)) ∧ (0 : ℤ) ≤ ms ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ (∀(l' : ℤ) (h' : ℤ), (0 : ℤ) ≤ l' ∧ l' ≤ h' ∧ h' ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms) ∧ (((0 : ℤ) ≤ i ∧ i ≤ i + (1 : ℤ)) ∧ a[Int.toNat i]! = List.sum (List.drop (Int.toNat i) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat i) a))) ∧ (∀(l' : ℤ), (0 : ℤ) ≤ l' ∧ l' < i + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat l') a)) ≤ a[Int.toNat i]!)) else ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if ms < s + a[Int.toNat i]! then (((0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ (0 : ℤ) ≤ s + a[Int.toNat i]! ∧ s + a[Int.toNat i]! = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat l) a))) ∧ (∀(l' : ℤ) (h' : ℤ), (0 : ℤ) ≤ l' ∧ l' ≤ h' ∧ h' ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ s + a[Int.toNat i]!) ∧ (((0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ)) ∧ s + a[Int.toNat i]! = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat l) a))) ∧ (∀(l' : ℤ), (0 : ℤ) ≤ l' ∧ l' < i + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat l') a)) ≤ s + a[Int.toNat i]!) else (((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ i + (1 : ℤ)) ∧ (0 : ℤ) ≤ ms ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ (∀(l' : ℤ) (h' : ℤ), (0 : ℤ) ≤ l' ∧ l' ≤ h' ∧ h' ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms) ∧ (((0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ)) ∧ s + a[Int.toNat i]! = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat l) a))) ∧ (∀(l' : ℤ), (0 : ℤ) ≤ l' ∧ l' < i + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat l') a)) ≤ s + a[Int.toNat i]!)))) ∧ ((((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ o1 + (1 : ℤ)) ∧ (0 : ℤ) ≤ ms ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ (∀(l' : ℤ) (h' : ℤ), (0 : ℤ) ≤ l' ∧ l' ≤ h' ∧ h' ≤ o1 + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms) ∧ (((0 : ℤ) ≤ l ∧ l ≤ o1 + (1 : ℤ)) ∧ s = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (o1 + (1 : ℤ)) - Int.toNat l) a))) ∧ (∀(l' : ℤ), (0 : ℤ) ≤ l' ∧ l' < o1 + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat (o1 + (1 : ℤ)) - Int.toNat l') a)) ≤ s) → (((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ Int.ofNat (List.length a)) ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ Spec.maxsub a ms))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length a)) ∧ (0 : ℤ) = List.sum (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a))) ∧ Spec.maxsub a (0 : ℤ))
  := sorry
end maximum_subarray_Algo4_maximum_subarrayqtvc
