theory space_saving_Top_space_saving_kqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_Sum"
begin
typedecl  elt
consts dummy :: "elt"
consts minimum :: "int list \<Rightarrow> int"
axiomatization where minimum'spec'0'0:   "(0 :: int) \<le> minimum a"
 if "(0 :: int) < int (length a)"
  for a :: "int list"
axiomatization where minimum'spec'0'1:   "minimum a < int (length a)"
 if "(0 :: int) < int (length a)"
  for a :: "int list"
axiomatization where minimum'spec:   "a ! nat (minimum a) \<le> a ! nat i"
 if "(0 :: int) < int (length a)"
 and "(0 :: int) \<le> i"
 and "i < int (length a)"
  for a :: "int list"
  and i :: "int"
definition occurs :: "elt \<Rightarrow> elt list \<Rightarrow> _"
  where "occurs v a \<longleftrightarrow> (\<exists>(i :: int). ((0 :: int) \<le> i \<and> i < int (length a)) \<and> v = a ! nat i)" for v a
theorem space_saving_k'vc:
  fixes k :: "int"
  fixes s :: "int \<Rightarrow> elt"
  assumes fact0: "(2 :: int) \<le> k"
  shows "(0 :: int) \<le> k"
  and "\<forall>(o1 :: elt list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < k \<longrightarrow> o1 ! nat i = dummy) \<and> int (length o1) = k \<longrightarrow> (0 :: int) \<le> k \<and> (\<forall>(o2 :: int list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < k \<longrightarrow> o2 ! nat i = (0 :: int)) \<and> int (length o2) = k \<longrightarrow> ((sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) o2)) = (0 :: int) \<and> (0 :: int) \<le> (0 :: int)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < k \<longrightarrow> (0 :: int) \<le> int (map_occ (o1 ! nat i) s (0 :: int) (0 :: int)) \<and> int (map_occ (o1 ! nat i) s (0 :: int) (0 :: int)) \<le> o2 ! nat i) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < k \<longrightarrow> (if o2 ! nat i = (0 :: int) then o1 ! nat i = dummy else \<not>o1 ! nat i = dummy)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < k \<longrightarrow> (0 :: int) < o2 ! nat i \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k \<longrightarrow> (0 :: int) < o2 ! nat j \<longrightarrow> \<not>i = j \<longrightarrow> \<not>o1 ! nat i = o1 ! nat j)) \<and> (\<forall>(y :: elt). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < k \<longrightarrow> \<not>y = o1 ! nat i) \<longrightarrow> int (map_occ y s (0 :: int) (0 :: int)) \<le> o2 ! nat (minimum o2))) \<and> (\<forall>(c :: int list) (e :: elt list). length c = length o2 \<longrightarrow> length e = length o1 \<longrightarrow> (0 :: int) \<le> sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < k \<longrightarrow> (0 :: int) \<le> int (map_occ (e ! nat i) s (0 :: int) (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))) \<and> int (map_occ (e ! nat i) s (0 :: int) (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))) \<le> c ! nat i) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < k \<longrightarrow> (if c ! nat i = (0 :: int) then e ! nat i = dummy else \<not>e ! nat i = dummy)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < k \<longrightarrow> (0 :: int) < c ! nat i \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k \<longrightarrow> (0 :: int) < c ! nat j \<longrightarrow> \<not>i = j \<longrightarrow> \<not>e ! nat i = e ! nat j)) \<and> (\<forall>(y :: elt). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < k \<longrightarrow> \<not>y = e ! nat i) \<longrightarrow> int (map_occ y s (0 :: int) (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))) \<le> c ! nat (minimum c)) \<longrightarrow> (0 :: int) \<le> sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) \<and> (\<not>s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c))) = dummy \<longrightarrow> int (length e) = k \<and> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> k) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> \<not>e ! nat j = s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))) \<and> (i < k \<longrightarrow> e ! nat i = s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))) \<longrightarrow> (if i < k then (((0 :: int) \<le> i \<and> i < int (length c) \<and> int (length c) = k) \<and> sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) = sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int) - (1 :: int)) \<and> (\<forall>(c1 :: int list). length c1 = length c \<longrightarrow> length c1 = length c \<longrightarrow> c1 ! nat i = c ! nat i + (1 :: int) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k \<longrightarrow> \<not>j = i \<longrightarrow> c1 ! nat j = c ! nat j) \<and> sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c1)) = sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int) \<longrightarrow> (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c1)) = sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int) \<and> (0 :: int) \<le> sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int)) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < k \<longrightarrow> (0 :: int) \<le> int (map_occ (e ! nat i1) s (0 :: int) (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int))) \<and> int (map_occ (e ! nat i1) s (0 :: int) (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int))) \<le> c1 ! nat i1) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < k \<longrightarrow> (if c1 ! nat i1 = (0 :: int) then e ! nat i1 = dummy else \<not>e ! nat i1 = dummy)) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < k \<longrightarrow> (0 :: int) < c1 ! nat i1 \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k \<longrightarrow> (0 :: int) < c1 ! nat j \<longrightarrow> \<not>i1 = j \<longrightarrow> \<not>e ! nat i1 = e ! nat j)) \<and> (\<forall>(y :: elt). (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < k \<longrightarrow> \<not>y = e ! nat i1) \<longrightarrow> int (map_occ y s (0 :: int) (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int))) \<le> c1 ! nat (minimum c1))) else (0 :: int) < int (length c) \<and> (let m :: int = minimum c in ((0 :: int) \<le> m \<and> m < int (length c)) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < int (length c) \<longrightarrow> c ! nat m \<le> c ! nat i1) \<longrightarrow> ((0 :: int) \<le> m \<and> m < int (length e)) \<and> (length (e[nat m := s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))]) = length e \<longrightarrow> length (e[nat m := s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))]) = length e \<longrightarrow> nth (e[nat m := s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))]) o nat = (nth e o nat)(m := s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))) \<longrightarrow> (((0 :: int) \<le> m \<and> m < int (length c) \<and> int (length c) = k) \<and> sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) = sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int) - (1 :: int)) \<and> (\<forall>(c1 :: int list). length c1 = length c \<longrightarrow> length c1 = length c \<longrightarrow> c1 ! nat m = c ! nat m + (1 :: int) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k \<longrightarrow> \<not>j = m \<longrightarrow> c1 ! nat j = c ! nat j) \<and> sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c1)) = sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int) \<longrightarrow> (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c1)) = sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int) \<and> (0 :: int) \<le> sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int)) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < k \<longrightarrow> (0 :: int) \<le> int (map_occ (e[nat m := s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))] ! nat i1) s (0 :: int) (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int))) \<and> int (map_occ (e[nat m := s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))] ! nat i1) s (0 :: int) (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int))) \<le> c1 ! nat i1) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < k \<longrightarrow> (if c1 ! nat i1 = (0 :: int) then e[nat m := s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))] ! nat i1 = dummy else \<not>e[nat m := s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))] ! nat i1 = dummy)) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < k \<longrightarrow> (0 :: int) < c1 ! nat i1 \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k \<longrightarrow> (0 :: int) < c1 ! nat j \<longrightarrow> \<not>i1 = j \<longrightarrow> \<not>e[nat m := s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))] ! nat i1 = e[nat m := s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))] ! nat j)) \<and> (\<forall>(y :: elt). (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < k \<longrightarrow> \<not>y = e[nat m := s (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)))] ! nat i1) \<longrightarrow> int (map_occ y s (0 :: int) (sum_list (drop (0 :: nat) (take (nat k - (0 :: nat)) c)) + (1 :: int))) \<le> c1 ! nat (minimum c1))))))))))"
  sorry
end
