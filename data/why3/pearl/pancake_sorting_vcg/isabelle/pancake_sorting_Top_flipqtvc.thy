theory pancake_sorting_Top_flipqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut"
begin
definition sorted :: "int list \<Rightarrow> int \<Rightarrow> _"
  where "sorted a hi \<longleftrightarrow> (\<forall>(j1 :: int) (j2 :: int). (0 :: int) \<le> j1 \<and> j1 \<le> j2 \<and> j2 < hi \<longrightarrow> a ! nat j2 \<le> a ! nat j1)" for a hi
theorem flip'vc:
  fixes i :: "int"
  fixes a :: "int list"
  assumes fact0: "(0 :: int) \<le> i"
  assumes fact1: "i < int (length a)"
  shows "let n :: int = int (length a) in \<not>(2 :: int) = (0 :: int) \<and> (let o1 :: int = (n - i) cdiv (2 :: int) - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((\<forall>(j :: int). i \<le> j \<and> j < i + (0 :: int) \<longrightarrow> a ! nat j = a ! nat (n - (1 :: int) - (j - i))) \<and> (\<forall>(j :: int). n - (0 :: int) \<le> j \<and> j < n \<longrightarrow> a ! nat j = a ! nat (n - (1 :: int) - (j - i))) \<and> a <~~> a) \<and> (\<forall>(a1 :: int list). length a1 = length a \<longrightarrow> (\<forall>(k :: int). ((0 :: int) \<le> k \<and> k \<le> o1) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> a1 ! nat j = a ! nat j) \<and> (\<forall>(j :: int). i \<le> j \<and> j < i + k \<longrightarrow> a1 ! nat j = a ! nat (n - (1 :: int) - (j - i))) \<and> (\<forall>(j :: int). i + k \<le> j \<and> j < n - k \<longrightarrow> a1 ! nat j = a ! nat j) \<and> (\<forall>(j :: int). n - k \<le> j \<and> j < n \<longrightarrow> a1 ! nat j = a ! nat (n - (1 :: int) - (j - i))) \<and> a <~~> a1 \<longrightarrow> (let o2 :: int = n - (1 :: int) - k; o3 :: int = i + k in (((0 :: int) \<le> o3 \<and> o3 < int (length a1)) \<and> (0 :: int) \<le> o2 \<and> o2 < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 o3 o2 \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> a2 ! nat j = a ! nat j) \<and> (\<forall>(j :: int). i \<le> j \<and> j < i + (k + (1 :: int)) \<longrightarrow> a2 ! nat j = a ! nat (n - (1 :: int) - (j - i))) \<and> (\<forall>(j :: int). i + (k + (1 :: int)) \<le> j \<and> j < n - (k + (1 :: int)) \<longrightarrow> a2 ! nat j = a ! nat j) \<and> (\<forall>(j :: int). n - (k + (1 :: int)) \<le> j \<and> j < n \<longrightarrow> a2 ! nat j = a ! nat (n - (1 :: int) - (j - i))) \<and> a <~~> a2))) \<and> ((\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> a1 ! nat j = a ! nat j) \<and> (\<forall>(j :: int). i \<le> j \<and> j < i + (o1 + (1 :: int)) \<longrightarrow> a1 ! nat j = a ! nat (n - (1 :: int) - (j - i))) \<and> (\<forall>(j :: int). i + (o1 + (1 :: int)) \<le> j \<and> j < n - (o1 + (1 :: int)) \<longrightarrow> a1 ! nat j = a ! nat j) \<and> (\<forall>(j :: int). n - (o1 + (1 :: int)) \<le> j \<and> j < n \<longrightarrow> a1 ! nat j = a ! nat (n - (1 :: int) - (j - i))) \<and> a <~~> a1 \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> a1 ! nat j = a ! nat j) \<and> (\<forall>(j :: int). i \<le> j \<and> j < int (length a1) \<longrightarrow> a1 ! nat j = a ! nat (int (length a1) - (1 :: int) - (j - i))) \<and> a <~~> a1))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> (\<forall>(j :: int). i \<le> j \<and> j < int (length a) \<longrightarrow> a ! nat j = a ! nat (int (length a) - (1 :: int) - (j - i))) \<and> a <~~> a))"
  sorry
end
