import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Fibonacci
import pearl.ropes_vcg.lean.ropes.MyString
import pearl.ropes_vcg.lean.ropes.Rope
open Classical
open Lean4Why3
namespace ropes_Balance_insert_leavesqtvc
axiom max : ℤ
axiom max'def : (2 : ℤ) ≤ max
axiom string_of_array : List Rope.rope -> ℤ -> ℤ -> MyString.char_string
axiom string_of_array_empty (l : ℤ) (q : List Rope.rope) (fact0 : (0 : ℤ) ≤ l) (fact1 : l ≤ Int.ofNat (List.length q)) : MyString.infix_eqeq (string_of_array q l l) MyString.empty
axiom string_of_array_concat_left (l : ℤ) (u : ℤ) (q : List Rope.rope) (fact0 : (0 : ℤ) ≤ l) (fact1 : l < u) (fact2 : u ≤ Int.ofNat (List.length q)) : MyString.infix_eqeq (string_of_array q l u) (MyString.app (string_of_array q (l + (1 : ℤ)) u) (Rope.string (q[Int.toNat l]!)))
noncomputable def string_of_queue (q : List Rope.rope) := string_of_array q (2 : ℤ) (Int.ofNat (List.length q))
theorem insert_leaves'vc (q : List Rope.rope) (r : Rope.rope) (fact0 : (2 : ℤ) < Int.ofNat (List.length q)) (fact1 : Int.ofNat (List.length q) = max + (1 : ℤ)) (fact2 : Rope.inv r) (fact3 : ∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv (q[Int.toNat j]!)) (fact4 : MyString.length (string_of_queue q) + Rope.length r < Fibonacci.fib (max + (1 : ℤ))) : match r with | Rope.rope.Emp => (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv (q[Int.toNat j]!)) ∧ MyString.infix_eqeq (string_of_queue q) (MyString.app (string_of_queue q) (Rope.string r)) | Rope.rope.Str _ _ _ => (((2 : ℤ) ≤ (2 : ℤ) ∧ (2 : ℤ) < Int.ofNat (List.length q) ∧ Int.ofNat (List.length q) = max + (1 : ℤ)) ∧ Rope.inv r ∧ (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv (q[Int.toNat j]!)) ∧ MyString.length (string_of_array q (2 : ℤ) (max + (1 : ℤ))) + Rope.length r < Fibonacci.fib (max + (1 : ℤ))) ∧ (∀(q1 : List Rope.rope), List.length q1 = List.length q → (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv (q1[Int.toNat j]!)) ∧ (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j < (2 : ℤ) → q1[Int.toNat j]! = q[Int.toNat j]!) ∧ MyString.infix_eqeq (string_of_array q1 (2 : ℤ) (max + (1 : ℤ))) (MyString.app (string_of_array q (2 : ℤ) (max + (1 : ℤ))) (Rope.string r)) → (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv (q1[Int.toNat j]!)) ∧ MyString.infix_eqeq (string_of_queue q1) (MyString.app (string_of_queue q) (Rope.string r))) | Rope.rope.App left1 right1 _ => ((match r with | Rope.rope.Emp => False | Rope.rope.Str _ _ _ => False | Rope.rope.App f f1 _ => f = left1 ∨ f1 = left1) ∧ ((2 : ℤ) < Int.ofNat (List.length q) ∧ Int.ofNat (List.length q) = max + (1 : ℤ)) ∧ Rope.inv left1 ∧ (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv (q[Int.toNat j]!)) ∧ MyString.length (string_of_queue q) + Rope.length left1 < Fibonacci.fib (max + (1 : ℤ))) ∧ (∀(q1 : List Rope.rope), List.length q1 = List.length q → (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv (q1[Int.toNat j]!)) ∧ MyString.infix_eqeq (string_of_queue q1) (MyString.app (string_of_queue q) (Rope.string left1)) → ((match r with | Rope.rope.Emp => False | Rope.rope.Str _ _ _ => False | Rope.rope.App f f1 _ => f = right1 ∨ f1 = right1) ∧ ((2 : ℤ) < Int.ofNat (List.length q1) ∧ Int.ofNat (List.length q1) = max + (1 : ℤ)) ∧ Rope.inv right1 ∧ (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv (q1[Int.toNat j]!)) ∧ MyString.length (string_of_queue q1) + Rope.length right1 < Fibonacci.fib (max + (1 : ℤ))) ∧ (∀(q2 : List Rope.rope), List.length q2 = List.length q1 → (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv (q2[Int.toNat j]!)) ∧ MyString.infix_eqeq (string_of_queue q2) (MyString.app (string_of_queue q1) (Rope.string right1)) → (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv (q2[Int.toNat j]!)) ∧ MyString.infix_eqeq (string_of_queue q2) (MyString.app (string_of_queue q) (Rope.string r))))
  := sorry
end ropes_Balance_insert_leavesqtvc
