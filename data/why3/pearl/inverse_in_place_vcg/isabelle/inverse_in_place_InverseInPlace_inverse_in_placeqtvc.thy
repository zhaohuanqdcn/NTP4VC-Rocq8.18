theory inverse_in_place_InverseInPlace_inverse_in_placeqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_NumOf"
begin
definition prefix_tl :: "int \<Rightarrow> int"
  where "prefix_tl x = -x - (1 :: int)" for x
consts fc :: "(int \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> bool"
axiomatization where fc'def:   "fc m n = True \<longleftrightarrow> (0 :: int) \<le> m n"
  for m :: "int \<Rightarrow> int"
  and n :: "int"
definition numof :: "(int \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int"
  where "numof m l r = int_NumOf.numof (fc m) l r" for m l r
definition is_permutation :: "int list \<Rightarrow> _"
  where "is_permutation a \<longleftrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length a) \<longrightarrow> ((0 :: int) \<le> a ! nat i \<and> a ! nat i < int (length a)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length a) \<longrightarrow> \<not>i = j \<longrightarrow> \<not>a ! nat i = a ! nat j))" for a
definition loopinvariant :: "int list \<Rightarrow> int list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "loopinvariant olda a m m' n \<longleftrightarrow> (\<forall>(e :: int). (0 :: int) \<le> e \<and> e < n \<longrightarrow> -n \<le> a ! nat e \<and> a ! nat e < n) \<and> (\<forall>(e :: int). m < e \<and> e < n \<longrightarrow> (0 :: int) \<le> a ! nat e) \<and> (\<forall>(e :: int). m < e \<and> e < n \<longrightarrow> olda ! nat (a ! nat e) = e) \<and> (\<forall>(e :: int). (0 :: int) \<le> e \<and> e \<le> m' \<longrightarrow> (0 :: int) \<le> a ! nat e \<longrightarrow> olda ! nat e = a ! nat e) \<and> (\<forall>(e :: int). (0 :: int) \<le> e \<and> e \<le> m \<longrightarrow> a ! nat e \<le> m) \<and> (\<forall>(e :: int). (0 :: int) \<le> e \<and> e \<le> m' \<longrightarrow> a ! nat e < (0 :: int) \<longrightarrow> olda ! nat (prefix_tl (a ! nat e)) = e \<and> (prefix_tl (a ! nat e) \<le> m \<longrightarrow> a ! nat (prefix_tl (a ! nat e)) < (0 :: int)))" for olda a m m' n
theorem inverse_in_place'vc:
  fixes a :: "int list"
  assumes fact0: "is_permutation a"
  shows "let n :: int = int (length a); o1 :: int = n - (1 :: int) in ((0 :: int) - (1 :: int) \<le> o1 \<longrightarrow> loopinvariant a a o1 o1 n \<and> (\<forall>(a1 :: int list). length a1 = length a \<longrightarrow> (\<forall>(m :: int). (m \<le> o1 \<and> (0 :: int) \<le> m) \<and> loopinvariant a a1 m m n \<longrightarrow> ((0 :: int) \<le> m \<and> m < int (length a1)) \<and> (let o2 :: int = a1 ! nat m in if (0 :: int) \<le> o2 then ((0 :: int) \<le> m \<and> m < int (length a1)) \<and> (length (a1[nat m := -(1 :: int)]) = length a1 \<longrightarrow> nth (a1[nat m := -(1 :: int)]) o nat = (nth a1 o nat)(m := -(1 :: int)) \<longrightarrow> (let o3 :: int = prefix_tl m in ((0 :: int) \<le> o2 \<and> o2 < int (length (a1[nat m := -(1 :: int)]))) \<and> ((a1[nat m := -(1 :: int)] ! nat o2 \<le> m \<and> ((0 :: int) \<le> o2 \<and> o2 \<le> m) \<and> (prefix_tl m \<le> o3 \<and> o3 < (0 :: int)) \<and> a ! nat (prefix_tl o3) = o2 \<and> a1[nat m := -(1 :: int)] ! nat (prefix_tl o3) < (0 :: int) \<and> a1[nat m := -(1 :: int)] ! nat m < (0 :: int)) \<and> (\<forall>(e :: int). (0 :: int) \<le> e \<and> e < m \<longrightarrow> a1[nat m := -(1 :: int)] ! nat e < (0 :: int) \<longrightarrow> \<not>a1[nat m := -(1 :: int)] ! nat e = o3) \<and> loopinvariant a (a1[nat m := -(1 :: int)]) m (m - (1 :: int)) n) \<and> (\<forall>(j :: int) (a2 :: int list). length a2 = length (a1[nat m := -(1 :: int)]) \<longrightarrow> (a2 ! nat (a ! nat (prefix_tl j)) \<le> m \<and> ((0 :: int) \<le> a ! nat (prefix_tl j) \<and> a ! nat (prefix_tl j) \<le> m) \<and> (prefix_tl m \<le> j \<and> j < (0 :: int)) \<and> a2 ! nat (prefix_tl j) < (0 :: int) \<and> a2 ! nat m < (0 :: int)) \<and> (\<forall>(e :: int). (0 :: int) \<le> e \<and> e < m \<longrightarrow> a2 ! nat e < (0 :: int) \<longrightarrow> \<not>a2 ! nat e = j) \<and> loopinvariant a a2 m (m - (1 :: int)) n \<longrightarrow> (if (0 :: int) \<le> a2 ! nat (a ! nat (prefix_tl j)) then ((0 :: int) \<le> a ! nat (prefix_tl j) \<and> a ! nat (prefix_tl j) < int (length a2)) \<and> (length (a2[nat (a ! nat (prefix_tl j)) := j]) = length a2 \<longrightarrow> nth (a2[nat (a ! nat (prefix_tl j)) := j]) o nat = (nth a2 o nat)(a ! nat (prefix_tl j) := j) \<longrightarrow> ((0 :: int) \<le> a2 ! nat (a ! nat (prefix_tl j)) \<and> a2 ! nat (a ! nat (prefix_tl j)) < int (length (a2[nat (a ! nat (prefix_tl j)) := j]))) \<and> ((0 :: int) \<le> numof (nth a2 o nat) (0 :: int) n \<and> numof (nth (a2[nat (a ! nat (prefix_tl j)) := j]) o nat) (0 :: int) n < numof (nth a2 o nat) (0 :: int) n) \<and> (a2[nat (a ! nat (prefix_tl j)) := j] ! nat (a2 ! nat (a ! nat (prefix_tl j))) \<le> m \<and> ((0 :: int) \<le> a2 ! nat (a ! nat (prefix_tl j)) \<and> a2 ! nat (a ! nat (prefix_tl j)) \<le> m) \<and> (prefix_tl m \<le> prefix_tl (a ! nat (prefix_tl j)) \<and> prefix_tl (a ! nat (prefix_tl j)) < (0 :: int)) \<and> a ! nat (prefix_tl (prefix_tl (a ! nat (prefix_tl j)))) = a2 ! nat (a ! nat (prefix_tl j)) \<and> a2[nat (a ! nat (prefix_tl j)) := j] ! nat (prefix_tl (prefix_tl (a ! nat (prefix_tl j)))) < (0 :: int) \<and> a2[nat (a ! nat (prefix_tl j)) := j] ! nat m < (0 :: int)) \<and> (\<forall>(e :: int). (0 :: int) \<le> e \<and> e < m \<longrightarrow> a2[nat (a ! nat (prefix_tl j)) := j] ! nat e < (0 :: int) \<longrightarrow> \<not>a2[nat (a ! nat (prefix_tl j)) := j] ! nat e = prefix_tl (a ! nat (prefix_tl j))) \<and> loopinvariant a (a2[nat (a ! nat (prefix_tl j)) := j]) m (m - (1 :: int)) n) else let o4 :: int = prefix_tl j in ((0 :: int) \<le> m \<and> m < int (length a2)) \<and> (length (a2[nat m := o4]) = length a2 \<longrightarrow> nth (a2[nat m := o4]) o nat = (nth a2 o nat)(m := o4) \<longrightarrow> loopinvariant a (a2[nat m := o4]) (m - (1 :: int)) (m - (1 :: int)) n))))) else let o3 :: int = prefix_tl o2 in ((0 :: int) \<le> m \<and> m < int (length a1)) \<and> (length (a1[nat m := o3]) = length a1 \<longrightarrow> nth (a1[nat m := o3]) o nat = (nth a1 o nat)(m := o3) \<longrightarrow> loopinvariant a (a1[nat m := o3]) (m - (1 :: int)) (m - (1 :: int)) n))) \<and> (loopinvariant a a1 ((0 :: int) - (1 :: int)) ((0 :: int) - (1 :: int)) n \<longrightarrow> is_permutation a1 \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length a1) \<longrightarrow> a ! nat (a1 ! nat i) = i)))) \<and> (o1 < (0 :: int) - (1 :: int) \<longrightarrow> is_permutation a \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length a) \<longrightarrow> a ! nat (a ! nat i) = i))"
  sorry
end
