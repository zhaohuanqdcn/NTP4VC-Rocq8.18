import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.add.Add
open Classical
open Lean4Why3
namespace mul_Mul_wmpn_mul_1qtvc
theorem wmpn_mul_1'vc (x : C.ptr (BitVec 64)) (sz : BitVec 32) (r : C.ptr (BitVec 64)) (y : BitVec 64) (fact0 : C.valid x (BitVec.toInt sz)) (fact1 : C.valid r (BitVec.toInt sz)) (fact2 : C.writable r = true) : C.min x ≤ C.offset x + (0 : ℤ) ∧ C.offset x + (0 : ℤ) ≤ C.max x ∧ (∀(o1 : C.ptr (BitVec 64)), C.offset o1 = C.offset x + (0 : ℤ) ∧ C.plength o1 = C.plength x ∧ C.pelts o1 = C.pelts x ∧ C.data o1 = C.data x ∧ C.min o1 = C.min x ∧ C.max o1 = C.max x ∧ C.zone1 o1 = C.zone1 x ∧ C.writable o1 = C.writable x → (C.min r ≤ C.offset r + (0 : ℤ) ∧ C.offset r + (0 : ℤ) ≤ C.max r) ∧ (∀(o2 : C.ptr (BitVec 64)), C.offset o2 = C.offset r + (0 : ℤ) ∧ C.plength o2 = C.plength r ∧ C.pelts o2 = C.pelts r ∧ C.data o2 = C.data r ∧ C.min o2 = C.min r ∧ C.max o2 = C.max r ∧ C.zone1 o2 = C.zone1 r ∧ C.writable o2 = C.writable r → (((0 : ℤ) ≤ BitVec.toInt sz ∧ BitVec.toInt sz ≤ BitVec.toInt sz) ∧ (0 : ℤ) = BitVec.toInt sz - BitVec.toInt sz ∧ Lemmas.value r (0 : ℤ) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (0 : ℕ) * (0 : ℤ) = Lemmas.value x (0 : ℤ) * BitVec.toUInt y ∧ C.offset o2 = C.offset r + (0 : ℤ) ∧ C.plength o2 = C.plength r ∧ C.min o2 = C.min r ∧ C.max o2 = C.max r ∧ C.writable o2 = true ∧ C.pelts o2 = C.pelts r ∧ C.offset o1 = C.offset x + (0 : ℤ) ∧ C.plength o1 = C.plength x ∧ C.min o1 = C.min x ∧ C.max o1 = C.max x ∧ C.pelts o1 = C.pelts x) ∧ (∀(i : BitVec 32) (rp : C.ptr (BitVec 64)) (up : C.ptr (BitVec 64)) (n : BitVec 32) (cl : BitVec 64) (r1 : C.ptr (BitVec 64)), List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → ((0 : ℤ) ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ BitVec.toInt sz) ∧ BitVec.toInt i = BitVec.toInt sz - BitVec.toInt n ∧ Lemmas.value r1 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt cl = Lemmas.value x (BitVec.toInt i) * BitVec.toUInt y ∧ C.offset rp = C.offset r1 + BitVec.toInt i ∧ C.plength rp = C.plength r1 ∧ C.min rp = C.min r1 ∧ C.max rp = C.max r1 ∧ C.writable rp = true ∧ C.pelts rp = C.pelts r1 ∧ C.offset up = C.offset x + BitVec.toInt i ∧ C.plength up = C.plength x ∧ C.min up = C.min x ∧ C.max up = C.max x ∧ C.pelts up = C.pelts x ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sz ≤ j → C.pelts r1 j = C.pelts r j) → (∀(o3 : Bool), (BitVec.toInt n = BitVec.toInt (0 : BitVec 32) → o3 = true) ∧ (o3 = true → n = (0 : BitVec 32)) → (if ¬o3 = true then (C.min up ≤ C.offset up ∧ C.offset up < C.max up) ∧ (C.min up ≤ C.offset up + (1 : ℤ) ∧ C.offset up + (1 : ℤ) ≤ C.max up) ∧ (∀(o4 : C.ptr (BitVec 64)), C.offset o4 = C.offset up + (1 : ℤ) ∧ C.plength o4 = C.plength up ∧ C.pelts o4 = C.pelts up ∧ C.data o4 = C.data up ∧ C.min o4 = C.min up ∧ C.max o4 = C.max up ∧ C.zone1 o4 = C.zone1 up ∧ C.writable o4 = C.writable up → (∀(l : BitVec 64) (h : BitVec 64), BitVec.toUInt l + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt h = BitVec.toUInt (C.pelts up (C.offset up)) * BitVec.toUInt y → (∀(lpl : BitVec 64), BitVec.toUInt lpl = (BitVec.toUInt l + BitVec.toUInt cl) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (∀(o5 : BitVec 64), (if BitVec.toUInt lpl < BitVec.toUInt cl then o5 = (1 : BitVec 64) else o5 = (0 : BitVec 64)) → uint'64_in_bounds (BitVec.toUInt o5 + BitVec.toUInt h) ∧ (∀(o6 : BitVec 64), BitVec.toUInt o6 = BitVec.toUInt o5 + BitVec.toUInt h → BitVec.toUInt lpl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt o6 = BitVec.toUInt (C.pelts up (C.offset up)) * BitVec.toUInt y + BitVec.toUInt cl)) ∧ (∀(cl1 : BitVec 64), BitVec.toUInt lpl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt cl1 = BitVec.toUInt (C.pelts up (C.offset up)) * BitVec.toUInt y + BitVec.toUInt cl → ((C.min rp ≤ C.offset rp ∧ C.offset rp < C.max rp) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)) (r2 : C.ptr (BitVec 64)), C.data rp1 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → C.data rp1 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → List.length (C.data r2) = List.length (C.data r1) ∧ C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.max r2 = C.max r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → C.pelts rp1 = Function.update (C.pelts rp) (C.offset rp1) lpl → (C.min rp1 ≤ C.offset rp1 + (1 : ℤ) ∧ C.offset rp1 + (1 : ℤ) ≤ C.max rp1) ∧ (∀(o5 : C.ptr (BitVec 64)), C.offset o5 = C.offset rp1 + (1 : ℤ) ∧ C.plength o5 = C.plength rp1 ∧ C.pelts o5 = C.pelts rp1 ∧ C.data o5 = C.data rp1 ∧ C.min o5 = C.min rp1 ∧ C.max o5 = C.max rp1 ∧ C.zone1 o5 = C.zone1 rp1 ∧ C.writable o5 = C.writable rp1 → int'32_in_bounds (BitVec.toInt n - (1 : ℤ)) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt n - (1 : ℤ) → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt i + (1 : ℤ) → BitVec.toInt o6 < BitVec.toInt n ∧ ((0 : ℤ) ≤ BitVec.toInt o6 ∧ BitVec.toInt o6 ≤ BitVec.toInt sz) ∧ BitVec.toInt o7 = BitVec.toInt sz - BitVec.toInt o6 ∧ Lemmas.value r2 (BitVec.toInt o7) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o7)) * BitVec.toUInt cl1 = Lemmas.value x (BitVec.toInt o7) * BitVec.toUInt y ∧ C.offset o5 = C.offset r2 + BitVec.toInt o7 ∧ C.plength o5 = C.plength r2 ∧ C.min o5 = C.min r2 ∧ C.max o5 = C.max r2 ∧ C.writable o5 = true ∧ C.pelts o5 = C.pelts r2 ∧ C.offset o4 = C.offset x + BitVec.toInt o7 ∧ C.plength o4 = C.plength x ∧ C.min o4 = C.min x ∧ C.max o4 = C.max x ∧ C.pelts o4 = C.pelts x ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sz ≤ j → C.pelts r2 j = C.pelts r j))))))))) else Lemmas.value r1 (BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz)) * BitVec.toUInt cl = Lemmas.value x (BitVec.toInt sz) * BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sz ≤ j → C.pelts r1 j = C.pelts r j))))))
  := sorry
end mul_Mul_wmpn_mul_1qtvc
