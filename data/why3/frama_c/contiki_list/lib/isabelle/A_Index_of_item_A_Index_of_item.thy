theory A_Index_of_item_A_Index_of_item
  imports "NTP4Verif.NTP4Verif" "Why3STD.Qed_Qed" "Why3STD.Memory_Memory" "../../lib/isabelle/Compound_Compound" "../../lib/isabelle/S1_list_S1_list"
begin
consts l_index_of :: "(addr \<Rightarrow> addr) \<Rightarrow> addr \<Rightarrow> addr \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int"
axiomatization where Q_no_more_elements:   "l_index_of mptr_0 item_0 array_0 down_0 up_0 = up_0"
 if "up_0 \<le> down_0"
 and "(0 :: int) \<le> up_0"
  for up_0 :: "int"
  and down_0 :: "int"
  and mptr_0 :: "addr \<Rightarrow> addr"
  and item_0 :: "addr"
  and array_0 :: "addr"
axiomatization where Q_found_item:   "l_index_of mptr_0 item_0 array_0 down_0 up_0 = down_0"
 if "mptr_0 (shift array_0 down_0) = item_0"
 and "(0 :: int) \<le> down_0"
 and "down_0 < up_0"
  for mptr_0 :: "addr \<Rightarrow> addr"
  and array_0 :: "addr"
  and down_0 :: "int"
  and item_0 :: "addr"
  and up_0 :: "int"
axiomatization where Q_not_the_item:   "l_index_of mptr_0 item_0 array_0 ((1 :: int) + down_0) up_0 = l_index_of mptr_0 item_0 array_0 down_0 up_0"
 if "\<not>mptr_0 (shift array_0 down_0) = item_0"
 and "(0 :: int) \<le> down_0"
 and "down_0 < up_0"
  for mptr_0 :: "addr \<Rightarrow> addr"
  and array_0 :: "addr"
  and down_0 :: "int"
  and item_0 :: "addr"
  and up_0 :: "int"
end
