theory mpz_getset_Set_wmpz_set_siqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "../../lib/isabelle/lemmas_Lemmas" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/mpz_Z" "../../lib/isabelle/mpz_Zutil"
begin
theorem wmpz_set_si'vc:
  fixes mpz :: "mpz_memo"
  fixes dst :: "mpz_ptr"
  fixes src :: "64 word"
  assumes fact0: "(1 :: int) \<le> alloc mpz dst"
  assumes fact1: "readers mpz dst = (0 :: int)"
  shows "readers mpz dst = (0 :: int)"
  and "(1 :: int) \<le> alloc mpz dst"
  and "\<forall>(mpz1 :: mpz_memo). sgn mpz1 = sgn mpz \<longrightarrow> (\<forall>(dstp :: 64 word ptr). (\<forall>(y :: mpz_ptr). \<not>y = dst \<longrightarrow> mpz_unchanged y mpz1 mpz) \<and> readers mpz1 dst = -(1 :: int) \<and> abs_value_of mpz1 dst = value dstp (abs_size mpz1 dst) \<and> zones mpz1 dst = zone1 dstp \<and> offset dstp = (0 :: int) \<and> plength dstp = alloc mpz1 dst \<and> c_C.min dstp = (0 :: int) \<and> c_C.max dstp = plength dstp \<and> writable dstp = True \<and> abs_size mpz1 dst = abs_size mpz dst \<and> value dstp (abs_size mpz dst) = abs_value_of mpz dst \<and> (if alloc mpz dst < (1 :: int) then alloc mpz1 dst = (1 :: int) else alloc mpz1 dst = alloc mpz dst) \<longrightarrow> (\<forall>(abs_src :: 64 word). uint abs_src = abs (sint src) \<longrightarrow> ((c_C.min dstp \<le> offset dstp \<and> offset dstp < c_C.max dstp) \<and> writable dstp = True) \<and> (\<forall>(dstp1 :: 64 word ptr). length (data dstp1) = length (data dstp) \<and> offset dstp1 = offset dstp \<and> c_C.min dstp1 = c_C.min dstp \<and> c_C.max dstp1 = c_C.max dstp \<and> writable dstp1 = writable dstp \<and> zone1 dstp1 = zone1 dstp \<longrightarrow> pelts dstp1 = (pelts dstp)(offset dstp1 := abs_src) \<longrightarrow> (uint abs_src = (0 :: int) \<longrightarrow> abs_src = (0 :: 64 word)) \<longrightarrow> (\<forall>(size :: 32 word). (if \<not>abs_src = (0 :: 64 word) then size = (1 :: 32 word) else size = (0 :: 32 word)) \<longrightarrow> (\<not>(0 :: int) \<le> sint src \<longrightarrow> int'32_in_bounds (-sint size)) \<and> (\<forall>(size1 :: 32 word). (if (0 :: int) \<le> sint src then size1 = size else sint size1 = -sint size) \<longrightarrow> (zones mpz1 dst = zone1 dstp1 \<and> readers mpz1 dst = -(1 :: int) \<and> offset dstp1 = (0 :: int) \<and> c_C.min dstp1 = (0 :: int) \<and> c_C.max dstp1 = plength dstp1 \<and> abs (sint size1) \<le> plength dstp1 \<and> plength dstp1 = alloc mpz1 dst \<and> (\<not>sint size1 = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint size1) - (1 :: int)) \<le> value dstp1 (abs (sint size1)))) \<and> (\<forall>(mpz2 :: mpz_memo). alloc mpz2 = alloc mpz1 \<and> readers mpz2 = readers mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = dst \<longrightarrow> mpz_unchanged y mpz2 mpz1) \<and> (sgn mpz2 dst = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint size1) \<and> (sgn mpz2 dst = -(1 :: int) \<longleftrightarrow> sint size1 < (0 :: int)) \<and> abs_size mpz2 dst = abs (sint size1) \<and> abs_value_of mpz2 dst = value dstp1 (abs (sint size1)) \<longrightarrow> (zones mpz2 dst = zone1 dstp1 \<and> readers mpz2 dst = -(1 :: int) \<and> c_C.min dstp1 = (0 :: int) \<and> c_C.max dstp1 = plength dstp1 \<and> abs_value_of mpz2 dst = value dstp1 (abs_size mpz2 dst)) \<and> (\<forall>(mpz3 :: mpz_memo). abs_value_of mpz3 = abs_value_of mpz2 \<and> alloc mpz3 = alloc mpz2 \<and> abs_size mpz3 = abs_size mpz2 \<and> sgn mpz3 = sgn mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> readers mpz3 dst = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = dst \<longrightarrow> readers mpz3 y = readers mpz2 y) \<longrightarrow> value_of dst mpz3 = sint src \<and> (\<forall>(x :: mpz_ptr). \<not>x = dst \<longrightarrow> mpz_unchanged x mpz3 mpz) \<and> readers mpz3 dst = (0 :: int))))))))"
  sorry
end
