theory Cbits_Cbits
  imports "NTP4Verif.NTP4Verif" Cint_Cint
begin
consts bit_testb :: "int \<Rightarrow> int \<Rightarrow> bool"
consts bit_test :: "int \<Rightarrow> int \<Rightarrow> bool"
consts lnot :: "int \<Rightarrow> int"
consts land :: "int \<Rightarrow> int \<Rightarrow> int"
consts lxor :: "int \<Rightarrow> int \<Rightarrow> int"
consts lor :: "int \<Rightarrow> int \<Rightarrow> int"
consts lsl :: "int \<Rightarrow> int \<Rightarrow> int"
consts lsr :: "int \<Rightarrow> int \<Rightarrow> int"
axiomatization where lnot_bool'0:   "lnot (0 :: int) = -(1 :: int)"
axiomatization where lnot_bool'1:   "lnot (-(1 :: int)) = (0 :: int)"
axiomatization where land_idemp:   "land x x = x"
  for x :: "int"
axiomatization where land_idemp_bis:   "land x (land x y) = land x y"
  for x :: "int"
  and y :: "int"
axiomatization where land_0:   "land (0 :: int) x = (0 :: int)"
  for x :: "int"
axiomatization where land_0bis:   "land x (0 :: int) = (0 :: int)"
  for x :: "int"
axiomatization where land_1:   "land (-(1 :: int)) x = x"
  for x :: "int"
axiomatization where land_1bis:   "land x (-(1 :: int)) = x"
  for x :: "int"
axiomatization where land_bool'0:   "land (0 :: int) (0 :: int) = (0 :: int)"
axiomatization where land_bool'1:   "land (0 :: int) (1 :: int) = (0 :: int)"
axiomatization where land_bool'2:   "land (1 :: int) (0 :: int) = (0 :: int)"
axiomatization where land_bool'3:   "land (1 :: int) (1 :: int) = (1 :: int)"
axiomatization where lor_idemp:   "lor x x = x"
  for x :: "int"
axiomatization where lor_idemp_bis:   "lor x (lor x y) = lor x y"
  for x :: "int"
  and y :: "int"
axiomatization where lor_1:   "lor (-(1 :: int)) x = -(1 :: int)"
  for x :: "int"
axiomatization where lor_1bis:   "lor x (-(1 :: int)) = -(1 :: int)"
  for x :: "int"
axiomatization where lor_0:   "lor (0 :: int) x = x"
  for x :: "int"
axiomatization where lor_0bis:   "lor x (0 :: int) = x"
  for x :: "int"
axiomatization where lor_bool'0:   "lor (0 :: int) (0 :: int) = (0 :: int)"
axiomatization where lor_bool'1:   "lor (0 :: int) (1 :: int) = (1 :: int)"
axiomatization where lor_bool'2:   "lor (1 :: int) (0 :: int) = (1 :: int)"
axiomatization where lor_bool'3:   "lor (1 :: int) (1 :: int) = (1 :: int)"
axiomatization where lxor_nilpotent:   "lxor x x = (0 :: int)"
  for x :: "int"
axiomatization where lxor_nilpotent_bis:   "lxor x (lxor x y) = y"
  for x :: "int"
  and y :: "int"
axiomatization where lxor_1:   "lxor (-(1 :: int)) x = lnot x"
  for x :: "int"
axiomatization where lxor_1bis:   "lxor x (-(1 :: int)) = lnot x"
  for x :: "int"
axiomatization where lxor_0:   "lxor (0 :: int) x = x"
  for x :: "int"
axiomatization where lxor_0bis:   "lxor x (0 :: int) = x"
  for x :: "int"
axiomatization where lxor_bool'0:   "lxor (0 :: int) (0 :: int) = (0 :: int)"
axiomatization where lxor_bool'1:   "lxor (0 :: int) (1 :: int) = (1 :: int)"
axiomatization where lxor_bool'2:   "lxor (1 :: int) (0 :: int) = (1 :: int)"
axiomatization where lxor_bool'3:   "lxor (1 :: int) (1 :: int) = (0 :: int)"
axiomatization where lsl_0:   "lsl x (0 :: int) = x"
  for x :: "int"
axiomatization where lsl_1:   "lsl x (1 :: int) = (2 :: int) * x"
  for x :: "int"
axiomatization where lsl_add:   "lsl (lsl x p) q = lsl x (p + q)"
 if "(0 :: int) \<le> p"
 and "(0 :: int) \<le> q"
  for p :: "int"
  and q :: "int"
  and x :: "int"
axiomatization where lsr_0:   "lsr x (0 :: int) = x"
  for x :: "int"
axiomatization where lsr_1:   "lsr x (1 :: int) = x cdiv (2 :: int)"
 if "(0 :: int) \<le> x"
  for x :: "int"
axiomatization where lsr_add:   "lsr (lsr x p) q = lsr x (p + q)"
 if "(0 :: int) \<le> p"
 and "(0 :: int) \<le> q"
  for p :: "int"
  and q :: "int"
  and x :: "int"
axiomatization where lsl_lsr_add:   "lsr (lsl x p) q = lsl x (p - q)"
 if "(0 :: int) \<le> q"
 and "q \<le> p"
  for q :: "int"
  and p :: "int"
  and x :: "int"
axiomatization where bit_test_def:   "bit_testb x k = True \<longleftrightarrow> bit_test x k"
  for x :: "int"
  and k :: "int"
axiomatization where bit_test_extraction:   "\<not>land x (lsl (1 :: int) k) = (0 :: int) \<longleftrightarrow> bit_test x k"
 if "(0 :: int) \<le> k"
  for k :: "int"
  and x :: "int"
axiomatization where bit_test_extraction_eq:   "land x (lsl (1 :: int) k) = lsl (1 :: int) k \<longleftrightarrow> bit_test x k"
 if "(0 :: int) \<le> k"
  for k :: "int"
  and x :: "int"
axiomatization where lsl_1_0:   "lsl (1 :: int) (0 :: int) = (1 :: int)"
axiomatization where bit_test_extraction_bis:   "bit_test x (0 :: int)"
 if "\<not>land (1 :: int) x = (0 :: int)"
  for x :: "int"
axiomatization where bit_test_extraction_bis_eq:   "land (1 :: int) x = (1 :: int)"
 if "bit_test x (0 :: int)"
  for x :: "int"
axiomatization where lnot_extraction_bool:   "bit_testb (lnot x) i = (\<not>bit_testb x i)"
 if "(0 :: int) \<le> i"
  for i :: "int"
  and x :: "int"
axiomatization where lnot_extraction:   "bit_test (lnot x) i \<longleftrightarrow> \<not>bit_test x i"
 if "(0 :: int) \<le> i"
  for i :: "int"
  and x :: "int"
axiomatization where land_extraction_bool:   "bit_testb (land x y) i = (bit_testb x i \<and> bit_testb y i)"
 if "(0 :: int) \<le> i"
  for i :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where land_extraction:   "bit_test (land x y) i \<longleftrightarrow> bit_test x i \<and> bit_test y i"
 if "(0 :: int) \<le> i"
  for i :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where lor_extraction_bool:   "bit_testb (lor x y) i = (bit_testb x i \<or> bit_testb y i)"
 if "(0 :: int) \<le> i"
  for i :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where lor_extraction:   "bit_test (lor x y) i \<longleftrightarrow> bit_test x i \<or> bit_test y i"
 if "(0 :: int) \<le> i"
  for i :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where lxor_extraction_bool:   "bit_testb (lxor x y) i = (bit_testb x i \<noteq> bit_testb y i)"
 if "(0 :: int) \<le> i"
  for i :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where lxor_extraction:   "bit_test (lxor x y) i \<longleftrightarrow> bit_test x i \<longleftrightarrow> \<not>bit_test y i"
 if "(0 :: int) \<le> i"
  for i :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where lsl_1_two_power:   "lsl (1 :: int) n = two_power_abs n"
 if "(0 :: int) \<le> n"
  for n :: "int"
axiomatization where land_1_lsl_1:   "(2 :: int) * a + land (1 :: int) x < lsl (1 :: int) ((1 :: int) + n)"
 if "(0 :: int) \<le> n"
 and "a < lsl (1 :: int) n"
  for n :: "int"
  and a :: "int"
  and x :: "int"
axiomatization where lsl_extraction_sup_bool:   "bit_testb (lsl x n) m = bit_testb x (m - n)"
 if "(0 :: int) \<le> n"
 and "(0 :: int) \<le> m"
 and "n \<le> m"
  for n :: "int"
  and m :: "int"
  and x :: "int"
axiomatization where lsl_extraction_sup:   "bit_test (lsl x n) m \<longleftrightarrow> bit_test x (m - n)"
 if "(0 :: int) \<le> n"
 and "(0 :: int) \<le> m"
 and "n \<le> m"
  for n :: "int"
  and m :: "int"
  and x :: "int"
axiomatization where lsl_extraction_inf_bool:   "bit_testb (lsl x n) m = False"
 if "(0 :: int) \<le> n"
 and "(0 :: int) \<le> m"
 and "m < n"
  for n :: "int"
  and m :: "int"
  and x :: "int"
axiomatization where lsl_extraction_inf:   "\<not>bit_test (lsl x n) m"
 if "(0 :: int) \<le> n"
 and "(0 :: int) \<le> m"
 and "m < n"
  for n :: "int"
  and m :: "int"
  and x :: "int"
axiomatization where lsr_extraction_bool:   "bit_testb (lsr x n) m = bit_testb x (m + n)"
 if "(0 :: int) \<le> n"
 and "(0 :: int) \<le> m"
  for n :: "int"
  and m :: "int"
  and x :: "int"
axiomatization where lsr_extractionl:   "bit_test (lsr x n) m \<longleftrightarrow> bit_test x (m + n)"
 if "(0 :: int) \<le> n"
 and "(0 :: int) \<le> m"
  for n :: "int"
  and m :: "int"
  and x :: "int"
axiomatization where lsl1_extraction_bool:   "bit_testb (lsl (1 :: int) i) j = (if i = j then True else False)"
 if "(0 :: int) \<le> i"
 and "(0 :: int) \<le> j"
  for i :: "int"
  and j :: "int"
axiomatization where lsl1_extraction:   "bit_test (lsl (1 :: int) i) j \<longleftrightarrow> i = j"
 if "(0 :: int) \<le> i"
 and "(0 :: int) \<le> j"
  for i :: "int"
  and j :: "int"
axiomatization where pos_extraction_sup:   "\<not>bit_test x j"
 if "(0 :: int) \<le> x"
 and "(0 :: int) \<le> i"
 and "x < lsl (1 :: int) i"
 and "i \<le> j"
  for x :: "int"
  and i :: "int"
  and j :: "int"
axiomatization where pos_extraction_sup_inv'0:   "(0 :: int) \<le> x"
 if "(0 :: int) \<le> i"
 and "\<forall>(j :: int). i \<le> j \<longrightarrow> \<not>bit_test x j"
  for i :: "int"
  and x :: "int"
axiomatization where pos_extraction_sup_inv'1:   "x < lsl (1 :: int) i"
 if "(0 :: int) \<le> i"
 and "\<forall>(j :: int). i \<le> j \<longrightarrow> \<not>bit_test x j"
  for i :: "int"
  and x :: "int"
axiomatization where to_uint_extraction_sup:   "\<not>bit_test x i"
 if "(0 :: int) \<le> n"
 and "n \<le> i"
 and "is_uint n x"
  for n :: "int"
  and i :: "int"
  and x :: "int"
axiomatization where to_uint_extraction_inf_bool:   "bit_testb (to_uint n x) i = bit_testb x i"
 if "(0 :: int) \<le> i"
 and "i < n"
  for i :: "int"
  and n :: "int"
  and x :: "int"
axiomatization where to_uint_extraction_inf:   "bit_test (to_uint n x) i \<longleftrightarrow> bit_test x i"
 if "(0 :: int) \<le> i"
 and "i < n"
  for i :: "int"
  and n :: "int"
  and x :: "int"
axiomatization where is_uint_ext:   "x = y"
 if "(0 :: int) \<le> n"
 and "is_uint n x"
 and "is_uint n y"
 and "\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> bit_test x i \<longleftrightarrow> bit_test y i"
  for n :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where to_uint8_extraction_sup:   "\<not>bit_test x i"
 if "(8 :: int) \<le> i"
 and "is_uint8 x"
  for i :: "int"
  and x :: "int"
axiomatization where to_uint8_extraction_inf_bool:   "bit_testb (to_uint8 x) i = bit_testb x i"
 if "(0 :: int) \<le> i"
 and "i < (8 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where to_uint8_extraction_inf:   "bit_test (to_uint8 x) i \<longleftrightarrow> bit_test x i"
 if "(0 :: int) \<le> i"
 and "i < (8 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where is_uint8_ext:   "x = y"
 if "is_uint8 x"
 and "is_uint8 y"
 and "\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (8 :: int) \<longrightarrow> bit_test x i \<longleftrightarrow> bit_test y i"
  for x :: "int"
  and y :: "int"
axiomatization where to_uint16_extraction_sup:   "\<not>bit_test x i"
 if "(16 :: int) \<le> i"
 and "is_uint16 x"
  for i :: "int"
  and x :: "int"
axiomatization where to_uint16_extraction_inf_bool:   "bit_testb (to_uint16 x) i = bit_testb x i"
 if "(0 :: int) \<le> i"
 and "i < (16 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where to_uint16_extraction_inf:   "bit_test (to_uint16 x) i \<longleftrightarrow> bit_test x i"
 if "(0 :: int) \<le> i"
 and "i < (16 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where is_uint16_ext:   "x = y"
 if "is_uint16 x"
 and "is_uint16 y"
 and "\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (16 :: int) \<longrightarrow> bit_test x i \<longleftrightarrow> bit_test y i"
  for x :: "int"
  and y :: "int"
axiomatization where to_uint32_extraction_sup:   "\<not>bit_test x i"
 if "(32 :: int) \<le> i"
 and "is_uint32 x"
  for i :: "int"
  and x :: "int"
axiomatization where to_uint32_extraction_inf_bool:   "bit_testb (to_uint32 x) i = bit_testb x i"
 if "(0 :: int) \<le> i"
 and "i < (32 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where to_uint32_extraction_inf:   "bit_test (to_uint32 x) i \<longleftrightarrow> bit_test x i"
 if "(0 :: int) \<le> i"
 and "i < (32 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where is_uint32_ext:   "x = y"
 if "is_uint32 x"
 and "is_uint32 y"
 and "\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (32 :: int) \<longrightarrow> bit_test x i \<longleftrightarrow> bit_test y i"
  for x :: "int"
  and y :: "int"
axiomatization where to_uint64_extraction_sup:   "\<not>bit_test x i"
 if "(64 :: int) \<le> i"
 and "is_uint64 x"
  for i :: "int"
  and x :: "int"
axiomatization where to_uint64_extraction_inf_bool:   "bit_testb (to_uint64 x) i = bit_testb x i"
 if "(0 :: int) \<le> i"
 and "i < (64 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where to_uint64_extraction_inf:   "bit_test (to_uint64 x) i \<longleftrightarrow> bit_test x i"
 if "(0 :: int) \<le> i"
 and "i < (64 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where is_uint64_ext:   "x = y"
 if "is_uint64 x"
 and "is_uint64 y"
 and "\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (64 :: int) \<longrightarrow> bit_test x i \<longleftrightarrow> bit_test y i"
  for x :: "int"
  and y :: "int"
axiomatization where to_sint_extraction_sup:   "bit_test x i \<longleftrightarrow> x < (0 :: int)"
 if "(0 :: int) \<le> n"
 and "n \<le> i"
 and "is_sint n x"
  for n :: "int"
  and i :: "int"
  and x :: "int"
axiomatization where to_sint_extraction_inf_bool:   "bit_testb (to_sint n x) i = bit_testb x i"
 if "(0 :: int) \<le> i"
 and "i < n"
  for i :: "int"
  and n :: "int"
  and x :: "int"
axiomatization where to_sint_extraction_inf:   "bit_test (to_sint n x) i \<longleftrightarrow> bit_test x i"
 if "(0 :: int) \<le> i"
 and "i < n"
  for i :: "int"
  and n :: "int"
  and x :: "int"
axiomatization where is_sint_ext:   "x = y"
 if "(0 :: int) \<le> n"
 and "is_sint n x"
 and "is_sint n y"
 and "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> n \<longrightarrow> bit_test x i \<longleftrightarrow> bit_test y i"
  for n :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where to_sint8_extraction_sup:   "bit_test x i \<longleftrightarrow> x < (0 :: int)"
 if "(7 :: int) \<le> i"
 and "is_sint8 x"
  for i :: "int"
  and x :: "int"
axiomatization where to_sint8_extraction_inf_bool:   "bit_testb (to_sint8 x) i = bit_testb x i"
 if "(0 :: int) \<le> i"
 and "i < (7 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where to_sint8_extraction_inf:   "bit_test (to_sint8 x) i \<longleftrightarrow> bit_test x i"
 if "(0 :: int) \<le> i"
 and "i < (7 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where is_sint8_ext:   "x = y"
 if "is_sint8 x"
 and "is_sint8 y"
 and "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (7 :: int) \<longrightarrow> bit_test x i \<longleftrightarrow> bit_test y i"
  for x :: "int"
  and y :: "int"
axiomatization where to_sint16_extraction_sup:   "bit_test x i \<longleftrightarrow> x < (0 :: int)"
 if "(15 :: int) \<le> i"
 and "is_sint16 x"
  for i :: "int"
  and x :: "int"
axiomatization where to_sint16_extraction_inf_bool:   "bit_testb (to_sint16 x) i = bit_testb x i"
 if "(0 :: int) \<le> i"
 and "i < (15 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where to_sint16_extraction_inf:   "bit_test (to_sint16 x) i \<longleftrightarrow> bit_test x i"
 if "(0 :: int) \<le> i"
 and "i < (15 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where is_sint16_ext:   "x = y"
 if "is_sint16 x"
 and "is_sint16 y"
 and "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (15 :: int) \<longrightarrow> bit_test x i \<longleftrightarrow> bit_test y i"
  for x :: "int"
  and y :: "int"
axiomatization where to_sint32_extraction_sup:   "bit_test x i \<longleftrightarrow> x < (0 :: int)"
 if "(31 :: int) \<le> i"
 and "is_sint32 x"
  for i :: "int"
  and x :: "int"
axiomatization where to_sint32_extraction_inf_bool:   "bit_testb (to_sint32 x) i = bit_testb x i"
 if "(0 :: int) \<le> i"
 and "i < (31 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where to_sint32_extraction_inf:   "bit_test (to_sint32 x) i \<longleftrightarrow> bit_test x i"
 if "(0 :: int) \<le> i"
 and "i < (31 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where is_sint32_ext:   "x = y"
 if "is_sint32 x"
 and "is_sint32 y"
 and "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (31 :: int) \<longrightarrow> bit_test x i \<longleftrightarrow> bit_test y i"
  for x :: "int"
  and y :: "int"
axiomatization where to_sint64_extraction_sup:   "bit_test x i \<longleftrightarrow> x < (0 :: int)"
 if "(63 :: int) \<le> i"
 and "is_sint64 x"
  for i :: "int"
  and x :: "int"
axiomatization where to_sint64_extraction_inf_bool:   "bit_testb (to_sint64 x) i = bit_testb x i"
 if "(0 :: int) \<le> i"
 and "i < (63 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where to_sint64_extraction_inf:   "bit_test (to_sint64 x) i \<longleftrightarrow> bit_test x i"
 if "(0 :: int) \<le> i"
 and "i < (63 :: int)"
  for i :: "int"
  and x :: "int"
axiomatization where is_sint64_ext:   "x = y"
 if "is_sint64 x"
 and "is_sint64 y"
 and "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (63 :: int) \<longrightarrow> bit_test x i \<longleftrightarrow> bit_test y i"
  for x :: "int"
  and y :: "int"
axiomatization where to_uint_lor:   "to_uint n (lor x y) = lor (to_uint n x) (to_uint n y)"
  for n :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where to_uint8_lor:   "to_uint8 (lor x y) = lor (to_uint8 x) (to_uint (8 :: int) y)"
  for x :: "int"
  and y :: "int"
axiomatization where to_uint16_lor:   "to_uint16 (lor x y) = lor (to_uint16 x) (to_uint16 y)"
  for x :: "int"
  and y :: "int"
axiomatization where to_uint32_lor:   "to_uint32 (lor x y) = lor (to_uint32 x) (to_uint32 y)"
  for x :: "int"
  and y :: "int"
axiomatization where to_uint64_lor:   "to_uint64 (lor x y) = lor (to_uint64 x) (to_uint64 y)"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint_lxor:   "to_uint n (lxor x y) = lxor x y"
 if "is_uint n x"
 and "is_uint n y"
  for n :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where is_uint_lor:   "to_uint n (lor x y) = lor x y"
 if "is_uint n x"
 and "is_uint n y"
  for n :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where is_uint_land:   "to_uint n (land x y) = land x y"
 if "is_uint n x"
 and "is_uint n y"
  for n :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where is_uint_lsr:   "to_uint n (lsr x y) = lsr x y"
 if "(0 :: int) \<le> y"
 and "is_uint n x"
  for y :: "int"
  and n :: "int"
  and x :: "int"
axiomatization where is_uint_lsl1_inf:   "to_uint n (lsl (1 :: int) y) = lsl (1 :: int) y"
 if "(0 :: int) \<le> y"
 and "y < n"
  for y :: "int"
  and n :: "int"
axiomatization where is_uint_lsl1_sup:   "to_uint n (lsl (1 :: int) y) = (0 :: int)"
 if "(0 :: int) \<le> n"
 and "n \<le> y"
  for n :: "int"
  and y :: "int"
axiomatization where is_uint8_lxor:   "to_uint8 (lxor x y) = lxor x y"
 if "is_uint8 x"
 and "is_uint8 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint8_lor:   "to_uint8 (lor x y) = lor x y"
 if "is_uint8 x"
 and "is_uint8 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint8_land:   "to_uint8 (land x y) = land x y"
 if "is_uint8 x"
 and "is_uint8 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint8_lsr:   "to_uint8 (lsr x y) = lsr x y"
 if "(0 :: int) \<le> y"
 and "is_uint8 x"
  for y :: "int"
  and x :: "int"
axiomatization where is_uint8_lsl1_inf:   "to_uint8 (lsl (1 :: int) y) = lsl (1 :: int) y"
 if "(0 :: int) \<le> y"
 and "y < (8 :: int)"
  for y :: "int"
axiomatization where is_uint8_lsl1_sup:   "to_uint8 (lsl (1 :: int) y) = (0 :: int)"
 if "(8 :: int) \<le> y"
  for y :: "int"
axiomatization where is_uint16_lxor:   "to_uint16 (lxor x y) = lxor x y"
 if "is_uint16 x"
 and "is_uint16 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint16_lor:   "to_uint16 (lor x y) = lor x y"
 if "is_uint16 x"
 and "is_uint16 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint16_land:   "to_uint16 (land x y) = land x y"
 if "is_uint16 x"
 and "is_uint16 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint16_lsr:   "to_uint16 (lsr x y) = lsr x y"
 if "(0 :: int) \<le> y"
 and "is_uint16 x"
  for y :: "int"
  and x :: "int"
axiomatization where is_uint16_lsl1_inf:   "to_uint16 (lsl (1 :: int) y) = lsl (1 :: int) y"
 if "(0 :: int) \<le> y"
 and "y < (16 :: int)"
  for y :: "int"
axiomatization where is_uint16_lsl1_sup:   "to_uint16 (lsl (1 :: int) y) = (0 :: int)"
 if "(16 :: int) \<le> y"
  for y :: "int"
axiomatization where is_uint32_lxor:   "to_uint32 (lxor x y) = lxor x y"
 if "is_uint32 x"
 and "is_uint32 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint32_lor:   "to_uint32 (lor x y) = lor x y"
 if "is_uint32 x"
 and "is_uint32 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint32_land:   "to_uint32 (land x y) = land x y"
 if "is_uint32 x"
 and "is_uint32 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint32_lsr:   "to_uint32 (lsr x y) = lsr x y"
 if "(0 :: int) \<le> y"
 and "is_uint32 x"
  for y :: "int"
  and x :: "int"
axiomatization where is_uint32_lsl1_inf:   "to_uint32 (lsl (1 :: int) y) = lsl (1 :: int) y"
 if "(0 :: int) \<le> y"
 and "y < (32 :: int)"
  for y :: "int"
axiomatization where is_uint32_lsl1_sup:   "to_uint32 (lsl (1 :: int) y) = (0 :: int)"
 if "(32 :: int) \<le> y"
  for y :: "int"
axiomatization where is_uint64_lxor:   "to_uint64 (lxor x y) = lxor x y"
 if "is_uint64 x"
 and "is_uint64 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint64_lor:   "to_uint64 (lor x y) = lor x y"
 if "is_uint64 x"
 and "is_uint64 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint64_land:   "to_uint64 (land x y) = land x y"
 if "is_uint64 x"
 and "is_uint64 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint64_lsr:   "to_uint64 (lsr x y) = lsr x y"
 if "(0 :: int) \<le> y"
 and "is_uint64 x"
  for y :: "int"
  and x :: "int"
axiomatization where is_uint64_lsl1_inf:   "to_uint64 (lsl (1 :: int) y) = lsl (1 :: int) y"
 if "(0 :: int) \<le> y"
 and "y < (64 :: int)"
  for y :: "int"
axiomatization where is_uint64_lsl1_sup:   "to_uint64 (lsl (1 :: int) y) = (0 :: int)"
 if "(64 :: int) \<le> y"
  for y :: "int"
axiomatization where is_sint_lnot:   "to_sint n (lnot x) = lnot x"
 if "is_sint n x"
  for n :: "int"
  and x :: "int"
axiomatization where is_sint_lxor:   "to_sint n (lxor x y) = lxor x y"
 if "is_sint n x"
 and "is_sint n y"
  for n :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where is_sint_lor:   "to_sint n (lor x y) = lor x y"
 if "is_sint n x"
 and "is_sint n y"
  for n :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where is_sint_land:   "to_sint n (land x y) = land x y"
 if "is_sint n x"
 and "is_sint n y"
  for n :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where is_sint_lsr:   "to_sint n (lsr x y) = lsr x y"
 if "(0 :: int) \<le> y"
 and "is_sint n x"
  for y :: "int"
  and n :: "int"
  and x :: "int"
axiomatization where is_sint_lsl1_inf:   "to_sint n (lsl (1 :: int) y) = lsl (1 :: int) y"
 if "(0 :: int) \<le> y"
 and "y < n"
  for y :: "int"
  and n :: "int"
axiomatization where is_sint_lsl1_sup:   "to_sint n (lsl (1 :: int) y) = (0 :: int)"
 if "(0 :: int) \<le> n"
 and "n < y"
  for n :: "int"
  and y :: "int"
axiomatization where is_sint8_lnot:   "to_sint8 (lnot x) = lnot x"
 if "is_sint8 x"
  for x :: "int"
axiomatization where is_sint8_lxor:   "to_sint8 (lxor x y) = lxor x y"
 if "is_sint8 x"
 and "is_sint8 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_sint8_lor:   "to_sint8 (lor x y) = lor x y"
 if "is_sint8 x"
 and "is_sint8 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_sint8_land:   "to_sint8 (land x y) = land x y"
 if "is_sint8 x"
 and "is_sint8 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_sint8_lsr:   "to_sint8 (lsr x y) = lsr x y"
 if "(0 :: int) \<le> y"
 and "is_sint8 x"
  for y :: "int"
  and x :: "int"
axiomatization where is_sint8_lsl1:   "lsl (1 :: int) (7 :: int) = (128 :: int)"
axiomatization where is_sint8_lsl1_inf:   "to_sint8 (lsl (1 :: int) y) = lsl (1 :: int) y"
 if "(0 :: int) \<le> y"
 and "y < (7 :: int)"
  for y :: "int"
axiomatization where is_sint8_lsl1_sup:   "to_sint8 (lsl (1 :: int) y) = (0 :: int)"
 if "(8 :: int) \<le> y"
  for y :: "int"
axiomatization where is_sint16_lnot:   "to_sint16 (lnot x) = lnot x"
 if "is_sint16 x"
  for x :: "int"
axiomatization where is_sint16_lxor:   "to_sint16 (lxor x y) = lxor x y"
 if "is_sint16 x"
 and "is_sint16 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_sint16_lor:   "to_sint16 (lor x y) = lor x y"
 if "is_sint16 x"
 and "is_sint16 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_sint16_land:   "to_sint16 (land x y) = land x y"
 if "is_sint16 x"
 and "is_sint16 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_sint16_lsr:   "to_sint16 (lsr x y) = lsr x y"
 if "(0 :: int) \<le> y"
 and "is_sint16 x"
  for y :: "int"
  and x :: "int"
axiomatization where is_sint16_lsl1:   "lsl (1 :: int) (15 :: int) = (32768 :: int)"
axiomatization where is_sint16_lsl1_inf:   "to_sint16 (lsl (1 :: int) y) = lsl (1 :: int) y"
 if "(0 :: int) \<le> y"
 and "y < (15 :: int)"
  for y :: "int"
axiomatization where is_sint16_lsl1_sup:   "to_sint16 (lsl (1 :: int) y) = (0 :: int)"
 if "(16 :: int) \<le> y"
  for y :: "int"
axiomatization where is_sint32_lnot:   "to_sint32 (lnot x) = lnot x"
 if "is_sint32 x"
  for x :: "int"
axiomatization where is_sint32_lxor:   "to_sint32 (lxor x y) = lxor x y"
 if "is_sint32 x"
 and "is_sint32 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_sint32_lor:   "to_sint32 (lor x y) = lor x y"
 if "is_sint32 x"
 and "is_sint32 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_sint32_land:   "to_sint32 (land x y) = land x y"
 if "is_sint32 x"
 and "is_sint32 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_sint32_lsr:   "to_sint32 (lsr x y) = lsr x y"
 if "(0 :: int) \<le> y"
 and "is_sint32 x"
  for y :: "int"
  and x :: "int"
axiomatization where is_sint32_lsl1:   "lsl (1 :: int) (31 :: int) = (2147483648 :: int)"
axiomatization where is_sint32_lsl1_inf:   "to_sint32 (lsl (1 :: int) y) = lsl (1 :: int) y"
 if "(0 :: int) \<le> y"
 and "y < (31 :: int)"
  for y :: "int"
axiomatization where is_sint32_lsl1_sup:   "to_sint32 (lsl (1 :: int) y) = (0 :: int)"
 if "(32 :: int) \<le> y"
  for y :: "int"
axiomatization where is_sint64_lnot:   "to_sint64 (lnot x) = lnot x"
 if "is_sint64 x"
  for x :: "int"
axiomatization where is_sint64_lxor:   "to_sint64 (lxor x y) = lxor x y"
 if "is_sint64 x"
 and "is_sint64 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_sint64_lor:   "to_sint64 (lor x y) = lor x y"
 if "is_sint64 x"
 and "is_sint64 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_sint64_land:   "to_sint64 (land x y) = land x y"
 if "is_sint64 x"
 and "is_sint64 y"
  for x :: "int"
  and y :: "int"
axiomatization where is_sint64_lsr:   "to_sint64 (lsr x y) = lsr x y"
 if "(0 :: int) \<le> y"
 and "is_sint64 x"
  for y :: "int"
  and x :: "int"
axiomatization where is_sint64_lsl1:   "lsl (1 :: int) (63 :: int) = (9223372036854775808 :: int)"
axiomatization where is_sint64_lsl1_inf:   "to_sint64 (lsl (1 :: int) y) = lsl (1 :: int) y"
 if "(0 :: int) \<le> y"
 and "y < (63 :: int)"
  for y :: "int"
axiomatization where is_sint64_lsl1_sup:   "to_sint64 (lsl (1 :: int) y) = (0 :: int)"
 if "(64 :: int) \<le> y"
  for y :: "int"
axiomatization where uint_land_range'0:   "(0 :: int) \<le> land x y"
 if "(0 :: int) \<le> x"
  for x :: "int"
  and y :: "int"
axiomatization where uint_land_range'1:   "land x y \<le> x"
 if "(0 :: int) \<le> x"
  for x :: "int"
  and y :: "int"
axiomatization where uint_lor_inf:   "x \<le> lor x y"
 if "-(1 :: int) \<le> x"
 and "(0 :: int) \<le> y"
  for x :: "int"
  and y :: "int"
axiomatization where sint_land_inf:   "land x y \<le> x"
 if "x \<le> (0 :: int)"
 and "y < (0 :: int)"
  for x :: "int"
  and y :: "int"
axiomatization where sint_lor_range'0:   "x \<le> lor x y"
 if "x < (0 :: int)"
  for x :: "int"
  and y :: "int"
axiomatization where sint_lor_range'1:   "lor x y < (0 :: int)"
 if "x < (0 :: int)"
  for x :: "int"
  and y :: "int"
axiomatization where is_uint_lor_distrib:   "is_uint n (lor x y) \<longleftrightarrow> is_uint n x \<and> is_uint n y"
  for n :: "int"
  and x :: "int"
  and y :: "int"
axiomatization where lor_addition:   "x + y = lor x y"
 if "land x y = (0 :: int)"
  for x :: "int"
  and y :: "int"
axiomatization where lxor_addition:   "x + y = lxor x y"
 if "land x y = (0 :: int)"
  for x :: "int"
  and y :: "int"
axiomatization where to_uint_land_edge:   "to_uint n x = land (lsl (1 :: int) n - (1 :: int)) x"
 if "(0 :: int) \<le> n"
  for n :: "int"
  and x :: "int"
end
