theory euler_sieve_EulerSieveImpl_createqtvc
  imports "NTP4Verif.NTP4Verif" "./euler_sieve_ArithmeticResults" "./euler_sieve_DivisibilityResults" "./euler_sieve_EulerSieveSpec" "mach.array_ArrayInt63"
begin
typedecl  t
consts nexts :: "t \<Rightarrow> int list"
consts marked :: "t \<Rightarrow> bool list"
consts arr :: "t \<Rightarrow> array_ArrayInt63.array63"
consts max :: "t \<Rightarrow> 63 word"
consts max_arr :: "t \<Rightarrow> 63 word"
axiomatization where t'invariant'0:   "sint (max self) < sint int'63_max"
  for self :: "t"
axiomatization where t'invariant'1:   "(3 :: int) \<le> sint (max self)"
  for self :: "t"
axiomatization where t'invariant'2:   "length (nexts self) = length (marked self)"
  for self :: "t"
axiomatization where t'invariant'3:   "int (length (marked self)) = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'4:   "(sint (max self) - (1 :: int)) ediv (2 :: int) = sint (max_arr self)"
  for self :: "t"
axiomatization where t'invariant'5:   "int (length (elts (arr self))) = sint (max_arr self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'6:   "inv_nexts (nexts self) (int (length (nexts self)))"
  for self :: "t"
axiomatization where t'invariant'7:   "all_eliminated_marked (marked self) (nexts self)"
  for self :: "t"
axiomatization where t'invariant'8:   "\<forall>(i :: int). (3 :: int) \<le> i \<and> i \<le> sint (max self) \<longrightarrow> i emod (2 :: int) = (0 :: int) \<longrightarrow> marked self ! nat i = True"
  for self :: "t"
axiomatization where t'invariant'9:   "\<forall>(i :: int). (3 :: int) \<le> i \<and> i < sint (max self) - (1 :: int) \<longrightarrow> i emod (2 :: int) = (1 :: int) \<longrightarrow> nexts self ! nat i emod (2 :: int) = (1 :: int) \<or> nexts self ! nat i = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'10:   "nexts self ! nat (sint (max self)) = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'11:   "(sint (max self) - (1 :: int)) emod (2 :: int) = (0 :: int) \<longrightarrow> nexts self ! nat (sint (max self) - (1 :: int)) = sint (max self)"
  for self :: "t"
axiomatization where t'invariant'12:   "(sint (max self) - (1 :: int)) emod (2 :: int) = (1 :: int) \<longrightarrow> nexts self ! nat (sint (max self) - (1 :: int)) = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'13:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> -(sint (max self) + (1 :: int)) \<le> elts (arr self) ! nat i \<and> elts (arr self) ! nat i \<le> sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'14:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> marked self ! nat ((2 :: int) * i + (1 :: int)) = True \<longleftrightarrow> elts (arr self) ! nat i < (0 :: int)"
  for self :: "t"
axiomatization where t'invariant'15:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> \<not>marked self ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts (arr self) ! nat i = nexts self ! nat ((2 :: int) * i + (1 :: int))"
  for self :: "t"
axiomatization where t'invariant'16:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> marked self ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts (arr self) ! nat i = -nexts self ! nat ((2 :: int) * i + (1 :: int))"
  for self :: "t"
axiomatization where t'invariant'17:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> (i < abs (elts (arr self) ! nat i) ediv (2 :: int) \<and> abs (elts (arr self) ! nat i) ediv (2 :: int) \<le> sint (max_arr self) + (1 :: int)) \<and> abs (elts (arr self) ! nat i) \<le> sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'18:   "\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> i < j \<and> j < abs (elts (arr self) ! nat i) ediv (2 :: int) \<longrightarrow> elts (arr self) ! nat j < (0 :: int)"
  for self :: "t"
definition t'eq :: "t \<Rightarrow> t \<Rightarrow> _"
  where "t'eq a b \<longleftrightarrow> nexts a = nexts b \<and> marked a = marked b \<and> arr a = arr b \<and> max a = max b \<and> max_arr a = max_arr b" for a b
axiomatization where t'inj:   "a = b"
 if "t'eq a b"
  for a :: "t"
  and b :: "t"
consts fc :: "63 word \<Rightarrow> int \<Rightarrow> int"
consts o1 :: "int \<Rightarrow> bool"
consts fc1 :: "63 word \<Rightarrow> 63 word \<Rightarrow> int \<Rightarrow> int"
axiomatization where fc'def:   "fc max1 i = (if i = sint max1 then sint max1 + (1 :: int) else if i = sint max1 - (1 :: int) then if i emod (2 :: int) = (0 :: int) then sint max1 else sint max1 + (1 :: int) else if i < (3 :: int) \<or> i emod (2 :: int) = (0 :: int) then i + (1 :: int) else i + (2 :: int))"
  for max1 :: "63 word"
  and i :: "int"
axiomatization where o'def:   "o1 i = True \<longleftrightarrow> i = (0 :: int) \<or> i = (1 :: int) \<or> (2 :: int) < i \<and> i emod (2 :: int) = (0 :: int)"
  for i :: "int"
axiomatization where fc'def1:   "fc1 max1 len_arr i = (if i = sint len_arr - (1 :: int) then sint max1 + (1 :: int) else if i = (0 :: int) then -(2 :: int) else (2 :: int) * i + (3 :: int))"
  for max1 :: "63 word"
  and len_arr :: "63 word"
  and i :: "int"
theorem create'vc:
  fixes max1 :: "63 word"
  assumes fact0: "sint max1 < sint int'63_max"
  assumes fact1: "(3 :: int) \<le> sint max1"
  shows "let len :: int = sint max1 + (1 :: int) in int'63_in_bounds (sint max1 - (1 :: int)) \<and> (\<forall>(o2 :: 63 word). sint o2 = sint max1 - (1 :: int) \<longrightarrow> (\<not>(2 :: int) = (0 :: int) \<and> int'63_in_bounds (sint o2 cdiv (2 :: int))) \<and> (\<forall>(o3 :: 63 word). sint o3 = sint o2 cdiv (2 :: int) \<longrightarrow> int'63_in_bounds (sint o3 + (1 :: int)) \<and> (\<forall>(len_arr :: 63 word). sint len_arr = sint o3 + (1 :: int) \<longrightarrow> (let o4 :: int \<Rightarrow> int = fc max1 in (0 :: int) \<le> len \<and> (let nexts1 :: int list = create_list len o4 in int (length nexts1) = len \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < len \<longrightarrow> nexts1 ! nat i = o4 i) \<longrightarrow> (\<forall>(i :: int). \<not>i = (0 :: int) \<longrightarrow> \<not>i = (1 :: int) \<longrightarrow> (2 :: int) < i \<longrightarrow> \<not>(2 :: int) = (0 :: int)) \<and> (let o5 :: int \<Rightarrow> bool = o1 in (0 :: int) \<le> len \<and> (let marked1 :: bool list = create_list len o5 in int (length marked1) = len \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < len \<longrightarrow> marked1 ! nat i = o5 i) \<longrightarrow> (let f :: int \<Rightarrow> int = fc1 max1 len_arr in (0 :: int) \<le> sint len_arr \<and> (\<forall>(arr1 :: array_ArrayInt63.array63). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < sint len_arr \<longrightarrow> elts arr1 ! nat i = sint (Groups.uminus_class.uminus (2 :: 63 word))) \<and> int (length (elts arr1)) = sint len_arr \<longrightarrow> int'63_in_bounds (sint len_arr - (1 :: int)) \<and> (\<forall>(o6 :: 63 word). sint o6 = sint len_arr - (1 :: int) \<longrightarrow> ((1 :: int) \<le> sint o6 + (1 :: int) \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (1 :: int) \<longrightarrow> elts arr1 ! nat j = f j) \<and> (\<forall>(arr2 :: array_ArrayInt63.array63). array_ArrayInt63.size arr2 = array_ArrayInt63.size arr1 \<longrightarrow> (\<forall>(i :: 63 word). let i1 :: int = sint i in ((1 :: int) \<le> i1 \<and> i1 \<le> sint o6) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i1 \<longrightarrow> elts arr2 ! nat j = f j) \<longrightarrow> int'63_in_bounds (sint len_arr - (1 :: int)) \<and> (\<forall>(o7 :: 63 word). sint o7 = sint len_arr - (1 :: int) \<longrightarrow> (sint i = sint o7 \<longrightarrow> i = o7) \<longrightarrow> (if i = o7 then int'63_in_bounds (sint max1 + (1 :: int)) else int'63_in_bounds ((2 :: int) * sint i) \<and> (\<forall>(o8 :: 63 word). sint o8 = (2 :: int) * sint i \<longrightarrow> int'63_in_bounds (sint o8 + (3 :: int)))) \<and> (\<forall>(o8 :: 63 word). (if i = o7 then sint o8 = sint max1 + (1 :: int) else \<exists>(o9 :: 63 word). sint o9 = (2 :: int) * sint i \<and> sint o8 = sint o9 + (3 :: int)) \<longrightarrow> ((0 :: int) \<le> sint i \<and> sint i < int (length (elts arr2))) \<and> (\<forall>(arr3 :: array_ArrayInt63.array63). array_ArrayInt63.size arr3 = array_ArrayInt63.size arr2 \<longrightarrow> elts arr3 = (elts arr2)[nat (sint i) := sint o8] \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i1 + (1 :: int) \<longrightarrow> elts arr3 ! nat j = f j))))) \<and> ((\<forall>(j :: int). (0 :: int) \<le> j \<and> j < sint o6 + (1 :: int) \<longrightarrow> elts arr2 ! nat j = f j) \<longrightarrow> int'63_in_bounds (sint max1 - (1 :: int)) \<and> (\<forall>(o7 :: 63 word). sint o7 = sint max1 - (1 :: int) \<longrightarrow> (\<not>(2 :: int) = (0 :: int) \<and> int'63_in_bounds (sint o7 cdiv (2 :: int))) \<and> (\<forall>(o8 :: 63 word). sint o8 = sint o7 cdiv (2 :: int) \<longrightarrow> ((sint max1 < sint int'63_max \<and> (3 :: int) \<le> sint max1) \<and> (length nexts1 = length marked1 \<and> int (length marked1) = sint max1 + (1 :: int)) \<and> (sint max1 - (1 :: int)) ediv (2 :: int) = sint o8 \<and> int (length (elts arr2)) = sint o8 + (1 :: int) \<and> inv_nexts nexts1 (int (length nexts1)) \<and> all_eliminated_marked marked1 nexts1 \<and> (\<forall>(i :: int). (3 :: int) \<le> i \<and> i \<le> sint max1 \<longrightarrow> i emod (2 :: int) = (0 :: int) \<longrightarrow> marked1 ! nat i = True) \<and> (\<forall>(i :: int). (3 :: int) \<le> i \<and> i < sint max1 - (1 :: int) \<longrightarrow> i emod (2 :: int) = (1 :: int) \<longrightarrow> nexts1 ! nat i emod (2 :: int) = (1 :: int) \<or> nexts1 ! nat i = sint max1 + (1 :: int)) \<and> (nexts1 ! nat (sint max1) = sint max1 + (1 :: int) \<and> ((sint max1 - (1 :: int)) emod (2 :: int) = (0 :: int) \<longrightarrow> nexts1 ! nat (sint max1 - (1 :: int)) = sint max1) \<and> ((sint max1 - (1 :: int)) emod (2 :: int) = (1 :: int) \<longrightarrow> nexts1 ! nat (sint max1 - (1 :: int)) = sint max1 + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint o8 \<longrightarrow> -(sint max1 + (1 :: int)) \<le> elts arr2 ! nat i \<and> elts arr2 ! nat i \<le> sint max1 + (1 :: int)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint o8 \<longrightarrow> marked1 ! nat ((2 :: int) * i + (1 :: int)) = True \<longleftrightarrow> elts arr2 ! nat i < (0 :: int)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint o8 \<longrightarrow> \<not>marked1 ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts arr2 ! nat i = nexts1 ! nat ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint o8 \<longrightarrow> marked1 ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts arr2 ! nat i = -nexts1 ! nat ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint o8 \<longrightarrow> (i < abs (elts arr2 ! nat i) ediv (2 :: int) \<and> abs (elts arr2 ! nat i) ediv (2 :: int) \<le> sint o8 + (1 :: int)) \<and> abs (elts arr2 ! nat i) \<le> sint max1 + (1 :: int)) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> sint o8 \<longrightarrow> i < j \<and> j < abs (elts arr2 ! nat i) ediv (2 :: int) \<longrightarrow> elts arr2 ! nat j < (0 :: int))) \<and> (\<forall>(result :: t). nexts result = nexts1 \<and> marked result = marked1 \<and> arr result = arr2 \<and> max result = max1 \<and> max_arr result = o8 \<longrightarrow> max result = max1 \<and> ((marked result ! (0 :: nat) = marked result ! (1 :: nat) \<and> marked result ! (1 :: nat) = True) \<and> \<not>marked result ! (2 :: nat) = True) \<and> (\<forall>(i :: int). (1 :: int) \<le> i \<and> i \<le> (sint max1 - (1 :: int)) ediv (2 :: int) \<longrightarrow> \<not>marked result ! nat ((2 :: int) * i + (1 :: int)) = True) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i \<le> (sint max1 + (1 :: int)) ediv (2 :: int) \<longrightarrow> (2 :: int) * i \<le> sint max1 \<longrightarrow> marked result ! nat ((2 :: int) * i) = True) \<and> (\<forall>(i :: int). (1 :: int) \<le> i \<and> i \<le> (sint max1 - (1 :: int)) ediv (2 :: int) \<longrightarrow> (2 :: int) * i + (1 :: int) < sint max1 - (1 :: int) \<longrightarrow> nexts result ! nat ((2 :: int) * i + (1 :: int)) = (2 :: int) * i + (3 :: int)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i \<le> (sint max1 - (1 :: int)) ediv (2 :: int) \<longrightarrow> (2 :: int) * i < sint max1 - (1 :: int) \<longrightarrow> nexts result ! nat ((2 :: int) * i) = (2 :: int) * i + (1 :: int)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint max1 \<longrightarrow> marked result ! nat i = True \<longrightarrow> i < (2 :: int) \<or> (2 :: int) dvd i))))))) \<and> (sint o6 + (1 :: int) < (1 :: int) \<longrightarrow> int'63_in_bounds (sint max1 - (1 :: int)) \<and> (\<forall>(o7 :: 63 word). sint o7 = sint max1 - (1 :: int) \<longrightarrow> (\<not>(2 :: int) = (0 :: int) \<and> int'63_in_bounds (sint o7 cdiv (2 :: int))) \<and> (\<forall>(o8 :: 63 word). sint o8 = sint o7 cdiv (2 :: int) \<longrightarrow> ((sint max1 < sint int'63_max \<and> (3 :: int) \<le> sint max1) \<and> (length nexts1 = length marked1 \<and> int (length marked1) = sint max1 + (1 :: int)) \<and> (sint max1 - (1 :: int)) ediv (2 :: int) = sint o8 \<and> int (length (elts arr1)) = sint o8 + (1 :: int) \<and> inv_nexts nexts1 (int (length nexts1)) \<and> all_eliminated_marked marked1 nexts1 \<and> (\<forall>(i :: int). (3 :: int) \<le> i \<and> i \<le> sint max1 \<longrightarrow> i emod (2 :: int) = (0 :: int) \<longrightarrow> marked1 ! nat i = True) \<and> (\<forall>(i :: int). (3 :: int) \<le> i \<and> i < sint max1 - (1 :: int) \<longrightarrow> i emod (2 :: int) = (1 :: int) \<longrightarrow> nexts1 ! nat i emod (2 :: int) = (1 :: int) \<or> nexts1 ! nat i = sint max1 + (1 :: int)) \<and> (nexts1 ! nat (sint max1) = sint max1 + (1 :: int) \<and> ((sint max1 - (1 :: int)) emod (2 :: int) = (0 :: int) \<longrightarrow> nexts1 ! nat (sint max1 - (1 :: int)) = sint max1) \<and> ((sint max1 - (1 :: int)) emod (2 :: int) = (1 :: int) \<longrightarrow> nexts1 ! nat (sint max1 - (1 :: int)) = sint max1 + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint o8 \<longrightarrow> -(sint max1 + (1 :: int)) \<le> elts arr1 ! nat i \<and> elts arr1 ! nat i \<le> sint max1 + (1 :: int)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint o8 \<longrightarrow> marked1 ! nat ((2 :: int) * i + (1 :: int)) = True \<longleftrightarrow> elts arr1 ! nat i < (0 :: int)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint o8 \<longrightarrow> \<not>marked1 ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts arr1 ! nat i = nexts1 ! nat ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint o8 \<longrightarrow> marked1 ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts arr1 ! nat i = -nexts1 ! nat ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint o8 \<longrightarrow> (i < abs (elts arr1 ! nat i) ediv (2 :: int) \<and> abs (elts arr1 ! nat i) ediv (2 :: int) \<le> sint o8 + (1 :: int)) \<and> abs (elts arr1 ! nat i) \<le> sint max1 + (1 :: int)) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> sint o8 \<longrightarrow> i < j \<and> j < abs (elts arr1 ! nat i) ediv (2 :: int) \<longrightarrow> elts arr1 ! nat j < (0 :: int))) \<and> (\<forall>(result :: t). nexts result = nexts1 \<and> marked result = marked1 \<and> arr result = arr1 \<and> max result = max1 \<and> max_arr result = o8 \<longrightarrow> max result = max1 \<and> ((marked result ! (0 :: nat) = marked result ! (1 :: nat) \<and> marked result ! (1 :: nat) = True) \<and> \<not>marked result ! (2 :: nat) = True) \<and> (\<forall>(i :: int). (1 :: int) \<le> i \<and> i \<le> (sint max1 - (1 :: int)) ediv (2 :: int) \<longrightarrow> \<not>marked result ! nat ((2 :: int) * i + (1 :: int)) = True) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i \<le> (sint max1 + (1 :: int)) ediv (2 :: int) \<longrightarrow> (2 :: int) * i \<le> sint max1 \<longrightarrow> marked result ! nat ((2 :: int) * i) = True) \<and> (\<forall>(i :: int). (1 :: int) \<le> i \<and> i \<le> (sint max1 - (1 :: int)) ediv (2 :: int) \<longrightarrow> (2 :: int) * i + (1 :: int) < sint max1 - (1 :: int) \<longrightarrow> nexts result ! nat ((2 :: int) * i + (1 :: int)) = (2 :: int) * i + (3 :: int)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i \<le> (sint max1 - (1 :: int)) ediv (2 :: int) \<longrightarrow> (2 :: int) * i < sint max1 - (1 :: int) \<longrightarrow> nexts result ! nat ((2 :: int) * i) = (2 :: int) * i + (1 :: int)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint max1 \<longrightarrow> marked result ! nat i = True \<longrightarrow> i < (2 :: int) \<or> (2 :: int) dvd i)))))))))))))))"
  sorry
end
