import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
open Classical
open Lean4Why3
namespace muller_Muller_compactqtvc
axiom fc : List ℤ -> ℤ -> Bool
axiom fc'def (a : List ℤ) (i : ℤ) : (fc a i = true) = (¬a[Int.toNat i]! = (0 : ℤ))
noncomputable def numof (a : List ℤ) (l : ℤ) (u : ℤ) := NumOf.numof (fc a) l u
theorem compact'vc (a : List ℤ) : let o1 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → (0 : ℤ) = numof a (0 : ℤ) (0 : ℤ) ∧ (∀(count : ℤ), (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ count = numof a (0 : ℤ) i → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if ¬a[Int.toNat i]! = (0 : ℤ) then count + (1 : ℤ) = numof a (0 : ℤ) (i + (1 : ℤ)) else count = numof a (0 : ℤ) (i + (1 : ℤ)))) ∧ (count = numof a (0 : ℤ) (o1 + (1 : ℤ)) → (0 : ℤ) ≤ count ∧ (∀(u : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < count → u[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length u) = count → (let o2 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); (0 : ℤ) ≤ o2 + (1 : ℤ) → (0 : ℤ) = numof a (0 : ℤ) (0 : ℤ) ∧ (∀(u1 : List ℤ) (count1 : ℤ), List.length u1 = List.length u → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o2) ∧ count1 = numof a (0 : ℤ) i → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if ¬a[Int.toNat i]! = (0 : ℤ) then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let o3 : ℤ := a[Int.toNat i]!; ((0 : ℤ) ≤ count1 ∧ count1 < Int.ofNat (List.length u1)) ∧ (List.length (List.set u1 (Int.toNat count1) o3) = List.length u1 → getElem! (List.set u1 (Int.toNat count1) o3) ∘ Int.toNat = Function.update (getElem! u1 ∘ Int.toNat) count1 o3 → count1 + (1 : ℤ) = numof a (0 : ℤ) (i + (1 : ℤ)))) else count1 = numof a (0 : ℤ) (i + (1 : ℤ)))))))))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (0 : ℤ) ≤ (0 : ℤ) ∧ (∀(u : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (0 : ℤ) → u[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length u) = (0 : ℤ) → (let o2 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); (0 : ℤ) ≤ o2 + (1 : ℤ) → (0 : ℤ) = numof a (0 : ℤ) (0 : ℤ) ∧ (∀(u1 : List ℤ) (count : ℤ), List.length u1 = List.length u → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o2) ∧ count = numof a (0 : ℤ) i → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if ¬a[Int.toNat i]! = (0 : ℤ) then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let o3 : ℤ := a[Int.toNat i]!; ((0 : ℤ) ≤ count ∧ count < Int.ofNat (List.length u1)) ∧ (List.length (List.set u1 (Int.toNat count) o3) = List.length u1 → getElem! (List.set u1 (Int.toNat count) o3) ∘ Int.toNat = Function.update (getElem! u1 ∘ Int.toNat) count o3 → count + (1 : ℤ) = numof a (0 : ℤ) (i + (1 : ℤ)))) else count = numof a (0 : ℤ) (i + (1 : ℤ))))))))
  := sorry
end muller_Muller_compactqtvc
