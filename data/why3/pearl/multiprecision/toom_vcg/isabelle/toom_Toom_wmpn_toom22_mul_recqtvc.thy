theory toom_Toom_wmpn_toom22_mul_recqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.c_C" "mach.int_Unsigned" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_1_Sub_1" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical"
begin
theorem wmpn_toom22_mul_rec'vc:
  fixes x :: "64 word ptr"
  fixes sx :: "32 word"
  fixes y :: "64 word ptr"
  fixes sy :: "32 word"
  fixes r :: "64 word ptr"
  fixes scratch :: "64 word ptr"
  fixes k :: "int"
  assumes fact0: "valid x (sint sx)"
  assumes fact1: "valid y (sint sy)"
  assumes fact2: "valid r (sint sx + sint sy)"
  assumes fact3: "writable r = True"
  assumes fact4: "writable scratch = True"
  assumes fact5: "(0 :: int) < sint sy"
  assumes fact6: "sint sy \<le> sint sx"
  assumes fact7: "sint sx \<le> sint sy + sint sy"
  assumes fact8: "(8 :: int) * sint sx < (2147483647 :: int)"
  assumes fact9: "(0 :: int) \<le> k"
  assumes fact10: "k \<le> (64 :: int)"
  assumes fact11: "sint sx \<le> sint (29 :: 32 word) * (2 :: int) ^\<^sub>i k"
  assumes fact12: "valid scratch ((2 :: int) * (sint sx + k))"
  shows "if sint sy \<le> sint (29 :: 32 word) then (((0 :: int) < sint sy \<and> sint sy \<le> sint sx) \<and> valid x (sint sx) \<and> valid y (sint sy) \<and> valid r (sint sy + sint sx) \<and> writable r = True) \<and> (\<forall>(r1 :: 64 word ptr). length (data r1) = length (data r) \<and> offset r1 = offset r \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> writable r1 = writable r \<and> zone1 r1 = zone1 r \<longrightarrow> value r1 (sint sy + sint sx) = value x (sint sx) * value y (sint sy) \<and> (\<forall>(j :: int). j < offset r1 \<or> offset r1 + (sint sy + sint sx) \<le> j \<longrightarrow> pelts r1 j = pelts r j) \<longrightarrow> value r1 (sint sx + sint sy) = value x (sint sx) * value y (sint sy) \<and> (\<forall>(j :: int). c_C.min r1 \<le> j \<and> j < offset r1 \<or> offset r1 + sint sx + sint sy \<le> j \<and> j < c_C.max r1 \<longrightarrow> pelts r1 j = pelts r j) \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> plength r1 = plength r) else int'32_in_bounds ((5 :: int) * sint sy) \<and> (\<forall>(o1 :: 32 word). sint o1 = (5 :: int) * sint sy \<longrightarrow> int'32_in_bounds ((4 :: int) * sint sx) \<and> (\<forall>(o2 :: 32 word). sint o2 = (4 :: int) * sint sx \<longrightarrow> (if sint o2 < sint o1 then (((0 :: int) \<le> k + k + (1 :: int) \<and> k + k < k + k + (1 :: int)) \<and> valid x (sint sx) \<and> valid y (sint sy) \<and> valid r (sint sx + sint sy) \<and> sint (29 :: 32 word) < sint sy \<and> ((0 :: int) < k \<and> k \<le> (64 :: int)) \<and> sint sx \<le> sint (29 :: 32 word) * (2 :: int) ^\<^sub>i k \<and> valid scratch ((2 :: int) * (sint sx + k)) \<and> (writable r = True \<and> writable scratch = True) \<and> (8 :: int) * sint sx < (2147483647 :: int) \<and> ((2 :: int) < sint sy \<and> sint sy \<le> sint sx \<and> sint sx < sint sy + sint sy - (1 :: int)) \<and> (4 :: int) * sint sx < (5 :: int) * sint sy) \<and> (\<forall>(scratch1 :: 64 word ptr) (r1 :: 64 word ptr). offset scratch1 = offset scratch \<and> writable scratch1 = writable scratch \<and> zone1 scratch1 = zone1 scratch \<longrightarrow> offset r1 = offset r \<and> writable r1 = writable r \<and> zone1 r1 = zone1 r \<longrightarrow> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> plength r1 = plength r \<and> c_C.min scratch1 = c_C.min scratch \<and> c_C.max scratch1 = c_C.max scratch \<and> plength scratch1 = plength scratch \<and> value r1 (sint sx + sint sy) = value x (sint sx) * value y (sint sy) \<and> (\<forall>(j :: int). c_C.min r1 \<le> j \<and> j < offset r1 \<or> offset r1 + sint sx + sint sy \<le> j \<and> j < c_C.max r1 \<longrightarrow> pelts r1 j = pelts r j) \<and> (\<forall>(j :: int). c_C.min scratch1 \<le> j \<and> j < offset scratch1 \<longrightarrow> pelts scratch1 j = pelts scratch j) \<longrightarrow> value r1 (sint sx + sint sy) = value x (sint sx) * value y (sint sy) \<and> (\<forall>(j :: int). c_C.min r1 \<le> j \<and> j < offset r1 \<or> offset r1 + sint sx + sint sy \<le> j \<and> j < c_C.max r1 \<longrightarrow> pelts r1 j = pelts r j) \<and> (\<forall>(j :: int). c_C.min scratch1 \<le> j \<and> j < offset scratch1 \<longrightarrow> pelts scratch1 j = pelts scratch j) \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> plength r1 = plength r \<and> c_C.min scratch1 = c_C.min scratch \<and> c_C.max scratch1 = c_C.max scratch \<and> plength scratch1 = plength scratch) else (((0 :: int) \<le> k + k + (1 :: int) \<and> k + k < k + k + (1 :: int)) \<and> valid x (sint sx) \<and> valid y (sint sy) \<and> valid r (sint sx + sint sy) \<and> (writable r = True \<and> writable scratch = True) \<and> sint (29 :: 32 word) < sint sy \<and> ((0 :: int) < k \<and> k \<le> (64 :: int)) \<and> sint sx \<le> sint (29 :: 32 word) * (2 :: int) ^\<^sub>i k \<and> valid scratch ((2 :: int) * (sint sx + k)) \<and> (8 :: int) * sint sx < (2147483647 :: int) \<and> ((4 :: int) < sint sy + (2 :: int) \<and> sint sy + (2 :: int) \<le> sint sx) \<and> sint sx + (6 :: int) \<le> (3 :: int) * sint sy) \<and> (\<forall>(scratch1 :: 64 word ptr) (r1 :: 64 word ptr). offset scratch1 = offset scratch \<and> writable scratch1 = writable scratch \<and> zone1 scratch1 = zone1 scratch \<longrightarrow> offset r1 = offset r \<and> writable r1 = writable r \<and> zone1 r1 = zone1 r \<longrightarrow> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> plength r1 = plength r \<and> c_C.min scratch1 = c_C.min scratch \<and> c_C.max scratch1 = c_C.max scratch \<and> plength scratch1 = plength scratch \<and> value r1 (sint sx + sint sy) = value x (sint sx) * value y (sint sy) \<and> (\<forall>(j :: int). c_C.min r1 \<le> j \<and> j < offset r1 \<or> offset r1 + sint sx + sint sy \<le> j \<and> j < c_C.max r1 \<longrightarrow> pelts r1 j = pelts r j) \<and> (\<forall>(j :: int). c_C.min scratch1 \<le> j \<and> j < offset scratch1 \<longrightarrow> pelts scratch1 j = pelts scratch j) \<longrightarrow> value r1 (sint sx + sint sy) = value x (sint sx) * value y (sint sy) \<and> (\<forall>(j :: int). c_C.min r1 \<le> j \<and> j < offset r1 \<or> offset r1 + sint sx + sint sy \<le> j \<and> j < c_C.max r1 \<longrightarrow> pelts r1 j = pelts r j) \<and> (\<forall>(j :: int). c_C.min scratch1 \<le> j \<and> j < offset scratch1 \<longrightarrow> pelts scratch1 j = pelts scratch j) \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> plength r1 = plength r \<and> c_C.min scratch1 = c_C.min scratch \<and> c_C.max scratch1 = c_C.max scratch \<and> plength scratch1 = plength scratch))))"
  sorry
end
