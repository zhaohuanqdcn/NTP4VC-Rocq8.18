theory set_str_Set_str_wmpn_set_str_otherqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "mach.c_UChar" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/powm_Powm" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/sub_1_Sub_1" "../../lib/isabelle/stringlemmas_String_lemmas" "../../lib/isabelle/base_info_BaseInfo"
begin
theorem wmpn_set_str_other'vc:
  fixes sn :: "32 word"
  fixes sz :: "32 word"
  fixes rp :: "64 word ptr"
  fixes sp :: "8 word ptr"
  fixes b :: "64 word"
  fixes info :: "wmpn_base_info"
  assumes fact0: "(0 :: int) < uint sn"
  assumes fact1: "uint sn \<le> (2147483647 :: int)"
  assumes fact2: "(0 :: int) < sint sz"
  assumes fact3: "valid rp (sint sz)"
  assumes fact4: "valid sp (uint sn)"
  assumes fact5: "(2 :: int) \<le> uint b"
  assumes fact6: "uint b \<le> (256 :: int)"
  assumes fact7: "uint b ^\<^sub>i uint sn \<le> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sz"
  assumes fact8: "writable rp = True"
  assumes fact9: "in_base (uint b) (pelts sp) (offset sp) (offset sp + uint sn)"
  assumes fact10: "base_info_BaseInfo.b info = uint b"
  shows "let o1 :: 32 word = base_info_BaseInfo.exp info in uint'32_in_bounds (uint sn - (1 :: int)) \<and> (\<forall>(o2 :: 32 word). uint o2 = uint sn - (1 :: int) \<longrightarrow> (\<not>uint o1 = (0 :: int) \<and> uint'32_in_bounds (uint o2 cmod uint o1)) \<and> (\<forall>(o3 :: 32 word). uint o3 = uint o2 cmod uint o1 \<longrightarrow> uint'32_in_bounds ((1 :: int) + uint o3) \<and> (\<forall>(o4 :: 32 word). uint o4 = (1 :: int) + uint o3 \<longrightarrow> (c_C.min sp \<le> offset sp \<and> offset sp < c_C.max sp) \<and> (\<forall>(o5 :: 64 word). uint o5 = uint (pelts sp (offset sp)) \<longrightarrow> (((1 :: int) \<le> uint o4 \<and> uint o4 \<le> uint sn) \<and> ((1 :: int) \<le> (1 :: int) \<and> (1 :: int) \<le> uint sn) \<and> uint o5 = svalue_sub (uint b) (pelts sp) (offset sp) (offset sp + (1 :: int)) \<and> ((0 :: int) \<le> uint o5 \<and> uint o5 < uint b ^\<^sub>i (1 :: int)) \<and> (1 :: int) + uint o4 - (1 :: int) = (1 :: int) + (uint sn - (1 :: int)) emod uint (base_info_BaseInfo.exp info) \<and> ((1 :: int) = uint sn \<longrightarrow> uint o4 = (1 :: int))) \<and> (\<forall>(j :: 32 word) (w :: 64 word) (k :: 32 word). ((1 :: int) \<le> uint k \<and> uint k \<le> uint sn) \<and> ((1 :: int) \<le> sint j \<and> sint j \<le> uint sn) \<and> uint w = svalue_sub (uint b) (pelts sp) (offset sp) (offset sp + sint j) \<and> ((0 :: int) \<le> uint w \<and> uint w < uint b ^\<^sub>i sint j) \<and> sint j + uint k - (1 :: int) = (1 :: int) + (uint sn - (1 :: int)) emod uint (base_info_BaseInfo.exp info) \<and> (sint j = uint sn \<longrightarrow> uint k = (1 :: int)) \<longrightarrow> uint'32_in_bounds (uint k - (1 :: int)) \<and> (\<forall>(o6 :: 32 word). uint o6 = uint k - (1 :: int) \<longrightarrow> (if (0 :: int) < uint o6 then (c_C.min sp \<le> offset sp + sint j \<and> offset sp + sint j < c_C.max sp) \<and> (\<forall>(sj :: 64 word). uint sj = uint (pelts sp (offset sp + sint j)) \<longrightarrow> uint'64_in_bounds (uint w * uint b) \<and> (\<forall>(o7 :: 64 word). uint o7 = uint w * uint b \<longrightarrow> uint'64_in_bounds (uint o7 + uint sj) \<and> (\<forall>(o8 :: 64 word). uint o8 = uint o7 + uint sj \<longrightarrow> int'32_in_bounds (sint j + (1 :: int)) \<and> (\<forall>(o9 :: 32 word). sint o9 = sint j + (1 :: int) \<longrightarrow> uint o6 < uint k \<and> ((1 :: int) \<le> uint o6 \<and> uint o6 \<le> uint sn) \<and> ((1 :: int) \<le> sint o9 \<and> sint o9 \<le> uint sn) \<and> uint o8 = svalue_sub (uint b) (pelts sp) (offset sp) (offset sp + sint o9) \<and> ((0 :: int) \<le> uint o8 \<and> uint o8 < uint b ^\<^sub>i sint o9) \<and> sint o9 + uint o6 - (1 :: int) = (1 :: int) + (uint sn - (1 :: int)) emod uint (base_info_BaseInfo.exp info) \<and> (sint o9 = uint sn \<longrightarrow> uint o6 = (1 :: int)))))) else ((c_C.min rp \<le> offset rp \<and> offset rp < c_C.max rp) \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> pelts rp1 = (pelts rp)(offset rp1 := w) \<longrightarrow> (((0 :: int) \<le> sint j \<and> sint j \<le> uint sn) \<and> value rp1 (1 :: int) = svalue_sub (uint b) (pelts sp) (offset sp) (offset sp + sint j) \<and> sint j \<le> uint sn \<and> ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) \<le> sint sz) \<and> ((0 :: int) < svalue (uint b) sp (sint j) \<longrightarrow> (0 :: int) < uint (pelts rp1 (offset rp1 + (1 :: int) - (1 :: int)))) \<and> (uint sn - sint j) emod uint (base_info_BaseInfo.exp info) = (0 :: int)) \<and> (\<forall>(rn :: 32 word) (j1 :: 32 word) (rp2 :: 64 word ptr). length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> ((0 :: int) \<le> sint j1 \<and> sint j1 \<le> uint sn) \<and> value rp2 (sint rn) = svalue_sub (uint b) (pelts sp) (offset sp) (offset sp + sint j1) \<and> sint j1 \<le> uint sn \<and> ((0 :: int) \<le> sint rn \<and> sint rn \<le> sint sz) \<and> ((0 :: int) < svalue (uint b) sp (sint j1) \<longrightarrow> (0 :: int) < uint (pelts rp2 (offset rp2 + sint rn - (1 :: int)))) \<and> (svalue (uint b) sp (sint j1) = (0 :: int) \<longrightarrow> sint rn = (1 :: int)) \<and> (uint sn - sint j1) emod uint (base_info_BaseInfo.exp info) = (0 :: int) \<longrightarrow> uint sn \<le> (2147483647 :: int) \<and> (\<forall>(o7 :: 32 word). sint o7 = uint sn \<longrightarrow> (if sint j1 < sint o7 then (c_C.min sp \<le> offset sp + sint j1 \<and> offset sp + sint j1 < c_C.max sp) \<and> (\<forall>(o8 :: 64 word). uint o8 = uint (pelts sp (offset sp + sint j1)) \<longrightarrow> int'32_in_bounds (sint j1 + (1 :: int)) \<and> (\<forall>(o9 :: 32 word). sint o9 = sint j1 + (1 :: int) \<longrightarrow> (let o10 :: 32 word = base_info_BaseInfo.exp info in uint'32_in_bounds (uint o10 - (1 :: int)) \<and> (\<forall>(o11 :: 32 word). uint o11 = uint o10 - (1 :: int) \<longrightarrow> ((1 :: int) \<le> uint o11 + (1 :: int) \<longrightarrow> (uint o8 = svalue_sub (uint b) (pelts sp) (offset sp + sint j1) (offset sp + sint o9) \<and> ((1 :: int) \<le> (1 :: int) \<and> (1 :: int) \<le> uint (base_info_BaseInfo.exp info)) \<and> sint o9 = sint j1 + (1 :: int)) \<and> (\<forall>(j2 :: 32 word) (w1 :: 64 word). (\<forall>(k1 :: 32 word). let k2 :: int = uint k1 in ((1 :: int) \<le> k2 \<and> k2 \<le> uint o11) \<and> uint w1 = svalue_sub (uint b) (pelts sp) (offset sp + sint j1) (offset sp + sint j2) \<and> ((1 :: int) \<le> k2 \<and> k2 \<le> uint (base_info_BaseInfo.exp info)) \<and> sint j2 = sint j1 + k2 \<longrightarrow> (c_C.min sp \<le> offset sp + sint j2 \<and> offset sp + sint j2 < c_C.max sp) \<and> (\<forall>(sj :: 64 word). uint sj = uint (pelts sp (offset sp + sint j2)) \<longrightarrow> uint'64_in_bounds (uint w1 * uint b) \<and> (\<forall>(o12 :: 64 word). uint o12 = uint w1 * uint b \<longrightarrow> uint'64_in_bounds (uint o12 + uint sj) \<and> (\<forall>(o13 :: 64 word). uint o13 = uint o12 + uint sj \<longrightarrow> int'32_in_bounds (sint j2 + (1 :: int)) \<and> (\<forall>(o14 :: 32 word). sint o14 = sint j2 + (1 :: int) \<longrightarrow> uint o13 = svalue_sub (uint b) (pelts sp) (offset sp + sint j1) (offset sp + sint o14) \<and> ((1 :: int) \<le> k2 + (1 :: int) \<and> k2 + (1 :: int) \<le> uint (base_info_BaseInfo.exp info)) \<and> sint o14 = sint j1 + (k2 + (1 :: int))))))) \<and> (uint w1 = svalue_sub (uint b) (pelts sp) (offset sp + sint j1) (offset sp + sint j2) \<and> ((1 :: int) \<le> uint o11 + (1 :: int) \<and> uint o11 + (1 :: int) \<le> uint (base_info_BaseInfo.exp info)) \<and> sint j2 = sint j1 + (uint o11 + (1 :: int)) \<longrightarrow> (valid rp2 (sint rn) \<and> writable rp2 = True) \<and> (\<forall>(rp3 :: 64 word ptr). length (data rp3) = length (data rp2) \<and> offset rp3 = offset rp2 \<and> c_C.min rp3 = c_C.min rp2 \<and> c_C.max rp3 = c_C.max rp2 \<and> writable rp3 = writable rp2 \<and> zone1 rp3 = zone1 rp2 \<longrightarrow> (\<forall>(o12 :: 64 word). value rp3 (sint rn) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint rn * uint o12 = value rp2 (sint rn) * uint (bb info) \<and> (\<forall>(j3 :: int). j3 < offset rp3 \<or> offset rp3 + sint rn \<le> j3 \<longrightarrow> pelts rp3 j3 = pelts rp2 j3) \<longrightarrow> (valid rp3 (sint rn) \<and> (0 :: int) < sint rn \<and> writable rp3 = True) \<and> (\<forall>(rp4 :: 64 word ptr). length (data rp4) = length (data rp3) \<and> offset rp4 = offset rp3 \<and> c_C.min rp4 = c_C.min rp3 \<and> c_C.max rp4 = c_C.max rp3 \<and> writable rp4 = writable rp3 \<and> zone1 rp4 = zone1 rp3 \<longrightarrow> (\<forall>(cy1 :: 64 word). value rp4 (sint rn) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint rn * uint cy1 = value rp3 (sint rn) + uint w1 \<and> ((0 :: int) \<le> uint cy1 \<and> uint cy1 \<le> (1 :: int)) \<and> (\<forall>(j3 :: int). j3 < offset rp4 \<or> offset rp4 + sint rn \<le> j3 \<longrightarrow> pelts rp4 j3 = pelts rp3 j3) \<longrightarrow> uint'64_in_bounds (uint o12 + uint cy1) \<and> (\<forall>(o13 :: 64 word). uint o13 = uint o12 + uint cy1 \<longrightarrow> (if (0 :: int) < uint o13 then ((c_C.min rp4 \<le> offset rp4 + sint rn \<and> offset rp4 + sint rn < c_C.max rp4) \<and> writable rp4 = True) \<and> (\<forall>(rp5 :: 64 word ptr). length (data rp5) = length (data rp4) \<and> offset rp5 = offset rp4 \<and> c_C.min rp5 = c_C.min rp4 \<and> c_C.max rp5 = c_C.max rp4 \<and> writable rp5 = writable rp4 \<and> zone1 rp5 = zone1 rp4 \<longrightarrow> pelts rp5 = (pelts rp4)(offset rp5 + sint rn := o13) \<and> pelts rp5 (offset rp5 + sint rn) = o13 \<longrightarrow> int'32_in_bounds (sint rn + (1 :: int)) \<and> (\<forall>(o14 :: 32 word). sint o14 = sint rn + (1 :: int) \<longrightarrow> ((0 :: int) \<le> uint sn - sint j1 \<and> uint sn - sint j2 < uint sn - sint j1) \<and> ((0 :: int) \<le> sint j2 \<and> sint j2 \<le> uint sn) \<and> value rp5 (sint o14) = svalue_sub (uint b) (pelts sp) (offset sp) (offset sp + sint j2) \<and> sint j2 \<le> uint sn \<and> ((0 :: int) \<le> sint o14 \<and> sint o14 \<le> sint sz) \<and> ((0 :: int) < svalue (uint b) sp (sint j2) \<longrightarrow> (0 :: int) < uint (pelts rp5 (offset rp5 + sint o14 - (1 :: int)))) \<and> (svalue (uint b) sp (sint j2) = (0 :: int) \<longrightarrow> sint o14 = (1 :: int)) \<and> (uint sn - sint j2) emod uint (base_info_BaseInfo.exp info) = (0 :: int))) else ((0 :: int) \<le> uint sn - sint j1 \<and> uint sn - sint j2 < uint sn - sint j1) \<and> ((0 :: int) \<le> sint j2 \<and> sint j2 \<le> uint sn) \<and> value rp4 (sint rn) = svalue_sub (uint b) (pelts sp) (offset sp) (offset sp + sint j2) \<and> sint j2 \<le> uint sn \<and> ((0 :: int) \<le> sint rn \<and> sint rn \<le> sint sz) \<and> ((0 :: int) < svalue (uint b) sp (sint j2) \<longrightarrow> (0 :: int) < uint (pelts rp4 (offset rp4 + sint rn - (1 :: int)))) \<and> (svalue (uint b) sp (sint j2) = (0 :: int) \<longrightarrow> sint rn = (1 :: int)) \<and> (uint sn - sint j2) emod uint (base_info_BaseInfo.exp info) = (0 :: int)))))))))) \<and> (uint o11 + (1 :: int) < (1 :: int) \<longrightarrow> (valid rp2 (sint rn) \<and> writable rp2 = True) \<and> (\<forall>(rp3 :: 64 word ptr). length (data rp3) = length (data rp2) \<and> offset rp3 = offset rp2 \<and> c_C.min rp3 = c_C.min rp2 \<and> c_C.max rp3 = c_C.max rp2 \<and> writable rp3 = writable rp2 \<and> zone1 rp3 = zone1 rp2 \<longrightarrow> (\<forall>(o12 :: 64 word). value rp3 (sint rn) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint rn * uint o12 = value rp2 (sint rn) * uint (bb info) \<and> (\<forall>(j2 :: int). j2 < offset rp3 \<or> offset rp3 + sint rn \<le> j2 \<longrightarrow> pelts rp3 j2 = pelts rp2 j2) \<longrightarrow> (valid rp3 (sint rn) \<and> (0 :: int) < sint rn \<and> writable rp3 = True) \<and> (\<forall>(rp4 :: 64 word ptr). length (data rp4) = length (data rp3) \<and> offset rp4 = offset rp3 \<and> c_C.min rp4 = c_C.min rp3 \<and> c_C.max rp4 = c_C.max rp3 \<and> writable rp4 = writable rp3 \<and> zone1 rp4 = zone1 rp3 \<longrightarrow> (\<forall>(cy1 :: 64 word). value rp4 (sint rn) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint rn * uint cy1 = value rp3 (sint rn) + uint o8 \<and> ((0 :: int) \<le> uint cy1 \<and> uint cy1 \<le> (1 :: int)) \<and> (\<forall>(j2 :: int). j2 < offset rp4 \<or> offset rp4 + sint rn \<le> j2 \<longrightarrow> pelts rp4 j2 = pelts rp3 j2) \<longrightarrow> uint'64_in_bounds (uint o12 + uint cy1) \<and> (\<forall>(o13 :: 64 word). uint o13 = uint o12 + uint cy1 \<longrightarrow> (if (0 :: int) < uint o13 then ((c_C.min rp4 \<le> offset rp4 + sint rn \<and> offset rp4 + sint rn < c_C.max rp4) \<and> writable rp4 = True) \<and> (\<forall>(rp5 :: 64 word ptr). length (data rp5) = length (data rp4) \<and> offset rp5 = offset rp4 \<and> c_C.min rp5 = c_C.min rp4 \<and> c_C.max rp5 = c_C.max rp4 \<and> writable rp5 = writable rp4 \<and> zone1 rp5 = zone1 rp4 \<longrightarrow> pelts rp5 = (pelts rp4)(offset rp5 + sint rn := o13) \<and> pelts rp5 (offset rp5 + sint rn) = o13 \<longrightarrow> int'32_in_bounds (sint rn + (1 :: int)) \<and> (\<forall>(o14 :: 32 word). sint o14 = sint rn + (1 :: int) \<longrightarrow> ((0 :: int) \<le> uint sn - sint j1 \<and> uint sn - sint o9 < uint sn - sint j1) \<and> ((0 :: int) \<le> sint o9 \<and> sint o9 \<le> uint sn) \<and> value rp5 (sint o14) = svalue_sub (uint b) (pelts sp) (offset sp) (offset sp + sint o9) \<and> sint o9 \<le> uint sn \<and> ((0 :: int) \<le> sint o14 \<and> sint o14 \<le> sint sz) \<and> ((0 :: int) < svalue (uint b) sp (sint o9) \<longrightarrow> (0 :: int) < uint (pelts rp5 (offset rp5 + sint o14 - (1 :: int)))) \<and> (svalue (uint b) sp (sint o9) = (0 :: int) \<longrightarrow> sint o14 = (1 :: int)) \<and> (uint sn - sint o9) emod uint (base_info_BaseInfo.exp info) = (0 :: int))) else ((0 :: int) \<le> uint sn - sint j1 \<and> uint sn - sint o9 < uint sn - sint j1) \<and> ((0 :: int) \<le> sint o9 \<and> sint o9 \<le> uint sn) \<and> value rp4 (sint rn) = svalue_sub (uint b) (pelts sp) (offset sp) (offset sp + sint o9) \<and> sint o9 \<le> uint sn \<and> ((0 :: int) \<le> sint rn \<and> sint rn \<le> sint sz) \<and> ((0 :: int) < svalue (uint b) sp (sint o9) \<longrightarrow> (0 :: int) < uint (pelts rp4 (offset rp4 + sint rn - (1 :: int)))) \<and> (svalue (uint b) sp (sint o9) = (0 :: int) \<longrightarrow> sint rn = (1 :: int)) \<and> (uint sn - sint o9) emod uint (base_info_BaseInfo.exp info) = (0 :: int)))))))))))) else ((0 :: int) < svalue (uint b) sp (uint sn) \<longrightarrow> (1 :: int) \<le> sint rn \<and> sint rn \<le> sint sz) \<and> value rp2 (sint rn) = svalue (uint b) sp (uint sn) \<and> ((0 :: int) < svalue (uint b) sp (uint sn) \<longrightarrow> (0 :: int) < uint (pelts rp2 (offset rp2 + sint rn - (1 :: int)))) \<and> (svalue (uint b) sp (uint sn) = (0 :: int) \<longrightarrow> sint rn = (1 :: int)) \<and> (0 :: int) < sint rn)))))))))))"
  sorry
end
