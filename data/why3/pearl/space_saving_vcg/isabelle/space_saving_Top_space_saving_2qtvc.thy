theory space_saving_Top_space_saving_2qtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref"
begin
typedecl  elt
consts dummy :: "elt"
theorem space_saving_2'vc:
  fixes s :: "int \<Rightarrow> elt"
  shows "(0 :: int) + (0 :: int) = (0 :: int)"
  and "(0 :: int) \<le> (0 :: int)"
  and "(0 :: int) \<le> int (map_occ dummy s (0 :: int) (0 :: int))"
  and "int (map_occ dummy s (0 :: int) (0 :: int)) \<le> (0 :: int)"
  and "(0 :: int) \<le> int (map_occ dummy s (0 :: int) (0 :: int))"
  and "int (map_occ dummy s (0 :: int) (0 :: int)) \<le> (0 :: int)"
  and "(0 :: int) < (0 :: int) \<longrightarrow> \<not>(0 :: int) < (0 :: int)"
  and "\<forall>(y :: elt). \<not>y = dummy \<longrightarrow> \<not>y = dummy \<longrightarrow> int (map_occ y s (0 :: int) (0 :: int)) \<le> min (0 :: int) (0 :: int)"
  and "\<forall>(n2 :: int) (x2 :: elt) (n1 :: int) (x1 :: elt). (0 :: int) \<le> n1 + n2 \<and> ((0 :: int) \<le> int (map_occ x1 s (0 :: int) (n1 + n2)) \<and> int (map_occ x1 s (0 :: int) (n1 + n2)) \<le> n1) \<and> ((0 :: int) \<le> int (map_occ x2 s (0 :: int) (n1 + n2)) \<and> int (map_occ x2 s (0 :: int) (n1 + n2)) \<le> n2) \<and> (if n1 = (0 :: int) then x1 = dummy else \<not>x1 = dummy) \<and> (if n2 = (0 :: int) then x2 = dummy else \<not>x2 = dummy) \<and> ((0 :: int) < n1 \<longrightarrow> (0 :: int) < n2 \<longrightarrow> \<not>x1 = x2) \<and> (\<forall>(y :: elt). \<not>y = x1 \<longrightarrow> \<not>y = x2 \<longrightarrow> int (map_occ y s (0 :: int) (n1 + n2)) \<le> min n1 n2) \<longrightarrow> (0 :: int) \<le> n1 + n2 \<and> (\<not>s (n1 + n2) = dummy \<longrightarrow> (if s (n1 + n2) = x1 then (n1 + (1 :: int) + n2 = n1 + n2 + (1 :: int) \<and> (0 :: int) \<le> n1 + n2 + (1 :: int)) \<and> ((0 :: int) \<le> int (map_occ x1 s (0 :: int) (n1 + n2 + (1 :: int))) \<and> int (map_occ x1 s (0 :: int) (n1 + n2 + (1 :: int))) \<le> n1 + (1 :: int)) \<and> ((0 :: int) \<le> int (map_occ x2 s (0 :: int) (n1 + n2 + (1 :: int))) \<and> int (map_occ x2 s (0 :: int) (n1 + n2 + (1 :: int))) \<le> n2) \<and> (if n1 + (1 :: int) = (0 :: int) then x1 = dummy else \<not>x1 = dummy) \<and> (if n2 = (0 :: int) then x2 = dummy else \<not>x2 = dummy) \<and> ((0 :: int) < n1 + (1 :: int) \<longrightarrow> (0 :: int) < n2 \<longrightarrow> \<not>x1 = x2) \<and> (\<forall>(y :: elt). \<not>y = x1 \<longrightarrow> \<not>y = x2 \<longrightarrow> int (map_occ y s (0 :: int) (n1 + n2 + (1 :: int))) \<le> min (n1 + (1 :: int)) n2) else if s (n1 + n2) = x2 then (n1 + (n2 + (1 :: int)) = n1 + n2 + (1 :: int) \<and> (0 :: int) \<le> n1 + n2 + (1 :: int)) \<and> ((0 :: int) \<le> int (map_occ x1 s (0 :: int) (n1 + n2 + (1 :: int))) \<and> int (map_occ x1 s (0 :: int) (n1 + n2 + (1 :: int))) \<le> n1) \<and> ((0 :: int) \<le> int (map_occ x2 s (0 :: int) (n1 + n2 + (1 :: int))) \<and> int (map_occ x2 s (0 :: int) (n1 + n2 + (1 :: int))) \<le> n2 + (1 :: int)) \<and> (if n1 = (0 :: int) then x1 = dummy else \<not>x1 = dummy) \<and> (if n2 + (1 :: int) = (0 :: int) then x2 = dummy else \<not>x2 = dummy) \<and> ((0 :: int) < n1 \<longrightarrow> (0 :: int) < n2 + (1 :: int) \<longrightarrow> \<not>x1 = x2) \<and> (\<forall>(y :: elt). \<not>y = x1 \<longrightarrow> \<not>y = x2 \<longrightarrow> int (map_occ y s (0 :: int) (n1 + n2 + (1 :: int))) \<le> min n1 (n2 + (1 :: int))) else if n1 \<le> n2 then (n1 + (1 :: int) + n2 = n1 + n2 + (1 :: int) \<and> (0 :: int) \<le> n1 + n2 + (1 :: int)) \<and> ((0 :: int) \<le> int (map_occ (s (n1 + n2)) s (0 :: int) (n1 + n2 + (1 :: int))) \<and> int (map_occ (s (n1 + n2)) s (0 :: int) (n1 + n2 + (1 :: int))) \<le> n1 + (1 :: int)) \<and> ((0 :: int) \<le> int (map_occ x2 s (0 :: int) (n1 + n2 + (1 :: int))) \<and> int (map_occ x2 s (0 :: int) (n1 + n2 + (1 :: int))) \<le> n2) \<and> (if n1 + (1 :: int) = (0 :: int) then s (n1 + n2) = dummy else \<not>s (n1 + n2) = dummy) \<and> (if n2 = (0 :: int) then x2 = dummy else \<not>x2 = dummy) \<and> ((0 :: int) < n1 + (1 :: int) \<longrightarrow> (0 :: int) < n2 \<longrightarrow> \<not>s (n1 + n2) = x2) \<and> (\<forall>(y :: elt). \<not>y = s (n1 + n2) \<longrightarrow> \<not>y = x2 \<longrightarrow> int (map_occ y s (0 :: int) (n1 + n2 + (1 :: int))) \<le> min (n1 + (1 :: int)) n2) else (n1 + (n2 + (1 :: int)) = n1 + n2 + (1 :: int) \<and> (0 :: int) \<le> n1 + n2 + (1 :: int)) \<and> ((0 :: int) \<le> int (map_occ x1 s (0 :: int) (n1 + n2 + (1 :: int))) \<and> int (map_occ x1 s (0 :: int) (n1 + n2 + (1 :: int))) \<le> n1) \<and> ((0 :: int) \<le> int (map_occ (s (n1 + n2)) s (0 :: int) (n1 + n2 + (1 :: int))) \<and> int (map_occ (s (n1 + n2)) s (0 :: int) (n1 + n2 + (1 :: int))) \<le> n2 + (1 :: int)) \<and> (if n1 = (0 :: int) then x1 = dummy else \<not>x1 = dummy) \<and> (if n2 + (1 :: int) = (0 :: int) then s (n1 + n2) = dummy else \<not>s (n1 + n2) = dummy) \<and> ((0 :: int) < n1 \<longrightarrow> (0 :: int) < n2 + (1 :: int) \<longrightarrow> \<not>x1 = s (n1 + n2)) \<and> (\<forall>(y :: elt). \<not>y = x1 \<longrightarrow> \<not>y = s (n1 + n2) \<longrightarrow> int (map_occ y s (0 :: int) (n1 + n2 + (1 :: int))) \<le> min n1 (n2 + (1 :: int)))))"
  sorry
end
