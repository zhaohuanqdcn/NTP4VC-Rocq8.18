theory imp_SymbolicInterpreter_symbolic_interp_whileqtvc
  imports "NTP4Verif.NTP4Verif" "../../lib/isabelle/imp_Syntax" "../../lib/isabelle/imp_ConcreteSemantics" "../../lib/isabelle/imp_Svar" "../../lib/isabelle/imp_Constraint" "../../lib/isabelle/imp_SymState" "../../lib/isabelle/imp_FreshSvar" "../../lib/isabelle/imp_SymStateSet"
begin
consts compose :: "(svar \<Rightarrow> int) \<Rightarrow> t \<Rightarrow> program_var \<Rightarrow> int option"
axiomatization where compose'def:   "compose rho sigma x = (case get sigma x of Some v \<Rightarrow> Some (rho v) | None \<Rightarrow> None)"
  for rho :: "svar \<Rightarrow> int"
  and sigma :: "t"
  and x :: "program_var"
definition state_extends :: "sym_state \<Rightarrow> sym_state \<Rightarrow> _"
  where "state_extends s s' \<longleftrightarrow> imp_Svar.to_fset (vars s) |\<subseteq>| imp_Svar.to_fset (vars s') \<and> (\<forall>(v :: svar). v |\<in>| imp_Svar.to_fset (vars s) \<longrightarrow> rho s v = rho s' v)" for s s'
consts svar_set_add :: "svar \<Rightarrow> imp_Svar.set \<Rightarrow> imp_Svar.set"
axiomatization where svar_set_add'def'0:   "imp_Svar.to_fset (svar_set_add v vs) = finsert v (imp_Svar.to_fset vs)"
  for v :: "svar"
  and vs :: "imp_Svar.set"
axiomatization where svar_set_add'def'1:   "if v |\<in>| imp_Svar.to_fset vs then fcard (imp_Svar.to_fset (svar_set_add v vs)) = fcard (imp_Svar.to_fset vs) else int (fcard (imp_Svar.to_fset (svar_set_add v vs))) = int (fcard (imp_Svar.to_fset vs)) + (1 :: int)"
  for v :: "svar"
  and vs :: "imp_Svar.set"
definition results_extend :: "sym_state \<Rightarrow> sym_state fset \<Rightarrow> sym_state fset \<Rightarrow> sym_state fset \<Rightarrow> _"
  where "results_extend s normals unbounds limits \<longleftrightarrow> (\<forall>(s' :: sym_state). s' |\<in>| normals \<or> s' |\<in>| unbounds \<or> s' |\<in>| limits \<longrightarrow> state_extends s s')" for s normals unbounds limits
theorem symbolic_interp_while'vc:
  fixes ctr :: "int"
  fixes n :: "int"
  fixes s :: "sym_state"
  fixes e :: "expr"
  fixes c :: "cmd"
  assumes fact0: "(0 :: int) \<le> ctr"
  assumes fact1: "ctr \<le> n"
  shows "\<not>ctr = n \<longrightarrow> (\<forall>(sym_cond :: symbolic_expr). eval_expr (compose (imp_SymState.rho s) (sigma s)) e (Enormal (interp_symbolic_expr (imp_SymState.rho s) sym_cond)) \<and> (\<forall>(v :: svar). v |\<in>| vars_in_symbolic_expr sym_cond \<longrightarrow> (\<exists>(x :: program_var). get (sigma s) x = Some v)) \<longrightarrow> (let o1 :: imp_Svar.set = vars s; o2 :: constr = Cconj (constr s) (Cneq sym_cond (Slit (0 :: int))); o3 :: t = sigma s in (vars_in_constraint o2 |\<subseteq>| imp_Svar.to_fset o1 \<and> (\<forall>(x :: program_var) (v :: svar). get o3 x = Some v \<longrightarrow> v |\<in>| imp_Svar.to_fset o1)) \<and> (\<forall>(s1 :: sym_state). sigma s1 = o3 \<and> constr s1 = o2 \<and> imp_SymState.rho s1 = imp_SymState.rho s \<and> vars s1 = o1 \<longrightarrow> (let o4 :: imp_Svar.set = vars s; o5 :: constr = Cconj (constr s) (Ceq sym_cond (Slit (0 :: int))); o6 :: t = sigma s in (vars_in_constraint o5 |\<subseteq>| imp_Svar.to_fset o4 \<and> (\<forall>(x :: program_var) (v :: svar). get o6 x = Some v \<longrightarrow> v |\<in>| imp_Svar.to_fset o4)) \<and> (\<forall>(s2 :: sym_state). sigma s2 = o6 \<and> constr s2 = o5 \<and> imp_SymState.rho s2 = imp_SymState.rho s \<and> vars s2 = o4 \<longrightarrow> (True = False \<longrightarrow> (\<forall>(rho :: svar \<Rightarrow> int). \<not>is_solution rho (constr s1))) \<longrightarrow> (0 :: int) \<le> n \<and> (\<forall>(normals1 :: imp_SymStateSet.set) (unbounds1 :: imp_SymStateSet.set) (limits1 :: imp_SymStateSet.set). results_extend s1 (imp_SymStateSet.to_fset normals1) (imp_SymStateSet.to_fset unbounds1) (imp_SymStateSet.to_fset limits1) \<and> (is_solution (imp_SymState.rho s1) (constr s1) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s1) (sigma s1)) c gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<and> is_solution (imp_SymState.rho s') (constr s') \<and> gamma' = compose (imp_SymState.rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<longrightarrow> is_solution (imp_SymState.rho s') (constr s') \<longrightarrow> is_solution (imp_SymState.rho s1) (constr s1) \<and> exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s1) (sigma s1)) c (compose (imp_SymState.rho s') (sigma s')) bhv) \<longrightarrow> (let o7 :: sym_state list = to_list normals1 in (\<forall>(e1 :: sym_state). e1 |\<in>| imp_SymStateSet.to_fset normals1 \<longleftrightarrow> e1 \<in> List.set o7) \<longrightarrow> (let o8 :: int = ctr + (1 :: int) in ((0 :: int) \<le> n - ctr \<and> n - o8 < n - ctr \<or> n - ctr = n - o8 \<and> (0 :: int) \<le> (0 :: int) \<and> int (length o7) < (0 :: int)) \<and> (0 :: int) \<le> o8 \<and> o8 \<le> n))))))))"
  and "\<forall>(normals :: imp_SymStateSet.set) (unbounds :: imp_SymStateSet.set) (limits :: imp_SymStateSet.set). (if ctr = n then (imp_SymStateSet.to_fset limits = finsert s fempty \<and> int (fcard (imp_SymStateSet.to_fset limits)) = (1 :: int)) \<and> (imp_SymStateSet.to_fset unbounds = fempty \<and> int (fcard (imp_SymStateSet.to_fset unbounds)) = (0 :: int)) \<and> imp_SymStateSet.to_fset normals = fempty \<and> int (fcard (imp_SymStateSet.to_fset normals)) = (0 :: int) else (\<exists>(sym_cond :: symbolic_expr). (eval_expr (compose (imp_SymState.rho s) (sigma s)) e (Enormal (interp_symbolic_expr (imp_SymState.rho s) sym_cond)) \<and> (\<forall>(v :: svar). v |\<in>| vars_in_symbolic_expr sym_cond \<longrightarrow> (\<exists>(x :: program_var). get (sigma s) x = Some v))) \<and> (\<exists>(s1 :: sym_state). (sigma s1 = sigma s \<and> constr s1 = Cconj (constr s) (Cneq sym_cond (Slit (0 :: int))) \<and> imp_SymState.rho s1 = imp_SymState.rho s \<and> vars s1 = vars s) \<and> (\<exists>(s2 :: sym_state). (sigma s2 = sigma s \<and> constr s2 = Cconj (constr s) (Ceq sym_cond (Slit (0 :: int))) \<and> imp_SymState.rho s2 = imp_SymState.rho s \<and> vars s2 = vars s) \<and> (\<exists>(normals1 :: imp_SymStateSet.set) (unbounds1 :: imp_SymStateSet.set) (limits1 :: imp_SymStateSet.set). (\<exists>(o1 :: bool). (o1 = False \<longrightarrow> (\<forall>(rho :: svar \<Rightarrow> int). \<not>is_solution rho (constr s1))) \<and> (if o1 = True then \<exists>(normals2 :: imp_SymStateSet.set) (unbounds2 :: imp_SymStateSet.set) (limits2 :: imp_SymStateSet.set). (results_extend s1 (imp_SymStateSet.to_fset normals2) (imp_SymStateSet.to_fset unbounds2) (imp_SymStateSet.to_fset limits2) \<and> (is_solution (imp_SymState.rho s1) (constr s1) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s1) (sigma s1)) c gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals2 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds2 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits2) \<and> is_solution (imp_SymState.rho s') (constr s') \<and> gamma' = compose (imp_SymState.rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals2 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds2 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits2) \<longrightarrow> is_solution (imp_SymState.rho s') (constr s') \<longrightarrow> is_solution (imp_SymState.rho s1) (constr s1) \<and> exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s1) (sigma s1)) c (compose (imp_SymState.rho s') (sigma s')) bhv)) \<and> (let o2 :: sym_state list = to_list normals2 in (\<forall>(e1 :: sym_state). e1 |\<in>| imp_SymStateSet.to_fset normals2 \<longleftrightarrow> e1 \<in> List.set o2) \<and> (let o3 :: int = ctr + (1 :: int) in \<exists>(unbounds3 :: imp_SymStateSet.set) (limits3 :: imp_SymStateSet.set). ((\<forall>(s' :: sym_state). s' |\<in>| imp_SymStateSet.to_fset normals1 \<or> s' |\<in>| imp_SymStateSet.to_fset unbounds3 \<or> s' |\<in>| imp_SymStateSet.to_fset limits3 \<longrightarrow> (\<exists>(s3 :: sym_state). s3 |\<in>| imp_SymStateSet.to_fset (of_list o2) \<and> state_extends s3 s')) \<and> (\<forall>(s3 :: sym_state). s3 |\<in>| imp_SymStateSet.to_fset (of_list o2) \<longrightarrow> is_solution (imp_SymState.rho s3) (constr s3) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_while (mk_loop_cnf n) o3 (compose (imp_SymState.rho s3) (sigma s3)) e c gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds3 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits3) \<and> is_solution (imp_SymState.rho s') (constr s') \<and> gamma' = compose (imp_SymState.rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds3 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits3) \<longrightarrow> is_solution (imp_SymState.rho s') (constr s') \<longrightarrow> (\<exists>(s3 :: sym_state). s3 |\<in>| imp_SymStateSet.to_fset (of_list o2) \<and> is_solution (imp_SymState.rho s3) (constr s3) \<and> exec_while (mk_loop_cnf n) o3 (compose (imp_SymState.rho s3) (sigma s3)) e c (compose (imp_SymState.rho s') (sigma s')) bhv))) \<and> imp_SymStateSet.to_fset limits1 = imp_SymStateSet.to_fset limits2 |\<union>| imp_SymStateSet.to_fset limits3 \<and> imp_SymStateSet.to_fset unbounds1 = imp_SymStateSet.to_fset unbounds2 |\<union>| imp_SymStateSet.to_fset unbounds3)) else (imp_SymStateSet.to_fset limits1 = fempty \<and> int (fcard (imp_SymStateSet.to_fset limits1)) = (0 :: int)) \<and> (imp_SymStateSet.to_fset unbounds1 = fempty \<and> int (fcard (imp_SymStateSet.to_fset unbounds1)) = (0 :: int)) \<and> imp_SymStateSet.to_fset normals1 = fempty \<and> int (fcard (imp_SymStateSet.to_fset normals1)) = (0 :: int))) \<and> (\<exists>(normals2 :: imp_SymStateSet.set) (unbounds2 :: imp_SymStateSet.set) (limits2 :: imp_SymStateSet.set). (\<exists>(o1 :: bool). (o1 = False \<longrightarrow> (\<forall>(rho :: svar \<Rightarrow> int). \<not>is_solution rho (constr s2))) \<and> (if o1 = True then (imp_SymStateSet.to_fset limits2 = fempty \<and> int (fcard (imp_SymStateSet.to_fset limits2)) = (0 :: int)) \<and> (imp_SymStateSet.to_fset unbounds2 = fempty \<and> int (fcard (imp_SymStateSet.to_fset unbounds2)) = (0 :: int)) \<and> imp_SymStateSet.to_fset normals2 = finsert s2 fempty \<and> int (fcard (imp_SymStateSet.to_fset normals2)) = (1 :: int) else (imp_SymStateSet.to_fset limits2 = fempty \<and> int (fcard (imp_SymStateSet.to_fset limits2)) = (0 :: int)) \<and> (imp_SymStateSet.to_fset unbounds2 = fempty \<and> int (fcard (imp_SymStateSet.to_fset unbounds2)) = (0 :: int)) \<and> imp_SymStateSet.to_fset normals2 = fempty \<and> int (fcard (imp_SymStateSet.to_fset normals2)) = (0 :: int))) \<and> imp_SymStateSet.to_fset limits = imp_SymStateSet.to_fset limits1 |\<union>| imp_SymStateSet.to_fset limits2 \<and> imp_SymStateSet.to_fset unbounds = imp_SymStateSet.to_fset unbounds1 |\<union>| imp_SymStateSet.to_fset unbounds2 \<and> imp_SymStateSet.to_fset normals = imp_SymStateSet.to_fset normals1 |\<union>| imp_SymStateSet.to_fset normals2))))) \<or> eval_expr (compose (imp_SymState.rho s) (sigma s)) e Eunbound_var \<and> (imp_SymStateSet.to_fset limits = fempty \<and> int (fcard (imp_SymStateSet.to_fset limits)) = (0 :: int)) \<and> (imp_SymStateSet.to_fset unbounds = finsert s fempty \<and> int (fcard (imp_SymStateSet.to_fset unbounds)) = (1 :: int)) \<and> imp_SymStateSet.to_fset normals = fempty \<and> int (fcard (imp_SymStateSet.to_fset normals)) = (0 :: int)) \<longrightarrow> results_extend s (imp_SymStateSet.to_fset normals) (imp_SymStateSet.to_fset unbounds) (imp_SymStateSet.to_fset limits) \<and> (is_solution (imp_SymState.rho s) (constr s) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_while (mk_loop_cnf n) ctr (compose (imp_SymState.rho s) (sigma s)) e c gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits) \<and> is_solution (imp_SymState.rho s') (constr s') \<and> gamma' = compose (imp_SymState.rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits) \<longrightarrow> is_solution (imp_SymState.rho s') (constr s') \<longrightarrow> is_solution (imp_SymState.rho s) (constr s) \<and> exec_while (mk_loop_cnf n) ctr (compose (imp_SymState.rho s) (sigma s)) e c (compose (imp_SymState.rho s') (sigma s')) bhv)"
  sorry
end
