import Why3.Base
import pearl.imp.lib.lean.imp.Syntax
import pearl.imp.lib.lean.imp.ConcreteSemantics
import pearl.imp.lib.lean.imp.Svar
import pearl.imp.lib.lean.imp.Constraint
import pearl.imp.lib.lean.imp.SymState
import pearl.imp.lib.lean.imp.FreshSvar
import pearl.imp.lib.lean.imp.SymStateSet
open Classical
open Lean4Why3
namespace imp_SymbolicInterpreter_symbolic_interp_cmdqtvc
axiom compose : (Svar.svar -> ℤ) -> Constraint.t -> Syntax.program_var -> Option ℤ
axiom compose'def (rho : Svar.svar -> ℤ) (sigma : Constraint.t) (x : Syntax.program_var) : compose rho sigma x = (match Constraint.get sigma x with | Option.some v => Option.some (rho v) | Option.none => Option.none)
noncomputable def state_extends (s : SymState.sym_state) (s' : SymState.sym_state) := Svar.to_fset (SymState.vars s) ⊆ Svar.to_fset (SymState.vars s') ∧ (∀(v : Svar.svar), v ∈ Svar.to_fset (SymState.vars s) → SymState.rho s v = SymState.rho s' v)
axiom svar_set_add : Svar.svar -> Svar.set -> Svar.set
axiom svar_set_add'def (v : Svar.svar) (vs : Svar.set) : Svar.to_fset (svar_set_add v vs) = insert v (Svar.to_fset vs) ∧ (if v ∈ Svar.to_fset vs then Finset.card (Svar.to_fset (svar_set_add v vs)) = Finset.card (Svar.to_fset vs) else Int.ofNat (Finset.card (Svar.to_fset (svar_set_add v vs))) = Int.ofNat (Finset.card (Svar.to_fset vs)) + (1 : ℤ))
noncomputable def results_extend (s : SymState.sym_state) (normals : Finset SymState.sym_state) (unbounds : Finset SymState.sym_state) (limits : Finset SymState.sym_state) := ∀(s' : SymState.sym_state), s' ∈ normals ∨ s' ∈ unbounds ∨ s' ∈ limits → state_extends s s'
theorem symbolic_interp_cmd'vc (n : ℤ) (c : Syntax.cmd) (s : SymState.sym_state) (fact0 : (0 : ℤ) ≤ n) : (match c with | Syntax.cmd.Cskip => True | Syntax.cmd.Cassign x e => (∀(se : Constraint.symbolic_expr), ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e (ConcreteSemantics.expr_behaviour.Enormal (Constraint.interp_symbolic_expr (SymState.rho s) se)) ∧ (∀(v : Svar.svar), v ∈ Constraint.vars_in_symbolic_expr se → (∃(x1 : Syntax.program_var), Constraint.get (SymState.sigma s) x1 = Option.some v)) → (∀(v' : Svar.svar), FreshSvar.is_fresh v' (Svar.to_fset (SymState.vars s)) → (let o1 : Constraint.t := SymState.sigma s; let sigma' : Constraint.t := Constraint.set o1 x v'; Constraint.get sigma' x = Option.some v' ∧ (∀(k' : Syntax.program_var), ¬k' = x → Constraint.get sigma' k' = Constraint.get o1 k') → (∀(constr' : Constraint.constr), (let constr : Constraint.constr := Constraint.constr.Cconj (SymState.constr s) (Constraint.constr.Ceq (Constraint.symbolic_expr.Svar v') se); (∃(v : Svar.svar), (match Constraint.get (SymState.sigma s) x with | Option.none => False | Option.some v1 => v = v1) ∧ (∀(rho : Svar.svar -> ℤ), Constraint.is_solution rho constr' = Constraint.is_solution rho (Constraint.constr.Cexists v constr)) ∧ Constraint.vars_in_constraint constr' ⊆ Constraint.vars_in_constraint (Constraint.constr.Cexists v constr)) ∨ Constraint.get (SymState.sigma s) x = Option.none ∧ constr' = constr) → (let o2 : Svar.set := SymState.vars s; ∀(vars' : Svar.set), Svar.to_fset vars' = insert v' (Svar.to_fset o2) ∧ (if v' ∈ Svar.to_fset o2 then Finset.card (Svar.to_fset vars') = Finset.card (Svar.to_fset o2) else Int.ofNat (Finset.card (Svar.to_fset vars')) = Int.ofNat (Finset.card (Svar.to_fset o2)) + (1 : ℤ)) → Constraint.vars_in_constraint constr' ⊆ Svar.to_fset vars' ∧ (∀(x1 : Syntax.program_var) (v : Svar.svar), Constraint.get sigma' x1 = Option.some v → v ∈ Svar.to_fset vars')))))) | Syntax.cmd.Cseq c1 c2 => ((match c with | Syntax.cmd.Cskip => False | Syntax.cmd.Cassign _ _ => False | Syntax.cmd.Cseq f f1 => f = c1 ∨ f1 = c1 | Syntax.cmd.Cif _ f f1 => f = c1 ∨ f1 = c1 | Syntax.cmd.Cwhile _ f => f = c1) ∧ (0 : ℤ) ≤ n) ∧ (∀(normals1 : SymStateSet.set) (unbounds1 : SymStateSet.set) (limits1 : SymStateSet.set), results_extend s (SymStateSet.to_fset normals1) (SymStateSet.to_fset unbounds1) (SymStateSet.to_fset limits1) ∧ (Constraint.is_solution (SymState.rho s) (SymState.constr s) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s) (SymState.sigma s)) c1 gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → Constraint.is_solution (SymState.rho s) (SymState.constr s) ∧ ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s) (SymState.sigma s)) c1 (compose (SymState.rho s') (SymState.sigma s')) bhv) → (let o1 : List SymState.sym_state := SymStateSet.to_list normals1; (∀(e : SymState.sym_state), (e ∈ SymStateSet.to_fset normals1) = (e ∈ o1)) → ((match c with | Syntax.cmd.Cskip => False | Syntax.cmd.Cassign _ _ => False | Syntax.cmd.Cseq f f1 => f = c2 ∨ f1 = c2 | Syntax.cmd.Cif _ f f1 => f = c2 ∨ f1 = c2 | Syntax.cmd.Cwhile _ f => f = c2) ∨ c = c2 ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ Int.ofNat (List.length o1) < (0 : ℤ)) ∧ (0 : ℤ) ≤ n)) | Syntax.cmd.Cif e c1 c2 => (∀(se : Constraint.symbolic_expr), ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e (ConcreteSemantics.expr_behaviour.Enormal (Constraint.interp_symbolic_expr (SymState.rho s) se)) ∧ (∀(v : Svar.svar), v ∈ Constraint.vars_in_symbolic_expr se → (∃(x : Syntax.program_var), Constraint.get (SymState.sigma s) x = Option.some v)) → (let o1 : Svar.set := SymState.vars s; let o2 : Constraint.constr := Constraint.constr.Cconj (SymState.constr s) (Constraint.constr.Cneq se (Constraint.symbolic_expr.Slit (0 : ℤ))); let o3 : Constraint.t := SymState.sigma s; (Constraint.vars_in_constraint o2 ⊆ Svar.to_fset o1 ∧ (∀(x : Syntax.program_var) (v : Svar.svar), Constraint.get o3 x = Option.some v → v ∈ Svar.to_fset o1)) ∧ (∀(s1 : SymState.sym_state), SymState.sigma s1 = o3 ∧ SymState.constr s1 = o2 ∧ SymState.rho s1 = SymState.rho s ∧ SymState.vars s1 = o1 → (let o4 : Svar.set := SymState.vars s; let o5 : Constraint.constr := Constraint.constr.Cconj (SymState.constr s) (Constraint.constr.Ceq se (Constraint.symbolic_expr.Slit (0 : ℤ))); let o6 : Constraint.t := SymState.sigma s; (Constraint.vars_in_constraint o5 ⊆ Svar.to_fset o4 ∧ (∀(x : Syntax.program_var) (v : Svar.svar), Constraint.get o6 x = Option.some v → v ∈ Svar.to_fset o4)) ∧ (∀(s2 : SymState.sym_state), SymState.sigma s2 = o6 ∧ SymState.constr s2 = o5 ∧ SymState.rho s2 = SymState.rho s ∧ SymState.vars s2 = o4 → ((true = false → (∀(rho : Svar.svar -> ℤ), ¬Constraint.is_solution rho (SymState.constr s1))) → (match c with | Syntax.cmd.Cskip => False | Syntax.cmd.Cassign _ _ => False | Syntax.cmd.Cseq f f1 => f = c1 ∨ f1 = c1 | Syntax.cmd.Cif _ f f1 => f = c1 ∨ f1 = c1 | Syntax.cmd.Cwhile _ f => f = c1) ∧ (0 : ℤ) ≤ n) ∧ (∀(normals1 : SymStateSet.set) (unbounds1 : SymStateSet.set) (limits1 : SymStateSet.set), (∃(o7 : Bool), (o7 = false → (∀(rho : Svar.svar -> ℤ), ¬Constraint.is_solution rho (SymState.constr s1))) ∧ (if o7 = true then results_extend s1 (SymStateSet.to_fset normals1) (SymStateSet.to_fset unbounds1) (SymStateSet.to_fset limits1) ∧ (Constraint.is_solution (SymState.rho s1) (SymState.constr s1) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s1) (SymState.sigma s1)) c1 gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → Constraint.is_solution (SymState.rho s1) (SymState.constr s1) ∧ ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s1) (SymState.sigma s1)) c1 (compose (SymState.rho s') (SymState.sigma s')) bhv) else (SymStateSet.to_fset limits1 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset limits1)) = (0 : ℤ)) ∧ (SymStateSet.to_fset unbounds1 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset unbounds1)) = (0 : ℤ)) ∧ SymStateSet.to_fset normals1 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset normals1)) = (0 : ℤ))) → (true = false → (∀(rho : Svar.svar -> ℤ), ¬Constraint.is_solution rho (SymState.constr s2))) → (match c with | Syntax.cmd.Cskip => False | Syntax.cmd.Cassign _ _ => False | Syntax.cmd.Cseq f f1 => f = c2 ∨ f1 = c2 | Syntax.cmd.Cif _ f f1 => f = c2 ∨ f1 = c2 | Syntax.cmd.Cwhile _ f => f = c2) ∧ (0 : ℤ) ≤ n)))))) | Syntax.cmd.Cwhile e c1 => ((match c with | Syntax.cmd.Cskip => False | Syntax.cmd.Cassign _ _ => False | Syntax.cmd.Cseq f f1 => f = Syntax.cmd.Cwhile e c1 ∨ f1 = Syntax.cmd.Cwhile e c1 | Syntax.cmd.Cif _ f f1 => f = Syntax.cmd.Cwhile e c1 ∨ f1 = Syntax.cmd.Cwhile e c1 | Syntax.cmd.Cwhile _ f => f = Syntax.cmd.Cwhile e c1) ∨ c = Syntax.cmd.Cwhile e c1 ∧ (0 : ℤ) ≤ n + (1 : ℤ) ∧ n - (0 : ℤ) < n + (1 : ℤ)) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ n) ∧ (∀(normals : SymStateSet.set) (unbounds : SymStateSet.set) (limits : SymStateSet.set), (match c with | Syntax.cmd.Cskip => (SymStateSet.to_fset limits = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset limits)) = (0 : ℤ)) ∧ (SymStateSet.to_fset unbounds = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset unbounds)) = (0 : ℤ)) ∧ SymStateSet.to_fset normals = insert s (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset normals)) = (1 : ℤ) | Syntax.cmd.Cassign x e => (∃(se : Constraint.symbolic_expr), (ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e (ConcreteSemantics.expr_behaviour.Enormal (Constraint.interp_symbolic_expr (SymState.rho s) se)) ∧ (∀(v : Svar.svar), v ∈ Constraint.vars_in_symbolic_expr se → (∃(x1 : Syntax.program_var), Constraint.get (SymState.sigma s) x1 = Option.some v))) ∧ (∃(v' : Svar.svar), FreshSvar.is_fresh v' (Svar.to_fset (SymState.vars s)) ∧ (let o1 : Constraint.t := SymState.sigma s; let sigma' : Constraint.t := Constraint.set o1 x v'; (Constraint.get sigma' x = Option.some v' ∧ (∀(k' : Syntax.program_var), ¬k' = x → Constraint.get sigma' k' = Constraint.get o1 k')) ∧ (∃(constr' : Constraint.constr), (let constr : Constraint.constr := Constraint.constr.Cconj (SymState.constr s) (Constraint.constr.Ceq (Constraint.symbolic_expr.Svar v') se); (∃(v : Svar.svar), (match Constraint.get (SymState.sigma s) x with | Option.none => False | Option.some v1 => v = v1) ∧ (∀(rho : Svar.svar -> ℤ), Constraint.is_solution rho constr' = Constraint.is_solution rho (Constraint.constr.Cexists v constr)) ∧ Constraint.vars_in_constraint constr' ⊆ Constraint.vars_in_constraint (Constraint.constr.Cexists v constr)) ∨ Constraint.get (SymState.sigma s) x = Option.none ∧ constr' = constr) ∧ (let o2 : Svar.set := SymState.vars s; ∃(vars' : Svar.set), (Svar.to_fset vars' = insert v' (Svar.to_fset o2) ∧ (if v' ∈ Svar.to_fset o2 then Finset.card (Svar.to_fset vars') = Finset.card (Svar.to_fset o2) else Int.ofNat (Finset.card (Svar.to_fset vars')) = Int.ofNat (Finset.card (Svar.to_fset o2)) + (1 : ℤ))) ∧ (∃(s' : SymState.sym_state), (SymState.sigma s' = sigma' ∧ SymState.constr s' = constr' ∧ SymState.rho s' = Function.update (SymState.rho s) v' (Constraint.interp_symbolic_expr (SymState.rho s) se) ∧ SymState.vars s' = vars') ∧ (SymStateSet.to_fset limits = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset limits)) = (0 : ℤ)) ∧ (SymStateSet.to_fset unbounds = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset unbounds)) = (0 : ℤ)) ∧ SymStateSet.to_fset normals = insert s' (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset normals)) = (1 : ℤ))))))) ∨ ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e ConcreteSemantics.expr_behaviour.Eunbound_var ∧ (SymStateSet.to_fset limits = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset limits)) = (0 : ℤ)) ∧ (SymStateSet.to_fset unbounds = insert s (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset unbounds)) = (1 : ℤ)) ∧ SymStateSet.to_fset normals = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset normals)) = (0 : ℤ) | Syntax.cmd.Cseq c1 c2 => (∃(normals1 : SymStateSet.set) (unbounds1 : SymStateSet.set) (limits1 : SymStateSet.set), (results_extend s (SymStateSet.to_fset normals1) (SymStateSet.to_fset unbounds1) (SymStateSet.to_fset limits1) ∧ (Constraint.is_solution (SymState.rho s) (SymState.constr s) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s) (SymState.sigma s)) c1 gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → Constraint.is_solution (SymState.rho s) (SymState.constr s) ∧ ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s) (SymState.sigma s)) c1 (compose (SymState.rho s') (SymState.sigma s')) bhv)) ∧ (let o1 : List SymState.sym_state := SymStateSet.to_list normals1; (∀(e : SymState.sym_state), (e ∈ SymStateSet.to_fset normals1) = (e ∈ o1)) ∧ (∃(unbounds2 : SymStateSet.set) (limits2 : SymStateSet.set), ((∀(s' : SymState.sym_state), s' ∈ SymStateSet.to_fset normals ∨ s' ∈ SymStateSet.to_fset unbounds2 ∨ s' ∈ SymStateSet.to_fset limits2 → (∃(s1 : SymState.sym_state), s1 ∈ SymStateSet.to_fset (SymStateSet.of_list o1) ∧ state_extends s1 s')) ∧ (∀(s1 : SymState.sym_state), s1 ∈ SymStateSet.to_fset (SymStateSet.of_list o1) → Constraint.is_solution (SymState.rho s1) (SymState.constr s1) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s1) (SymState.sigma s1)) c2 gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds2 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits2) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds2 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits2) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → (∃(s1 : SymState.sym_state), s1 ∈ SymStateSet.to_fset (SymStateSet.of_list o1) ∧ Constraint.is_solution (SymState.rho s1) (SymState.constr s1) ∧ ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s1) (SymState.sigma s1)) c2 (compose (SymState.rho s') (SymState.sigma s')) bhv))) ∧ SymStateSet.to_fset limits = SymStateSet.to_fset limits1 ∪ SymStateSet.to_fset limits2 ∧ SymStateSet.to_fset unbounds = SymStateSet.to_fset unbounds1 ∪ SymStateSet.to_fset unbounds2))) | Syntax.cmd.Cif e c1 c2 => (∃(se : Constraint.symbolic_expr), (ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e (ConcreteSemantics.expr_behaviour.Enormal (Constraint.interp_symbolic_expr (SymState.rho s) se)) ∧ (∀(v : Svar.svar), v ∈ Constraint.vars_in_symbolic_expr se → (∃(x : Syntax.program_var), Constraint.get (SymState.sigma s) x = Option.some v))) ∧ (∃(s1 : SymState.sym_state), (SymState.sigma s1 = SymState.sigma s ∧ SymState.constr s1 = Constraint.constr.Cconj (SymState.constr s) (Constraint.constr.Cneq se (Constraint.symbolic_expr.Slit (0 : ℤ))) ∧ SymState.rho s1 = SymState.rho s ∧ SymState.vars s1 = SymState.vars s) ∧ (∃(s2 : SymState.sym_state), (SymState.sigma s2 = SymState.sigma s ∧ SymState.constr s2 = Constraint.constr.Cconj (SymState.constr s) (Constraint.constr.Ceq se (Constraint.symbolic_expr.Slit (0 : ℤ))) ∧ SymState.rho s2 = SymState.rho s ∧ SymState.vars s2 = SymState.vars s) ∧ (∃(normals1 : SymStateSet.set) (unbounds1 : SymStateSet.set) (limits1 : SymStateSet.set), (∃(o1 : Bool), (o1 = false → (∀(rho : Svar.svar -> ℤ), ¬Constraint.is_solution rho (SymState.constr s1))) ∧ (if o1 = true then results_extend s1 (SymStateSet.to_fset normals1) (SymStateSet.to_fset unbounds1) (SymStateSet.to_fset limits1) ∧ (Constraint.is_solution (SymState.rho s1) (SymState.constr s1) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s1) (SymState.sigma s1)) c1 gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → Constraint.is_solution (SymState.rho s1) (SymState.constr s1) ∧ ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s1) (SymState.sigma s1)) c1 (compose (SymState.rho s') (SymState.sigma s')) bhv) else (SymStateSet.to_fset limits1 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset limits1)) = (0 : ℤ)) ∧ (SymStateSet.to_fset unbounds1 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset unbounds1)) = (0 : ℤ)) ∧ SymStateSet.to_fset normals1 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset normals1)) = (0 : ℤ))) ∧ (∃(normals2 : SymStateSet.set) (unbounds2 : SymStateSet.set) (limits2 : SymStateSet.set), (∃(o1 : Bool), (o1 = false → (∀(rho : Svar.svar -> ℤ), ¬Constraint.is_solution rho (SymState.constr s2))) ∧ (if o1 = true then results_extend s2 (SymStateSet.to_fset normals2) (SymStateSet.to_fset unbounds2) (SymStateSet.to_fset limits2) ∧ (Constraint.is_solution (SymState.rho s2) (SymState.constr s2) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s2) (SymState.sigma s2)) c2 gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals2 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds2 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits2) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals2 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds2 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits2) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → Constraint.is_solution (SymState.rho s2) (SymState.constr s2) ∧ ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s2) (SymState.sigma s2)) c2 (compose (SymState.rho s') (SymState.sigma s')) bhv) else (SymStateSet.to_fset limits2 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset limits2)) = (0 : ℤ)) ∧ (SymStateSet.to_fset unbounds2 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset unbounds2)) = (0 : ℤ)) ∧ SymStateSet.to_fset normals2 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset normals2)) = (0 : ℤ))) ∧ SymStateSet.to_fset limits = SymStateSet.to_fset limits1 ∪ SymStateSet.to_fset limits2 ∧ SymStateSet.to_fset unbounds = SymStateSet.to_fset unbounds1 ∪ SymStateSet.to_fset unbounds2 ∧ SymStateSet.to_fset normals = SymStateSet.to_fset normals1 ∪ SymStateSet.to_fset normals2))))) ∨ ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e ConcreteSemantics.expr_behaviour.Eunbound_var ∧ (SymStateSet.to_fset limits = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset limits)) = (0 : ℤ)) ∧ (SymStateSet.to_fset unbounds = insert s (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset unbounds)) = (1 : ℤ)) ∧ SymStateSet.to_fset normals = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset normals)) = (0 : ℤ) | Syntax.cmd.Cwhile e c1 => results_extend s (SymStateSet.to_fset normals) (SymStateSet.to_fset unbounds) (SymStateSet.to_fset limits) ∧ (Constraint.is_solution (SymState.rho s) (SymState.constr s) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) (0 : ℤ) (compose (SymState.rho s) (SymState.sigma s)) e c1 gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → Constraint.is_solution (SymState.rho s) (SymState.constr s) ∧ ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) (0 : ℤ) (compose (SymState.rho s) (SymState.sigma s)) e c1 (compose (SymState.rho s') (SymState.sigma s')) bhv)) → results_extend s (SymStateSet.to_fset normals) (SymStateSet.to_fset unbounds) (SymStateSet.to_fset limits) ∧ (Constraint.is_solution (SymState.rho s) (SymState.constr s) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s) (SymState.sigma s)) c gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → Constraint.is_solution (SymState.rho s) (SymState.constr s) ∧ ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s) (SymState.sigma s)) c (compose (SymState.rho s') (SymState.sigma s')) bhv))
  := sorry
end imp_SymbolicInterpreter_symbolic_interp_cmdqtvc
