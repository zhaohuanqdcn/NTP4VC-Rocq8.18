theory all_distinct_AllDistinct_all_distinctqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref"
begin
theorem all_distinct'vc:
  fixes m :: "int"
  fixes a :: "int list"
  assumes fact0: "(0 :: int) \<le> m"
  assumes fact1: "\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length a) \<longrightarrow> (0 :: int) \<le> a ! nat i \<and> a ! nat i < m"
  shows "(0 :: int) \<le> m"
  and "\<forall>(dejavu :: bool list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < m \<longrightarrow> dejavu ! nat i = False) \<and> int (length dejavu) = m \<longrightarrow> (let o1 :: int = int (length a) - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < (0 :: int) \<longrightarrow> (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> \<not>i = j \<longrightarrow> \<not>a ! nat i = a ! nat j) \<and> (\<forall>(x :: int). (0 :: int) \<le> x \<and> x < m \<longrightarrow> dejavu ! nat x = True \<longleftrightarrow> (\<exists>(i :: int). ((0 :: int) \<le> i \<and> i < (0 :: int)) \<and> a ! nat i = x))) \<and> (\<forall>(dejavu1 :: bool list). length dejavu1 = length dejavu \<longrightarrow> (\<forall>(k :: int). ((0 :: int) \<le> k \<and> k \<le> o1) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < k \<longrightarrow> (0 :: int) \<le> j \<and> j < k \<longrightarrow> \<not>i = j \<longrightarrow> \<not>a ! nat i = a ! nat j) \<and> (\<forall>(x :: int). (0 :: int) \<le> x \<and> x < m \<longrightarrow> dejavu1 ! nat x = True \<longleftrightarrow> (\<exists>(i :: int). ((0 :: int) \<le> i \<and> i < k) \<and> a ! nat i = x)) \<longrightarrow> ((0 :: int) \<le> k \<and> k < int (length a)) \<and> (let v :: int = a ! nat k in ((0 :: int) \<le> v \<and> v < int (length dejavu1)) \<and> (if dejavu1 ! nat v = True then \<not>(\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < int (length a) \<longrightarrow> (0 :: int) \<le> j \<and> j < int (length a) \<longrightarrow> \<not>i = j \<longrightarrow> \<not>a ! nat i = a ! nat j) else let o2 :: bool = True in ((0 :: int) \<le> v \<and> v < int (length dejavu1)) \<and> (length (dejavu1[nat v := o2]) = length dejavu1 \<longrightarrow> nth (dejavu1[nat v := o2]) o nat = (nth dejavu1 o nat)(v := o2) \<longrightarrow> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < k + (1 :: int) \<longrightarrow> (0 :: int) \<le> j \<and> j < k + (1 :: int) \<longrightarrow> \<not>i = j \<longrightarrow> \<not>a ! nat i = a ! nat j) \<and> (\<forall>(x :: int). (0 :: int) \<le> x \<and> x < m \<longrightarrow> dejavu1[nat v := o2] ! nat x = True \<longleftrightarrow> (\<exists>(i :: int). ((0 :: int) \<le> i \<and> i < k + (1 :: int)) \<and> a ! nat i = x)))))) \<and> ((\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < o1 + (1 :: int) \<longrightarrow> (0 :: int) \<le> j \<and> j < o1 + (1 :: int) \<longrightarrow> \<not>i = j \<longrightarrow> \<not>a ! nat i = a ! nat j) \<and> (\<forall>(x :: int). (0 :: int) \<le> x \<and> x < m \<longrightarrow> dejavu1 ! nat x = True \<longleftrightarrow> (\<exists>(i :: int). ((0 :: int) \<le> i \<and> i < o1 + (1 :: int)) \<and> a ! nat i = x)) \<longrightarrow> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < int (length a) \<longrightarrow> (0 :: int) \<le> j \<and> j < int (length a) \<longrightarrow> \<not>i = j \<longrightarrow> \<not>a ! nat i = a ! nat j)))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < int (length a) \<longrightarrow> (0 :: int) \<le> j \<and> j < int (length a) \<longrightarrow> \<not>i = j \<longrightarrow> \<not>a ! nat i = a ! nat j)))"
  sorry
end
