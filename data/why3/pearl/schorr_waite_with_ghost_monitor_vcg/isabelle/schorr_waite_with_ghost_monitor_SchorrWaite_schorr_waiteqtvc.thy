theory schorr_waite_with_ghost_monitor_SchorrWaite_schorr_waiteqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "./schorr_waite_with_ghost_monitor_Memory" "./schorr_waite_with_ghost_monitor_GraphShape"
begin
theorem schorr_waite'vc:
  fixes root :: "loc"
  fixes graph :: "loc fset"
  fixes heap :: "memory"
  assumes fact0: "root |\<in>| graph"
  assumes fact1: "\<forall>(l :: loc). l |\<in>| graph \<and> \<not>l = null \<longrightarrow> left1 heap l |\<in>| graph \<and> right1 heap l |\<in>| graph"
  assumes fact2: "\<forall>(x :: loc). x |\<in>| graph \<longrightarrow> \<not>mark heap x = True"
  shows "\<forall>(p :: loc) (t :: loc) (pc :: int) (heap1 :: memory). (0 :: int) \<le> pc \<and> pc < (2 :: int) \<longrightarrow> (if pc = (0 :: int) then (pc = (0 :: int) \<longrightarrow> True) \<and> (pc = (1 :: int) \<and> \<not>(\<not>p = null \<or> \<not>t = null \<and> \<not>mark heap1 t = True) \<longrightarrow> (1 :: int) = (2 :: int) \<and> root = t \<and> null = p) \<and> (pc = (1 :: int) \<and> (\<not>p = null \<or> \<not>t = null \<and> \<not>mark heap1 t = True) \<longrightarrow> ((t = null \<or> mark heap1 t = True) \<and> color heap1 p = True \<longrightarrow> root = p \<and> null = right1 heap1 p \<and> update (right1 heap1) (right1 heap1) p t) \<and> ((t = null \<or> mark heap1 t = True) \<and> \<not>color heap1 p = True \<longrightarrow> null = p \<and> root = right1 heap1 p \<and> update (right1 heap1) (right1 heap1) null (left1 heap1 p) \<and> update (left1 heap1) (left1 heap1) null t \<and> update (color heap1) (color heap1) null True) \<and> (\<not>(t = null \<or> mark heap1 t = True) \<longrightarrow> null = t \<and> root = left1 heap1 t \<and> update (left1 heap1) (left1 heap1) t p \<and> update (mark heap1) (mark heap1) null True \<and> update (color heap1) (color heap1) null False)) else pc = (1 :: int) \<and> (\<forall>(o1 :: bool). (if \<not>p = null then o1 = True else if \<not>t = null then o1 = (if mark heap1 t = True then False else True) else o1 = False) \<longrightarrow> (if o1 = True then \<forall>(o2 :: bool). (if t = null then o2 = True else o2 = mark heap1 t) \<longrightarrow> (if o2 = True then \<not>p = null \<and> (if color heap1 p = True then \<not>p = null \<and> \<not>p = null \<and> (\<forall>(heap2 :: memory). left1 heap2 = left1 heap1 \<and> mark heap2 = mark heap1 \<and> color heap2 = color heap1 \<longrightarrow> update (right1 heap2) (right1 heap1) p t \<longrightarrow> (pc = (0 :: int) \<longrightarrow> p = root \<and> right1 heap1 p = null \<and> heap2 = heap1) \<and> (pc = (1 :: int) \<and> \<not>(\<not>p = null \<or> \<not>t = null \<and> \<not>mark heap1 t = True) \<longrightarrow> (1 :: int) = (2 :: int) \<and> p = t \<and> right1 heap1 p = p \<and> heap2 = heap1) \<and> (pc = (1 :: int) \<and> (\<not>p = null \<or> \<not>t = null \<and> \<not>mark heap1 t = True) \<longrightarrow> ((t = null \<or> mark heap1 t = True) \<and> color heap1 p = True \<longrightarrow> update (right1 heap2) (right1 heap1) p t \<and> left1 heap2 = left1 heap1 \<and> mark heap2 = mark heap1 \<and> color heap2 = color heap1) \<and> ((t = null \<or> mark heap1 t = True) \<and> \<not>color heap1 p = True \<longrightarrow> right1 heap1 p = p \<and> p = right1 heap1 p \<and> update (right1 heap2) (right1 heap1) (right1 heap1 p) (left1 heap1 p) \<and> update (left1 heap2) (left1 heap1) (right1 heap1 p) t \<and> update (color heap2) (color heap1) (right1 heap1 p) True \<and> mark heap2 = mark heap1) \<and> (\<not>(t = null \<or> mark heap1 t = True) \<longrightarrow> right1 heap1 p = t \<and> p = left1 heap1 t \<and> update (left1 heap2) (left1 heap1) t p \<and> update (mark heap2) (mark heap1) (right1 heap1 p) True \<and> update (color heap2) (color heap1) (right1 heap1 p) False \<and> right1 heap2 = right1 heap1))) else \<not>p = null \<and> \<not>p = null \<and> \<not>p = null \<and> (\<forall>(heap2 :: memory). left1 heap2 = left1 heap1 \<and> mark heap2 = mark heap1 \<and> color heap2 = color heap1 \<longrightarrow> update (right1 heap2) (right1 heap1) p (left1 heap1 p) \<longrightarrow> \<not>p = null \<and> (\<forall>(heap3 :: memory). right1 heap3 = right1 heap2 \<and> mark heap3 = mark heap2 \<and> color heap3 = color heap2 \<longrightarrow> update (left1 heap3) (left1 heap2) p t \<longrightarrow> \<not>p = null \<and> (\<forall>(heap4 :: memory). left1 heap4 = left1 heap3 \<and> right1 heap4 = right1 heap3 \<and> mark heap4 = mark heap3 \<longrightarrow> update (color heap4) (color heap3) p True \<longrightarrow> (pc = (0 :: int) \<longrightarrow> right1 heap1 p = root \<and> p = null \<and> heap4 = heap1) \<and> (pc = (1 :: int) \<and> \<not>(\<not>p = null \<or> \<not>t = null \<and> \<not>mark heap1 t = True) \<longrightarrow> (1 :: int) = (2 :: int) \<and> right1 heap1 p = t \<and> heap4 = heap1) \<and> (pc = (1 :: int) \<and> (\<not>p = null \<or> \<not>t = null \<and> \<not>mark heap1 t = True) \<longrightarrow> ((t = null \<or> mark heap1 t = True) \<and> color heap1 p = True \<longrightarrow> right1 heap1 p = p \<and> p = right1 heap1 p \<and> update (right1 heap4) (right1 heap1) p t \<and> left1 heap4 = left1 heap1 \<and> mark heap4 = mark heap1 \<and> color heap4 = color heap1) \<and> ((t = null \<or> mark heap1 t = True) \<and> \<not>color heap1 p = True \<longrightarrow> update (right1 heap4) (right1 heap1) p (left1 heap1 p) \<and> update (left1 heap4) (left1 heap1) p t \<and> update (color heap4) (color heap1) p True \<and> mark heap4 = mark heap1) \<and> (\<not>(t = null \<or> mark heap1 t = True) \<longrightarrow> p = t \<and> right1 heap1 p = left1 heap1 t \<and> update (left1 heap4) (left1 heap1) t p \<and> update (mark heap4) (mark heap1) p True \<and> update (color heap4) (color heap1) p False \<and> right1 heap4 = right1 heap1)))))) else \<not>t = null \<and> \<not>t = null \<and> (\<forall>(heap2 :: memory). right1 heap2 = right1 heap1 \<and> mark heap2 = mark heap1 \<and> color heap2 = color heap1 \<longrightarrow> update (left1 heap2) (left1 heap1) t p \<longrightarrow> \<not>t = null \<and> (\<forall>(heap3 :: memory). left1 heap3 = left1 heap2 \<and> right1 heap3 = right1 heap2 \<and> color heap3 = color heap2 \<longrightarrow> update (mark heap3) (mark heap2) t True \<longrightarrow> \<not>t = null \<and> (\<forall>(heap4 :: memory). left1 heap4 = left1 heap3 \<and> right1 heap4 = right1 heap3 \<and> mark heap4 = mark heap3 \<longrightarrow> update (color heap4) (color heap3) t False \<longrightarrow> (pc = (0 :: int) \<longrightarrow> left1 heap1 t = root \<and> t = null \<and> heap4 = heap1) \<and> (pc = (1 :: int) \<and> \<not>(\<not>p = null \<or> \<not>t = null \<and> \<not>mark heap1 t = True) \<longrightarrow> (1 :: int) = (2 :: int) \<and> left1 heap1 t = t \<and> t = p \<and> heap4 = heap1) \<and> (pc = (1 :: int) \<and> (\<not>p = null \<or> \<not>t = null \<and> \<not>mark heap1 t = True) \<longrightarrow> ((t = null \<or> mark heap1 t = True) \<and> color heap1 p = True \<longrightarrow> left1 heap1 t = p \<and> t = right1 heap1 p \<and> update (right1 heap4) (right1 heap1) p t \<and> left1 heap4 = left1 heap1 \<and> mark heap4 = mark heap1 \<and> color heap4 = color heap1) \<and> ((t = null \<or> mark heap1 t = True) \<and> \<not>color heap1 p = True \<longrightarrow> t = p \<and> left1 heap1 t = right1 heap1 p \<and> update (right1 heap4) (right1 heap1) t (left1 heap1 p) \<and> update (left1 heap4) (left1 heap1) t t \<and> update (color heap4) (color heap1) t True \<and> mark heap4 = mark heap1) \<and> (\<not>(t = null \<or> mark heap1 t = True) \<longrightarrow> update (left1 heap4) (left1 heap1) t p \<and> update (mark heap4) (mark heap1) t True \<and> update (color heap4) (color heap1) t False \<and> right1 heap4 = right1 heap1)))))) else (pc = (0 :: int) \<longrightarrow> (2 :: int) = (1 :: int) \<and> t = root \<and> p = null) \<and> (pc = (1 :: int) \<and> \<not>(\<not>p = null \<or> \<not>t = null \<and> \<not>mark heap1 t = True) \<longrightarrow> True) \<and> (pc = (1 :: int) \<and> (\<not>p = null \<or> \<not>t = null \<and> \<not>mark heap1 t = True) \<longrightarrow> (2 :: int) = (1 :: int) \<and> ((t = null \<or> mark heap1 t = True) \<and> color heap1 p = True \<longrightarrow> t = p \<and> p = right1 heap1 p \<and> update (right1 heap1) (right1 heap1) p t) \<and> ((t = null \<or> mark heap1 t = True) \<and> \<not>color heap1 p = True \<longrightarrow> t = right1 heap1 p \<and> update (right1 heap1) (right1 heap1) p (left1 heap1 p) \<and> update (left1 heap1) (left1 heap1) p t \<and> update (color heap1) (color heap1) p True) \<and> (\<not>(t = null \<or> mark heap1 t = True) \<longrightarrow> p = t \<and> t = left1 heap1 t \<and> update (left1 heap1) (left1 heap1) t p \<and> update (mark heap1) (mark heap1) p True \<and> update (color heap1) (color heap1) p False)))))"
  and "\<forall>(p :: loc) (t :: loc) (heap1 :: memory) (gray_nodes :: loc fset). t |\<in>| graph \<and> well_colored_on graph gray_nodes heap (mark heap1) \<and> (\<forall>(x :: loc). \<not>x = null \<and> \<not>mark heap1 x = True \<longrightarrow> left1 heap1 x = left1 heap x \<and> right1 heap1 x = right1 heap x) \<longrightarrow> (\<forall>(o1 :: bool). (if t = null then o1 = True else o1 = mark heap1 t) \<longrightarrow> (if o1 = True then unchanged_structure heap1 heap1 \<and> well_colored_on graph gray_nodes heap (mark heap1) \<and> (\<not>t = null \<longrightarrow> mark heap1 t = True) else let new_gray :: loc fset = finsert t gray_nodes in ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) < (2 :: int)) \<and> (\<forall>(p1 :: loc) (t1 :: loc) (pc :: int) (heap2 :: memory). ((1 :: int) = (0 :: int) \<longrightarrow> pc = (1 :: int) \<and> t1 = root \<and> p1 = null \<and> heap2 = heap1) \<and> (\<not>(\<not>p = null \<or> \<not>t = null \<and> \<not>mark heap1 t = True) \<longrightarrow> pc = (2 :: int) \<and> t1 = t \<and> p1 = p \<and> heap2 = heap1) \<and> (\<not>p = null \<or> \<not>t = null \<and> \<not>mark heap1 t = True \<longrightarrow> pc = (1 :: int) \<and> ((t = null \<or> mark heap1 t = True) \<and> color heap1 p = True \<longrightarrow> t1 = p \<and> p1 = right1 heap1 p \<and> update (right1 heap2) (right1 heap1) p t \<and> left1 heap2 = left1 heap1 \<and> mark heap2 = mark heap1 \<and> color heap2 = color heap1) \<and> ((t = null \<or> mark heap1 t = True) \<and> \<not>color heap1 p = True \<longrightarrow> p1 = p \<and> t1 = right1 heap1 p \<and> update (right1 heap2) (right1 heap1) p1 (left1 heap1 p) \<and> update (left1 heap2) (left1 heap1) p1 t \<and> update (color heap2) (color heap1) p1 True \<and> mark heap2 = mark heap1) \<and> (\<not>(t = null \<or> mark heap1 t = True) \<longrightarrow> p1 = t \<and> t1 = left1 heap1 t \<and> update (left1 heap2) (left1 heap1) t p \<and> update (mark heap2) (mark heap1) p1 True \<and> update (color heap2) (color heap1) p1 False \<and> right1 heap2 = right1 heap1)) \<longrightarrow> (((0 :: int) \<le> int (fcard graph) - int (fcard gray_nodes) \<and> int (fcard graph) - int (fcard new_gray) < int (fcard graph) - int (fcard gray_nodes)) \<and> pc = (1 :: int) \<and> t1 |\<in>| graph \<and> well_colored_on graph new_gray heap (mark heap2) \<and> (\<forall>(x :: loc). \<not>x = null \<and> \<not>mark heap2 x = True \<longrightarrow> left1 heap2 x = left1 heap x \<and> right1 heap2 x = right1 heap x)) \<and> (\<forall>(heap3 :: memory). unchanged_structure heap2 heap3 \<and> well_colored_on graph new_gray heap (mark heap3) \<and> (\<not>t1 = null \<longrightarrow> mark heap3 t1 = True) \<and> (\<forall>(x :: loc). \<not>x = null \<longrightarrow> \<not>path heap t1 x \<or> mark heap2 x = True \<longrightarrow> mark heap3 x = mark heap2 x \<and> color heap3 x = color heap2 x) \<longrightarrow> ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) < (2 :: int)) \<and> (\<forall>(p2 :: loc) (t2 :: loc) (pc1 :: int) (heap4 :: memory). ((1 :: int) = (0 :: int) \<longrightarrow> pc1 = (1 :: int) \<and> t2 = root \<and> p2 = null \<and> heap4 = heap3) \<and> (\<not>(\<not>p1 = null \<or> \<not>t1 = null \<and> \<not>mark heap3 t1 = True) \<longrightarrow> pc1 = (2 :: int) \<and> t2 = t1 \<and> p2 = p1 \<and> heap4 = heap3) \<and> (\<not>p1 = null \<or> \<not>t1 = null \<and> \<not>mark heap3 t1 = True \<longrightarrow> pc1 = (1 :: int) \<and> ((t1 = null \<or> mark heap3 t1 = True) \<and> color heap3 p1 = True \<longrightarrow> t2 = p1 \<and> p2 = right1 heap3 p1 \<and> update (right1 heap4) (right1 heap3) p1 t1 \<and> left1 heap4 = left1 heap3 \<and> mark heap4 = mark heap3 \<and> color heap4 = color heap3) \<and> ((t1 = null \<or> mark heap3 t1 = True) \<and> \<not>color heap3 p1 = True \<longrightarrow> p2 = p1 \<and> t2 = right1 heap3 p1 \<and> update (right1 heap4) (right1 heap3) p2 (left1 heap3 p1) \<and> update (left1 heap4) (left1 heap3) p2 t1 \<and> update (color heap4) (color heap3) p2 True \<and> mark heap4 = mark heap3) \<and> (\<not>(t1 = null \<or> mark heap3 t1 = True) \<longrightarrow> p2 = t1 \<and> t2 = left1 heap3 t1 \<and> update (left1 heap4) (left1 heap3) t1 p1 \<and> update (mark heap4) (mark heap3) p2 True \<and> update (color heap4) (color heap3) p2 False \<and> right1 heap4 = right1 heap3)) \<longrightarrow> (((0 :: int) \<le> int (fcard graph) - int (fcard gray_nodes) \<and> int (fcard graph) - int (fcard new_gray) < int (fcard graph) - int (fcard gray_nodes)) \<and> pc1 = (1 :: int) \<and> t2 |\<in>| graph \<and> well_colored_on graph new_gray heap (mark heap4) \<and> (\<forall>(x :: loc). \<not>x = null \<and> \<not>mark heap4 x = True \<longrightarrow> left1 heap4 x = left1 heap x \<and> right1 heap4 x = right1 heap x)) \<and> (\<forall>(heap5 :: memory). unchanged_structure heap4 heap5 \<and> well_colored_on graph new_gray heap (mark heap5) \<and> (\<not>t2 = null \<longrightarrow> mark heap5 t2 = True) \<and> (\<forall>(x :: loc). \<not>x = null \<longrightarrow> \<not>path heap t2 x \<or> mark heap4 x = True \<longrightarrow> mark heap5 x = mark heap4 x \<and> color heap5 x = color heap4 x) \<longrightarrow> ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) < (2 :: int)) \<and> (\<forall>(p3 :: loc) (t3 :: loc) (pc2 :: int) (heap6 :: memory). ((1 :: int) = (0 :: int) \<longrightarrow> pc2 = (1 :: int) \<and> t3 = root \<and> p3 = null \<and> heap6 = heap5) \<and> (\<not>(\<not>p2 = null \<or> \<not>t2 = null \<and> \<not>mark heap5 t2 = True) \<longrightarrow> pc2 = (2 :: int) \<and> t3 = t2 \<and> p3 = p2 \<and> heap6 = heap5) \<and> (\<not>p2 = null \<or> \<not>t2 = null \<and> \<not>mark heap5 t2 = True \<longrightarrow> pc2 = (1 :: int) \<and> ((t2 = null \<or> mark heap5 t2 = True) \<and> color heap5 p2 = True \<longrightarrow> t3 = p2 \<and> p3 = right1 heap5 p2 \<and> update (right1 heap6) (right1 heap5) p2 t2 \<and> left1 heap6 = left1 heap5 \<and> mark heap6 = mark heap5 \<and> color heap6 = color heap5) \<and> ((t2 = null \<or> mark heap5 t2 = True) \<and> \<not>color heap5 p2 = True \<longrightarrow> p3 = p2 \<and> t3 = right1 heap5 p2 \<and> update (right1 heap6) (right1 heap5) p3 (left1 heap5 p2) \<and> update (left1 heap6) (left1 heap5) p3 t2 \<and> update (color heap6) (color heap5) p3 True \<and> mark heap6 = mark heap5) \<and> (\<not>(t2 = null \<or> mark heap5 t2 = True) \<longrightarrow> p3 = t2 \<and> t3 = left1 heap5 t2 \<and> update (left1 heap6) (left1 heap5) t2 p2 \<and> update (mark heap6) (mark heap5) p3 True \<and> update (color heap6) (color heap5) p3 False \<and> right1 heap6 = right1 heap5)) \<longrightarrow> pc2 = (1 :: int) \<and> (t3 = t \<and> p3 = p) \<and> unchanged_structure heap1 heap6 \<and> well_colored_on graph gray_nodes heap (mark heap6) \<and> (\<not>t3 = null \<longrightarrow> mark heap6 t3 = True) \<and> (\<forall>(x :: loc). \<not>x = null \<longrightarrow> \<not>path heap t3 x \<or> mark heap1 x = True \<longrightarrow> mark heap6 x = mark heap1 x \<and> color heap6 x = color heap1 x))))))))"
  and "(0 :: int) \<le> (0 :: int)"
  and "(0 :: int) < (2 :: int)"
  and "((0 :: int) = (1 :: int) \<longrightarrow> (1 :: int) = (2 :: int) \<and> root = null) \<longrightarrow> (let o1 :: loc fset = fempty in (root |\<in>| graph \<and> well_colored_on graph o1 heap (mark heap) \<and> (\<forall>(x :: loc). \<not>x = null \<and> \<not>mark heap x = True \<longrightarrow> True)) \<and> (\<forall>(heap1 :: memory). unchanged_structure heap heap1 \<and> well_colored_on graph o1 heap (mark heap1) \<and> (\<not>root = null \<longrightarrow> mark heap1 root = True) \<and> (\<forall>(x :: loc). \<not>x = null \<longrightarrow> \<not>path heap root x \<or> mark heap x = True \<longrightarrow> mark heap1 x = mark heap x \<and> color heap1 x = color heap x) \<longrightarrow> ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) < (2 :: int)) \<and> (\<forall>(p :: loc) (t :: loc) (pc :: int) (heap2 :: memory). ((1 :: int) = (0 :: int) \<longrightarrow> pc = (1 :: int) \<and> t = root \<and> p = null \<and> heap2 = heap1) \<and> (\<not>(\<not>True \<or> \<not>root = null \<and> \<not>mark heap1 root = True) \<longrightarrow> pc = (2 :: int) \<and> t = root \<and> p = null \<and> heap2 = heap1) \<and> (\<not>True \<or> \<not>root = null \<and> \<not>mark heap1 root = True \<longrightarrow> pc = (1 :: int) \<and> ((root = null \<or> mark heap1 root = True) \<and> color heap1 null = True \<longrightarrow> t = null \<and> p = right1 heap1 null \<and> update (right1 heap2) (right1 heap1) null root \<and> left1 heap2 = left1 heap1 \<and> mark heap2 = mark heap1 \<and> color heap2 = color heap1) \<and> ((root = null \<or> mark heap1 root = True) \<and> \<not>color heap1 null = True \<longrightarrow> p = null \<and> t = right1 heap1 null \<and> update (right1 heap2) (right1 heap1) p (left1 heap1 null) \<and> update (left1 heap2) (left1 heap1) p root \<and> update (color heap2) (color heap1) p True \<and> mark heap2 = mark heap1) \<and> (\<not>(root = null \<or> mark heap1 root = True) \<longrightarrow> p = root \<and> t = left1 heap1 root \<and> update (left1 heap2) (left1 heap1) root null \<and> update (mark heap2) (mark heap1) p True \<and> update (color heap2) (color heap1) p False \<and> right1 heap2 = right1 heap1)) \<longrightarrow> unchanged_structure heap heap2 \<and> (\<forall>(x :: loc). path heap root x \<and> \<not>x = null \<longrightarrow> mark heap2 x = True) \<and> (\<forall>(x :: loc). \<not>path heap root x \<and> \<not>x = null \<longrightarrow> mark heap2 x = mark heap x))))"
  sorry
end
