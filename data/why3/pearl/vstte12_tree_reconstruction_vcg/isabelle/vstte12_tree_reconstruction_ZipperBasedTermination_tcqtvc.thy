theory vstte12_tree_reconstruction_ZipperBasedTermination_tcqtvc
  imports "NTP4Verif.NTP4Verif" "./vstte12_tree_reconstruction_Tree"
begin
theorem tc'vc:
  fixes right1 :: "(int \<times> tree) list"
  fixes left1 :: "(int \<times> tree) list"
  shows "case right1 of Nil \<Rightarrow> True | Cons x x1 \<Rightarrow> (case x1 of Nil \<Rightarrow> (case x of (x2, x3) \<Rightarrow> (case left1 of Nil \<Rightarrow> True | Cons x4 x5 \<Rightarrow> (case x4 of (x6, x7) \<Rightarrow> (if x6 = x2 then let o1 :: (int \<times> tree) list = Cons (x6 - (1 :: int), Node x7 x3) x1 in (0 :: int) \<le> int (length left1) + int (length right1) \<and> int (length x5) + int (length o1) < int (length left1) + int (length right1) \<or> int (length left1) + int (length right1) = int (length x5) + int (length o1) \<and> (0 :: int) \<le> int (length right1) \<and> length o1 < length right1 else let o1 :: (int \<times> tree) list = Cons (x2, x3) left1 in (0 :: int) \<le> int (length left1) + int (length right1) \<and> int (length o1) + int (length x1) < int (length left1) + int (length right1) \<or> int (length left1) + int (length right1) = int (length o1) + int (length x1) \<and> (0 :: int) \<le> int (length right1) \<and> length x1 < length right1)))) | _ \<Rightarrow> (case x of (x2, x3) \<Rightarrow> (case left1 of Nil \<Rightarrow> (let o1 :: (int \<times> tree) list = Cons (x2, x3) (Nil :: (int \<times> tree) list) in (0 :: int) \<le> int (length left1) + int (length right1) \<and> int (length o1) + int (length x1) < int (length left1) + int (length right1) \<or> int (length left1) + int (length right1) = int (length o1) + int (length x1) \<and> (0 :: int) \<le> int (length right1) \<and> length x1 < length right1) | Cons x4 x5 \<Rightarrow> (case x4 of (x6, x7) \<Rightarrow> (if x6 = x2 then let o1 :: (int \<times> tree) list = Cons (x6 - (1 :: int), Node x7 x3) x1 in (0 :: int) \<le> int (length left1) + int (length right1) \<and> int (length x5) + int (length o1) < int (length left1) + int (length right1) \<or> int (length left1) + int (length right1) = int (length x5) + int (length o1) \<and> (0 :: int) \<le> int (length right1) \<and> length o1 < length right1 else let o1 :: (int \<times> tree) list = Cons (x2, x3) left1 in (0 :: int) \<le> int (length left1) + int (length right1) \<and> int (length o1) + int (length x1) < int (length left1) + int (length right1) \<or> int (length left1) + int (length right1) = int (length o1) + int (length x1) \<and> (0 :: int) \<le> int (length right1) \<and> length x1 < length right1)))))"
  sorry
end
