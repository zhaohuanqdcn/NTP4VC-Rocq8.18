import Why3.Base
import Why3.why3.Ref.Ref
import pearl.edit_distance_vcg.lean.edit_distance.MyWord
open Classical
open Lean4Why3
namespace edit_distance_EditDistance_distanceqtvc
axiom suffix : List MyWord.char -> ℤ -> List MyWord.char
axiom suffix_nil (a : List MyWord.char) : suffix a (Int.ofNat (List.length a)) = ([] : List MyWord.char)
axiom suffix_cons (i : ℤ) (a : List MyWord.char) (fact0 : (0 : ℤ) ≤ i) (fact1 : i < Int.ofNat (List.length a)) : suffix a i = List.cons (a[Int.toNat i]!) (suffix a (i + (1 : ℤ)))
noncomputable def min_suffix (a1 : List MyWord.char) (a2 : List MyWord.char) (i : ℤ) (j : ℤ) (n : ℤ) := MyWord.min_dist (suffix a1 i) (suffix a2 j) n
theorem distance'vc (w1 : List MyWord.char) (w2 : List MyWord.char) : let n1 : ℤ := Int.ofNat (List.length w1); let n2 : ℤ := Int.ofNat (List.length w2); let o1 : ℤ := n2 + (1 : ℤ); (0 : ℤ) ≤ o1 ∧ (∀(t : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o1 → t[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length t) = o1 → ((0 : ℤ) ≤ n2 + (1 : ℤ) → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → t[Int.toNat j]! = n2 - j) ∧ (∀(t1 : List ℤ), List.length t1 = List.length t → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ n2) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → t1[Int.toNat j]! = n2 - j) → (let o2 : ℤ := n2 - i; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length t1)) ∧ (List.length (List.set t1 (Int.toNat i) o2) = List.length t1 → getElem! (List.set t1 (Int.toNat i) o2) ∘ Int.toNat = Function.update (getElem! t1 ∘ Int.toNat) i o2 → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → (List.set t1 (Int.toNat i) o2)[Int.toNat j]! = n2 - j)))) ∧ ((∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < n2 + (1 : ℤ) → t1[Int.toNat j]! = n2 - j) → (let o2 : ℤ := n1 - (1 : ℤ); ((0 : ℤ) - (1 : ℤ) ≤ o2 → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ n2 → min_suffix w1 w2 (o2 + (1 : ℤ)) j (t1[Int.toNat j]!)) ∧ (∀(t2 : List ℤ), List.length t2 = List.length t1 → (∀(i : ℤ), (i ≤ o2 ∧ (0 : ℤ) ≤ i) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ n2 → min_suffix w1 w2 (i + (1 : ℤ)) j (t2[Int.toNat j]!)) → ((0 : ℤ) ≤ n2 ∧ n2 < Int.ofNat (List.length t2)) ∧ ((0 : ℤ) ≤ n2 ∧ n2 < Int.ofNat (List.length t2)) ∧ (let o3 : ℤ := t2[Int.toNat n2]! + (1 : ℤ); ((0 : ℤ) ≤ n2 ∧ n2 < Int.ofNat (List.length t2)) ∧ (List.length (List.set t2 (Int.toNat n2) o3) = List.length t2 → getElem! (List.set t2 (Int.toNat n2) o3) ∘ Int.toNat = Function.update (getElem! t2 ∘ Int.toNat) n2 o3 → (let o4 : ℤ := n2 - (1 : ℤ); ((0 : ℤ) - (1 : ℤ) ≤ o4 → ((∀(k : ℤ), o4 < k ∧ k ≤ n2 → min_suffix w1 w2 i k ((List.set t2 (Int.toNat n2) o3)[Int.toNat k]!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k ≤ o4 → min_suffix w1 w2 (i + (1 : ℤ)) k ((List.set t2 (Int.toNat n2) o3)[Int.toNat k]!)) ∧ min_suffix w1 w2 (i + (1 : ℤ)) (o4 + (1 : ℤ)) (t2[Int.toNat n2]!)) ∧ (∀(oldt : ℤ) (t3 : List ℤ), List.length t3 = List.length (List.set t2 (Int.toNat n2) o3) → (∀(j : ℤ), (j ≤ o4 ∧ (0 : ℤ) ≤ j) ∧ (∀(k : ℤ), j < k ∧ k ≤ n2 → min_suffix w1 w2 i k (t3[Int.toNat k]!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j → min_suffix w1 w2 (i + (1 : ℤ)) k (t3[Int.toNat k]!)) ∧ min_suffix w1 w2 (i + (1 : ℤ)) (j + (1 : ℤ)) oldt → ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length t3)) ∧ ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length w2)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length w1)) ∧ (if w1[Int.toNat i]! = w2[Int.toNat j]! then ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length t3)) ∧ (List.length (List.set t3 (Int.toNat j) oldt) = List.length t3 → getElem! (List.set t3 (Int.toNat j) oldt) ∘ Int.toNat = Function.update (getElem! t3 ∘ Int.toNat) j oldt → (∀(k : ℤ), j - (1 : ℤ) < k ∧ k ≤ n2 → min_suffix w1 w2 i k ((List.set t3 (Int.toNat j) oldt)[Int.toNat k]!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j - (1 : ℤ) → min_suffix w1 w2 (i + (1 : ℤ)) k ((List.set t3 (Int.toNat j) oldt)[Int.toNat k]!)) ∧ min_suffix w1 w2 (i + (1 : ℤ)) (j - (1 : ℤ) + (1 : ℤ)) (t3[Int.toNat j]!)) else let o5 : ℤ := j + (1 : ℤ); ((0 : ℤ) ≤ o5 ∧ o5 < Int.ofNat (List.length t3)) ∧ ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length t3)) ∧ (let o6 : ℤ := min (t3[Int.toNat j]!) (t3[Int.toNat o5]!) + (1 : ℤ); ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length t3)) ∧ (List.length (List.set t3 (Int.toNat j) o6) = List.length t3 → getElem! (List.set t3 (Int.toNat j) o6) ∘ Int.toNat = Function.update (getElem! t3 ∘ Int.toNat) j o6 → (∀(k : ℤ), j - (1 : ℤ) < k ∧ k ≤ n2 → min_suffix w1 w2 i k ((List.set t3 (Int.toNat j) o6)[Int.toNat k]!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j - (1 : ℤ) → min_suffix w1 w2 (i + (1 : ℤ)) k ((List.set t3 (Int.toNat j) o6)[Int.toNat k]!)) ∧ min_suffix w1 w2 (i + (1 : ℤ)) (j - (1 : ℤ) + (1 : ℤ)) (t3[Int.toNat j]!))))) ∧ ((∀(k : ℤ), (0 : ℤ) - (1 : ℤ) < k ∧ k ≤ n2 → min_suffix w1 w2 i k (t3[Int.toNat k]!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k ≤ (0 : ℤ) - (1 : ℤ) → min_suffix w1 w2 (i + (1 : ℤ)) k (t3[Int.toNat k]!)) ∧ min_suffix w1 w2 (i + (1 : ℤ)) ((0 : ℤ) - (1 : ℤ) + (1 : ℤ)) oldt → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ n2 → min_suffix w1 w2 (i - (1 : ℤ) + (1 : ℤ)) j (t3[Int.toNat j]!))))) ∧ (o4 < (0 : ℤ) - (1 : ℤ) → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ n2 → min_suffix w1 w2 (i - (1 : ℤ) + (1 : ℤ)) j ((List.set t2 (Int.toNat n2) o3)[Int.toNat j]!))))))) ∧ ((∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ n2 → min_suffix w1 w2 ((0 : ℤ) - (1 : ℤ) + (1 : ℤ)) j (t2[Int.toNat j]!)) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length t2)) ∧ MyWord.min_dist (suffix w1 (0 : ℤ)) (suffix w2 (0 : ℤ)) (t2[(0 : ℕ)]!)))) ∧ (o2 < (0 : ℤ) - (1 : ℤ) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length t1)) ∧ MyWord.min_dist (suffix w1 (0 : ℤ)) (suffix w2 (0 : ℤ)) (t1[(0 : ℕ)]!)))))) ∧ (n2 + (1 : ℤ) < (0 : ℤ) → (let o2 : ℤ := n1 - (1 : ℤ); ((0 : ℤ) - (1 : ℤ) ≤ o2 → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ n2 → min_suffix w1 w2 (o2 + (1 : ℤ)) j (t[Int.toNat j]!)) ∧ (∀(t1 : List ℤ), List.length t1 = List.length t → (∀(i : ℤ), (i ≤ o2 ∧ (0 : ℤ) ≤ i) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ n2 → min_suffix w1 w2 (i + (1 : ℤ)) j (t1[Int.toNat j]!)) → ((0 : ℤ) ≤ n2 ∧ n2 < Int.ofNat (List.length t1)) ∧ ((0 : ℤ) ≤ n2 ∧ n2 < Int.ofNat (List.length t1)) ∧ (let o3 : ℤ := t1[Int.toNat n2]! + (1 : ℤ); ((0 : ℤ) ≤ n2 ∧ n2 < Int.ofNat (List.length t1)) ∧ (List.length (List.set t1 (Int.toNat n2) o3) = List.length t1 → getElem! (List.set t1 (Int.toNat n2) o3) ∘ Int.toNat = Function.update (getElem! t1 ∘ Int.toNat) n2 o3 → (let o4 : ℤ := n2 - (1 : ℤ); ((0 : ℤ) - (1 : ℤ) ≤ o4 → ((∀(k : ℤ), o4 < k ∧ k ≤ n2 → min_suffix w1 w2 i k ((List.set t1 (Int.toNat n2) o3)[Int.toNat k]!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k ≤ o4 → min_suffix w1 w2 (i + (1 : ℤ)) k ((List.set t1 (Int.toNat n2) o3)[Int.toNat k]!)) ∧ min_suffix w1 w2 (i + (1 : ℤ)) (o4 + (1 : ℤ)) (t1[Int.toNat n2]!)) ∧ (∀(oldt : ℤ) (t2 : List ℤ), List.length t2 = List.length (List.set t1 (Int.toNat n2) o3) → (∀(j : ℤ), (j ≤ o4 ∧ (0 : ℤ) ≤ j) ∧ (∀(k : ℤ), j < k ∧ k ≤ n2 → min_suffix w1 w2 i k (t2[Int.toNat k]!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j → min_suffix w1 w2 (i + (1 : ℤ)) k (t2[Int.toNat k]!)) ∧ min_suffix w1 w2 (i + (1 : ℤ)) (j + (1 : ℤ)) oldt → ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length t2)) ∧ ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length w2)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length w1)) ∧ (if w1[Int.toNat i]! = w2[Int.toNat j]! then ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length t2)) ∧ (List.length (List.set t2 (Int.toNat j) oldt) = List.length t2 → getElem! (List.set t2 (Int.toNat j) oldt) ∘ Int.toNat = Function.update (getElem! t2 ∘ Int.toNat) j oldt → (∀(k : ℤ), j - (1 : ℤ) < k ∧ k ≤ n2 → min_suffix w1 w2 i k ((List.set t2 (Int.toNat j) oldt)[Int.toNat k]!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j - (1 : ℤ) → min_suffix w1 w2 (i + (1 : ℤ)) k ((List.set t2 (Int.toNat j) oldt)[Int.toNat k]!)) ∧ min_suffix w1 w2 (i + (1 : ℤ)) (j - (1 : ℤ) + (1 : ℤ)) (t2[Int.toNat j]!)) else let o5 : ℤ := j + (1 : ℤ); ((0 : ℤ) ≤ o5 ∧ o5 < Int.ofNat (List.length t2)) ∧ ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length t2)) ∧ (let o6 : ℤ := min (t2[Int.toNat j]!) (t2[Int.toNat o5]!) + (1 : ℤ); ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length t2)) ∧ (List.length (List.set t2 (Int.toNat j) o6) = List.length t2 → getElem! (List.set t2 (Int.toNat j) o6) ∘ Int.toNat = Function.update (getElem! t2 ∘ Int.toNat) j o6 → (∀(k : ℤ), j - (1 : ℤ) < k ∧ k ≤ n2 → min_suffix w1 w2 i k ((List.set t2 (Int.toNat j) o6)[Int.toNat k]!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j - (1 : ℤ) → min_suffix w1 w2 (i + (1 : ℤ)) k ((List.set t2 (Int.toNat j) o6)[Int.toNat k]!)) ∧ min_suffix w1 w2 (i + (1 : ℤ)) (j - (1 : ℤ) + (1 : ℤ)) (t2[Int.toNat j]!))))) ∧ ((∀(k : ℤ), (0 : ℤ) - (1 : ℤ) < k ∧ k ≤ n2 → min_suffix w1 w2 i k (t2[Int.toNat k]!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k ≤ (0 : ℤ) - (1 : ℤ) → min_suffix w1 w2 (i + (1 : ℤ)) k (t2[Int.toNat k]!)) ∧ min_suffix w1 w2 (i + (1 : ℤ)) ((0 : ℤ) - (1 : ℤ) + (1 : ℤ)) oldt → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ n2 → min_suffix w1 w2 (i - (1 : ℤ) + (1 : ℤ)) j (t2[Int.toNat j]!))))) ∧ (o4 < (0 : ℤ) - (1 : ℤ) → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ n2 → min_suffix w1 w2 (i - (1 : ℤ) + (1 : ℤ)) j ((List.set t1 (Int.toNat n2) o3)[Int.toNat j]!))))))) ∧ ((∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ n2 → min_suffix w1 w2 ((0 : ℤ) - (1 : ℤ) + (1 : ℤ)) j (t1[Int.toNat j]!)) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length t1)) ∧ MyWord.min_dist (suffix w1 (0 : ℤ)) (suffix w2 (0 : ℤ)) (t1[(0 : ℕ)]!)))) ∧ (o2 < (0 : ℤ) - (1 : ℤ) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length t)) ∧ MyWord.min_dist (suffix w1 (0 : ℤ)) (suffix w2 (0 : ℤ)) (t[(0 : ℕ)]!)))))
  := sorry
end edit_distance_EditDistance_distanceqtvc
