import Why3.Base
import Why3.why3.Ref.Ref
import pearl.koda_ruskey_vcg.lean.koda_ruskey.KodaRuskey_Spec
import pearl.koda_ruskey_vcg.lean.koda_ruskey.Lemmas
open Classical
open Lean4Why3
namespace koda_ruskey_KodaRuskey_enumqtvc
theorem enum'vc (f0 : KodaRuskey_Spec.forest) (bits : List KodaRuskey_Spec.color) (st : List KodaRuskey_Spec.forest) (visited : List (ℤ -> KodaRuskey_Spec.color)) (fact0 : KodaRuskey_Spec.size_forest f0 = Int.ofNat (List.length bits)) (fact1 : KodaRuskey_Spec.valid_nums_forest f0 (Int.ofNat (List.length bits))) (fact2 : Lemmas.sub st f0 (getElem! bits ∘ Int.toNat)) (fact3 : ¬st = ([] : List KodaRuskey_Spec.forest)) (fact4 : Lemmas.any_stack st (getElem! bits ∘ Int.toNat)) (fact5 : KodaRuskey_Spec.valid_coloring f0 (getElem! bits ∘ Int.toNat)) : match st with | ([] : List KodaRuskey_Spec.forest) => False | List.cons KodaRuskey_Spec.forest.E st' => (match st' with | ([] : List KodaRuskey_Spec.forest) => (let o1 : ℤ -> KodaRuskey_Spec.color := getElem! bits ∘ Int.toNat; let o2 : List (ℤ -> KodaRuskey_Spec.color) := visited ++ [o1]; Int.ofNat (List.length o2) = (1 : ℤ) + Int.ofNat (List.length visited) ∧ o2[List.length visited]! = o1 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length visited) → o2[Int.toNat i]! = visited[Int.toNat i]!) → Lemmas.inverse st (getElem! bits ∘ Int.toNat) (getElem! bits ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! bits ∘ Int.toNat) ∧ Lemmas.stored_solutions f0 (getElem! bits ∘ Int.toNat) st visited o2) | _ => (((0 : ℤ) ≤ Lemmas.size_stack st ∧ Lemmas.size_stack st' < Lemmas.size_stack st ∨ Lemmas.size_stack st = Lemmas.size_stack st' ∧ (match st with | ([] : List KodaRuskey_Spec.forest) => False | List.cons _ f => f = st')) ∧ KodaRuskey_Spec.size_forest f0 = Int.ofNat (List.length bits) ∧ KodaRuskey_Spec.valid_nums_forest f0 (Int.ofNat (List.length bits)) ∧ Lemmas.sub st' f0 (getElem! bits ∘ Int.toNat) ∧ ¬st' = ([] : List KodaRuskey_Spec.forest) ∧ Lemmas.any_stack st' (getElem! bits ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! bits ∘ Int.toNat)) ∧ (∀(bits1 : List KodaRuskey_Spec.color) (visited1 : List (ℤ -> KodaRuskey_Spec.color)), List.length bits1 = List.length bits → (∀(i : ℤ), ¬Lemmas.mem_stack i st' → bits1[Int.toNat i]! = bits[Int.toNat i]!) ∧ Lemmas.inverse st' (getElem! bits ∘ Int.toNat) (getElem! bits1 ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! bits1 ∘ Int.toNat) ∧ Lemmas.stored_solutions f0 (getElem! bits1 ∘ Int.toNat) st' visited visited1 → (∀(i : ℤ), ¬Lemmas.mem_stack i st → bits1[Int.toNat i]! = bits[Int.toNat i]!) ∧ Lemmas.inverse st (getElem! bits ∘ Int.toNat) (getElem! bits1 ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! bits1 ∘ Int.toNat) ∧ Lemmas.stored_solutions f0 (getElem! bits1 ∘ Int.toNat) st visited visited1)) | List.cons f@(KodaRuskey_Spec.forest.N i f1 f2) st' => ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length bits)) ∧ (if bits[Int.toNat i]! = KodaRuskey_Spec.color.White then let o1 : List KodaRuskey_Spec.forest := List.cons f2 st'; (((0 : ℤ) ≤ Lemmas.size_stack st ∧ Lemmas.size_stack o1 < Lemmas.size_stack st ∨ Lemmas.size_stack st = Lemmas.size_stack o1 ∧ (match st with | ([] : List KodaRuskey_Spec.forest) => False | List.cons _ f3 => f3 = o1)) ∧ KodaRuskey_Spec.size_forest f0 = Int.ofNat (List.length bits) ∧ KodaRuskey_Spec.valid_nums_forest f0 (Int.ofNat (List.length bits)) ∧ Lemmas.sub o1 f0 (getElem! bits ∘ Int.toNat) ∧ Lemmas.any_stack o1 (getElem! bits ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! bits ∘ Int.toNat)) ∧ (∀(bits1 : List KodaRuskey_Spec.color) (visited1 : List (ℤ -> KodaRuskey_Spec.color)), List.length bits1 = List.length bits → (∀(i1 : ℤ), ¬Lemmas.mem_stack i1 o1 → bits1[Int.toNat i1]! = bits[Int.toNat i1]!) ∧ Lemmas.inverse o1 (getElem! bits ∘ Int.toNat) (getElem! bits1 ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! bits1 ∘ Int.toNat) ∧ Lemmas.stored_solutions f0 (getElem! bits1 ∘ Int.toNat) o1 visited visited1 → (let o2 : KodaRuskey_Spec.color := KodaRuskey_Spec.color.Black; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length bits1)) ∧ (List.length (List.set bits1 (Int.toNat i) o2) = List.length bits1 → getElem! (List.set bits1 (Int.toNat i) o2) ∘ Int.toNat = Function.update (getElem! bits1 ∘ Int.toNat) i o2 → (let o3 : List KodaRuskey_Spec.forest := List.cons f1 (List.cons f2 st'); (((0 : ℤ) ≤ Lemmas.size_stack st ∧ Lemmas.size_stack o3 < Lemmas.size_stack st ∨ Lemmas.size_stack st = Lemmas.size_stack o3 ∧ (match st with | ([] : List KodaRuskey_Spec.forest) => False | List.cons _ f3 => f3 = o3)) ∧ KodaRuskey_Spec.size_forest f0 = Int.ofNat (List.length (List.set bits1 (Int.toNat i) o2)) ∧ KodaRuskey_Spec.valid_nums_forest f0 (Int.ofNat (List.length (List.set bits1 (Int.toNat i) o2))) ∧ Lemmas.sub o3 f0 (getElem! (List.set bits1 (Int.toNat i) o2) ∘ Int.toNat) ∧ Lemmas.any_stack o3 (getElem! (List.set bits1 (Int.toNat i) o2) ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! (List.set bits1 (Int.toNat i) o2) ∘ Int.toNat)) ∧ (∀(bits2 : List KodaRuskey_Spec.color) (visited2 : List (ℤ -> KodaRuskey_Spec.color)), List.length bits2 = List.length (List.set bits1 (Int.toNat i) o2) → (∀(i1 : ℤ), ¬Lemmas.mem_stack i1 o3 → bits2[Int.toNat i1]! = (List.set bits1 (Int.toNat i) o2)[Int.toNat i1]!) ∧ Lemmas.inverse o3 (getElem! (List.set bits1 (Int.toNat i) o2) ∘ Int.toNat) (getElem! bits2 ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! bits2 ∘ Int.toNat) ∧ Lemmas.stored_solutions f0 (getElem! bits2 ∘ Int.toNat) o3 visited1 visited2 → (∀(i1 : ℤ), ¬Lemmas.mem_stack i1 st → bits2[Int.toNat i1]! = bits[Int.toNat i1]!) ∧ Lemmas.inverse st (getElem! bits ∘ Int.toNat) (getElem! bits2 ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! bits2 ∘ Int.toNat) ∧ Lemmas.stored_solutions f0 (getElem! bits2 ∘ Int.toNat) st visited visited2))))) else let o1 : List KodaRuskey_Spec.forest := List.cons f1 (List.cons f2 st'); (((0 : ℤ) ≤ Lemmas.size_stack st ∧ Lemmas.size_stack o1 < Lemmas.size_stack st ∨ Lemmas.size_stack st = Lemmas.size_stack o1 ∧ (match st with | ([] : List KodaRuskey_Spec.forest) => False | List.cons _ f3 => f3 = o1)) ∧ KodaRuskey_Spec.size_forest f0 = Int.ofNat (List.length bits) ∧ KodaRuskey_Spec.valid_nums_forest f0 (Int.ofNat (List.length bits)) ∧ Lemmas.sub o1 f0 (getElem! bits ∘ Int.toNat) ∧ Lemmas.any_stack o1 (getElem! bits ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! bits ∘ Int.toNat)) ∧ (∀(bits1 : List KodaRuskey_Spec.color) (visited1 : List (ℤ -> KodaRuskey_Spec.color)), List.length bits1 = List.length bits → (∀(i1 : ℤ), ¬Lemmas.mem_stack i1 o1 → bits1[Int.toNat i1]! = bits[Int.toNat i1]!) ∧ Lemmas.inverse o1 (getElem! bits ∘ Int.toNat) (getElem! bits1 ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! bits1 ∘ Int.toNat) ∧ Lemmas.stored_solutions f0 (getElem! bits1 ∘ Int.toNat) o1 visited visited1 → (let o2 : KodaRuskey_Spec.color := KodaRuskey_Spec.color.White; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length bits1)) ∧ (List.length (List.set bits1 (Int.toNat i) o2) = List.length bits1 → getElem! (List.set bits1 (Int.toNat i) o2) ∘ Int.toNat = Function.update (getElem! bits1 ∘ Int.toNat) i o2 → (let o3 : List KodaRuskey_Spec.forest := List.cons f2 st'; (((0 : ℤ) ≤ Lemmas.size_stack st ∧ Lemmas.size_stack o3 < Lemmas.size_stack st ∨ Lemmas.size_stack st = Lemmas.size_stack o3 ∧ (match st with | ([] : List KodaRuskey_Spec.forest) => False | List.cons _ f3 => f3 = o3)) ∧ KodaRuskey_Spec.size_forest f0 = Int.ofNat (List.length (List.set bits1 (Int.toNat i) o2)) ∧ KodaRuskey_Spec.valid_nums_forest f0 (Int.ofNat (List.length (List.set bits1 (Int.toNat i) o2))) ∧ Lemmas.sub o3 f0 (getElem! (List.set bits1 (Int.toNat i) o2) ∘ Int.toNat) ∧ Lemmas.any_stack o3 (getElem! (List.set bits1 (Int.toNat i) o2) ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! (List.set bits1 (Int.toNat i) o2) ∘ Int.toNat)) ∧ (∀(bits2 : List KodaRuskey_Spec.color) (visited2 : List (ℤ -> KodaRuskey_Spec.color)), List.length bits2 = List.length (List.set bits1 (Int.toNat i) o2) → (∀(i1 : ℤ), ¬Lemmas.mem_stack i1 o3 → bits2[Int.toNat i1]! = (List.set bits1 (Int.toNat i) o2)[Int.toNat i1]!) ∧ Lemmas.inverse o3 (getElem! (List.set bits1 (Int.toNat i) o2) ∘ Int.toNat) (getElem! bits2 ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! bits2 ∘ Int.toNat) ∧ Lemmas.stored_solutions f0 (getElem! bits2 ∘ Int.toNat) o3 visited1 visited2 → (∀(i1 : ℤ), ¬Lemmas.mem_stack i1 st → bits2[Int.toNat i1]! = bits[Int.toNat i1]!) ∧ Lemmas.inverse st (getElem! bits ∘ Int.toNat) (getElem! bits2 ∘ Int.toNat) ∧ KodaRuskey_Spec.valid_coloring f0 (getElem! bits2 ∘ Int.toNat) ∧ Lemmas.stored_solutions f0 (getElem! bits2 ∘ Int.toNat) st visited visited2))))))
  := sorry
end koda_ruskey_KodaRuskey_enumqtvc
