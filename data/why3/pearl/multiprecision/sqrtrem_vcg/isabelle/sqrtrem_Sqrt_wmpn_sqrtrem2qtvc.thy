theory sqrtrem_Sqrt_wmpn_sqrtrem2qtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "Why3STD.real_Truncate" "mach.c_C" "mach.int_Unsigned" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_1_Sub_1" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/sqrt_Sqrt1" "mach.fxp_Fxp"
begin
theorem wmpn_sqrtrem2'vc:
  fixes rp :: "64 word ptr"
  fixes sp :: "64 word ptr"
  fixes np :: "64 word ptr"
  assumes fact0: "valid rp (1 :: int)"
  assumes fact1: "valid sp (1 :: int)"
  assumes fact2: "valid np (2 :: int)"
  assumes fact3: "(2 :: int) ^\<^sub>i ((64 :: int) - (2 :: int)) \<le> uint (pelts np (offset np + (1 :: int)))"
  assumes fact4: "writable sp = True"
  assumes fact5: "writable rp = True"
  shows "c_C.min np \<le> offset np"
  and "offset np < c_C.max np"
  and "let np0 :: 64 word = pelts np (offset np) in (c_C.min np \<le> offset np + (1 :: int) \<and> offset np + (1 :: int) < c_C.max np) \<and> (c_C.min np \<le> offset np + (1 :: int) \<and> offset np + (1 :: int) < c_C.max np) \<and> (let o1 :: 64 word = pelts np (offset np + (1 :: int)) in (valid rp (1 :: int) \<and> (4611686018427387904 :: int) \<le> uint o1 \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(o2 :: 64 word). (uint o2 * uint o2 \<le> uint o1 \<and> uint o1 < (uint o2 + (1 :: int)) * (uint o2 + (1 :: int))) \<and> uint o2 * uint o2 + uint (pelts rp1 (offset rp1)) = uint o1 \<and> uint (pelts rp1 (offset rp1)) \<le> (2 :: int) * uint o2 \<longrightarrow> (c_C.min rp1 \<le> offset rp1 \<and> offset rp1 < c_C.max rp1) \<and> (let o3 :: 64 word = pelts rp1 (offset rp1) in uint'64_in_bounds (64 :: int) \<and> (\<forall>(o4 :: 64 word). uint o4 = (64 :: int) \<longrightarrow> (\<not>(2 :: int) = (0 :: int) \<and> uint'64_in_bounds (uint o4 cdiv (2 :: int))) \<and> (\<forall>(prec :: 64 word). uint prec = uint o4 cdiv (2 :: int) \<longrightarrow> uint'64_in_bounds (uint prec + (1 :: int)) \<and> (\<forall>(o5 :: 64 word). uint o5 = uint prec + (1 :: int) \<longrightarrow> ((0 :: int) \<le> uint o5 \<and> uint o5 < (64 :: int)) \<and> (\<forall>(nph :: 64 word). uint nph = uint np0 ediv (2 :: int) ^\<^sub>i uint o5 \<longrightarrow> uint'64_in_bounds (uint prec - (1 :: int)) \<and> (\<forall>(o6 :: 64 word). uint o6 = uint prec - (1 :: int) \<longrightarrow> (((0 :: int) \<le> uint o6 \<and> uint o6 < (64 :: int)) \<and> (2 :: int) ^\<^sub>i uint o6 * uint o3 \<le> (18446744073709551615 :: int)) \<and> (\<forall>(o7 :: 64 word). uint o7 = (2 :: int) ^\<^sub>i uint o6 * uint o3 \<longrightarrow> uint'64_in_bounds (uint o7 + uint nph) \<and> (\<forall>(o8 :: 64 word). uint o8 = uint o7 + uint nph \<longrightarrow> (\<not>uint o2 = (0 :: int) \<and> uint'64_in_bounds (uint o8 cdiv uint o2)) \<and> (\<forall>(o9 :: 64 word). uint o9 = uint o8 cdiv uint o2 \<longrightarrow> (((0 :: int) \<le> uint prec \<and> uint prec < (64 :: int)) \<and> (\<forall>(rq :: 64 word). uint rq = uint o9 ediv (2 :: int) ^\<^sub>i uint prec \<longrightarrow> uint'64_in_bounds (uint o9 - uint rq) \<and> (\<forall>(o10 :: 64 word). uint o10 = uint o9 - uint rq \<longrightarrow> (if uint o9 = (2 :: int) ^\<^sub>i uint prec then uint o10 = (2 :: int) ^\<^sub>i uint prec - (1 :: int) else o10 = o9) \<and> uint o10 < (2 :: int) ^\<^sub>i uint prec))) \<and> (\<forall>(q :: 64 word). (if uint o9 = (2 :: int) ^\<^sub>i uint prec then uint q = (2 :: int) ^\<^sub>i uint prec - (1 :: int) else q = o9) \<and> uint q < (2 :: int) ^\<^sub>i uint prec \<longrightarrow> uint'64_in_bounds (uint q * uint o2) \<and> (\<forall>(o10 :: 64 word). uint o10 = uint q * uint o2 \<longrightarrow> uint'64_in_bounds (uint o8 - uint o10) \<and> (\<forall>(u :: 64 word). uint u = uint o8 - uint o10 \<longrightarrow> (((0 :: int) \<le> uint prec \<and> uint prec < (64 :: int)) \<and> (2 :: int) ^\<^sub>i uint prec * uint o2 \<le> (18446744073709551615 :: int)) \<and> (\<forall>(o11 :: 64 word). uint o11 = (2 :: int) ^\<^sub>i uint prec * uint o2 \<longrightarrow> uint'64_in_bounds (uint o11 + uint q) \<and> (\<forall>(o12 :: 64 word). uint o12 = uint o11 + uint q \<longrightarrow> uint'64_in_bounds (uint prec - (1 :: int)) \<and> (\<forall>(o13 :: 64 word). uint o13 = uint prec - (1 :: int) \<longrightarrow> ((0 :: int) \<le> uint o13 \<and> uint o13 < (64 :: int)) \<and> (\<forall>(uh :: 64 word). uint uh = uint u ediv (2 :: int) ^\<^sub>i uint o13 \<longrightarrow> uint uh \<le> (9223372036854775807 :: int) \<and> (\<forall>(o14 :: 64 word). sint o14 = uint uh \<longrightarrow> uint'64_in_bounds (uint prec + (1 :: int)) \<and> (\<forall>(o15 :: 64 word). uint o15 = uint prec + (1 :: int) \<longrightarrow> (((0 :: int) \<le> uint o15 \<and> uint o15 < (64 :: int)) \<and> (2 :: int) ^\<^sub>i uint o15 * uint (1 :: 64 word) \<le> (18446744073709551615 :: int)) \<and> (\<forall>(o16 :: 64 word). uint o16 = (2 :: int) ^\<^sub>i uint o15 * uint (1 :: 64 word) \<longrightarrow> (\<not>uint o16 = (0 :: int) \<and> uint'64_in_bounds (uint np0 cmod uint o16)) \<and> (\<forall>(npl :: 64 word). uint npl = uint np0 cmod uint o16 \<longrightarrow> uint'64_in_bounds (uint prec + (1 :: int)) \<and> (\<forall>(o17 :: 64 word). uint o17 = uint prec + (1 :: int) \<longrightarrow> ((0 :: int) \<le> uint o17 \<and> uint o17 < (64 :: int)) \<and> (\<forall>(ul :: 64 word). uint ul = uint u * (2 :: int) ^\<^sub>i uint o17 emod ((18446744073709551615 :: int) + (1 :: int)) \<and> uint ul \<le> (18446744073709551615 :: int) + (1 :: int) - (2 :: int) ^\<^sub>i uint o17 \<longrightarrow> uint'64_in_bounds (uint ul + uint npl) \<and> (\<forall>(o18 :: 64 word). uint o18 = uint ul + uint npl \<longrightarrow> uint'64_in_bounds (uint q * uint q) \<and> (\<forall>(q2 :: 64 word). uint q2 = uint q * uint q \<longrightarrow> (if uint o18 < uint q2 then int'64_in_bounds (sint o14 - (1 :: int)) \<and> (\<forall>(o19 :: 64 word). sint o19 = sint o14 - (1 :: int) \<longrightarrow> (\<forall>(o20 :: 64 word). uint o20 = (uint o18 - uint q2) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> uint o20 + ((18446744073709551615 :: int) + (1 :: int)) * sint o19 = uint o18 + ((18446744073709551615 :: int) + (1 :: int)) * sint o14 - uint q2)) else \<forall>(o19 :: 64 word). uint o19 = (uint o18 - uint q2) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> uint o19 + ((18446744073709551615 :: int) + (1 :: int)) * sint o14 = uint o18 + ((18446744073709551615 :: int) + (1 :: int)) * sint o14 - uint q2) \<and> (\<forall>(cc :: 64 word) (rp0 :: 64 word). uint rp0 + ((18446744073709551615 :: int) + (1 :: int)) * sint cc = uint o18 + ((18446744073709551615 :: int) + (1 :: int)) * sint o14 - uint q2 \<longrightarrow> (if sint cc < (0 :: int) then (\<forall>(o19 :: 64 word). uint o19 = (uint rp0 + uint o12) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (if uint o19 < uint o12 then int'64_in_bounds (sint cc + (1 :: int)) \<and> (\<forall>(o20 :: 64 word). sint o20 = sint cc + (1 :: int) \<longrightarrow> uint o19 + ((18446744073709551615 :: int) + (1 :: int)) * sint o20 = uint rp0 + ((18446744073709551615 :: int) + (1 :: int)) * sint cc + uint o12 \<and> ((0 :: int) \<le> sint o20 \<or> uint o19 = uint rp0 + uint o12)) else uint o19 + ((18446744073709551615 :: int) + (1 :: int)) * sint cc = uint rp0 + ((18446744073709551615 :: int) + (1 :: int)) * sint cc + uint o12 \<and> ((0 :: int) \<le> sint cc \<or> uint o19 = uint rp0 + uint o12))) \<and> (\<forall>(cc1 :: 64 word) (rp01 :: 64 word). uint rp01 + ((18446744073709551615 :: int) + (1 :: int)) * sint cc1 = uint rp0 + ((18446744073709551615 :: int) + (1 :: int)) * sint cc + uint o12 \<and> ((0 :: int) \<le> sint cc1 \<or> uint rp01 = uint rp0 + uint o12) \<longrightarrow> uint'64_in_bounds (uint o12 - (1 :: int)) \<and> (\<forall>(o19 :: 64 word). uint o19 = uint o12 - (1 :: int) \<longrightarrow> (\<forall>(o20 :: 64 word). uint o20 = (uint rp01 + uint o19) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (if uint o20 < uint o19 then int'64_in_bounds (sint cc1 + (1 :: int)) \<and> (\<forall>(o21 :: 64 word). sint o21 = sint cc1 + (1 :: int) \<longrightarrow> uint o20 + ((18446744073709551615 :: int) + (1 :: int)) * sint o21 = uint rp01 + ((18446744073709551615 :: int) + (1 :: int)) * sint cc1 + uint o19 \<and> (0 :: int) \<le> sint o21) else uint o20 + ((18446744073709551615 :: int) + (1 :: int)) * sint cc1 = uint rp01 + ((18446744073709551615 :: int) + (1 :: int)) * sint cc1 + uint o19 \<and> (0 :: int) \<le> sint cc1)) \<and> (\<forall>(cc2 :: 64 word) (rp02 :: 64 word). uint rp02 + ((18446744073709551615 :: int) + (1 :: int)) * sint cc2 = uint rp01 + ((18446744073709551615 :: int) + (1 :: int)) * sint cc1 + uint o19 \<and> (0 :: int) \<le> sint cc2 \<longrightarrow> ((c_C.min rp1 \<le> offset rp1 \<and> offset rp1 < c_C.max rp1) \<and> writable rp1 = True) \<and> (\<forall>(rp2 :: 64 word ptr). length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> pelts rp2 = (pelts rp1)(offset rp2 := rp02) \<longrightarrow> ((c_C.min sp \<le> offset sp \<and> offset sp < c_C.max sp) \<and> writable sp = True) \<and> (\<forall>(sp1 :: 64 word ptr). length (data sp1) = length (data sp) \<and> offset sp1 = offset sp \<and> c_C.min sp1 = c_C.min sp \<and> c_C.max sp1 = c_C.max sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> pelts sp1 = (pelts sp)(offset sp1 := o19) \<longrightarrow> (0 :: int) \<le> sint cc2 \<and> (\<forall>(result :: 64 word). uint result = sint cc2 \<longrightarrow> value np (2 :: int) = uint (pelts sp1 (offset sp1)) * uint (pelts sp1 (offset sp1)) + uint result * ((18446744073709551615 :: int) + (1 :: int)) + uint (pelts rp2 (offset rp2)) \<and> uint (pelts rp2 (offset rp2)) + uint result * ((18446744073709551615 :: int) + (1 :: int)) \<le> (2 :: int) * uint (pelts sp1 (offset sp1)) \<and> (0 :: int) \<le> uint result \<and> uint result \<le> (1 :: int))))))) else ((c_C.min rp1 \<le> offset rp1 \<and> offset rp1 < c_C.max rp1) \<and> writable rp1 = True) \<and> (\<forall>(rp2 :: 64 word ptr). length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> pelts rp2 = (pelts rp1)(offset rp2 := rp0) \<longrightarrow> ((c_C.min sp \<le> offset sp \<and> offset sp < c_C.max sp) \<and> writable sp = True) \<and> (\<forall>(sp1 :: 64 word ptr). length (data sp1) = length (data sp) \<and> offset sp1 = offset sp \<and> c_C.min sp1 = c_C.min sp \<and> c_C.max sp1 = c_C.max sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> pelts sp1 = (pelts sp)(offset sp1 := o12) \<longrightarrow> (0 :: int) \<le> sint cc \<and> (\<forall>(result :: 64 word). uint result = sint cc \<longrightarrow> value np (2 :: int) = uint (pelts sp1 (offset sp1)) * uint (pelts sp1 (offset sp1)) + uint result * ((18446744073709551615 :: int) + (1 :: int)) + uint (pelts rp2 (offset rp2)) \<and> uint (pelts rp2 (offset rp2)) + uint result * ((18446744073709551615 :: int) + (1 :: int)) \<le> (2 :: int) * uint (pelts sp1 (offset sp1)) \<and> (0 :: int) \<le> uint result \<and> uint result \<le> (1 :: int)))))))))))))))))))))))))))))))))"
  sorry
end
