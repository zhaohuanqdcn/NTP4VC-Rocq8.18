theory huffman_with_two_queues_Top_huffman_codingqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_Sum"
begin
consts get_closure :: "'a list \<Rightarrow> int \<Rightarrow> 'a"
axiomatization where get_closure_def:   "get_closure y y1 = y ! nat y1"
  for y :: "'a list"
  and y1 :: "int"
definition last :: "int list \<Rightarrow> int"
  where "last s = s ! nat (int (length s) - (1 :: int))" for s
theorem huffman_coding'vc:
  fixes s :: "int list"
  assumes fact0: "(0 :: int) < int (length s)"
  assumes fact1: "sorted s"
  shows "(0 :: int) < int (length s) + int (length [])"
  and "sum_list s + sum_list [] = sum_list s"
  and "sorted s"
  and "sorted []"
  and "(2 :: int) \<le> int (length s) \<longrightarrow> (1 :: int) \<le> int (length []) \<longrightarrow> last [] \<le> s ! (0 :: nat) + s ! (1 :: nat)"
  and "(1 :: int) \<le> int (length s) \<longrightarrow> (2 :: int) \<le> int (length []) \<longrightarrow> last [] \<le> s ! (0 :: nat) + [] ! (0 :: nat)"
  and "(2 :: int) \<le> int (length []) \<longrightarrow> last [] \<le> [] ! (0 :: nat) + [] ! (1 :: nat)"
  and "\<forall>(y :: int list) (x :: int list). (0 :: int) < int (length x) + int (length y) \<and> sum_list x + sum_list y = sum_list s \<and> sorted x \<and> sorted y \<and> ((2 :: int) \<le> int (length x) \<longrightarrow> (1 :: int) \<le> int (length y) \<longrightarrow> last y \<le> x ! (0 :: nat) + x ! (1 :: nat)) \<and> ((1 :: int) \<le> int (length x) \<longrightarrow> (2 :: int) \<le> int (length y) \<longrightarrow> last y \<le> x ! (0 :: nat) + y ! (0 :: nat)) \<and> ((2 :: int) \<le> int (length y) \<longrightarrow> last y \<le> y ! (0 :: nat) + y ! (1 :: nat)) \<longrightarrow> (if (2 :: int) \<le> int (length x) + int (length y) then if int (length y) = (0 :: int) then let o1 :: int = x ! (0 :: nat) + x ! (1 :: nat); o2 :: int list = y @ [o1] in int (length o2) = (1 :: int) + int (length y) \<and> o2 ! length y = o1 \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length y) \<longrightarrow> o2 ! nat i = y ! nat i) \<longrightarrow> ((0 :: int) \<le> (2 :: int) \<and> (2 :: int) \<le> int (length x)) \<and> ((0 :: int) \<le> int (length x) + int (length y) \<and> int (length (drop (2 :: nat) x)) + int (length o2) < int (length x) + int (length y)) \<and> (0 :: int) < int (length (drop (2 :: nat) x)) + int (length o2) \<and> sum_list (drop (2 :: nat) x) + sum_list o2 = sum_list s \<and> sorted (drop (2 :: nat) x) \<and> sorted o2 \<and> ((2 :: int) \<le> int (length (drop (2 :: nat) x)) \<longrightarrow> (1 :: int) \<le> int (length o2) \<longrightarrow> last o2 \<le> drop (2 :: nat) x ! (0 :: nat) + drop (2 :: nat) x ! (1 :: nat)) \<and> ((1 :: int) \<le> int (length (drop (2 :: nat) x)) \<longrightarrow> (2 :: int) \<le> int (length o2) \<longrightarrow> last o2 \<le> drop (2 :: nat) x ! (0 :: nat) + o2 ! (0 :: nat)) \<and> ((2 :: int) \<le> int (length o2) \<longrightarrow> last o2 \<le> o2 ! (0 :: nat) + o2 ! (1 :: nat)) else if int (length x) = (0 :: int) then let o1 :: int = y ! (0 :: nat) + y ! (1 :: nat) in ((0 :: int) \<le> (2 :: int) \<and> (2 :: int) \<le> int (length y)) \<and> (let o2 :: int list = drop (2 :: nat) y; o3 :: int list = o2 @ [o1] in int (length o3) = (1 :: int) + int (length o2) \<and> o3 ! length o2 = o1 \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length o2) \<longrightarrow> o3 ! nat i = o2 ! nat i) \<longrightarrow> ((0 :: int) \<le> int (length x) + int (length y) \<and> int (length x) + int (length o3) < int (length x) + int (length y)) \<and> (0 :: int) < int (length x) + int (length o3) \<and> sum_list x + sum_list o3 = sum_list s \<and> sorted x \<and> sorted o3 \<and> ((2 :: int) \<le> int (length x) \<longrightarrow> (1 :: int) \<le> int (length o3) \<longrightarrow> last o3 \<le> x ! (0 :: nat) + x ! (1 :: nat)) \<and> ((1 :: int) \<le> int (length x) \<longrightarrow> (2 :: int) \<le> int (length o3) \<longrightarrow> last o3 \<le> x ! (0 :: nat) + o3 ! (0 :: nat)) \<and> ((2 :: int) \<le> int (length o3) \<longrightarrow> last o3 \<le> o3 ! (0 :: nat) + o3 ! (1 :: nat))) else if x ! (0 :: nat) \<le> y ! (0 :: nat) then \<forall>(o1 :: bool). (if (2 :: int) \<le> int (length x) then o1 = (if x ! (1 :: nat) \<le> y ! (0 :: nat) then True else False) else o1 = False) \<longrightarrow> (if o1 = True then let o2 :: int = x ! (0 :: nat) + x ! (1 :: nat); o3 :: int list = y @ [o2] in int (length o3) = (1 :: int) + int (length y) \<and> o3 ! length y = o2 \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length y) \<longrightarrow> o3 ! nat i = y ! nat i) \<longrightarrow> ((0 :: int) \<le> (2 :: int) \<and> (2 :: int) \<le> int (length x)) \<and> ((0 :: int) \<le> int (length x) + int (length y) \<and> int (length (drop (2 :: nat) x)) + int (length o3) < int (length x) + int (length y)) \<and> (0 :: int) < int (length (drop (2 :: nat) x)) + int (length o3) \<and> sum_list (drop (2 :: nat) x) + sum_list o3 = sum_list s \<and> sorted (drop (2 :: nat) x) \<and> sorted o3 \<and> ((2 :: int) \<le> int (length (drop (2 :: nat) x)) \<longrightarrow> (1 :: int) \<le> int (length o3) \<longrightarrow> last o3 \<le> drop (2 :: nat) x ! (0 :: nat) + drop (2 :: nat) x ! (1 :: nat)) \<and> ((1 :: int) \<le> int (length (drop (2 :: nat) x)) \<longrightarrow> (2 :: int) \<le> int (length o3) \<longrightarrow> last o3 \<le> drop (2 :: nat) x ! (0 :: nat) + o3 ! (0 :: nat)) \<and> ((2 :: int) \<le> int (length o3) \<longrightarrow> last o3 \<le> o3 ! (0 :: nat) + o3 ! (1 :: nat)) else let o2 :: int = x ! (0 :: nat) + y ! (0 :: nat) in ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) \<le> int (length y)) \<and> (let o3 :: int list = drop (1 :: nat) y; o4 :: int list = o3 @ [o2] in int (length o4) = (1 :: int) + int (length o3) \<and> o4 ! length o3 = o2 \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length o3) \<longrightarrow> o4 ! nat i = o3 ! nat i) \<longrightarrow> ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) \<le> int (length x)) \<and> ((0 :: int) \<le> int (length x) + int (length y) \<and> int (length (drop (1 :: nat) x)) + int (length o4) < int (length x) + int (length y)) \<and> (0 :: int) < int (length (drop (1 :: nat) x)) + int (length o4) \<and> sum_list (drop (1 :: nat) x) + sum_list o4 = sum_list s \<and> sorted (drop (1 :: nat) x) \<and> sorted o4 \<and> ((2 :: int) \<le> int (length (drop (1 :: nat) x)) \<longrightarrow> (1 :: int) \<le> int (length o4) \<longrightarrow> last o4 \<le> drop (1 :: nat) x ! (0 :: nat) + drop (1 :: nat) x ! (1 :: nat)) \<and> ((1 :: int) \<le> int (length (drop (1 :: nat) x)) \<longrightarrow> (2 :: int) \<le> int (length o4) \<longrightarrow> last o4 \<le> drop (1 :: nat) x ! (0 :: nat) + o4 ! (0 :: nat)) \<and> ((2 :: int) \<le> int (length o4) \<longrightarrow> last o4 \<le> o4 ! (0 :: nat) + o4 ! (1 :: nat)))) else \<forall>(o1 :: bool). (if (2 :: int) \<le> int (length y) then o1 = (if y ! (1 :: nat) \<le> x ! (0 :: nat) then True else False) else o1 = False) \<longrightarrow> (if o1 = True then let o2 :: int = y ! (0 :: nat) + y ! (1 :: nat) in ((0 :: int) \<le> (2 :: int) \<and> (2 :: int) \<le> int (length y)) \<and> (let o3 :: int list = drop (2 :: nat) y; o4 :: int list = o3 @ [o2] in int (length o4) = (1 :: int) + int (length o3) \<and> o4 ! length o3 = o2 \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length o3) \<longrightarrow> o4 ! nat i = o3 ! nat i) \<longrightarrow> ((0 :: int) \<le> int (length x) + int (length y) \<and> int (length x) + int (length o4) < int (length x) + int (length y)) \<and> (0 :: int) < int (length x) + int (length o4) \<and> sum_list x + sum_list o4 = sum_list s \<and> sorted x \<and> sorted o4 \<and> ((2 :: int) \<le> int (length x) \<longrightarrow> (1 :: int) \<le> int (length o4) \<longrightarrow> last o4 \<le> x ! (0 :: nat) + x ! (1 :: nat)) \<and> ((1 :: int) \<le> int (length x) \<longrightarrow> (2 :: int) \<le> int (length o4) \<longrightarrow> last o4 \<le> x ! (0 :: nat) + o4 ! (0 :: nat)) \<and> ((2 :: int) \<le> int (length o4) \<longrightarrow> last o4 \<le> o4 ! (0 :: nat) + o4 ! (1 :: nat))) else let o2 :: int = x ! (0 :: nat) + y ! (0 :: nat) in ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) \<le> int (length y)) \<and> (let o3 :: int list = drop (1 :: nat) y; o4 :: int list = o3 @ [o2] in int (length o4) = (1 :: int) + int (length o3) \<and> o4 ! length o3 = o2 \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length o3) \<longrightarrow> o4 ! nat i = o3 ! nat i) \<longrightarrow> ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) \<le> int (length x)) \<and> ((0 :: int) \<le> int (length x) + int (length y) \<and> int (length (drop (1 :: nat) x)) + int (length o4) < int (length x) + int (length y)) \<and> (0 :: int) < int (length (drop (1 :: nat) x)) + int (length o4) \<and> sum_list (drop (1 :: nat) x) + sum_list o4 = sum_list s \<and> sorted (drop (1 :: nat) x) \<and> sorted o4 \<and> ((2 :: int) \<le> int (length (drop (1 :: nat) x)) \<longrightarrow> (1 :: int) \<le> int (length o4) \<longrightarrow> last o4 \<le> drop (1 :: nat) x ! (0 :: nat) + drop (1 :: nat) x ! (1 :: nat)) \<and> ((1 :: int) \<le> int (length (drop (1 :: nat) x)) \<longrightarrow> (2 :: int) \<le> int (length o4) \<longrightarrow> last o4 \<le> drop (1 :: nat) x ! (0 :: nat) + o4 ! (0 :: nat)) \<and> ((2 :: int) \<le> int (length o4) \<longrightarrow> last o4 \<le> o4 ! (0 :: nat) + o4 ! (1 :: nat)))) else \<forall>(result :: int). (if (0 :: int) < int (length x) then result = x ! (0 :: nat) else result = y ! (0 :: nat)) \<longrightarrow> result = sum_list s)"
  sorry
end
