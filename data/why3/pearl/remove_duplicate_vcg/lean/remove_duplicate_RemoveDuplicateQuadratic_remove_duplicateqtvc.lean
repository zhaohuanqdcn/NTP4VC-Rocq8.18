import Why3.Base
import Why3.why3.Ref.Ref
import pearl.remove_duplicate_vcg.lean.remove_duplicate.Spec
open Classical
open Lean4Why3
namespace remove_duplicate_RemoveDuplicateQuadratic_remove_duplicateqtvc
axiom t : Type
axiom inhabited_axiom_t : Inhabited t
attribute [instance] inhabited_axiom_t
axiom eq : t -> t -> Prop
axiom eq'spec (x : t) (y : t) : eq x y = (x = y)
theorem remove_duplicate'vc (a : List t) : let n : ℤ := Int.ofNat (List.length a); (0 : ℤ) ≤ n ∧ (∀(from1 : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → from1[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length from1) = n → (0 : ℤ) ≤ n ∧ (∀(to' : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → to'[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length to') = n → (let o1 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → ((0 : ℤ) ≤ (0 : ℤ) ∧ Spec.nodup a (0 : ℤ) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → ((0 : ℤ) ≤ to'[Int.toNat j]! ∧ to'[Int.toNat j]! < (0 : ℤ)) ∧ a[Int.toNat j]! = a[Int.toNat (to'[Int.toNat j]!)]!) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → ((0 : ℤ) ≤ from1[Int.toNat j]! ∧ from1[Int.toNat j]! < (0 : ℤ)) ∧ a[Int.toNat j]! = a[Int.toNat (from1[Int.toNat j]!)]!)) ∧ (∀(to_1 : List ℤ) (from2 : List ℤ) (r : ℤ) (a1 : List t), List.length to_1 = List.length to' → List.length from2 = List.length from1 → List.length a1 = List.length a → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ ((0 : ℤ) ≤ r ∧ r ≤ i) ∧ Spec.nodup a1 r ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r → ((0 : ℤ) ≤ to_1[Int.toNat j]! ∧ to_1[Int.toNat j]! < i) ∧ a1[Int.toNat j]! = a[Int.toNat (to_1[Int.toNat j]!)]!) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → ((0 : ℤ) ≤ from2[Int.toNat j]! ∧ from2[Int.toNat j]! < r) ∧ a[Int.toNat j]! = a1[Int.toNat (from2[Int.toNat j]!)]!) ∧ (∀(j : ℤ), i ≤ j ∧ j < n → a1[Int.toNat j]! = a[Int.toNat j]!) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (let o2 : t := a1[Int.toNat i]!; ((0 : ℤ) ≤ r ∧ r ≤ Int.ofNat (List.length a1)) ∧ (∀(w : ℤ), (Spec.appears o2 a1 r → ((0 : ℤ) ≤ w ∧ w < r) ∧ a1[Int.toNat w]! = o2) → (if ¬Spec.appears o2 a1 r then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (let o3 : t := a1[Int.toNat i]!; ((0 : ℤ) ≤ r ∧ r < Int.ofNat (List.length a1)) ∧ (List.length (List.set a1 (Int.toNat r) o3) = List.length a1 → getElem! (List.set a1 (Int.toNat r) o3) ∘ Int.toNat = Function.update (getElem! a1 ∘ Int.toNat) r o3 → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length from2)) ∧ (List.length (List.set from2 (Int.toNat i) r) = List.length from2 → getElem! (List.set from2 (Int.toNat i) r) ∘ Int.toNat = Function.update (getElem! from2 ∘ Int.toNat) i r → ((0 : ℤ) ≤ r ∧ r < Int.ofNat (List.length to_1)) ∧ (List.length (List.set to_1 (Int.toNat r) i) = List.length to_1 → getElem! (List.set to_1 (Int.toNat r) i) ∘ Int.toNat = Function.update (getElem! to_1 ∘ Int.toNat) r i → ((0 : ℤ) ≤ r + (1 : ℤ) ∧ r + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ Spec.nodup (List.set a1 (Int.toNat r) o3) (r + (1 : ℤ)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r + (1 : ℤ) → ((0 : ℤ) ≤ (List.set to_1 (Int.toNat r) i)[Int.toNat j]! ∧ (List.set to_1 (Int.toNat r) i)[Int.toNat j]! < i + (1 : ℤ)) ∧ (List.set a1 (Int.toNat r) o3)[Int.toNat j]! = a[Int.toNat ((List.set to_1 (Int.toNat r) i)[Int.toNat j]!)]!) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → ((0 : ℤ) ≤ (List.set from2 (Int.toNat i) r)[Int.toNat j]! ∧ (List.set from2 (Int.toNat i) r)[Int.toNat j]! < r + (1 : ℤ)) ∧ a[Int.toNat j]! = (List.set a1 (Int.toNat r) o3)[Int.toNat ((List.set from2 (Int.toNat i) r)[Int.toNat j]!)]!) ∧ (∀(j : ℤ), i + (1 : ℤ) ≤ j ∧ j < n → (List.set a1 (Int.toNat r) o3)[Int.toNat j]! = a[Int.toNat j]!))))) else ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length from2)) ∧ (List.length (List.set from2 (Int.toNat i) w) = List.length from2 → getElem! (List.set from2 (Int.toNat i) w) ∘ Int.toNat = Function.update (getElem! from2 ∘ Int.toNat) i w → ((0 : ℤ) ≤ r ∧ r ≤ i + (1 : ℤ)) ∧ Spec.nodup a1 r ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r → ((0 : ℤ) ≤ to_1[Int.toNat j]! ∧ to_1[Int.toNat j]! < i + (1 : ℤ)) ∧ a1[Int.toNat j]! = a[Int.toNat (to_1[Int.toNat j]!)]!) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → ((0 : ℤ) ≤ (List.set from2 (Int.toNat i) w)[Int.toNat j]! ∧ (List.set from2 (Int.toNat i) w)[Int.toNat j]! < r) ∧ a[Int.toNat j]! = a1[Int.toNat ((List.set from2 (Int.toNat i) w)[Int.toNat j]!)]!) ∧ (∀(j : ℤ), i + (1 : ℤ) ≤ j ∧ j < n → a1[Int.toNat j]! = a[Int.toNat j]!)))))) ∧ (((0 : ℤ) ≤ r ∧ r ≤ o1 + (1 : ℤ)) ∧ Spec.nodup a1 r ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r → ((0 : ℤ) ≤ to_1[Int.toNat j]! ∧ to_1[Int.toNat j]! < o1 + (1 : ℤ)) ∧ a1[Int.toNat j]! = a[Int.toNat (to_1[Int.toNat j]!)]!) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < o1 + (1 : ℤ) → ((0 : ℤ) ≤ from2[Int.toNat j]! ∧ from2[Int.toNat j]! < r) ∧ a[Int.toNat j]! = a1[Int.toNat (from2[Int.toNat j]!)]!) ∧ (∀(j : ℤ), o1 + (1 : ℤ) ≤ j ∧ j < n → a1[Int.toNat j]! = a[Int.toNat j]!) → ((0 : ℤ) ≤ r ∧ r ≤ Int.ofNat (List.length a1)) ∧ Spec.nodup a1 r ∧ (∀(v : t), Spec.appears v a (Int.ofNat (List.length a1)) = Spec.appears v a1 r)))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length a)) ∧ Spec.nodup a (0 : ℤ) ∧ (∀(v : t), Spec.appears v a (Int.ofNat (List.length a)) = Spec.appears v a (0 : ℤ))))))
  := sorry
end remove_duplicate_RemoveDuplicateQuadratic_remove_duplicateqtvc
