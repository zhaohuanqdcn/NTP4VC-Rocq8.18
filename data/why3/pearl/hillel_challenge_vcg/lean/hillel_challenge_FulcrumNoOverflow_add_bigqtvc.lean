import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Sum
open Classical
open Lean4Why3
namespace hillel_challenge_FulcrumNoOverflow_add_bigqtvc
axiom big : Type
axiom inhabited_axiom_big : Inhabited big
attribute [instance] inhabited_axiom_big
axiom q : big -> BitVec 32
axiom r : big -> BitVec 32
axiom v : big -> ℤ
axiom big'invariant (self : big) : -((2147483647 : ℤ) + (1 : ℤ)) ≤ BitVec.toInt (q self) ∧ BitVec.toInt (q self) ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt (r self) ∧ BitVec.toInt (r self) ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ) ∧ v self = BitVec.toInt (q self) * ((2147483647 : ℤ) + (1 : ℤ)) + BitVec.toInt (r self)
noncomputable def big'eq (a : big) (b : big) := q a = q b ∧ r a = r b ∧ v a = v b
axiom big'inj (a : big) (b : big) (fact0 : big'eq a b) : a = b
axiom big_zero : Unit -> big
axiom big_zero'def (x : Unit) : q (big_zero x) = (0 : BitVec 32) ∧ r (big_zero x) = (0 : BitVec 32) ∧ v (big_zero x) = (0 : ℤ)
theorem add_big'vc (b : big) (x : BitVec 32) (fact0 : -((2147483647 : ℤ) + (1 : ℤ)) * ((2147483647 : ℤ) + (1 : ℤ)) ≤ v b + BitVec.toInt x) (fact1 : v b + BitVec.toInt x ≤ ((2147483647 : ℤ) + (1 : ℤ)) * ((2147483647 : ℤ) + (1 : ℤ)) - (1 : ℤ)) : if BitVec.toInt x < (0 : ℤ) then let o1 : BitVec 32 := r b; int'32_in_bounds (BitVec.toInt o1 + BitVec.toInt x) ∧ (∀(r' : BitVec 32), BitVec.toInt r' = BitVec.toInt o1 + BitVec.toInt x → (if BitVec.toInt r' < (0 : ℤ) then let o2 : BitVec 32 := q b; int'32_in_bounds (BitVec.toInt o2 - (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt o2 - (1 : ℤ) → int'32_in_bounds (BitVec.toInt r' + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt r' + (1 : ℤ) → int'32_in_bounds (BitVec.toInt o4 + BitVec.toInt (2147483647 : BitVec 32)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt o4 + BitVec.toInt (2147483647 : BitVec 32) → (∀(b1 : big), ((-((2147483647 : ℤ) + (1 : ℤ)) ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ v b + BitVec.toInt x = BitVec.toInt o3 * ((2147483647 : ℤ) + (1 : ℤ)) + BitVec.toInt o5) ∧ (v b + BitVec.toInt x = v b1 ∧ o5 = r b1 ∧ o3 = q b1 → v b1 = v b + BitVec.toInt x))))) else ∀(b1 : big), ((-((2147483647 : ℤ) + (1 : ℤ)) ≤ BitVec.toInt (q b) ∧ BitVec.toInt (q b) ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt r' ∧ BitVec.toInt r' ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ v b + BitVec.toInt x = BitVec.toInt (q b) * ((2147483647 : ℤ) + (1 : ℤ)) + BitVec.toInt r') ∧ (v b + BitVec.toInt x = v b1 ∧ r' = r b1 ∧ q b = q b1 → v b1 = v b + BitVec.toInt x))) else int'32_in_bounds (BitVec.toInt (-(2147483648 : BitVec 32)) + BitVec.toInt x) ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = BitVec.toInt (-(2147483648 : BitVec 32)) + BitVec.toInt x → (let o2 : BitVec 32 := r b; int'32_in_bounds (BitVec.toInt o2 + BitVec.toInt o1) ∧ (∀(r' : BitVec 32), BitVec.toInt r' = BitVec.toInt o2 + BitVec.toInt o1 → (if BitVec.toInt r' < (0 : ℤ) then int'32_in_bounds (BitVec.toInt r' + (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt r' + (1 : ℤ) → int'32_in_bounds (BitVec.toInt o3 + BitVec.toInt (2147483647 : BitVec 32)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt o3 + BitVec.toInt (2147483647 : BitVec 32) → (∀(b1 : big), ((-((2147483647 : ℤ) + (1 : ℤ)) ≤ BitVec.toInt (q b) ∧ BitVec.toInt (q b) ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ v b + BitVec.toInt x = BitVec.toInt (q b) * ((2147483647 : ℤ) + (1 : ℤ)) + BitVec.toInt o4) ∧ (v b + BitVec.toInt x = v b1 ∧ o4 = r b1 ∧ q b = q b1 → v b1 = v b + BitVec.toInt x)))) else let o3 : BitVec 32 := q b; int'32_in_bounds (BitVec.toInt o3 + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt o3 + (1 : ℤ) → (∀(b1 : big), ((-((2147483647 : ℤ) + (1 : ℤ)) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt r' ∧ BitVec.toInt r' ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ v b + BitVec.toInt x = BitVec.toInt o4 * ((2147483647 : ℤ) + (1 : ℤ)) + BitVec.toInt r') ∧ (v b + BitVec.toInt x = v b1 ∧ r' = r b1 ∧ o4 = q b1 → v b1 = v b + BitVec.toInt x)))))))
  := sorry
end hillel_challenge_FulcrumNoOverflow_add_bigqtvc
