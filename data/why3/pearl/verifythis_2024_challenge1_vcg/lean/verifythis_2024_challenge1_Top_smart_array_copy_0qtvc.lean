import Why3.Base
open Classical
open Lean4Why3
namespace verifythis_2024_challenge1_Top_smart_array_copy_0qtvc
noncomputable def permutation (l : ℤ) (p : List ℤ) := ((0 : ℤ) ≤ l ∧ l ≤ Int.ofNat (List.length p)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < l → (0 : ℤ) ≤ p[Int.toNat i]! ∧ p[Int.toNat i]! < l) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < l → (0 : ℤ) ≤ j ∧ j < l → ¬i = j → ¬p[Int.toNat i]! = p[Int.toNat j]!)
noncomputable def permutation_pair (l : ℤ) (p : List ℤ) (invp : List ℤ) := permutation l p ∧ permutation l invp ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < l → p[Int.toNat (invp[Int.toNat i]!)]! = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < l → invp[Int.toNat (p[Int.toNat i]!)]! = i)
axiom identity : ℤ -> List ℤ
axiom identity'spec'1 (l : ℤ) (fact0 : (0 : ℤ) < l) : Int.ofNat (List.length (identity l)) = l
axiom identity'spec'0 (l : ℤ) (i : ℤ) (fact0 : (0 : ℤ) < l) (fact1 : (0 : ℤ) ≤ i) (fact2 : i < l) : (identity l)[Int.toNat i]! = i
axiom identity'spec (l : ℤ) (fact0 : (0 : ℤ) < l) : permutation_pair l (identity l) (identity l)
axiom elt : Type
axiom inhabited_axiom_elt : Inhabited elt
attribute [instance] inhabited_axiom_elt
noncomputable def valid_chunk (a : List elt) (ofs : ℤ) (len : ℤ) := (0 : ℤ) ≤ ofs ∧ ofs ≤ ofs + len ∧ ofs + len ≤ Int.ofNat (List.length a)
noncomputable def copy (src : List elt) (dst : List elt) (ofs : ℤ) (len : ℤ) := valid_chunk src ofs len ∧ List.length src = List.length dst ∧ (∀(i : ℤ), ofs ≤ i ∧ i < ofs + len → dst[Int.toNat i]! = src[Int.toNat i]!)
theorem smart_array_copy_0'vc (src : List elt) (dst : List elt) (k : ℤ) (l : ℤ) (q : ℤ) (r : ℤ) (fact0 : List.length src = List.length dst) (fact1 : (0 : ℤ) < Int.ofNat (List.length dst)) (fact2 : (0 : ℤ) < k) (fact3 : (0 : ℤ) < l) (fact4 : (0 : ℤ) ≤ q) (fact5 : (0 : ℤ) ≤ r) (fact6 : r < k * l) (fact7 : Int.ofNat (List.length dst) = q * k * l + r) : let m : ℤ := k * l; let o1 : ℤ := q - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → copy src dst (0 : ℤ) ((0 : ℤ) * m) ∧ (∀(dst1 : List elt), List.length dst1 = List.length dst → (∀(s : ℤ), ((0 : ℤ) ≤ s ∧ s ≤ o1) ∧ copy src dst1 (0 : ℤ) (s * m) → (let start : ℤ := s * m; (0 : ℤ) < l ∧ (∀(sigma : List ℤ) (invsigma : List ℤ), (List.length sigma = List.length invsigma ∧ Int.ofNat (List.length invsigma) = l) ∧ permutation_pair l sigma invsigma → (let o2 : ℤ := l - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → (copy src dst1 (0 : ℤ) (s * m) ∧ (∀(j' : ℤ), (0 : ℤ) ≤ j' ∧ j' < (0 : ℤ) → copy src dst1 (start + sigma[Int.toNat j']! * k) k)) ∧ (∀(dst2 : List elt), List.length dst2 = List.length dst1 → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j ≤ o2) ∧ copy src dst2 (0 : ℤ) (s * m) ∧ (∀(j' : ℤ), (0 : ℤ) ≤ j' ∧ j' < j → copy src dst2 (start + sigma[Int.toNat j']! * k) k) → ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length sigma)) ∧ (let startj : ℤ := start + sigma[Int.toNat j]! * k; let o3 : ℤ := k - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → (copy src dst2 (0 : ℤ) (s * m) ∧ (∀(j' : ℤ), (0 : ℤ) ≤ j' ∧ j' < j → copy src dst2 (start + sigma[Int.toNat j']! * k) k) ∧ copy src dst2 startj (0 : ℤ)) ∧ (∀(dst3 : List elt), List.length dst3 = List.length dst2 → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o3) ∧ copy src dst3 (0 : ℤ) (s * m) ∧ (∀(j' : ℤ), (0 : ℤ) ≤ j' ∧ j' < j → copy src dst3 (start + sigma[Int.toNat j']! * k) k) ∧ copy src dst3 startj i → (let o4 : ℤ := startj + i; ((0 : ℤ) ≤ o4 ∧ o4 < Int.ofNat (List.length src)) ∧ (let o5 : elt := src[Int.toNat o4]!; let o6 : ℤ := startj + i; ((0 : ℤ) ≤ o6 ∧ o6 < Int.ofNat (List.length dst3)) ∧ (List.length (List.set dst3 (Int.toNat o6) o5) = List.length dst3 → getElem! (List.set dst3 (Int.toNat o6) o5) ∘ Int.toNat = Function.update (getElem! dst3 ∘ Int.toNat) o6 o5 → copy src (List.set dst3 (Int.toNat o6) o5) (0 : ℤ) (s * m) ∧ (∀(j' : ℤ), (0 : ℤ) ≤ j' ∧ j' < j → copy src (List.set dst3 (Int.toNat o6) o5) (start + sigma[Int.toNat j']! * k) k) ∧ copy src (List.set dst3 (Int.toNat o6) o5) startj (i + (1 : ℤ)))))) ∧ (copy src dst3 (0 : ℤ) (s * m) ∧ (∀(j' : ℤ), (0 : ℤ) ≤ j' ∧ j' < j → copy src dst3 (start + sigma[Int.toNat j']! * k) k) ∧ copy src dst3 startj (o3 + (1 : ℤ)) → copy src dst3 (0 : ℤ) (s * m) ∧ (∀(j' : ℤ), (0 : ℤ) ≤ j' ∧ j' < j + (1 : ℤ) → copy src dst3 (start + sigma[Int.toNat j']! * k) k)))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → copy src dst2 (0 : ℤ) (s * m) ∧ (∀(j' : ℤ), (0 : ℤ) ≤ j' ∧ j' < j + (1 : ℤ) → copy src dst2 (start + sigma[Int.toNat j']! * k) k)))) ∧ (copy src dst2 (0 : ℤ) (s * m) ∧ (∀(j' : ℤ), (0 : ℤ) ≤ j' ∧ j' < o2 + (1 : ℤ) → copy src dst2 (start + sigma[Int.toNat j']! * k) k) → copy src dst2 (0 : ℤ) ((s + (1 : ℤ)) * m)))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → copy src dst1 (0 : ℤ) ((s + (1 : ℤ)) * m)))))) ∧ (copy src dst1 (0 : ℤ) ((o1 + (1 : ℤ)) * m) → (let last : ℤ := q * m; let o2 : ℤ := r - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → (copy src dst1 (0 : ℤ) (q * m) ∧ copy src dst1 last (0 : ℤ)) ∧ (∀(dst2 : List elt), List.length dst2 = List.length dst1 → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o2) ∧ copy src dst2 (0 : ℤ) (q * m) ∧ copy src dst2 last i → (let o3 : ℤ := last + i; ((0 : ℤ) ≤ o3 ∧ o3 < Int.ofNat (List.length src)) ∧ (let o4 : elt := src[Int.toNat o3]!; let o5 : ℤ := last + i; ((0 : ℤ) ≤ o5 ∧ o5 < Int.ofNat (List.length dst2)) ∧ (List.length (List.set dst2 (Int.toNat o5) o4) = List.length dst2 → getElem! (List.set dst2 (Int.toNat o5) o4) ∘ Int.toNat = Function.update (getElem! dst2 ∘ Int.toNat) o5 o4 → copy src (List.set dst2 (Int.toNat o5) o4) (0 : ℤ) (q * m) ∧ copy src (List.set dst2 (Int.toNat o5) o4) last (i + (1 : ℤ)))))) ∧ (copy src dst2 (0 : ℤ) (q * m) ∧ copy src dst2 last (o2 + (1 : ℤ)) → copy src dst2 (0 : ℤ) (Int.ofNat (List.length dst))))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → copy src dst1 (0 : ℤ) (Int.ofNat (List.length dst))))))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (let last : ℤ := q * m; let o2 : ℤ := r - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → (copy src dst (0 : ℤ) (q * m) ∧ copy src dst last (0 : ℤ)) ∧ (∀(dst1 : List elt), List.length dst1 = List.length dst → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o2) ∧ copy src dst1 (0 : ℤ) (q * m) ∧ copy src dst1 last i → (let o3 : ℤ := last + i; ((0 : ℤ) ≤ o3 ∧ o3 < Int.ofNat (List.length src)) ∧ (let o4 : elt := src[Int.toNat o3]!; let o5 : ℤ := last + i; ((0 : ℤ) ≤ o5 ∧ o5 < Int.ofNat (List.length dst1)) ∧ (List.length (List.set dst1 (Int.toNat o5) o4) = List.length dst1 → getElem! (List.set dst1 (Int.toNat o5) o4) ∘ Int.toNat = Function.update (getElem! dst1 ∘ Int.toNat) o5 o4 → copy src (List.set dst1 (Int.toNat o5) o4) (0 : ℤ) (q * m) ∧ copy src (List.set dst1 (Int.toNat o5) o4) last (i + (1 : ℤ)))))) ∧ (copy src dst1 (0 : ℤ) (q * m) ∧ copy src dst1 last (o2 + (1 : ℤ)) → copy src dst1 (0 : ℤ) (Int.ofNat (List.length dst))))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → copy src dst (0 : ℤ) (Int.ofNat (List.length dst)))))
  := sorry
end verifythis_2024_challenge1_Top_smart_array_copy_0qtvc
