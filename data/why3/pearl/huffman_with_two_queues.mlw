use int.Int
use seq.Seq
use seq.SortedInt
use seq.Sum

function last (s: seq int) : int = s[length s - 1]

let ghost add_last (s: seq int) (x: int) : unit
  requires { length s > 0 }
  requires { sorted s }
  requires { last s <= x }
  ensures  { sorted (snoc s x) }
= ()

let ghost sorted_tail (s: seq int) : unit
  requires { sorted s }
  requires { length s >= 1 }
  ensures  { sorted s[1 .. ] }
= ()

let ghost sorted_tail_tail (s: seq int) : unit
  requires { sorted s }
  requires { length s >= 2 }
  ensures  { sorted s[2 .. ] }
= ()

let huffman_coding (s: seq int) : int
  requires { length s > 0 }
  requires { sorted s }
  ensures  { result = sum s }
= let ref x = s in
  let ref y = empty in
  while length x + length y >= 2 do
    invariant { length x + length y > 0 }
    invariant { sum x + sum y = sum s }
    invariant { sorted x } invariant { sorted y }
    invariant { length x >= 2 -> length y >= 1 -> last y <= x[0] + x[1] }
    invariant { length x >= 1 -> length y >= 2 -> last y <= x[0] + y[0] }
    invariant {                  length y >= 2 -> last y <= y[0] + y[1] }
    variant   { length x + length y }
    if length y = 0 then begin
      y <- snoc y (x[0] + x[1]);
      x <- x[2 .. ]
    end else if length x = 0 then begin
      y <- snoc y[2 .. ] (y[0] + y[1]);
    end else begin (* both non-empty *)
      if x[0] <= y[0] then
        if length x >= 2 && x[1] <= y[0] then begin
          y <- snoc y (x[0] + x[1]);
          x <- x[2 .. ]
        end else begin
          y <- snoc y[1 .. ] (x[0] + y[0]);
          x <- x[1 .. ]
        end
      else
        if length y >= 2 && y[1] <= x[0] then begin
          y <- snoc y[2 .. ] (y[0] + y[1]);
        end else begin
          y <- snoc y[1 .. ] (x[0] + y[0]);
          x <- x[1 .. ]
        end
    end
  done;
  if length x > 0 then x[0] else y[0]
