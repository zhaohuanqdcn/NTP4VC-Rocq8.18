theory Unification_Impl_check_unified_free_varqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "../../lib/isabelle/Unification_Types" "../../lib/isabelle/Functions_Config" "../../lib/isabelle/Functions_Func" "../../lib/isabelle/BacktrackArray_Types" "../../lib/isabelle/Predicates_Pred" "../../lib/isabelle/BacktrackArray_Logic" "../../lib/isabelle/Choice_Choice" "../../lib/isabelle/BacktrackArray_Impl" "../../lib/isabelle/Firstorder_symbol_spec_Spec" "../../lib/isabelle/Nat_Nat" "../../lib/isabelle/OptionFuncs_Funcs" "../../lib/isabelle/Sum_Sum" "../../lib/isabelle/Firstorder_symbol_impl_Types" "../../lib/isabelle/Firstorder_symbol_impl_Logic" "../../lib/isabelle/Firstorder_symbol_impl_Impl" "../../lib/isabelle/Firstorder_term_spec_Spec" "../../lib/isabelle/Firstorder_term_impl_Types" "../../lib/isabelle/Firstorder_term_impl_Logic" "../../lib/isabelle/Firstorder_term_impl_Impl" "../../lib/isabelle/Unification_Logic"
begin
theorem check_unified_free_var'vc:
  fixes rhob :: "sdata t"
  fixes rho :: "unifier_subst"
  fixes t :: "nlimpl_fo_term"
  fixes x :: "int"
  assumes fact0: "unifier_subst_ok rhob rho"
  assumes fact1: "nlimpl_fo_term_ok t"
  assumes fact2: "\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field t) \<longrightarrow> (0 :: int) \<le> y"
  shows "nlimpl_fo_term_ok t"
  and "\<forall>(o1 :: cons_fo_term). cons_ok_fo_term o1 \<and> cons_rel_fo_term o1 t \<and> cons_open_rel_fo_term o1 t \<longrightarrow> (case o1 of NLCVar_fo_term y \<Rightarrow> (correct rhob \<and> (0 :: int) \<le> y) \<and> (let by' :: sdata list = table (current_timestamp rhob) y in list_forall (inv rhob) by' \<longrightarrow> (case by' of Nil \<Rightarrow> (unifier_subst_ok rhob rho \<and> unassigned (current_timestamp rhob) y) \<and> ((let tm :: (int, int) fo_term = Var_fo_term y in tm = subst_fo_term tm subst_id_symbol (unifier_base_model rho) \<and> tm = subst_fo_term tm subst_id_symbol (unifier rho)) \<longrightarrow> \<not>x = y \<longrightarrow> \<not>is_fo_term_free_var_in_fo_term x (subst_fo_term (model_fo_term_field t) subst_id_symbol (unifier rho))) | Cons (PConflict _ _) _ \<Rightarrow> (unifier_subst_ok rhob rho \<and> unassigned (current_timestamp rhob) y) \<and> ((let tm :: (int, int) fo_term = Var_fo_term y in tm = subst_fo_term tm subst_id_symbol (unifier_base_model rho) \<and> tm = subst_fo_term tm subst_id_symbol (unifier rho)) \<longrightarrow> \<not>x = y \<longrightarrow> \<not>is_fo_term_free_var_in_fo_term x (subst_fo_term (model_fo_term_field t) subst_id_symbol (unifier rho))) | Cons (Assign t2) _ \<Rightarrow> (unifier_subst_ok rhob rho \<and> nlimpl_fo_term_ok t2 \<and> (\<forall>(y1 :: int). is_fo_term_free_var_in_fo_term y1 (model_fo_term_field t2) \<longrightarrow> (0 :: int) \<le> y1)) \<and> (\<not>is_fo_term_free_var_in_fo_term x (subst_fo_term (model_fo_term_field t2) subst_id_symbol (unifier rho)) \<longrightarrow> \<not>is_fo_term_free_var_in_fo_term x (subst_fo_term (model_fo_term_field t) subst_id_symbol (unifier rho))))) | NLC_App f l \<Rightarrow> (nlimpl_fo_term_list_ok l \<and> unifier_subst_ok rhob rho \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term_list y (model_fo_term_list_field l) \<longrightarrow> (0 :: int) \<le> y)) \<and> (\<not>is_fo_term_free_var_in_fo_term_list x (subst_fo_term_list (model_fo_term_list_field l) subst_id_symbol (unifier rho)) \<longrightarrow> \<not>is_fo_term_free_var_in_fo_term x (subst_fo_term (model_fo_term_field t) subst_id_symbol (unifier rho))))"
  sorry
end
