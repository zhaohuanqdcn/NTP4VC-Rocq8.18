import Why3.Base
import pearl.search_vcg.lean.search.Path
open Classical
open Lean4Why3
namespace search_Dfs_dfsqtvc
theorem dfs'vc (p : ℤ) (m : ℤ) (s : Path.state) (fact0 : (0 : ℤ) ≤ p) (fact1 : p ≤ m + (1 : ℤ)) : if m < p then ∀(t : Path.state) (n : ℤ), (0 : ℤ) ≤ n ∧ n ≤ m - p → Path.success t → ¬Path.path s t n else if Path.success s then Path.path s s (0 : ℤ) ∧ Path.success s ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ m - p else let mv : List Path.state := Path.moves s; let o1 : ℤ := Int.ofNat (List.length mv) - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → (∀(j : ℤ) (t : Path.state) (n : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → Path.path (mv[Int.toNat j]!) t n → Path.success t → ¬((0 : ℤ) ≤ n ∧ n < m - p)) ∧ (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ (∀(j : ℤ) (t : Path.state) (n : ℤ), (0 : ℤ) ≤ j ∧ j < i → Path.path (mv[Int.toNat j]!) t n → Path.success t → ¬((0 : ℤ) ≤ n ∧ n < m - p)) → (let o2 : ℤ := p + (1 : ℤ); let o3 : Path.state := mv[Int.toNat i]!; (((0 : ℤ) ≤ m - p ∧ m - o2 < m - p) ∧ (0 : ℤ) ≤ o2 ∧ o2 ≤ m + (1 : ℤ)) ∧ (∀(o4 : Path.outcome), (match o4 with | Path.outcome.NoSolution => (∀(t : Path.state) (n : ℤ), (0 : ℤ) ≤ n ∧ n ≤ m - o2 → Path.success t → ¬Path.path o3 t n) | Path.outcome.Solution t n => Path.path o3 t n ∧ Path.success t ∧ (0 : ℤ) ≤ n ∧ n ≤ m - o2) → (match o4 with | Path.outcome.Solution t n => (let o5 : ℤ := n + (1 : ℤ); Path.path s t o5 ∧ Path.success t ∧ (0 : ℤ) ≤ o5 ∧ o5 ≤ m - p) | Path.outcome.NoSolution => (∀(j : ℤ) (t : Path.state) (n : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → Path.path (mv[Int.toNat j]!) t n → Path.success t → ¬((0 : ℤ) ≤ n ∧ n < m - p)))))) ∧ ((∀(j : ℤ) (t : Path.state) (n : ℤ), (0 : ℤ) ≤ j ∧ j < o1 + (1 : ℤ) → Path.path (mv[Int.toNat j]!) t n → Path.success t → ¬((0 : ℤ) ≤ n ∧ n < m - p)) → (∀(t : Path.state) (n : ℤ), (0 : ℤ) ≤ n ∧ n ≤ m - p → Path.success t → ¬Path.path s t n))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (∀(t : Path.state) (n : ℤ), (0 : ℤ) ≤ n ∧ n ≤ m - p → Path.success t → ¬Path.path s t n))
  := sorry
end search_Dfs_dfsqtvc
