import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
open Classical
open Lean4Why3
namespace linked_list_rev_Termination_list_reversalqtvc
axiom loc : Type
axiom inhabited_axiom_loc : Inhabited loc
attribute [instance] inhabited_axiom_loc
axiom null : loc
structure mem where
  next : loc -> loc
axiom inhabited_axiom_mem : Inhabited mem
attribute [instance] inhabited_axiom_mem
noncomputable def valid_cells (s : ℤ -> loc) (n : ℤ) := (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ¬s i = null) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ j ∧ j < n → ¬i = j → ¬s i = s j)
noncomputable def inside_memory (s : ℤ -> loc) (n : ℤ) (l : loc) := l = null ∨ (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ l = s i)
noncomputable def finite_memory (m : mem) (s : ℤ -> loc) (n : ℤ) := ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → inside_memory s n (mem.next m (s i))
axiom fc : (ℤ -> loc) -> (loc -> ℤ) -> ℤ -> Bool
axiom fc'def (s : ℤ -> loc) (idx : loc -> ℤ) (i : ℤ) : (fc s idx i = true) = ((0 : ℤ) < idx (s i))
noncomputable def seen (s : ℤ -> loc) (idx : loc -> ℤ) (lo : ℤ) (hi : ℤ) := NumOf.numof (fc s idx) lo hi
axiom o1 : loc -> ℤ
axiom o'def (p : loc) : o1 p = (if p = null then (0 : ℤ) else -(1 : ℤ))
theorem list_reversal'vc (mem1 : loc -> loc) : let mem2 : mem := mem.mk mem1; ∀(s : ℤ -> loc) (n : ℤ) (l : loc), (0 : ℤ) ≤ n ∧ valid_cells s n ∧ finite_memory mem2 s n ∧ inside_memory s n l → (let o2 : loc -> ℤ := o1; (inside_memory s n l ∧ inside_memory s n null ∧ finite_memory mem2 s n ∧ ((0 : ℤ) = seen s o2 (0 : ℤ) n ∧ (0 : ℤ) ≤ seen s o2 (0 : ℤ) n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → -(1 : ℤ) ≤ o2 (s i) ∧ o2 (s i) ≤ (0 : ℤ)) ∧ (∀(p : loc), (o2 p = (0 : ℤ)) = (p = null)) ∧ (if o2 l = -(1 : ℤ) then o2 null = (0 : ℤ) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) < o2 (s i) → o2 (mem1 (s i)) = o2 (s i) - (1 : ℤ)) else ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) < o2 (s i) ∧ o2 (s i) ≤ o2 l → o2 (mem1 (s i)) = o2 (s i) - (1 : ℤ))) ∧ (∀(idx : loc -> ℤ) (r : loc) (l1 : loc) (mem3 : loc -> loc), inside_memory s n l1 ∧ inside_memory s n r ∧ finite_memory (mem.mk mem3) s n ∧ (0 : ℤ) ≤ seen s idx (0 : ℤ) n ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → -(1 : ℤ) ≤ idx (s i) ∧ idx (s i) ≤ seen s idx (0 : ℤ) n) ∧ (∀(p : loc), (idx p = (0 : ℤ)) = (p = null)) ∧ (if idx l1 = -(1 : ℤ) then idx r = seen s idx (0 : ℤ) n ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) < idx (s i) → idx (mem3 (s i)) = idx (s i) - (1 : ℤ)) else ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) < idx (s i) ∧ idx (s i) ≤ idx l1 → idx (mem3 (s i)) = idx (s i) - (1 : ℤ)) → ¬l1 = null → (if idx l1 = -(1 : ℤ) then (valid_cells s n ∧ inside_memory s n l1 ∧ ¬l1 = null ∧ idx l1 = -(1 : ℤ) ∧ (0 : ℤ) ≤ seen s idx (0 : ℤ) n) ∧ (seen s (Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ))) (0 : ℤ) n = (1 : ℤ) + seen s idx (0 : ℤ) n → ¬l1 = null ∧ ¬l1 = null ∧ ((0 : ℤ) ≤ n - seen s idx (0 : ℤ) n ∧ n - (seen s idx (0 : ℤ) n + (1 : ℤ)) < n - seen s idx (0 : ℤ) n ∨ n - seen s idx (0 : ℤ) n = n - (seen s idx (0 : ℤ) n + (1 : ℤ)) ∧ (0 : ℤ) ≤ (1 : ℤ) + idx l1 ∧ (1 : ℤ) + Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) (mem3 l1) < (1 : ℤ) + idx l1) ∧ inside_memory s n (mem3 l1) ∧ inside_memory s n l1 ∧ finite_memory (mem.mk (Function.update mem3 l1 r)) s n ∧ (seen s idx (0 : ℤ) n + (1 : ℤ) = seen s (Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ))) (0 : ℤ) n ∧ (0 : ℤ) ≤ seen s (Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ))) (0 : ℤ) n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → -(1 : ℤ) ≤ Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) (s i) ∧ Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) (s i) ≤ seen s idx (0 : ℤ) n + (1 : ℤ)) ∧ (∀(p : loc), (Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) p = (0 : ℤ)) = (p = null)) ∧ (if Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) (mem3 l1) = -(1 : ℤ) then Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) l1 = seen s idx (0 : ℤ) n + (1 : ℤ) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) < Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) (s i) → Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) (Function.update mem3 l1 r (s i)) = Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) (s i) - (1 : ℤ)) else ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) < Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) (s i) ∧ Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) (s i) ≤ Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) (mem3 l1) → Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) (Function.update mem3 l1 r (s i)) = Function.update idx l1 (seen s idx (0 : ℤ) n + (1 : ℤ)) (s i) - (1 : ℤ))) else ¬l1 = null ∧ ¬l1 = null ∧ ((0 : ℤ) ≤ n - seen s idx (0 : ℤ) n ∧ n - seen s idx (0 : ℤ) n < n - seen s idx (0 : ℤ) n ∨ (0 : ℤ) ≤ (1 : ℤ) + idx l1 ∧ (1 : ℤ) + idx (mem3 l1) < (1 : ℤ) + idx l1) ∧ inside_memory s n (mem3 l1) ∧ inside_memory s n l1 ∧ finite_memory (mem.mk (Function.update mem3 l1 r)) s n ∧ (0 : ℤ) ≤ seen s idx (0 : ℤ) n ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → -(1 : ℤ) ≤ idx (s i) ∧ idx (s i) ≤ seen s idx (0 : ℤ) n) ∧ (∀(p : loc), (idx p = (0 : ℤ)) = (p = null)) ∧ (if idx (mem3 l1) = -(1 : ℤ) then idx l1 = seen s idx (0 : ℤ) n ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) < idx (s i) → idx (Function.update mem3 l1 r (s i)) = idx (s i) - (1 : ℤ)) else ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) < idx (s i) ∧ idx (s i) ≤ idx (mem3 l1) → idx (Function.update mem3 l1 r (s i)) = idx (s i) - (1 : ℤ)))))
  := sorry
end linked_list_rev_Termination_list_reversalqtvc
