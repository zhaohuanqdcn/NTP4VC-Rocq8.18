import Why3.Base
import pearl.euler_sieve_vcg.lean.euler_sieve.ArithmeticResults
import pearl.euler_sieve_vcg.lean.euler_sieve.DivisibilityResults
import pearl.euler_sieve_vcg.lean.euler_sieve.EulerSieveSpec
import Why3.mach.array.ArrayInt63
open Classical
open Lean4Why3
namespace euler_sieve_EulerSieveImpl_set_markqtvc
axiom t : Type
axiom inhabited_axiom_t : Inhabited t
attribute [instance] inhabited_axiom_t
axiom nexts : t -> List ℤ
axiom marked : t -> List Bool
axiom arr : t -> ArrayInt63.array63
axiom max : t -> BitVec 63
axiom max_arr : t -> BitVec 63
axiom t'invariant (self : t) : BitVec.toInt (max self) < BitVec.toInt int'63_max ∧ (3 : ℤ) ≤ BitVec.toInt (max self) ∧ List.length (nexts self) = List.length (marked self) ∧ Int.ofNat (List.length (marked self)) = BitVec.toInt (max self) + (1 : ℤ) ∧ (BitVec.toInt (max self) - (1 : ℤ)) / (2 : ℤ) = BitVec.toInt (max_arr self) ∧ Int.ofNat (List.length (ArrayInt63.elts (arr self))) = BitVec.toInt (max_arr self) + (1 : ℤ) ∧ EulerSieveSpec.inv_nexts (nexts self) (Int.ofNat (List.length (nexts self))) ∧ EulerSieveSpec.all_eliminated_marked (marked self) (nexts self) ∧ (∀(i : ℤ), (3 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max self) → i % (2 : ℤ) = (0 : ℤ) → (marked self)[Int.toNat i]! = true) ∧ (∀(i : ℤ), (3 : ℤ) ≤ i ∧ i < BitVec.toInt (max self) - (1 : ℤ) → i % (2 : ℤ) = (1 : ℤ) → (nexts self)[Int.toNat i]! % (2 : ℤ) = (1 : ℤ) ∨ (nexts self)[Int.toNat i]! = BitVec.toInt (max self) + (1 : ℤ)) ∧ (nexts self)[Int.toNat (BitVec.toInt (max self))]! = BitVec.toInt (max self) + (1 : ℤ) ∧ ((BitVec.toInt (max self) - (1 : ℤ)) % (2 : ℤ) = (0 : ℤ) → (nexts self)[Int.toNat (BitVec.toInt (max self) - (1 : ℤ))]! = BitVec.toInt (max self)) ∧ ((BitVec.toInt (max self) - (1 : ℤ)) % (2 : ℤ) = (1 : ℤ) → (nexts self)[Int.toNat (BitVec.toInt (max self) - (1 : ℤ))]! = BitVec.toInt (max self) + (1 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → -(BitVec.toInt (max self) + (1 : ℤ)) ≤ (ArrayInt63.elts (arr self))[Int.toNat i]! ∧ (ArrayInt63.elts (arr self))[Int.toNat i]! ≤ BitVec.toInt (max self) + (1 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → ((marked self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true) = ((ArrayInt63.elts (arr self))[Int.toNat i]! < (0 : ℤ))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → ¬(marked self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true → (ArrayInt63.elts (arr self))[Int.toNat i]! = (nexts self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → (marked self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true → (ArrayInt63.elts (arr self))[Int.toNat i]! = -(nexts self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → (i < abs ((ArrayInt63.elts (arr self))[Int.toNat i]!) / (2 : ℤ) ∧ abs ((ArrayInt63.elts (arr self))[Int.toNat i]!) / (2 : ℤ) ≤ BitVec.toInt (max_arr self) + (1 : ℤ)) ∧ abs ((ArrayInt63.elts (arr self))[Int.toNat i]!) ≤ BitVec.toInt (max self) + (1 : ℤ)) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → i < j ∧ j < abs ((ArrayInt63.elts (arr self))[Int.toNat i]!) / (2 : ℤ) → (ArrayInt63.elts (arr self))[Int.toNat j]! < (0 : ℤ))
noncomputable def t'eq (a : t) (b : t) := nexts a = nexts b ∧ marked a = marked b ∧ arr a = arr b ∧ max a = max b ∧ max_arr a = max_arr b
axiom t'inj (a : t) (b : t) (fact0 : t'eq a b) : a = b
theorem set_mark'vc (i : BitVec 63) (t1 : t) (fact0 : (0 : ℤ) ≤ BitVec.toInt i) (fact1 : BitVec.toInt i ≤ BitVec.toInt (max t1)) (fact2 : BitVec.toInt i % (2 : ℤ) = (1 : ℤ)) : ¬(2 : ℤ) = (0 : ℤ) ∧ int'63_in_bounds (Int.tdiv (BitVec.toInt i) (2 : ℤ)) ∧ (∀(x : BitVec 63), BitVec.toInt x = Int.tdiv (BitVec.toInt i) (2 : ℤ) → (let o1 : ArrayInt63.array63 := arr t1; ((0 : ℤ) ≤ BitVec.toInt x ∧ BitVec.toInt x < Int.ofNat (List.length (ArrayInt63.elts o1))) ∧ (∀(o2 : BitVec 63), BitVec.toInt o2 = (ArrayInt63.elts o1)[Int.toNat (BitVec.toInt x)]! → (if (0 : ℤ) ≤ BitVec.toInt o2 then let o3 : ArrayInt63.array63 := arr t1; ((0 : ℤ) ≤ BitVec.toInt x ∧ BitVec.toInt x < Int.ofNat (List.length (ArrayInt63.elts o3))) ∧ (∀(o4 : BitVec 63), BitVec.toInt o4 = (ArrayInt63.elts o3)[Int.toNat (BitVec.toInt x)]! → int'63_in_bounds (-BitVec.toInt o4) ∧ (∀(o5 : BitVec 63), BitVec.toInt o5 = -BitVec.toInt o4 → (let o6 : ArrayInt63.array63 := arr t1; ((0 : ℤ) ≤ BitVec.toInt x ∧ BitVec.toInt x < Int.ofNat (List.length (ArrayInt63.elts o6))) ∧ (∀(t_arr : ArrayInt63.array63), ArrayInt63.size t_arr = ArrayInt63.size o6 → ArrayInt63.size t_arr = ArrayInt63.size (arr t1) → ArrayInt63.elts t_arr = List.set (ArrayInt63.elts o6) (Int.toNat (BitVec.toInt x)) (BitVec.toInt o5) → (let o7 : Bool := true; let o8 : ℤ := BitVec.toInt i; ((0 : ℤ) ≤ o8 ∧ o8 < Int.ofNat (List.length (marked t1))) ∧ (let o9 : List Bool := List.set (marked t1) (Int.toNat o8) o7; List.length o9 = List.length (marked t1) ∧ o9[Int.toNat o8]! = o7 ∧ (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length (marked t1))) ∧ ¬j = o8 → o9[Int.toNat j]! = (marked t1)[Int.toNat j]!) → (∀(t2 : t), ((BitVec.toInt (max t1) < BitVec.toInt int'63_max ∧ (3 : ℤ) ≤ BitVec.toInt (max t1)) ∧ (List.length (nexts t1) = List.length o9 ∧ Int.ofNat (List.length o9) = BitVec.toInt (max t1) + (1 : ℤ)) ∧ (BitVec.toInt (max t1) - (1 : ℤ)) / (2 : ℤ) = BitVec.toInt (max_arr t1) ∧ Int.ofNat (List.length (ArrayInt63.elts t_arr)) = BitVec.toInt (max_arr t1) + (1 : ℤ) ∧ EulerSieveSpec.inv_nexts (nexts t1) (Int.ofNat (List.length (nexts t1))) ∧ EulerSieveSpec.all_eliminated_marked o9 (nexts t1) ∧ (∀(i1 : ℤ), (3 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max t1) → i1 % (2 : ℤ) = (0 : ℤ) → o9[Int.toNat i1]! = true) ∧ (∀(i1 : ℤ), (3 : ℤ) ≤ i1 ∧ i1 < BitVec.toInt (max t1) - (1 : ℤ) → i1 % (2 : ℤ) = (1 : ℤ) → (nexts t1)[Int.toNat i1]! % (2 : ℤ) = (1 : ℤ) ∨ (nexts t1)[Int.toNat i1]! = BitVec.toInt (max t1) + (1 : ℤ)) ∧ ((nexts t1)[Int.toNat (BitVec.toInt (max t1))]! = BitVec.toInt (max t1) + (1 : ℤ) ∧ ((BitVec.toInt (max t1) - (1 : ℤ)) % (2 : ℤ) = (0 : ℤ) → (nexts t1)[Int.toNat (BitVec.toInt (max t1) - (1 : ℤ))]! = BitVec.toInt (max t1)) ∧ ((BitVec.toInt (max t1) - (1 : ℤ)) % (2 : ℤ) = (1 : ℤ) → (nexts t1)[Int.toNat (BitVec.toInt (max t1) - (1 : ℤ))]! = BitVec.toInt (max t1) + (1 : ℤ))) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max_arr t1) → -(BitVec.toInt (max t1) + (1 : ℤ)) ≤ (ArrayInt63.elts t_arr)[Int.toNat i1]! ∧ (ArrayInt63.elts t_arr)[Int.toNat i1]! ≤ BitVec.toInt (max t1) + (1 : ℤ)) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max_arr t1) → (o9[Int.toNat ((2 : ℤ) * i1 + (1 : ℤ))]! = true) = ((ArrayInt63.elts t_arr)[Int.toNat i1]! < (0 : ℤ))) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max_arr t1) → ¬o9[Int.toNat ((2 : ℤ) * i1 + (1 : ℤ))]! = true → (ArrayInt63.elts t_arr)[Int.toNat i1]! = (nexts t1)[Int.toNat ((2 : ℤ) * i1 + (1 : ℤ))]!) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max_arr t1) → o9[Int.toNat ((2 : ℤ) * i1 + (1 : ℤ))]! = true → (ArrayInt63.elts t_arr)[Int.toNat i1]! = -(nexts t1)[Int.toNat ((2 : ℤ) * i1 + (1 : ℤ))]!) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max_arr t1) → (i1 < abs ((ArrayInt63.elts t_arr)[Int.toNat i1]!) / (2 : ℤ) ∧ abs ((ArrayInt63.elts t_arr)[Int.toNat i1]!) / (2 : ℤ) ≤ BitVec.toInt (max_arr t1) + (1 : ℤ)) ∧ abs ((ArrayInt63.elts t_arr)[Int.toNat i1]!) ≤ BitVec.toInt (max t1) + (1 : ℤ)) ∧ (∀(i1 : ℤ) (j : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max_arr t1) → i1 < j ∧ j < abs ((ArrayInt63.elts t_arr)[Int.toNat i1]!) / (2 : ℤ) → (ArrayInt63.elts t_arr)[Int.toNat j]! < (0 : ℤ))) ∧ (max_arr t1 = max_arr t2 ∧ max t1 = max t2 ∧ t_arr = arr t2 ∧ o9 = marked t2 ∧ nexts t1 = nexts t2 → marked t2 = List.set (marked t1) (Int.toNat (BitVec.toInt i)) true)))))))) else let o3 : Bool := true; let o4 : ℤ := BitVec.toInt i; let o5 : List Bool := marked t1; ((0 : ℤ) ≤ o4 ∧ o4 < Int.ofNat (List.length o5)) ∧ (let o6 : List Bool := List.set o5 (Int.toNat o4) o3; List.length o6 = List.length o5 ∧ o6[Int.toNat o4]! = o3 ∧ (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length o5)) ∧ ¬j = o4 → o6[Int.toNat j]! = o5[Int.toNat j]!) → (∀(t2 : t), ((BitVec.toInt (max t1) < BitVec.toInt int'63_max ∧ (3 : ℤ) ≤ BitVec.toInt (max t1)) ∧ (List.length (nexts t1) = List.length o6 ∧ Int.ofNat (List.length o6) = BitVec.toInt (max t1) + (1 : ℤ)) ∧ (BitVec.toInt (max t1) - (1 : ℤ)) / (2 : ℤ) = BitVec.toInt (max_arr t1) ∧ Int.ofNat (List.length (ArrayInt63.elts (arr t1))) = BitVec.toInt (max_arr t1) + (1 : ℤ) ∧ EulerSieveSpec.inv_nexts (nexts t1) (Int.ofNat (List.length (nexts t1))) ∧ EulerSieveSpec.all_eliminated_marked o6 (nexts t1) ∧ (∀(i1 : ℤ), (3 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max t1) → i1 % (2 : ℤ) = (0 : ℤ) → o6[Int.toNat i1]! = true) ∧ (∀(i1 : ℤ), (3 : ℤ) ≤ i1 ∧ i1 < BitVec.toInt (max t1) - (1 : ℤ) → i1 % (2 : ℤ) = (1 : ℤ) → (nexts t1)[Int.toNat i1]! % (2 : ℤ) = (1 : ℤ) ∨ (nexts t1)[Int.toNat i1]! = BitVec.toInt (max t1) + (1 : ℤ)) ∧ ((nexts t1)[Int.toNat (BitVec.toInt (max t1))]! = BitVec.toInt (max t1) + (1 : ℤ) ∧ ((BitVec.toInt (max t1) - (1 : ℤ)) % (2 : ℤ) = (0 : ℤ) → (nexts t1)[Int.toNat (BitVec.toInt (max t1) - (1 : ℤ))]! = BitVec.toInt (max t1)) ∧ ((BitVec.toInt (max t1) - (1 : ℤ)) % (2 : ℤ) = (1 : ℤ) → (nexts t1)[Int.toNat (BitVec.toInt (max t1) - (1 : ℤ))]! = BitVec.toInt (max t1) + (1 : ℤ))) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max_arr t1) → -(BitVec.toInt (max t1) + (1 : ℤ)) ≤ (ArrayInt63.elts (arr t1))[Int.toNat i1]! ∧ (ArrayInt63.elts (arr t1))[Int.toNat i1]! ≤ BitVec.toInt (max t1) + (1 : ℤ)) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max_arr t1) → (o6[Int.toNat ((2 : ℤ) * i1 + (1 : ℤ))]! = true) = ((ArrayInt63.elts (arr t1))[Int.toNat i1]! < (0 : ℤ))) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max_arr t1) → ¬o6[Int.toNat ((2 : ℤ) * i1 + (1 : ℤ))]! = true → (ArrayInt63.elts (arr t1))[Int.toNat i1]! = (nexts t1)[Int.toNat ((2 : ℤ) * i1 + (1 : ℤ))]!) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max_arr t1) → o6[Int.toNat ((2 : ℤ) * i1 + (1 : ℤ))]! = true → (ArrayInt63.elts (arr t1))[Int.toNat i1]! = -(nexts t1)[Int.toNat ((2 : ℤ) * i1 + (1 : ℤ))]!) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max_arr t1) → (i1 < abs ((ArrayInt63.elts (arr t1))[Int.toNat i1]!) / (2 : ℤ) ∧ abs ((ArrayInt63.elts (arr t1))[Int.toNat i1]!) / (2 : ℤ) ≤ BitVec.toInt (max_arr t1) + (1 : ℤ)) ∧ abs ((ArrayInt63.elts (arr t1))[Int.toNat i1]!) ≤ BitVec.toInt (max t1) + (1 : ℤ)) ∧ (∀(i1 : ℤ) (j : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt (max_arr t1) → i1 < j ∧ j < abs ((ArrayInt63.elts (arr t1))[Int.toNat i1]!) / (2 : ℤ) → (ArrayInt63.elts (arr t1))[Int.toNat j]! < (0 : ℤ))) ∧ (max_arr t1 = max_arr t2 ∧ max t1 = max t2 ∧ arr t1 = arr t2 ∧ o6 = marked t2 ∧ nexts t1 = nexts t2 → marked t2 = List.set (marked t1) (Int.toNat (BitVec.toInt i)) true)))))))
  := sorry
end euler_sieve_EulerSieveImpl_set_markqtvc
