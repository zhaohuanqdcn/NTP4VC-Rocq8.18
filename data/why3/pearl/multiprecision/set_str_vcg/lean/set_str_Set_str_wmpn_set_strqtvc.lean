import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import Why3.mach.c.UChar
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.powm.Powm
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.valuation.Valuation
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.sub_1.Sub_1
import pearl.multiprecision.lib.lean.stringlemmas.String_lemmas
import pearl.multiprecision.lib.lean.base_info.BaseInfo
open Classical
open Lean4Why3
namespace set_str_Set_str_wmpn_set_strqtvc
theorem wmpn_set_str'vc (sp : C.ptr (BitVec 8)) (sn : BitVec 32) (rp : C.ptr (BitVec 64)) (sz : BitVec 32) (base : BitVec 32) (fact0 : C.valid sp (BitVec.toUInt sn)) (fact1 : C.valid rp (BitVec.toInt sz)) (fact2 : (0 : ℤ) < BitVec.toInt sz) (fact3 : (0 : ℤ) ≤ BitVec.toUInt sn) (fact4 : HPow.hPow (BitVec.toInt base) (Int.toNat (BitVec.toUInt sn)) ≤ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz - (1 : ℤ)))) (fact5 : (2 : ℤ) ≤ BitVec.toInt base) (fact6 : BitVec.toInt base ≤ (256 : ℤ)) (fact7 : C.writable rp = true) (fact8 : String_lemmas.in_base (BitVec.toInt base) (C.pelts sp) (C.offset sp) (C.offset sp + BitVec.toUInt sn)) (fact9 : BitVec.toUInt sn = (0 : ℤ) → sn = (0 : BitVec 32)) : if sn = (0 : BitVec 32) then (0 : ℤ) ≤ BitVec.toInt sz - (1 : ℤ) ∧ Lemmas.value rp (0 : ℤ) = String_lemmas.svalue (BitVec.toInt base) sp (BitVec.toUInt sn) ∧ ((0 : ℤ) < BitVec.toUInt sn → (0 : ℤ) < BitVec.toInt (C.pelts sp (C.offset sp)) → (0 : ℤ) < BitVec.toUInt (C.pelts rp (C.offset rp + (0 : ℤ) - (1 : ℤ)))) else (0 : ℤ) ≤ BitVec.toInt base ∧ (∀(o1 : BitVec 64), BitVec.toUInt o1 = BitVec.toInt base → ((2 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (256 : ℤ)) ∧ (∀(bits : BitVec 32), ((0 : ℤ) ≤ BitVec.toUInt bits ∧ BitVec.toUInt bits ≤ (8 : ℤ)) ∧ (¬BitVec.toUInt bits = (0 : ℤ) → HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits)) = BitVec.toUInt o1) ∧ (BitVec.toUInt bits = (0 : ℤ) → (∀(n : ℤ), (0 : ℤ) ≤ n → ¬HPow.hPow (2 : ℤ) (Int.toNat n) = BitVec.toUInt o1)) → (BitVec.toUInt bits = (0 : ℤ) → bits = (0 : BitVec 32)) → (if ¬bits = (0 : BitVec 32) then int'32_in_bounds (BitVec.toInt sz - (1 : ℤ)) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toInt sz - (1 : ℤ) → (((0 : ℤ) < BitVec.toUInt sn ∧ BitVec.toUInt sn ≤ (2147483647 : ℤ)) ∧ (0 : ℤ) < BitVec.toInt o2 ∧ C.valid rp (BitVec.toInt o2) ∧ C.valid sp (BitVec.toUInt sn) ∧ ((1 : ℤ) ≤ BitVec.toUInt bits ∧ BitVec.toUInt bits ≤ (8 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits * BitVec.toUInt sn)) ≤ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o2)) ∧ C.writable rp = true ∧ String_lemmas.in_base (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) (C.pelts sp) (C.offset sp) (C.offset sp + BitVec.toUInt sn)) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(r : BitVec 32), ((0 : ℤ) ≤ BitVec.toInt r ∧ BitVec.toInt r ≤ BitVec.toInt o2) ∧ Lemmas.value rp1 (BitVec.toInt r) = String_lemmas.svalue (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) sp (BitVec.toUInt sn) ∧ ((0 : ℤ) < BitVec.toInt r → (0 : ℤ) < BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt r - (1 : ℤ)))) → BitVec.toInt r ≤ BitVec.toInt sz - (1 : ℤ) ∧ Lemmas.value rp1 (BitVec.toInt r) = String_lemmas.svalue (BitVec.toInt base) sp (BitVec.toUInt sn) ∧ ((0 : ℤ) < BitVec.toUInt sn → (0 : ℤ) < BitVec.toInt (C.pelts sp (C.offset sp)) → (0 : ℤ) < BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt r - (1 : ℤ))))))) else (0 : ℤ) ≤ BitVec.toInt base ∧ (∀(o2 : BitVec 64), BitVec.toUInt o2 = BitVec.toInt base → ((2 : ℤ) ≤ BitVec.toUInt o2 ∧ BitVec.toUInt o2 ≤ (256 : ℤ)) ∧ (∀(info : BaseInfo.wmpn_base_info), BaseInfo.b info = BitVec.toUInt o2 → (0 : ℤ) ≤ BitVec.toInt base ∧ (∀(o3 : BitVec 64), BitVec.toUInt o3 = BitVec.toInt base → int'32_in_bounds (BitVec.toInt sz - (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt sz - (1 : ℤ) → (((0 : ℤ) < BitVec.toUInt sn ∧ BitVec.toUInt sn ≤ (2147483647 : ℤ)) ∧ (0 : ℤ) < BitVec.toInt o4 ∧ C.valid rp (BitVec.toInt o4) ∧ C.valid sp (BitVec.toUInt sn) ∧ ((2 : ℤ) ≤ BitVec.toUInt o3 ∧ BitVec.toUInt o3 ≤ (256 : ℤ)) ∧ HPow.hPow (BitVec.toUInt o3) (Int.toNat (BitVec.toUInt sn)) ≤ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o4)) ∧ C.writable rp = true ∧ String_lemmas.in_base (BitVec.toUInt o3) (C.pelts sp) (C.offset sp) (C.offset sp + BitVec.toUInt sn) ∧ BaseInfo.b info = BitVec.toUInt o3) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(r : BitVec 32), ((0 : ℤ) < String_lemmas.svalue (BitVec.toUInt o3) sp (BitVec.toUInt sn) → (1 : ℤ) ≤ BitVec.toInt r ∧ BitVec.toInt r ≤ BitVec.toInt o4) ∧ Lemmas.value rp1 (BitVec.toInt r) = String_lemmas.svalue (BitVec.toUInt o3) sp (BitVec.toUInt sn) ∧ ((0 : ℤ) < String_lemmas.svalue (BitVec.toUInt o3) sp (BitVec.toUInt sn) → (0 : ℤ) < BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt r - (1 : ℤ)))) ∧ (String_lemmas.svalue (BitVec.toUInt o3) sp (BitVec.toUInt sn) = (0 : ℤ) → BitVec.toInt r = (1 : ℤ)) ∧ (0 : ℤ) < BitVec.toInt r → BitVec.toInt r ≤ BitVec.toInt sz - (1 : ℤ) ∧ Lemmas.value rp1 (BitVec.toInt r) = String_lemmas.svalue (BitVec.toInt base) sp (BitVec.toUInt sn) ∧ ((0 : ℤ) < BitVec.toUInt sn → (0 : ℤ) < BitVec.toInt (C.pelts sp (C.offset sp)) → (0 : ℤ) < BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt r - (1 : ℤ)))))))))))))
  := sorry
end set_str_Set_str_wmpn_set_strqtvc
