import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace binary_multiplication_BinaryMultiplication63_binary_multqtvc
theorem binary_mult'vc (a : BitVec 63) (b : BitVec 63) (fact0 : BitVec.toInt int'63_min < BitVec.toInt a * BitVec.toInt b) (fact1 : BitVec.toInt a * BitVec.toInt b ≤ BitVec.toInt int'63_max) : (if (0 : ℤ) ≤ BitVec.toInt a * BitVec.toInt b then (0 : ℤ) ≤ BitVec.toInt a * BitVec.toInt b ∧ (0 : ℤ) ≤ (0 : ℤ) else BitVec.toInt a * BitVec.toInt b ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ)) ∧ (0 : ℤ) + BitVec.toInt a * BitVec.toInt b = BitVec.toInt a * BitVec.toInt b ∧ (∀(z : BitVec 63) (y : BitVec 63) (x : BitVec 63), (if (0 : ℤ) ≤ BitVec.toInt a * BitVec.toInt b then (0 : ℤ) ≤ BitVec.toInt x * BitVec.toInt y ∧ (0 : ℤ) ≤ BitVec.toInt z else BitVec.toInt x * BitVec.toInt y ≤ (0 : ℤ) ∧ BitVec.toInt z ≤ (0 : ℤ)) ∧ BitVec.toInt z + BitVec.toInt x * BitVec.toInt y = BitVec.toInt a * BitVec.toInt b → (BitVec.toInt y = (0 : ℤ) → y = (0 : BitVec 63)) → (if ¬y = (0 : BitVec 63) then (¬(2 : ℤ) = (0 : ℤ) ∧ int'63_in_bounds (Int.tmod (BitVec.toInt y) (2 : ℤ))) ∧ (∀(o1 : BitVec 63), BitVec.toInt o1 = Int.tmod (BitVec.toInt y) (2 : ℤ) → int'63_in_bounds (BitVec.toInt x * BitVec.toInt o1) ∧ (∀(o2 : BitVec 63), BitVec.toInt o2 = BitVec.toInt x * BitVec.toInt o1 → int'63_in_bounds (BitVec.toInt z + BitVec.toInt o2) ∧ (∀(o3 : BitVec 63), BitVec.toInt o3 = BitVec.toInt z + BitVec.toInt o2 → (¬(2 : ℤ) = (0 : ℤ) ∧ int'63_in_bounds (Int.tdiv (BitVec.toInt y) (2 : ℤ))) ∧ (∀(o4 : BitVec 63), BitVec.toInt o4 = Int.tdiv (BitVec.toInt y) (2 : ℤ) → (BitVec.toInt o4 = (0 : ℤ) → o4 = (0 : BitVec 63)) → (if ¬o4 = (0 : BitVec 63) then int'63_in_bounds ((2 : ℤ) * BitVec.toInt x) ∧ (∀(o5 : BitVec 63), BitVec.toInt o5 = (2 : ℤ) * BitVec.toInt x → ((0 : ℤ) ≤ abs (BitVec.toInt y) ∧ abs (BitVec.toInt o4) < abs (BitVec.toInt y)) ∧ (if (0 : ℤ) ≤ BitVec.toInt a * BitVec.toInt b then (0 : ℤ) ≤ BitVec.toInt o5 * BitVec.toInt o4 ∧ (0 : ℤ) ≤ BitVec.toInt o3 else BitVec.toInt o5 * BitVec.toInt o4 ≤ (0 : ℤ) ∧ BitVec.toInt o3 ≤ (0 : ℤ)) ∧ BitVec.toInt o3 + BitVec.toInt o5 * BitVec.toInt o4 = BitVec.toInt a * BitVec.toInt b) else ((0 : ℤ) ≤ abs (BitVec.toInt y) ∧ abs (BitVec.toInt o4) < abs (BitVec.toInt y)) ∧ (if (0 : ℤ) ≤ BitVec.toInt a * BitVec.toInt b then (0 : ℤ) ≤ BitVec.toInt x * BitVec.toInt o4 ∧ (0 : ℤ) ≤ BitVec.toInt o3 else BitVec.toInt x * BitVec.toInt o4 ≤ (0 : ℤ) ∧ BitVec.toInt o3 ≤ (0 : ℤ)) ∧ BitVec.toInt o3 + BitVec.toInt x * BitVec.toInt o4 = BitVec.toInt a * BitVec.toInt b))))) else BitVec.toInt z = BitVec.toInt a * BitVec.toInt b))
  := sorry
end binary_multiplication_BinaryMultiplication63_binary_multqtvc
