import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import Why3.mach.c.UChar
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.powm.Powm
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.valuation.Valuation
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.sub_1.Sub_1
import pearl.multiprecision.lib.lean.stringlemmas.String_lemmas
import pearl.multiprecision.lib.lean.base_info.BaseInfo
open Classical
open Lean4Why3
namespace get_str_Get_str_wmpn_limb_get_strqtvc
theorem wmpn_limb_get_str'vc (binfo : BaseInfo.wmpn_base_info) (sp : C.ptr (BitVec 8)) (d1 : BitVec 64) (shift : BitVec 64) (di : BitVec 64) (sz : BitVec 32) (w : BitVec 64) (fact0 : (2 : ℤ) ≤ BaseInfo.b binfo) (fact1 : BaseInfo.b binfo ≤ (256 : ℤ)) (fact2 : C.writable sp = true) (fact3 : ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt d1) (fact4 : (0 : ℤ) ≤ BitVec.toUInt shift) (fact5 : BitVec.toUInt shift ≤ (63 : ℤ)) (fact6 : BaseInfo.b binfo * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt shift)) = BitVec.toUInt d1) (fact7 : Div.reciprocal di d1) (fact8 : C.valid sp (BitVec.toInt sz)) (fact9 : (0 : ℤ) < BitVec.toInt sz) (fact10 : BitVec.toUInt w < HPow.hPow (BaseInfo.b binfo) (Int.toNat (BitVec.toInt sz))) : let base : ℤ := BaseInfo.b binfo; (((0 : ℤ) ≤ BitVec.toUInt w ∧ BitVec.toUInt w < (18446744073709551615 : ℤ) + (1 : ℤ)) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt sz) ∧ ((0 : ℤ) < BitVec.toUInt w → (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < BitVec.toInt sz) ∧ String_lemmas.in_base base (C.pelts sp) (C.offset sp) (C.offset sp + (0 : ℤ)) ∧ (BitVec.toUInt w = (0 : ℤ) → (0 : ℤ) < (0 : ℤ) → (0 : ℤ) < BitVec.toInt (C.pelts sp (C.offset sp + (0 : ℤ) - (1 : ℤ)))) ∧ BitVec.toUInt w = String_lemmas.svalue_le base sp (0 : ℤ) + HPow.hPow base (0 : ℕ) * BitVec.toUInt w) ∧ (∀(i : BitVec 32) (w1 : BitVec 64) (sp1 : C.ptr (BitVec 8)), List.length (C.data sp1) = List.length (C.data sp) ∧ C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.max sp1 = C.max sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → ((0 : ℤ) ≤ BitVec.toUInt w1 ∧ BitVec.toUInt w1 < (18446744073709551615 : ℤ) + (1 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sz) ∧ ((0 : ℤ) < BitVec.toUInt w1 → (0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i < BitVec.toInt sz) ∧ String_lemmas.in_base base (C.pelts sp1) (C.offset sp1) (C.offset sp1 + BitVec.toInt i) ∧ (BitVec.toUInt w1 = (0 : ℤ) → (0 : ℤ) < BitVec.toInt i → (0 : ℤ) < BitVec.toInt (C.pelts sp1 (C.offset sp1 + BitVec.toInt i - (1 : ℤ)))) ∧ BitVec.toUInt w = String_lemmas.svalue_le base sp1 (BitVec.toInt i) + HPow.hPow base (Int.toNat (BitVec.toInt i)) * BitVec.toUInt w1 ∧ (∀(j : ℤ), j < C.offset sp1 ∨ C.offset sp1 + BitVec.toInt i ≤ j → C.pelts sp1 j = C.pelts sp j) → (if (0 : ℤ) < BitVec.toUInt w1 then uint'64_in_bounds ((64 : ℤ) - BitVec.toUInt shift) ∧ (∀(o1 : BitVec 64), BitVec.toUInt o1 = (64 : ℤ) - BitVec.toUInt shift → ((0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 < (64 : ℤ)) ∧ (∀(h : BitVec 64), BitVec.toUInt h = BitVec.toUInt w1 / HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o1)) → ((0 : ℤ) ≤ BitVec.toUInt shift ∧ BitVec.toUInt shift < (64 : ℤ)) ∧ (∀(l : BitVec 64), BitVec.toUInt l = BitVec.toUInt w1 * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt shift)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt d1 ∧ BitVec.toUInt h < BitVec.toUInt d1 ∧ Div.reciprocal di d1) ∧ (∀(q : BitVec 64) (r : BitVec 64), BitVec.toUInt q * BitVec.toUInt d1 + BitVec.toUInt r = BitVec.toUInt l + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt h ∧ (0 : ℤ) ≤ BitVec.toUInt r ∧ BitVec.toUInt r < BitVec.toUInt d1 → (((0 : ℤ) ≤ BitVec.toUInt shift ∧ BitVec.toUInt shift < (64 : ℤ)) ∧ BitVec.toUInt r % HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt shift)) = (0 : ℤ)) ∧ (∀(nr : BitVec 64), BitVec.toUInt r = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt shift)) * BitVec.toUInt nr → (((0 : ℤ) ≤ BitVec.toUInt shift ∧ BitVec.toUInt shift < (64 : ℤ)) ∧ BitVec.toUInt r % HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt shift)) = (0 : ℤ)) ∧ (∀(o2 : BitVec 64), BitVec.toUInt r = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt shift)) * BitVec.toUInt o2 → ((0 : ℤ) ≤ BitVec.toUInt o2 ∧ BitVec.toUInt o2 ≤ (255 : ℤ)) ∧ (∀(o3 : BitVec 8), BitVec.toInt o3 = BitVec.toUInt o2 → ((C.min sp1 ≤ C.offset sp1 + BitVec.toInt i ∧ C.offset sp1 + BitVec.toInt i < C.max sp1) ∧ C.writable sp1 = true) ∧ (∀(sp2 : C.ptr (BitVec 8)), List.length (C.data sp2) = List.length (C.data sp1) ∧ C.offset sp2 = C.offset sp1 ∧ C.min sp2 = C.min sp1 ∧ C.max sp2 = C.max sp1 ∧ C.writable sp2 = C.writable sp1 ∧ C.zone1 sp2 = C.zone1 sp1 → C.pelts sp2 = Function.update (C.pelts sp1) (C.offset sp2 + BitVec.toInt i) o3 ∧ C.pelts sp2 (C.offset sp2 + BitVec.toInt i) = o3 → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt i + (1 : ℤ) → BitVec.toUInt q < BitVec.toUInt w1 ∧ ((0 : ℤ) ≤ BitVec.toUInt q ∧ BitVec.toUInt q < (18446744073709551615 : ℤ) + (1 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ BitVec.toInt sz) ∧ ((0 : ℤ) < BitVec.toUInt q → (0 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 < BitVec.toInt sz) ∧ String_lemmas.in_base base (C.pelts sp2) (C.offset sp2) (C.offset sp2 + BitVec.toInt o4) ∧ (BitVec.toUInt q = (0 : ℤ) → (0 : ℤ) < BitVec.toInt o4 → (0 : ℤ) < BitVec.toInt (C.pelts sp2 (C.offset sp2 + BitVec.toInt o4 - (1 : ℤ)))) ∧ BitVec.toUInt w = String_lemmas.svalue_le base sp2 (BitVec.toInt o4) + HPow.hPow base (Int.toNat (BitVec.toInt o4)) * BitVec.toUInt q ∧ (∀(j : ℤ), j < C.offset sp2 ∨ C.offset sp2 + BitVec.toInt o4 ≤ j → C.pelts sp2 j = C.pelts sp j)))))))))) else (0 : ℤ) ≤ BitVec.toInt i ∧ (∀(result : BitVec 32), BitVec.toUInt result = BitVec.toInt i → String_lemmas.svalue_le (BaseInfo.b binfo) sp1 (BitVec.toUInt result) = BitVec.toUInt w ∧ ((0 : ℤ) ≤ BitVec.toUInt result ∧ BitVec.toUInt result ≤ BitVec.toInt sz) ∧ ((0 : ℤ) < BitVec.toUInt result → (0 : ℤ) < BitVec.toInt (C.pelts sp1 (C.offset sp1 + BitVec.toUInt result - (1 : ℤ)))) ∧ (∀(i1 : ℤ), i1 < C.offset sp1 ∨ C.offset sp1 + BitVec.toUInt result ≤ i1 → C.pelts sp1 i1 = C.pelts sp i1) ∧ String_lemmas.in_base (BaseInfo.b binfo) (C.pelts sp1) (C.offset sp1) (C.offset sp1 + BitVec.toUInt result))))
  := sorry
end get_str_Get_str_wmpn_limb_get_strqtvc
