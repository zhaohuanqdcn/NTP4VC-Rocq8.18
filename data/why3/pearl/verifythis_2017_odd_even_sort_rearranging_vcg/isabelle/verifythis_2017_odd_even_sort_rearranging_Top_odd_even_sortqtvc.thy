theory verifythis_2017_odd_even_sort_rearranging_Top_odd_even_sortqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_Sum" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut" "Why3STD.array_IntArraySorted"
begin
consts array_max :: "int list \<Rightarrow> int"
axiomatization where array_max'spec:   "a ! nat j \<le> array_max a"
 if "(0 :: int) \<le> j"
 and "j < int (length a)"
  for j :: "int"
  and a :: "int list"
definition aux :: "(int \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int"
  where "aux a m i = i * (m - a i)" for a m i
consts aux_closure :: "(int \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int"
axiomatization where aux_closure_def:   "aux_closure y y1 y2 = aux y y1 y2"
  for y :: "int \<Rightarrow> int"
  and y1 :: "int"
  and y2 :: "int"
definition entropy :: "int list \<Rightarrow> int \<Rightarrow> int"
  where "entropy a m = sum (aux_closure (nth a o nat) m) (0 :: int) (int (length a))" for a m
theorem odd_even_sort'vc:
  fixes a :: "int list"
  assumes fact0: "(0 :: int) < int (length a)"
  shows "let m :: int = array_max a in (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length a) \<longrightarrow> a ! nat j \<le> m) \<longrightarrow> a <~~> a \<and> (\<forall>(ok :: bool) (a1 :: int list). length a1 = length a \<longrightarrow> a <~~> a1 \<and> (ok = True \<longrightarrow> array_IntArraySorted.sorted a1) \<longrightarrow> (if \<not>ok = True then (a <~~> a1 \<and> ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) \<le> int (length a1)) \<and> odd (1 :: int) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (1 :: int) \<longrightarrow> odd j \<longrightarrow> a1 ! nat j \<le> a1 ! nat (j + (1 :: int))) \<and> (\<not>True \<longrightarrow> entropy a1 m < entropy a1 m)) \<and> (\<forall>(i :: int) (ok1 :: bool) (a2 :: int list). length a2 = length a1 \<longrightarrow> a <~~> a2 \<and> ((0 :: int) \<le> i \<and> i \<le> int (length a2)) \<and> odd i \<and> (ok1 = True \<longrightarrow> entropy a2 m = entropy a1 m) \<and> (ok1 = True \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> odd j \<longrightarrow> a2 ! nat j \<le> a2 ! nat (j + (1 :: int)))) \<and> (\<not>ok1 = True \<longrightarrow> entropy a2 m < entropy a1 m) \<longrightarrow> (if i < int (length a2) - (1 :: int) then let o1 :: int = i + (1 :: int) in ((0 :: int) \<le> o1 \<and> o1 < int (length a2)) \<and> ((0 :: int) \<le> i \<and> i < int (length a2)) \<and> (if a2 ! nat o1 < a2 ! nat i then let o2 :: int = i + (1 :: int) in (a2 ! nat o2 < a2 ! nat i \<and> (0 :: int) \<le> i \<and> i < o2 \<and> o2 < int (length a2)) \<and> (\<forall>(a3 :: int list). length a3 = length a2 \<longrightarrow> list_exchange a2 a3 i o2 \<and> entropy a3 m < entropy a2 m \<longrightarrow> ((0 :: int) \<le> int (length a2) - i \<and> int (length a3) - (i + (2 :: int)) < int (length a2) - i) \<and> a <~~> a3 \<and> ((0 :: int) \<le> i + (2 :: int) \<and> i + (2 :: int) \<le> int (length a3)) \<and> odd (i + (2 :: int)) \<and> (False = True \<longrightarrow> entropy a3 m = entropy a1 m) \<and> (False = True \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (2 :: int) \<longrightarrow> odd j \<longrightarrow> a3 ! nat j \<le> a3 ! nat (j + (1 :: int)))) \<and> (\<not>False = True \<longrightarrow> entropy a3 m < entropy a1 m)) else ((0 :: int) \<le> int (length a2) - i \<and> int (length a2) - (i + (2 :: int)) < int (length a2) - i) \<and> a <~~> a2 \<and> ((0 :: int) \<le> i + (2 :: int) \<and> i + (2 :: int) \<le> int (length a2)) \<and> odd (i + (2 :: int)) \<and> (ok1 = True \<longrightarrow> entropy a2 m = entropy a1 m) \<and> (ok1 = True \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (2 :: int) \<longrightarrow> odd j \<longrightarrow> a2 ! nat j \<le> a2 ! nat (j + (1 :: int)))) \<and> (\<not>ok1 = True \<longrightarrow> entropy a2 m < entropy a1 m)) else (a <~~> a2 \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> int (length a2)) \<and> even (0 :: int) \<and> (ok1 = True \<longrightarrow> entropy a2 m = entropy a1 m) \<and> (ok1 = True \<longrightarrow> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < int (length a2) - (1 :: int)) \<and> odd j \<longrightarrow> a2 ! nat j \<le> a2 ! nat (j + (1 :: int)))) \<and> (ok1 = True \<longrightarrow> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < (0 :: int)) \<and> even j \<longrightarrow> a2 ! nat j \<le> a2 ! nat (j + (1 :: int)))) \<and> (\<not>ok1 = True \<longrightarrow> entropy a2 m < entropy a1 m)) \<and> (\<forall>(i1 :: int) (ok2 :: bool) (a3 :: int list). length a3 = length a2 \<longrightarrow> a <~~> a3 \<and> ((0 :: int) \<le> i1 \<and> i1 \<le> int (length a3)) \<and> even i1 \<and> (ok2 = True \<longrightarrow> entropy a3 m = entropy a1 m) \<and> (ok2 = True \<longrightarrow> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < int (length a3) - (1 :: int)) \<and> odd j \<longrightarrow> a3 ! nat j \<le> a3 ! nat (j + (1 :: int)))) \<and> (ok2 = True \<longrightarrow> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < i1) \<and> even j \<longrightarrow> a3 ! nat j \<le> a3 ! nat (j + (1 :: int)))) \<and> (\<not>ok2 = True \<longrightarrow> entropy a3 m < entropy a1 m) \<longrightarrow> (if i1 < int (length a3) - (1 :: int) then let o1 :: int = i1 + (1 :: int) in ((0 :: int) \<le> o1 \<and> o1 < int (length a3)) \<and> ((0 :: int) \<le> i1 \<and> i1 < int (length a3)) \<and> (if a3 ! nat o1 < a3 ! nat i1 then let o2 :: int = i1 + (1 :: int) in (a3 ! nat o2 < a3 ! nat i1 \<and> (0 :: int) \<le> i1 \<and> i1 < o2 \<and> o2 < int (length a3)) \<and> (\<forall>(a4 :: int list). length a4 = length a3 \<longrightarrow> list_exchange a3 a4 i1 o2 \<and> entropy a4 m < entropy a3 m \<longrightarrow> ((0 :: int) \<le> int (length a3) - i1 \<and> int (length a4) - (i1 + (2 :: int)) < int (length a3) - i1) \<and> a <~~> a4 \<and> ((0 :: int) \<le> i1 + (2 :: int) \<and> i1 + (2 :: int) \<le> int (length a4)) \<and> even (i1 + (2 :: int)) \<and> (False = True \<longrightarrow> entropy a4 m = entropy a1 m) \<and> (False = True \<longrightarrow> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < int (length a4) - (1 :: int)) \<and> odd j \<longrightarrow> a4 ! nat j \<le> a4 ! nat (j + (1 :: int)))) \<and> (False = True \<longrightarrow> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < i1 + (2 :: int)) \<and> even j \<longrightarrow> a4 ! nat j \<le> a4 ! nat (j + (1 :: int)))) \<and> (\<not>False = True \<longrightarrow> entropy a4 m < entropy a1 m)) else ((0 :: int) \<le> int (length a3) - i1 \<and> int (length a3) - (i1 + (2 :: int)) < int (length a3) - i1) \<and> a <~~> a3 \<and> ((0 :: int) \<le> i1 + (2 :: int) \<and> i1 + (2 :: int) \<le> int (length a3)) \<and> even (i1 + (2 :: int)) \<and> (ok2 = True \<longrightarrow> entropy a3 m = entropy a1 m) \<and> (ok2 = True \<longrightarrow> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < int (length a3) - (1 :: int)) \<and> odd j \<longrightarrow> a3 ! nat j \<le> a3 ! nat (j + (1 :: int)))) \<and> (ok2 = True \<longrightarrow> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < i1 + (2 :: int)) \<and> even j \<longrightarrow> a3 ! nat j \<le> a3 ! nat (j + (1 :: int)))) \<and> (\<not>ok2 = True \<longrightarrow> entropy a3 m < entropy a1 m)) else ((0 :: int) \<le> entropy a1 m + (if ok = True then 0 :: int else (1 :: int)) \<and> entropy a3 m + (if ok2 = True then 0 :: int else (1 :: int)) < entropy a1 m + (if ok = True then 0 :: int else (1 :: int))) \<and> a <~~> a3 \<and> (ok2 = True \<longrightarrow> array_IntArraySorted.sorted a3))))) else array_IntArraySorted.sorted a1 \<and> a <~~> a1))"
  sorry
end
