import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
import Why3.array.IntArraySorted
open Classical
open Lean4Why3
namespace quicksort_Traditional_quick_recqtvc
theorem quick_rec'vc (l : ℤ) (r : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ l) (fact1 : l ≤ r) (fact2 : r ≤ Int.ofNat (List.length a)) : if r ≤ l + (1 : ℤ) then IntArraySorted.sorted_sub1 a l r ∧ List.permut_sub' a a (Int.toNat l) (Int.toNat r) else ((0 : ℤ) ≤ l ∧ l < Int.ofNat (List.length a)) ∧ (let v : ℤ := a[Int.toNat l]!; ((l ≤ l ∧ l < r - (1 : ℤ)) ∧ (∀(k : ℤ), l ≤ k ∧ k ≤ l → a[Int.toNat k]! ≤ v) ∧ (l < r ∧ r ≤ r) ∧ (∀(k : ℤ), r ≤ k ∧ k < r → v ≤ a[Int.toNat k]!) ∧ List.permut_sub' a a (Int.toNat l) (Int.toNat r) ∧ a[Int.toNat l]! = v) ∧ (∀(j : ℤ) (i : ℤ) (a1 : List ℤ), List.length a1 = List.length a → (l ≤ i ∧ i < r - (1 : ℤ)) ∧ (∀(k : ℤ), l ≤ k ∧ k ≤ i → a1[Int.toNat k]! ≤ v) ∧ (l < j ∧ j ≤ r) ∧ (∀(k : ℤ), j ≤ k ∧ k < r → v ≤ a1[Int.toNat k]!) ∧ List.permut_sub' a a1 (Int.toNat l) (Int.toNat r) ∧ a1[Int.toNat l]! = v → ((i < i + (1 : ℤ) ∧ i + (1 : ℤ) < r) ∧ (∀(k : ℤ), l ≤ k ∧ k < i + (1 : ℤ) → a1[Int.toNat k]! ≤ v)) ∧ (∀(i1 : ℤ), (i < i1 ∧ i1 < r) ∧ (∀(k : ℤ), l ≤ k ∧ k < i1 → a1[Int.toNat k]! ≤ v) → ((0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a1)) ∧ (if a1[Int.toNat i1]! < v then if i1 = r - (1 : ℤ) then ((l ≤ j - (1 : ℤ) ∧ j - (1 : ℤ) < j) ∧ (∀(k : ℤ), j - (1 : ℤ) < k ∧ k < r → v ≤ a1[Int.toNat k]!)) ∧ (∀(j1 : ℤ), (l ≤ j1 ∧ j1 < j) ∧ (∀(k : ℤ), j1 < k ∧ k < r → v ≤ a1[Int.toNat k]!) → ((0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a1)) ∧ (if v < a1[Int.toNat j1]! then if j1 = l then if j1 ≤ i1 then (((0 : ℤ) ≤ l ∧ l < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 l j1 → (((0 : ℤ) ≤ r - l ∧ j1 - l < r - l) ∧ (0 : ℤ) ≤ l ∧ l ≤ j1 ∧ j1 ≤ Int.ofNat (List.length a2)) ∧ (∀(a3 : List ℤ), List.length a3 = List.length a2 → IntArraySorted.sorted_sub1 a3 l j1 ∧ List.permut_sub' a2 a3 (Int.toNat l) (Int.toNat j1) → (let o1 : ℤ := j1 + (1 : ℤ); (((0 : ℤ) ≤ r - l ∧ r - o1 < r - l) ∧ (0 : ℤ) ≤ o1 ∧ o1 ≤ r ∧ r ≤ Int.ofNat (List.length a3)) ∧ (∀(a4 : List ℤ), List.length a4 = List.length a3 → IntArraySorted.sorted_sub1 a4 o1 r ∧ List.permut_sub' a3 a4 (Int.toNat o1) (Int.toNat r) → IntArraySorted.sorted_sub1 a4 l r ∧ List.permut_sub' a a4 (Int.toNat l) (Int.toNat r))))) else (((0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 i1 j1 → ((0 : ℤ) ≤ j - i ∧ j1 - i1 < j - i) ∧ (l ≤ i1 ∧ i1 < r - (1 : ℤ)) ∧ (∀(k : ℤ), l ≤ k ∧ k ≤ i1 → a2[Int.toNat k]! ≤ v) ∧ (l < j1 ∧ j1 ≤ r) ∧ (∀(k : ℤ), j1 ≤ k ∧ k < r → v ≤ a2[Int.toNat k]!) ∧ List.permut_sub' a a2 (Int.toNat l) (Int.toNat r) ∧ a2[Int.toNat l]! = v) else ((0 : ℤ) ≤ j1 ∧ j1 - (1 : ℤ) < j1) ∧ (l ≤ j1 - (1 : ℤ) ∧ j1 - (1 : ℤ) < j) ∧ (∀(k : ℤ), j1 - (1 : ℤ) < k ∧ k < r → v ≤ a1[Int.toNat k]!) else if j1 ≤ i1 then (((0 : ℤ) ≤ l ∧ l < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 l j1 → (((0 : ℤ) ≤ r - l ∧ j1 - l < r - l) ∧ (0 : ℤ) ≤ l ∧ l ≤ j1 ∧ j1 ≤ Int.ofNat (List.length a2)) ∧ (∀(a3 : List ℤ), List.length a3 = List.length a2 → IntArraySorted.sorted_sub1 a3 l j1 ∧ List.permut_sub' a2 a3 (Int.toNat l) (Int.toNat j1) → (let o1 : ℤ := j1 + (1 : ℤ); (((0 : ℤ) ≤ r - l ∧ r - o1 < r - l) ∧ (0 : ℤ) ≤ o1 ∧ o1 ≤ r ∧ r ≤ Int.ofNat (List.length a3)) ∧ (∀(a4 : List ℤ), List.length a4 = List.length a3 → IntArraySorted.sorted_sub1 a4 o1 r ∧ List.permut_sub' a3 a4 (Int.toNat o1) (Int.toNat r) → IntArraySorted.sorted_sub1 a4 l r ∧ List.permut_sub' a a4 (Int.toNat l) (Int.toNat r))))) else (((0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 i1 j1 → ((0 : ℤ) ≤ j - i ∧ j1 - i1 < j - i) ∧ (l ≤ i1 ∧ i1 < r - (1 : ℤ)) ∧ (∀(k : ℤ), l ≤ k ∧ k ≤ i1 → a2[Int.toNat k]! ≤ v) ∧ (l < j1 ∧ j1 ≤ r) ∧ (∀(k : ℤ), j1 ≤ k ∧ k < r → v ≤ a2[Int.toNat k]!) ∧ List.permut_sub' a a2 (Int.toNat l) (Int.toNat r) ∧ a2[Int.toNat l]! = v))) else ((0 : ℤ) ≤ r - i1 ∧ r - (i1 + (1 : ℤ)) < r - i1) ∧ (i < i1 + (1 : ℤ) ∧ i1 + (1 : ℤ) < r) ∧ (∀(k : ℤ), l ≤ k ∧ k < i1 + (1 : ℤ) → a1[Int.toNat k]! ≤ v) else ((l ≤ j - (1 : ℤ) ∧ j - (1 : ℤ) < j) ∧ (∀(k : ℤ), j - (1 : ℤ) < k ∧ k < r → v ≤ a1[Int.toNat k]!)) ∧ (∀(j1 : ℤ), (l ≤ j1 ∧ j1 < j) ∧ (∀(k : ℤ), j1 < k ∧ k < r → v ≤ a1[Int.toNat k]!) → ((0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a1)) ∧ (if v < a1[Int.toNat j1]! then if j1 = l then if j1 ≤ i1 then (((0 : ℤ) ≤ l ∧ l < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 l j1 → (((0 : ℤ) ≤ r - l ∧ j1 - l < r - l) ∧ (0 : ℤ) ≤ l ∧ l ≤ j1 ∧ j1 ≤ Int.ofNat (List.length a2)) ∧ (∀(a3 : List ℤ), List.length a3 = List.length a2 → IntArraySorted.sorted_sub1 a3 l j1 ∧ List.permut_sub' a2 a3 (Int.toNat l) (Int.toNat j1) → (let o1 : ℤ := j1 + (1 : ℤ); (((0 : ℤ) ≤ r - l ∧ r - o1 < r - l) ∧ (0 : ℤ) ≤ o1 ∧ o1 ≤ r ∧ r ≤ Int.ofNat (List.length a3)) ∧ (∀(a4 : List ℤ), List.length a4 = List.length a3 → IntArraySorted.sorted_sub1 a4 o1 r ∧ List.permut_sub' a3 a4 (Int.toNat o1) (Int.toNat r) → IntArraySorted.sorted_sub1 a4 l r ∧ List.permut_sub' a a4 (Int.toNat l) (Int.toNat r))))) else (((0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 i1 j1 → ((0 : ℤ) ≤ j - i ∧ j1 - i1 < j - i) ∧ (l ≤ i1 ∧ i1 < r - (1 : ℤ)) ∧ (∀(k : ℤ), l ≤ k ∧ k ≤ i1 → a2[Int.toNat k]! ≤ v) ∧ (l < j1 ∧ j1 ≤ r) ∧ (∀(k : ℤ), j1 ≤ k ∧ k < r → v ≤ a2[Int.toNat k]!) ∧ List.permut_sub' a a2 (Int.toNat l) (Int.toNat r) ∧ a2[Int.toNat l]! = v) else ((0 : ℤ) ≤ j1 ∧ j1 - (1 : ℤ) < j1) ∧ (l ≤ j1 - (1 : ℤ) ∧ j1 - (1 : ℤ) < j) ∧ (∀(k : ℤ), j1 - (1 : ℤ) < k ∧ k < r → v ≤ a1[Int.toNat k]!) else if j1 ≤ i1 then (((0 : ℤ) ≤ l ∧ l < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 l j1 → (((0 : ℤ) ≤ r - l ∧ j1 - l < r - l) ∧ (0 : ℤ) ≤ l ∧ l ≤ j1 ∧ j1 ≤ Int.ofNat (List.length a2)) ∧ (∀(a3 : List ℤ), List.length a3 = List.length a2 → IntArraySorted.sorted_sub1 a3 l j1 ∧ List.permut_sub' a2 a3 (Int.toNat l) (Int.toNat j1) → (let o1 : ℤ := j1 + (1 : ℤ); (((0 : ℤ) ≤ r - l ∧ r - o1 < r - l) ∧ (0 : ℤ) ≤ o1 ∧ o1 ≤ r ∧ r ≤ Int.ofNat (List.length a3)) ∧ (∀(a4 : List ℤ), List.length a4 = List.length a3 → IntArraySorted.sorted_sub1 a4 o1 r ∧ List.permut_sub' a3 a4 (Int.toNat o1) (Int.toNat r) → IntArraySorted.sorted_sub1 a4 l r ∧ List.permut_sub' a a4 (Int.toNat l) (Int.toNat r))))) else (((0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 i1 j1 → ((0 : ℤ) ≤ j - i ∧ j1 - i1 < j - i) ∧ (l ≤ i1 ∧ i1 < r - (1 : ℤ)) ∧ (∀(k : ℤ), l ≤ k ∧ k ≤ i1 → a2[Int.toNat k]! ≤ v) ∧ (l < j1 ∧ j1 ≤ r) ∧ (∀(k : ℤ), j1 ≤ k ∧ k < r → v ≤ a2[Int.toNat k]!) ∧ List.permut_sub' a a2 (Int.toNat l) (Int.toNat r) ∧ a2[Int.toNat l]! = v)))))))
  := sorry
end quicksort_Traditional_quick_recqtvc
