theory verifythis_2021_shearsort_ShearSort_shear_sortqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_NumOf" "Why3STD.int_Sum" "Why3STD.map_MapExt" "Why3STD.map_MapPermut" "Why3STD.matrix_Matrix"
begin
consts column :: "'a matrix \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a"
axiomatization where column'def:   "column m j i = elts m i j"
  for m :: "'a matrix"
  and j :: "int"
  and i :: "int"
consts moccf :: "'a \<Rightarrow> (int \<Rightarrow> int \<Rightarrow> 'a) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int"
axiomatization where moccf'def:   "moccf x e c i = int (map_occ x (e i) (0 :: int) c)"
  for x :: "'a"
  and e :: "int \<Rightarrow> int \<Rightarrow> 'a"
  and c :: "int"
  and i :: "int"
definition mocc :: "'a \<Rightarrow> (int \<Rightarrow> int \<Rightarrow> 'a) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int"
  where "mocc x e r c = sum (moccf x e c) (0 :: int) r" for x e r c
consts compose :: "('b \<Rightarrow> 'c) \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'c"
axiomatization where compose'def:   "compose g f x = g (f x)"
  for g :: "'b \<Rightarrow> 'c"
  and f :: "'a \<Rightarrow> 'b"
  and x :: "'a"
definition below_column :: "(int \<Rightarrow> int \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "below_column e col v row \<longleftrightarrow> e row col \<le> v" for e col v row
definition above_column :: "(int \<Rightarrow> int \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "above_column e col v row \<longleftrightarrow> v < e row col" for e col v row
consts fc :: "int \<Rightarrow> int"
consts fc1 :: "int \<Rightarrow> int"
consts fc2 :: "int \<Rightarrow> int \<Rightarrow> int"
consts fc3 :: "int \<Rightarrow> int \<Rightarrow> int"
consts fc4 :: "int \<Rightarrow> int \<Rightarrow> int"
consts fc5 :: "int \<Rightarrow> int"
consts fc6 :: "int \<Rightarrow> int"
consts fc7 :: "int \<Rightarrow> int \<Rightarrow> int"
consts below_column_closure :: "(int \<Rightarrow> int \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool"
consts above_column_closure :: "(int \<Rightarrow> int \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool"
consts column_closure :: "'a matrix \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a"
consts fc8 :: "int \<Rightarrow> int"
consts fc9 :: "int \<Rightarrow> int"
consts fc10 :: "int \<Rightarrow> int \<Rightarrow> int"
consts fc11 :: "int \<Rightarrow> int \<Rightarrow> int"
consts fc12 :: "int \<Rightarrow> int \<Rightarrow> int"
consts fc13 :: "int \<Rightarrow> int"
consts fc14 :: "int \<Rightarrow> int"
consts fc15 :: "int \<Rightarrow> int \<Rightarrow> int"
axiomatization where fc'def:   "fc x = (0 :: int)"
  for x :: "int"
axiomatization where fc'def1:   "fc1 x = (0 :: int)"
  for x :: "int"
axiomatization where fc'def2:   "fc2 n x = n"
  for n :: "int"
  and x :: "int"
axiomatization where fc'def3:   "fc3 n x = n"
  for n :: "int"
  and x :: "int"
axiomatization where fc'def4:   "fc4 n x = n"
  for n :: "int"
  and x :: "int"
axiomatization where fc'def5:   "fc5 x = (0 :: int)"
  for x :: "int"
axiomatization where fc'def6:   "fc6 x = (0 :: int)"
  for x :: "int"
axiomatization where fc'def7:   "fc7 n x = n"
  for n :: "int"
  and x :: "int"
axiomatization where below_column_closure_def:   "below_column_closure y y1 y2 y3 = True \<longleftrightarrow> below_column y y1 y2 y3"
  for y :: "int \<Rightarrow> int \<Rightarrow> int"
  and y1 :: "int"
  and y2 :: "int"
  and y3 :: "int"
axiomatization where above_column_closure_def:   "above_column_closure y y1 y2 y3 = True \<longleftrightarrow> above_column y y1 y2 y3"
  for y :: "int \<Rightarrow> int \<Rightarrow> int"
  and y1 :: "int"
  and y2 :: "int"
  and y3 :: "int"
axiomatization where column_closure_def:   "column_closure y y1 = column y y1"
  for y :: "'a matrix"
  and y1 :: "int"
axiomatization where fc'def8:   "fc8 x = (0 :: int)"
  for x :: "int"
axiomatization where fc'def9:   "fc9 x = (0 :: int)"
  for x :: "int"
axiomatization where fc'def10:   "fc10 n x = n"
  for n :: "int"
  and x :: "int"
axiomatization where fc'def11:   "fc11 n x = n"
  for n :: "int"
  and x :: "int"
axiomatization where fc'def12:   "fc12 n x = n"
  for n :: "int"
  and x :: "int"
axiomatization where fc'def13:   "fc13 x = (0 :: int)"
  for x :: "int"
axiomatization where fc'def14:   "fc14 x = (0 :: int)"
  for x :: "int"
axiomatization where fc'def15:   "fc15 n x = n"
  for n :: "int"
  and x :: "int"
theorem shear_sort'vc:
  fixes m :: "int matrix"
  shows "let n :: int = rows m; c :: int = columns m in if \<not>n = (0 :: int) then let o1 :: int = n - (1 :: int) in (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> o1) \<and> o1 * (2 :: int) ^\<^sub>i (0 :: int) < n \<and> n \<le> (2 :: int) ^\<^sub>i (0 :: int) * (o1 + (1 :: int))) \<and> (\<forall>(p :: int) (l :: int). ((0 :: int) \<le> l \<and> (0 :: int) \<le> p) \<and> (\<not>l = (0 :: int) \<longrightarrow> (2 :: int) ^\<^sub>i (l - (1 :: int)) \<le> n) \<and> p * (2 :: int) ^\<^sub>i l < n \<and> n \<le> (2 :: int) ^\<^sub>i l * (p + (1 :: int)) \<longrightarrow> (if \<not>p = (0 :: int) then \<not>(2 :: int) = (0 :: int) \<and> ((0 :: int) \<le> p \<and> p cdiv (2 :: int) < p) \<and> ((0 :: int) \<le> l + (1 :: int) \<and> (0 :: int) \<le> p cdiv (2 :: int)) \<and> (\<not>l + (1 :: int) = (0 :: int) \<longrightarrow> (2 :: int) ^\<^sub>i (l + (1 :: int) - (1 :: int)) \<le> n) \<and> p cdiv (2 :: int) * (2 :: int) ^\<^sub>i (l + (1 :: int)) < n \<and> n \<le> (2 :: int) ^\<^sub>i (l + (1 :: int)) * (p cdiv (2 :: int) + (1 :: int)) else (\<forall>(ones :: int \<Rightarrow> int) (zeros :: int \<Rightarrow> int) (m1 :: int matrix). rows m1 = rows m \<and> columns m1 = columns m \<longrightarrow> (\<forall>(v :: int). (0 :: int) \<le> zeros v \<and> zeros v \<le> ones v \<and> ones v \<le> n) \<and> (\<forall>(v :: int). ones v \<le> zeros v + (1 :: int)) \<and> (\<forall>(v :: int) (i :: int) (j :: int). ((0 :: int) \<le> i \<and> i < zeros v) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> elts m1 i j \<le> v) \<and> (\<forall>(v :: int) (i :: int) (j :: int). (ones v \<le> i \<and> i < n) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> v < elts m1 i j) \<longrightarrow> (\<forall>(i :: int) (j1 :: int) (j2 :: int) (k :: int). ((0 :: int) \<le> i \<and> i < k \<and> k < n) \<and> ((0 :: int) \<le> j1 \<and> j1 < c) \<and> (0 :: int) \<le> j2 \<and> j2 < c \<longrightarrow> elts m1 i j1 \<le> elts m1 k j2)) \<and> ((0 :: int) \<le> l + (1 :: int) \<longrightarrow> ((\<forall>(v :: int). (0 :: int) \<le> fc v \<and> fc1 v \<le> fc2 n v \<and> fc3 n v \<le> n) \<and> (\<forall>(v :: int). fc4 n v \<le> fc5 v + n) \<and> (\<forall>(v :: int) (i :: int) (j :: int). ((0 :: int) \<le> i \<and> i < fc6 v) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> elts m i j \<le> v) \<and> (\<forall>(v :: int) (i :: int) (j :: int). (fc7 n v \<le> i \<and> i < n) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> v < elts m i j) \<and> (0 :: int) < n \<and> ((n - (1 :: int)) * (2 :: int) ^\<^sub>i (0 :: int) < n \<and> n \<le> n * (2 :: int) ^\<^sub>i (0 :: int)) \<and> (l < (0 :: int) \<longrightarrow> (\<forall>(i :: int) (j :: int) (k :: int). ((0 :: int) \<le> i \<and> i < n) \<and> (0 :: int) \<le> j \<and> j \<le> k \<and> k < c \<longrightarrow> (let a :: int = elts m i j; b :: int = elts m i k in if i cmod (2 :: int) = (0 :: int) then a \<le> b else b \<le> a)))) \<and> (\<forall>(ones :: int \<Rightarrow> int) (zeros :: int \<Rightarrow> int) (k :: int) (m1 :: int matrix). rows m1 = rows m \<and> columns m1 = columns m \<longrightarrow> (\<forall>(ind :: int). ((0 :: int) \<le> ind \<and> ind \<le> l) \<and> (\<forall>(v :: int). (0 :: int) \<le> zeros v \<and> zeros v \<le> ones v \<and> ones v \<le> n) \<and> (\<forall>(v :: int). ones v \<le> zeros v + k) \<and> (\<forall>(v :: int) (i :: int) (j :: int). ((0 :: int) \<le> i \<and> i < zeros v) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> elts m1 i j \<le> v) \<and> (\<forall>(v :: int) (i :: int) (j :: int). (ones v \<le> i \<and> i < n) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> v < elts m1 i j) \<and> (0 :: int) < k \<and> ((k - (1 :: int)) * (2 :: int) ^\<^sub>i ind < n \<and> n \<le> k * (2 :: int) ^\<^sub>i ind) \<and> (l < ind \<longrightarrow> (\<forall>(i :: int) (j :: int) (k1 :: int). ((0 :: int) \<le> i \<and> i < n) \<and> (0 :: int) \<le> j \<and> j \<le> k1 \<and> k1 < c \<longrightarrow> (let a :: int = elts m1 i j; b :: int = elts m1 i k1 in if i cmod (2 :: int) = (0 :: int) then a \<le> b else b \<le> a))) \<and> (\<forall>(x :: int). mocc x (elts m) n c = mocc x (elts m1) n c) \<longrightarrow> (\<forall>(m2 :: int matrix). rows m2 = rows m1 \<and> columns m2 = columns m1 \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < rows m2 \<longrightarrow> permut (elts m2 i) (elts m1 i) (0 :: int) (columns m2)) \<and> (\<forall>(i :: int) (j :: int) (k1 :: int). ((0 :: int) \<le> i \<and> i < rows m2) \<and> (0 :: int) \<le> j \<and> j \<le> k1 \<and> k1 < columns m2 \<longrightarrow> (let a :: int = elts m2 i j; b :: int = elts m2 i k1 in if i cmod (2 :: int) = (0 :: int) then a \<le> b else b \<le> a)) \<longrightarrow> (let e :: int \<Rightarrow> int \<Rightarrow> int = elts m2 in \<not>(2 :: int) = (0 :: int) \<and> (let kd :: int = (k + (1 :: int)) cdiv (2 :: int) in (\<forall>(v :: int). let z :: int = zeros v; o2 :: int = ones v in ((z \<le> z \<and> z \<le> o2) \<and> (z \<le> z \<and> o2 \<le> o2) \<and> z - z = (2 :: int) * (z - z + o2 - o2) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < c \<longrightarrow> z \<le> numof (below_column_closure e j v) (0 :: int) z \<and> n - o2 \<le> numof (above_column_closure e j v) (0 :: int) z + numof (above_column_closure e j v) o2 n)) \<and> (\<forall>(index :: int) (no :: int) (nz :: int). (z \<le> index \<and> index \<le> o2) \<and> (z \<le> nz \<and> no \<le> o2) \<and> index - z = (2 :: int) * (nz - z + o2 - no) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < c \<longrightarrow> nz \<le> numof (below_column_closure e j v) (0 :: int) index \<and> n - no \<le> numof (above_column_closure e j v) (0 :: int) index + numof (above_column_closure e j v) o2 n) \<longrightarrow> (if index + (1 :: int) < o2 then (\<forall>(r1 :: int \<Rightarrow> int) (r2 :: int \<Rightarrow> int) (b :: bool). (\<forall>(j :: int) (k1 :: int). (0 :: int) \<le> j \<and> j \<le> k1 \<and> k1 < c \<longrightarrow> (if b = True then r1 j \<le> r1 k1 else r1 k1 \<le> r1 j)) \<and> (\<forall>(j :: int) (k1 :: int). (0 :: int) \<le> j \<and> j \<le> k1 \<and> k1 < c \<longrightarrow> (if b = True then r2 k1 \<le> r2 j else r2 j \<le> r2 k1)) \<longrightarrow> (if \<not>b = True then (((0 :: int) \<le> (if b = True then 0 :: int else (1 :: int)) \<and> (if True then 0 :: int else (1 :: int)) < (if b = True then 0 :: int else (1 :: int))) \<and> (\<forall>(j :: int) (k1 :: int). (0 :: int) \<le> j \<and> j \<le> k1 \<and> k1 < c \<longrightarrow> r2 j \<le> r2 k1) \<and> (\<forall>(j :: int) (k1 :: int). (0 :: int) \<le> j \<and> j \<le> k1 \<and> k1 < c \<longrightarrow> r1 k1 \<le> r1 j)) \<and> (\<forall>(result :: bool). (result = True \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < c \<longrightarrow> r2 i \<le> v \<or> r1 i \<le> v)) \<and> (\<not>result = True \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < c \<longrightarrow> v < r2 i \<or> v < r1 i)) \<longrightarrow> (result = True \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < c \<longrightarrow> r1 i \<le> v \<or> r2 i \<le> v)) \<and> (\<not>result = True \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < c \<longrightarrow> v < r1 i \<or> v < r2 i))) else (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> c) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> r1 j \<le> v \<and> v < r2 j)) \<and> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> c) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> r1 j \<le> v \<and> v < r2 j) \<longrightarrow> (\<forall>(o3 :: bool). (if \<not>i = c then if r1 i \<le> v then o3 = (if v < r2 i then True else False) else o3 = False else o3 = False) \<longrightarrow> (if o3 = True then ((0 :: int) \<le> c - i \<and> c - (i + (1 :: int)) < c - i) \<and> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> c) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> r1 j \<le> v \<and> v < r2 j) else \<forall>(result :: bool). (if i = c then result = True else result = (if r2 i \<le> v then True else False)) \<longrightarrow> (result = True \<longrightarrow> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < c \<longrightarrow> r1 i1 \<le> v \<or> r2 i1 \<le> v)) \<and> (\<not>result = True \<longrightarrow> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < c \<longrightarrow> v < r1 i1 \<or> v < r2 i1))))))) \<and> \<not>(2 :: int) = (0 :: int) \<and> (let o3 :: int = index cmod (2 :: int); o4 :: int \<Rightarrow> int = e (index + (1 :: int)); o5 :: int \<Rightarrow> int = e index in ((\<forall>(j :: int) (k1 :: int). (0 :: int) \<le> j \<and> j \<le> k1 \<and> k1 < c \<longrightarrow> (if o3 = (0 :: int) then o5 j \<le> o5 k1 else o5 k1 \<le> o5 j)) \<and> (\<forall>(j :: int) (k1 :: int). (0 :: int) \<le> j \<and> j \<le> k1 \<and> k1 < c \<longrightarrow> (if o3 = (0 :: int) then o4 k1 \<le> o4 j else o4 j \<le> o4 k1))) \<and> (\<forall>(o6 :: bool). (o6 = True \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < c \<longrightarrow> o5 i \<le> v \<or> o4 i \<le> v)) \<and> (\<not>o6 = True \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < c \<longrightarrow> v < o5 i \<or> v < o4 i)) \<longrightarrow> (if o6 = True then ((0 :: int) \<le> o2 - index \<and> o2 - (index + (2 :: int)) < o2 - index) \<and> (z \<le> index + (2 :: int) \<and> index + (2 :: int) \<le> o2) \<and> (z \<le> nz + (1 :: int) \<and> no \<le> o2) \<and> index + (2 :: int) - z = (2 :: int) * (nz + (1 :: int) - z + o2 - no) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < c \<longrightarrow> nz + (1 :: int) \<le> numof (below_column_closure e j v) (0 :: int) (index + (2 :: int)) \<and> n - no \<le> numof (above_column_closure e j v) (0 :: int) (index + (2 :: int)) + numof (above_column_closure e j v) o2 n) else ((0 :: int) \<le> o2 - index \<and> o2 - (index + (2 :: int)) < o2 - index) \<and> (z \<le> index + (2 :: int) \<and> index + (2 :: int) \<le> o2) \<and> (z \<le> nz \<and> no - (1 :: int) \<le> o2) \<and> index + (2 :: int) - z = (2 :: int) * (nz - z + o2 - (no - (1 :: int))) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < c \<longrightarrow> nz \<le> numof (below_column_closure e j v) (0 :: int) (index + (2 :: int)) \<and> n - (no - (1 :: int)) \<le> numof (above_column_closure e j v) (0 :: int) (index + (2 :: int)) + numof (above_column_closure e j v) o2 n)))) else ((0 :: int) \<le> nz \<and> nz \<le> no \<and> no \<le> n) \<and> no \<le> nz + kd \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < c \<longrightarrow> nz \<le> numof (below_column_closure e j v) (0 :: int) n \<and> n - no \<le> numof (above_column_closure e j v) (0 :: int) n)))) \<and> (\<forall>(nzo :: int \<Rightarrow> int \<times> int). (\<forall>(v :: int). (case nzo v of (nz, no) \<Rightarrow> ((0 :: int) \<le> nz \<and> nz \<le> no \<and> no \<le> n) \<and> no \<le> nz + kd \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < c \<longrightarrow> nz \<le> numof (below_column_closure e j v) (0 :: int) n \<and> n - no \<le> numof (above_column_closure e j v) (0 :: int) n))) \<longrightarrow> (\<forall>(v :: int). let o2 :: int \<times> int = nzo v in (case o2 of (nz, no) \<Rightarrow> ((0 :: int) \<le> nz \<and> nz \<le> no \<and> no \<le> n) \<and> no \<le> nz + kd \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < c \<longrightarrow> nz \<le> numof (below_column_closure e j v) (0 :: int) n \<and> n - no \<le> numof (above_column_closure e j v) (0 :: int) n)) \<longrightarrow> (\<forall>(result :: int). (case o2 of (x, _) \<Rightarrow> result = x) \<longrightarrow> result = (case nzo v of (x, _) \<Rightarrow> x))) \<and> (\<forall>(newz :: int \<Rightarrow> int). (\<forall>(v :: int). newz v = (case nzo v of (x, _) \<Rightarrow> x)) \<longrightarrow> (\<forall>(v :: int). let o2 :: int \<times> int = nzo v in (case o2 of (nz, no) \<Rightarrow> ((0 :: int) \<le> nz \<and> nz \<le> no \<and> no \<le> n) \<and> no \<le> nz + kd \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < c \<longrightarrow> nz \<le> numof (below_column_closure e j v) (0 :: int) n \<and> n - no \<le> numof (above_column_closure e j v) (0 :: int) n)) \<longrightarrow> (\<forall>(result :: int). (case o2 of (_, y) \<Rightarrow> result = y) \<longrightarrow> result = (case nzo v of (_, y) \<Rightarrow> y))) \<and> (\<forall>(newo :: int \<Rightarrow> int). (\<forall>(v :: int). newo v = (case nzo v of (_, y) \<Rightarrow> y)) \<longrightarrow> (ind = l \<longrightarrow> (\<forall>(v :: int). (0 :: int) \<le> zeros v \<and> zeros v \<le> ones v \<and> ones v \<le> n) \<and> (\<forall>(v :: int). ones v \<le> zeros v + (1 :: int)) \<and> (\<forall>(v :: int) (i :: int) (j :: int). ((0 :: int) \<le> i \<and> i < zeros v) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> elts m2 i j \<le> v) \<and> (\<forall>(v :: int) (i :: int) (j :: int). (ones v \<le> i \<and> i < n) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> v < elts m2 i j)) \<and> ((ind = l \<longrightarrow> (\<forall>(i :: int) (j1 :: int) (j2 :: int) (k1 :: int). ((0 :: int) \<le> i \<and> i < k1 \<and> k1 < n) \<and> ((0 :: int) \<le> j1 \<and> j1 < c) \<and> (0 :: int) \<le> j2 \<and> j2 < c \<longrightarrow> elts m2 i j1 \<le> elts m2 k1 j2)) \<longrightarrow> (\<forall>(m3 :: int matrix). rows m3 = rows m2 \<and> columns m3 = columns m2 \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < columns m3 \<longrightarrow> permut (column m3 j) (column m2 j) (0 :: int) (rows m3)) \<and> (\<forall>(i :: int) (j :: int) (k1 :: int). ((0 :: int) \<le> i \<and> i \<le> k1 \<and> k1 < rows m3) \<and> (0 :: int) \<le> j \<and> j < columns m3 \<longrightarrow> elts m3 i j \<le> elts m3 k1 j) \<longrightarrow> (let cl2 :: int \<Rightarrow> int \<Rightarrow> int = column_closure m3; e1 :: int \<Rightarrow> int \<Rightarrow> int = elts m3 in (\<forall>(v :: int) (i :: int) (j :: int). ((0 :: int) \<le> i \<and> i < n) \<and> ((0 :: int) < numof (below_column_closure e1 j v) (i + (1 :: int)) n \<and> (0 :: int) \<le> j \<and> j < c) \<and> v < cl2 j i \<longrightarrow> (let o2 :: int = i + (1 :: int) in ((0 :: int) \<le> n - i \<and> n - o2 < n - i) \<and> ((0 :: int) \<le> o2 \<and> o2 < n) \<and> ((0 :: int) < numof (below_column_closure e1 j v) (o2 + (1 :: int)) n \<and> (0 :: int) \<le> j \<and> j < c) \<and> v < cl2 j o2)) \<and> (\<forall>(v :: int) (i :: int) (j :: int). ((0 :: int) \<le> i \<and> i < n) \<and> ((0 :: int) < numof (above_column_closure e1 j v) (0 :: int) i \<and> (0 :: int) \<le> j \<and> j < c) \<and> cl2 j i \<le> v \<longrightarrow> (let o2 :: int = i - (1 :: int) in ((0 :: int) \<le> i \<and> o2 < i) \<and> ((0 :: int) \<le> o2 \<and> o2 < n) \<and> ((0 :: int) < numof (above_column_closure e1 j v) (0 :: int) o2 \<and> (0 :: int) \<le> j \<and> j < c) \<and> cl2 j o2 \<le> v)) \<and> (\<forall>(v :: int). (0 :: int) \<le> newz v \<and> newz v \<le> newo v \<and> newo v \<le> n) \<and> (\<forall>(v :: int). newo v \<le> newz v + kd) \<and> (\<forall>(v :: int) (i :: int) (j :: int). ((0 :: int) \<le> i \<and> i < newz v) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> elts m3 i j \<le> v) \<and> (\<forall>(v :: int) (i :: int) (j :: int). (newo v \<le> i \<and> i < n) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> v < elts m3 i j) \<and> (0 :: int) < kd \<and> ((kd - (1 :: int)) * (2 :: int) ^\<^sub>i (ind + (1 :: int)) < n \<and> n \<le> kd * (2 :: int) ^\<^sub>i (ind + (1 :: int))) \<and> (l < ind + (1 :: int) \<longrightarrow> (\<forall>(i :: int) (j :: int) (k1 :: int). ((0 :: int) \<le> i \<and> i < n) \<and> (0 :: int) \<le> j \<and> j \<le> k1 \<and> k1 < c \<longrightarrow> (let a :: int = elts m3 i j; b :: int = elts m3 i k1 in if i cmod (2 :: int) = (0 :: int) then a \<le> b else b \<le> a))) \<and> (\<forall>(x :: int). mocc x (elts m) n c = mocc x (elts m3) n c))))))))))) \<and> ((\<forall>(v :: int). (0 :: int) \<le> zeros v \<and> zeros v \<le> ones v \<and> ones v \<le> n) \<and> (\<forall>(v :: int). ones v \<le> zeros v + k) \<and> (\<forall>(v :: int) (i :: int) (j :: int). ((0 :: int) \<le> i \<and> i < zeros v) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> elts m1 i j \<le> v) \<and> (\<forall>(v :: int) (i :: int) (j :: int). (ones v \<le> i \<and> i < n) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> v < elts m1 i j) \<and> (0 :: int) < k \<and> ((k - (1 :: int)) * (2 :: int) ^\<^sub>i (l + (1 :: int)) < n \<and> n \<le> k * (2 :: int) ^\<^sub>i (l + (1 :: int))) \<and> (l < l + (1 :: int) \<longrightarrow> (\<forall>(i :: int) (j :: int) (k1 :: int). ((0 :: int) \<le> i \<and> i < n) \<and> (0 :: int) \<le> j \<and> j \<le> k1 \<and> k1 < c \<longrightarrow> (let a :: int = elts m1 i j; b :: int = elts m1 i k1 in if i cmod (2 :: int) = (0 :: int) then a \<le> b else b \<le> a))) \<and> (\<forall>(x :: int). mocc x (elts m) n c = mocc x (elts m1) n c) \<longrightarrow> ((\<forall>(v :: int). (0 :: int) \<le> zeros v \<and> zeros v \<le> ones v \<and> ones v \<le> n) \<and> (\<forall>(v :: int). ones v \<le> zeros v + (1 :: int)) \<and> (\<forall>(v :: int) (i :: int) (j :: int). ((0 :: int) \<le> i \<and> i < zeros v) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> elts m1 i j \<le> v) \<and> (\<forall>(v :: int) (i :: int) (j :: int). (ones v \<le> i \<and> i < n) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> v < elts m1 i j)) \<and> ((\<forall>(i :: int) (j1 :: int) (j2 :: int) (k1 :: int). ((0 :: int) \<le> i \<and> i < k1 \<and> k1 < n) \<and> ((0 :: int) \<le> j1 \<and> j1 < c) \<and> (0 :: int) \<le> j2 \<and> j2 < c \<longrightarrow> elts m1 i j1 \<le> elts m1 k1 j2) \<longrightarrow> (\<forall>(i :: int) (j1 :: int) (j2 :: int) (k1 :: int). ((0 :: int) \<le> i \<and> i < k1 \<and> k1 < rows m1) \<and> ((0 :: int) \<le> j1 \<and> j1 < columns m1) \<and> (0 :: int) \<le> j2 \<and> j2 < columns m1 \<longrightarrow> elts m1 i j1 \<le> elts m1 k1 j2) \<and> (\<forall>(i :: int) (j :: int) (k1 :: int). ((0 :: int) \<le> i \<and> i < rows m1) \<and> (0 :: int) \<le> j \<and> j \<le> k1 \<and> k1 < columns m1 \<longrightarrow> (if i cmod (2 :: int) = (0 :: int) then elts m1 i j \<le> elts m1 i k1 else elts m1 i k1 \<le> elts m1 i j)) \<and> (\<forall>(x :: int). mocc x (elts m) (rows m1) (columns m1) = mocc x (elts m1) (rows m1) (columns m1)))))) \<and> (l + (1 :: int) < (0 :: int) \<longrightarrow> ((\<forall>(v :: int). (0 :: int) \<le> fc8 v \<and> fc9 v \<le> fc10 n v \<and> fc11 n v \<le> n) \<and> (\<forall>(v :: int). fc12 n v \<le> fc13 v + (1 :: int)) \<and> (\<forall>(v :: int) (i :: int) (j :: int). ((0 :: int) \<le> i \<and> i < fc14 v) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> elts m i j \<le> v) \<and> (\<forall>(v :: int) (i :: int) (j :: int). (fc15 n v \<le> i \<and> i < n) \<and> (0 :: int) \<le> j \<and> j < c \<longrightarrow> v < elts m i j)) \<and> ((\<forall>(i :: int) (j1 :: int) (j2 :: int) (k :: int). ((0 :: int) \<le> i \<and> i < k \<and> k < n) \<and> ((0 :: int) \<le> j1 \<and> j1 < c) \<and> (0 :: int) \<le> j2 \<and> j2 < c \<longrightarrow> elts m i j1 \<le> elts m k j2) \<longrightarrow> (\<forall>(i :: int) (j1 :: int) (j2 :: int) (k :: int). ((0 :: int) \<le> i \<and> i < k \<and> k < rows m) \<and> ((0 :: int) \<le> j1 \<and> j1 < columns m) \<and> (0 :: int) \<le> j2 \<and> j2 < columns m \<longrightarrow> elts m i j1 \<le> elts m k j2) \<and> (\<forall>(i :: int) (j :: int) (k :: int). ((0 :: int) \<le> i \<and> i < rows m) \<and> (0 :: int) \<le> j \<and> j \<le> k \<and> k < columns m \<longrightarrow> (if i cmod (2 :: int) = (0 :: int) then elts m i j \<le> elts m i k else elts m i k \<le> elts m i j)))))) else (\<forall>(i :: int) (j1 :: int) (j2 :: int) (k :: int). ((0 :: int) \<le> i \<and> i < k \<and> k < rows m) \<and> ((0 :: int) \<le> j1 \<and> j1 < columns m) \<and> (0 :: int) \<le> j2 \<and> j2 < columns m \<longrightarrow> elts m i j1 \<le> elts m k j2) \<and> (\<forall>(i :: int) (j :: int) (k :: int). ((0 :: int) \<le> i \<and> i < rows m) \<and> (0 :: int) \<le> j \<and> j \<le> k \<and> k < columns m \<longrightarrow> (if i cmod (2 :: int) = (0 :: int) then elts m i j \<le> elts m i k else elts m i k \<le> elts m i j))"
  sorry
end
