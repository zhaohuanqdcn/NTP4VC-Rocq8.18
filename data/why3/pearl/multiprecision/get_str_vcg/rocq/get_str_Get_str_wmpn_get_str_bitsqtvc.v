From Coq Require Import Strings.String.
From Coq Require Import String Ascii.
From Coq Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Coq Require Classical.
From Coq Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Coq Require Import Sorting.Sorted.
From Coq Require Import Reals.Rbasic_fun.
From Coq Require Import Reals.Abstract.ConstructiveAbs.
From Coq Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Coq Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Coq Require Import ZArith.Zeuclid.
From Coq Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Coq Require Import Reals.
Require Import Why3.Base.
Require Import Why3.why3.Ref.Ref.
Require Import Why3.map.Const.
Require Import Why3.map.MapEq.
Require Import Why3.mach.int.Unsigned.
Require Import Why3.mach.c.C.
Require Import Why3.mach.c.UChar.
Require Import multiprecision.types.Config.
Require Import multiprecision.types.Types.
Require Import multiprecision.types.Int32Eq.
Require Import multiprecision.types.UInt64Eq.
Require Import multiprecision.lemmas.Lemmas.
Require Import multiprecision.powm.Powm.
Require Import multiprecision.compare.Compare.
Require Import multiprecision.valuation.Valuation.
Require Import multiprecision.util.Util.
Require Import multiprecision.ptralias.Alias.
Require Import multiprecision.util.UtilOld.
Require Import multiprecision.add.Add.
Require Import multiprecision.add.AddOld.
Require Import multiprecision.sub.SubOld.
Require Import multiprecision.mul.Mul.
Require Import multiprecision.mul.Mul_basecase.
Require Import multiprecision.logical.LogicalUtil.
Require Import multiprecision.logical.Logical.
Require Import multiprecision.logical.LogicalOld.
Require Import multiprecision.div.Div.
Require Import multiprecision.toom.Toom.
Require Import multiprecision.add_1.Add_1.
Require Import multiprecision.sub_1.Sub_1.
Require Import multiprecision.stringlemmas.String_lemmas.
Require Import multiprecision.base_info.BaseInfo.
Open Scope Z_scope.
Theorem wmpn_get_str_bits'vc (un : bv 32%N) (up : ptr (bv 64%N)) (bits : bv 32%N) (sp : ptr (bv 8%N)) (ub : bv 32%N) (fact0 : 1%Z ≤ bv_signed un) (fact1 : valid up (bv_signed un)) (fact2 : 1%Z ≤ bv_unsigned bits) (fact3 : bv_unsigned bits ≤ 8%Z) (fact4 : valid sp (ZEuclid.div (bv_signed ub + bv_unsigned bits - 1%Z) (bv_unsigned bits))) (fact5 : 0%Z ≤ bv_signed ub) (fact6 : value up (bv_signed un) < Z.pow 2%Z (bv_signed ub)) (fact7 : 0%Z < bv_unsigned (pelts up (offset up + bv_signed un - 1%Z))) (fact8 : 64%Z * bv_signed un + 7%Z ≤ 2147483647%Z) (fact9 : writable sp = true) : int'32_in_bounds (bv_signed un - 1%Z) ∧ (∀(o1 : bv 32%N), bv_signed o1 = bv_signed un - 1%Z -> (min up ≤ offset up + bv_signed o1 ∧ offset up + bv_signed o1 < C.max up) ∧ (let um : bv 64%N := pelts up (offset up + bv_signed o1) in 0%Z < bv_unsigned um ∧ (∀(sb : bv 64%N), (1%Z ≤ bv_unsigned sb ∧ bv_unsigned sb ≤ 64%Z) ∧ Z.pow 2%Z (bv_unsigned sb - 1%Z) ≤ bv_unsigned um ∧ bv_unsigned um < Z.pow 2%Z (bv_unsigned sb) -> bv_unsigned bits ≤ 2147483647%Z ∧ (∀(o2 : bv 32%N), bv_signed o2 = bv_unsigned bits -> bv_unsigned sb ≤ 2147483647%Z ∧ (∀(o3 : bv 32%N), bv_signed o3 = bv_unsigned sb -> int'32_in_bounds (bv_signed un - 1%Z) ∧ (∀(o4 : bv 32%N), bv_signed o4 = bv_signed un - 1%Z -> int'32_in_bounds (64%Z * bv_signed o4) ∧ (∀(o5 : bv 32%N), bv_signed o5 = 64%Z * bv_signed o4 -> int'32_in_bounds (bv_signed o5 + bv_signed o3) ∧ (∀(o6 : bv 32%N), bv_signed o6 = bv_signed o5 + bv_signed o3 -> int'32_in_bounds (bv_signed o6 + bv_signed o2) ∧ (∀(o7 : bv 32%N), bv_signed o7 = bv_signed o6 + bv_signed o2 -> int'32_in_bounds (bv_signed o7 - 1%Z) ∧ (∀(e : bv 32%N), bv_signed e = bv_signed o7 - 1%Z -> bv_unsigned bits ≤ 2147483647%Z ∧ (∀(o8 : bv 32%N), bv_signed o8 = bv_unsigned bits -> (¬ bv_signed o8 = 0%Z ∧ int'32_in_bounds (Z.rem (bv_signed e) (bv_signed o8))) ∧ (∀(sn : bv 32%N), bv_signed sn = Z.rem (bv_signed e) (bv_signed o8) -> (∀(o9 : bv 64%N), bv_unsigned o9 = bv_unsigned bits -> ((0%Z ≤ bv_unsigned o9 ∧ bv_unsigned o9 < 64%Z) ∧ Z.pow 2%Z (bv_unsigned o9) * bv_unsigned (1%bv : bv 64%N) ≤ 18446744073709551615%Z) ∧ (∀(b : bv 64%N), bv_unsigned b = Z.pow 2%Z (bv_unsigned o9) * bv_unsigned (1%bv : bv 64%N) -> ((0%Z ≤ 0%Z ∧ 0%Z ≤ bv_signed un) ∧ (0%Z ≤ bv_signed sn ∧ bv_signed sn ≤ bv_signed sn) ∧ (bv_signed sn - bv_signed sn) * bv_unsigned bits = 0%Z ∧ (0%Z < bv_signed sn -> 0%Z = 64%Z * 0%Z + 0%Z) ∧ (0%Z ≤ 0%Z ∧ 0%Z < 64%Z ∨ (0%bv : bv 32%N) = un) ∧ in_base (bv_unsigned b) (pelts sp) (offset sp + bv_signed sn) (offset sp + bv_signed sn) ∧ (svalue_sub (bv_unsigned b) (pelts sp) (offset sp + bv_signed sn) (offset sp + bv_signed sn) = valueb up 0%Z ∧ 0%Z ≤ 64%Z * bv_signed un ∨ bv_signed sn = 0%Z ∧ svalue (bv_unsigned b) sp (bv_signed sn) = value up (bv_signed un))) ∧ (∀(shift : bv 64%N) (j : bv 32%N) (i : bv 32%N) (sp1 : ptr (bv 8%N)), length (data sp1) = length (data sp) ∧ offset sp1 = offset sp ∧ min sp1 = min sp ∧ C.max sp1 = C.max sp ∧ writable sp1 = writable sp ∧ zone1 sp1 = zone1 sp -> (0%Z ≤ bv_signed i ∧ bv_signed i ≤ bv_signed un) ∧ (0%Z ≤ bv_signed j ∧ bv_signed j ≤ bv_signed sn) ∧ (0%Z < bv_signed j -> (bv_signed sn - bv_signed j) * bv_unsigned bits = 64%Z * bv_signed i + bv_unsigned shift) ∧ (0%Z ≤ bv_unsigned shift ∧ bv_unsigned shift < 64%Z ∨ i = un) ∧ in_base (bv_unsigned b) (pelts sp1) (offset sp1 + bv_signed j) (offset sp1 + bv_signed sn) ∧ (svalue_sub (bv_unsigned b) (pelts sp1) (offset sp1 + bv_signed j) (offset sp1 + bv_signed sn) = valueb up ((bv_signed sn - bv_signed j) * bv_unsigned bits) ∧ (bv_signed sn - bv_signed j) * bv_unsigned bits ≤ 64%Z * bv_signed un ∨ bv_signed j = 0%Z ∧ svalue (bv_unsigned b) sp1 (bv_signed sn) = value up (bv_signed un)) ∧ (∀(k : Z), k < offset sp1 ∨ offset sp1 + bv_signed sn ≤ k -> pelts sp1 k = pelts sp k) -> (if decide (0%Z < bv_signed j) then int'32_in_bounds (bv_signed j - 1%Z) ∧ (∀(o10 : bv 32%N), bv_signed o10 = bv_signed j - 1%Z -> (min up ≤ offset up + bv_signed i ∧ offset up + bv_signed i < C.max up) ∧ (0%Z ≤ bv_unsigned shift ∧ bv_unsigned shift < 64%Z) ∧ (∀(o11 : bv 64%N), bv_unsigned o11 = ZEuclid.div (bv_unsigned (pelts up (offset up + bv_signed i))) (Z.pow 2%Z (bv_unsigned shift)) -> ¬ Z.pow 2%Z (bv_unsigned shift) = 0%Z ∧ (∀(o12 : bv 64%N), bv_unsigned o12 = bv_unsigned bits -> uint'64_in_bounds (bv_unsigned shift + bv_unsigned o12) ∧ (∀(o13 : bv 64%N), bv_unsigned o13 = bv_unsigned shift + bv_unsigned o12 -> (if decide (64%Z ≤ bv_unsigned o13) then int'32_in_bounds (bv_signed i + 1%Z) ∧ (∀(o14 : bv 32%N), bv_signed o14 = bv_signed i + 1%Z -> (if decide (bv_signed o14 < bv_signed un) then uint'64_in_bounds (bv_unsigned o13 - 64%Z) ∧ (∀(o15 : bv 64%N), bv_unsigned o15 = bv_unsigned o13 - 64%Z -> (min up ≤ offset up + bv_signed o14 ∧ offset up + bv_signed o14 < C.max up) ∧ (∀(o16 : bv 64%N), bv_unsigned o16 = bv_unsigned bits -> uint'64_in_bounds (bv_unsigned o16 - bv_unsigned o15) ∧ (∀(o17 : bv 64%N), bv_unsigned o17 = bv_unsigned o16 - bv_unsigned o15 -> (0%Z ≤ bv_unsigned o17 ∧ bv_unsigned o17 < 64%Z) ∧ (∀(high : bv 64%N), bv_unsigned high = ZEuclid.modulo (bv_unsigned (pelts up (offset up + bv_signed o14)) * Z.pow 2%Z (bv_unsigned o17)) (18446744073709551615%Z + 1%Z) -> uint'64_in_bounds (bv_unsigned o11 + bv_unsigned high) ∧ (∀(o18 : bv 64%N), bv_unsigned o18 = bv_unsigned o11 + bv_unsigned high -> (¬ bv_unsigned b = 0%Z ∧ uint'64_in_bounds (Z.quot (bv_unsigned o18) (bv_unsigned b))) ∧ (∀(sj : bv 64%N), bv_unsigned sj = Z.quot (bv_unsigned o18) (bv_unsigned b) -> (0%Z ≤ bv_unsigned sj ∧ bv_unsigned sj ≤ 255%Z) ∧ (∀(o19 : bv 8%N), bv_signed o19 = bv_unsigned sj -> ((min sp1 ≤ offset sp1 + bv_signed o10 ∧ offset sp1 + bv_signed o10 < C.max sp1) ∧ writable sp1 = true) ∧ (∀(sp2 : ptr (bv 8%N)), length (data sp2) = length (data sp1) ∧ offset sp2 = offset sp1 ∧ min sp2 = min sp1 ∧ C.max sp2 = C.max sp1 ∧ writable sp2 = writable sp1 ∧ zone1 sp2 = zone1 sp1 -> pelts sp2 = fun_updt (pelts sp1) (offset sp2 + bv_signed o10) o19 ∧ pelts sp2 (offset sp2 + bv_signed o10) = o19 -> bv_signed o10 < bv_signed j ∧ (0%Z ≤ bv_signed o14 ∧ bv_signed o14 ≤ bv_signed un) ∧ (0%Z ≤ bv_signed o10 ∧ bv_signed o10 ≤ bv_signed sn) ∧ (bv_signed sn - bv_signed o10) * bv_unsigned bits = (bv_signed sn - bv_signed j) * bv_unsigned bits + bv_unsigned bits ∧ (0%Z < bv_signed o10 -> (bv_signed sn - bv_signed j) * bv_unsigned bits + bv_unsigned bits = 64%Z * bv_signed o14 + bv_unsigned o15) ∧ (0%Z ≤ bv_unsigned o15 ∧ bv_unsigned o15 < 64%Z ∨ o14 = un) ∧ in_base (bv_unsigned b) (pelts sp2) (offset sp2 + bv_signed o10) (offset sp2 + bv_signed sn) ∧ (svalue_sub (bv_unsigned b) (pelts sp2) (offset sp2 + bv_signed o10) (offset sp2 + bv_signed sn) = valueb up ((bv_signed sn - bv_signed j) * bv_unsigned bits + bv_unsigned bits) ∧ (bv_signed sn - bv_signed j) * bv_unsigned bits + bv_unsigned bits ≤ 64%Z * bv_signed un ∨ bv_signed o10 = 0%Z ∧ svalue (bv_unsigned b) sp2 (bv_signed sn) = value up (bv_signed un)) ∧ (∀(k : Z), k < offset sp2 ∨ offset sp2 + bv_signed sn ≤ k -> pelts sp2 k = pelts sp k))))))))) else (¬ bv_unsigned b = 0%Z ∧ uint'64_in_bounds (Z.quot (bv_unsigned o11) (bv_unsigned b))) ∧ (∀(sj : bv 64%N), bv_unsigned sj = Z.quot (bv_unsigned o11) (bv_unsigned b) -> (0%Z ≤ bv_unsigned sj ∧ bv_unsigned sj ≤ 255%Z) ∧ (∀(o15 : bv 8%N), bv_signed o15 = bv_unsigned sj -> ((min sp1 ≤ offset sp1 + bv_signed o10 ∧ offset sp1 + bv_signed o10 < C.max sp1) ∧ writable sp1 = true) ∧ (∀(sp2 : ptr (bv 8%N)), length (data sp2) = length (data sp1) ∧ offset sp2 = offset sp1 ∧ min sp2 = min sp1 ∧ C.max sp2 = C.max sp1 ∧ writable sp2 = writable sp1 ∧ zone1 sp2 = zone1 sp1 -> pelts sp2 = fun_updt (pelts sp1) (offset sp2 + bv_signed o10) o15 ∧ pelts sp2 (offset sp2 + bv_signed o10) = o15 -> bv_signed o10 < bv_signed j ∧ (0%Z ≤ bv_signed o14 ∧ bv_signed o14 ≤ bv_signed un) ∧ (0%Z ≤ bv_signed o10 ∧ bv_signed o10 ≤ bv_signed sn) ∧ (bv_signed sn - bv_signed o10) * bv_unsigned bits = (bv_signed sn - bv_signed j) * bv_unsigned bits + bv_unsigned bits ∧ (0%Z < bv_signed o10 -> (bv_signed sn - bv_signed j) * bv_unsigned bits + bv_unsigned bits = 64%Z * bv_signed o14 + bv_unsigned o13) ∧ (0%Z ≤ bv_unsigned o13 ∧ bv_unsigned o13 < 64%Z ∨ o14 = un) ∧ in_base (bv_unsigned b) (pelts sp2) (offset sp2 + bv_signed o10) (offset sp2 + bv_signed sn) ∧ (svalue_sub (bv_unsigned b) (pelts sp2) (offset sp2 + bv_signed o10) (offset sp2 + bv_signed sn) = valueb up ((bv_signed sn - bv_signed j) * bv_unsigned bits + bv_unsigned bits) ∧ (bv_signed sn - bv_signed j) * bv_unsigned bits + bv_unsigned bits ≤ 64%Z * bv_signed un ∨ bv_signed o10 = 0%Z ∧ svalue (bv_unsigned b) sp2 (bv_signed sn) = value up (bv_signed un)) ∧ (∀(k : Z), k < offset sp2 ∨ offset sp2 + bv_signed sn ≤ k -> pelts sp2 k = pelts sp k)))))) else (¬ bv_unsigned b = 0%Z ∧ uint'64_in_bounds (Z.quot (bv_unsigned o11) (bv_unsigned b))) ∧ (∀(sj : bv 64%N), bv_unsigned sj = Z.quot (bv_unsigned o11) (bv_unsigned b) -> (0%Z ≤ bv_unsigned sj ∧ bv_unsigned sj ≤ 255%Z) ∧ (∀(o14 : bv 8%N), bv_signed o14 = bv_unsigned sj -> ((min sp1 ≤ offset sp1 + bv_signed o10 ∧ offset sp1 + bv_signed o10 < C.max sp1) ∧ writable sp1 = true) ∧ (∀(sp2 : ptr (bv 8%N)), length (data sp2) = length (data sp1) ∧ offset sp2 = offset sp1 ∧ min sp2 = min sp1 ∧ C.max sp2 = C.max sp1 ∧ writable sp2 = writable sp1 ∧ zone1 sp2 = zone1 sp1 -> pelts sp2 = fun_updt (pelts sp1) (offset sp2 + bv_signed o10) o14 ∧ pelts sp2 (offset sp2 + bv_signed o10) = o14 -> bv_signed o10 < bv_signed j ∧ (0%Z ≤ bv_signed i ∧ bv_signed i ≤ bv_signed un) ∧ (0%Z ≤ bv_signed o10 ∧ bv_signed o10 ≤ bv_signed sn) ∧ (bv_signed sn - bv_signed o10) * bv_unsigned bits = (bv_signed sn - bv_signed j) * bv_unsigned bits + bv_unsigned bits ∧ (0%Z < bv_signed o10 -> (bv_signed sn - bv_signed j) * bv_unsigned bits + bv_unsigned bits = 64%Z * bv_signed i + bv_unsigned o13) ∧ (0%Z ≤ bv_unsigned o13 ∧ bv_unsigned o13 < 64%Z ∨ i = un) ∧ in_base (bv_unsigned b) (pelts sp2) (offset sp2 + bv_signed o10) (offset sp2 + bv_signed sn) ∧ (svalue_sub (bv_unsigned b) (pelts sp2) (offset sp2 + bv_signed o10) (offset sp2 + bv_signed sn) = valueb up ((bv_signed sn - bv_signed j) * bv_unsigned bits + bv_unsigned bits) ∧ (bv_signed sn - bv_signed j) * bv_unsigned bits + bv_unsigned bits ≤ 64%Z * bv_signed un ∨ bv_signed o10 = 0%Z ∧ svalue (bv_unsigned b) sp2 (bv_signed sn) = value up (bv_signed un)) ∧ (∀(k : Z), k < offset sp2 ∨ offset sp2 + bv_signed sn ≤ k -> pelts sp2 k = pelts sp k))))))))) else 0%Z ≤ bv_signed sn ∧ (∀(result : bv 32%N), bv_unsigned result = bv_signed sn -> in_base (Z.pow 2%Z (bv_unsigned bits)) (pelts sp1) (offset sp1) (offset sp1 + bv_unsigned result) ∧ svalue (Z.pow 2%Z (bv_unsigned bits)) sp1 (bv_unsigned result) = value up (bv_signed un) ∧ (0%Z < bv_unsigned result ∧ bv_unsigned result ≤ ZEuclid.div (bv_signed ub + bv_unsigned bits - 1%Z) (bv_unsigned bits)) ∧ 0%Z < bv_signed (pelts sp1 (offset sp1)) ∧ (∀(j1 : Z), j1 < offset sp1 ∨ offset sp1 + ZEuclid.div (bv_signed ub + bv_unsigned bits - 1%Z) (bv_unsigned bits) ≤ j1 -> pelts sp1 j1 = pelts sp j1)))))))))))))))))).
Proof.
Admitted.
