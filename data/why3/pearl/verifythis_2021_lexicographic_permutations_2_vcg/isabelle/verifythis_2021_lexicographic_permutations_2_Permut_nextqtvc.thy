theory verifythis_2021_lexicographic_permutations_2_Permut_nextqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut" "Why3STD.array_IntArraySorted"
begin
definition sorted_sub :: "int list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "sorted_sub a l u \<longleftrightarrow> (\<forall>(i1 :: int) (i2 :: int). l \<le> i1 \<and> i1 < i2 \<and> i2 < u \<longrightarrow> a ! nat i2 \<le> a ! nat i1)" for a l u
definition sorted :: "int list \<Rightarrow> _"
  where "sorted a \<longleftrightarrow> (\<forall>(i1 :: int) (i2 :: int). (0 :: int) \<le> i1 \<and> i1 < i2 \<and> i2 < int (length a) \<longrightarrow> a ! nat i2 \<le> a ! nat i1)" for a
definition le :: "int list \<Rightarrow> int list \<Rightarrow> _"
  where "le a1 a2 \<longleftrightarrow> length a1 = length a2 \<and> (\<exists>(i :: int). ((0 :: int) \<le> i \<and> i \<le> int (length a1)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> a1 ! nat j = a2 ! nat j) \<and> (i < int (length a1) \<longrightarrow> a1 ! nat i < a2 ! nat i))" for a1 a2
definition lt :: "int list \<Rightarrow> int list \<Rightarrow> _"
  where "lt a1 a2 \<longleftrightarrow> le a1 a2 \<and> \<not>a1 = a2" for a1 a2
consts find_eq :: "int list \<Rightarrow> int list \<Rightarrow> int \<Rightarrow> int"
axiomatization where find_eq'def:   "if i = int (length a1) \<or> \<not>a1 ! nat i = a2 ! nat i then find_eq a1 a2 i = i else find_eq a1 a2 i = find_eq a1 a2 (i + (1 :: int))"
 if "length a1 = length a2"
 and "(0 :: int) \<le> i"
 and "i \<le> int (length a1)"
 and "drop (0 :: nat) (take (nat i - (0 :: nat)) a1) = drop (0 :: nat) (take (nat i - (0 :: nat)) a2)"
  for a1 :: "int list"
  and a2 :: "int list"
  and i :: "int"
axiomatization where find_eq'spec'1'0:   "(0 :: int) \<le> find_eq a1 a2 i"
 if "length a1 = length a2"
 and "(0 :: int) \<le> i"
 and "i \<le> int (length a1)"
 and "drop (0 :: nat) (take (nat i - (0 :: nat)) a1) = drop (0 :: nat) (take (nat i - (0 :: nat)) a2)"
  for a1 :: "int list"
  and a2 :: "int list"
  and i :: "int"
axiomatization where find_eq'spec'1'1:   "find_eq a1 a2 i \<le> int (length a1)"
 if "length a1 = length a2"
 and "(0 :: int) \<le> i"
 and "i \<le> int (length a1)"
 and "drop (0 :: nat) (take (nat i - (0 :: nat)) a1) = drop (0 :: nat) (take (nat i - (0 :: nat)) a2)"
  for a1 :: "int list"
  and a2 :: "int list"
  and i :: "int"
axiomatization where find_eq'spec'0:   "drop (0 :: nat) (take (nat (find_eq a1 a2 i) - (0 :: nat)) a1) = drop (0 :: nat) (take (nat (find_eq a1 a2 i) - (0 :: nat)) a2)"
 if "length a1 = length a2"
 and "(0 :: int) \<le> i"
 and "i \<le> int (length a1)"
 and "drop (0 :: nat) (take (nat i - (0 :: nat)) a1) = drop (0 :: nat) (take (nat i - (0 :: nat)) a2)"
  for a1 :: "int list"
  and a2 :: "int list"
  and i :: "int"
axiomatization where find_eq'spec:   "\<not>a1 ! nat (find_eq a1 a2 i) = a2 ! nat (find_eq a1 a2 i)"
 if "length a1 = length a2"
 and "(0 :: int) \<le> i"
 and "i \<le> int (length a1)"
 and "drop (0 :: nat) (take (nat i - (0 :: nat)) a1) = drop (0 :: nat) (take (nat i - (0 :: nat)) a2)"
 and "find_eq a1 a2 i < int (length a1)"
  for a1 :: "int list"
  and a2 :: "int list"
  and i :: "int"
definition find_le :: "int list \<Rightarrow> int list \<Rightarrow> bool"
  where "find_le a1 a2 = (if length a1 = length a2 then let i :: int = find_eq a1 a2 (0 :: int) in if i = int (length a1) then True else if a1 ! nat i < a2 ! nat i then True else False else False)" for a1 a2
axiomatization where find_le'spec:   "find_le a1 a2 = True \<longleftrightarrow> le a1 a2"
  for a1 :: "int list"
  and a2 :: "int list"
theorem next'vc:
  fixes a :: "int list"
  shows "let o1 :: int = int (length a) - (1 :: int) in (o1 \<le> int (length a) - (1 :: int) \<and> sorted_sub a o1 (int (length a))) \<and> (\<forall>(i :: int). i \<le> int (length a) - (1 :: int) \<and> sorted_sub a i (int (length a)) \<longrightarrow> ((0 :: int) < i \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (let o2 :: int = i - (1 :: int) in (0 :: int) \<le> o2 \<and> o2 < int (length a))) \<and> (\<forall>(o2 :: bool). (if (0 :: int) < i then o2 = (if a ! nat i \<le> a ! nat (i - (1 :: int)) then True else False) else o2 = False) \<longrightarrow> (if o2 = True then ((0 :: int) \<le> i \<and> i - (1 :: int) < i) \<and> i - (1 :: int) \<le> int (length a) - (1 :: int) \<and> sorted_sub a (i - (1 :: int)) (int (length a)) else if i \<le> (0 :: int) then a <~~> a \<and> (\<forall>(a' :: int list). a <~~> a' \<longrightarrow> le a a' \<longrightarrow> a = a') else let o3 :: int = int (length a) - (1 :: int) in ((i \<le> o3 \<and> o3 \<le> int (length a) - (1 :: int)) \<and> (\<forall>(k :: int). o3 < k \<and> k < int (length a) \<longrightarrow> a ! nat k \<le> a ! nat (i - (1 :: int)))) \<and> (\<forall>(j :: int). (i \<le> j \<and> j \<le> int (length a) - (1 :: int)) \<and> (\<forall>(k :: int). j < k \<and> k < int (length a) \<longrightarrow> a ! nat k \<le> a ! nat (i - (1 :: int))) \<longrightarrow> (let o4 :: int = i - (1 :: int) in ((0 :: int) \<le> o4 \<and> o4 < int (length a)) \<and> ((0 :: int) \<le> j \<and> j < int (length a)) \<and> (if a ! nat j \<le> a ! nat o4 then ((0 :: int) \<le> j \<and> j - (1 :: int) < j) \<and> (i \<le> j - (1 :: int) \<and> j - (1 :: int) \<le> int (length a) - (1 :: int)) \<and> (\<forall>(k :: int). j - (1 :: int) < k \<and> k < int (length a) \<longrightarrow> a ! nat k \<le> a ! nat (i - (1 :: int))) else let o5 :: int = i - (1 :: int) in ((0 :: int) \<le> o5 \<and> o5 < int (length a)) \<and> (let o6 :: int = a ! nat o5 in ((0 :: int) \<le> j \<and> j < int (length a)) \<and> (let o7 :: int = a ! nat j; o8 :: int = i - (1 :: int) in ((0 :: int) \<le> o8 \<and> o8 < int (length a)) \<and> (length (a[nat o8 := o7]) = length a \<longrightarrow> nth (a[nat o8 := o7]) o nat = (nth a o nat)(o8 := o7) \<longrightarrow> ((0 :: int) \<le> j \<and> j < int (length (a[nat o8 := o7]))) \<and> (length (a[nat j := o6, nat o8 := o7]) = length (a[nat o8 := o7]) \<longrightarrow> nth (a[nat j := o6, nat o8 := o7]) o nat = (nth (a[nat o8 := o7]) o nat)(j := o6) \<longrightarrow> ((i \<le> i \<and> i < int (length (a[nat j := o6, nat o8 := o7]))) \<and> (i \<le> int (length (a[nat j := o6, nat o8 := o7])) - (1 :: int) \<and> int (length (a[nat j := o6, nat o8 := o7])) - (1 :: int) < int (length (a[nat j := o6, nat o8 := o7]))) \<and> a[nat j := o6, nat o8 := o7] <~~> a[nat j := o6, nat o8 := o7] \<and> drop (0 :: nat) (take (nat i - (0 :: nat)) (a[nat j := o6, nat o8 := o7])) = drop (0 :: nat) (take (nat i - (0 :: nat)) (a[nat j := o6, nat o8 := o7])) \<and> (\<forall>(k1 :: int) (k2 :: int). i \<le> k1 \<and> k1 < k2 \<and> k2 < i \<longrightarrow> a[nat j := o6, nat o8 := o7] ! nat k1 \<le> a[nat j := o6, nat o8 := o7] ! nat k2) \<and> (\<forall>(k1 :: int) (k2 :: int). i \<le> k1 \<and> k1 < k2 \<and> k2 < int (length (a[nat j := o6, nat o8 := o7])) - (1 :: int) + (1 :: int) \<longrightarrow> a[nat j := o6, nat o8 := o7] ! nat k2 \<le> a[nat j := o6, nat o8 := o7] ! nat k1) \<and> (\<forall>(k1 :: int) (k2 :: int). int (length (a[nat j := o6, nat o8 := o7])) - (1 :: int) + (1 :: int) \<le> k1 \<and> k1 < k2 \<and> k2 < int (length (a[nat j := o6, nat o8 := o7])) \<longrightarrow> a[nat j := o6, nat o8 := o7] ! nat k1 \<le> a[nat j := o6, nat o8 := o7] ! nat k2) \<and> (\<forall>(k1 :: int) (k2 :: int). i \<le> k1 \<and> k1 < i \<longrightarrow> i \<le> k2 \<and> k2 \<le> int (length (a[nat j := o6, nat o8 := o7])) - (1 :: int) \<longrightarrow> a[nat j := o6, nat o8 := o7] ! nat k1 \<le> a[nat j := o6, nat o8 := o7] ! nat k2) \<and> (\<forall>(k1 :: int) (k2 :: int). i \<le> k1 \<and> k1 \<le> int (length (a[nat j := o6, nat o8 := o7])) - (1 :: int) \<longrightarrow> int (length (a[nat j := o6, nat o8 := o7])) - (1 :: int) < k2 \<and> k2 < int (length (a[nat j := o6, nat o8 := o7])) \<longrightarrow> a[nat j := o6, nat o8 := o7] ! nat k1 \<le> a[nat j := o6, nat o8 := o7] ! nat k2) \<and> (\<forall>(k1 :: int) (k2 :: int). i \<le> k1 \<and> k1 < i \<longrightarrow> int (length (a[nat j := o6, nat o8 := o7])) - (1 :: int) < k2 \<and> k2 < int (length (a[nat j := o6, nat o8 := o7])) \<longrightarrow> a[nat j := o6, nat o8 := o7] ! nat k1 \<le> a[nat j := o6, nat o8 := o7] ! nat k2)) \<and> (\<forall>(j1 :: int) (i1 :: int) (a1 :: int list). length a1 = length (a[nat j := o6, nat o8 := o7]) \<longrightarrow> (i \<le> i1 \<and> i1 < int (length a1)) \<and> (i \<le> j1 \<and> j1 < int (length a1)) \<and> a1 <~~> a[nat j := o6, nat o8 := o7] \<and> drop (0 :: nat) (take (nat i - (0 :: nat)) a1) = drop (0 :: nat) (take (nat i - (0 :: nat)) (a[nat j := o6, nat o8 := o7])) \<and> (\<forall>(k1 :: int) (k2 :: int). i \<le> k1 \<and> k1 < k2 \<and> k2 < i1 \<longrightarrow> a1 ! nat k1 \<le> a1 ! nat k2) \<and> (\<forall>(k1 :: int) (k2 :: int). i1 \<le> k1 \<and> k1 < k2 \<and> k2 < j1 + (1 :: int) \<longrightarrow> a1 ! nat k2 \<le> a1 ! nat k1) \<and> (\<forall>(k1 :: int) (k2 :: int). j1 + (1 :: int) \<le> k1 \<and> k1 < k2 \<and> k2 < int (length a1) \<longrightarrow> a1 ! nat k1 \<le> a1 ! nat k2) \<and> (\<forall>(k1 :: int) (k2 :: int). i \<le> k1 \<and> k1 < i1 \<longrightarrow> i1 \<le> k2 \<and> k2 \<le> j1 \<longrightarrow> a1 ! nat k1 \<le> a1 ! nat k2) \<and> (\<forall>(k1 :: int) (k2 :: int). i1 \<le> k1 \<and> k1 \<le> j1 \<longrightarrow> j1 < k2 \<and> k2 < int (length a1) \<longrightarrow> a1 ! nat k1 \<le> a1 ! nat k2) \<and> (\<forall>(k1 :: int) (k2 :: int). i \<le> k1 \<and> k1 < i1 \<longrightarrow> j1 < k2 \<and> k2 < int (length a1) \<longrightarrow> a1 ! nat k1 \<le> a1 ! nat k2) \<longrightarrow> (if i1 < j1 then ((0 :: int) \<le> i1 \<and> i1 < int (length a1)) \<and> ((0 :: int) \<le> j1 \<and> j1 < int (length a1)) \<and> (let o9 :: int = a1 ! nat j1 in ((0 :: int) \<le> i1 \<and> i1 < int (length a1)) \<and> (length (a1[nat i1 := o9]) = length a1 \<longrightarrow> nth (a1[nat i1 := o9]) o nat = (nth a1 o nat)(i1 := o9) \<longrightarrow> ((0 :: int) \<le> j1 \<and> j1 < int (length (a1[nat i1 := o9]))) \<and> (length (a1[nat j1 := a1 ! nat i1, nat i1 := o9]) = length (a1[nat i1 := o9]) \<longrightarrow> nth (a1[nat j1 := a1 ! nat i1, nat i1 := o9]) o nat = (nth (a1[nat i1 := o9]) o nat)(j1 := a1 ! nat i1) \<longrightarrow> ((0 :: int) \<le> j1 - i1 \<and> j1 - (1 :: int) - (i1 + (1 :: int)) < j1 - i1) \<and> (i \<le> i1 + (1 :: int) \<and> i1 + (1 :: int) < int (length (a1[nat j1 := a1 ! nat i1, nat i1 := o9]))) \<and> (i \<le> j1 - (1 :: int) \<and> j1 - (1 :: int) < int (length (a1[nat j1 := a1 ! nat i1, nat i1 := o9]))) \<and> a1[nat j1 := a1 ! nat i1, nat i1 := o9] <~~> a[nat j := o6, nat o8 := o7] \<and> drop (0 :: nat) (take (nat i - (0 :: nat)) (a1[nat j1 := a1 ! nat i1, nat i1 := o9])) = drop (0 :: nat) (take (nat i - (0 :: nat)) (a[nat j := o6, nat o8 := o7])) \<and> (\<forall>(k1 :: int) (k2 :: int). i \<le> k1 \<and> k1 < k2 \<and> k2 < i1 + (1 :: int) \<longrightarrow> a1[nat j1 := a1 ! nat i1, nat i1 := o9] ! nat k1 \<le> a1[nat j1 := a1 ! nat i1, nat i1 := o9] ! nat k2) \<and> (\<forall>(k1 :: int) (k2 :: int). i1 + (1 :: int) \<le> k1 \<and> k1 < k2 \<and> k2 < j1 - (1 :: int) + (1 :: int) \<longrightarrow> a1[nat j1 := a1 ! nat i1, nat i1 := o9] ! nat k2 \<le> a1[nat j1 := a1 ! nat i1, nat i1 := o9] ! nat k1) \<and> (\<forall>(k1 :: int) (k2 :: int). j1 - (1 :: int) + (1 :: int) \<le> k1 \<and> k1 < k2 \<and> k2 < int (length (a1[nat j1 := a1 ! nat i1, nat i1 := o9])) \<longrightarrow> a1[nat j1 := a1 ! nat i1, nat i1 := o9] ! nat k1 \<le> a1[nat j1 := a1 ! nat i1, nat i1 := o9] ! nat k2) \<and> (\<forall>(k1 :: int) (k2 :: int). i \<le> k1 \<and> k1 < i1 + (1 :: int) \<longrightarrow> i1 + (1 :: int) \<le> k2 \<and> k2 \<le> j1 - (1 :: int) \<longrightarrow> a1[nat j1 := a1 ! nat i1, nat i1 := o9] ! nat k1 \<le> a1[nat j1 := a1 ! nat i1, nat i1 := o9] ! nat k2) \<and> (\<forall>(k1 :: int) (k2 :: int). i1 + (1 :: int) \<le> k1 \<and> k1 \<le> j1 - (1 :: int) \<longrightarrow> j1 - (1 :: int) < k2 \<and> k2 < int (length (a1[nat j1 := a1 ! nat i1, nat i1 := o9])) \<longrightarrow> a1[nat j1 := a1 ! nat i1, nat i1 := o9] ! nat k1 \<le> a1[nat j1 := a1 ! nat i1, nat i1 := o9] ! nat k2) \<and> (\<forall>(k1 :: int) (k2 :: int). i \<le> k1 \<and> k1 < i1 + (1 :: int) \<longrightarrow> j1 - (1 :: int) < k2 \<and> k2 < int (length (a1[nat j1 := a1 ! nat i1, nat i1 := o9])) \<longrightarrow> a1[nat j1 := a1 ! nat i1, nat i1 := o9] ! nat k1 \<le> a1[nat j1 := a1 ! nat i1, nat i1 := o9] ! nat k2)))) else a1 <~~> a \<and> lt a a1 \<and> (\<forall>(a' :: int list). a <~~> a' \<longrightarrow> lt a a' \<longrightarrow> le a1 a')))))))))))))"
  sorry
end
