theory search_Dfs_dfsqtvc
  imports "NTP4Verif.NTP4Verif" "./search_Path"
begin
theorem dfs'vc:
  fixes p :: "int"
  fixes m :: "int"
  fixes s :: "state"
  assumes fact0: "(0 :: int) \<le> p"
  assumes fact1: "p \<le> m + (1 :: int)"
  shows "if m < p then \<forall>(t :: state) (n :: int). (0 :: int) \<le> n \<and> n \<le> m - p \<longrightarrow> success t \<longrightarrow> \<not>path s t n else if success s then path s s (0 :: int) \<and> success s \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> m - p else let mv :: state list = moves s; o1 :: int = int (length mv) - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> (\<forall>(j :: int) (t :: state) (n :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> path (mv ! nat j) t n \<longrightarrow> success t \<longrightarrow> \<not>((0 :: int) \<le> n \<and> n < m - p)) \<and> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o1) \<and> (\<forall>(j :: int) (t :: state) (n :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> path (mv ! nat j) t n \<longrightarrow> success t \<longrightarrow> \<not>((0 :: int) \<le> n \<and> n < m - p)) \<longrightarrow> (let o2 :: int = p + (1 :: int); o3 :: state = mv ! nat i in (((0 :: int) \<le> m - p \<and> m - o2 < m - p) \<and> (0 :: int) \<le> o2 \<and> o2 \<le> m + (1 :: int)) \<and> (\<forall>(o4 :: outcome). (case o4 of NoSolution \<Rightarrow> (\<forall>(t :: state) (n :: int). (0 :: int) \<le> n \<and> n \<le> m - o2 \<longrightarrow> success t \<longrightarrow> \<not>path o3 t n) | Solution t n \<Rightarrow> path o3 t n \<and> success t \<and> (0 :: int) \<le> n \<and> n \<le> m - o2) \<longrightarrow> (case o4 of Solution t n \<Rightarrow> (let o5 :: int = n + (1 :: int) in path s t o5 \<and> success t \<and> (0 :: int) \<le> o5 \<and> o5 \<le> m - p) | NoSolution \<Rightarrow> (\<forall>(j :: int) (t :: state) (n :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> path (mv ! nat j) t n \<longrightarrow> success t \<longrightarrow> \<not>((0 :: int) \<le> n \<and> n < m - p)))))) \<and> ((\<forall>(j :: int) (t :: state) (n :: int). (0 :: int) \<le> j \<and> j < o1 + (1 :: int) \<longrightarrow> path (mv ! nat j) t n \<longrightarrow> success t \<longrightarrow> \<not>((0 :: int) \<le> n \<and> n < m - p)) \<longrightarrow> (\<forall>(t :: state) (n :: int). (0 :: int) \<le> n \<and> n \<le> m - p \<longrightarrow> success t \<longrightarrow> \<not>path s t n))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> (\<forall>(t :: state) (n :: int). (0 :: int) \<le> n \<and> n \<le> m - p \<longrightarrow> success t \<longrightarrow> \<not>path s t n))"
  sorry
end
