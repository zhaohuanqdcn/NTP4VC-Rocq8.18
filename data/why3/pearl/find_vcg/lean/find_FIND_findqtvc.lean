import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
open Classical
open Lean4Why3
namespace find_FIND_findqtvc
axiom x_N : ℤ
axiom f : ℤ
axiom f_N_range : (1 : ℤ) ≤ f ∧ f ≤ x_N
noncomputable def found (a : List ℤ) := ∀(p : ℤ) (q : ℤ), (1 : ℤ) ≤ p ∧ p ≤ f ∧ f ≤ q ∧ q ≤ x_N → a[Int.toNat p]! ≤ a[Int.toNat f]! ∧ a[Int.toNat f]! ≤ a[Int.toNat q]!
noncomputable def m_invariant (m : ℤ) (a : List ℤ) := m ≤ f ∧ (∀(p : ℤ) (q : ℤ), (1 : ℤ) ≤ p ∧ p < m ∧ m ≤ q ∧ q ≤ x_N → a[Int.toNat p]! ≤ a[Int.toNat q]!)
noncomputable def n_invariant (n : ℤ) (a : List ℤ) := f ≤ n ∧ (∀(p : ℤ) (q : ℤ), (1 : ℤ) ≤ p ∧ p ≤ n ∧ n < q ∧ q ≤ x_N → a[Int.toNat p]! ≤ a[Int.toNat q]!)
noncomputable def i_invariant (m : ℤ) (n : ℤ) (i : ℤ) (q : ℤ) (r : ℤ) (a : List ℤ) := m ≤ i ∧ (∀(p : ℤ), (1 : ℤ) ≤ p ∧ p < i → a[Int.toNat p]! ≤ r) ∧ (i ≤ n → (i ≤ q ∧ q ≤ n) ∧ r ≤ a[Int.toNat q]!)
noncomputable def j_invariant (m : ℤ) (n : ℤ) (j : ℤ) (p : ℤ) (r : ℤ) (a : List ℤ) := j ≤ n ∧ (∀(q : ℤ), j < q ∧ q ≤ x_N → r ≤ a[Int.toNat q]!) ∧ (m ≤ j → (m ≤ p ∧ p ≤ j) ∧ a[Int.toNat p]! ≤ r)
noncomputable def termination (i : ℤ) (j : ℤ) (i0 : ℤ) (j0 : ℤ) (r : ℤ) (a : List ℤ) := i0 < i ∧ j < j0 ∨ (i ≤ f ∧ f ≤ j) ∧ a[Int.toNat f]! = r
theorem find'vc (a : List ℤ) (fact0 : Int.ofNat (List.length a) = x_N + (1 : ℤ)) : m_invariant (1 : ℤ) a ∧ n_invariant x_N a ∧ List.Perm a a ∧ (1 : ℤ) ≤ (1 : ℤ) ∧ x_N ≤ x_N ∧ (∀(n : ℤ) (m : ℤ) (a1 : List ℤ), List.length a1 = List.length a → m_invariant m a1 ∧ n_invariant n a1 ∧ List.Perm a1 a ∧ (1 : ℤ) ≤ m ∧ n ≤ x_N → (if m < n then let o1 : ℤ := f; ((0 : ℤ) ≤ o1 ∧ o1 < Int.ofNat (List.length a1)) ∧ (let r : ℤ := a1[Int.toNat o1]!; (i_invariant m n m f r a1 ∧ j_invariant m n n f r a1 ∧ m_invariant m a1 ∧ n_invariant n a1 ∧ (0 : ℤ) ≤ n ∧ m ≤ x_N + (1 : ℤ) ∧ termination m n m n r a1 ∧ List.Perm a1 a) ∧ (∀(q : ℤ) (p : ℤ) (j : ℤ) (i : ℤ) (a2 : List ℤ), List.length a2 = List.length a1 → i_invariant m n i q r a2 ∧ j_invariant m n j p r a2 ∧ m_invariant m a2 ∧ n_invariant n a2 ∧ (0 : ℤ) ≤ j ∧ i ≤ x_N + (1 : ℤ) ∧ termination i j m n r a2 ∧ List.Perm a2 a → (if i ≤ j then (i_invariant m n i q r a2 ∧ (i ≤ i ∧ i ≤ n) ∧ termination i j m n r a2) ∧ (∀(i1 : ℤ), i_invariant m n i1 q r a2 ∧ (i ≤ i1 ∧ i1 ≤ n) ∧ termination i1 j m n r a2 → ((0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a2)) ∧ (if a2[Int.toNat i1]! < r then ((0 : ℤ) ≤ x_N + (1 : ℤ) - i1 ∧ x_N + (1 : ℤ) - (i1 + (1 : ℤ)) < x_N + (1 : ℤ) - i1) ∧ i_invariant m n (i1 + (1 : ℤ)) q r a2 ∧ (i ≤ i1 + (1 : ℤ) ∧ i1 + (1 : ℤ) ≤ n) ∧ termination (i1 + (1 : ℤ)) j m n r a2 else (j_invariant m n j p r a2 ∧ j ≤ j ∧ m ≤ j ∧ termination i1 j m n r a2) ∧ (∀(j1 : ℤ), j_invariant m n j1 p r a2 ∧ j1 ≤ j ∧ m ≤ j1 ∧ termination i1 j1 m n r a2 → ((0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a2)) ∧ (if r < a2[Int.toNat j1]! then ((0 : ℤ) ≤ j1 ∧ j1 - (1 : ℤ) < j1) ∧ j_invariant m n (j1 - (1 : ℤ)) p r a2 ∧ j1 - (1 : ℤ) ≤ j ∧ m ≤ j1 - (1 : ℤ) ∧ termination i1 (j1 - (1 : ℤ)) m n r a2 else if i1 ≤ j1 then ((0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a2)) ∧ (let w : ℤ := a2[Int.toNat i1]!; ((0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a2)) ∧ (let o2 : ℤ := a2[Int.toNat j1]!; ((0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat i1) o2) = List.length a2 → getElem! (List.set a2 (Int.toNat i1) o2) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) i1 o2 → ((0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length (List.set a2 (Int.toNat i1) o2))) ∧ (List.length (List.set (List.set a2 (Int.toNat i1) o2) (Int.toNat j1) w) = List.length (List.set a2 (Int.toNat i1) o2) → getElem! (List.set (List.set a2 (Int.toNat i1) o2) (Int.toNat j1) w) ∘ Int.toNat = Function.update (getElem! (List.set a2 (Int.toNat i1) o2) ∘ Int.toNat) j1 w → (∀(o3 : ℤ), (if i1 < j1 then o3 = i1 else o3 = j1 - (1 : ℤ)) → (∀(o4 : ℤ), (if i1 < j1 then o4 = j1 else o4 = i1 + (1 : ℤ)) → ((0 : ℤ) ≤ x_N + (2 : ℤ) + j - i ∧ x_N + (2 : ℤ) + (j1 - (1 : ℤ)) - (i1 + (1 : ℤ)) < x_N + (2 : ℤ) + j - i) ∧ i_invariant m n (i1 + (1 : ℤ)) o4 r (List.set (List.set a2 (Int.toNat i1) o2) (Int.toNat j1) w) ∧ j_invariant m n (j1 - (1 : ℤ)) o3 r (List.set (List.set a2 (Int.toNat i1) o2) (Int.toNat j1) w) ∧ m_invariant m (List.set (List.set a2 (Int.toNat i1) o2) (Int.toNat j1) w) ∧ n_invariant n (List.set (List.set a2 (Int.toNat i1) o2) (Int.toNat j1) w) ∧ (0 : ℤ) ≤ j1 - (1 : ℤ) ∧ i1 + (1 : ℤ) ≤ x_N + (1 : ℤ) ∧ termination (i1 + (1 : ℤ)) (j1 - (1 : ℤ)) m n r (List.set (List.set a2 (Int.toNat i1) o2) (Int.toNat j1) w) ∧ List.Perm (List.set (List.set a2 (Int.toNat i1) o2) (Int.toNat j1) w) a)))))) else ((0 : ℤ) ≤ x_N + (2 : ℤ) + j - i ∧ x_N + (2 : ℤ) + j1 - i1 < x_N + (2 : ℤ) + j - i) ∧ i_invariant m n i1 q r a2 ∧ j_invariant m n j1 p r a2 ∧ m_invariant m a2 ∧ n_invariant n a2 ∧ (0 : ℤ) ≤ j1 ∧ i1 ≤ x_N + (1 : ℤ) ∧ termination i1 j1 m n r a2 ∧ List.Perm a2 a)))) else if f ≤ j then ((0 : ℤ) ≤ n - m ∧ j - m < n - m) ∧ m_invariant m a2 ∧ n_invariant j a2 ∧ List.Perm a2 a ∧ (1 : ℤ) ≤ m ∧ j ≤ x_N else if i ≤ f then ((0 : ℤ) ≤ n - m ∧ n - i < n - m) ∧ m_invariant i a2 ∧ n_invariant n a2 ∧ List.Perm a2 a ∧ (1 : ℤ) ≤ i ∧ n ≤ x_N else ((0 : ℤ) ≤ n - m ∧ f - f < n - m) ∧ m_invariant f a2 ∧ n_invariant f a2 ∧ List.Perm a2 a ∧ (1 : ℤ) ≤ f ∧ f ≤ x_N))) else found a1 ∧ List.Perm a1 a))
  := sorry
end find_FIND_findqtvc
