import Why3.Base
import Why3.string.StringBuffer
open Classical
open Lean4Why3
namespace string_base64_encoding_Base64_int2b64qtvc
noncomputable def int2b64 (i : ℤ) := if (0 : ℤ) ≤ i ∧ i ≤ (25 : ℤ) then BitVec.ofNat 8 (Int.toNat (i + (65 : ℤ))) else if (26 : ℤ) ≤ i ∧ i ≤ (51 : ℤ) then BitVec.ofNat 8 (Int.toNat (i - (26 : ℤ) + (97 : ℤ))) else if (52 : ℤ) ≤ i ∧ i ≤ (61 : ℤ) then BitVec.ofNat 8 (Int.toNat (i - (52 : ℤ) + (48 : ℤ))) else if i = (62 : ℤ) then BitVec.ofNat 8 (43 : ℕ) else if i = (63 : ℤ) then BitVec.ofNat 8 (47 : ℕ) else BitVec.ofNat 8 (0 : ℕ)
theorem int2b64'vc (i : BitVec 63) (o1 : Bool) (fact0 : (0 : ℤ) ≤ BitVec.toInt i) (fact1 : BitVec.toInt i < (64 : ℤ)) (fact2 : if (0 : ℤ) ≤ BitVec.toInt i then o1 = (if BitVec.toInt i ≤ (25 : ℤ) then true else false) else o1 = false) : (if o1 = true then int'63_in_bounds (BitVec.toInt i + (65 : ℤ)) ∧ (∀(o2 : BitVec 63), BitVec.toInt o2 = BitVec.toInt i + (65 : ℤ) → (0 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 < (256 : ℤ)) else ∀(o2 : Bool), (if (26 : ℤ) ≤ BitVec.toInt i then o2 = (if BitVec.toInt i ≤ (51 : ℤ) then true else false) else o2 = false) → (if o2 = true then int'63_in_bounds (BitVec.toInt i - (26 : ℤ)) ∧ (∀(o3 : BitVec 63), BitVec.toInt o3 = BitVec.toInt i - (26 : ℤ) → int'63_in_bounds (BitVec.toInt o3 + (97 : ℤ)) ∧ (∀(o4 : BitVec 63), BitVec.toInt o4 = BitVec.toInt o3 + (97 : ℤ) → (0 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 < (256 : ℤ))) else ∀(o3 : Bool), (if (52 : ℤ) ≤ BitVec.toInt i then o3 = (if BitVec.toInt i ≤ (61 : ℤ) then true else false) else o3 = false) → (if o3 = true then int'63_in_bounds (BitVec.toInt i - (52 : ℤ)) ∧ (∀(o4 : BitVec 63), BitVec.toInt o4 = BitVec.toInt i - (52 : ℤ) → int'63_in_bounds (BitVec.toInt o4 + (48 : ℤ)) ∧ (∀(o5 : BitVec 63), BitVec.toInt o5 = BitVec.toInt o4 + (48 : ℤ) → (0 : ℤ) ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 < (256 : ℤ))) else (BitVec.toInt i = (62 : ℤ) → i = (62 : BitVec 63)) → (if i = (62 : BitVec 63) then (0 : ℤ) ≤ (43 : ℤ) ∧ (43 : ℤ) < (256 : ℤ) else (BitVec.toInt i = (63 : ℤ) → i = (63 : BitVec 63)) → i = (63 : BitVec 63) ∧ (0 : ℤ) ≤ (47 : ℤ) ∧ (47 : ℤ) < (256 : ℤ))))) ∧ (∀(result : BitVec 8), (if o1 = true then ∃(o2 : BitVec 63), BitVec.toInt o2 = BitVec.toInt i + (65 : ℤ) ∧ result = BitVec.ofNat 8 (Int.toNat (BitVec.toInt o2)) else ∃(o2 : Bool), (if (26 : ℤ) ≤ BitVec.toInt i then o2 = (if BitVec.toInt i ≤ (51 : ℤ) then true else false) else o2 = false) ∧ (if o2 = true then ∃(o3 : BitVec 63), BitVec.toInt o3 = BitVec.toInt i - (26 : ℤ) ∧ (∃(o4 : BitVec 63), BitVec.toInt o4 = BitVec.toInt o3 + (97 : ℤ) ∧ result = BitVec.ofNat 8 (Int.toNat (BitVec.toInt o4))) else ∃(o3 : Bool), (if (52 : ℤ) ≤ BitVec.toInt i then o3 = (if BitVec.toInt i ≤ (61 : ℤ) then true else false) else o3 = false) ∧ (if o3 = true then ∃(o4 : BitVec 63), BitVec.toInt o4 = BitVec.toInt i - (52 : ℤ) ∧ (∃(o5 : BitVec 63), BitVec.toInt o5 = BitVec.toInt o4 + (48 : ℤ) ∧ result = BitVec.ofNat 8 (Int.toNat (BitVec.toInt o5))) else (BitVec.toInt i = (62 : ℤ) → i = (62 : BitVec 63)) ∧ (if i = (62 : BitVec 63) then result = BitVec.ofNat 8 (43 : ℕ) else (BitVec.toInt i = (63 : ℤ) → i = (63 : BitVec 63)) ∧ i = (63 : BitVec 63) ∧ result = BitVec.ofNat 8 (47 : ℕ))))) → result = int2b64 (BitVec.toInt i))
  := sorry
end string_base64_encoding_Base64_int2b64qtvc
