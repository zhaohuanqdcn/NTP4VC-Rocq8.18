From Stdlib Require Import Strings.String.
From Stdlib Require Import String Ascii.
From Stdlib Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Stdlib Require Classical.
From Stdlib Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Stdlib Require Import Sorting.Sorted.
From Stdlib Require Import Reals.Rbasic_fun.
From Stdlib Require Import Reals.Abstract.ConstructiveAbs.
From Stdlib Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Stdlib Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Stdlib Require Import ZArith.Zeuclid.
From Stdlib Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Stdlib Require Import Reals.
Require Import Why3.Base.
Require Import Why3.why3.Ref.Ref.
Require Import schorr_waite_with_ghost_monitor_vcg.schorr_waite_with_ghost_monitor.Memory.
Require Import schorr_waite_with_ghost_monitor_vcg.schorr_waite_with_ghost_monitor.GraphShape.
Open Scope Z_scope.
Theorem schorr_waite'vc (root : loc) (graph : gset loc) (heap : memory) (fact0 : root ∈ graph) (fact1 : ∀(l : loc), l ∈ graph ∧ ¬ l = null -> left1 heap l ∈ graph ∧ right1 heap l ∈ graph) (fact2 : ∀(x : loc), x ∈ graph -> ¬ mark heap x = true) : (∀(p : loc) (t : loc) (pc : Z) (heap1 : memory), 0%Z ≤ pc ∧ pc < 2%Z -> (if decide (pc = 0%Z) then (pc = 0%Z -> True) ∧ (pc = 1%Z ∧ ¬ (¬ p = null ∨ ¬ t = null ∧ ¬ mark heap1 t = true) -> 1%Z = 2%Z ∧ root = t ∧ null = p) ∧ (pc = 1%Z ∧ (¬ p = null ∨ ¬ t = null ∧ ¬ mark heap1 t = true) -> ((t = null ∨ mark heap1 t = true) ∧ color heap1 p = true -> root = p ∧ null = right1 heap1 p ∧ update (right1 heap1) (right1 heap1) p t) ∧ ((t = null ∨ mark heap1 t = true) ∧ ¬ color heap1 p = true -> null = p ∧ root = right1 heap1 p ∧ update (right1 heap1) (right1 heap1) null (left1 heap1 p) ∧ update (left1 heap1) (left1 heap1) null t ∧ update (color heap1) (color heap1) null true) ∧ (¬ (t = null ∨ mark heap1 t = true) -> null = t ∧ root = left1 heap1 t ∧ update (left1 heap1) (left1 heap1) t p ∧ update (mark heap1) (mark heap1) null true ∧ update (color heap1) (color heap1) null false)) else pc = 1%Z ∧ (∀(o1 : bool), (if decide (¬ p = null) then o1 = true else if decide (¬ t = null) then o1 = (if decide (mark heap1 t = true) then false else true) else o1 = false) -> (if decide (o1 = true) then ∀(o2 : bool), (if decide (t = null) then o2 = true else o2 = mark heap1 t) -> (if decide (o2 = true) then ¬ p = null ∧ (if decide (color heap1 p = true) then ¬ p = null ∧ ¬ p = null ∧ (∀(heap2 : memory), left1 heap2 = left1 heap1 ∧ mark heap2 = mark heap1 ∧ color heap2 = color heap1 -> update (right1 heap2) (right1 heap1) p t -> (pc = 0%Z -> p = root ∧ right1 heap1 p = null ∧ heap2 = heap1) ∧ (pc = 1%Z ∧ ¬ (¬ p = null ∨ ¬ t = null ∧ ¬ mark heap1 t = true) -> 1%Z = 2%Z ∧ p = t ∧ right1 heap1 p = p ∧ heap2 = heap1) ∧ (pc = 1%Z ∧ (¬ p = null ∨ ¬ t = null ∧ ¬ mark heap1 t = true) -> ((t = null ∨ mark heap1 t = true) ∧ color heap1 p = true -> update (right1 heap2) (right1 heap1) p t ∧ left1 heap2 = left1 heap1 ∧ mark heap2 = mark heap1 ∧ color heap2 = color heap1) ∧ ((t = null ∨ mark heap1 t = true) ∧ ¬ color heap1 p = true -> right1 heap1 p = p ∧ p = right1 heap1 p ∧ update (right1 heap2) (right1 heap1) (right1 heap1 p) (left1 heap1 p) ∧ update (left1 heap2) (left1 heap1) (right1 heap1 p) t ∧ update (color heap2) (color heap1) (right1 heap1 p) true ∧ mark heap2 = mark heap1) ∧ (¬ (t = null ∨ mark heap1 t = true) -> right1 heap1 p = t ∧ p = left1 heap1 t ∧ update (left1 heap2) (left1 heap1) t p ∧ update (mark heap2) (mark heap1) (right1 heap1 p) true ∧ update (color heap2) (color heap1) (right1 heap1 p) false ∧ right1 heap2 = right1 heap1))) else ¬ p = null ∧ ¬ p = null ∧ ¬ p = null ∧ (∀(heap2 : memory), left1 heap2 = left1 heap1 ∧ mark heap2 = mark heap1 ∧ color heap2 = color heap1 -> update (right1 heap2) (right1 heap1) p (left1 heap1 p) -> ¬ p = null ∧ (∀(heap3 : memory), right1 heap3 = right1 heap2 ∧ mark heap3 = mark heap2 ∧ color heap3 = color heap2 -> update (left1 heap3) (left1 heap2) p t -> ¬ p = null ∧ (∀(heap4 : memory), left1 heap4 = left1 heap3 ∧ right1 heap4 = right1 heap3 ∧ mark heap4 = mark heap3 -> update (color heap4) (color heap3) p true -> (pc = 0%Z -> right1 heap1 p = root ∧ p = null ∧ heap4 = heap1) ∧ (pc = 1%Z ∧ ¬ (¬ p = null ∨ ¬ t = null ∧ ¬ mark heap1 t = true) -> 1%Z = 2%Z ∧ right1 heap1 p = t ∧ heap4 = heap1) ∧ (pc = 1%Z ∧ (¬ p = null ∨ ¬ t = null ∧ ¬ mark heap1 t = true) -> ((t = null ∨ mark heap1 t = true) ∧ color heap1 p = true -> right1 heap1 p = p ∧ p = right1 heap1 p ∧ update (right1 heap4) (right1 heap1) p t ∧ left1 heap4 = left1 heap1 ∧ mark heap4 = mark heap1 ∧ color heap4 = color heap1) ∧ ((t = null ∨ mark heap1 t = true) ∧ ¬ color heap1 p = true -> update (right1 heap4) (right1 heap1) p (left1 heap1 p) ∧ update (left1 heap4) (left1 heap1) p t ∧ update (color heap4) (color heap1) p true ∧ mark heap4 = mark heap1) ∧ (¬ (t = null ∨ mark heap1 t = true) -> p = t ∧ right1 heap1 p = left1 heap1 t ∧ update (left1 heap4) (left1 heap1) t p ∧ update (mark heap4) (mark heap1) p true ∧ update (color heap4) (color heap1) p false ∧ right1 heap4 = right1 heap1)))))) else ¬ t = null ∧ ¬ t = null ∧ (∀(heap2 : memory), right1 heap2 = right1 heap1 ∧ mark heap2 = mark heap1 ∧ color heap2 = color heap1 -> update (left1 heap2) (left1 heap1) t p -> ¬ t = null ∧ (∀(heap3 : memory), left1 heap3 = left1 heap2 ∧ right1 heap3 = right1 heap2 ∧ color heap3 = color heap2 -> update (mark heap3) (mark heap2) t true -> ¬ t = null ∧ (∀(heap4 : memory), left1 heap4 = left1 heap3 ∧ right1 heap4 = right1 heap3 ∧ mark heap4 = mark heap3 -> update (color heap4) (color heap3) t false -> (pc = 0%Z -> left1 heap1 t = root ∧ t = null ∧ heap4 = heap1) ∧ (pc = 1%Z ∧ ¬ (¬ p = null ∨ ¬ t = null ∧ ¬ mark heap1 t = true) -> 1%Z = 2%Z ∧ left1 heap1 t = t ∧ t = p ∧ heap4 = heap1) ∧ (pc = 1%Z ∧ (¬ p = null ∨ ¬ t = null ∧ ¬ mark heap1 t = true) -> ((t = null ∨ mark heap1 t = true) ∧ color heap1 p = true -> left1 heap1 t = p ∧ t = right1 heap1 p ∧ update (right1 heap4) (right1 heap1) p t ∧ left1 heap4 = left1 heap1 ∧ mark heap4 = mark heap1 ∧ color heap4 = color heap1) ∧ ((t = null ∨ mark heap1 t = true) ∧ ¬ color heap1 p = true -> t = p ∧ left1 heap1 t = right1 heap1 p ∧ update (right1 heap4) (right1 heap1) t (left1 heap1 p) ∧ update (left1 heap4) (left1 heap1) t t ∧ update (color heap4) (color heap1) t true ∧ mark heap4 = mark heap1) ∧ (¬ (t = null ∨ mark heap1 t = true) -> update (left1 heap4) (left1 heap1) t p ∧ update (mark heap4) (mark heap1) t true ∧ update (color heap4) (color heap1) t false ∧ right1 heap4 = right1 heap1)))))) else (pc = 0%Z -> 2%Z = 1%Z ∧ t = root ∧ p = null) ∧ (pc = 1%Z ∧ ¬ (¬ p = null ∨ ¬ t = null ∧ ¬ mark heap1 t = true) -> True) ∧ (pc = 1%Z ∧ (¬ p = null ∨ ¬ t = null ∧ ¬ mark heap1 t = true) -> 2%Z = 1%Z ∧ ((t = null ∨ mark heap1 t = true) ∧ color heap1 p = true -> t = p ∧ p = right1 heap1 p ∧ update (right1 heap1) (right1 heap1) p t) ∧ ((t = null ∨ mark heap1 t = true) ∧ ¬ color heap1 p = true -> t = right1 heap1 p ∧ update (right1 heap1) (right1 heap1) p (left1 heap1 p) ∧ update (left1 heap1) (left1 heap1) p t ∧ update (color heap1) (color heap1) p true) ∧ (¬ (t = null ∨ mark heap1 t = true) -> p = t ∧ t = left1 heap1 t ∧ update (left1 heap1) (left1 heap1) t p ∧ update (mark heap1) (mark heap1) p true ∧ update (color heap1) (color heap1) p false)))))) ∧ (∀(p : loc) (t : loc) (heap1 : memory) (gray_nodes : gset loc), t ∈ graph ∧ well_colored_on graph gray_nodes heap (mark heap1) ∧ (∀(x : loc), ¬ x = null ∧ ¬ mark heap1 x = true -> left1 heap1 x = left1 heap x ∧ right1 heap1 x = right1 heap x) -> (∀(o1 : bool), (if decide (t = null) then o1 = true else o1 = mark heap1 t) -> (if decide (o1 = true) then unchanged_structure heap1 heap1 ∧ well_colored_on graph gray_nodes heap (mark heap1) ∧ (¬ t = null -> mark heap1 t = true) else let new_gray : gset loc := insert_set t gray_nodes in (0%Z ≤ 1%Z ∧ 1%Z < 2%Z) ∧ (∀(p1 : loc) (t1 : loc) (pc : Z) (heap2 : memory), (1%Z = 0%Z -> pc = 1%Z ∧ t1 = root ∧ p1 = null ∧ heap2 = heap1) ∧ (¬ (¬ p = null ∨ ¬ t = null ∧ ¬ mark heap1 t = true) -> pc = 2%Z ∧ t1 = t ∧ p1 = p ∧ heap2 = heap1) ∧ (¬ p = null ∨ ¬ t = null ∧ ¬ mark heap1 t = true -> pc = 1%Z ∧ ((t = null ∨ mark heap1 t = true) ∧ color heap1 p = true -> t1 = p ∧ p1 = right1 heap1 p ∧ update (right1 heap2) (right1 heap1) p t ∧ left1 heap2 = left1 heap1 ∧ mark heap2 = mark heap1 ∧ color heap2 = color heap1) ∧ ((t = null ∨ mark heap1 t = true) ∧ ¬ color heap1 p = true -> p1 = p ∧ t1 = right1 heap1 p ∧ update (right1 heap2) (right1 heap1) p1 (left1 heap1 p) ∧ update (left1 heap2) (left1 heap1) p1 t ∧ update (color heap2) (color heap1) p1 true ∧ mark heap2 = mark heap1) ∧ (¬ (t = null ∨ mark heap1 t = true) -> p1 = t ∧ t1 = left1 heap1 t ∧ update (left1 heap2) (left1 heap1) t p ∧ update (mark heap2) (mark heap1) p1 true ∧ update (color heap2) (color heap1) p1 false ∧ right1 heap2 = right1 heap1)) -> ((0%Z ≤ Z.of_nat (size graph) - Z.of_nat (size gray_nodes) ∧ Z.of_nat (size graph) - Z.of_nat (size new_gray) < Z.of_nat (size graph) - Z.of_nat (size gray_nodes)) ∧ pc = 1%Z ∧ t1 ∈ graph ∧ well_colored_on graph new_gray heap (mark heap2) ∧ (∀(x : loc), ¬ x = null ∧ ¬ mark heap2 x = true -> left1 heap2 x = left1 heap x ∧ right1 heap2 x = right1 heap x)) ∧ (∀(heap3 : memory), unchanged_structure heap2 heap3 ∧ well_colored_on graph new_gray heap (mark heap3) ∧ (¬ t1 = null -> mark heap3 t1 = true) ∧ (∀(x : loc), ¬ x = null -> ¬ path heap t1 x ∨ mark heap2 x = true -> mark heap3 x = mark heap2 x ∧ color heap3 x = color heap2 x) -> (0%Z ≤ 1%Z ∧ 1%Z < 2%Z) ∧ (∀(p2 : loc) (t2 : loc) (pc1 : Z) (heap4 : memory), (1%Z = 0%Z -> pc1 = 1%Z ∧ t2 = root ∧ p2 = null ∧ heap4 = heap3) ∧ (¬ (¬ p1 = null ∨ ¬ t1 = null ∧ ¬ mark heap3 t1 = true) -> pc1 = 2%Z ∧ t2 = t1 ∧ p2 = p1 ∧ heap4 = heap3) ∧ (¬ p1 = null ∨ ¬ t1 = null ∧ ¬ mark heap3 t1 = true -> pc1 = 1%Z ∧ ((t1 = null ∨ mark heap3 t1 = true) ∧ color heap3 p1 = true -> t2 = p1 ∧ p2 = right1 heap3 p1 ∧ update (right1 heap4) (right1 heap3) p1 t1 ∧ left1 heap4 = left1 heap3 ∧ mark heap4 = mark heap3 ∧ color heap4 = color heap3) ∧ ((t1 = null ∨ mark heap3 t1 = true) ∧ ¬ color heap3 p1 = true -> p2 = p1 ∧ t2 = right1 heap3 p1 ∧ update (right1 heap4) (right1 heap3) p2 (left1 heap3 p1) ∧ update (left1 heap4) (left1 heap3) p2 t1 ∧ update (color heap4) (color heap3) p2 true ∧ mark heap4 = mark heap3) ∧ (¬ (t1 = null ∨ mark heap3 t1 = true) -> p2 = t1 ∧ t2 = left1 heap3 t1 ∧ update (left1 heap4) (left1 heap3) t1 p1 ∧ update (mark heap4) (mark heap3) p2 true ∧ update (color heap4) (color heap3) p2 false ∧ right1 heap4 = right1 heap3)) -> ((0%Z ≤ Z.of_nat (size graph) - Z.of_nat (size gray_nodes) ∧ Z.of_nat (size graph) - Z.of_nat (size new_gray) < Z.of_nat (size graph) - Z.of_nat (size gray_nodes)) ∧ pc1 = 1%Z ∧ t2 ∈ graph ∧ well_colored_on graph new_gray heap (mark heap4) ∧ (∀(x : loc), ¬ x = null ∧ ¬ mark heap4 x = true -> left1 heap4 x = left1 heap x ∧ right1 heap4 x = right1 heap x)) ∧ (∀(heap5 : memory), unchanged_structure heap4 heap5 ∧ well_colored_on graph new_gray heap (mark heap5) ∧ (¬ t2 = null -> mark heap5 t2 = true) ∧ (∀(x : loc), ¬ x = null -> ¬ path heap t2 x ∨ mark heap4 x = true -> mark heap5 x = mark heap4 x ∧ color heap5 x = color heap4 x) -> (0%Z ≤ 1%Z ∧ 1%Z < 2%Z) ∧ (∀(p3 : loc) (t3 : loc) (pc2 : Z) (heap6 : memory), (1%Z = 0%Z -> pc2 = 1%Z ∧ t3 = root ∧ p3 = null ∧ heap6 = heap5) ∧ (¬ (¬ p2 = null ∨ ¬ t2 = null ∧ ¬ mark heap5 t2 = true) -> pc2 = 2%Z ∧ t3 = t2 ∧ p3 = p2 ∧ heap6 = heap5) ∧ (¬ p2 = null ∨ ¬ t2 = null ∧ ¬ mark heap5 t2 = true -> pc2 = 1%Z ∧ ((t2 = null ∨ mark heap5 t2 = true) ∧ color heap5 p2 = true -> t3 = p2 ∧ p3 = right1 heap5 p2 ∧ update (right1 heap6) (right1 heap5) p2 t2 ∧ left1 heap6 = left1 heap5 ∧ mark heap6 = mark heap5 ∧ color heap6 = color heap5) ∧ ((t2 = null ∨ mark heap5 t2 = true) ∧ ¬ color heap5 p2 = true -> p3 = p2 ∧ t3 = right1 heap5 p2 ∧ update (right1 heap6) (right1 heap5) p3 (left1 heap5 p2) ∧ update (left1 heap6) (left1 heap5) p3 t2 ∧ update (color heap6) (color heap5) p3 true ∧ mark heap6 = mark heap5) ∧ (¬ (t2 = null ∨ mark heap5 t2 = true) -> p3 = t2 ∧ t3 = left1 heap5 t2 ∧ update (left1 heap6) (left1 heap5) t2 p2 ∧ update (mark heap6) (mark heap5) p3 true ∧ update (color heap6) (color heap5) p3 false ∧ right1 heap6 = right1 heap5)) -> pc2 = 1%Z ∧ (t3 = t ∧ p3 = p) ∧ unchanged_structure heap1 heap6 ∧ well_colored_on graph gray_nodes heap (mark heap6) ∧ (¬ t3 = null -> mark heap6 t3 = true) ∧ (∀(x : loc), ¬ x = null -> ¬ path heap t3 x ∨ mark heap1 x = true -> mark heap6 x = mark heap1 x ∧ color heap6 x = color heap1 x))))))))) ∧ 0%Z ≤ 0%Z ∧ 0%Z < 2%Z ∧ ((0%Z = 1%Z -> 1%Z = 2%Z ∧ root = null) -> (let o1 : gset loc := (∅ : gset loc) in (root ∈ graph ∧ well_colored_on graph o1 heap (mark heap) ∧ (∀(x : loc), ¬ x = null ∧ ¬ mark heap x = true -> True)) ∧ (∀(heap1 : memory), unchanged_structure heap heap1 ∧ well_colored_on graph o1 heap (mark heap1) ∧ (¬ root = null -> mark heap1 root = true) ∧ (∀(x : loc), ¬ x = null -> ¬ path heap root x ∨ mark heap x = true -> mark heap1 x = mark heap x ∧ color heap1 x = color heap x) -> (0%Z ≤ 1%Z ∧ 1%Z < 2%Z) ∧ (∀(p : loc) (t : loc) (pc : Z) (heap2 : memory), (1%Z = 0%Z -> pc = 1%Z ∧ t = root ∧ p = null ∧ heap2 = heap1) ∧ (¬ (¬ True ∨ ¬ root = null ∧ ¬ mark heap1 root = true) -> pc = 2%Z ∧ t = root ∧ p = null ∧ heap2 = heap1) ∧ (¬ True ∨ ¬ root = null ∧ ¬ mark heap1 root = true -> pc = 1%Z ∧ ((root = null ∨ mark heap1 root = true) ∧ color heap1 null = true -> t = null ∧ p = right1 heap1 null ∧ update (right1 heap2) (right1 heap1) null root ∧ left1 heap2 = left1 heap1 ∧ mark heap2 = mark heap1 ∧ color heap2 = color heap1) ∧ ((root = null ∨ mark heap1 root = true) ∧ ¬ color heap1 null = true -> p = null ∧ t = right1 heap1 null ∧ update (right1 heap2) (right1 heap1) p (left1 heap1 null) ∧ update (left1 heap2) (left1 heap1) p root ∧ update (color heap2) (color heap1) p true ∧ mark heap2 = mark heap1) ∧ (¬ (root = null ∨ mark heap1 root = true) -> p = root ∧ t = left1 heap1 root ∧ update (left1 heap2) (left1 heap1) root null ∧ update (mark heap2) (mark heap1) p true ∧ update (color heap2) (color heap1) p false ∧ right1 heap2 = right1 heap1)) -> unchanged_structure heap heap2 ∧ (∀(x : loc), path heap root x ∧ ¬ x = null -> mark heap2 x = true) ∧ (∀(x : loc), ¬ path heap root x ∧ ¬ x = null -> mark heap2 x = mark heap x))))).
Admitted.
