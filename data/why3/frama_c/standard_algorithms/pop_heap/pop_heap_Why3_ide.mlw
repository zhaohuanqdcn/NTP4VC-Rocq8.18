(* ---------------------------------------------------------- *)
(* --- Post-condition 'heap' in 'pop_heap'                --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_post_heap
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Compound.Compound
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition 'heap' in 'pop_heap'":
*)
goal goal0:
  forall p_1 p : bool.
  forall i_3 i_2 i_1 i : int.
  forall t_1 t : map int int.
  forall t_5 t_4 t_3 t_2 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  let x = t_4[a_1] in
  let x_1 = i - 1 in
  let a_2 = (shift_sint32 a x_1) in
  let a_3 = (shift_sint32 a ((to_uint32 x_1))) in
  let a_4 = (shift_sint32 a i_1) in
  let x_2 = t_3[a_2] in
  let a_5 = (shift_sint32 a i_3) in
  (0 < i) ->
  (((region (a.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((p_isheap t_4 a i)) ->
  ((is_sint32 x)) ->
  ((valid_rw t a_1 i)) ->
  ((is_sint32 t_5[a_2])) ->
  (if (2 <= i)
   then (((valid_rd t a_1 1)) /\ ((valid_rd t a_3 1)) /\
         (if (t_4[a_2] < x)
          then ((p=False) /\ (p_1=False) /\ (t_1 = t) /\
                (((havoc t_2 t_4 a_1 x_1)) = t_3) /\
                (t_3[a_4 <- x_2][a_2 <- x] = t_5) /\ (0 < i_2) /\
                (0 <= i_1) /\ (i_1 < i_3) /\
                (x_2 < t_3[(shift_sint32 a ((l_heapparent i_1)))]) /\
                ((2 + i_1) <= i) /\ ((p_isheap t_3 a i)) /\
                ((p_heapmaximumchild t_3 a i i_1 i_3)) /\
                ((p_heapmaximumchild t_4 a i 0 i_2)) /\
                ((valid_rw t_1 a_1 i)) /\ ((valid_rw t_1 a_4 1)) /\
                ((p_upperbound_1_ t_3 a 0 i x)) /\ ((valid_rd t_1 a_3 1)) /\
                ((valid_rw t_1 a_3 1)) /\
                (((2 + i_2) <= i) -> (((l_heapparent i_2)) = 0)) /\
                (((2 + i_3) <= i) -> (((l_heapparent i_3)) = i_1)) /\
                ((i <= (1 + i_3)) \/
                 ((t_3[a_5] <= x_2) /\ ((valid_rd t_1 a_5 1)))))
          else (t_5 = t_4))) else (t_5 = t_4)) ->
  ((p_isheap t_5 a x_1))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'result' in 'pop_heap'              --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_post_result
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Compound.Compound
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition 'result' in 'pop_heap'":
*)
goal goal1:
  forall p_1 p : bool.
  forall i_3 i_2 i_1 i : int.
  forall t_1 t : map int int.
  forall t_5 t_4 t_3 t_2 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  let x = t_5[a_1] in
  let x_1 = i - 1 in
  let a_2 = (shift_sint32 a x_1) in
  let x_2 = t_4[a_2] in
  let a_3 = (shift_sint32 a ((to_uint32 x_1))) in
  let a_4 = (shift_sint32 a i_1) in
  let x_3 = t_3[a_2] in
  let a_5 = (shift_sint32 a i_3) in
  (0 < i) ->
  (((region (a.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((p_isheap t_5 a i)) ->
  ((is_sint32 x)) ->
  ((valid_rw t a_1 i)) ->
  ((is_sint32 x_2)) ->
  (if (2 <= i)
   then (((valid_rd t a_1 1)) /\ ((valid_rd t a_3 1)) /\
         (if (t_5[a_2] < x)
          then ((p=False) /\ (p_1=False) /\ (t_1 = t) /\
                (((havoc t_2 t_5 a_1 x_1)) = t_3) /\
                (t_3[a_4 <- x_3][a_2 <- x] = t_4) /\ (0 < i_2) /\
                (0 <= i_1) /\ (i_1 < i_3) /\
                (x_3 < t_3[(shift_sint32 a ((l_heapparent i_1)))]) /\
                ((2 + i_1) <= i) /\ ((p_isheap t_3 a i)) /\
                ((p_heapmaximumchild t_3 a i i_1 i_3)) /\
                ((p_heapmaximumchild t_5 a i 0 i_2)) /\
                ((valid_rw t_1 a_1 i)) /\ ((valid_rw t_1 a_4 1)) /\
                ((p_upperbound_1_ t_3 a 0 i x)) /\ ((valid_rd t_1 a_3 1)) /\
                ((valid_rw t_1 a_3 1)) /\
                (((2 + i_2) <= i) -> (((l_heapparent i_2)) = 0)) /\
                (((2 + i_3) <= i) -> (((l_heapparent i_3)) = i_1)) /\
                ((i <= (1 + i_3)) \/
                 ((t_3[a_5] <= x_3) /\ ((valid_rd t_1 a_5 1)))))
          else (t_5 = t_4))) else (t_5 = t_4)) ->
  (x_2 = x)

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'max' in 'pop_heap'                 --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_post_max
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Compound.Compound
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition 'max' in 'pop_heap'":
*)
goal goal2:
  forall p_1 p : bool.
  forall i_3 i_2 i_1 i : int.
  forall t_1 t : map int int.
  forall t_5 t_4 t_3 t_2 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  let x = t_4[a_1] in
  let x_1 = i - 1 in
  let a_2 = (shift_sint32 a x_1) in
  let a_3 = (shift_sint32 a ((to_uint32 x_1))) in
  let a_4 = (shift_sint32 a i_1) in
  let x_2 = t_3[a_2] in
  let a_5 = (shift_sint32 a i_3) in
  (0 < i) ->
  (((region (a.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((p_isheap t_4 a i)) ->
  ((is_sint32 x)) ->
  ((valid_rw t a_1 i)) ->
  ((is_sint32 t_5[a_2])) ->
  (if (2 <= i)
   then (((valid_rd t a_1 1)) /\ ((valid_rd t a_3 1)) /\
         (if (t_4[a_2] < x)
          then ((p=False) /\ (p_1=False) /\ (t_1 = t) /\
                (((havoc t_2 t_4 a_1 x_1)) = t_3) /\
                (t_3[a_4 <- x_2][a_2 <- x] = t_5) /\ (0 < i_2) /\
                (0 <= i_1) /\ (i_1 < i_3) /\
                (x_2 < t_3[(shift_sint32 a ((l_heapparent i_1)))]) /\
                ((2 + i_1) <= i) /\ ((p_isheap t_3 a i)) /\
                ((p_heapmaximumchild t_3 a i i_1 i_3)) /\
                ((p_heapmaximumchild t_4 a i 0 i_2)) /\
                ((valid_rw t_1 a_1 i)) /\ ((valid_rw t_1 a_4 1)) /\
                ((p_upperbound_1_ t_3 a 0 i x)) /\ ((valid_rd t_1 a_3 1)) /\
                ((valid_rw t_1 a_3 1)) /\
                (((2 + i_2) <= i) -> (((l_heapparent i_2)) = 0)) /\
                (((2 + i_3) <= i) -> (((l_heapparent i_3)) = i_1)) /\
                ((i <= (1 + i_3)) \/
                 ((t_3[a_5] <= x_2) /\ ((valid_rd t_1 a_5 1)))))
          else (t_5 = t_4))) else (t_5 = t_4)) ->
  ((p_maxelement t_5 a i x_1))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'reorder' in 'pop_heap'             --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_post_reorder
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Compound.Compound
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition 'reorder' in 'pop_heap'":
*)
goal goal3:
  forall p_1 p : bool.
  forall i_3 i_2 i_1 i : int.
  forall t_1 t : map int int.
  forall t_5 t_4 t_3 t_2 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  let x = t_4[a_1] in
  let x_1 = i - 1 in
  let a_2 = (shift_sint32 a x_1) in
  let a_3 = (shift_sint32 a ((to_uint32 x_1))) in
  let a_4 = (shift_sint32 a i_1) in
  let x_2 = t_3[a_2] in
  let a_5 = (shift_sint32 a i_3) in
  (0 < i) ->
  (((region (a.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((p_isheap t_4 a i)) ->
  ((is_sint32 x)) ->
  ((valid_rw t a_1 i)) ->
  ((is_sint32 t_5[a_2])) ->
  (if (2 <= i)
   then (((valid_rd t a_1 1)) /\ ((valid_rd t a_3 1)) /\
         (if (t_4[a_2] < x)
          then ((p=False) /\ (p_1=False) /\ (t_1 = t) /\
                (((havoc t_2 t_4 a_1 x_1)) = t_3) /\
                (t_3[a_4 <- x_2][a_2 <- x] = t_5) /\ (0 < i_2) /\
                (0 <= i_1) /\ (i_1 < i_3) /\
                (x_2 < t_3[(shift_sint32 a ((l_heapparent i_1)))]) /\
                ((2 + i_1) <= i) /\ ((p_isheap t_3 a i)) /\
                ((p_heapmaximumchild t_3 a i i_1 i_3)) /\
                ((p_heapmaximumchild t_4 a i 0 i_2)) /\
                ((valid_rw t_1 a_1 i)) /\ ((valid_rw t_1 a_4 1)) /\
                ((p_upperbound_1_ t_3 a 0 i x)) /\ ((valid_rd t_1 a_3 1)) /\
                ((valid_rw t_1 a_3 1)) /\
                (((2 + i_2) <= i) -> (((l_heapparent i_2)) = 0)) /\
                (((2 + i_3) <= i) -> (((l_heapparent i_3)) = i_1)) /\
                ((i <= (1 + i_3)) \/
                 ((t_3[a_5] <= x_2) /\ ((valid_rd t_1 a_5 1)))))
          else (t_5 = t_4))) else (t_5 = t_4)) ->
  ((p_multisetunchanged_2_ t_5 t_4 a i))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file pop_heap.c, line 10) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_assert_rte_mem_access
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Compound.Compound

(*
goal WP "expl:Assertion 'rte,mem_access' (file pop_heap.c, line 10)":
*)
goal goal4:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  (0 < i) ->
  (((region (a.base))) <= 0) ->
  (2 <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((p_isheap t_1 a i)) ->
  ((is_sint32 t_1[a_1])) ->
  ((valid_rw t a_1 i)) ->
  ((valid_rd t a_1 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file pop_heap.c, line 14) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_assert_rte_mem_access_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Compound.Compound

(*
goal WP "expl:Assertion 'rte,mem_access' (file pop_heap.c, line 14)":
*)
goal goal5:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  let x = i - 1 in
  (0 < i) ->
  (((region (a.base))) <= 0) ->
  (2 <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((p_isheap t_1 a i)) ->
  ((is_sint32 t_1[a_1])) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rw t a_1 i)) ->
  ((is_sint32 t_1[(shift_sint32 a x)])) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x)))) 1))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant 'heap' (file pop_heap.c, line 24) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_loop_inv_heap_2_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic.Axiomatic
use import Compound.Compound
use import Cint.Cint
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Preservation of Invariant 'heap' (file pop_heap.c, line 24)":
*)
goal goal6:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a : addr.
  let x = (l_heapparent i_1) in
  let x_1 = i - 1 in
  let a_1 = (shift_sint32 a x_1) in
  let x_2 = t_2[a_1] in
  let a_2 = (shift_sint32 a 0) in
  let x_3 = t_2[a_2] in
  let a_3 = (havoc t_1 t_2 a_2 x_1) in
  let a_4 = a_3[a_1] in
  let a_5 = (shift_sint32 a i_1) in
  let a_6 = a_3[a_5] in
  let a_7 = a_3[(shift_sint32 a ((l_heapparent x)))] in
  let a_8 = (shift_sint32 a x) in
  let a_9 = a_3[a_8 <- a_6] in
  let a_10 = a_9[a_1] in
  (0 < i) ->
  (0 < i_2) ->
  (0 <= i_1) ->
  (i_1 < i_3) ->
  (0 <= x) ->
  (x < i_1) ->
  (((region (a.base))) <= 0) ->
  (x_2 < x_3) ->
  (a_4 < a_6) ->
  (a_4 < a_7) ->
  (2 <= i) ->
  ((2 + i_1) <= i) ->
  ((2 + x) <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((is_uint32 x)) ->
  ((p_isheap t_2 a i)) ->
  ((is_sint32 x_3)) ->
  ((p_heapmaximumchild t_2 a i 0 i_2)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_5 1)) ->
  ((valid_rw t a_2 i)) ->
  ((is_sint32 t_2[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((valid_rw t a_8 1)) ->
  ((is_sint32 x_2)) ->
  ((is_sint32 a_6)) ->
  ((is_sint32 a_4)) ->
  ((is_sint32 a_7)) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x_1)))) 1)) ->
  ((p_isheap a_3 a i)) ->
  ((is_sint32 a_10)) ->
  ((p_isheap a_9 a i)) ->
  ((p_upperbound_1_ a_3 a 0 i x_3)) ->
  ((p_heapmaximumchild a_3 a i x i_1)) ->
  ((p_heapmaximumchild a_9 a i i_1 i_3)) ->
  (((2 + i_2) <= i) -> (((l_heapparent i_2)) = 0)) ->
  (((2 + i_3) <= i) -> (((l_heapparent i_3)) = i_1)) ->
  (a_10 < a_6)

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant 'heap' (file pop_heap.c, line 24) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_loop_inv_heap_2_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Establishment of Invariant 'heap' (file pop_heap.c, line 24)":
*)
goal goal7:
  let x = (l_heapparent 0) in
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a : addr.
  let x_1 = i - 1 in
  let x_2 = t_1[(shift_sint32 a x_1)] in
  let a_1 = (shift_sint32 a 0) in
  let x_3 = t_1[a_1] in
  let x_4 = t_1[(shift_sint32 a x)] in
  (0 < i) ->
  (0 < i_1) ->
  (((region (a.base))) <= 0) ->
  (x_2 < x_3) ->
  (2 <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((p_isheap t_1 a i)) ->
  ((is_sint32 x_3)) ->
  ((p_heapmaximumchild t_1 a i 0 i_1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rw t a_1 i)) ->
  ((is_sint32 x_4)) ->
  ((is_sint32 x_2)) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x_1)))) 1)) ->
  (((2 + i_1) <= i) -> (((l_heapparent i_1)) = 0)) ->
  (x_2 < x_4)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant 'max' (file pop_heap.c, line 27) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_loop_inv_max_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic.Axiomatic
use import Compound.Compound
use import Cint.Cint
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Preservation of Invariant 'max' (file pop_heap.c, line 27)":
*)
goal goal8:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a : addr.
  let x = (l_heapparent i_2) in
  let x_1 = i - 1 in
  let a_1 = (shift_sint32 a x_1) in
  let x_2 = t_2[a_1] in
  let a_2 = (shift_sint32 a 0) in
  let x_3 = t_2[a_2] in
  let a_3 = (havoc t_1 t_2 a_2 x_1) in
  let a_4 = a_3[a_1] in
  let a_5 = (shift_sint32 a i_2) in
  let a_6 = a_3[a_5] in
  let a_7 = a_3[(shift_sint32 a ((l_heapparent x)))] in
  let a_8 = (shift_sint32 a x) in
  let a_9 = a_3[a_8 <- a_6] in
  (0 < i) ->
  (0 < i_1) ->
  (0 <= i_2) ->
  (i_2 < i_3) ->
  (0 <= x) ->
  (x < i_2) ->
  (((region (a.base))) <= 0) ->
  (x_2 < x_3) ->
  (a_4 < a_6) ->
  (a_4 < a_7) ->
  (2 <= i) ->
  ((2 + i_2) <= i) ->
  ((2 + x) <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((is_uint32 x)) ->
  ((p_isheap t_2 a i)) ->
  ((is_sint32 x_3)) ->
  ((p_heapmaximumchild t_2 a i 0 i_1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_5 1)) ->
  ((valid_rw t a_2 i)) ->
  ((is_sint32 t_2[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((valid_rw t a_8 1)) ->
  ((is_sint32 x_2)) ->
  ((is_sint32 a_6)) ->
  ((is_sint32 a_4)) ->
  ((is_sint32 a_7)) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x_1)))) 1)) ->
  ((p_isheap a_3 a i)) ->
  ((is_sint32 a_9[a_1])) ->
  ((p_isheap a_9 a i)) ->
  ((p_upperbound_1_ a_3 a 0 i x_3)) ->
  ((p_heapmaximumchild a_3 a i x i_2)) ->
  ((p_heapmaximumchild a_9 a i i_2 i_3)) ->
  (((2 + i_1) <= i) -> (((l_heapparent i_1)) = 0)) ->
  (((2 + i_3) <= i) -> (((l_heapparent i_3)) = i_2)) ->
  ((p_upperbound_1_ a_9 a 0 i x_3))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant 'max' (file pop_heap.c, line 27) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_loop_inv_max_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Establishment of Invariant 'max' (file pop_heap.c, line 27)":
*)
goal goal9:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a : addr.
  let x = i - 1 in
  let x_1 = t_1[(shift_sint32 a x)] in
  let a_1 = (shift_sint32 a 0) in
  let x_2 = t_1[a_1] in
  (0 < i) ->
  (0 < i_1) ->
  (((region (a.base))) <= 0) ->
  (x_1 < x_2) ->
  (2 <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((p_isheap t_1 a i)) ->
  ((is_sint32 x_2)) ->
  ((p_heapmaximumchild t_1 a i 0 i_1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rw t a_1 i)) ->
  ((is_sint32 t_1[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((is_sint32 x_1)) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x)))) 1)) ->
  (((2 + i_1) <= i) -> (((l_heapparent i_1)) = 0)) ->
  ((p_upperbound_1_ t_1 a 0 i x_2))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file pop_heap.c, line 31) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_assert_rte_mem_access_4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic.Axiomatic
use import Compound.Compound
use import Cint.Cint
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assertion 'rte,mem_access' (file pop_heap.c, line 31)":
*)
goal goal10:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a : addr.
  let x = (l_heapparent i_2) in
  let x_1 = i - 1 in
  let a_1 = (shift_sint32 a x_1) in
  let x_2 = t_2[a_1] in
  let a_2 = (shift_sint32 a 0) in
  let x_3 = t_2[a_2] in
  let a_3 = (havoc t_1 t_2 a_2 x_1) in
  let a_4 = a_3[a_1] in
  let a_5 = a_3[(shift_sint32 a ((l_heapparent x)))] in
  (0 < i) ->
  (0 < i_1) ->
  (0 <= x) ->
  (x < i_2) ->
  (((region (a.base))) <= 0) ->
  (x_2 < x_3) ->
  (a_4 < a_5) ->
  (2 <= i) ->
  ((2 + i_2) <= i) ->
  ((2 + x) <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 x)) ->
  ((p_isheap t_2 a i)) ->
  ((is_sint32 x_3)) ->
  ((p_heapmaximumchild t_2 a i 0 i_1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rw t a_2 i)) ->
  ((is_sint32 t_2[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((is_sint32 x_2)) ->
  ((is_sint32 a_4)) ->
  ((is_sint32 a_5)) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x_1)))) 1)) ->
  ((p_isheap a_3 a i)) ->
  ((p_upperbound_1_ a_3 a 0 i x_3)) ->
  ((p_heapmaximumchild a_3 a i x i_2)) ->
  (((2 + i_1) <= i) -> (((l_heapparent i_1)) = 0)) ->
  ((valid_rd t ((shift_sint32 a i_2)) 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file pop_heap.c, line 32) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_assert_rte_mem_access_5
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic.Axiomatic
use import Compound.Compound
use import Cint.Cint
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assertion 'rte,mem_access' (file pop_heap.c, line 32)":
*)
goal goal11:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a : addr.
  let x = (l_heapparent i_2) in
  let x_1 = i - 1 in
  let a_1 = (shift_sint32 a x_1) in
  let x_2 = t_2[a_1] in
  let a_2 = (shift_sint32 a 0) in
  let x_3 = t_2[a_2] in
  let a_3 = (havoc t_1 t_2 a_2 x_1) in
  let a_4 = a_3[a_1] in
  let a_5 = (shift_sint32 a i_2) in
  let a_6 = a_3[a_5] in
  let a_7 = a_3[(shift_sint32 a ((l_heapparent x)))] in
  (0 < i) ->
  (0 < i_1) ->
  (0 <= x) ->
  (x < i_2) ->
  (((region (a.base))) <= 0) ->
  (x_2 < x_3) ->
  (a_4 < a_6) ->
  (a_4 < a_7) ->
  (2 <= i) ->
  ((2 + i_2) <= i) ->
  ((2 + x) <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 x)) ->
  ((p_isheap t_2 a i)) ->
  ((is_sint32 x_3)) ->
  ((p_heapmaximumchild t_2 a i 0 i_1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_5 1)) ->
  ((valid_rw t a_2 i)) ->
  ((is_sint32 t_2[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((is_sint32 x_2)) ->
  ((is_sint32 a_6)) ->
  ((is_sint32 a_4)) ->
  ((is_sint32 a_7)) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x_1)))) 1)) ->
  ((p_isheap a_3 a i)) ->
  ((p_upperbound_1_ a_3 a 0 i x_3)) ->
  ((p_heapmaximumchild a_3 a i x i_2)) ->
  (((2 + i_1) <= i) -> (((l_heapparent i_1)) = 0)) ->
  ((valid_rw t ((shift_sint32 a x)) 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file pop_heap.c, line 42) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_assert_rte_mem_access_7
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Axiomatic.Axiomatic
use import Cint.Cint
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assertion 'rte,mem_access' (file pop_heap.c, line 42)":
*)
goal goal12:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_3 t_2 t_1 : map addr int.
  forall a : addr.
  let x = i - 1 in
  let a_1 = (shift_sint32 a x) in
  let x_1 = t_2[a_1] in
  let a_2 = (shift_sint32 a 0) in
  let x_2 = t_2[a_2] in
  let a_3 = (havoc t_1 t_2 a_2 x) in
  let a_4 = a_3[a_1] in
  let a_5 = a_3[(shift_sint32 a ((l_heapparent i_1)))] in
  let a_6 = (shift_sint32 a i_3) in
  (0 < i) ->
  (0 < i_2) ->
  (0 <= i_1) ->
  (i_1 < i_3) ->
  (((region (a.base))) <= 0) ->
  (x_1 < x_2) ->
  (a_4 < a_5) ->
  (2 <= i) ->
  ((2 + i_1) <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((p_isheap t_2 a i)) ->
  ((is_sint32 x_2)) ->
  ((p_heapmaximumchild t_2 a i 0 i_2)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rw t a_2 i)) ->
  ((is_sint32 t_2[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((is_sint32 x_1)) ->
  ((is_sint32 a_5)) ->
  ((is_sint32 a_4)) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x)))) 1)) ->
  ((p_isheap a_3 a i)) ->
  ((p_upperbound_1_ a_3 a 0 i x_2)) ->
  ((p_heapmaximumchild a_3 a i i_1 i_3)) ->
  (((2 + i_2) <= i) -> (((l_heapparent i_2)) = 0)) ->
  (((2 + i_3) <= i) -> (((l_heapparent i_3)) = i_1)) ->
  ((i <= (1 + i_3)) \/
   ((a_3 = t_3) /\ (t_3[a_6] <= t_3[a_1]) /\ ((valid_rd t a_6 1)))) ->
  ((valid_rw t ((shift_sint32 a i_1)) 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file pop_heap.c, line 44) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_assert_rte_mem_access_9
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Axiomatic.Axiomatic
use import Cint.Cint
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assertion 'rte,mem_access' (file pop_heap.c, line 44)":
*)
goal goal13:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_3 t_2 t_1 : map addr int.
  forall a : addr.
  let x = i - 1 in
  let a_1 = (shift_sint32 a x) in
  let x_1 = t_2[a_1] in
  let a_2 = (shift_sint32 a 0) in
  let x_2 = t_2[a_2] in
  let a_3 = (havoc t_1 t_2 a_2 x) in
  let a_4 = a_3[a_1] in
  let a_5 = a_3[(shift_sint32 a ((l_heapparent i_1)))] in
  let a_6 = (shift_sint32 a ((to_uint32 x))) in
  let a_7 = (shift_sint32 a i_3) in
  (0 < i) ->
  (0 < i_2) ->
  (0 <= i_1) ->
  (i_1 < i_3) ->
  (((region (a.base))) <= 0) ->
  (x_1 < x_2) ->
  (a_4 < a_5) ->
  (2 <= i) ->
  ((2 + i_1) <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((p_isheap t_2 a i)) ->
  ((is_sint32 x_2)) ->
  ((p_heapmaximumchild t_2 a i 0 i_2)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t ((shift_sint32 a i_1)) 1)) ->
  ((is_sint32 t_2[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((is_sint32 x_1)) ->
  ((is_sint32 a_5)) ->
  ((is_sint32 a_4)) ->
  ((valid_rd t a_6 1)) ->
  ((p_isheap a_3 a i)) ->
  ((p_upperbound_1_ a_3 a 0 i x_2)) ->
  ((p_heapmaximumchild a_3 a i i_1 i_3)) ->
  (((2 + i_2) <= i) -> (((l_heapparent i_2)) = 0)) ->
  (((2 + i_3) <= i) -> (((l_heapparent i_3)) = i_1)) ->
  ((i <= (1 + i_3)) \/
   ((a_3 = t_3) /\ (t_3[a_7] <= t_3[a_1]) /\ ((valid_rd t a_7 1)))) ->
  ((valid_rw t a_6 1))

end

(* ---------------------------------------------------------- *)
(* --- Loop assigns (file pop_heap.c, line 28) (3/3)      --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_loop_assign_part3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic.Axiomatic
use import Compound.Compound
use import Cint.Cint
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Loop assigns (file pop_heap.c, line 28) (3/3)":
*)
goal goal14:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a : addr.
  let x = (l_heapparent i_2) in
  let x_1 = i - 1 in
  let a_1 = (shift_sint32 a x_1) in
  let x_2 = t_2[a_1] in
  let a_2 = (shift_sint32 a 0) in
  let x_3 = t_2[a_2] in
  let a_3 = (havoc t_1 t_2 a_2 x_1) in
  let a_4 = a_3[a_1] in
  let a_5 = (shift_sint32 a i_2) in
  let a_6 = a_3[a_5] in
  let a_7 = a_3[(shift_sint32 a ((l_heapparent x)))] in
  let a_8 = (shift_sint32 a x) in
  let a_9 = a_3[a_8 <- a_6] in
  (0 < i) ->
  (0 < i_1) ->
  (0 <= i_2) ->
  (i_2 < i_3) ->
  (0 <= x) ->
  (x < i_2) ->
  (((region (a.base))) <= 0) ->
  (x_2 < x_3) ->
  (a_4 < a_6) ->
  (a_4 < a_7) ->
  (2 <= i) ->
  ((2 + i_2) <= i) ->
  ((2 + x) <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((is_uint32 x)) ->
  ((p_isheap t_2 a i)) ->
  ((is_sint32 x_3)) ->
  ((p_heapmaximumchild t_2 a i 0 i_1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_5 1)) ->
  ((valid_rw t a_2 i)) ->
  ((is_sint32 t_2[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((valid_rw t a_8 1)) ->
  (not (invalid t a_8 1)) ->
  ((is_sint32 x_2)) ->
  ((is_sint32 a_6)) ->
  ((is_sint32 a_4)) ->
  ((is_sint32 a_7)) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x_1)))) 1)) ->
  ((p_isheap a_3 a i)) ->
  ((is_sint32 a_9[a_1])) ->
  ((p_isheap a_9 a i)) ->
  ((p_upperbound_1_ a_3 a 0 i x_3)) ->
  ((p_heapmaximumchild a_3 a i x i_2)) ->
  ((p_heapmaximumchild a_9 a i i_2 i_3)) ->
  (((2 + i_1) <= i) -> (((l_heapparent i_1)) = 0)) ->
  (((2 + i_3) <= i) -> (((l_heapparent i_3)) = i_2)) ->
  ((included a_8 1 a_2 x_1))

end

(* ---------------------------------------------------------- *)
(* --- Assigns (file pop_heap.h, line 15) in 'pop_heap' (4/5) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_assign_exit_part4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic.Axiomatic
use import Compound.Compound
use import Cint.Cint
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assigns (file pop_heap.h, line 15) in 'pop_heap' (4/5)":
*)
goal goal15:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a : addr.
  let x = (l_heapparent i_2) in
  let x_1 = i - 1 in
  let a_1 = (shift_sint32 a x_1) in
  let x_2 = t_2[a_1] in
  let a_2 = (shift_sint32 a 0) in
  let x_3 = t_2[a_2] in
  let a_3 = (havoc t_1 t_2 a_2 x_1) in
  let a_4 = a_3[a_1] in
  let a_5 = (shift_sint32 a i_2) in
  let a_6 = a_3[a_5] in
  let a_7 = a_3[(shift_sint32 a ((l_heapparent x)))] in
  let a_8 = (shift_sint32 a x) in
  (0 < i) ->
  (0 < i_1) ->
  (0 <= x) ->
  (x < i_2) ->
  (((region (a.base))) <= 0) ->
  (x_2 < x_3) ->
  (a_4 < a_6) ->
  (a_4 < a_7) ->
  (2 <= i) ->
  ((2 + i_2) <= i) ->
  ((2 + x) <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 x)) ->
  ((p_isheap t_2 a i)) ->
  ((is_sint32 x_3)) ->
  ((p_heapmaximumchild t_2 a i 0 i_1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_5 1)) ->
  ((valid_rw t a_2 i)) ->
  ((is_sint32 t_2[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((valid_rw t a_8 1)) ->
  (not (invalid t a_8 1)) ->
  ((is_sint32 x_2)) ->
  ((is_sint32 a_6)) ->
  ((is_sint32 a_4)) ->
  ((is_sint32 a_7)) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x_1)))) 1)) ->
  ((p_isheap a_3 a i)) ->
  ((p_upperbound_1_ a_3 a 0 i x_3)) ->
  ((p_heapmaximumchild a_3 a i x i_2)) ->
  (((2 + i_1) <= i) -> (((l_heapparent i_1)) = 0)) ->
  ((included a_8 1 a_2 i))

end

(* ---------------------------------------------------------- *)
(* --- Assigns (file pop_heap.h, line 15) in 'pop_heap' (4/5) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_assign_normal_part4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Axiomatic.Axiomatic
use import Cint.Cint
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assigns (file pop_heap.h, line 15) in 'pop_heap' (4/5)":
*)
goal goal16:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_3 t_2 t_1 : map addr int.
  forall a : addr.
  let x = i - 1 in
  let a_1 = (shift_sint32 a x) in
  let x_1 = t_2[a_1] in
  let a_2 = (shift_sint32 a 0) in
  let x_2 = t_2[a_2] in
  let a_3 = (havoc t_1 t_2 a_2 x) in
  let a_4 = a_3[a_1] in
  let a_5 = a_3[(shift_sint32 a ((l_heapparent i_1)))] in
  let a_6 = (shift_sint32 a i_1) in
  let a_7 = (shift_sint32 a i_3) in
  (0 < i) ->
  (0 < i_2) ->
  (0 <= i_1) ->
  (i_1 < i_3) ->
  (((region (a.base))) <= 0) ->
  (x_1 < x_2) ->
  (a_4 < a_5) ->
  (2 <= i) ->
  ((2 + i_1) <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((p_isheap t_2 a i)) ->
  ((is_sint32 x_2)) ->
  ((p_heapmaximumchild t_2 a i 0 i_2)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_6 1)) ->
  (not (invalid t a_6 1)) ->
  ((is_sint32 t_2[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((is_sint32 x_1)) ->
  ((is_sint32 a_5)) ->
  ((is_sint32 a_4)) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x)))) 1)) ->
  ((p_isheap a_3 a i)) ->
  ((p_upperbound_1_ a_3 a 0 i x_2)) ->
  ((p_heapmaximumchild a_3 a i i_1 i_3)) ->
  (((2 + i_2) <= i) -> (((l_heapparent i_2)) = 0)) ->
  (((2 + i_3) <= i) -> (((l_heapparent i_3)) = i_1)) ->
  ((i <= (1 + i_3)) \/
   ((a_3 = t_3) /\ (t_3[a_7] <= t_3[a_1]) /\ ((valid_rd t a_7 1)))) ->
  ((included a_6 1 a_2 i))

end

(* ---------------------------------------------------------- *)
(* --- Assigns (file pop_heap.h, line 15) in 'pop_heap' (5/5) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_assign_normal_part5
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Axiomatic.Axiomatic
use import Cint.Cint
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Assigns (file pop_heap.h, line 15) in 'pop_heap' (5/5)":
*)
goal goal17:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_3 t_2 t_1 : map addr int.
  forall a : addr.
  let x = i - 1 in
  let a_1 = (shift_sint32 a x) in
  let x_1 = t_2[a_1] in
  let a_2 = (shift_sint32 a 0) in
  let x_2 = t_2[a_2] in
  let a_3 = (havoc t_1 t_2 a_2 x) in
  let a_4 = a_3[a_1] in
  let a_5 = a_3[(shift_sint32 a ((l_heapparent i_1)))] in
  let a_6 = (shift_sint32 a ((to_uint32 x))) in
  let a_7 = (shift_sint32 a i_3) in
  (0 < i) ->
  (0 < i_2) ->
  (0 <= i_1) ->
  (i_1 < i_3) ->
  (((region (a.base))) <= 0) ->
  (x_1 < x_2) ->
  (a_4 < a_5) ->
  (2 <= i) ->
  ((2 + i_1) <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((p_isheap t_2 a i)) ->
  ((is_sint32 x_2)) ->
  ((p_heapmaximumchild t_2 a i 0 i_2)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t ((shift_sint32 a i_1)) 1)) ->
  ((is_sint32 t_2[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((is_sint32 x_1)) ->
  (not (invalid t a_1 1)) ->
  ((is_sint32 a_5)) ->
  ((is_sint32 a_4)) ->
  ((valid_rd t a_6 1)) ->
  ((valid_rw t a_6 1)) ->
  ((p_isheap a_3 a i)) ->
  ((p_upperbound_1_ a_3 a 0 i x_2)) ->
  ((p_heapmaximumchild a_3 a i i_1 i_3)) ->
  (((2 + i_2) <= i) -> (((l_heapparent i_2)) = 0)) ->
  (((2 + i_3) <= i) -> (((l_heapparent i_3)) = i_1)) ->
  ((i <= (1 + i_3)) \/
   ((a_3 = t_3) /\ (t_3[a_7] <= t_3[a_1]) /\ ((valid_rd t a_7 1)))) ->
  ((included a_1 1 a_2 i))

end

(* ---------------------------------------------------------- *)
(* --- Positivity of Loop variant at loop (file pop_heap.c, line 31) --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_loop_term_positive
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic.Axiomatic
use import Compound.Compound
use import Cint.Cint
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Positivity of Loop variant at loop (file pop_heap.c, line 31)":
*)
goal goal18:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a : addr.
  let x = (l_heapparent i_2) in
  let x_1 = i - 1 in
  let a_1 = (shift_sint32 a x_1) in
  let x_2 = t_2[a_1] in
  let a_2 = (shift_sint32 a 0) in
  let x_3 = t_2[a_2] in
  let a_3 = (havoc t_1 t_2 a_2 x_1) in
  let a_4 = a_3[a_1] in
  let a_5 = (shift_sint32 a i_2) in
  let a_6 = a_3[a_5] in
  let a_7 = a_3[(shift_sint32 a ((l_heapparent x)))] in
  let a_8 = (shift_sint32 a x) in
  let a_9 = a_3[a_8 <- a_6] in
  (0 < i) ->
  (0 < i_1) ->
  (0 <= i_2) ->
  (i_2 < i_3) ->
  (0 <= x) ->
  (x < i_2) ->
  (((region (a.base))) <= 0) ->
  (x_2 < x_3) ->
  (a_4 < a_6) ->
  (a_4 < a_7) ->
  (2 <= i) ->
  ((2 + i_2) <= i) ->
  ((2 + x) <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((is_uint32 x)) ->
  ((p_isheap t_2 a i)) ->
  ((is_sint32 x_3)) ->
  ((p_heapmaximumchild t_2 a i 0 i_1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_5 1)) ->
  ((valid_rw t a_2 i)) ->
  ((is_sint32 t_2[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((valid_rw t a_8 1)) ->
  ((is_sint32 x_2)) ->
  ((is_sint32 a_6)) ->
  ((is_sint32 a_4)) ->
  ((is_sint32 a_7)) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x_1)))) 1)) ->
  ((p_isheap a_3 a i)) ->
  ((is_sint32 a_9[a_1])) ->
  ((p_isheap a_9 a i)) ->
  ((p_upperbound_1_ a_3 a 0 i x_3)) ->
  ((p_heapmaximumchild a_3 a i x i_2)) ->
  ((p_heapmaximumchild a_9 a i i_2 i_3)) ->
  (((2 + i_1) <= i) -> (((l_heapparent i_1)) = 0)) ->
  (((2 + i_3) <= i) -> (((l_heapparent i_3)) = i_2)) ->
  (x <= i)

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition 'bound' in 'maximum_heap_child'' in 'pop_heap' at call 'maximum_heap_child' (file pop_heap.c, line 35)
 --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_call_maximum_heap_child_pre_bound_2_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic.Axiomatic
use import Compound.Compound
use import Cint.Cint
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Instance of 'Pre-condition 'bound' in 'maximum_heap_child'' in 'pop_heap' at call 'maximum_heap_child' (file pop_heap.c, line 35)
":
*)
goal goal19:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a : addr.
  let x = (l_heapparent i_1) in
  let x_1 = i - 1 in
  let a_1 = (shift_sint32 a x_1) in
  let x_2 = t_2[a_1] in
  let a_2 = (shift_sint32 a 0) in
  let x_3 = t_2[a_2] in
  let a_3 = (havoc t_1 t_2 a_2 x_1) in
  let a_4 = a_3[a_1] in
  let a_5 = (shift_sint32 a i_1) in
  let a_6 = a_3[a_5] in
  let a_7 = a_3[(shift_sint32 a ((l_heapparent x)))] in
  (0 < i) ->
  (0 < i_2) ->
  (0 <= x) ->
  (x < i_1) ->
  (((region (a.base))) <= 0) ->
  (x_2 < x_3) ->
  (a_4 < a_6) ->
  (a_4 < a_7) ->
  (2 <= i) ->
  ((2 + i_1) <= i) ->
  ((2 + x) <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 x)) ->
  ((p_isheap t_2 a i)) ->
  ((is_sint32 x_3)) ->
  ((p_heapmaximumchild t_2 a i 0 i_2)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_5 1)) ->
  ((valid_rw t a_2 i)) ->
  ((is_sint32 t_2[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((valid_rw t ((shift_sint32 a x)) 1)) ->
  ((is_sint32 x_2)) ->
  ((is_sint32 a_6)) ->
  ((is_sint32 a_4)) ->
  ((is_sint32 a_7)) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x_1)))) 1)) ->
  ((p_isheap a_3 a i)) ->
  ((p_upperbound_1_ a_3 a 0 i x_3)) ->
  ((p_heapmaximumchild a_3 a i x i_1)) ->
  (((2 + i_2) <= i) -> (((l_heapparent i_2)) = 0)) ->
  (0 <= i_1)

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition 'heap' in 'maximum_heap_child'' in 'pop_heap' at call 'maximum_heap_child' (file pop_heap.c, line 35)
 --- *)
(* ---------------------------------------------------------- *)
theory VCpop_heap_call_maximum_heap_child_pre_heap_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Axiomatic.Axiomatic
use import Compound.Compound
use import Cint.Cint
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Instance of 'Pre-condition 'heap' in 'maximum_heap_child'' in 'pop_heap' at call 'maximum_heap_child' (file pop_heap.c, line 35)
":
*)
goal goal20:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a : addr.
  let x = (l_heapparent i_2) in
  let x_1 = i - 1 in
  let a_1 = (shift_sint32 a x_1) in
  let x_2 = t_2[a_1] in
  let a_2 = (shift_sint32 a 0) in
  let x_3 = t_2[a_2] in
  let a_3 = (havoc t_1 t_2 a_2 x_1) in
  let a_4 = a_3[a_1] in
  let a_5 = (shift_sint32 a i_2) in
  let a_6 = a_3[a_5] in
  let a_7 = a_3[(shift_sint32 a ((l_heapparent x)))] in
  let a_8 = (shift_sint32 a x) in
  let a_9 = a_3[a_8 <- a_6] in
  (0 < i) ->
  (0 < i_1) ->
  (0 <= x) ->
  (x < i_2) ->
  (((region (a.base))) <= 0) ->
  (x_2 < x_3) ->
  (a_4 < a_6) ->
  (a_4 < a_7) ->
  (2 <= i) ->
  ((2 + i_2) <= i) ->
  ((2 + x) <= i) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 x)) ->
  ((p_isheap t_2 a i)) ->
  ((is_sint32 x_3)) ->
  ((p_heapmaximumchild t_2 a i 0 i_1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_5 1)) ->
  ((valid_rw t a_2 i)) ->
  ((is_sint32 t_2[(shift_sint32 a ((l_heapparent 0)))])) ->
  ((valid_rw t a_8 1)) ->
  ((is_sint32 x_2)) ->
  ((is_sint32 a_6)) ->
  ((is_sint32 a_4)) ->
  ((is_sint32 a_7)) ->
  ((valid_rd t ((shift_sint32 a ((to_uint32 x_1)))) 1)) ->
  ((p_isheap a_3 a i)) ->
  ((is_sint32 a_9[a_1])) ->
  ((p_upperbound_1_ a_3 a 0 i x_3)) ->
  ((p_heapmaximumchild a_3 a i x i_2)) ->
  (((2 + i_1) <= i) -> (((l_heapparent i_1)) = 0)) ->
  ((p_isheap a_9 a i))

end

