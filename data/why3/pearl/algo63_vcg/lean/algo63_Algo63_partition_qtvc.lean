import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
open Classical
open Lean4Why3
namespace algo63_Algo63_partition_qtvc
theorem partition_'vc (m : ℤ) (n : ℤ) (a : List ℤ) (f : ℤ) (fact0 : (0 : ℤ) ≤ m) (fact1 : m < n) (fact2 : n < Int.ofNat (List.length a)) (fact3 : m ≤ f) (fact4 : f ≤ n) : (0 : ℤ) ≤ f ∧ f < Int.ofNat (List.length a) ∧ (let x : ℤ := a[Int.toNat f]!; (∀(j : ℤ) (i : ℤ) (a1 : List ℤ), List.length a1 = List.length a → ((m ≤ j ∧ j ≤ n) ∧ m ≤ i ∧ i ≤ n) ∧ List.permut_sub' a a1 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), m ≤ r ∧ r < i → a1[Int.toNat r]! ≤ x) ∧ (∀(r : ℤ), j < r ∧ r ≤ n → x ≤ a1[Int.toNat r]!) ∧ a1[Int.toNat f]! = x → ((m ≤ i ∧ i ≤ n) ∧ (∀(r : ℤ), m ≤ r ∧ r < i → a1[Int.toNat r]! ≤ x)) ∧ (∀(i1 : ℤ), (m ≤ i1 ∧ i1 ≤ n) ∧ (∀(r : ℤ), m ≤ r ∧ r < i1 → a1[Int.toNat r]! ≤ x) → (i1 < n → (0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a1)) ∧ (∀(o1 : Bool), (if i1 < n then o1 = (if a1[Int.toNat i1]! ≤ x then true else false) else o1 = false) → (if o1 = true then ((0 : ℤ) ≤ n - i1 ∧ n - (i1 + (1 : ℤ)) < n - i1) ∧ (m ≤ i1 + (1 : ℤ) ∧ i1 + (1 : ℤ) ≤ n) ∧ (∀(r : ℤ), m ≤ r ∧ r < i1 + (1 : ℤ) → a1[Int.toNat r]! ≤ x) else ((m ≤ j ∧ j ≤ n) ∧ (∀(r : ℤ), j < r ∧ r ≤ n → x ≤ a1[Int.toNat r]!)) ∧ (∀(j1 : ℤ), (m ≤ j1 ∧ j1 ≤ n) ∧ (∀(r : ℤ), j1 < r ∧ r ≤ n → x ≤ a1[Int.toNat r]!) → (m < j1 → (0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a1)) ∧ (∀(o2 : Bool), (if m < j1 then o2 = (if x ≤ a1[Int.toNat j1]! then true else false) else o2 = false) → (if o2 = true then ((0 : ℤ) ≤ j1 ∧ j1 - (1 : ℤ) < j1) ∧ (m ≤ j1 - (1 : ℤ) ∧ j1 - (1 : ℤ) ≤ n) ∧ (∀(r : ℤ), j1 - (1 : ℤ) < r ∧ r ≤ n → x ≤ a1[Int.toNat r]!) else if i1 < j1 then (((0 : ℤ) ≤ m ∧ m ≤ i1 ∧ i1 ≤ n ∧ n < Int.ofNat (List.length a1)) ∧ m ≤ j1 ∧ j1 ≤ n) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 i1 j1 ∧ List.permut_sub' a1 a2 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) → (((0 : ℤ) ≤ (1 : ℤ) + j - i ∧ (1 : ℤ) + (j1 - (1 : ℤ)) - (i1 + (1 : ℤ)) < (1 : ℤ) + j - i) ∧ ((m ≤ j1 - (1 : ℤ) ∧ j1 - (1 : ℤ) ≤ n) ∧ m ≤ i1 + (1 : ℤ) ∧ i1 + (1 : ℤ) ≤ n) ∧ List.permut_sub' a a2 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), m ≤ r ∧ r < i1 + (1 : ℤ) → a2[Int.toNat r]! ≤ x) ∧ (∀(r : ℤ), j1 - (1 : ℤ) < r ∧ r ≤ n → x ≤ a2[Int.toNat r]!) ∧ a2[Int.toNat f]! = x) ∧ (∀(j2 : ℤ) (i2 : ℤ) (a3 : List ℤ), List.length a3 = List.length a2 → (m ≤ j2 ∧ j2 ≤ i2 ∧ i2 ≤ n) ∧ List.permut_sub' a2 a3 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (i2 = n ∨ x < a3[Int.toNat i2]!) ∧ (j2 = m ∨ a3[Int.toNat j2]! < x) ∧ a3[Int.toNat f]! = x ∧ (∀(r : ℤ), m ≤ r ∧ r < i2 → a3[Int.toNat r]! ≤ x) ∧ (∀(r : ℤ), j2 < r ∧ r ≤ n → x ≤ a3[Int.toNat r]!) → (m ≤ j2 ∧ j2 ≤ i2 ∧ i2 ≤ n) ∧ List.permut_sub' a1 a3 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (i2 = n ∨ x < a3[Int.toNat i2]!) ∧ (j2 = m ∨ a3[Int.toNat j2]! < x) ∧ a3[Int.toNat f]! = x ∧ (∀(r : ℤ), m ≤ r ∧ r < i2 → a3[Int.toNat r]! ≤ x) ∧ (∀(r : ℤ), j2 < r ∧ r ≤ n → x ≤ a3[Int.toNat r]!))) else (m ≤ j1 ∧ j1 ≤ i1 ∧ i1 ≤ n) ∧ List.permut_sub' a1 a1 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (i1 = n ∨ x < a1[Int.toNat i1]!) ∧ (j1 = m ∨ a1[Int.toNat j1]! < x) ∧ a1[Int.toNat f]! = x ∧ (∀(r : ℤ), m ≤ r ∧ r < i1 → a1[Int.toNat r]! ≤ x) ∧ (∀(r : ℤ), j1 < r ∧ r ≤ n → x ≤ a1[Int.toNat r]!)))))))) ∧ (((m ≤ n ∧ n ≤ n) ∧ m ≤ m ∧ m ≤ n) ∧ List.permut_sub' a a (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), m ≤ r ∧ r < m → a[Int.toNat r]! ≤ x) ∧ (∀(r : ℤ), n < r ∧ r ≤ n → x ≤ a[Int.toNat r]!) ∧ a[Int.toNat f]! = x) ∧ (∀(j : ℤ) (i : ℤ) (a1 : List ℤ), List.length a1 = List.length a → (m ≤ j ∧ j ≤ i ∧ i ≤ n) ∧ List.permut_sub' a a1 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (i = n ∨ x < a1[Int.toNat i]!) ∧ (j = m ∨ a1[Int.toNat j]! < x) ∧ a1[Int.toNat f]! = x ∧ (∀(r : ℤ), m ≤ r ∧ r < i → a1[Int.toNat r]! ≤ x) ∧ (∀(r : ℤ), j < r ∧ r ≤ n → x ≤ a1[Int.toNat r]!) → (if i < f then (((0 : ℤ) ≤ m ∧ m ≤ i ∧ i ≤ n ∧ n < Int.ofNat (List.length a1)) ∧ m ≤ f ∧ f ≤ n) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 i f ∧ List.permut_sub' a1 a2 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) → (m ≤ j ∧ j < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ n) ∧ List.permut_sub' a a2 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), m ≤ r ∧ r ≤ j → a2[Int.toNat r]! ≤ x) ∧ (∀(r : ℤ), j < r ∧ r < i + (1 : ℤ) → a2[Int.toNat r]! = x) ∧ (∀(r : ℤ), i + (1 : ℤ) ≤ r ∧ r ≤ n → x ≤ a2[Int.toNat r]!)) else if f < j then (((0 : ℤ) ≤ m ∧ m ≤ f ∧ f ≤ n ∧ n < Int.ofNat (List.length a1)) ∧ m ≤ j ∧ j ≤ n) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 f j ∧ List.permut_sub' a1 a2 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) → (m ≤ j - (1 : ℤ) ∧ j - (1 : ℤ) < i ∧ i ≤ n) ∧ List.permut_sub' a a2 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), m ≤ r ∧ r ≤ j - (1 : ℤ) → a2[Int.toNat r]! ≤ x) ∧ (∀(r : ℤ), j - (1 : ℤ) < r ∧ r < i → a2[Int.toNat r]! = x) ∧ (∀(r : ℤ), i ≤ r ∧ r ≤ n → x ≤ a2[Int.toNat r]!)) else (m ≤ j ∧ j < i ∧ i ≤ n) ∧ List.permut_sub' a a1 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), m ≤ r ∧ r ≤ j → a1[Int.toNat r]! ≤ x) ∧ (∀(r : ℤ), j < r ∧ r < i → a1[Int.toNat r]! = x) ∧ (∀(r : ℤ), i ≤ r ∧ r ≤ n → x ≤ a1[Int.toNat r]!))))
  := sorry
end algo63_Algo63_partition_qtvc
