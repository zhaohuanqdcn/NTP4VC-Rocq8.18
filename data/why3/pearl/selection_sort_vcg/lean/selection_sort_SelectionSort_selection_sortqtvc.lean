import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
import Why3.array.IntArraySorted
open Classical
open Lean4Why3
namespace selection_sort_SelectionSort_selection_sortqtvc
theorem selection_sort'vc (a : List ℤ) : let o1 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → (IntArraySorted.sorted_sub1 a (0 : ℤ) (0 : ℤ) ∧ List.Perm a a ∧ (∀(k1 : ℤ) (k2 : ℤ), (0 : ℤ) ≤ k1 ∧ k1 < (0 : ℤ) ∧ (0 : ℤ) ≤ k2 ∧ k2 < Int.ofNat (List.length a) → a[Int.toNat k1]! ≤ a[Int.toNat k2]!)) ∧ (∀(a1 : List ℤ), List.length a1 = List.length a → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ IntArraySorted.sorted_sub1 a1 (0 : ℤ) i ∧ List.Perm a a1 ∧ (∀(k1 : ℤ) (k2 : ℤ), (0 : ℤ) ≤ k1 ∧ k1 < i ∧ i ≤ k2 ∧ k2 < Int.ofNat (List.length a1) → a1[Int.toNat k1]! ≤ a1[Int.toNat k2]!) → (let o2 : ℤ := Int.ofNat (List.length a1) - (1 : ℤ); let o3 : ℤ := i + (1 : ℤ); (o3 ≤ o2 + (1 : ℤ) → ((i ≤ i ∧ i < o3) ∧ (∀(k : ℤ), i ≤ k ∧ k < o3 → a1[Int.toNat i]! ≤ a1[Int.toNat k]!)) ∧ (∀(min : ℤ), (∀(j : ℤ), (o3 ≤ j ∧ j ≤ o2) ∧ (i ≤ min ∧ min < j) ∧ (∀(k : ℤ), i ≤ k ∧ k < j → a1[Int.toNat min]! ≤ a1[Int.toNat k]!) → ((0 : ℤ) ≤ min ∧ min < Int.ofNat (List.length a1)) ∧ ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a1)) ∧ (if a1[Int.toNat j]! < a1[Int.toNat min]! then (i ≤ j ∧ j < j + (1 : ℤ)) ∧ (∀(k : ℤ), i ≤ k ∧ k < j + (1 : ℤ) → a1[Int.toNat j]! ≤ a1[Int.toNat k]!) else (i ≤ min ∧ min < j + (1 : ℤ)) ∧ (∀(k : ℤ), i ≤ k ∧ k < j + (1 : ℤ) → a1[Int.toNat min]! ≤ a1[Int.toNat k]!))) ∧ ((i ≤ min ∧ min < o2 + (1 : ℤ)) ∧ (∀(k : ℤ), i ≤ k ∧ k < o2 + (1 : ℤ) → a1[Int.toNat min]! ≤ a1[Int.toNat k]!) → (if ¬min = i then (((0 : ℤ) ≤ min ∧ min < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 min i → IntArraySorted.sorted_sub1 a2 (0 : ℤ) (i + (1 : ℤ)) ∧ List.Perm a a2 ∧ (∀(k1 : ℤ) (k2 : ℤ), (0 : ℤ) ≤ k1 ∧ k1 < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ k2 ∧ k2 < Int.ofNat (List.length a2) → a2[Int.toNat k1]! ≤ a2[Int.toNat k2]!)) else IntArraySorted.sorted_sub1 a1 (0 : ℤ) (i + (1 : ℤ)) ∧ List.Perm a a1 ∧ (∀(k1 : ℤ) (k2 : ℤ), (0 : ℤ) ≤ k1 ∧ k1 < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ k2 ∧ k2 < Int.ofNat (List.length a1) → a1[Int.toNat k1]! ≤ a1[Int.toNat k2]!))))) ∧ (o2 + (1 : ℤ) < o3 → (if ¬True then (((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 i i → IntArraySorted.sorted_sub1 a2 (0 : ℤ) (i + (1 : ℤ)) ∧ List.Perm a a2 ∧ (∀(k1 : ℤ) (k2 : ℤ), (0 : ℤ) ≤ k1 ∧ k1 < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ k2 ∧ k2 < Int.ofNat (List.length a2) → a2[Int.toNat k1]! ≤ a2[Int.toNat k2]!)) else IntArraySorted.sorted_sub1 a1 (0 : ℤ) (i + (1 : ℤ)) ∧ List.Perm a a1 ∧ (∀(k1 : ℤ) (k2 : ℤ), (0 : ℤ) ≤ k1 ∧ k1 < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ k2 ∧ k2 < Int.ofNat (List.length a1) → a1[Int.toNat k1]! ≤ a1[Int.toNat k2]!))))) ∧ (IntArraySorted.sorted_sub1 a1 (0 : ℤ) (o1 + (1 : ℤ)) ∧ List.Perm a a1 ∧ (∀(k1 : ℤ) (k2 : ℤ), (0 : ℤ) ≤ k1 ∧ k1 < o1 + (1 : ℤ) ∧ o1 + (1 : ℤ) ≤ k2 ∧ k2 < Int.ofNat (List.length a1) → a1[Int.toNat k1]! ≤ a1[Int.toNat k2]!) → IntArraySorted.sorted a1 ∧ List.Perm a a1))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → IntArraySorted.sorted a ∧ List.Perm a a)
  := sorry
end selection_sort_SelectionSort_selection_sortqtvc
