import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Fibonacci
import pearl.ropes_vcg.lean.ropes.MyString
import pearl.ropes_vcg.lean.ropes.Rope
open Classical
open Lean4Why3
namespace ropes_Balance_insertqtvc
axiom max : ℤ
axiom max'def : (2 : ℤ) ≤ max
axiom string_of_array : List Rope.rope -> ℤ -> ℤ -> MyString.char_string
axiom string_of_array_empty (l : ℤ) (q : List Rope.rope) (fact0 : (0 : ℤ) ≤ l) (fact1 : l ≤ Int.ofNat (List.length q)) : MyString.infix_eqeq (string_of_array q l l) MyString.empty
axiom string_of_array_concat_left (l : ℤ) (u : ℤ) (q : List Rope.rope) (fact0 : (0 : ℤ) ≤ l) (fact1 : l < u) (fact2 : u ≤ Int.ofNat (List.length q)) : MyString.infix_eqeq (string_of_array q l u) (MyString.app (string_of_array q (l + (1 : ℤ)) u) (Rope.string (q[Int.toNat l]!)))
noncomputable def string_of_queue (q : List Rope.rope) := string_of_array q (2 : ℤ) (Int.ofNat (List.length q))
theorem insert'vc (i : ℤ) (q : List Rope.rope) (r : Rope.rope) (fact0 : (2 : ℤ) ≤ i) (fact1 : i < Int.ofNat (List.length q)) (fact2 : Int.ofNat (List.length q) = max + (1 : ℤ)) (fact3 : Rope.inv r) (fact4 : ∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv (q[Int.toNat j]!)) (fact5 : MyString.length (string_of_array q i (max + (1 : ℤ))) + Rope.length r < Fibonacci.fib (max + (1 : ℤ))) : (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length q) ∧ (let o1 : Rope.rope := q[Int.toNat i]!; (Rope.inv o1 ∧ Rope.inv r) ∧ (∀(r' : Rope.rope), Rope.inv r' ∧ MyString.infix_eqeq (Rope.string r') (MyString.app (Rope.string o1) (Rope.string r)) → (let o2 : ℤ := i + (1 : ℤ); (0 : ℤ) ≤ o2 ∧ (if Rope.length r' < Fibonacci.fib o2 then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length q)) ∧ (List.length (List.set q (Int.toNat i) r') = List.length q → getElem! (List.set q (Int.toNat i) r') ∘ Int.toNat = Function.update (getElem! q ∘ Int.toNat) i r' → (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv ((List.set q (Int.toNat i) r')[Int.toNat j]!)) ∧ (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j < i → (List.set q (Int.toNat i) r')[Int.toNat j]! = q[Int.toNat j]!) ∧ MyString.infix_eqeq (string_of_array (List.set q (Int.toNat i) r') i (max + (1 : ℤ))) (MyString.app (string_of_array q i (max + (1 : ℤ))) (Rope.string r))) else let o3 : Rope.rope := Rope.rope.Emp; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length q)) ∧ (List.length (List.set q (Int.toNat i) o3) = List.length q → getElem! (List.set q (Int.toNat i) o3) ∘ Int.toNat = Function.update (getElem! q ∘ Int.toNat) i o3 → (let o4 : ℤ := i + (1 : ℤ); (((0 : ℤ) ≤ max - i ∧ max - o4 < max - i) ∧ ((2 : ℤ) ≤ o4 ∧ o4 < Int.ofNat (List.length (List.set q (Int.toNat i) o3)) ∧ Int.ofNat (List.length (List.set q (Int.toNat i) o3)) = max + (1 : ℤ)) ∧ Rope.inv r' ∧ (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv ((List.set q (Int.toNat i) o3)[Int.toNat j]!)) ∧ MyString.length (string_of_array (List.set q (Int.toNat i) o3) o4 (max + (1 : ℤ))) + Rope.length r' < Fibonacci.fib (max + (1 : ℤ))) ∧ (∀(q1 : List Rope.rope), List.length q1 = List.length (List.set q (Int.toNat i) o3) → (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv (q1[Int.toNat j]!)) ∧ (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j < o4 → q1[Int.toNat j]! = (List.set q (Int.toNat i) o3)[Int.toNat j]!) ∧ MyString.infix_eqeq (string_of_array q1 o4 (max + (1 : ℤ))) (MyString.app (string_of_array (List.set q (Int.toNat i) o3) o4 (max + (1 : ℤ))) (Rope.string r')) → (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j ≤ max → Rope.inv (q1[Int.toNat j]!)) ∧ (∀(j : ℤ), (2 : ℤ) ≤ j ∧ j < i → q1[Int.toNat j]! = q[Int.toNat j]!) ∧ MyString.infix_eqeq (string_of_array q1 i (max + (1 : ℤ))) (MyString.app (string_of_array q i (max + (1 : ℤ))) (Rope.string r)))))))))
  := sorry
end ropes_Balance_insertqtvc
