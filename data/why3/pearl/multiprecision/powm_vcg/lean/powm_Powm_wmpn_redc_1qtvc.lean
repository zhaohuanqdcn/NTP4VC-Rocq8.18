import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.c.C
import Why3.mach.int.Unsigned
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.valuation.Valuation
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.sub_1.Sub_1
open Classical
open Lean4Why3
namespace powm_Powm_wmpn_redc_1qtvc
noncomputable def redc (ur : ℤ) (u : ℤ) (n : ℤ) (m : ℤ) := ur % m = HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat n) * u % m
theorem wmpn_redc_1'vc (n : BitVec 32) (mp : C.ptr (BitVec 64)) (up : C.ptr (BitVec 64)) (rp : C.ptr (BitVec 64)) (invm : BitVec 64) (fact0 : (0 : ℤ) < BitVec.toInt n) (fact1 : C.valid mp (BitVec.toInt n)) (fact2 : C.valid up ((2 : ℤ) * BitVec.toInt n)) (fact3 : C.valid rp (BitVec.toInt n)) (fact4 : Odd (Lemmas.value mp (BitVec.toInt n))) (fact5 : Lemmas.value mp (BitVec.toInt n) * BitVec.toUInt invm % ((18446744073709551615 : ℤ) + (1 : ℤ)) = (18446744073709551615 : ℤ) + (1 : ℤ) - (1 : ℤ)) (fact6 : C.writable up = true) (fact7 : C.writable rp = true) : C.min up ≤ C.offset up + (0 : ℤ) ∧ C.offset up + (0 : ℤ) ≤ C.max up ∧ (∀(o1 : C.ptr (BitVec 64)), C.offset o1 = C.offset up + (0 : ℤ) ∧ C.plength o1 = C.plength up ∧ C.pelts o1 = C.pelts up ∧ C.data o1 = C.data up ∧ C.min o1 = C.min up ∧ C.max o1 = C.max up ∧ C.zone1 o1 = C.zone1 up ∧ C.writable o1 = C.writable up → (let vm : ℤ := Lemmas.value mp (BitVec.toInt n); int'32_in_bounds (BitVec.toInt n - (1 : ℤ)) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toInt n - (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o2 + (1 : ℤ) → (C.offset o1 = C.offset up + (0 : ℤ) ∧ C.pelts o1 = C.pelts up ∧ C.min o1 = C.min up ∧ C.max o1 = C.max up ∧ C.plength o1 = C.plength up ∧ C.writable o1 = true ∧ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (0 : ℕ) * Lemmas.value o1 (BitVec.toInt n + BitVec.toInt n - (0 : ℤ)) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * Lemmas.value up (0 : ℤ) = Lemmas.value up (BitVec.toInt n + BitVec.toInt n) + vm * (0 : ℤ) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (0 : ℕ)) ∧ (HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (0 : ℕ) * Lemmas.value o1 (BitVec.toInt n + BitVec.toInt n - (0 : ℤ)) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * Lemmas.value up (0 : ℤ)) % vm = Lemmas.value up (BitVec.toInt n + BitVec.toInt n) % vm) ∧ (∀(added : ℤ) (u : C.ptr (BitVec 64)) (up1 : C.ptr (BitVec 64)), List.length (C.data up1) = List.length (C.data up) ∧ C.offset up1 = C.offset up ∧ C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → (∀(j : BitVec 32), let j1 : ℤ := BitVec.toInt j; ((0 : ℤ) ≤ j1 ∧ j1 ≤ BitVec.toInt o2) ∧ C.offset u = C.offset up1 + j1 ∧ C.pelts u = C.pelts up1 ∧ C.min u = C.min up1 ∧ C.max u = C.max up1 ∧ C.plength u = C.plength up1 ∧ C.writable u = true ∧ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat j1) * Lemmas.value u (BitVec.toInt n + BitVec.toInt n - j1) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * Lemmas.value up1 j1 = Lemmas.value up (BitVec.toInt n + BitVec.toInt n) + vm * added ∧ ((0 : ℤ) ≤ added ∧ added < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat j1)) ∧ (HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat j1) * Lemmas.value u (BitVec.toInt n + BitVec.toInt n - j1) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * Lemmas.value up1 j1) % vm = Lemmas.value up (BitVec.toInt n + BitVec.toInt n) % vm → (C.min u ≤ C.offset u ∧ C.offset u < C.max u) ∧ (∀(m : BitVec 64), BitVec.toUInt m = BitVec.toUInt (C.pelts u (C.offset u)) * BitVec.toUInt invm % ((18446744073709551615 : ℤ) + (1 : ℤ)) → int'32_in_bounds (BitVec.toInt n + BitVec.toInt n) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt n + BitVec.toInt n → int'32_in_bounds (BitVec.toInt o3 - BitVec.toInt j) ∧ (∀(nnj : BitVec 32), BitVec.toInt nnj = BitVec.toInt o3 - BitVec.toInt j → (C.valid mp (BitVec.toInt n) ∧ C.valid u (BitVec.toInt n) ∧ C.writable u = true) ∧ (∀(u1 : C.ptr (BitVec 64)) (up2 : C.ptr (BitVec 64)), C.data u1 = C.data up2 ∧ List.length (C.data up2) = List.length (C.data u) ∧ C.offset u1 = C.offset u ∧ C.min u1 = C.min u ∧ C.max u1 = C.max u ∧ C.writable u1 = C.writable u ∧ C.zone1 u1 = C.zone1 u → C.data u1 = C.data up2 ∧ List.length (C.data up2) = List.length (C.data u) ∧ C.offset u1 = C.offset u ∧ C.min u1 = C.min u ∧ C.max u1 = C.max u ∧ C.writable u1 = C.writable u ∧ C.zone1 u1 = C.zone1 u → List.length (C.data up2) = List.length (C.data up1) ∧ C.offset up2 = C.offset up1 ∧ C.min up2 = C.min up1 ∧ C.max up2 = C.max up1 ∧ C.writable up2 = C.writable up1 ∧ C.zone1 up2 = C.zone1 up1 → (∀(o4 : BitVec 64), Lemmas.value u1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt o4 = Lemmas.value u (BitVec.toInt n) + Lemmas.value mp (BitVec.toInt n) * BitVec.toUInt m ∧ (∀(j2 : ℤ), j2 < C.offset u1 ∨ C.offset u1 + BitVec.toInt n ≤ j2 → C.pelts u1 j2 = C.pelts u j2) → ((C.min u1 ≤ C.offset u1 ∧ C.offset u1 < C.max u1) ∧ C.writable u1 = true) ∧ (∀(u2 : C.ptr (BitVec 64)) (up3 : C.ptr (BitVec 64)), C.data u2 = C.data up3 ∧ List.length (C.data up3) = List.length (C.data u1) ∧ C.offset u2 = C.offset u1 ∧ C.min u2 = C.min u1 ∧ C.max u2 = C.max u1 ∧ C.writable u2 = C.writable u1 ∧ C.zone1 u2 = C.zone1 u1 → C.data u2 = C.data up3 ∧ List.length (C.data up3) = List.length (C.data u1) ∧ C.offset u2 = C.offset u1 ∧ C.min u2 = C.min u1 ∧ C.max u2 = C.max u1 ∧ C.writable u2 = C.writable u1 ∧ C.zone1 u2 = C.zone1 u1 → List.length (C.data up3) = List.length (C.data up2) ∧ C.offset up3 = C.offset up2 ∧ C.min up3 = C.min up2 ∧ C.max up3 = C.max up2 ∧ C.writable up3 = C.writable up2 ∧ C.zone1 up3 = C.zone1 up2 → C.pelts u2 = Function.update (C.pelts u1) (C.offset u2) o4 → (C.min u2 ≤ C.offset u2 + (1 : ℤ) ∧ C.offset u2 + (1 : ℤ) ≤ C.max u2) ∧ (∀(o5 : C.ptr (BitVec 64)), C.offset o5 = C.offset u2 + (1 : ℤ) ∧ C.plength o5 = C.plength u2 ∧ C.pelts o5 = C.pelts u2 ∧ C.data o5 = C.data u2 ∧ C.min o5 = C.min u2 ∧ C.max o5 = C.max u2 ∧ C.zone1 o5 = C.zone1 u2 ∧ C.writable o5 = C.writable u2 → C.offset o5 = C.offset up3 + (j1 + (1 : ℤ)) ∧ C.pelts o5 = C.pelts up3 ∧ C.min o5 = C.min up3 ∧ C.max o5 = C.max up3 ∧ C.plength o5 = C.plength up3 ∧ C.writable o5 = true ∧ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (j1 + (1 : ℤ))) * Lemmas.value o5 (BitVec.toInt n + BitVec.toInt n - (j1 + (1 : ℤ))) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * Lemmas.value up3 (j1 + (1 : ℤ)) = Lemmas.value up (BitVec.toInt n + BitVec.toInt n) + vm * (added + BitVec.toUInt m * HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt j))) ∧ ((0 : ℤ) ≤ added + BitVec.toUInt m * HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt j)) ∧ added + BitVec.toUInt m * HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt j)) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (j1 + (1 : ℤ)))) ∧ (HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (j1 + (1 : ℤ))) * Lemmas.value o5 (BitVec.toInt n + BitVec.toInt n - (j1 + (1 : ℤ))) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * Lemmas.value up3 (j1 + (1 : ℤ))) % vm = Lemmas.value up (BitVec.toInt n + BitVec.toInt n) % vm)))))))) ∧ (C.offset u = C.offset up1 + (BitVec.toInt o2 + (1 : ℤ)) ∧ C.pelts u = C.pelts up1 ∧ C.min u = C.min up1 ∧ C.max u = C.max up1 ∧ C.plength u = C.plength up1 ∧ C.writable u = true ∧ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o2 + (1 : ℤ))) * Lemmas.value u (BitVec.toInt n + BitVec.toInt n - (BitVec.toInt o2 + (1 : ℤ))) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * Lemmas.value up1 (BitVec.toInt o2 + (1 : ℤ)) = Lemmas.value up (BitVec.toInt n + BitVec.toInt n) + vm * added ∧ ((0 : ℤ) ≤ added ∧ added < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o2 + (1 : ℤ)))) ∧ (HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o2 + (1 : ℤ))) * Lemmas.value u (BitVec.toInt n + BitVec.toInt n - (BitVec.toInt o2 + (1 : ℤ))) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * Lemmas.value up1 (BitVec.toInt o2 + (1 : ℤ))) % vm = Lemmas.value up (BitVec.toInt n + BitVec.toInt n) % vm → int'32_in_bounds (-BitVec.toInt n) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = -BitVec.toInt n → (C.min u ≤ C.offset u + BitVec.toInt o3 ∧ C.offset u + BitVec.toInt o3 ≤ C.max u) ∧ (∀(u' : C.ptr (BitVec 64)), C.offset u' = C.offset u + BitVec.toInt o3 ∧ C.plength u' = C.plength u ∧ C.pelts u' = C.pelts u ∧ C.data u' = C.data u ∧ C.min u' = C.min u ∧ C.max u' = C.max u ∧ C.zone1 u' = C.zone1 u ∧ C.writable u' = C.writable u → int'32_in_bounds (-BitVec.toInt n) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = -BitVec.toInt n → (C.min u ≤ C.offset u + BitVec.toInt o4 ∧ C.offset u + BitVec.toInt o4 ≤ C.max u) ∧ (∀(o5 : C.ptr (BitVec 64)), C.offset o5 = C.offset u + BitVec.toInt o4 ∧ C.plength o5 = C.plength u ∧ C.pelts o5 = C.pelts u ∧ C.data o5 = C.data u ∧ C.min o5 = C.min u ∧ C.max o5 = C.max u ∧ C.zone1 o5 = C.zone1 u ∧ C.writable o5 = C.writable u → (C.valid u (BitVec.toInt n) ∧ C.valid o5 (BitVec.toInt n) ∧ C.valid rp (BitVec.toInt n) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(o6 : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt o6 ∧ BitVec.toUInt o6 ≤ (1 : ℤ)) ∧ Lemmas.value rp1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt o6 = Lemmas.value u (BitVec.toInt n) + Lemmas.value o5 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset rp1 ∨ C.offset rp1 + BitVec.toInt n ≤ j → C.pelts rp1 j = C.pelts rp j) → (∀(o7 : Bool), (BitVec.toUInt o6 = BitVec.toUInt (0 : BitVec 64) → o7 = true) ∧ (o7 = true → o6 = (0 : BitVec 64)) → (if ¬o7 = true then ((0 : ℤ) ≤ BitVec.toInt n ∧ C.valid rp1 (BitVec.toInt n) ∧ C.valid mp (BitVec.toInt n) ∧ C.writable rp1 = true) ∧ (∀(rp2 : C.ptr (BitVec 64)), List.length (C.data rp2) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → (∀(b : BitVec 64), Lemmas.value rp2 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt b = Lemmas.value rp1 (BitVec.toInt n) - Lemmas.value mp (BitVec.toInt n) ∧ ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset rp2 ∨ C.offset rp2 + BitVec.toInt n ≤ j → C.pelts rp2 j = C.pelts rp1 j) → Lemmas.value rp2 (BitVec.toInt n) % vm = (Lemmas.value rp1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt o6) % vm ∧ (∀(j : ℤ), j < C.offset rp2 ∨ C.offset rp2 + BitVec.toInt n ≤ j → C.pelts rp2 j = C.pelts rp1 j) ∧ (Lemmas.value up ((2 : ℤ) * BitVec.toInt n) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * vm → Lemmas.value rp2 (BitVec.toInt n) < (2 : ℤ) * vm))) else Lemmas.value rp1 (BitVec.toInt n) % vm = (Lemmas.value rp1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt o6) % vm ∧ (Lemmas.value up ((2 : ℤ) * BitVec.toInt n) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * vm → Lemmas.value rp1 (BitVec.toInt n) < (2 : ℤ) * vm))) ∧ (∀(rp2 : C.ptr (BitVec 64)), List.length (C.data rp2) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → Lemmas.value rp2 (BitVec.toInt n) % vm = (Lemmas.value rp1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt o6) % vm ∧ (∀(j : ℤ), j < C.offset rp2 ∨ C.offset rp2 + BitVec.toInt n ≤ j → C.pelts rp2 j = C.pelts rp1 j) ∧ (Lemmas.value up ((2 : ℤ) * BitVec.toInt n) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * vm → Lemmas.value rp2 (BitVec.toInt n) < (2 : ℤ) * vm) → redc (Lemmas.value up ((2 : ℤ) * BitVec.toInt n)) (Lemmas.value rp2 (BitVec.toInt n)) (BitVec.toInt n) (Lemmas.value mp (BitVec.toInt n)) ∧ (∀(j : ℤ), j < C.offset rp2 ∨ C.offset rp2 + BitVec.toInt n ≤ j → C.pelts rp2 j = C.pelts rp j) ∧ (Lemmas.value up ((2 : ℤ) * BitVec.toInt n) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * Lemmas.value mp (BitVec.toInt n) → Lemmas.value rp2 (BitVec.toInt n) < (2 : ℤ) * Lemmas.value mp (BitVec.toInt n)))))))))))) ∧ (BitVec.toInt o2 + (1 : ℤ) < (0 : ℤ) → int'32_in_bounds (-BitVec.toInt n) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = -BitVec.toInt n → (C.min o1 ≤ C.offset o1 + BitVec.toInt o3 ∧ C.offset o1 + BitVec.toInt o3 ≤ C.max o1) ∧ (∀(u' : C.ptr (BitVec 64)), C.offset u' = C.offset o1 + BitVec.toInt o3 ∧ C.plength u' = C.plength o1 ∧ C.pelts u' = C.pelts o1 ∧ C.data u' = C.data o1 ∧ C.min u' = C.min o1 ∧ C.max u' = C.max o1 ∧ C.zone1 u' = C.zone1 o1 ∧ C.writable u' = C.writable o1 → int'32_in_bounds (-BitVec.toInt n) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = -BitVec.toInt n → (C.min o1 ≤ C.offset o1 + BitVec.toInt o4 ∧ C.offset o1 + BitVec.toInt o4 ≤ C.max o1) ∧ (∀(o5 : C.ptr (BitVec 64)), C.offset o5 = C.offset o1 + BitVec.toInt o4 ∧ C.plength o5 = C.plength o1 ∧ C.pelts o5 = C.pelts o1 ∧ C.data o5 = C.data o1 ∧ C.min o5 = C.min o1 ∧ C.max o5 = C.max o1 ∧ C.zone1 o5 = C.zone1 o1 ∧ C.writable o5 = C.writable o1 → (C.valid o1 (BitVec.toInt n) ∧ C.valid o5 (BitVec.toInt n) ∧ C.valid rp (BitVec.toInt n) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(o6 : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt o6 ∧ BitVec.toUInt o6 ≤ (1 : ℤ)) ∧ Lemmas.value rp1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt o6 = Lemmas.value o1 (BitVec.toInt n) + Lemmas.value o5 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset rp1 ∨ C.offset rp1 + BitVec.toInt n ≤ j → C.pelts rp1 j = C.pelts rp j) → (∀(o7 : Bool), (BitVec.toUInt o6 = BitVec.toUInt (0 : BitVec 64) → o7 = true) ∧ (o7 = true → o6 = (0 : BitVec 64)) → (if ¬o7 = true then ((0 : ℤ) ≤ BitVec.toInt n ∧ C.valid rp1 (BitVec.toInt n) ∧ C.valid mp (BitVec.toInt n) ∧ C.writable rp1 = true) ∧ (∀(rp2 : C.ptr (BitVec 64)), List.length (C.data rp2) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → (∀(b : BitVec 64), Lemmas.value rp2 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt b = Lemmas.value rp1 (BitVec.toInt n) - Lemmas.value mp (BitVec.toInt n) ∧ ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset rp2 ∨ C.offset rp2 + BitVec.toInt n ≤ j → C.pelts rp2 j = C.pelts rp1 j) → Lemmas.value rp2 (BitVec.toInt n) % vm = (Lemmas.value rp1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt o6) % vm ∧ (∀(j : ℤ), j < C.offset rp2 ∨ C.offset rp2 + BitVec.toInt n ≤ j → C.pelts rp2 j = C.pelts rp1 j) ∧ (Lemmas.value up ((2 : ℤ) * BitVec.toInt n) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * vm → Lemmas.value rp2 (BitVec.toInt n) < (2 : ℤ) * vm))) else Lemmas.value rp1 (BitVec.toInt n) % vm = (Lemmas.value rp1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt o6) % vm ∧ (Lemmas.value up ((2 : ℤ) * BitVec.toInt n) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * vm → Lemmas.value rp1 (BitVec.toInt n) < (2 : ℤ) * vm))) ∧ (∀(rp2 : C.ptr (BitVec 64)), List.length (C.data rp2) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → Lemmas.value rp2 (BitVec.toInt n) % vm = (Lemmas.value rp1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt o6) % vm ∧ (∀(j : ℤ), j < C.offset rp2 ∨ C.offset rp2 + BitVec.toInt n ≤ j → C.pelts rp2 j = C.pelts rp1 j) ∧ (Lemmas.value up ((2 : ℤ) * BitVec.toInt n) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * vm → Lemmas.value rp2 (BitVec.toInt n) < (2 : ℤ) * vm) → redc (Lemmas.value up ((2 : ℤ) * BitVec.toInt n)) (Lemmas.value rp2 (BitVec.toInt n)) (BitVec.toInt n) (Lemmas.value mp (BitVec.toInt n)) ∧ (∀(j : ℤ), j < C.offset rp2 ∨ C.offset rp2 + BitVec.toInt n ≤ j → C.pelts rp2 j = C.pelts rp j) ∧ (Lemmas.value up ((2 : ℤ) * BitVec.toInt n) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * Lemmas.value mp (BitVec.toInt n) → Lemmas.value rp2 (BitVec.toInt n) < (2 : ℤ) * Lemmas.value mp (BitVec.toInt n)))))))))))))
  := sorry
end powm_Powm_wmpn_redc_1qtvc
