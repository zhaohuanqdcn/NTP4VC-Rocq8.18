theory split_string_SplitStringOCaml_split_stringqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.queue_Queue"
begin
typedecl  char
typedecl  string'
consts contents' :: "string' \<Rightarrow> char list"
consts concat :: "string' list \<Rightarrow> char \<Rightarrow> char list"
axiomatization where concat'def:   "if int (length ss) = (1 :: int) then concat ss sep = contents' (ss ! (0 :: nat)) else concat ss sep = concat (drop (0 :: nat) (take (nat (int (length ss) - (1 :: int)) - (0 :: nat)) ss)) sep @ Cons sep (contents' (ss ! nat (int (length ss) - (1 :: int))))"
 if "(1 :: int) \<le> int (length ss)"
  for ss :: "string' list"
  and sep :: "char"
definition notin :: "char \<Rightarrow> string' \<Rightarrow> _"
  where "notin sep s \<longleftrightarrow> \<not>sep \<in> set (contents' s)" for sep s
theorem split_string'vc:
  fixes limit :: "63 word"
  fixes o1 :: "string' t"
  fixes s :: "string'"
  fixes sep :: "char"
  assumes fact0: "sint limit = -(1 :: int) \<or> (1 :: int) \<le> sint limit"
  assumes fact1: "seq o1 = []"
  assumes fact2: "sint limit = (1 :: int) \<longrightarrow> limit = (1 :: 63 word)"
  shows "if limit = (1 :: 63 word) then \<forall>(ss :: string' t). seq ss = seq o1 @ [s] \<longrightarrow> (1 :: int) \<le> int (length (seq ss)) \<and> (sint limit = -(1 :: int) \<or> int (length (seq ss)) \<le> sint limit) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length (seq ss)) - (1 :: int) \<longrightarrow> notin sep (seq ss ! nat j)) \<and> (int (length (seq ss)) = sint limit \<or> notin sep (seq ss ! nat (int (length (seq ss)) - (1 :: int)))) \<and> concat (seq ss) sep = contents' s else (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> int (length (contents' s))) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length (seq o1)) \<longrightarrow> notin sep (seq o1 ! nat j)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> \<not>contents' s ! nat j = sep) \<and> (sint limit = -(1 :: int) \<or> int (length (seq o1)) < sint limit - (1 :: int)) \<and> contents' s = drop (0 :: nat) (contents' s) \<and> concat (seq o1 @ [s]) sep = contents' s) \<and> (\<forall>(suffix :: string') (b :: 63 word) (i :: 63 word) (ss :: string' t). ((0 :: int) \<le> sint b \<and> sint b \<le> sint i \<and> sint i \<le> int (length (contents' s))) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length (seq ss)) \<longrightarrow> notin sep (seq ss ! nat j)) \<and> (\<forall>(j :: int). sint b \<le> j \<and> j < sint i \<longrightarrow> \<not>contents' s ! nat j = sep) \<and> (sint limit = -(1 :: int) \<or> int (length (seq ss)) < sint limit - (1 :: int)) \<and> contents' suffix = drop (nat (sint b)) (contents' s) \<and> concat (seq ss @ [suffix]) sep = contents' s \<longrightarrow> (\<forall>(o2 :: 63 word). sint o2 = int (length (contents' s)) \<longrightarrow> (if sint i < sint o2 then ((0 :: int) \<le> sint i \<and> sint i < int (length (contents' s))) \<and> (if contents' s ! nat (sint i) = sep then ((0 :: int) \<le> sint b \<and> sint b \<le> sint i \<and> sint i \<le> int (length (contents' s))) \<and> (\<forall>(o3 :: string'). contents' o3 = drop (nat (sint b)) (take (nat (sint i) - nat (sint b)) (contents' s)) \<longrightarrow> (\<forall>(ss1 :: string' t). seq ss1 = seq ss @ [o3] \<longrightarrow> int'63_in_bounds (sint limit - (1 :: int)) \<and> (\<forall>(o4 :: 63 word). sint o4 = sint limit - (1 :: int) \<longrightarrow> (\<forall>(o5 :: nat). o5 = length (seq ss1) \<longrightarrow> (\<forall>(o6 :: 63 word). sint o6 = int o5 \<longrightarrow> (sint o6 = sint o4 \<longrightarrow> o6 = o4) \<longrightarrow> (if o6 = o4 then \<forall>(o7 :: 63 word). sint o7 = int (length (contents' s)) \<longrightarrow> int'63_in_bounds (sint i + (1 :: int)) \<and> (\<forall>(o8 :: 63 word). sint o8 = sint i + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint o8 \<and> sint o8 \<le> sint o7 \<and> sint o7 \<le> int (length (contents' s))) \<and> (\<forall>(o9 :: string'). contents' o9 = drop (nat (sint o8)) (take (nat (sint o7) - nat (sint o8)) (contents' s)) \<longrightarrow> (\<forall>(ss2 :: string' t). seq ss2 = seq ss1 @ [o9] \<longrightarrow> (1 :: int) \<le> int (length (seq ss2)) \<and> (sint limit = -(1 :: int) \<or> int (length (seq ss2)) \<le> sint limit) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length (seq ss2)) - (1 :: int) \<longrightarrow> notin sep (seq ss2 ! nat j)) \<and> (int (length (seq ss2)) = sint limit \<or> notin sep (seq ss2 ! nat (int (length (seq ss2)) - (1 :: int)))) \<and> concat (seq ss2) sep = contents' s))) else int'63_in_bounds (sint i + (1 :: int)) \<and> (\<forall>(o7 :: 63 word). sint o7 = sint i + (1 :: int) \<longrightarrow> (\<forall>(o8 :: 63 word). sint o8 = int (length (contents' s)) \<longrightarrow> ((0 :: int) \<le> sint o7 \<and> sint o7 \<le> sint o8 \<and> sint o8 \<le> int (length (contents' s))) \<and> (\<forall>(o9 :: string'). contents' o9 = drop (nat (sint o7)) (take (nat (sint o8) - nat (sint o7)) (contents' s)) \<longrightarrow> int'63_in_bounds (sint i + (1 :: int)) \<and> (\<forall>(o10 :: 63 word). sint o10 = sint i + (1 :: int) \<longrightarrow> ((0 :: int) \<le> int (length (contents' s)) - sint i \<and> int (length (contents' s)) - sint o10 < int (length (contents' s)) - sint i) \<and> ((0 :: int) \<le> sint o7 \<and> sint o7 \<le> sint o10 \<and> sint o10 \<le> int (length (contents' s))) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length (seq ss1)) \<longrightarrow> notin sep (seq ss1 ! nat j)) \<and> (\<forall>(j :: int). sint o7 \<le> j \<and> j < sint o10 \<longrightarrow> \<not>contents' s ! nat j = sep) \<and> (sint limit = -(1 :: int) \<or> int (length (seq ss1)) < sint limit - (1 :: int)) \<and> contents' o9 = drop (nat (sint o7)) (contents' s) \<and> concat (seq ss1 @ [o9]) sep = contents' s)))))))))) else int'63_in_bounds (sint i + (1 :: int)) \<and> (\<forall>(o3 :: 63 word). sint o3 = sint i + (1 :: int) \<longrightarrow> ((0 :: int) \<le> int (length (contents' s)) - sint i \<and> int (length (contents' s)) - sint o3 < int (length (contents' s)) - sint i) \<and> ((0 :: int) \<le> sint b \<and> sint b \<le> sint o3 \<and> sint o3 \<le> int (length (contents' s))) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length (seq ss)) \<longrightarrow> notin sep (seq ss ! nat j)) \<and> (\<forall>(j :: int). sint b \<le> j \<and> j < sint o3 \<longrightarrow> \<not>contents' s ! nat j = sep) \<and> (sint limit = -(1 :: int) \<or> int (length (seq ss)) < sint limit - (1 :: int)) \<and> contents' suffix = drop (nat (sint b)) (contents' s) \<and> concat (seq ss @ [suffix]) sep = contents' s)) else \<forall>(o3 :: 63 word). sint o3 = int (length (contents' s)) \<longrightarrow> ((0 :: int) \<le> sint b \<and> sint b \<le> sint o3 \<and> sint o3 \<le> int (length (contents' s))) \<and> (\<forall>(o4 :: string'). contents' o4 = drop (nat (sint b)) (take (nat (sint o3) - nat (sint b)) (contents' s)) \<longrightarrow> (\<forall>(ss1 :: string' t). seq ss1 = seq ss @ [o4] \<longrightarrow> (1 :: int) \<le> int (length (seq ss1)) \<and> (sint limit = -(1 :: int) \<or> int (length (seq ss1)) \<le> sint limit) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length (seq ss1)) - (1 :: int) \<longrightarrow> notin sep (seq ss1 ! nat j)) \<and> (int (length (seq ss1)) = sint limit \<or> notin sep (seq ss1 ! nat (int (length (seq ss1)) - (1 :: int)))) \<and> concat (seq ss1) sep = contents' s)))))"
  sorry
end
