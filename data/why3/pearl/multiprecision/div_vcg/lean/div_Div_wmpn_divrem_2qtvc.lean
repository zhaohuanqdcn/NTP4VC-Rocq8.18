import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.mul.Mul
open Classical
open Lean4Why3
namespace div_Div_wmpn_divrem_2qtvc
noncomputable def reciprocal (v : BitVec 64) (d : BitVec 64) := BitVec.toUInt v = (((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) - (1 : ℤ)) / BitVec.toUInt d - ((18446744073709551615 : ℤ) + (1 : ℤ))
noncomputable def reciprocal_3by2 (v : BitVec 64) (dh : BitVec 64) (dl : BitVec 64) := BitVec.toUInt v = (((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) - (1 : ℤ)) / (BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh) - ((18446744073709551615 : ℤ) + (1 : ℤ))
noncomputable def normalized (x : C.ptr (BitVec 64)) (sz : BitVec 32) := C.valid x (BitVec.toInt sz) ∧ ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt (C.pelts x (C.offset x + BitVec.toInt sz - (1 : ℤ)))
theorem wmpn_divrem_2'vc (sx : BitVec 32) (x : C.ptr (BitVec 64)) (y : C.ptr (BitVec 64)) (q : C.ptr (BitVec 64)) (fact0 : (2 : ℤ) ≤ BitVec.toInt sx) (fact1 : C.valid x (BitVec.toInt sx)) (fact2 : C.valid y (2 : ℤ)) (fact3 : C.valid q (BitVec.toInt sx - (2 : ℤ))) (fact4 : ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt (C.pelts y (C.offset y + (1 : ℤ)))) (fact5 : C.writable q = true) (fact6 : C.writable x = true) : int'32_in_bounds (BitVec.toInt sx - (2 : ℤ)) ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = BitVec.toInt sx - (2 : ℤ) → (C.min x ≤ C.offset x + BitVec.toInt o1 ∧ C.offset x + BitVec.toInt o1 ≤ C.max x) ∧ (∀(o2 : C.ptr (BitVec 64)), C.offset o2 = C.offset x + BitVec.toInt o1 ∧ C.plength o2 = C.plength x ∧ C.pelts o2 = C.pelts x ∧ C.data o2 = C.data x ∧ C.min o2 = C.min x ∧ C.max o2 = C.max x ∧ C.zone1 o2 = C.zone1 x ∧ C.writable o2 = C.writable x → (C.min y ≤ C.offset y + (1 : ℤ) ∧ C.offset y + (1 : ℤ) < C.max y) ∧ (let dh : BitVec 64 := C.pelts y (C.offset y + (1 : ℤ)); (C.min y ≤ C.offset y ∧ C.offset y < C.max y) ∧ (let dl : BitVec 64 := C.pelts y (C.offset y); (C.min o2 ≤ C.offset o2 + (1 : ℤ) ∧ C.offset o2 + (1 : ℤ) < C.max o2) ∧ (let o3 : BitVec 64 := C.pelts o2 (C.offset o2 + (1 : ℤ)); (C.min o2 ≤ C.offset o2 ∧ C.offset o2 < C.max o2) ∧ (let o4 : BitVec 64 := C.pelts o2 (C.offset o2); int'32_in_bounds (BitVec.toInt sx - (2 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt sx - (2 : ℤ) → ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt dh ∧ (∀(dinv : BitVec 64), reciprocal_3by2 dinv dh dl → ((if BitVec.toUInt dh ≤ BitVec.toUInt o3 then if BitVec.toUInt dh < BitVec.toUInt o3 then True else true = (if BitVec.toUInt dl ≤ BitVec.toUInt o4 then true else false) else true = false) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (1 : ℤ)) ∧ (∀(r0 : BitVec 64) (b : BitVec 64), BitVec.toUInt r0 - ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt b = BitVec.toUInt o4 - BitVec.toUInt dl - (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ) → (0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ))) ∧ (∀(rh : BitVec 64) (rl : BitVec 64) (qh : BitVec 64), (∃(o6 : Bool), (if BitVec.toUInt dh ≤ BitVec.toUInt o3 then if BitVec.toUInt dh < BitVec.toUInt o3 then o6 = true else o6 = (if BitVec.toUInt dl ≤ BitVec.toUInt o4 then true else false) else o6 = false) ∧ (if o6 = true then ∃(d : BitVec 64), (BitVec.toUInt rl - ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt d = BitVec.toUInt o4 - BitVec.toUInt dl - (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toUInt d ∧ BitVec.toUInt d ≤ (1 : ℤ)) ∧ (∃(d1 : BitVec 64), (BitVec.toUInt rh - ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt d1 = BitVec.toUInt o3 - BitVec.toUInt dh - BitVec.toUInt d ∧ (0 : ℤ) ≤ BitVec.toUInt d1 ∧ BitVec.toUInt d1 ≤ (1 : ℤ)) ∧ qh = (1 : BitVec 64)) else (rh = o3 ∧ rl = o4) ∧ qh = (0 : BitVec 64))) → (((0 : ℤ) ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 ≤ BitVec.toInt sx - (2 : ℤ)) ∧ C.offset o2 = C.offset x + BitVec.toInt o5 ∧ C.plength o2 = C.plength x ∧ C.min o2 = C.min x ∧ C.max o2 = C.max x ∧ C.pelts o2 = C.pelts x ∧ C.writable o2 = true ∧ Lemmas.value x (BitVec.toInt sx) = (Lemmas.value_sub (C.pelts q) (C.offset q + BitVec.toInt o5) (C.offset q + BitVec.toInt sx - (2 : ℤ)) + BitVec.toUInt qh * HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx - (2 : ℤ) - BitVec.toInt o5))) * Lemmas.value y (2 : ℤ) * HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o5)) + Lemmas.value x (BitVec.toInt o5) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o5)) * (BitVec.toUInt rl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt rh) ∧ BitVec.toUInt rl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt rh < BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh) ∧ (∀(i : BitVec 32) (rl1 : BitVec 64) (rh1 : BitVec 64) (xp : C.ptr (BitVec 64)) (q1 : C.ptr (BitVec 64)), List.length (C.data q1) = List.length (C.data q) ∧ C.offset q1 = C.offset q ∧ C.min q1 = C.min q ∧ C.max q1 = C.max q ∧ C.writable q1 = C.writable q ∧ C.zone1 q1 = C.zone1 q → ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sx - (2 : ℤ)) ∧ C.offset xp = C.offset x + BitVec.toInt i ∧ C.plength xp = C.plength x ∧ C.min xp = C.min x ∧ C.max xp = C.max x ∧ C.pelts xp = C.pelts x ∧ C.writable xp = true ∧ Lemmas.value x (BitVec.toInt sx) = (Lemmas.value_sub (C.pelts q1) (C.offset q1 + BitVec.toInt i) (C.offset q1 + BitVec.toInt sx - (2 : ℤ)) + BitVec.toUInt qh * HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx - (2 : ℤ) - BitVec.toInt i))) * Lemmas.value y (2 : ℤ) * HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) + Lemmas.value x (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * (BitVec.toUInt rl1 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt rh1) ∧ BitVec.toUInt rl1 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt rh1 < BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh → (if (0 : ℤ) < BitVec.toInt i then (C.min xp ≤ C.offset xp + -(1 : ℤ) ∧ C.offset xp + -(1 : ℤ) ≤ C.max xp) ∧ (∀(o6 : C.ptr (BitVec 64)), C.offset o6 = C.offset xp + -(1 : ℤ) ∧ C.plength o6 = C.plength xp ∧ C.pelts o6 = C.pelts xp ∧ C.data o6 = C.data xp ∧ C.min o6 = C.min xp ∧ C.max o6 = C.max xp ∧ C.zone1 o6 = C.zone1 xp ∧ C.writable o6 = C.writable xp → (C.min o6 ≤ C.offset o6 ∧ C.offset o6 < C.max o6) ∧ (((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt dh ∧ reciprocal_3by2 dinv dh dl ∧ BitVec.toUInt rl1 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt rh1 < BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh) ∧ (∀(qu : BitVec 64) (r0 : BitVec 64) (r1 : BitVec 64), BitVec.toUInt qu * BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt qu * BitVec.toUInt dh + BitVec.toUInt r0 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt r1 = BitVec.toUInt (C.pelts o6 (C.offset o6)) + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt rl1 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt rh1 ∧ (0 : ℤ) ≤ BitVec.toUInt r0 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt r1 ∧ BitVec.toUInt r0 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt r1 < BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh → int'32_in_bounds (BitVec.toInt i - (1 : ℤ)) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt i - (1 : ℤ) → ((C.min q1 ≤ C.offset q1 + BitVec.toInt o7 ∧ C.offset q1 + BitVec.toInt o7 < C.max q1) ∧ C.writable q1 = true) ∧ (∀(q2 : C.ptr (BitVec 64)), List.length (C.data q2) = List.length (C.data q1) ∧ C.offset q2 = C.offset q1 ∧ C.min q2 = C.min q1 ∧ C.max q2 = C.max q1 ∧ C.writable q2 = C.writable q1 ∧ C.zone1 q2 = C.zone1 q1 → C.pelts q2 = Function.update (C.pelts q1) (C.offset q2 + BitVec.toInt o7) qu ∧ C.pelts q2 (C.offset q2 + BitVec.toInt o7) = qu → BitVec.toInt o7 < BitVec.toInt i ∧ ((0 : ℤ) ≤ BitVec.toInt o7 ∧ BitVec.toInt o7 ≤ BitVec.toInt sx - (2 : ℤ)) ∧ C.offset o6 = C.offset x + BitVec.toInt o7 ∧ C.plength o6 = C.plength x ∧ C.min o6 = C.min x ∧ C.max o6 = C.max x ∧ C.pelts o6 = C.pelts x ∧ C.writable o6 = true ∧ Lemmas.value x (BitVec.toInt sx) = (Lemmas.value_sub (C.pelts q2) (C.offset q2 + BitVec.toInt o7) (C.offset q2 + BitVec.toInt sx - (2 : ℤ)) + BitVec.toUInt qh * HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx - (2 : ℤ) - BitVec.toInt o7))) * Lemmas.value y (2 : ℤ) * HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o7)) + Lemmas.value x (BitVec.toInt o7) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o7)) * (BitVec.toUInt r0 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt r1) ∧ BitVec.toUInt r0 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt r1 < BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh)))) else ((C.min x ≤ C.offset x + (1 : ℤ) ∧ C.offset x + (1 : ℤ) < C.max x) ∧ C.writable x = true) ∧ (∀(x1 : C.ptr (BitVec 64)), List.length (C.data x1) = List.length (C.data x) ∧ C.offset x1 = C.offset x ∧ C.min x1 = C.min x ∧ C.max x1 = C.max x ∧ C.writable x1 = C.writable x ∧ C.zone1 x1 = C.zone1 x → C.pelts x1 = Function.update (C.pelts x) (C.offset x1 + (1 : ℤ)) rh1 ∧ C.pelts x1 (C.offset x1 + (1 : ℤ)) = rh1 → ((C.min x1 ≤ C.offset x1 ∧ C.offset x1 < C.max x1) ∧ C.writable x1 = true) ∧ (∀(x2 : C.ptr (BitVec 64)), List.length (C.data x2) = List.length (C.data x1) ∧ C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.max x2 = C.max x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → C.pelts x2 = Function.update (C.pelts x1) (C.offset x2) rl1 → Lemmas.value x (BitVec.toInt sx) = (Lemmas.value q1 (BitVec.toInt sx - (2 : ℤ)) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx - (2 : ℤ))) * BitVec.toUInt qh) * Lemmas.value y (2 : ℤ) + Lemmas.value x2 (2 : ℤ) ∧ Lemmas.value x2 (2 : ℤ) < Lemmas.value y (2 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toUInt qh ∧ BitVec.toUInt qh ≤ (1 : ℤ))))))))))))))
  := sorry
end div_Div_wmpn_divrem_2qtvc
