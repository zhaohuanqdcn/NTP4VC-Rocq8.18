import Why3.Base
import Why3.Qed.Qed
import Why3.Memory.Memory
import frama_c.airborne.float_quat_of_rmat.lib.lean.Axiomatic15.Axiomatic15
import Why3.Cmath.Cmath
import Why3.Cfloat.Cfloat
import frama_c.airborne.float_quat_of_rmat.lib.lean.Compound.Compound
import frama_c.airborne.float_quat_of_rmat.lib.lean.Axiomatic17.Axiomatic17
import frama_c.airborne.float_quat_of_rmat.lib.lean.S10_RealRMat_s.S10_RealRMat_s
import frama_c.airborne.float_quat_of_rmat.lib.lean.Axiomatic19.Axiomatic19
import frama_c.airborne.float_quat_of_rmat.lib.lean.S11_RealQuat_s.S11_RealQuat_s
import Why3.Square.Square
import frama_c.airborne.float_quat_of_rmat.lib.lean.Axiomatic18.Axiomatic18
open Classical
open Lean4Why3
namespace float_quat_of_rmat_Why3_ide_VCfloat_quat_of_rmat_trace_pos_post_goal12
theorem goal12 (t_1 : Memory.addr -> ℝ) (a : Memory.addr) (a_1 : Memory.addr) (t_8 : Memory.addr -> ℝ) (r_3 : ℝ) (r_7 : ℝ) (t_7 : Memory.addr -> ℝ) (r_6 : ℝ) (r_2 : ℝ) (t_4 : Memory.addr -> ℝ) (r_1 : ℝ) (t_6 : Memory.addr -> ℝ) (r_5 : ℝ) (r : ℝ) (t_5 : Memory.addr -> ℝ) (r_4 : ℝ) (t : ℤ -> ℤ) (t_9 : Memory.addr -> ℝ) (t_2 : Memory.addr -> ℝ) (t_3 : Memory.addr -> ℝ) : let a_2 : S10_RealRMat_s.s10_realrmat_s := Axiomatic17.l_l_rmat_of_floatrmat t_1 a; let a_3 : Memory.addr := Memory.shift a (0 : ℤ); let a_4 : Memory.addr := Memory.shift a_3 (0 : ℤ); let r_8 : ℝ := t_1 a_4; let a_5 : Memory.addr := Memory.shift a_3 (4 : ℤ); let r_9 : ℝ := t_1 a_5; let a_6 : Memory.addr := Memory.shift a_3 (8 : ℤ); let r_10 : ℝ := t_1 a_6; let r_11 : ℝ := r_8 + r_9 + r_10; let a_7 : Memory.addr := Memory.shift a_1 (0 : ℤ); let m : Memory.addr -> ℝ := Function.update t_8 a_7 ((1 : ℝ) / (2 : ℝ) * r_3); let a_8 : Memory.addr := Memory.shift a_1 (1 : ℤ); let a_9 : Memory.addr := Memory.shift a_3 (5 : ℤ); let a_10 : Memory.addr := Memory.shift a_3 (7 : ℤ); let m_1 : Memory.addr -> ℝ := Function.update m a_8 ((m a_9 + -m a_10) / r_7); let a_11 : Memory.addr := Memory.shift a_1 (2 : ℤ); let a_12 : Memory.addr := Memory.shift a_3 (6 : ℤ); let a_13 : Memory.addr := Memory.shift a_3 (2 : ℤ); let m_2 : Memory.addr -> ℝ := Function.update m_1 a_11 ((m_1 a_12 + -m_1 a_13) / r_7); let a_14 : Memory.addr := Memory.shift a_1 (3 : ℤ); let a_15 : Memory.addr := Memory.shift a_3 (1 : ℤ); let a_16 : Memory.addr := Memory.shift a_3 (3 : ℤ); let r_13 : ℝ := (1 : ℝ) + (t_8 a_4 + t_8 a_5 + t_8 a_6); let m_3 : Memory.addr -> ℝ := Function.update (Function.update t_7 a_7 ((t_7 a_9 + -t_7 a_10) / r_6)) a_8 ((1 : ℝ) / (2 : ℝ) * r_2); let m_4 : Memory.addr -> ℝ := Function.update m_3 a_11 ((m_3 a_15 + m_3 a_16) / r_6); let r_15 : ℝ := t_7 a_4 + -t_7 a_5 + -t_7 a_6 + (1 : ℝ); let r_16 : ℝ := t_4 a_6; let r_17 : ℝ := t_4 a_5; let r_19 : ℝ := (2 : ℝ) * r_1; let m_5 : Memory.addr -> ℝ := Function.update t_6 a_7 ((t_6 a_12 + -t_6 a_13) / r_5); let m_6 : Memory.addr -> ℝ := Function.update (Function.update m_5 a_8 ((m_5 a_15 + m_5 a_16) / r_5)) a_11 ((1 : ℝ) / (2 : ℝ) * r_1); let m_7 : Memory.addr -> ℝ := Function.update m_6 a_14 ((m_6 a_9 + m_6 a_10) / r_5); let r_20 : ℝ := t_6 a_5 + -t_6 a_4 + -t_6 a_6 + (1 : ℝ); let r_22 : ℝ := (2 : ℝ) * r; let m_8 : Memory.addr -> ℝ := Function.update t_5 a_7 ((t_5 a_15 + -t_5 a_16) / r_4); let m_9 : Memory.addr -> ℝ := Function.update m_8 a_8 ((m_8 a_12 + m_8 a_13) / r_4); let m_10 : Memory.addr -> ℝ := Function.update (Function.update m_9 a_11 ((m_9 a_9 + m_9 a_10) / r_4)) a_14 ((1 : ℝ) / (2 : ℝ) * r); let r_23 : ℝ := t_5 a_6 + -t_5 a_4 + -t_5 a_5 + (1 : ℝ); (0 : ℝ) < Axiomatic19.l_trace_2' t_1 a → Memory.region (Memory.addr.base a) ≤ (0 : ℤ) → Memory.region (Memory.addr.base a_1) ≤ (0 : ℤ) → Memory.linked t → Cfloat.is_float32 r → Cfloat.is_float32 r_1 → Cfloat.is_float32 r_2 → Cfloat.is_float32 r_3 → Cfloat.is_float32 r_4 → Cfloat.is_float32 r_5 → Cfloat.is_float32 r_6 → Cfloat.is_float32 r_7 → Memory.valid_rw t a_1 (4 : ℤ) → Axiomatic15.p_rvalid_floatrmat t t_1 a → Memory.separated a (9 : ℤ) a_1 (4 : ℤ) → Axiomatic17.p_rotation_matrix a_2 → Axiomatic17.p_special_orthogonal a_2 → Cfloat.is_float32 r_8 → Cfloat.is_float32 r_9 → Cfloat.is_float32 r_10 → Cfloat.is_float32 r_11 → (if (0 : ℝ) < r_11 then t_8 = t_1 ∧ (2 : ℝ) * r_3 = r_7 ∧ Function.update m_2 a_14 ((m_2 a_15 + -m_2 a_16) / r_7) = t_9 ∧ (0 : ℝ) ≤ r_3 ∧ (0 : ℝ) ≤ r_13 ∧ Cfloat.is_finite32 r_3 ∧ Cfloat.is_finite32 r_13 else t_2 = t_1 ∧ (if t_2 a_5 < t_2 a_4 then t_3 = t_2 ∧ (if t_3 a_6 < t_3 a_4 then t_7 = t_3 ∧ (2 : ℝ) * r_2 = r_6 ∧ Function.update m_4 a_14 ((m_4 a_12 + m_4 a_13) / r_6) = t_9 ∧ (0 : ℝ) ≤ r_2 ∧ (0 : ℝ) ≤ r_15 ∧ Cfloat.is_finite32 r_2 ∧ Cfloat.is_finite32 r_15 else t_4 = t_3 ∧ (if r_16 < r_17 then t_6 = t_4 ∧ r_19 = r_5 ∧ m_7 = t_9 ∧ (0 : ℝ) ≤ r_1 ∧ (0 : ℝ) ≤ r_20 ∧ Cfloat.is_finite32 r_1 ∧ Cfloat.is_finite32 r_20 else t_5 = t_4 ∧ r_22 = r_4 ∧ m_10 = t_9 ∧ (0 : ℝ) ≤ r ∧ (0 : ℝ) ≤ r_23 ∧ Cfloat.is_finite32 r ∧ Cfloat.is_finite32 r_23)) else t_4 = t_2 ∧ (if r_16 < r_17 then t_6 = t_4 ∧ r_19 = r_5 ∧ m_7 = t_9 ∧ (0 : ℝ) ≤ r_1 ∧ (0 : ℝ) ≤ r_20 ∧ Cfloat.is_finite32 r_1 ∧ Cfloat.is_finite32 r_20 else t_5 = t_4 ∧ r_22 = r_4 ∧ m_10 = t_9 ∧ (0 : ℝ) ≤ r ∧ (0 : ℝ) ≤ r_23 ∧ Cfloat.is_finite32 r ∧ Cfloat.is_finite32 r_23))) → S11_RealQuat_s.eqs11_realquat_s (Axiomatic19.l_l_floatquat_of_rmat_trace_pos_t t_9 a) (Axiomatic18.l_l_quat_of_floatquat t_9 a_1)
  := sorry
end float_quat_of_rmat_Why3_ide_VCfloat_quat_of_rmat_trace_pos_post_goal12
