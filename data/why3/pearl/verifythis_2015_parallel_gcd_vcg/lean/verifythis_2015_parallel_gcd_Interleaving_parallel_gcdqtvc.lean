import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace verifythis_2015_parallel_gcd_Interleaving_parallel_gcdqtvc
inductive state where
  | ReadA : state
  | ReadB : state
  | Compare : state
  | Halt : state
axiom inhabited_axiom_state : Inhabited state
attribute [instance] inhabited_axiom_state
structure thread where
  local_a : ℤ
  local_b : ℤ
  state1 : state
axiom inhabited_axiom_thread : Inhabited thread
attribute [instance] inhabited_axiom_thread
noncomputable def inv (th : thread) (d : ℤ) (a : ℤ) (b : ℤ) := (0 : ℤ) < a ∧ (0 : ℤ) < b ∧ Int.ofNat (Int.gcd a b) = d ∧ (match thread.state1 th with | state.ReadA => True | state.ReadB => thread.local_a th = a | state.Compare => thread.local_a th = a ∧ b ≤ thread.local_b th ∧ (thread.local_b th ≤ thread.local_a th → thread.local_b th = b) | state.Halt => thread.local_a th = a ∧ a = b)
noncomputable def progress_thread (th : thread) (a : ℤ) (b : ℤ) := b < a ∨ a = b ∧ ¬thread.state1 th = state.Halt
noncomputable def state_index (s : state) := match s with | state.ReadA => (7 : ℤ) | state.ReadB => (5 : ℤ) | state.Compare => (3 : ℤ) | state.Halt => (2 : ℤ)
noncomputable def sync (th : thread) (b : ℤ) := match thread.state1 th with | state.Compare => thread.local_b th = b | _ => True
noncomputable def sync_index (th : thread) (b : ℤ) := if sync th b then (0 : ℤ) else (42 : ℤ)
noncomputable def prog_index (th : thread) (b : ℤ) := sync_index th b + state_index (thread.state1 th)
theorem parallel_gcd'vc (a0 : ℤ) (b0 : ℤ) (fact0 : (0 : ℤ) < a0) (fact1 : (0 : ℤ) < b0) : let d : ℤ := Int.ofNat (Int.gcd a0 b0); ∀(th1 : thread), thread.state1 th1 = state.ReadA → (∀(th2 : thread), thread.state1 th2 = state.ReadA → (inv th1 d a0 b0 ∧ inv th2 d b0 a0) ∧ (∀(th21 : thread) (th11 : thread) (b : ℤ) (a : ℤ) (timer : ℤ) (scheduled : Bool), inv th11 d a b ∧ inv th21 d b a → (∀(o1 : Bool), (if ¬thread.state1 th11 = state.Halt then o1 = true else o1 = (if ¬thread.state1 th21 = state.Halt then true else false)) → (if o1 = true then ∀(timer1 : ℤ) (scheduled1 : Bool), (scheduled1 = scheduled → (0 : ℤ) ≤ timer1 ∧ timer1 < timer) → (if scheduled1 = true then inv th11 d a b ∧ (∀(th12 : thread) (a1 : ℤ), inv th12 d a1 b ∧ ((0 : ℤ) < a1 ∧ a1 ≤ a) ∧ (a1 < a → a1 + b ≤ a) ∧ (progress_thread th12 a1 b → prog_index th12 b < prog_index th11 b ∨ a1 < a) → ((0 : ℤ) ≤ a + b ∧ a1 + b < a + b ∨ a + b = a1 + b ∧ ((0 : ℤ) ≤ (if a = b then prog_index th21 a + prog_index th11 b else if a < b then prog_index th21 a else prog_index th11 b) ∧ (if a1 = b then prog_index th21 a1 + prog_index th12 b else if a1 < b then prog_index th21 a1 else prog_index th12 b) < (if a = b then prog_index th21 a + prog_index th11 b else if a < b then prog_index th21 a else prog_index th11 b) ∨ (if a = b then prog_index th21 a + prog_index th11 b else if a < b then prog_index th21 a else prog_index th11 b) = (if a1 = b then prog_index th21 a1 + prog_index th12 b else if a1 < b then prog_index th21 a1 else prog_index th12 b) ∧ ((0 : ℤ) ≤ (if progress_thread th11 a b then if scheduled = true then (1 : ℤ) else (0 : ℤ) else if progress_thread th21 b a then if scheduled = true then (0 : ℤ) else (1 : ℤ) else (0 : ℤ)) ∧ (if progress_thread th12 a1 b then if scheduled1 = true then (1 : ℤ) else (0 : ℤ) else if progress_thread th21 b a1 then if scheduled1 = true then (0 : ℤ) else (1 : ℤ) else (0 : ℤ)) < (if progress_thread th11 a b then if scheduled = true then (1 : ℤ) else (0 : ℤ) else if progress_thread th21 b a then if scheduled = true then (0 : ℤ) else (1 : ℤ) else (0 : ℤ)) ∨ (if progress_thread th11 a b then if scheduled = true then (1 : ℤ) else (0 : ℤ) else if progress_thread th21 b a then if scheduled = true then (0 : ℤ) else (1 : ℤ) else (0 : ℤ)) = (if progress_thread th12 a1 b then if scheduled1 = true then (1 : ℤ) else (0 : ℤ) else if progress_thread th21 b a1 then if scheduled1 = true then (0 : ℤ) else (1 : ℤ) else (0 : ℤ)) ∧ (0 : ℤ) ≤ timer ∧ timer1 < timer))) ∧ inv th12 d a1 b ∧ inv th21 d b a1) else inv th21 d b a ∧ (∀(th22 : thread) (b1 : ℤ), inv th22 d b1 a ∧ ((0 : ℤ) < b1 ∧ b1 ≤ b) ∧ (b1 < b → b1 + a ≤ b) ∧ (progress_thread th22 b1 a → prog_index th22 a < prog_index th21 a ∨ b1 < b) → ((0 : ℤ) ≤ a + b ∧ a + b1 < a + b ∨ a + b = a + b1 ∧ ((0 : ℤ) ≤ (if a = b then prog_index th21 a + prog_index th11 b else if a < b then prog_index th21 a else prog_index th11 b) ∧ (if a = b1 then prog_index th22 a + prog_index th11 b1 else if a < b1 then prog_index th22 a else prog_index th11 b1) < (if a = b then prog_index th21 a + prog_index th11 b else if a < b then prog_index th21 a else prog_index th11 b) ∨ (if a = b then prog_index th21 a + prog_index th11 b else if a < b then prog_index th21 a else prog_index th11 b) = (if a = b1 then prog_index th22 a + prog_index th11 b1 else if a < b1 then prog_index th22 a else prog_index th11 b1) ∧ ((0 : ℤ) ≤ (if progress_thread th11 a b then if scheduled = true then (1 : ℤ) else (0 : ℤ) else if progress_thread th21 b a then if scheduled = true then (0 : ℤ) else (1 : ℤ) else (0 : ℤ)) ∧ (if progress_thread th11 a b1 then if scheduled1 = true then (1 : ℤ) else (0 : ℤ) else if progress_thread th22 b1 a then if scheduled1 = true then (0 : ℤ) else (1 : ℤ) else (0 : ℤ)) < (if progress_thread th11 a b then if scheduled = true then (1 : ℤ) else (0 : ℤ) else if progress_thread th21 b a then if scheduled = true then (0 : ℤ) else (1 : ℤ) else (0 : ℤ)) ∨ (if progress_thread th11 a b then if scheduled = true then (1 : ℤ) else (0 : ℤ) else if progress_thread th21 b a then if scheduled = true then (0 : ℤ) else (1 : ℤ) else (0 : ℤ)) = (if progress_thread th11 a b1 then if scheduled1 = true then (1 : ℤ) else (0 : ℤ) else if progress_thread th22 b1 a then if scheduled1 = true then (0 : ℤ) else (1 : ℤ) else (0 : ℤ)) ∧ (0 : ℤ) ≤ timer ∧ timer1 < timer))) ∧ inv th11 d a b1 ∧ inv th22 d b1 a)) else a = Int.ofNat (Int.gcd a0 b0)))))
  := sorry
end verifythis_2015_parallel_gcd_Interleaving_parallel_gcdqtvc
