From Stdlib Require Import Strings.String.
From Stdlib Require Import String Ascii.
From Stdlib Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Stdlib Require Classical.
From Stdlib Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Stdlib Require Import Sorting.Sorted.
From Stdlib Require Import Reals.Rbasic_fun.
From Stdlib Require Import Reals.Abstract.ConstructiveAbs.
From Stdlib Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Stdlib Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Stdlib Require Import ZArith.Zeuclid.
From Stdlib Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Stdlib Require Import Reals.
Require Import Why3.Base.
Require Import euler_sieve_vcg.euler_sieve.ArithmeticResults.
Require Import euler_sieve_vcg.euler_sieve.DivisibilityResults.
Require Import euler_sieve_vcg.euler_sieve.EulerSieveSpec.
Require Import Why3.mach.array.ArrayInt63.
Open Scope Z_scope.
Axiom t : Type.
Axiom t_inhabited : Inhabited t.
Global Existing Instance t_inhabited.
Axiom t_countable : Countable t.
Global Existing Instance t_countable.
Axiom nexts : t -> list Z.
Axiom marked : t -> list bool.
Axiom arr : t -> ArrayInt63.array63.
Axiom max : t -> bv 63%N.
Axiom max_arr : t -> bv 63%N.
Axiom t'invariant : forall  (self : t), bv_signed (max self) < bv_signed int'63_max ∧ 3%Z ≤ bv_signed (max self) ∧ length (nexts self) = length (marked self) ∧ Z.of_nat (length (marked self)) = bv_signed (max self) + 1%Z ∧ ZEuclid.div (bv_signed (max self) - 1%Z) 2%Z = bv_signed (max_arr self) ∧ Z.of_nat (length (elts (arr self))) = bv_signed (max_arr self) + 1%Z ∧ inv_nexts (nexts self) (Z.of_nat (length (nexts self))) ∧ all_eliminated_marked (marked self) (nexts self) ∧ (∀(i : Z), 3%Z ≤ i ∧ i ≤ bv_signed (max self) -> ZEuclid.modulo i 2%Z = 0%Z -> nth (Z.to_nat i) (marked self) inhabitant = true) ∧ (∀(i : Z), 3%Z ≤ i ∧ i < bv_signed (max self) - 1%Z -> ZEuclid.modulo i 2%Z = 1%Z -> ZEuclid.modulo (nth (Z.to_nat i) (nexts self) inhabitant) 2%Z = 1%Z ∨ nth (Z.to_nat i) (nexts self) inhabitant = bv_signed (max self) + 1%Z) ∧ nth (Z.to_nat (bv_signed (max self))) (nexts self) inhabitant = bv_signed (max self) + 1%Z ∧ (ZEuclid.modulo (bv_signed (max self) - 1%Z) 2%Z = 0%Z -> nth (Z.to_nat (bv_signed (max self) - 1%Z)) (nexts self) inhabitant = bv_signed (max self)) ∧ (ZEuclid.modulo (bv_signed (max self) - 1%Z) 2%Z = 1%Z -> nth (Z.to_nat (bv_signed (max self) - 1%Z)) (nexts self) inhabitant = bv_signed (max self) + 1%Z) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed (max_arr self) -> - (bv_signed (max self) + 1%Z) ≤ nth (Z.to_nat i) (elts (arr self)) inhabitant ∧ nth (Z.to_nat i) (elts (arr self)) inhabitant ≤ bv_signed (max self) + 1%Z) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed (max_arr self) -> (nth (Z.to_nat (2%Z * i + 1%Z)) (marked self) inhabitant = true) = (nth (Z.to_nat i) (elts (arr self)) inhabitant < 0%Z)) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed (max_arr self) -> ¬ nth (Z.to_nat (2%Z * i + 1%Z)) (marked self) inhabitant = true -> nth (Z.to_nat i) (elts (arr self)) inhabitant = nth (Z.to_nat (2%Z * i + 1%Z)) (nexts self) inhabitant) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed (max_arr self) -> nth (Z.to_nat (2%Z * i + 1%Z)) (marked self) inhabitant = true -> nth (Z.to_nat i) (elts (arr self)) inhabitant = - nth (Z.to_nat (2%Z * i + 1%Z)) (nexts self) inhabitant) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed (max_arr self) -> (i < ZEuclid.div (Z.abs (nth (Z.to_nat i) (elts (arr self)) inhabitant)) 2%Z ∧ ZEuclid.div (Z.abs (nth (Z.to_nat i) (elts (arr self)) inhabitant)) 2%Z ≤ bv_signed (max_arr self) + 1%Z) ∧ Z.abs (nth (Z.to_nat i) (elts (arr self)) inhabitant) ≤ bv_signed (max self) + 1%Z) ∧ (∀(i : Z) (j : Z), 0%Z ≤ i ∧ i ≤ bv_signed (max_arr self) -> i < j ∧ j < ZEuclid.div (Z.abs (nth (Z.to_nat i) (elts (arr self)) inhabitant)) 2%Z -> nth (Z.to_nat j) (elts (arr self)) inhabitant < 0%Z).
Definition t'eq (a : t) (b : t) := nexts a = nexts b ∧ marked a = marked b ∧ arr a = arr b ∧ max a = max b ∧ max_arr a = max_arr b.
Axiom t'inj : forall  (a : t) (b : t) (fact0 : t'eq a b), a = b.
Axiom fc : bv 63%N -> Z -> Z.
Axiom o1 : Z -> bool.
Axiom fc1 : bv 63%N -> bv 63%N -> Z -> Z.
Axiom fc'def : forall  (max1 : bv 63%N) (i : Z), fc max1 i = (if decide (i = bv_signed max1) then bv_signed max1 + 1%Z else if decide (i = bv_signed max1 - 1%Z) then if decide (ZEuclid.modulo i 2%Z = 0%Z) then bv_signed max1 else bv_signed max1 + 1%Z else if decide (i < 3%Z ∨ ZEuclid.modulo i 2%Z = 0%Z) then i + 1%Z else i + 2%Z).
Axiom o'def : forall  (i : Z), (o1 i = true) = (i = 0%Z ∨ i = 1%Z ∨ 2%Z < i ∧ ZEuclid.modulo i 2%Z = 0%Z).
Axiom fc'def1 : forall  (max1 : bv 63%N) (len_arr : bv 63%N) (i : Z), fc1 max1 len_arr i = (if decide (i = bv_signed len_arr - 1%Z) then bv_signed max1 + 1%Z else if decide (i = 0%Z) then - 2%Z else 2%Z * i + 3%Z).
Theorem create'vc (max1 : bv 63%N) (fact0 : bv_signed max1 < bv_signed int'63_max) (fact1 : 3%Z ≤ bv_signed max1) : let len : Z := bv_signed max1 + 1%Z in int'63_in_bounds (bv_signed max1 - 1%Z) ∧ (∀(o2 : bv 63%N), bv_signed o2 = bv_signed max1 - 1%Z -> (¬ 2%Z = 0%Z ∧ int'63_in_bounds (Z.rem (bv_signed o2) 2%Z)) ∧ (∀(o3 : bv 63%N), bv_signed o3 = Z.rem (bv_signed o2) 2%Z -> int'63_in_bounds (bv_signed o3 + 1%Z) ∧ (∀(len_arr : bv 63%N), bv_signed len_arr = bv_signed o3 + 1%Z -> (let o4 : Z -> Z := fc max1 in 0%Z ≤ len ∧ (let nexts1 : list Z := create_list (Z.to_nat len) (o4 ∘ Z.of_nat) in Z.of_nat (length nexts1) = len ∧ (∀(i : Z), 0%Z ≤ i ∧ i < len -> nth (Z.to_nat i) nexts1 inhabitant = o4 i) -> (∀(i : Z), ¬ i = 0%Z -> ¬ i = 1%Z -> 2%Z < i -> ¬ 2%Z = 0%Z) ∧ (let o5 : Z -> bool := o1 in 0%Z ≤ len ∧ (let marked1 : list bool := create_list (Z.to_nat len) (o5 ∘ Z.of_nat) in Z.of_nat (length marked1) = len ∧ (∀(i : Z), 0%Z ≤ i ∧ i < len -> nth (Z.to_nat i) marked1 inhabitant = o5 i) -> (let f : Z -> Z := fc1 max1 len_arr in 0%Z ≤ bv_signed len_arr ∧ (∀(arr1 : ArrayInt63.array63), (∀(i : Z), 0%Z ≤ i ∧ i < bv_signed len_arr -> nth (Z.to_nat i) (elts arr1) inhabitant = bv_signed ((-2)%bv : bv 63%N)) ∧ Z.of_nat (length (elts arr1)) = bv_signed len_arr -> int'63_in_bounds (bv_signed len_arr - 1%Z) ∧ (∀(o6 : bv 63%N), bv_signed o6 = bv_signed len_arr - 1%Z -> (1%Z ≤ bv_signed o6 + 1%Z -> (∀(j : Z), 0%Z ≤ j ∧ j < 1%Z -> nth (Z.to_nat j) (elts arr1) inhabitant = f j) ∧ (∀(arr2 : ArrayInt63.array63), ArrayInt63.size arr2 = ArrayInt63.size arr1 -> (∀(i : bv 63%N), let i1 : Z := bv_signed i in (1%Z ≤ i1 ∧ i1 ≤ bv_signed o6) ∧ (∀(j : Z), 0%Z ≤ j ∧ j < i1 -> nth (Z.to_nat j) (elts arr2) inhabitant = f j) -> int'63_in_bounds (bv_signed len_arr - 1%Z) ∧ (∀(o7 : bv 63%N), bv_signed o7 = bv_signed len_arr - 1%Z -> (bv_signed i = bv_signed o7 -> i = o7) -> (if decide (i = o7) then int'63_in_bounds (bv_signed max1 + 1%Z) else int'63_in_bounds (2%Z * bv_signed i) ∧ (∀(o8 : bv 63%N), bv_signed o8 = 2%Z * bv_signed i -> int'63_in_bounds (bv_signed o8 + 3%Z))) ∧ (∀(o8 : bv 63%N), (if decide (i = o7) then bv_signed o8 = bv_signed max1 + 1%Z else ∃(o9 : bv 63%N), bv_signed o9 = 2%Z * bv_signed i ∧ bv_signed o8 = bv_signed o9 + 3%Z) -> (0%Z ≤ bv_signed i ∧ bv_signed i < Z.of_nat (length (elts arr2))) ∧ (∀(arr3 : ArrayInt63.array63), ArrayInt63.size arr3 = ArrayInt63.size arr2 -> elts arr3 = set_list (elts arr2) (Z.to_nat (bv_signed i)) (bv_signed o8) -> (∀(j : Z), 0%Z ≤ j ∧ j < i1 + 1%Z -> nth (Z.to_nat j) (elts arr3) inhabitant = f j))))) ∧ ((∀(j : Z), 0%Z ≤ j ∧ j < bv_signed o6 + 1%Z -> nth (Z.to_nat j) (elts arr2) inhabitant = f j) -> int'63_in_bounds (bv_signed max1 - 1%Z) ∧ (∀(o7 : bv 63%N), bv_signed o7 = bv_signed max1 - 1%Z -> (¬ 2%Z = 0%Z ∧ int'63_in_bounds (Z.rem (bv_signed o7) 2%Z)) ∧ (∀(o8 : bv 63%N), bv_signed o8 = Z.rem (bv_signed o7) 2%Z -> ((bv_signed max1 < bv_signed int'63_max ∧ 3%Z ≤ bv_signed max1) ∧ (length nexts1 = length marked1 ∧ Z.of_nat (length marked1) = bv_signed max1 + 1%Z) ∧ ZEuclid.div (bv_signed max1 - 1%Z) 2%Z = bv_signed o8 ∧ Z.of_nat (length (elts arr2)) = bv_signed o8 + 1%Z ∧ inv_nexts nexts1 (Z.of_nat (length nexts1)) ∧ all_eliminated_marked marked1 nexts1 ∧ (∀(i : Z), 3%Z ≤ i ∧ i ≤ bv_signed max1 -> ZEuclid.modulo i 2%Z = 0%Z -> nth (Z.to_nat i) marked1 inhabitant = true) ∧ (∀(i : Z), 3%Z ≤ i ∧ i < bv_signed max1 - 1%Z -> ZEuclid.modulo i 2%Z = 1%Z -> ZEuclid.modulo (nth (Z.to_nat i) nexts1 inhabitant) 2%Z = 1%Z ∨ nth (Z.to_nat i) nexts1 inhabitant = bv_signed max1 + 1%Z) ∧ (nth (Z.to_nat (bv_signed max1)) nexts1 inhabitant = bv_signed max1 + 1%Z ∧ (ZEuclid.modulo (bv_signed max1 - 1%Z) 2%Z = 0%Z -> nth (Z.to_nat (bv_signed max1 - 1%Z)) nexts1 inhabitant = bv_signed max1) ∧ (ZEuclid.modulo (bv_signed max1 - 1%Z) 2%Z = 1%Z -> nth (Z.to_nat (bv_signed max1 - 1%Z)) nexts1 inhabitant = bv_signed max1 + 1%Z)) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed o8 -> - (bv_signed max1 + 1%Z) ≤ nth (Z.to_nat i) (elts arr2) inhabitant ∧ nth (Z.to_nat i) (elts arr2) inhabitant ≤ bv_signed max1 + 1%Z) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed o8 -> (nth (Z.to_nat (2%Z * i + 1%Z)) marked1 inhabitant = true) = (nth (Z.to_nat i) (elts arr2) inhabitant < 0%Z)) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed o8 -> ¬ nth (Z.to_nat (2%Z * i + 1%Z)) marked1 inhabitant = true -> nth (Z.to_nat i) (elts arr2) inhabitant = nth (Z.to_nat (2%Z * i + 1%Z)) nexts1 inhabitant) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed o8 -> nth (Z.to_nat (2%Z * i + 1%Z)) marked1 inhabitant = true -> nth (Z.to_nat i) (elts arr2) inhabitant = - nth (Z.to_nat (2%Z * i + 1%Z)) nexts1 inhabitant) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed o8 -> (i < ZEuclid.div (Z.abs (nth (Z.to_nat i) (elts arr2) inhabitant)) 2%Z ∧ ZEuclid.div (Z.abs (nth (Z.to_nat i) (elts arr2) inhabitant)) 2%Z ≤ bv_signed o8 + 1%Z) ∧ Z.abs (nth (Z.to_nat i) (elts arr2) inhabitant) ≤ bv_signed max1 + 1%Z) ∧ (∀(i : Z) (j : Z), 0%Z ≤ i ∧ i ≤ bv_signed o8 -> i < j ∧ j < ZEuclid.div (Z.abs (nth (Z.to_nat i) (elts arr2) inhabitant)) 2%Z -> nth (Z.to_nat j) (elts arr2) inhabitant < 0%Z)) ∧ (∀(result : t), nexts result = nexts1 ∧ marked result = marked1 ∧ arr result = arr2 ∧ max result = max1 ∧ max_arr result = o8 -> max result = max1 ∧ ((nth 0%nat (marked result) inhabitant = nth 1%nat (marked result) inhabitant ∧ nth 1%nat (marked result) inhabitant = true) ∧ ¬ nth 2%nat (marked result) inhabitant = true) ∧ (∀(i : Z), 1%Z ≤ i ∧ i ≤ ZEuclid.div (bv_signed max1 - 1%Z) 2%Z -> ¬ nth (Z.to_nat (2%Z * i + 1%Z)) (marked result) inhabitant = true) ∧ (∀(i : Z), 2%Z ≤ i ∧ i ≤ ZEuclid.div (bv_signed max1 + 1%Z) 2%Z -> 2%Z * i ≤ bv_signed max1 -> nth (Z.to_nat (2%Z * i)) (marked result) inhabitant = true) ∧ (∀(i : Z), 1%Z ≤ i ∧ i ≤ ZEuclid.div (bv_signed max1 - 1%Z) 2%Z -> 2%Z * i + 1%Z < bv_signed max1 - 1%Z -> nth (Z.to_nat (2%Z * i + 1%Z)) (nexts result) inhabitant = 2%Z * i + 3%Z) ∧ (∀(i : Z), 2%Z ≤ i ∧ i ≤ ZEuclid.div (bv_signed max1 - 1%Z) 2%Z -> 2%Z * i < bv_signed max1 - 1%Z -> nth (Z.to_nat (2%Z * i)) (nexts result) inhabitant = 2%Z * i + 1%Z) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed max1 -> nth (Z.to_nat i) (marked result) inhabitant = true -> i < 2%Z ∨ (2%Z | i)))))))) ∧ (bv_signed o6 + 1%Z < 1%Z -> int'63_in_bounds (bv_signed max1 - 1%Z) ∧ (∀(o7 : bv 63%N), bv_signed o7 = bv_signed max1 - 1%Z -> (¬ 2%Z = 0%Z ∧ int'63_in_bounds (Z.rem (bv_signed o7) 2%Z)) ∧ (∀(o8 : bv 63%N), bv_signed o8 = Z.rem (bv_signed o7) 2%Z -> ((bv_signed max1 < bv_signed int'63_max ∧ 3%Z ≤ bv_signed max1) ∧ (length nexts1 = length marked1 ∧ Z.of_nat (length marked1) = bv_signed max1 + 1%Z) ∧ ZEuclid.div (bv_signed max1 - 1%Z) 2%Z = bv_signed o8 ∧ Z.of_nat (length (elts arr1)) = bv_signed o8 + 1%Z ∧ inv_nexts nexts1 (Z.of_nat (length nexts1)) ∧ all_eliminated_marked marked1 nexts1 ∧ (∀(i : Z), 3%Z ≤ i ∧ i ≤ bv_signed max1 -> ZEuclid.modulo i 2%Z = 0%Z -> nth (Z.to_nat i) marked1 inhabitant = true) ∧ (∀(i : Z), 3%Z ≤ i ∧ i < bv_signed max1 - 1%Z -> ZEuclid.modulo i 2%Z = 1%Z -> ZEuclid.modulo (nth (Z.to_nat i) nexts1 inhabitant) 2%Z = 1%Z ∨ nth (Z.to_nat i) nexts1 inhabitant = bv_signed max1 + 1%Z) ∧ (nth (Z.to_nat (bv_signed max1)) nexts1 inhabitant = bv_signed max1 + 1%Z ∧ (ZEuclid.modulo (bv_signed max1 - 1%Z) 2%Z = 0%Z -> nth (Z.to_nat (bv_signed max1 - 1%Z)) nexts1 inhabitant = bv_signed max1) ∧ (ZEuclid.modulo (bv_signed max1 - 1%Z) 2%Z = 1%Z -> nth (Z.to_nat (bv_signed max1 - 1%Z)) nexts1 inhabitant = bv_signed max1 + 1%Z)) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed o8 -> - (bv_signed max1 + 1%Z) ≤ nth (Z.to_nat i) (elts arr1) inhabitant ∧ nth (Z.to_nat i) (elts arr1) inhabitant ≤ bv_signed max1 + 1%Z) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed o8 -> (nth (Z.to_nat (2%Z * i + 1%Z)) marked1 inhabitant = true) = (nth (Z.to_nat i) (elts arr1) inhabitant < 0%Z)) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed o8 -> ¬ nth (Z.to_nat (2%Z * i + 1%Z)) marked1 inhabitant = true -> nth (Z.to_nat i) (elts arr1) inhabitant = nth (Z.to_nat (2%Z * i + 1%Z)) nexts1 inhabitant) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed o8 -> nth (Z.to_nat (2%Z * i + 1%Z)) marked1 inhabitant = true -> nth (Z.to_nat i) (elts arr1) inhabitant = - nth (Z.to_nat (2%Z * i + 1%Z)) nexts1 inhabitant) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed o8 -> (i < ZEuclid.div (Z.abs (nth (Z.to_nat i) (elts arr1) inhabitant)) 2%Z ∧ ZEuclid.div (Z.abs (nth (Z.to_nat i) (elts arr1) inhabitant)) 2%Z ≤ bv_signed o8 + 1%Z) ∧ Z.abs (nth (Z.to_nat i) (elts arr1) inhabitant) ≤ bv_signed max1 + 1%Z) ∧ (∀(i : Z) (j : Z), 0%Z ≤ i ∧ i ≤ bv_signed o8 -> i < j ∧ j < ZEuclid.div (Z.abs (nth (Z.to_nat i) (elts arr1) inhabitant)) 2%Z -> nth (Z.to_nat j) (elts arr1) inhabitant < 0%Z)) ∧ (∀(result : t), nexts result = nexts1 ∧ marked result = marked1 ∧ arr result = arr1 ∧ max result = max1 ∧ max_arr result = o8 -> max result = max1 ∧ ((nth 0%nat (marked result) inhabitant = nth 1%nat (marked result) inhabitant ∧ nth 1%nat (marked result) inhabitant = true) ∧ ¬ nth 2%nat (marked result) inhabitant = true) ∧ (∀(i : Z), 1%Z ≤ i ∧ i ≤ ZEuclid.div (bv_signed max1 - 1%Z) 2%Z -> ¬ nth (Z.to_nat (2%Z * i + 1%Z)) (marked result) inhabitant = true) ∧ (∀(i : Z), 2%Z ≤ i ∧ i ≤ ZEuclid.div (bv_signed max1 + 1%Z) 2%Z -> 2%Z * i ≤ bv_signed max1 -> nth (Z.to_nat (2%Z * i)) (marked result) inhabitant = true) ∧ (∀(i : Z), 1%Z ≤ i ∧ i ≤ ZEuclid.div (bv_signed max1 - 1%Z) 2%Z -> 2%Z * i + 1%Z < bv_signed max1 - 1%Z -> nth (Z.to_nat (2%Z * i + 1%Z)) (nexts result) inhabitant = 2%Z * i + 3%Z) ∧ (∀(i : Z), 2%Z ≤ i ∧ i ≤ ZEuclid.div (bv_signed max1 - 1%Z) 2%Z -> 2%Z * i < bv_signed max1 - 1%Z -> nth (Z.to_nat (2%Z * i)) (nexts result) inhabitant = 2%Z * i + 1%Z) ∧ (∀(i : Z), 0%Z ≤ i ∧ i ≤ bv_signed max1 -> nth (Z.to_nat i) (marked result) inhabitant = true -> i < 2%Z ∨ (2%Z | i)))))))))))))))).
Admitted.
