import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace sieve_Sieve_sieveqtvc
noncomputable def no_factor_lt (bnd : ℤ) (num : ℤ) := (1 : ℤ) < num ∧ (∀(k : ℤ) (l : ℤ), ((1 : ℤ) < l ∧ l < bnd) ∧ (1 : ℤ) < k → ¬num = k * l)
theorem sieve'vc (n : ℤ) (fact0 : (1 : ℤ) < n) : (0 : ℤ) ≤ n ∧ (∀(t : List Bool), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → t[Int.toNat i]! = true) ∧ Int.ofNat (List.length t) = n → (let o1 : Bool := false; ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length t)) ∧ (List.length (List.set t (0 : ℕ) o1) = List.length t → getElem! (List.set t (0 : ℕ) o1) ∘ Int.toNat = Function.update (getElem! t ∘ Int.toNat) (0 : ℤ) o1 → (let o2 : Bool := false; ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < Int.ofNat (List.length (List.set t (0 : ℕ) o1))) ∧ (List.length (List.set (List.set t (0 : ℕ) o1) (1 : ℕ) o2) = List.length (List.set t (0 : ℕ) o1) → getElem! (List.set (List.set t (0 : ℕ) o1) (1 : ℕ) o2) ∘ Int.toNat = Function.update (getElem! (List.set t (0 : ℕ) o1) ∘ Int.toNat) (1 : ℤ) o2 → (((1 : ℤ) < (2 : ℤ) ∧ (2 : ℤ) ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < n → ((List.set (List.set t (0 : ℕ) o1) (1 : ℕ) o2)[Int.toNat j]! = true) = no_factor_lt (2 : ℤ) j)) ∧ (∀(i : ℤ) (t1 : List Bool), List.length t1 = List.length (List.set (List.set t (0 : ℕ) o1) (1 : ℕ) o2) → ((1 : ℤ) < i ∧ i ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < n → (t1[Int.toNat j]! = true) = no_factor_lt i j) → (if i < n then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length t1)) ∧ (if t1[Int.toNat i]! = true then (((1 : ℤ) < i ∧ i ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < n → (t1[Int.toNat j]! = true) = (no_factor_lt i j ∧ (∀(k : ℤ), (1 : ℤ) < k ∧ k < i → ¬j = k * i)))) ∧ (∀(r : ℤ) (t2 : List Bool), List.length t2 = List.length t1 → ((1 : ℤ) < r ∧ r ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < n → (t2[Int.toNat j]! = true) = (no_factor_lt i j ∧ (∀(k : ℤ), (1 : ℤ) < k ∧ k < r → ¬j = k * i))) → (if r * i < n then let o3 : Bool := false; ((0 : ℤ) ≤ r * i ∧ r * i < Int.ofNat (List.length t2)) ∧ (List.length (List.set t2 (Int.toNat (r * i)) o3) = List.length t2 → getElem! (List.set t2 (Int.toNat (r * i)) o3) ∘ Int.toNat = Function.update (getElem! t2 ∘ Int.toNat) (r * i) o3 → ((0 : ℤ) ≤ n - r ∧ n - (r + (1 : ℤ)) < n - r) ∧ (((1 : ℤ) < r + (1 : ℤ) ∧ r + (1 : ℤ) ≤ n) ∧ r * i + i = (r + (1 : ℤ)) * i) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < n → ((List.set t2 (Int.toNat (r * i)) o3)[Int.toNat j]! = true) = (no_factor_lt i j ∧ (∀(k : ℤ), (1 : ℤ) < k ∧ k < r + (1 : ℤ) → ¬j = k * i)))) else ((0 : ℤ) ≤ n - i ∧ n - (i + (1 : ℤ)) < n - i) ∧ ((1 : ℤ) < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < n → (t2[Int.toNat j]! = true) = no_factor_lt (i + (1 : ℤ)) j))) else ((0 : ℤ) ≤ n - i ∧ n - (i + (1 : ℤ)) < n - i) ∧ ((1 : ℤ) < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < n → (t1[Int.toNat j]! = true) = no_factor_lt (i + (1 : ℤ)) j)) else Int.ofNat (List.length t1) = n ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < n → (t1[Int.toNat i1]! = true) = Nat.Prime (Int.toNat i1)))))))))
  := sorry
end sieve_Sieve_sieveqtvc
