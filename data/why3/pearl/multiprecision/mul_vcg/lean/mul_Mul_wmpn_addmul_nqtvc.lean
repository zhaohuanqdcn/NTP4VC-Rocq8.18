import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.add.Add
open Classical
open Lean4Why3
namespace mul_Mul_wmpn_addmul_nqtvc
theorem wmpn_addmul_n'vc (sz : BitVec 32) (x : C.ptr (BitVec 64)) (y : C.ptr (BitVec 64)) (r : C.ptr (BitVec 64)) (fact0 : (0 : ℤ) < BitVec.toInt sz) (fact1 : C.valid x (BitVec.toInt sz)) (fact2 : C.valid y (BitVec.toInt sz)) (fact3 : C.valid r (BitVec.toInt sz + BitVec.toInt sz)) (fact4 : C.writable r = true) : C.min r ≤ C.offset r + (0 : ℤ) ∧ C.offset r + (0 : ℤ) ≤ C.max r ∧ (∀(o1 : C.ptr (BitVec 64)), C.offset o1 = C.offset r + (0 : ℤ) ∧ C.plength o1 = C.plength r ∧ C.pelts o1 = C.pelts r ∧ C.data o1 = C.data r ∧ C.min o1 = C.min r ∧ C.max o1 = C.max r ∧ C.zone1 o1 = C.zone1 r ∧ C.writable o1 = C.writable r → (C.min y ≤ C.offset y + (0 : ℤ) ∧ C.offset y + (0 : ℤ) ≤ C.max y) ∧ (∀(o2 : C.ptr (BitVec 64)), C.offset o2 = C.offset y + (0 : ℤ) ∧ C.plength o2 = C.plength y ∧ C.pelts o2 = C.pelts y ∧ C.data o2 = C.data y ∧ C.min o2 = C.min y ∧ C.max o2 = C.max y ∧ C.zone1 o2 = C.zone1 y ∧ C.writable o2 = C.writable y → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt sz) ∧ (0 : ℤ) = BitVec.toInt sz - BitVec.toInt sz ∧ Lemmas.value r ((0 : ℤ) + BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat ((0 : ℤ) + BitVec.toInt sz)) * (0 : ℤ) = Lemmas.value r ((0 : ℤ) + BitVec.toInt sz) + Lemmas.value x (BitVec.toInt sz) * Lemmas.value y (0 : ℤ) ∧ C.offset o1 = C.offset r + (0 : ℤ) ∧ C.min o1 = C.min r ∧ C.max o1 = C.max r ∧ C.writable o1 = true ∧ C.pelts o1 = C.pelts r ∧ C.plength o1 = C.plength r ∧ C.offset o2 = C.offset y + (0 : ℤ) ∧ C.plength o2 = C.plength y ∧ C.min o2 = C.min y ∧ C.max o2 = C.max y ∧ C.pelts o2 = C.pelts y ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (1 : ℤ)) ∧ (∀(i : BitVec 32) (vn : BitVec 32) (c : BitVec 64) (vp : C.ptr (BitVec 64)) (rp : C.ptr (BitVec 64)) (r1 : C.ptr (BitVec 64)), List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sz) ∧ BitVec.toInt i = BitVec.toInt sz - BitVec.toInt vn ∧ Lemmas.value r1 (BitVec.toInt i + BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i + BitVec.toInt sz)) * BitVec.toUInt c = Lemmas.value r (BitVec.toInt i + BitVec.toInt sz) + Lemmas.value x (BitVec.toInt sz) * Lemmas.value y (BitVec.toInt i) ∧ C.offset rp = C.offset r1 + BitVec.toInt i ∧ C.min rp = C.min r1 ∧ C.max rp = C.max r1 ∧ C.writable rp = true ∧ C.pelts rp = C.pelts r1 ∧ C.plength rp = C.plength r1 ∧ C.offset vp = C.offset y + BitVec.toInt i ∧ C.plength vp = C.plength y ∧ C.min vp = C.min y ∧ C.max vp = C.max y ∧ C.pelts vp = C.pelts y ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (∀(j : ℤ), C.offset rp + BitVec.toInt sz ≤ j → C.pelts r j = C.pelts r1 j) → (∀(o3 : Bool), (BitVec.toInt vn = BitVec.toInt (0 : BitVec 32) → o3 = true) ∧ (o3 = true → vn = (0 : BitVec 32)) → (if ¬o3 = true then (C.min vp ≤ C.offset vp ∧ C.offset vp < C.max vp) ∧ (C.valid x (BitVec.toInt sz) ∧ C.valid rp (BitVec.toInt sz) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)) (r2 : C.ptr (BitVec 64)), C.data rp1 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → C.data rp1 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → List.length (C.data r2) = List.length (C.data r1) ∧ C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.max r2 = C.max r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → (∀(c' : BitVec 64), Lemmas.value rp1 (BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz)) * BitVec.toUInt c' = Lemmas.value rp (BitVec.toInt sz) + Lemmas.value x (BitVec.toInt sz) * BitVec.toUInt (C.pelts vp (C.offset vp)) ∧ (∀(j : ℤ), j < C.offset rp1 ∨ C.offset rp1 + BitVec.toInt sz ≤ j → C.pelts rp1 j = C.pelts rp j) → (C.min rp1 ≤ C.offset rp1 + BitVec.toInt sz ∧ C.offset rp1 + BitVec.toInt sz < C.max rp1) ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (∀(res : BitVec 64) (carry : BitVec 64), BitVec.toUInt res + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt carry = BitVec.toUInt c' + BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt sz)) + BitVec.toUInt c ∧ (0 : ℤ) ≤ BitVec.toUInt carry ∧ BitVec.toUInt carry ≤ (1 : ℤ) → ((C.min rp1 ≤ C.offset rp1 + BitVec.toInt sz ∧ C.offset rp1 + BitVec.toInt sz < C.max rp1) ∧ C.writable rp1 = true) ∧ (∀(rp2 : C.ptr (BitVec 64)) (r3 : C.ptr (BitVec 64)), C.data rp2 = C.data r3 ∧ List.length (C.data r3) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → C.data rp2 = C.data r3 ∧ List.length (C.data r3) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → List.length (C.data r3) = List.length (C.data r2) ∧ C.offset r3 = C.offset r2 ∧ C.min r3 = C.min r2 ∧ C.max r3 = C.max r2 ∧ C.writable r3 = C.writable r2 ∧ C.zone1 r3 = C.zone1 r2 → C.pelts rp2 = Function.update (C.pelts rp1) (C.offset rp2 + BitVec.toInt sz) res ∧ C.pelts rp2 (C.offset rp2 + BitVec.toInt sz) = res → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt i + (1 : ℤ) → (C.min rp2 ≤ C.offset rp2 + (1 : ℤ) ∧ C.offset rp2 + (1 : ℤ) ≤ C.max rp2) ∧ (∀(o5 : C.ptr (BitVec 64)), C.offset o5 = C.offset rp2 + (1 : ℤ) ∧ C.plength o5 = C.plength rp2 ∧ C.pelts o5 = C.pelts rp2 ∧ C.data o5 = C.data rp2 ∧ C.min o5 = C.min rp2 ∧ C.max o5 = C.max rp2 ∧ C.zone1 o5 = C.zone1 rp2 ∧ C.writable o5 = C.writable rp2 → (C.min vp ≤ C.offset vp + (1 : ℤ) ∧ C.offset vp + (1 : ℤ) ≤ C.max vp) ∧ (∀(o6 : C.ptr (BitVec 64)), C.offset o6 = C.offset vp + (1 : ℤ) ∧ C.plength o6 = C.plength vp ∧ C.pelts o6 = C.pelts vp ∧ C.data o6 = C.data vp ∧ C.min o6 = C.min vp ∧ C.max o6 = C.max vp ∧ C.zone1 o6 = C.zone1 vp ∧ C.writable o6 = C.writable vp → int'32_in_bounds (BitVec.toInt vn - (1 : ℤ)) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt vn - (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt sz - BitVec.toInt i ∧ BitVec.toInt sz - BitVec.toInt o4 < BitVec.toInt sz - BitVec.toInt i) ∧ ((0 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ BitVec.toInt sz) ∧ BitVec.toInt o4 = BitVec.toInt sz - BitVec.toInt o7 ∧ Lemmas.value r3 (BitVec.toInt o4 + BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o4 + BitVec.toInt sz)) * BitVec.toUInt carry = Lemmas.value r (BitVec.toInt o4 + BitVec.toInt sz) + Lemmas.value x (BitVec.toInt sz) * Lemmas.value y (BitVec.toInt o4) ∧ C.offset o5 = C.offset r3 + BitVec.toInt o4 ∧ C.min o5 = C.min r3 ∧ C.max o5 = C.max r3 ∧ C.writable o5 = true ∧ C.pelts o5 = C.pelts r3 ∧ C.plength o5 = C.plength r3 ∧ C.offset o6 = C.offset y + BitVec.toInt o4 ∧ C.plength o6 = C.plength y ∧ C.min o6 = C.min y ∧ C.max o6 = C.max y ∧ C.pelts o6 = C.pelts y ∧ ((0 : ℤ) ≤ BitVec.toUInt carry ∧ BitVec.toUInt carry ≤ (1 : ℤ)) ∧ (∀(j : ℤ), C.offset o5 + BitVec.toInt sz ≤ j → C.pelts r j = C.pelts r3 j))))))))) else Lemmas.value r1 (BitVec.toInt sz + BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz + BitVec.toInt sz)) * BitVec.toUInt c = Lemmas.value r (BitVec.toInt sz + BitVec.toInt sz) + Lemmas.value x (BitVec.toInt sz) * Lemmas.value y (BitVec.toInt sz))))))
  := sorry
end mul_Mul_wmpn_addmul_nqtvc
