import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Sum
open Classical
open Lean4Why3
namespace maximum_subarray_Algo5_maximum_subarrayqtvc
theorem maximum_subarray'vc (a : List ℤ) : let o1 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → ((∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ (0 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take ((0 : ℕ) - Int.toNat l) a)) ≤ (0 : ℤ)) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ List.sum (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a)) = (0 : ℤ)) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ (0 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a)) ≤ (0 : ℤ)) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ List.sum (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a)) = (0 : ℤ)) ∧ (∀(cl : ℤ) (hi : ℤ) (lo : ℤ) (curmax : ℤ) (maxsum : ℤ), (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat i - Int.toNat l) a)) ≤ curmax) ∧ (((0 : ℤ) ≤ cl ∧ cl ≤ i) ∧ List.sum (List.drop (Int.toNat cl) (List.take (Int.toNat i - Int.toNat cl) a)) = curmax) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a)) ≤ maxsum) ∧ ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ i) ∧ List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a)) = maxsum → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if curmax + a[Int.toNat i]! < (0 : ℤ) then if maxsum < (0 : ℤ) then (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat l) a)) ≤ (0 : ℤ)) ∧ (((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ List.sum (List.drop (Int.toNat (i + (1 : ℤ))) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat (i + (1 : ℤ))) a)) = (0 : ℤ)) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a)) ≤ (0 : ℤ)) ∧ ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ List.sum (List.drop (Int.toNat (i + (1 : ℤ))) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat (i + (1 : ℤ))) a)) = (0 : ℤ) else (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat l) a)) ≤ (0 : ℤ)) ∧ (((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ List.sum (List.drop (Int.toNat (i + (1 : ℤ))) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat (i + (1 : ℤ))) a)) = (0 : ℤ)) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a)) ≤ maxsum) ∧ ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ i + (1 : ℤ)) ∧ List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a)) = maxsum else if maxsum < curmax + a[Int.toNat i]! then (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat l) a)) ≤ curmax + a[Int.toNat i]!) ∧ (((0 : ℤ) ≤ cl ∧ cl ≤ i + (1 : ℤ)) ∧ List.sum (List.drop (Int.toNat cl) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat cl) a)) = curmax + a[Int.toNat i]!) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a)) ≤ curmax + a[Int.toNat i]!) ∧ ((0 : ℤ) ≤ cl ∧ cl ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ List.sum (List.drop (Int.toNat cl) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat cl) a)) = curmax + a[Int.toNat i]! else (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat l) a)) ≤ curmax + a[Int.toNat i]!) ∧ (((0 : ℤ) ≤ cl ∧ cl ≤ i + (1 : ℤ)) ∧ List.sum (List.drop (Int.toNat cl) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat cl) a)) = curmax + a[Int.toNat i]!) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a)) ≤ maxsum) ∧ ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ i + (1 : ℤ)) ∧ List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a)) = maxsum)) ∧ ((∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ o1 + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (o1 + (1 : ℤ)) - Int.toNat l) a)) ≤ curmax) ∧ (((0 : ℤ) ≤ cl ∧ cl ≤ o1 + (1 : ℤ)) ∧ List.sum (List.drop (Int.toNat cl) (List.take (Int.toNat (o1 + (1 : ℤ)) - Int.toNat cl) a)) = curmax) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ o1 + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a)) ≤ maxsum) ∧ ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ o1 + (1 : ℤ)) ∧ List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a)) = maxsum → (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ Int.ofNat (List.length a) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a)) ≤ maxsum) ∧ (∃(l : ℤ) (h : ℤ), ((0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ Int.ofNat (List.length a)) ∧ List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a)) = maxsum)))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ Int.ofNat (List.length a) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a)) ≤ (0 : ℤ)) ∧ (∃(l : ℤ) (h : ℤ), ((0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ Int.ofNat (List.length a)) ∧ List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a)) = (0 : ℤ)))
  := sorry
end maximum_subarray_Algo5_maximum_subarrayqtvc
