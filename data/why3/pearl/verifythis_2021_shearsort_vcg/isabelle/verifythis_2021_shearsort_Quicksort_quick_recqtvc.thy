theory verifythis_2021_shearsort_Quicksort_quick_recqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut" "Why3STD.array_IntArraySorted"
begin
definition qs_partition :: "int list \<Rightarrow> int list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "qs_partition a1 a2 l m r v \<longleftrightarrow> permut_sub' a1 a2 (nat l) (nat r) \<and> (\<forall>(j :: int). l \<le> j \<and> j < m \<longrightarrow> a2 ! nat j < v) \<and> (\<forall>(j :: int). m < j \<and> j < r \<longrightarrow> v \<le> a2 ! nat j) \<and> a2 ! nat m = v" for a1 a2 l m r v
theorem quick_rec'vc:
  fixes l :: "int"
  fixes r :: "int"
  fixes a :: "int list"
  assumes fact0: "(0 :: int) \<le> l"
  assumes fact1: "l \<le> r"
  assumes fact2: "r \<le> int (length a)"
  shows "if l + (1 :: int) < r then ((0 :: int) \<le> l \<and> l < int (length a)) \<and> (let v :: int = a ! nat l; o1 :: int = r - (1 :: int); o2 :: int = l + (1 :: int) in (o2 \<le> o1 + (1 :: int) \<longrightarrow> ((a ! nat l = v \<and> l \<le> l \<and> l < o2) \<and> (\<forall>(j :: int). l < j \<and> j \<le> l \<longrightarrow> a ! nat j < v) \<and> (\<forall>(j :: int). l < j \<and> j < o2 \<longrightarrow> v \<le> a ! nat j) \<and> permut_sub' a a (nat l) (nat r)) \<and> (\<forall>(m :: int) (a1 :: int list). length a1 = length a \<longrightarrow> (\<forall>(i :: int). (o2 \<le> i \<and> i \<le> o1) \<and> (a1 ! nat l = v \<and> l \<le> m \<and> m < i) \<and> (\<forall>(j :: int). l < j \<and> j \<le> m \<longrightarrow> a1 ! nat j < v) \<and> (\<forall>(j :: int). m < j \<and> j < i \<longrightarrow> v \<le> a1 ! nat j) \<and> permut_sub' a a1 (nat l) (nat r) \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a1)) \<and> (if a1 ! nat i < v then (((0 :: int) \<le> i \<and> i < int (length a1)) \<and> (0 :: int) \<le> m + (1 :: int) \<and> m + (1 :: int) < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 i (m + (1 :: int)) \<longrightarrow> (a2 ! nat l = v \<and> l \<le> m + (1 :: int) \<and> m + (1 :: int) < i + (1 :: int)) \<and> (\<forall>(j :: int). l < j \<and> j \<le> m + (1 :: int) \<longrightarrow> a2 ! nat j < v) \<and> (\<forall>(j :: int). m + (1 :: int) < j \<and> j < i + (1 :: int) \<longrightarrow> v \<le> a2 ! nat j) \<and> permut_sub' a a2 (nat l) (nat r)) else (a1 ! nat l = v \<and> l \<le> m \<and> m < i + (1 :: int)) \<and> (\<forall>(j :: int). l < j \<and> j \<le> m \<longrightarrow> a1 ! nat j < v) \<and> (\<forall>(j :: int). m < j \<and> j < i + (1 :: int) \<longrightarrow> v \<le> a1 ! nat j) \<and> permut_sub' a a1 (nat l) (nat r))) \<and> ((a1 ! nat l = v \<and> l \<le> m \<and> m < o1 + (1 :: int)) \<and> (\<forall>(j :: int). l < j \<and> j \<le> m \<longrightarrow> a1 ! nat j < v) \<and> (\<forall>(j :: int). m < j \<and> j < o1 + (1 :: int) \<longrightarrow> v \<le> a1 ! nat j) \<and> permut_sub' a a1 (nat l) (nat r) \<longrightarrow> (((0 :: int) \<le> l \<and> l < int (length a1)) \<and> (0 :: int) \<le> m \<and> m < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 l m \<longrightarrow> (((0 :: int) \<le> r - l \<and> m - l < r - l) \<and> (0 :: int) \<le> l \<and> l \<le> m \<and> m \<le> int (length a2)) \<and> (\<forall>(a3 :: int list). length a3 = length a2 \<longrightarrow> sorted_sub1 a3 l m \<and> permut_sub' a2 a3 (nat l) (nat m) \<longrightarrow> (let o3 :: int = m + (1 :: int) in (((0 :: int) \<le> r - l \<and> r - o3 < r - l) \<and> (0 :: int) \<le> o3 \<and> o3 \<le> r \<and> r \<le> int (length a3)) \<and> (\<forall>(a4 :: int list). length a4 = length a3 \<longrightarrow> sorted_sub1 a4 o3 r \<and> permut_sub' a3 a4 (nat o3) (nat r) \<longrightarrow> sorted_sub1 a4 l r \<and> permut_sub' a a4 (nat l) (nat r)))))))) \<and> (o1 + (1 :: int) < o2 \<longrightarrow> ((0 :: int) \<le> l \<and> l < int (length a)) \<and> (\<forall>(a1 :: int list). length a1 = length a \<longrightarrow> list_exchange a a1 l l \<longrightarrow> (((0 :: int) \<le> r - l \<and> l - l < r - l) \<and> (0 :: int) \<le> l \<and> l \<le> l \<and> l \<le> int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> sorted_sub1 a2 l l \<and> permut_sub' a1 a2 (nat l) (nat l) \<longrightarrow> (let o3 :: int = l + (1 :: int) in (((0 :: int) \<le> r - l \<and> r - o3 < r - l) \<and> (0 :: int) \<le> o3 \<and> o3 \<le> r \<and> r \<le> int (length a2)) \<and> (\<forall>(a3 :: int list). length a3 = length a2 \<longrightarrow> sorted_sub1 a3 o3 r \<and> permut_sub' a2 a3 (nat o3) (nat r) \<longrightarrow> sorted_sub1 a3 l r \<and> permut_sub' a a3 (nat l) (nat r))))))) else sorted_sub1 a l r \<and> permut_sub' a a (nat l) (nat r)"
  sorry
end
