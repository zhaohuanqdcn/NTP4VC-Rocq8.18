theory mpz_cmpabs_Zcmpabs_wmpz_cmpabs_uiqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/mpz_Z" "../../lib/isabelle/mpz_Zutil"
begin
theorem wmpz_cmpabs_ui'vc:
  fixes mpz :: "mpz_memo"
  fixes u :: "mpz_ptr"
  fixes v_digit :: "64 word"
  assumes fact0: "(0 :: int) \<le> readers mpz u"
  shows "-(2 :: int) < readers mpz u"
  and "\<forall>(un :: 32 word). sint un = sgn mpz u * abs_size mpz u \<longrightarrow> (\<forall>(o1 :: bool). (sint un = sint (0 :: 32 word) \<longrightarrow> o1 = True) \<and> (o1 = True \<longrightarrow> un = (0 :: 32 word)) \<longrightarrow> (if o1 = True then \<forall>(o2 :: bool). (uint v_digit = uint (0 :: 64 word) \<longrightarrow> o2 = True) \<and> (o2 = True \<longrightarrow> v_digit = (0 :: 64 word)) \<longrightarrow> (\<forall>(r :: 32 word). (if \<not>o2 = True then r = Groups.uminus_class.uminus (1 :: 32 word) else r = (0 :: 32 word)) \<longrightarrow> (\<forall>(w :: mpz_ptr). mpz_unchanged w mpz mpz) \<and> ((0 :: int) < sint r \<longrightarrow> uint v_digit < abs (value_of u mpz)) \<and> (sint r < (0 :: int) \<longrightarrow> abs (value_of u mpz) < uint v_digit) \<and> (sint r = (0 :: int) \<longrightarrow> abs (value_of u mpz) = uint v_digit)) else -(2147483648 :: int) < sint un \<and> (\<forall>(o2 :: 32 word). sint o2 = abs (sint un) \<longrightarrow> (\<forall>(o3 :: bool). (sint o2 = sint (1 :: 32 word) \<longrightarrow> o3 = True) \<and> (o3 = True \<longrightarrow> o2 = (1 :: 32 word)) \<longrightarrow> (if o3 = True then (0 :: int) \<le> readers mpz u \<and> (\<forall>(mpz1 :: mpz_memo). abs_value_of mpz1 = abs_value_of mpz \<and> alloc mpz1 = alloc mpz \<and> abs_size mpz1 = abs_size mpz \<and> sgn mpz1 = sgn mpz \<and> zones mpz1 = zones mpz \<longrightarrow> (\<forall>(up :: 64 word ptr). readers mpz1 u = readers mpz u + (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>u = y \<longrightarrow> readers mpz1 y = readers mpz y) \<and> value up (abs_size mpz1 u) = abs_value_of mpz1 u \<and> plength up = alloc mpz1 u \<and> offset up = (0 :: int) \<and> c_C.min up = (0 :: int) \<and> c_C.max up = plength up \<and> zone1 up = zones mpz1 u \<longrightarrow> (c_C.min up \<le> offset up \<and> offset up < c_C.max up) \<and> (let ul :: 64 word = pelts up (offset up) in (zones mpz1 u = zone1 up \<and> (1 :: int) \<le> readers mpz1 u \<and> c_C.min up = (0 :: int) \<and> c_C.max up = plength up) \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> readers mpz2 u = readers mpz1 u - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = u \<longrightarrow> readers mpz2 y = readers mpz1 y) \<longrightarrow> (if uint v_digit < uint ul then (\<forall>(w :: mpz_ptr). mpz_unchanged w mpz2 mpz) \<and> ((0 :: int) < (1 :: int) \<longrightarrow> uint v_digit < abs (value_of u mpz2)) \<and> ((1 :: int) < (0 :: int) \<longrightarrow> abs (value_of u mpz2) < uint v_digit) \<and> ((1 :: int) = (0 :: int) \<longrightarrow> abs (value_of u mpz2) = uint v_digit) else if uint ul < uint v_digit then (\<forall>(w :: mpz_ptr). mpz_unchanged w mpz2 mpz) \<and> ((0 :: int) < -(1 :: int) \<longrightarrow> uint v_digit < abs (value_of u mpz2)) \<and> (-(1 :: int) < (0 :: int) \<longrightarrow> abs (value_of u mpz2) < uint v_digit) \<and> (-(1 :: int) = (0 :: int) \<longrightarrow> abs (value_of u mpz2) = uint v_digit) else (\<forall>(w :: mpz_ptr). mpz_unchanged w mpz2 mpz) \<and> ((0 :: int) < (0 :: int) \<longrightarrow> uint v_digit < abs (value_of u mpz2)) \<and> ((0 :: int) < (0 :: int) \<longrightarrow> abs (value_of u mpz2) < uint v_digit) \<and> abs (value_of u mpz2) = uint v_digit))))) else (\<forall>(w :: mpz_ptr). mpz_unchanged w mpz mpz) \<and> ((0 :: int) < (1 :: int) \<longrightarrow> uint v_digit < abs (value_of u mpz)) \<and> ((1 :: int) < (0 :: int) \<longrightarrow> abs (value_of u mpz) < uint v_digit) \<and> ((1 :: int) = (0 :: int) \<longrightarrow> abs (value_of u mpz) = uint v_digit))))))"
  sorry
end
