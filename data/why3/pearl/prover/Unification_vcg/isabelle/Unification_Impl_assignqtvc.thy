theory Unification_Impl_assignqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "../../lib/isabelle/Unification_Types" "../../lib/isabelle/Functions_Config" "../../lib/isabelle/Functions_Func" "../../lib/isabelle/BacktrackArray_Types" "../../lib/isabelle/Predicates_Pred" "../../lib/isabelle/BacktrackArray_Logic" "../../lib/isabelle/Choice_Choice" "../../lib/isabelle/BacktrackArray_Impl" "../../lib/isabelle/Firstorder_symbol_spec_Spec" "../../lib/isabelle/Nat_Nat" "../../lib/isabelle/OptionFuncs_Funcs" "../../lib/isabelle/Sum_Sum" "../../lib/isabelle/Firstorder_symbol_impl_Types" "../../lib/isabelle/Firstorder_symbol_impl_Logic" "../../lib/isabelle/Firstorder_symbol_impl_Impl" "../../lib/isabelle/Firstorder_term_spec_Spec" "../../lib/isabelle/Firstorder_term_impl_Types" "../../lib/isabelle/Firstorder_term_impl_Logic" "../../lib/isabelle/Firstorder_term_impl_Impl" "../../lib/isabelle/Unification_Logic"
begin
theorem assign'vc:
  fixes z :: "int"
  fixes t :: "nlimpl_fo_term"
  fixes rhob :: "sdata t"
  fixes rho :: "unifier_subst"
  fixes lv :: "int list"
  fixes lp :: "int \<Rightarrow> bool"
  assumes fact0: "(0 :: int) \<le> z"
  assumes fact1: "nlimpl_fo_term_ok t"
  assumes fact2: "unifier_subst_ok rhob rho"
  assumes fact3: "unassigned (current_timestamp rhob) z"
  assumes fact4: "\<not>subst_fo_term (model_fo_term_field t) subst_id_symbol (unifier rho) = Var_fo_term z"
  assumes fact5: "\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field t) \<longrightarrow> (0 :: int) \<le> y"
  assumes fact6: "\<forall>(x :: int). x \<in> set lv \<longrightarrow> lp x = True \<and> (0 :: int) \<le> x"
  assumes fact7: "\<forall>(x :: int). unassigned (current_timestamp rhob) x \<longrightarrow> lp x = True"
  shows "let tm :: (int, int) fo_term = model_fo_term_field t; rhoi :: int \<Rightarrow> (int, int) fo_term = unifier rho in (unifier_subst_ok rhob rho \<and> unassigned (current_timestamp rhob) z) \<and> ((let tm1 :: (int, int) fo_term = Var_fo_term z in tm1 = subst_fo_term tm1 subst_id_symbol (unifier_base_model rho) \<and> tm1 = subst_fo_term tm1 subst_id_symbol (unifier rho)) \<longrightarrow> (unifier_subst_ok rhob rho \<and> nlimpl_fo_term_ok t \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term y (model_fo_term_field t) \<longrightarrow> (0 :: int) \<le> y)) \<and> (\<not>is_fo_term_free_var_in_fo_term z (subst_fo_term (model_fo_term_field t) subst_id_symbol (unifier rho)) \<longrightarrow> (let uf :: int \<Rightarrow> (int, int) fo_term = update (subst_id_fo_term :: int \<Rightarrow> (int, int) fo_term) z (subst_fo_term tm subst_id_symbol rhoi); rhoi' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term rhoi subst_id_symbol uf; o1 :: sdata = Assign t in (correct rhob \<and> (0 :: int) \<le> z \<and> inv rhob o1 = True) \<and> (\<forall>(rhob1 :: sdata t). inv rhob1 = inv rhob \<longrightarrow> past_time (current_timestamp rhob1) rhob1 \<and> correct rhob1 \<and> precede rhob rhob1 \<and> (let tb0 :: int \<Rightarrow> sdata list = table (current_timestamp rhob) in table (current_timestamp rhob1) = update tb0 z (Cons o1 (tb0 z))) \<longrightarrow> (\<forall>(x :: int). x \<in> set (Cons z lv) \<longrightarrow> lp x = True \<and> (0 :: int) \<le> x) \<and> (\<forall>(x :: int). unassigned (current_timestamp rhob1) x \<longrightarrow> lp x = True) \<and> unifier_subst_ok rhob1 (unifier_subst'mk (update (unifier_base_model rho) z tm) rhoi') \<and> precede rhob rhob1 \<and> subst_compose_fo_term (unifier rho) subst_id_symbol uf = rhoi' \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in s' z = subst_fo_term (model_fo_term_field t) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term rhoi' subst_id_symbol s) \<and> rhoi' z = subst_fo_term (model_fo_term_field t) subst_id_symbol rhoi' \<and> (let s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term rhoi' subst_id_symbol s1 = rhoi' \<and> rhoi' = subst_compose_fo_term s1 subst_id_symbol rhoi') \<and> (let s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term rhoi' subst_id_symbol s1 = rhoi' \<and> rhoi' = subst_compose_fo_term s1 subst_id_symbol rhoi')))) \<and> precede rhob rhob \<and> correct rhob)"
  sorry
end
