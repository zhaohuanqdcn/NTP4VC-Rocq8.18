import Why3.Base
import Why3.bintree.Tree
import Why3.bintree.Size
import Why3.bintree.Height
open Classical
open Lean4Why3
namespace tree_height_HeightSmallSpace_height_limitedqtvc
noncomputable def leaves {α : Type} [Inhabited α] (t : Tree.tree α) := (1 : ℤ) + Size.size t
theorem height_limited'vc {α : Type} [Inhabited α] (lim : ℤ) (acc : ℤ) (t : Tree.tree α) (s : Option (ℤ × ℤ × Tree.tree α)) (depth : ℤ) (fact0 : (0 : ℤ) < lim) (fact1 : (0 : ℤ) ≤ acc) : (match t with | (Tree.tree.Empty : Tree.tree α) => True | Tree.tree.Node l _ r => (∀(limc : ℤ), (0 : ℤ) ≤ limc ∧ limc < lim → (¬limc = (0 : ℤ) → ¬(2 : ℤ) = (0 : ℤ) ∧ (let o1 : ℤ := Int.tdiv limc (2 : ℤ); (((0 : ℤ) ≤ limc ∧ o1 < limc) ∧ (0 : ℤ) ≤ o1 ∧ o1 < lim) ∧ (∀(o2 : Option (ℤ × ℤ × Tree.tree α)), (match o2 with | (Option.none : Option (ℤ × ℤ × Tree.tree α)) => o1 < leaves l ∧ o1 < leaves r | Option.some (h, sz, rm) => Height.height t = (1 : ℤ) + max h (Height.height rm) ∧ leaves t = leaves rm + sz ∧ (0 : ℤ) < sz ∧ sz ≤ o1) → (match o2 with | s@(Option.some _) => True | (Option.none : Option (ℤ × ℤ × Tree.tree α)) => (((0 : ℤ) ≤ lim ∧ limc < lim) ∧ (0 : ℤ) < limc ∧ (0 : ℤ) ≤ (0 : ℤ)) ∧ (∀(o3 : Option (ℤ × ℤ)), (match o3 with | Option.none => limc < leaves l | Option.some (res, dl) => res = max (0 : ℤ) ((0 : ℤ) + Height.height l) ∧ limc = leaves l + dl ∧ (0 : ℤ) ≤ dl) → (match o3 with | Option.some (h, dl) => True | Option.none => (((0 : ℤ) ≤ lim ∧ limc < lim) ∧ (0 : ℤ) < limc ∧ (0 : ℤ) ≤ (0 : ℤ)) ∧ (∀(o4 : Option (ℤ × ℤ)), (match o4 with | Option.none => limc < leaves r | Option.some (res, dl) => res = max (0 : ℤ) ((0 : ℤ) + Height.height r) ∧ limc = leaves r + dl ∧ (0 : ℤ) ≤ dl) → (match o4 with | Option.some (h, dl) => True | Option.none => True)))))))) ∧ (∀(result : Option (ℤ × ℤ × Tree.tree α)), (if limc = (0 : ℤ) then result = (Option.none : Option (ℤ × ℤ × Tree.tree α)) else let o1 : ℤ := Int.tdiv limc (2 : ℤ); ∃(o2 : Option (ℤ × ℤ × Tree.tree α)), (match o2 with | (Option.none : Option (ℤ × ℤ × Tree.tree α)) => o1 < leaves l ∧ o1 < leaves r | Option.some (h, sz, rm) => Height.height t = (1 : ℤ) + max h (Height.height rm) ∧ leaves t = leaves rm + sz ∧ (0 : ℤ) < sz ∧ sz ≤ o1) ∧ (match o2 with | s@(Option.some _) => result = s | (Option.none : Option (ℤ × ℤ × Tree.tree α)) => (∃(o3 : Option (ℤ × ℤ)), (match o3 with | Option.none => limc < leaves l | Option.some (res, dl) => res = max (0 : ℤ) ((0 : ℤ) + Height.height l) ∧ limc = leaves l + dl ∧ (0 : ℤ) ≤ dl) ∧ (match o3 with | Option.some (h, dl) => result = Option.some (h, limc - dl, r) | Option.none => (∃(o4 : Option (ℤ × ℤ)), (match o4 with | Option.none => limc < leaves r | Option.some (res, dl) => res = max (0 : ℤ) ((0 : ℤ) + Height.height r) ∧ limc = leaves r + dl ∧ (0 : ℤ) ≤ dl) ∧ (match o4 with | Option.some (h, dl) => result = Option.some (h, limc - dl, l) | Option.none => result = (Option.none : Option (ℤ × ℤ × Tree.tree α)))))))) → (match result with | (Option.none : Option (ℤ × ℤ × Tree.tree α)) => limc < leaves l ∧ limc < leaves r | Option.some (h, sz, rm) => Height.height t = (1 : ℤ) + max h (Height.height rm) ∧ leaves t = leaves rm + sz ∧ (0 : ℤ) < sz ∧ sz ≤ limc))) ∧ ¬(2 : ℤ) = (0 : ℤ) ∧ (let limc : ℤ := Int.tdiv lim (2 : ℤ); ((0 : ℤ) ≤ limc ∧ limc < lim) ∧ (∀(o1 : Option (ℤ × ℤ × Tree.tree α)), (match o1 with | (Option.none : Option (ℤ × ℤ × Tree.tree α)) => limc < leaves l ∧ limc < leaves r | Option.some (h, sz, rm) => Height.height t = (1 : ℤ) + max h (Height.height rm) ∧ leaves t = leaves rm + sz ∧ (0 : ℤ) < sz ∧ sz ≤ limc) → (match o1 with | (Option.none : Option (ℤ × ℤ × Tree.tree α)) => True | Option.some (h, sz, rm) => (let o2 : ℤ := lim - sz; ((0 : ℤ) ≤ lim ∧ o2 < lim) ∧ (0 : ℤ) < o2 ∧ (0 : ℤ) ≤ max acc (depth + h + (1 : ℤ))))))) ∧ (∀(result : Option (ℤ × ℤ)), (match t with | (Tree.tree.Empty : Tree.tree α) => result = Option.some (max acc depth, lim - (1 : ℤ)) | Tree.tree.Node l _ r => (let limc : ℤ := Int.tdiv lim (2 : ℤ); ∃(o1 : Option (ℤ × ℤ × Tree.tree α)), (match o1 with | (Option.none : Option (ℤ × ℤ × Tree.tree α)) => limc < leaves l ∧ limc < leaves r | Option.some (h, sz, rm) => Height.height t = (1 : ℤ) + max h (Height.height rm) ∧ leaves t = leaves rm + sz ∧ (0 : ℤ) < sz ∧ sz ≤ limc) ∧ (match o1 with | (Option.none : Option (ℤ × ℤ × Tree.tree α)) => result = Option.none | Option.some (h, sz, rm) => (let o2 : ℤ := lim - sz; match result with | Option.none => o2 < leaves rm | Option.some (res, dl) => res = max (max acc (depth + h + (1 : ℤ))) (depth + (1 : ℤ) + Height.height rm) ∧ o2 = leaves rm + dl ∧ (0 : ℤ) ≤ dl)))) → (match result with | Option.none => lim < leaves t | Option.some (res, dl) => res = max acc (depth + Height.height t) ∧ lim = leaves t + dl ∧ (0 : ℤ) ≤ dl))
  := sorry
end tree_height_HeightSmallSpace_height_limitedqtvc
