import Why3.Base
import Why3.int.NumOf
import Why3.queue.Queue
open Classical
open Lean4Why3
namespace mergesort_queue_MergesortQueue_mergesortqtvc
axiom elt : Type
axiom inhabited_axiom_elt : Inhabited elt
attribute [instance] inhabited_axiom_elt
axiom le : elt -> elt -> Prop
axiom Refl (x : elt) : le x x
axiom Trans (x : elt) (y : elt) (z : elt) (fact0 : le x y) (fact1 : le y z) : le x z
axiom Total (x : elt) (y : elt) : le x y ∨ le y x
noncomputable def sorted_sub (s : List elt) (l : ℤ) (u : ℤ) := ∀(i1 : ℤ) (i2 : ℤ), l ≤ i1 ∧ i1 ≤ i2 ∧ i2 < u → le (s[Int.toNat i1]!) (s[Int.toNat i2]!)
noncomputable def sorted (s : List elt) := sorted_sub s (0 : ℤ) (Int.ofNat (List.length s))
axiom sorted_cons (s : List elt) (x : elt) : ((∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s) → le x (s[Int.toNat i]!)) ∧ sorted s) = sorted (List.cons x s)
axiom sorted_append (s1 : List elt) (s2 : List elt) : (sorted s1 ∧ sorted s2 ∧ (∀(i : ℤ) (j : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s1)) ∧ (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length s2) → le (s1[Int.toNat i]!) (s2[Int.toNat j]!))) = sorted (s1 ++ s2)
axiom sorted_snoc (s : List elt) (x : elt) : ((∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s) → le (s[Int.toNat i]!) x) ∧ sorted s) = sorted (s ++ [x])
theorem mergesort'vc (o1 : ℕ) (q : Queue.t elt) (fact0 : o1 = List.length (Queue.seq q)) : if (1 : ℕ) < o1 then ∀(q1 : Queue.t elt), Queue.seq q1 = ([] : List elt) → (∀(q2 : Queue.t elt), Queue.seq q2 = ([] : List elt) → ((∀(x : elt), Int.ofNat (List.count x (Queue.seq q1)) + Int.ofNat (List.count x (Queue.seq q2)) + Int.ofNat (List.count x (Queue.seq q)) = Int.ofNat (List.count x (Queue.seq q))) ∧ Int.ofNat (List.length (Queue.seq q)) = Int.ofNat (List.length (Queue.seq q1)) + Int.ofNat (List.length (Queue.seq q2)) + Int.ofNat (List.length (Queue.seq q)) ∧ (List.length (Queue.seq q1) = List.length (Queue.seq q2) ∨ Int.ofNat (List.length (Queue.seq q)) = (0 : ℤ) ∧ Int.ofNat (List.length (Queue.seq q1)) = Int.ofNat (List.length (Queue.seq q2)) + (1 : ℤ))) ∧ (∀(q21 : Queue.t elt) (q11 : Queue.t elt) (q3 : Queue.t elt), (∀(x : elt), Int.ofNat (List.count x (Queue.seq q11)) + Int.ofNat (List.count x (Queue.seq q21)) + Int.ofNat (List.count x (Queue.seq q3)) = Int.ofNat (List.count x (Queue.seq q))) ∧ Int.ofNat (List.length (Queue.seq q)) = Int.ofNat (List.length (Queue.seq q11)) + Int.ofNat (List.length (Queue.seq q21)) + Int.ofNat (List.length (Queue.seq q3)) ∧ (List.length (Queue.seq q11) = List.length (Queue.seq q21) ∨ Int.ofNat (List.length (Queue.seq q3)) = (0 : ℤ) ∧ Int.ofNat (List.length (Queue.seq q11)) = Int.ofNat (List.length (Queue.seq q21)) + (1 : ℤ)) → (if ¬Queue.seq q3 = ([] : List elt) then ¬Queue.seq q3 = ([] : List elt) ∧ (∀(q4 : Queue.t elt), Queue.seq q4 = List.drop (1 : ℕ) (Queue.seq q3) → (∀(q12 : Queue.t elt), Queue.seq q12 = Queue.seq q11 ++ [(Queue.seq q3)[(0 : ℕ)]!] → (if ¬Queue.seq q4 = ([] : List elt) then ¬Queue.seq q4 = ([] : List elt) ∧ (∀(q5 : Queue.t elt), Queue.seq q5 = List.drop (1 : ℕ) (Queue.seq q4) → (∀(q22 : Queue.t elt), Queue.seq q22 = Queue.seq q21 ++ [(Queue.seq q4)[(0 : ℕ)]!] → ((0 : ℤ) ≤ Int.ofNat (List.length (Queue.seq q3)) ∧ List.length (Queue.seq q5) < List.length (Queue.seq q3)) ∧ (∀(x : elt), Int.ofNat (List.count x (Queue.seq q12)) + Int.ofNat (List.count x (Queue.seq q22)) + Int.ofNat (List.count x (Queue.seq q5)) = Int.ofNat (List.count x (Queue.seq q))) ∧ Int.ofNat (List.length (Queue.seq q)) = Int.ofNat (List.length (Queue.seq q12)) + Int.ofNat (List.length (Queue.seq q22)) + Int.ofNat (List.length (Queue.seq q5)) ∧ (List.length (Queue.seq q12) = List.length (Queue.seq q22) ∨ Int.ofNat (List.length (Queue.seq q5)) = (0 : ℤ) ∧ Int.ofNat (List.length (Queue.seq q12)) = Int.ofNat (List.length (Queue.seq q22)) + (1 : ℤ)))) else ((0 : ℤ) ≤ Int.ofNat (List.length (Queue.seq q3)) ∧ List.length (Queue.seq q4) < List.length (Queue.seq q3)) ∧ (∀(x : elt), Int.ofNat (List.count x (Queue.seq q12)) + Int.ofNat (List.count x (Queue.seq q21)) + Int.ofNat (List.count x (Queue.seq q4)) = Int.ofNat (List.count x (Queue.seq q))) ∧ Int.ofNat (List.length (Queue.seq q)) = Int.ofNat (List.length (Queue.seq q12)) + Int.ofNat (List.length (Queue.seq q21)) + Int.ofNat (List.length (Queue.seq q4)) ∧ (List.length (Queue.seq q12) = List.length (Queue.seq q21) ∨ Int.ofNat (List.length (Queue.seq q4)) = (0 : ℤ) ∧ Int.ofNat (List.length (Queue.seq q12)) = Int.ofNat (List.length (Queue.seq q21)) + (1 : ℤ))))) else ((0 : ℤ) ≤ Int.ofNat (List.length (Queue.seq q)) ∧ List.length (Queue.seq q11) < List.length (Queue.seq q)) ∧ (∀(q12 : Queue.t elt), sorted (Queue.seq q12) ∧ List.Perm (Queue.seq q12) (Queue.seq q11) → ((0 : ℤ) ≤ Int.ofNat (List.length (Queue.seq q)) ∧ List.length (Queue.seq q21) < List.length (Queue.seq q)) ∧ (∀(q22 : Queue.t elt), sorted (Queue.seq q22) ∧ List.Perm (Queue.seq q22) (Queue.seq q21) → (Queue.seq q3 = ([] : List elt) ∧ sorted (Queue.seq q12) ∧ sorted (Queue.seq q22)) ∧ (∀(q4 : Queue.t elt), sorted (Queue.seq q4) ∧ Int.ofNat (List.length (Queue.seq q4)) = Int.ofNat (List.length (Queue.seq q12)) + Int.ofNat (List.length (Queue.seq q22)) ∧ (∀(x : elt), Int.ofNat (List.count x (Queue.seq q4)) = Int.ofNat (List.count x (Queue.seq q12)) + Int.ofNat (List.count x (Queue.seq q22))) → sorted (Queue.seq q4) ∧ List.Perm (Queue.seq q4) (Queue.seq q))))))) else sorted (Queue.seq q) ∧ List.Perm (Queue.seq q) (Queue.seq q)
  := sorry
end mergesort_queue_MergesortQueue_mergesortqtvc
