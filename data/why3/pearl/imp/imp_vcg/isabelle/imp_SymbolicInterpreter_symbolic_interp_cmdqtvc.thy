theory imp_SymbolicInterpreter_symbolic_interp_cmdqtvc
  imports "NTP4Verif.NTP4Verif" "../../lib/isabelle/imp_Syntax" "../../lib/isabelle/imp_ConcreteSemantics" "../../lib/isabelle/imp_Svar" "../../lib/isabelle/imp_Constraint" "../../lib/isabelle/imp_SymState" "../../lib/isabelle/imp_FreshSvar" "../../lib/isabelle/imp_SymStateSet"
begin
consts compose :: "(svar \<Rightarrow> int) \<Rightarrow> t \<Rightarrow> program_var \<Rightarrow> int option"
axiomatization where compose'def:   "compose rho sigma x = (case get sigma x of Some v \<Rightarrow> Some (rho v) | None \<Rightarrow> None)"
  for rho :: "svar \<Rightarrow> int"
  and sigma :: "t"
  and x :: "program_var"
definition state_extends :: "sym_state \<Rightarrow> sym_state \<Rightarrow> _"
  where "state_extends s s' \<longleftrightarrow> imp_Svar.to_fset (vars s) |\<subseteq>| imp_Svar.to_fset (vars s') \<and> (\<forall>(v :: svar). v |\<in>| imp_Svar.to_fset (vars s) \<longrightarrow> rho s v = rho s' v)" for s s'
consts svar_set_add :: "svar \<Rightarrow> imp_Svar.set \<Rightarrow> imp_Svar.set"
axiomatization where svar_set_add'def'0:   "imp_Svar.to_fset (svar_set_add v vs) = finsert v (imp_Svar.to_fset vs)"
  for v :: "svar"
  and vs :: "imp_Svar.set"
axiomatization where svar_set_add'def'1:   "if v |\<in>| imp_Svar.to_fset vs then fcard (imp_Svar.to_fset (svar_set_add v vs)) = fcard (imp_Svar.to_fset vs) else int (fcard (imp_Svar.to_fset (svar_set_add v vs))) = int (fcard (imp_Svar.to_fset vs)) + (1 :: int)"
  for v :: "svar"
  and vs :: "imp_Svar.set"
definition results_extend :: "sym_state \<Rightarrow> sym_state fset \<Rightarrow> sym_state fset \<Rightarrow> sym_state fset \<Rightarrow> _"
  where "results_extend s normals unbounds limits \<longleftrightarrow> (\<forall>(s' :: sym_state). s' |\<in>| normals \<or> s' |\<in>| unbounds \<or> s' |\<in>| limits \<longrightarrow> state_extends s s')" for s normals unbounds limits
theorem symbolic_interp_cmd'vc:
  fixes n :: "int"
  fixes c :: "cmd"
  fixes s :: "sym_state"
  assumes fact0: "(0 :: int) \<le> n"
  shows "case c of Cskip \<Rightarrow> True | Cassign x e \<Rightarrow> (\<forall>(se :: symbolic_expr). eval_expr (compose (imp_SymState.rho s) (sigma s)) e (Enormal (interp_symbolic_expr (imp_SymState.rho s) se)) \<and> (\<forall>(v :: svar). v |\<in>| vars_in_symbolic_expr se \<longrightarrow> (\<exists>(x1 :: program_var). get (sigma s) x1 = Some v)) \<longrightarrow> (\<forall>(v' :: svar). is_fresh v' (imp_Svar.to_fset (vars s)) \<longrightarrow> (let o1 :: t = sigma s; sigma' :: t = imp_Constraint.set o1 x v' in get sigma' x = Some v' \<and> (\<forall>(k' :: program_var). \<not>k' = x \<longrightarrow> get sigma' k' = get o1 k') \<longrightarrow> (\<forall>(constr' :: constr). (let constr :: constr = Cconj (imp_SymState.constr s) (Ceq (Svar v') se) in (\<exists>(v :: svar). (case get (sigma s) x of None \<Rightarrow> False | Some v1 \<Rightarrow> v = v1) \<and> (\<forall>(rho :: svar \<Rightarrow> int). is_solution rho constr' \<longleftrightarrow> is_solution rho (Cexists v constr)) \<and> vars_in_constraint constr' |\<subseteq>| vars_in_constraint (Cexists v constr)) \<or> get (sigma s) x = None \<and> constr' = constr) \<longrightarrow> (let o2 :: imp_Svar.set = vars s in \<forall>(vars' :: imp_Svar.set). imp_Svar.to_fset vars' = finsert v' (imp_Svar.to_fset o2) \<and> (if v' |\<in>| imp_Svar.to_fset o2 then fcard (imp_Svar.to_fset vars') = fcard (imp_Svar.to_fset o2) else int (fcard (imp_Svar.to_fset vars')) = int (fcard (imp_Svar.to_fset o2)) + (1 :: int)) \<longrightarrow> vars_in_constraint constr' |\<subseteq>| imp_Svar.to_fset vars' \<and> (\<forall>(x1 :: program_var) (v :: svar). get sigma' x1 = Some v \<longrightarrow> v |\<in>| imp_Svar.to_fset vars')))))) | Cseq c1 c2 \<Rightarrow> ((case c of Cskip \<Rightarrow> False | Cassign _ _ \<Rightarrow> False | Cseq f f1 \<Rightarrow> f = c1 \<or> f1 = c1 | Cif _ f f1 \<Rightarrow> f = c1 \<or> f1 = c1 | Cwhile _ f \<Rightarrow> f = c1) \<and> (0 :: int) \<le> n) \<and> (\<forall>(normals1 :: imp_SymStateSet.set) (unbounds1 :: imp_SymStateSet.set) (limits1 :: imp_SymStateSet.set). results_extend s (imp_SymStateSet.to_fset normals1) (imp_SymStateSet.to_fset unbounds1) (imp_SymStateSet.to_fset limits1) \<and> (is_solution (imp_SymState.rho s) (imp_SymState.constr s) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s) (sigma s)) c1 gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<and> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<and> gamma' = compose (imp_SymState.rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<longrightarrow> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<longrightarrow> is_solution (imp_SymState.rho s) (imp_SymState.constr s) \<and> exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s) (sigma s)) c1 (compose (imp_SymState.rho s') (sigma s')) bhv) \<longrightarrow> (let o1 :: sym_state list = to_list normals1 in (\<forall>(e :: sym_state). e |\<in>| imp_SymStateSet.to_fset normals1 \<longleftrightarrow> e \<in> List.set o1) \<longrightarrow> ((case c of Cskip \<Rightarrow> False | Cassign _ _ \<Rightarrow> False | Cseq f f1 \<Rightarrow> f = c2 \<or> f1 = c2 | Cif _ f f1 \<Rightarrow> f = c2 \<or> f1 = c2 | Cwhile _ f \<Rightarrow> f = c2) \<or> c = c2 \<and> (0 :: int) \<le> (0 :: int) \<and> int (length o1) < (0 :: int)) \<and> (0 :: int) \<le> n)) | Cif e c1 c2 \<Rightarrow> (\<forall>(se :: symbolic_expr). eval_expr (compose (imp_SymState.rho s) (sigma s)) e (Enormal (interp_symbolic_expr (imp_SymState.rho s) se)) \<and> (\<forall>(v :: svar). v |\<in>| vars_in_symbolic_expr se \<longrightarrow> (\<exists>(x :: program_var). get (sigma s) x = Some v)) \<longrightarrow> (let o1 :: imp_Svar.set = vars s; o2 :: constr = Cconj (imp_SymState.constr s) (Cneq se (Slit (0 :: int))); o3 :: t = sigma s in (vars_in_constraint o2 |\<subseteq>| imp_Svar.to_fset o1 \<and> (\<forall>(x :: program_var) (v :: svar). get o3 x = Some v \<longrightarrow> v |\<in>| imp_Svar.to_fset o1)) \<and> (\<forall>(s1 :: sym_state). sigma s1 = o3 \<and> imp_SymState.constr s1 = o2 \<and> imp_SymState.rho s1 = imp_SymState.rho s \<and> vars s1 = o1 \<longrightarrow> (let o4 :: imp_Svar.set = vars s; o5 :: constr = Cconj (imp_SymState.constr s) (Ceq se (Slit (0 :: int))); o6 :: t = sigma s in (vars_in_constraint o5 |\<subseteq>| imp_Svar.to_fset o4 \<and> (\<forall>(x :: program_var) (v :: svar). get o6 x = Some v \<longrightarrow> v |\<in>| imp_Svar.to_fset o4)) \<and> (\<forall>(s2 :: sym_state). sigma s2 = o6 \<and> imp_SymState.constr s2 = o5 \<and> imp_SymState.rho s2 = imp_SymState.rho s \<and> vars s2 = o4 \<longrightarrow> ((True = False \<longrightarrow> (\<forall>(rho :: svar \<Rightarrow> int). \<not>is_solution rho (imp_SymState.constr s1))) \<longrightarrow> (case c of Cskip \<Rightarrow> False | Cassign _ _ \<Rightarrow> False | Cseq f f1 \<Rightarrow> f = c1 \<or> f1 = c1 | Cif _ f f1 \<Rightarrow> f = c1 \<or> f1 = c1 | Cwhile _ f \<Rightarrow> f = c1) \<and> (0 :: int) \<le> n) \<and> (\<forall>(normals1 :: imp_SymStateSet.set) (unbounds1 :: imp_SymStateSet.set) (limits1 :: imp_SymStateSet.set). (\<exists>(o7 :: bool). (o7 = False \<longrightarrow> (\<forall>(rho :: svar \<Rightarrow> int). \<not>is_solution rho (imp_SymState.constr s1))) \<and> (if o7 = True then results_extend s1 (imp_SymStateSet.to_fset normals1) (imp_SymStateSet.to_fset unbounds1) (imp_SymStateSet.to_fset limits1) \<and> (is_solution (imp_SymState.rho s1) (imp_SymState.constr s1) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s1) (sigma s1)) c1 gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<and> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<and> gamma' = compose (imp_SymState.rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<longrightarrow> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<longrightarrow> is_solution (imp_SymState.rho s1) (imp_SymState.constr s1) \<and> exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s1) (sigma s1)) c1 (compose (imp_SymState.rho s') (sigma s')) bhv) else (imp_SymStateSet.to_fset limits1 = fempty \<and> int (fcard (imp_SymStateSet.to_fset limits1)) = (0 :: int)) \<and> (imp_SymStateSet.to_fset unbounds1 = fempty \<and> int (fcard (imp_SymStateSet.to_fset unbounds1)) = (0 :: int)) \<and> imp_SymStateSet.to_fset normals1 = fempty \<and> int (fcard (imp_SymStateSet.to_fset normals1)) = (0 :: int))) \<longrightarrow> (True = False \<longrightarrow> (\<forall>(rho :: svar \<Rightarrow> int). \<not>is_solution rho (imp_SymState.constr s2))) \<longrightarrow> (case c of Cskip \<Rightarrow> False | Cassign _ _ \<Rightarrow> False | Cseq f f1 \<Rightarrow> f = c2 \<or> f1 = c2 | Cif _ f f1 \<Rightarrow> f = c2 \<or> f1 = c2 | Cwhile _ f \<Rightarrow> f = c2) \<and> (0 :: int) \<le> n)))))) | Cwhile e c1 \<Rightarrow> ((case c of Cskip \<Rightarrow> False | Cassign _ _ \<Rightarrow> False | Cseq f f1 \<Rightarrow> f = Cwhile e c1 \<or> f1 = Cwhile e c1 | Cif _ f f1 \<Rightarrow> f = Cwhile e c1 \<or> f1 = Cwhile e c1 | Cwhile _ f \<Rightarrow> f = Cwhile e c1) \<or> c = Cwhile e c1 \<and> (0 :: int) \<le> n + (1 :: int) \<and> n - (0 :: int) < n + (1 :: int)) \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> n"
  and "\<forall>(normals :: imp_SymStateSet.set) (unbounds :: imp_SymStateSet.set) (limits :: imp_SymStateSet.set). (case c of Cskip \<Rightarrow> (imp_SymStateSet.to_fset limits = fempty \<and> int (fcard (imp_SymStateSet.to_fset limits)) = (0 :: int)) \<and> (imp_SymStateSet.to_fset unbounds = fempty \<and> int (fcard (imp_SymStateSet.to_fset unbounds)) = (0 :: int)) \<and> imp_SymStateSet.to_fset normals = finsert s fempty \<and> int (fcard (imp_SymStateSet.to_fset normals)) = (1 :: int) | Cassign x e \<Rightarrow> (\<exists>(se :: symbolic_expr). (eval_expr (compose (imp_SymState.rho s) (sigma s)) e (Enormal (interp_symbolic_expr (imp_SymState.rho s) se)) \<and> (\<forall>(v :: svar). v |\<in>| vars_in_symbolic_expr se \<longrightarrow> (\<exists>(x1 :: program_var). get (sigma s) x1 = Some v))) \<and> (\<exists>(v' :: svar). is_fresh v' (imp_Svar.to_fset (vars s)) \<and> (let o1 :: t = sigma s; sigma' :: t = imp_Constraint.set o1 x v' in (get sigma' x = Some v' \<and> (\<forall>(k' :: program_var). \<not>k' = x \<longrightarrow> get sigma' k' = get o1 k')) \<and> (\<exists>(constr' :: constr). (let constr :: constr = Cconj (imp_SymState.constr s) (Ceq (Svar v') se) in (\<exists>(v :: svar). (case get (sigma s) x of None \<Rightarrow> False | Some v1 \<Rightarrow> v = v1) \<and> (\<forall>(rho :: svar \<Rightarrow> int). is_solution rho constr' \<longleftrightarrow> is_solution rho (Cexists v constr)) \<and> vars_in_constraint constr' |\<subseteq>| vars_in_constraint (Cexists v constr)) \<or> get (sigma s) x = None \<and> constr' = constr) \<and> (let o2 :: imp_Svar.set = vars s in \<exists>(vars' :: imp_Svar.set). (imp_Svar.to_fset vars' = finsert v' (imp_Svar.to_fset o2) \<and> (if v' |\<in>| imp_Svar.to_fset o2 then fcard (imp_Svar.to_fset vars') = fcard (imp_Svar.to_fset o2) else int (fcard (imp_Svar.to_fset vars')) = int (fcard (imp_Svar.to_fset o2)) + (1 :: int))) \<and> (\<exists>(s' :: sym_state). (sigma s' = sigma' \<and> imp_SymState.constr s' = constr' \<and> imp_SymState.rho s' = (imp_SymState.rho s)(v' := interp_symbolic_expr (imp_SymState.rho s) se) \<and> vars s' = vars') \<and> (imp_SymStateSet.to_fset limits = fempty \<and> int (fcard (imp_SymStateSet.to_fset limits)) = (0 :: int)) \<and> (imp_SymStateSet.to_fset unbounds = fempty \<and> int (fcard (imp_SymStateSet.to_fset unbounds)) = (0 :: int)) \<and> imp_SymStateSet.to_fset normals = finsert s' fempty \<and> int (fcard (imp_SymStateSet.to_fset normals)) = (1 :: int))))))) \<or> eval_expr (compose (imp_SymState.rho s) (sigma s)) e Eunbound_var \<and> (imp_SymStateSet.to_fset limits = fempty \<and> int (fcard (imp_SymStateSet.to_fset limits)) = (0 :: int)) \<and> (imp_SymStateSet.to_fset unbounds = finsert s fempty \<and> int (fcard (imp_SymStateSet.to_fset unbounds)) = (1 :: int)) \<and> imp_SymStateSet.to_fset normals = fempty \<and> int (fcard (imp_SymStateSet.to_fset normals)) = (0 :: int) | Cseq c1 c2 \<Rightarrow> (\<exists>(normals1 :: imp_SymStateSet.set) (unbounds1 :: imp_SymStateSet.set) (limits1 :: imp_SymStateSet.set). (results_extend s (imp_SymStateSet.to_fset normals1) (imp_SymStateSet.to_fset unbounds1) (imp_SymStateSet.to_fset limits1) \<and> (is_solution (imp_SymState.rho s) (imp_SymState.constr s) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s) (sigma s)) c1 gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<and> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<and> gamma' = compose (imp_SymState.rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<longrightarrow> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<longrightarrow> is_solution (imp_SymState.rho s) (imp_SymState.constr s) \<and> exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s) (sigma s)) c1 (compose (imp_SymState.rho s') (sigma s')) bhv)) \<and> (let o1 :: sym_state list = to_list normals1 in (\<forall>(e :: sym_state). e |\<in>| imp_SymStateSet.to_fset normals1 \<longleftrightarrow> e \<in> List.set o1) \<and> (\<exists>(unbounds2 :: imp_SymStateSet.set) (limits2 :: imp_SymStateSet.set). ((\<forall>(s' :: sym_state). s' |\<in>| imp_SymStateSet.to_fset normals \<or> s' |\<in>| imp_SymStateSet.to_fset unbounds2 \<or> s' |\<in>| imp_SymStateSet.to_fset limits2 \<longrightarrow> (\<exists>(s1 :: sym_state). s1 |\<in>| imp_SymStateSet.to_fset (of_list o1) \<and> state_extends s1 s')) \<and> (\<forall>(s1 :: sym_state). s1 |\<in>| imp_SymStateSet.to_fset (of_list o1) \<longrightarrow> is_solution (imp_SymState.rho s1) (imp_SymState.constr s1) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s1) (sigma s1)) c2 gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds2 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits2) \<and> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<and> gamma' = compose (imp_SymState.rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds2 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits2) \<longrightarrow> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<longrightarrow> (\<exists>(s1 :: sym_state). s1 |\<in>| imp_SymStateSet.to_fset (of_list o1) \<and> is_solution (imp_SymState.rho s1) (imp_SymState.constr s1) \<and> exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s1) (sigma s1)) c2 (compose (imp_SymState.rho s') (sigma s')) bhv))) \<and> imp_SymStateSet.to_fset limits = imp_SymStateSet.to_fset limits1 |\<union>| imp_SymStateSet.to_fset limits2 \<and> imp_SymStateSet.to_fset unbounds = imp_SymStateSet.to_fset unbounds1 |\<union>| imp_SymStateSet.to_fset unbounds2))) | Cif e c1 c2 \<Rightarrow> (\<exists>(se :: symbolic_expr). (eval_expr (compose (imp_SymState.rho s) (sigma s)) e (Enormal (interp_symbolic_expr (imp_SymState.rho s) se)) \<and> (\<forall>(v :: svar). v |\<in>| vars_in_symbolic_expr se \<longrightarrow> (\<exists>(x :: program_var). get (sigma s) x = Some v))) \<and> (\<exists>(s1 :: sym_state). (sigma s1 = sigma s \<and> imp_SymState.constr s1 = Cconj (imp_SymState.constr s) (Cneq se (Slit (0 :: int))) \<and> imp_SymState.rho s1 = imp_SymState.rho s \<and> vars s1 = vars s) \<and> (\<exists>(s2 :: sym_state). (sigma s2 = sigma s \<and> imp_SymState.constr s2 = Cconj (imp_SymState.constr s) (Ceq se (Slit (0 :: int))) \<and> imp_SymState.rho s2 = imp_SymState.rho s \<and> vars s2 = vars s) \<and> (\<exists>(normals1 :: imp_SymStateSet.set) (unbounds1 :: imp_SymStateSet.set) (limits1 :: imp_SymStateSet.set). (\<exists>(o1 :: bool). (o1 = False \<longrightarrow> (\<forall>(rho :: svar \<Rightarrow> int). \<not>is_solution rho (imp_SymState.constr s1))) \<and> (if o1 = True then results_extend s1 (imp_SymStateSet.to_fset normals1) (imp_SymStateSet.to_fset unbounds1) (imp_SymStateSet.to_fset limits1) \<and> (is_solution (imp_SymState.rho s1) (imp_SymState.constr s1) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s1) (sigma s1)) c1 gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<and> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<and> gamma' = compose (imp_SymState.rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals1 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds1 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits1) \<longrightarrow> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<longrightarrow> is_solution (imp_SymState.rho s1) (imp_SymState.constr s1) \<and> exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s1) (sigma s1)) c1 (compose (imp_SymState.rho s') (sigma s')) bhv) else (imp_SymStateSet.to_fset limits1 = fempty \<and> int (fcard (imp_SymStateSet.to_fset limits1)) = (0 :: int)) \<and> (imp_SymStateSet.to_fset unbounds1 = fempty \<and> int (fcard (imp_SymStateSet.to_fset unbounds1)) = (0 :: int)) \<and> imp_SymStateSet.to_fset normals1 = fempty \<and> int (fcard (imp_SymStateSet.to_fset normals1)) = (0 :: int))) \<and> (\<exists>(normals2 :: imp_SymStateSet.set) (unbounds2 :: imp_SymStateSet.set) (limits2 :: imp_SymStateSet.set). (\<exists>(o1 :: bool). (o1 = False \<longrightarrow> (\<forall>(rho :: svar \<Rightarrow> int). \<not>is_solution rho (imp_SymState.constr s2))) \<and> (if o1 = True then results_extend s2 (imp_SymStateSet.to_fset normals2) (imp_SymStateSet.to_fset unbounds2) (imp_SymStateSet.to_fset limits2) \<and> (is_solution (imp_SymState.rho s2) (imp_SymState.constr s2) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s2) (sigma s2)) c2 gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals2 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds2 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits2) \<and> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<and> gamma' = compose (imp_SymState.rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals2 | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds2 | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits2) \<longrightarrow> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<longrightarrow> is_solution (imp_SymState.rho s2) (imp_SymState.constr s2) \<and> exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s2) (sigma s2)) c2 (compose (imp_SymState.rho s') (sigma s')) bhv) else (imp_SymStateSet.to_fset limits2 = fempty \<and> int (fcard (imp_SymStateSet.to_fset limits2)) = (0 :: int)) \<and> (imp_SymStateSet.to_fset unbounds2 = fempty \<and> int (fcard (imp_SymStateSet.to_fset unbounds2)) = (0 :: int)) \<and> imp_SymStateSet.to_fset normals2 = fempty \<and> int (fcard (imp_SymStateSet.to_fset normals2)) = (0 :: int))) \<and> imp_SymStateSet.to_fset limits = imp_SymStateSet.to_fset limits1 |\<union>| imp_SymStateSet.to_fset limits2 \<and> imp_SymStateSet.to_fset unbounds = imp_SymStateSet.to_fset unbounds1 |\<union>| imp_SymStateSet.to_fset unbounds2 \<and> imp_SymStateSet.to_fset normals = imp_SymStateSet.to_fset normals1 |\<union>| imp_SymStateSet.to_fset normals2))))) \<or> eval_expr (compose (imp_SymState.rho s) (sigma s)) e Eunbound_var \<and> (imp_SymStateSet.to_fset limits = fempty \<and> int (fcard (imp_SymStateSet.to_fset limits)) = (0 :: int)) \<and> (imp_SymStateSet.to_fset unbounds = finsert s fempty \<and> int (fcard (imp_SymStateSet.to_fset unbounds)) = (1 :: int)) \<and> imp_SymStateSet.to_fset normals = fempty \<and> int (fcard (imp_SymStateSet.to_fset normals)) = (0 :: int) | Cwhile e c1 \<Rightarrow> results_extend s (imp_SymStateSet.to_fset normals) (imp_SymStateSet.to_fset unbounds) (imp_SymStateSet.to_fset limits) \<and> (is_solution (imp_SymState.rho s) (imp_SymState.constr s) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_while (mk_loop_cnf n) (0 :: int) (compose (imp_SymState.rho s) (sigma s)) e c1 gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits) \<and> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<and> gamma' = compose (imp_SymState.rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits) \<longrightarrow> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<longrightarrow> is_solution (imp_SymState.rho s) (imp_SymState.constr s) \<and> exec_while (mk_loop_cnf n) (0 :: int) (compose (imp_SymState.rho s) (sigma s)) e c1 (compose (imp_SymState.rho s') (sigma s')) bhv)) \<longrightarrow> results_extend s (imp_SymStateSet.to_fset normals) (imp_SymStateSet.to_fset unbounds) (imp_SymStateSet.to_fset limits) \<and> (is_solution (imp_SymState.rho s) (imp_SymState.constr s) \<longrightarrow> (\<forall>(gamma' :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s) (sigma s)) c gamma' bhv \<longrightarrow> (\<exists>(s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits) \<and> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<and> gamma' = compose (imp_SymState.rho s') (sigma s')))) \<and> (\<forall>(bhv :: behavior) (s' :: sym_state). (case bhv of Cnormal \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset normals | Cunbound_var \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset unbounds | Cloop_limit \<Rightarrow> s' |\<in>| imp_SymStateSet.to_fset limits) \<longrightarrow> is_solution (imp_SymState.rho s') (imp_SymState.constr s') \<longrightarrow> is_solution (imp_SymState.rho s) (imp_SymState.constr s) \<and> exec_cmd (mk_loop_cnf n) (compose (imp_SymState.rho s) (sigma s)) c (compose (imp_SymState.rho s') (sigma s')) bhv)"
  sorry
end
