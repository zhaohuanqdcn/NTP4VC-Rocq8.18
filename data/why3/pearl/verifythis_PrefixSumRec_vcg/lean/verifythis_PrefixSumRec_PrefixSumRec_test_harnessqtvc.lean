import Why3.Base
import Why3.int.Sum
open Classical
open Lean4Why3
namespace verifythis_PrefixSumRec_PrefixSumRec_test_harnessqtvc
noncomputable def is_power_of_2 (x : ℤ) := ∃(k : ℤ), (0 : ℤ) ≤ k ∧ x = HPow.hPow (2 : ℤ) (Int.toNat k)
noncomputable def go_left (left1 : ℤ) (right1 : ℤ) := let space : ℤ := right1 - left1; left1 - Int.tdiv space (2 : ℤ)
noncomputable def go_right (left1 : ℤ) (right1 : ℤ) := let space : ℤ := right1 - left1; right1 - Int.tdiv space (2 : ℤ)
inductive phase1 : ℤ -> ℤ -> List ℤ -> List ℤ -> Prop where
 | Leaf (right1 : ℤ) (left1 : ℤ) (a : List ℤ) (a0 : List ℤ) : right1 = left1 + (1 : ℤ) → a[Int.toNat left1]! = a0[Int.toNat left1]! → phase1 left1 right1 a0 a
 | Node (left1 : ℤ) (right1 : ℤ) (a0 : List ℤ) (a : List ℤ) : left1 + (1 : ℤ) < right1 → phase1 (go_left left1 right1) left1 a0 a → phase1 (go_right left1 right1) right1 a0 a → a[Int.toNat left1]! = List.sum (List.drop (Int.toNat (left1 - (right1 - left1) + (1 : ℤ))) (List.take (Int.toNat (left1 + (1 : ℤ)) - Int.toNat (left1 - (right1 - left1) + (1 : ℤ))) a0)) → phase1 left1 right1 a0 a
noncomputable def partial_sum (left1 : ℤ) (right1 : ℤ) (a0 : List ℤ) (a : List ℤ) := ∀(i : ℤ), left1 - (right1 - left1) < i ∧ i ≤ right1 → a[Int.toNat i]! = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a0))
theorem test_harness'vc : (0 : ℤ) ≤ (8 : ℤ) ∧ (∀(a : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (8 : ℤ) → a[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length a) = (8 : ℤ) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length a)) ∧ (List.length (List.set a (0 : ℕ) (3 : ℤ)) = List.length a → getElem! (List.set a (0 : ℕ) (3 : ℤ)) ∘ Int.toNat = Function.update (getElem! a ∘ Int.toNat) (0 : ℤ) (3 : ℤ) → ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < Int.ofNat (List.length (List.set a (0 : ℕ) (3 : ℤ)))) ∧ (List.length (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) = List.length (List.set a (0 : ℕ) (3 : ℤ)) → getElem! (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) ∘ Int.toNat = Function.update (getElem! (List.set a (0 : ℕ) (3 : ℤ)) ∘ Int.toNat) (1 : ℤ) (1 : ℤ) → ((0 : ℤ) ≤ (2 : ℤ) ∧ (2 : ℤ) < Int.ofNat (List.length (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)))) ∧ (List.length (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) = List.length (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) → getElem! (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) ∘ Int.toNat = Function.update (getElem! (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) ∘ Int.toNat) (2 : ℤ) (7 : ℤ) → ((0 : ℤ) ≤ (3 : ℤ) ∧ (3 : ℤ) < Int.ofNat (List.length (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)))) ∧ (List.length (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) = List.length (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) → getElem! (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) ∘ Int.toNat = Function.update (getElem! (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) ∘ Int.toNat) (3 : ℤ) (0 : ℤ) → ((0 : ℤ) ≤ (4 : ℤ) ∧ (4 : ℤ) < Int.ofNat (List.length (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)))) ∧ (List.length (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) = List.length (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) → getElem! (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) ∘ Int.toNat = Function.update (getElem! (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) ∘ Int.toNat) (4 : ℤ) (4 : ℤ) → ((0 : ℤ) ≤ (5 : ℤ) ∧ (5 : ℤ) < Int.ofNat (List.length (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)))) ∧ (List.length (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)) = List.length (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) → getElem! (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)) ∘ Int.toNat = Function.update (getElem! (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) ∘ Int.toNat) (5 : ℤ) (1 : ℤ) → ((0 : ℤ) ≤ (6 : ℤ) ∧ (6 : ℤ) < Int.ofNat (List.length (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)))) ∧ (List.length (List.set (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)) (6 : ℕ) (6 : ℤ)) = List.length (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)) → getElem! (List.set (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)) (6 : ℕ) (6 : ℤ)) ∘ Int.toNat = Function.update (getElem! (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)) ∘ Int.toNat) (6 : ℤ) (6 : ℤ) → ((0 : ℤ) ≤ (7 : ℤ) ∧ (7 : ℤ) < Int.ofNat (List.length (List.set (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)) (6 : ℕ) (6 : ℤ)))) ∧ (List.length (List.set (List.set (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)) (6 : ℕ) (6 : ℤ)) (7 : ℕ) (3 : ℤ)) = List.length (List.set (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)) (6 : ℕ) (6 : ℤ)) → getElem! (List.set (List.set (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)) (6 : ℕ) (6 : ℤ)) (7 : ℕ) (3 : ℤ)) ∘ Int.toNat = Function.update (getElem! (List.set (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)) (6 : ℕ) (6 : ℤ)) ∘ Int.toNat) (7 : ℤ) (3 : ℤ) → (2 : ℤ) ≤ Int.ofNat (List.length (List.set (List.set (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)) (6 : ℕ) (6 : ℤ)) (7 : ℕ) (3 : ℤ))) ∧ is_power_of_2 (Int.ofNat (List.length (List.set (List.set (List.set (List.set (List.set (List.set (List.set (List.set a (0 : ℕ) (3 : ℤ)) (1 : ℕ) (1 : ℤ)) (2 : ℕ) (7 : ℤ)) (3 : ℕ) (0 : ℤ)) (4 : ℕ) (4 : ℤ)) (5 : ℕ) (1 : ℤ)) (6 : ℕ) (6 : ℤ)) (7 : ℕ) (3 : ℤ)))))))))))))
  := sorry
end verifythis_PrefixSumRec_PrefixSumRec_test_harnessqtvc
