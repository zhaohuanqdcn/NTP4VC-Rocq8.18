import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace maximum_subarray_MaxProd_maximum_subarrayqtvc
axiom prod : List ℤ -> ℤ -> ℤ -> ℤ
axiom prod'def (lo : ℤ) (hi : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ lo) (fact1 : lo ≤ hi) (fact2 : hi ≤ Int.ofNat (List.length a)) : if lo = hi then prod a lo hi = (1 : ℤ) else prod a lo hi = prod a lo (hi - (1 : ℤ)) * a[Int.toNat (hi - (1 : ℤ))]!
theorem maximum_subarray'vc (a : List ℤ) : let o1 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → (((0 : ℤ) ≤ (0 : ℤ) ∧ prod a (0 : ℤ) (0 : ℤ) = (1 : ℤ) ∧ (1 : ℤ) ≤ (1 : ℤ)) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ (0 : ℤ) → (0 : ℤ) ≤ prod a l (0 : ℤ) → prod a l (0 : ℤ) ≤ (1 : ℤ)) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ ((0 : ℤ) < (0 : ℤ) → (0 : ℤ) ≤ (0 : ℤ) ∧ prod a (0 : ℤ) (0 : ℤ) = (0 : ℤ) ∧ (0 : ℤ) < (0 : ℤ)) ∧ ((0 : ℤ) < (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ (0 : ℤ) → prod a l (0 : ℤ) < (0 : ℤ) → (0 : ℤ) ≤ prod a l (0 : ℤ))) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ (0 : ℤ) → (0 : ℤ) ≤ prod a l (0 : ℤ)) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ (0 : ℤ) → prod a l h ≤ (1 : ℤ)) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ prod a (0 : ℤ) (0 : ℤ) = (1 : ℤ) ∧ (1 : ℤ) ≤ (1 : ℤ)) ∧ (∀(cln : ℤ) (clp : ℤ) (hi : ℤ) (lo : ℤ) (curmaxn : ℤ) (curmaxp : ℤ) (maxprd : ℤ), (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ (((0 : ℤ) ≤ clp ∧ clp ≤ i) ∧ prod a clp i = curmaxp ∧ (1 : ℤ) ≤ curmaxp) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i → (0 : ℤ) ≤ prod a l i → prod a l i ≤ curmaxp) ∧ curmaxn ≤ (0 : ℤ) ∧ (curmaxn < (0 : ℤ) → ((0 : ℤ) ≤ cln ∧ cln ≤ i) ∧ prod a cln i = curmaxn ∧ curmaxn < (0 : ℤ)) ∧ (curmaxn < (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i → prod a l i < (0 : ℤ) → curmaxn ≤ prod a l i)) ∧ (curmaxn = (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i → (0 : ℤ) ≤ prod a l i)) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i → prod a l h ≤ maxprd) ∧ ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ i) ∧ prod a lo hi = maxprd ∧ (1 : ℤ) ≤ maxprd → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if a[Int.toNat i]! = (0 : ℤ) then if maxprd < (1 : ℤ) then (((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ prod a (i + (1 : ℤ)) (i + (1 : ℤ)) = (1 : ℤ) ∧ (1 : ℤ) ≤ (1 : ℤ)) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)) → prod a l (i + (1 : ℤ)) ≤ (1 : ℤ)) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ ((0 : ℤ) < (0 : ℤ) → ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ prod a (i + (1 : ℤ)) (i + (1 : ℤ)) = (0 : ℤ) ∧ (0 : ℤ) < (0 : ℤ)) ∧ ((0 : ℤ) < (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → prod a l (i + (1 : ℤ)) < (0 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)))) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ))) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i + (1 : ℤ) → prod a l h ≤ (1 : ℤ)) ∧ ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ prod a (i + (1 : ℤ)) (i + (1 : ℤ)) = (1 : ℤ) ∧ (1 : ℤ) ≤ (1 : ℤ) else (((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ prod a (i + (1 : ℤ)) (i + (1 : ℤ)) = (1 : ℤ) ∧ (1 : ℤ) ≤ (1 : ℤ)) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)) → prod a l (i + (1 : ℤ)) ≤ (1 : ℤ)) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ ((0 : ℤ) < (0 : ℤ) → ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ prod a (i + (1 : ℤ)) (i + (1 : ℤ)) = (0 : ℤ) ∧ (0 : ℤ) < (0 : ℤ)) ∧ ((0 : ℤ) < (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → prod a l (i + (1 : ℤ)) < (0 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)))) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ))) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i + (1 : ℤ) → prod a l h ≤ maxprd) ∧ ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ i + (1 : ℤ)) ∧ prod a lo hi = maxprd ∧ (1 : ℤ) ≤ maxprd else ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if (0 : ℤ) < a[Int.toNat i]! then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if maxprd < curmaxp * a[Int.toNat i]! then (((0 : ℤ) ≤ clp ∧ clp ≤ i + (1 : ℤ)) ∧ prod a clp (i + (1 : ℤ)) = curmaxp * a[Int.toNat i]! ∧ (1 : ℤ) ≤ curmaxp * a[Int.toNat i]!) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)) → prod a l (i + (1 : ℤ)) ≤ curmaxp * a[Int.toNat i]!) ∧ curmaxn * a[Int.toNat i]! ≤ (0 : ℤ) ∧ (curmaxn * a[Int.toNat i]! < (0 : ℤ) → ((0 : ℤ) ≤ cln ∧ cln ≤ i + (1 : ℤ)) ∧ prod a cln (i + (1 : ℤ)) = curmaxn * a[Int.toNat i]! ∧ curmaxn * a[Int.toNat i]! < (0 : ℤ)) ∧ (curmaxn * a[Int.toNat i]! < (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → prod a l (i + (1 : ℤ)) < (0 : ℤ) → curmaxn * a[Int.toNat i]! ≤ prod a l (i + (1 : ℤ)))) ∧ (curmaxn * a[Int.toNat i]! = (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)))) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i + (1 : ℤ) → prod a l h ≤ curmaxp * a[Int.toNat i]!) ∧ ((0 : ℤ) ≤ clp ∧ clp ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ prod a clp (i + (1 : ℤ)) = curmaxp * a[Int.toNat i]! ∧ (1 : ℤ) ≤ curmaxp * a[Int.toNat i]! else (((0 : ℤ) ≤ clp ∧ clp ≤ i + (1 : ℤ)) ∧ prod a clp (i + (1 : ℤ)) = curmaxp * a[Int.toNat i]! ∧ (1 : ℤ) ≤ curmaxp * a[Int.toNat i]!) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)) → prod a l (i + (1 : ℤ)) ≤ curmaxp * a[Int.toNat i]!) ∧ curmaxn * a[Int.toNat i]! ≤ (0 : ℤ) ∧ (curmaxn * a[Int.toNat i]! < (0 : ℤ) → ((0 : ℤ) ≤ cln ∧ cln ≤ i + (1 : ℤ)) ∧ prod a cln (i + (1 : ℤ)) = curmaxn * a[Int.toNat i]! ∧ curmaxn * a[Int.toNat i]! < (0 : ℤ)) ∧ (curmaxn * a[Int.toNat i]! < (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → prod a l (i + (1 : ℤ)) < (0 : ℤ) → curmaxn * a[Int.toNat i]! ≤ prod a l (i + (1 : ℤ)))) ∧ (curmaxn * a[Int.toNat i]! = (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)))) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i + (1 : ℤ) → prod a l h ≤ maxprd) ∧ ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ i + (1 : ℤ)) ∧ prod a lo hi = maxprd ∧ (1 : ℤ) ≤ maxprd) else if curmaxn < (0 : ℤ) then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if maxprd < curmaxn * a[Int.toNat i]! then (((0 : ℤ) ≤ cln ∧ cln ≤ i + (1 : ℤ)) ∧ prod a cln (i + (1 : ℤ)) = curmaxn * a[Int.toNat i]! ∧ (1 : ℤ) ≤ curmaxn * a[Int.toNat i]!) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)) → prod a l (i + (1 : ℤ)) ≤ curmaxn * a[Int.toNat i]!) ∧ curmaxp * a[Int.toNat i]! ≤ (0 : ℤ) ∧ (curmaxp * a[Int.toNat i]! < (0 : ℤ) → ((0 : ℤ) ≤ clp ∧ clp ≤ i + (1 : ℤ)) ∧ prod a clp (i + (1 : ℤ)) = curmaxp * a[Int.toNat i]! ∧ curmaxp * a[Int.toNat i]! < (0 : ℤ)) ∧ (curmaxp * a[Int.toNat i]! < (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → prod a l (i + (1 : ℤ)) < (0 : ℤ) → curmaxp * a[Int.toNat i]! ≤ prod a l (i + (1 : ℤ)))) ∧ (curmaxp * a[Int.toNat i]! = (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)))) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i + (1 : ℤ) → prod a l h ≤ curmaxn * a[Int.toNat i]!) ∧ ((0 : ℤ) ≤ cln ∧ cln ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ prod a cln (i + (1 : ℤ)) = curmaxn * a[Int.toNat i]! ∧ (1 : ℤ) ≤ curmaxn * a[Int.toNat i]! else (((0 : ℤ) ≤ cln ∧ cln ≤ i + (1 : ℤ)) ∧ prod a cln (i + (1 : ℤ)) = curmaxn * a[Int.toNat i]! ∧ (1 : ℤ) ≤ curmaxn * a[Int.toNat i]!) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)) → prod a l (i + (1 : ℤ)) ≤ curmaxn * a[Int.toNat i]!) ∧ curmaxp * a[Int.toNat i]! ≤ (0 : ℤ) ∧ (curmaxp * a[Int.toNat i]! < (0 : ℤ) → ((0 : ℤ) ≤ clp ∧ clp ≤ i + (1 : ℤ)) ∧ prod a clp (i + (1 : ℤ)) = curmaxp * a[Int.toNat i]! ∧ curmaxp * a[Int.toNat i]! < (0 : ℤ)) ∧ (curmaxp * a[Int.toNat i]! < (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → prod a l (i + (1 : ℤ)) < (0 : ℤ) → curmaxp * a[Int.toNat i]! ≤ prod a l (i + (1 : ℤ)))) ∧ (curmaxp * a[Int.toNat i]! = (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)))) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i + (1 : ℤ) → prod a l h ≤ maxprd) ∧ ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ i + (1 : ℤ)) ∧ prod a lo hi = maxprd ∧ (1 : ℤ) ≤ maxprd) else ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if maxprd < (1 : ℤ) then (((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ prod a (i + (1 : ℤ)) (i + (1 : ℤ)) = (1 : ℤ) ∧ (1 : ℤ) ≤ (1 : ℤ)) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)) → prod a l (i + (1 : ℤ)) ≤ (1 : ℤ)) ∧ curmaxp * a[Int.toNat i]! ≤ (0 : ℤ) ∧ (curmaxp * a[Int.toNat i]! < (0 : ℤ) → ((0 : ℤ) ≤ clp ∧ clp ≤ i + (1 : ℤ)) ∧ prod a clp (i + (1 : ℤ)) = curmaxp * a[Int.toNat i]! ∧ curmaxp * a[Int.toNat i]! < (0 : ℤ)) ∧ (curmaxp * a[Int.toNat i]! < (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → prod a l (i + (1 : ℤ)) < (0 : ℤ) → curmaxp * a[Int.toNat i]! ≤ prod a l (i + (1 : ℤ)))) ∧ (curmaxp * a[Int.toNat i]! = (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)))) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i + (1 : ℤ) → prod a l h ≤ (1 : ℤ)) ∧ ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ prod a (i + (1 : ℤ)) (i + (1 : ℤ)) = (1 : ℤ) ∧ (1 : ℤ) ≤ (1 : ℤ) else (((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ prod a (i + (1 : ℤ)) (i + (1 : ℤ)) = (1 : ℤ) ∧ (1 : ℤ) ≤ (1 : ℤ)) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)) → prod a l (i + (1 : ℤ)) ≤ (1 : ℤ)) ∧ curmaxp * a[Int.toNat i]! ≤ (0 : ℤ) ∧ (curmaxp * a[Int.toNat i]! < (0 : ℤ) → ((0 : ℤ) ≤ clp ∧ clp ≤ i + (1 : ℤ)) ∧ prod a clp (i + (1 : ℤ)) = curmaxp * a[Int.toNat i]! ∧ curmaxp * a[Int.toNat i]! < (0 : ℤ)) ∧ (curmaxp * a[Int.toNat i]! < (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → prod a l (i + (1 : ℤ)) < (0 : ℤ) → curmaxp * a[Int.toNat i]! ≤ prod a l (i + (1 : ℤ)))) ∧ (curmaxp * a[Int.toNat i]! = (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ i + (1 : ℤ) → (0 : ℤ) ≤ prod a l (i + (1 : ℤ)))) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ i + (1 : ℤ) → prod a l h ≤ maxprd) ∧ ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ i + (1 : ℤ)) ∧ prod a lo hi = maxprd ∧ (1 : ℤ) ≤ maxprd)))) ∧ ((((0 : ℤ) ≤ clp ∧ clp ≤ o1 + (1 : ℤ)) ∧ prod a clp (o1 + (1 : ℤ)) = curmaxp ∧ (1 : ℤ) ≤ curmaxp) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ o1 + (1 : ℤ) → (0 : ℤ) ≤ prod a l (o1 + (1 : ℤ)) → prod a l (o1 + (1 : ℤ)) ≤ curmaxp) ∧ curmaxn ≤ (0 : ℤ) ∧ (curmaxn < (0 : ℤ) → ((0 : ℤ) ≤ cln ∧ cln ≤ o1 + (1 : ℤ)) ∧ prod a cln (o1 + (1 : ℤ)) = curmaxn ∧ curmaxn < (0 : ℤ)) ∧ (curmaxn < (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ o1 + (1 : ℤ) → prod a l (o1 + (1 : ℤ)) < (0 : ℤ) → curmaxn ≤ prod a l (o1 + (1 : ℤ)))) ∧ (curmaxn = (0 : ℤ) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l ≤ o1 + (1 : ℤ) → (0 : ℤ) ≤ prod a l (o1 + (1 : ℤ)))) ∧ (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ o1 + (1 : ℤ) → prod a l h ≤ maxprd) ∧ ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ o1 + (1 : ℤ)) ∧ prod a lo hi = maxprd ∧ (1 : ℤ) ≤ maxprd → (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ Int.ofNat (List.length a) → prod a l h ≤ maxprd) ∧ (∃(l : ℤ) (h : ℤ), ((0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ Int.ofNat (List.length a)) ∧ prod a l h = maxprd)))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ Int.ofNat (List.length a) → prod a l h ≤ (1 : ℤ)) ∧ (∃(l : ℤ) (h : ℤ), ((0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ Int.ofNat (List.length a)) ∧ prod a l h = (1 : ℤ)))
  := sorry
end maximum_subarray_MaxProd_maximum_subarrayqtvc
