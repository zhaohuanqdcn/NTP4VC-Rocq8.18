From Stdlib Require Import Strings.String.
From Stdlib Require Import String Ascii.
From Stdlib Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Stdlib Require Classical.
From Stdlib Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Stdlib Require Import Sorting.Sorted.
From Stdlib Require Import Reals.Rbasic_fun.
From Stdlib Require Import Reals.Abstract.ConstructiveAbs.
From Stdlib Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Stdlib Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Stdlib Require Import ZArith.Zeuclid.
From Stdlib Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Stdlib Require Import Reals.
Require Import Why3.Base.
Require Import Why3.why3.Ref.Ref.
Require Import Why3.int.NumOf.
Require Import Why3.int.Sum.
Require Import Why3.matrix.Matrix.
Open Scope Z_scope.
Axiom fc : Z -> matrix Z -> Z -> Z.
Axiom fc'def : forall  (x : Z) (m : matrix Z) (i : Z), fc x m i = Z.of_nat (map_occ_list x (elts m i) 0%Z (columns m)).
Definition mocc (x : Z) (m : matrix Z) : Z := sum (fc x m) 0%Z (rows m).
Definition lt (i : Z) (j : Z) (k : Z) (l : Z) := i < k ∨ i = k ∧ (if decide (Z.quot i 2%Z = 0%Z) then j < l else l < j).
Definition snake_order (m : matrix Z) := let rw : Z := rows m in let cl : Z := columns m in ∀(i : Z) (j : Z) (k : Z) (l : Z), 0%Z ≤ i ∧ i < rw -> 0%Z ≤ j ∧ j < cl -> 0%Z ≤ k ∧ k < rw -> 0%Z ≤ l ∧ l < cl -> lt i j k l -> elts m i j ≤ elts m k l.
Axiom fc1 : matrix Z -> Z -> Z -> Z -> Z -> bool.
Axiom fc2 : matrix Z -> Z -> Z -> Z -> Z.
Axiom fc3 : matrix Z -> Z -> Z -> Z.
Axiom fc4 : matrix Z -> Z -> Z.
Axiom fc'def1 : forall  (m : matrix Z) (i : Z) (j : Z) (k : Z) (l : Z), (fc1 m i j k l = true) = (lt i j k l ∧ elts m k l < elts m i j).
Axiom fc'def2 : forall  (m : matrix Z) (i : Z) (j : Z) (k : Z), fc2 m i j k = numof (fc1 m i j k) 0%Z (columns m).
Axiom fc'def3 : forall  (m : matrix Z) (i : Z) (j : Z), fc3 m i j = sum (fc2 m i j) 0%Z (rows m).
Axiom fc'def4 : forall  (m : matrix Z) (i : Z), fc4 m i = sum (fc3 m i) 0%Z (columns m).
Definition inversions (m : matrix Z) : Z := sum (fc4 m) 0%Z (rows m).
Definition sorted_row (m : matrix Z) (row : Z) (ascending : bool) := (0%Z ≤ row ∧ row < rows m) ∧ (if decide (ascending = true) then ∀(j : Z) (l : Z), 0%Z ≤ j ∧ j ≤ l ∧ l < columns m -> elts m row j ≤ elts m row l else ∀(j : Z) (l : Z), 0%Z ≤ j ∧ j ≤ l ∧ l < columns m -> elts m row l ≤ elts m row j).
Definition sorted_column (m : matrix Z) (column : Z) := (0%Z ≤ column ∧ column < columns m) ∧ (∀(i : Z) (k : Z), 0%Z ≤ i ∧ i ≤ k ∧ k < rows m -> elts m i column ≤ elts m k column).
Theorem shearsort'vc (m : matrix Z) (m1 : matrix Z) (fact0 : rows m = columns m) (fact1 : rows m1 = rows m) (fact2 : columns m1 = columns m) (fact3 : ∀(x : Z), mocc x m1 = mocc x m) : let o1 : Z := columns m - 1%Z in (0%Z ≤ o1 + 1%Z -> ((∀(k : Z), 0%Z ≤ k ∧ k < 0%Z -> sorted_row m1 k (if decide (Z.quot k 2%Z = 0%Z) then true else false)) ∧ (∀(x : Z), mocc x m1 = mocc x m) ∧ inversions m1 ≤ inversions m1) ∧ (∀(m2 : matrix Z), rows m2 = rows m1 ∧ columns m2 = columns m1 -> (∀(i : Z), (0%Z ≤ i ∧ i ≤ o1) ∧ (∀(k : Z), 0%Z ≤ k ∧ k < i -> sorted_row m2 k (if decide (Z.quot k 2%Z = 0%Z) then true else false)) ∧ (∀(x : Z), mocc x m2 = mocc x m) ∧ inversions m2 ≤ inversions m1 -> ¬ 2%Z = 0%Z ∧ (0%Z ≤ i ∧ i < rows m2) ∧ (∀(m3 : matrix Z), rows m3 = rows m2 ∧ columns m3 = columns m2 -> (∀(i1 : Z) (j : Z), 0%Z ≤ i1 ∧ i1 < rows m3 -> 0%Z ≤ j ∧ j < columns m3 -> ¬ i1 = i -> elts m3 i1 j = elts m2 i1 j) ∧ (∀(x : Z), mocc x m3 = mocc x m2) ∧ sorted_row m3 i (if decide (Z.quot i 2%Z = 0%Z) then true else false) ∧ inversions m3 ≤ inversions m2 -> (∀(k : Z), 0%Z ≤ k ∧ k < i + 1%Z -> sorted_row m3 k (if decide (Z.quot k 2%Z = 0%Z) then true else false)) ∧ (∀(x : Z), mocc x m3 = mocc x m) ∧ inversions m3 ≤ inversions m1)) ∧ ((∀(k : Z), 0%Z ≤ k ∧ k < o1 + 1%Z -> sorted_row m2 k (if decide (Z.quot k 2%Z = 0%Z) then true else false)) ∧ (∀(x : Z), mocc x m2 = mocc x m) ∧ inversions m2 ≤ inversions m1 -> (let o2 : Z := columns m - 1%Z in (0%Z ≤ o2 + 1%Z -> ((∀(l : Z), 0%Z ≤ l ∧ l < 0%Z -> sorted_column m2 l) ∧ (∀(x : Z), mocc x m2 = mocc x m) ∧ inversions m2 ≤ inversions m2) ∧ (∀(nochange : bool) (m3 : matrix Z), rows m3 = rows m2 ∧ columns m3 = columns m2 -> (∀(j : Z), (0%Z ≤ j ∧ j ≤ o2) ∧ (nochange = true -> (∀(i : Z) (j1 : Z), 0%Z ≤ i ∧ i < rows m3 -> 0%Z ≤ j1 ∧ j1 < columns m3 -> elts m3 i j1 = elts m2 i j1)) ∧ (∀(l : Z), 0%Z ≤ l ∧ l < j -> sorted_column m3 l) ∧ (∀(x : Z), mocc x m3 = mocc x m) ∧ inversions m3 ≤ inversions m2 ∧ (¬ nochange = true -> inversions m3 < inversions m2) -> (0%Z ≤ j ∧ j < columns m3) ∧ (∀(m4 : matrix Z), rows m4 = rows m3 ∧ columns m4 = columns m3 -> (∀(nch : bool), (∀(i : Z) (j1 : Z), 0%Z ≤ i ∧ i < rows m4 -> 0%Z ≤ j1 ∧ j1 < columns m4 -> ¬ j1 = j -> elts m4 i j1 = elts m3 i j1) ∧ (∀(x : Z), mocc x m4 = mocc x m3) ∧ (nch = true -> (∀(i : Z), 0%Z ≤ i ∧ i < rows m4 -> elts m4 i j = elts m3 i j)) ∧ sorted_column m4 j ∧ inversions m4 ≤ inversions m3 ∧ (¬ nch = true -> inversions m4 < inversions m3) -> (if decide (¬ nch = true) then (false = true -> (∀(i : Z) (j1 : Z), 0%Z ≤ i ∧ i < rows m4 -> 0%Z ≤ j1 ∧ j1 < columns m4 -> elts m4 i j1 = elts m2 i j1)) ∧ (∀(l : Z), 0%Z ≤ l ∧ l < j + 1%Z -> sorted_column m4 l) ∧ (∀(x : Z), mocc x m4 = mocc x m) ∧ inversions m4 ≤ inversions m2 ∧ (¬ false = true -> inversions m4 < inversions m2) else (nochange = true -> (∀(i : Z) (j1 : Z), 0%Z ≤ i ∧ i < rows m4 -> 0%Z ≤ j1 ∧ j1 < columns m4 -> elts m4 i j1 = elts m2 i j1)) ∧ (∀(l : Z), 0%Z ≤ l ∧ l < j + 1%Z -> sorted_column m4 l) ∧ (∀(x : Z), mocc x m4 = mocc x m) ∧ inversions m4 ≤ inversions m2 ∧ (¬ nochange = true -> inversions m4 < inversions m2))))) ∧ ((nochange = true -> (∀(i : Z) (j : Z), 0%Z ≤ i ∧ i < rows m3 -> 0%Z ≤ j ∧ j < columns m3 -> elts m3 i j = elts m2 i j)) ∧ (∀(l : Z), 0%Z ≤ l ∧ l < o2 + 1%Z -> sorted_column m3 l) ∧ (∀(x : Z), mocc x m3 = mocc x m) ∧ inversions m3 ≤ inversions m2 ∧ (¬ nochange = true -> inversions m3 < inversions m2) -> (if decide (nochange = true) then (∀(i : Z) (j : Z) (k : Z) (l : Z), (0%Z ≤ i ∧ i < columns m) ∧ (0%Z ≤ j ∧ j < columns m) ∧ (0%Z ≤ k ∧ k < columns m) ∧ (0%Z ≤ l ∧ l < columns m) ∧ lt i j k l -> elts m3 i j ≤ elts m3 k l) ∧ snake_order m3 ∧ (∀(x : Z), mocc x m3 = mocc x m) else (0%Z ≤ inversions m1 ∧ inversions m3 < inversions m1) ∧ (∀(x : Z), mocc x m3 = mocc x m))))) ∧ (o2 + 1%Z < 0%Z -> (∀(i : Z) (j : Z) (k : Z) (l : Z), (0%Z ≤ i ∧ i < columns m) ∧ (0%Z ≤ j ∧ j < columns m) ∧ (0%Z ≤ k ∧ k < columns m) ∧ (0%Z ≤ l ∧ l < columns m) ∧ lt i j k l -> elts m2 i j ≤ elts m2 k l) ∧ snake_order m2 ∧ (∀(x : Z), mocc x m2 = mocc x m)))))) ∧ (o1 + 1%Z < 0%Z -> (let o2 : Z := columns m - 1%Z in (0%Z ≤ o2 + 1%Z -> ((∀(l : Z), 0%Z ≤ l ∧ l < 0%Z -> sorted_column m1 l) ∧ (∀(x : Z), mocc x m1 = mocc x m) ∧ inversions m1 ≤ inversions m1) ∧ (∀(nochange : bool) (m2 : matrix Z), rows m2 = rows m1 ∧ columns m2 = columns m1 -> (∀(j : Z), (0%Z ≤ j ∧ j ≤ o2) ∧ (nochange = true -> (∀(i : Z) (j1 : Z), 0%Z ≤ i ∧ i < rows m2 -> 0%Z ≤ j1 ∧ j1 < columns m2 -> elts m2 i j1 = elts m1 i j1)) ∧ (∀(l : Z), 0%Z ≤ l ∧ l < j -> sorted_column m2 l) ∧ (∀(x : Z), mocc x m2 = mocc x m) ∧ inversions m2 ≤ inversions m1 ∧ (¬ nochange = true -> inversions m2 < inversions m1) -> (0%Z ≤ j ∧ j < columns m2) ∧ (∀(m3 : matrix Z), rows m3 = rows m2 ∧ columns m3 = columns m2 -> (∀(nch : bool), (∀(i : Z) (j1 : Z), 0%Z ≤ i ∧ i < rows m3 -> 0%Z ≤ j1 ∧ j1 < columns m3 -> ¬ j1 = j -> elts m3 i j1 = elts m2 i j1) ∧ (∀(x : Z), mocc x m3 = mocc x m2) ∧ (nch = true -> (∀(i : Z), 0%Z ≤ i ∧ i < rows m3 -> elts m3 i j = elts m2 i j)) ∧ sorted_column m3 j ∧ inversions m3 ≤ inversions m2 ∧ (¬ nch = true -> inversions m3 < inversions m2) -> (if decide (¬ nch = true) then (false = true -> (∀(i : Z) (j1 : Z), 0%Z ≤ i ∧ i < rows m3 -> 0%Z ≤ j1 ∧ j1 < columns m3 -> elts m3 i j1 = elts m1 i j1)) ∧ (∀(l : Z), 0%Z ≤ l ∧ l < j + 1%Z -> sorted_column m3 l) ∧ (∀(x : Z), mocc x m3 = mocc x m) ∧ inversions m3 ≤ inversions m1 ∧ (¬ false = true -> inversions m3 < inversions m1) else (nochange = true -> (∀(i : Z) (j1 : Z), 0%Z ≤ i ∧ i < rows m3 -> 0%Z ≤ j1 ∧ j1 < columns m3 -> elts m3 i j1 = elts m1 i j1)) ∧ (∀(l : Z), 0%Z ≤ l ∧ l < j + 1%Z -> sorted_column m3 l) ∧ (∀(x : Z), mocc x m3 = mocc x m) ∧ inversions m3 ≤ inversions m1 ∧ (¬ nochange = true -> inversions m3 < inversions m1))))) ∧ ((nochange = true -> (∀(i : Z) (j : Z), 0%Z ≤ i ∧ i < rows m2 -> 0%Z ≤ j ∧ j < columns m2 -> elts m2 i j = elts m1 i j)) ∧ (∀(l : Z), 0%Z ≤ l ∧ l < o2 + 1%Z -> sorted_column m2 l) ∧ (∀(x : Z), mocc x m2 = mocc x m) ∧ inversions m2 ≤ inversions m1 ∧ (¬ nochange = true -> inversions m2 < inversions m1) -> (if decide (nochange = true) then (∀(i : Z) (j : Z) (k : Z) (l : Z), (0%Z ≤ i ∧ i < columns m) ∧ (0%Z ≤ j ∧ j < columns m) ∧ (0%Z ≤ k ∧ k < columns m) ∧ (0%Z ≤ l ∧ l < columns m) ∧ lt i j k l -> elts m2 i j ≤ elts m2 k l) ∧ snake_order m2 ∧ (∀(x : Z), mocc x m2 = mocc x m) else (0%Z ≤ inversions m1 ∧ inversions m2 < inversions m1) ∧ (∀(x : Z), mocc x m2 = mocc x m))))) ∧ (o2 + 1%Z < 0%Z -> (∀(i : Z) (j : Z) (k : Z) (l : Z), (0%Z ≤ i ∧ i < columns m) ∧ (0%Z ≤ j ∧ j < columns m) ∧ (0%Z ≤ k ∧ k < columns m) ∧ (0%Z ≤ l ∧ l < columns m) ∧ lt i j k l -> elts m1 i j ≤ elts m1 k l) ∧ snake_order m1 ∧ (∀(x : Z), mocc x m1 = mocc x m)))).
Admitted.
