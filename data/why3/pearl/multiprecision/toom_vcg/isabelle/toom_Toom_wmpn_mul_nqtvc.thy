theory toom_Toom_wmpn_mul_nqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.c_C" "mach.int_Unsigned" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_1_Sub_1" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical"
begin
theorem wmpn_mul_n'vc:
  fixes sz :: "32 word"
  fixes x :: "64 word ptr"
  fixes y :: "64 word ptr"
  fixes r :: "64 word ptr"
  fixes k :: "int"
  assumes fact0: "(0 :: int) < sint sz"
  assumes fact1: "valid x (sint sz)"
  assumes fact2: "valid y (sint sz)"
  assumes fact3: "valid r (sint sz + sint sz)"
  assumes fact4: "writable r = True"
  assumes fact5: "(8 :: int) * sint sz < (2147483647 :: int)"
  assumes fact6: "sint sz \<le> sint (29 :: 32 word) * (2 :: int) ^\<^sub>i k"
  assumes fact7: "(0 :: int) \<le> k"
  assumes fact8: "k \<le> (64 :: int)"
  shows "if sint sz \<le> sint (29 :: 32 word) then (((0 :: int) < sint sz \<and> sint sz \<le> sint sz) \<and> valid x (sint sz) \<and> valid y (sint sz) \<and> valid r (sint sz + sint sz) \<and> writable r = True) \<and> (\<forall>(r1 :: 64 word ptr). length (data r1) = length (data r) \<and> offset r1 = offset r \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> writable r1 = writable r \<and> zone1 r1 = zone1 r \<longrightarrow> value r1 (sint sz + sint sz) = value x (sint sz) * value y (sint sz) \<and> (\<forall>(j :: int). j < offset r1 \<or> offset r1 + (sint sz + sint sz) \<le> j \<longrightarrow> pelts r1 j = pelts r j) \<longrightarrow> value r1 (sint sz + sint sz) = value x (sint sz) * value y (sint sz) \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> plength r1 = plength r \<and> (\<forall>(j :: int). c_C.min r1 \<le> j \<and> j < offset r1 \<or> offset r1 + sint sz + sint sz \<le> j \<and> j < c_C.max r1 \<longrightarrow> pelts r1 j = pelts r j)) else int'32_in_bounds (sint sz + (64 :: int)) \<and> (\<forall>(o1 :: 32 word). sint o1 = sint sz + (64 :: int) \<longrightarrow> int'32_in_bounds ((2 :: int) * sint o1) \<and> (\<forall>(o2 :: 32 word). sint o2 = (2 :: int) * sint o1 \<longrightarrow> (0 :: int) \<le> sint o2 \<and> (\<forall>(o3 :: 32 word). uint o3 = sint o2 \<longrightarrow> (0 :: int) \<le> uint o3 \<and> (\<forall>(ws :: 64 word ptr). plength ws = uint o3 \<and> offset ws = (0 :: int) \<and> c_C.min ws = (0 :: int) \<and> c_C.max ws = uint o3 \<and> writable ws = True \<longrightarrow> (valid x (sint sz) \<and> valid y (sint sz) \<and> valid r (sint sz + sint sz) \<and> sint (29 :: 32 word) < sint sz \<and> ((0 :: int) < (64 :: int) \<and> (64 :: int) \<le> (64 :: int)) \<and> sint sz \<le> sint (29 :: 32 word) * (2 :: int) ^\<^sub>i (64 :: int) \<and> valid ws ((2 :: int) * (sint sz + (64 :: int))) \<and> (writable r = True \<and> writable ws = True) \<and> (8 :: int) * sint sz < (2147483647 :: int) \<and> ((2 :: int) < sint sz \<and> sint sz \<le> sint sz \<and> sint sz < sint sz + sint sz - (1 :: int)) \<and> (4 :: int) * sint sz < (5 :: int) * sint sz) \<and> (\<forall>(ws1 :: 64 word ptr) (r1 :: 64 word ptr). offset ws1 = offset ws \<and> writable ws1 = writable ws \<and> zone1 ws1 = zone1 ws \<longrightarrow> offset r1 = offset r \<and> writable r1 = writable r \<and> zone1 r1 = zone1 r \<longrightarrow> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> plength r1 = plength r \<and> c_C.min ws1 = c_C.min ws \<and> c_C.max ws1 = c_C.max ws \<and> plength ws1 = plength ws \<and> value r1 (sint sz + sint sz) = value x (sint sz) * value y (sint sz) \<and> (\<forall>(j :: int). c_C.min r1 \<le> j \<and> j < offset r1 \<or> offset r1 + sint sz + sint sz \<le> j \<and> j < c_C.max r1 \<longrightarrow> pelts r1 j = pelts r j) \<and> (\<forall>(j :: int). c_C.min ws1 \<le> j \<and> j < offset ws1 \<longrightarrow> pelts ws1 j = pelts ws j) \<longrightarrow> value r1 (sint sz + sint sz) = value x (sint sz) * value y (sint sz) \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> plength r1 = plength r \<and> (\<forall>(j :: int). c_C.min r1 \<le> j \<and> j < offset r1 \<or> offset r1 + sint sz + sint sz \<le> j \<and> j < c_C.max r1 \<longrightarrow> pelts r1 j = pelts r j))))))"
  sorry
end
