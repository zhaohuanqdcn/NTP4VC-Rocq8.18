import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.LogicalOld
open Classical
open Lean4Why3
namespace div_Div_div3by2_invqtvc
noncomputable def reciprocal (v : BitVec 64) (d : BitVec 64) := BitVec.toUInt v = (((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) - (1 : ℤ)) / BitVec.toUInt d - ((18446744073709551615 : ℤ) + (1 : ℤ))
noncomputable def reciprocal_3by2 (v : BitVec 64) (dh : BitVec 64) (dl : BitVec 64) := BitVec.toUInt v = (((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) - (1 : ℤ)) / (BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh) - ((18446744073709551615 : ℤ) + (1 : ℤ))
theorem div3by2_inv'vc (dh : BitVec 64) (v : BitVec 64) (dl : BitVec 64) (um : BitVec 64) (uh : BitVec 64) (l : BitVec 64) (h : BitVec 64) (ul : BitVec 64) (fact0 : ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt dh) (fact1 : reciprocal_3by2 v dh dl) (fact2 : BitVec.toUInt um + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt uh < BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh) (fact3 : BitVec.toUInt l + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt h = BitVec.toUInt v * BitVec.toUInt uh) : (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (1 : ℤ) ∧ (∀(sl : BitVec 64) (c : BitVec 64), BitVec.toUInt sl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt c = BitVec.toUInt um + BitVec.toUInt l + (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (∀(sh : BitVec 64) (c' : BitVec 64), BitVec.toUInt sh + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt c' = BitVec.toUInt uh + BitVec.toUInt h + BitVec.toUInt c ∧ (0 : ℤ) ≤ BitVec.toUInt c' ∧ BitVec.toUInt c' ≤ (1 : ℤ) → (∀(o1 : BitVec 64), BitVec.toUInt o1 = (BitVec.toUInt sh + (1 : ℤ)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (∀(p : BitVec 64), BitVec.toUInt p = BitVec.toUInt dh * BitVec.toUInt sh % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (∀(o2 : BitVec 64), BitVec.toUInt o2 = (BitVec.toUInt um - BitVec.toUInt p) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → ¬(18446744073709551615 : ℤ) + (1 : ℤ) = (0 : ℤ) ∧ (∀(tl : BitVec 64) (th : BitVec 64), BitVec.toUInt tl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt th = BitVec.toUInt sh * BitVec.toUInt dl → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (1 : ℤ)) ∧ (∀(il : BitVec 64) (b : BitVec 64), BitVec.toUInt il - ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt b = BitVec.toUInt ul - BitVec.toUInt tl - (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ (∀(ih : BitVec 64) (b' : BitVec 64), BitVec.toUInt ih - ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt b' = BitVec.toUInt o2 - BitVec.toUInt th - BitVec.toUInt b ∧ (0 : ℤ) ≤ BitVec.toUInt b' ∧ BitVec.toUInt b' ≤ (1 : ℤ) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (1 : ℤ)) ∧ (∀(bl : BitVec 64) (b2 : BitVec 64), BitVec.toUInt bl - ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt b2 = BitVec.toUInt il - BitVec.toUInt dl - (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toUInt b2 ∧ BitVec.toUInt b2 ≤ (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt b2 ∧ BitVec.toUInt b2 ≤ (1 : ℤ)) ∧ (∀(bh : BitVec 64) (b2' : BitVec 64), BitVec.toUInt bh - ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt b2' = BitVec.toUInt ih - BitVec.toUInt dh - BitVec.toUInt b2 ∧ (0 : ℤ) ≤ BitVec.toUInt b2' ∧ BitVec.toUInt b2' ≤ (1 : ℤ) → (if BitVec.toUInt sl ≤ BitVec.toUInt bh then ∀(o3 : BitVec 64), BitVec.toUInt o3 = (BitVec.toUInt o1 - (1 : ℤ)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (1 : ℤ)) ∧ (∀(rl : BitVec 64) (c1 : BitVec 64), BitVec.toUInt rl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt c1 = BitVec.toUInt bl + BitVec.toUInt dl + (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toUInt c1 ∧ BitVec.toUInt c1 ≤ (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt c1 ∧ BitVec.toUInt c1 ≤ (1 : ℤ)) ∧ (∀(rh : BitVec 64) (c'1 : BitVec 64), BitVec.toUInt rh + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt c'1 = BitVec.toUInt bh + BitVec.toUInt dh + BitVec.toUInt c1 ∧ (0 : ℤ) ≤ BitVec.toUInt c'1 ∧ BitVec.toUInt c'1 ≤ (1 : ℤ) → (∀(o4 : Bool), (if BitVec.toUInt dh < BitVec.toUInt rh then o4 = true else ∃(o5 : Bool), ((BitVec.toUInt rh = BitVec.toUInt dh → o5 = true) ∧ (o5 = true → rh = dh)) ∧ o4 = (if o5 = true then if BitVec.toUInt dl ≤ BitVec.toUInt rl then true else false else false)) → (if o4 = true then ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (1 : ℤ)) ∧ (∀(bl1 : BitVec 64) (b1 : BitVec 64), BitVec.toUInt bl1 - ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt b1 = BitVec.toUInt rl - BitVec.toUInt dl - (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toUInt b1 ∧ BitVec.toUInt b1 ≤ (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt b1 ∧ BitVec.toUInt b1 ≤ (1 : ℤ)) ∧ (∀(bh1 : BitVec 64) (b'1 : BitVec 64), BitVec.toUInt bh1 - ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt b'1 = BitVec.toUInt rh - BitVec.toUInt dh - BitVec.toUInt b1 ∧ (0 : ℤ) ≤ BitVec.toUInt b'1 ∧ BitVec.toUInt b'1 ≤ (1 : ℤ) → (∀(o5 : BitVec 64), BitVec.toUInt o5 = (BitVec.toUInt o3 + (1 : ℤ)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → BitVec.toUInt o5 * BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt o5 * BitVec.toUInt dh + BitVec.toUInt bl1 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt bh1 = BitVec.toUInt ul + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt um + ((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt uh ∧ (0 : ℤ) ≤ BitVec.toUInt bl1 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt bh1 ∧ BitVec.toUInt bl1 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt bh1 < BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh))) else BitVec.toUInt o3 * BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt o3 * BitVec.toUInt dh + BitVec.toUInt rl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt rh = BitVec.toUInt ul + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt um + ((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt uh ∧ (0 : ℤ) ≤ BitVec.toUInt rl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt rh ∧ BitVec.toUInt rl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt rh < BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh)))) else ∀(o3 : Bool), (if BitVec.toUInt dh < BitVec.toUInt bh then o3 = true else ∃(o4 : Bool), ((BitVec.toUInt bh = BitVec.toUInt dh → o4 = true) ∧ (o4 = true → bh = dh)) ∧ o3 = (if o4 = true then if BitVec.toUInt dl ≤ BitVec.toUInt bl then true else false else false)) → (if o3 = true then ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (1 : ℤ)) ∧ (∀(bl1 : BitVec 64) (b3 : BitVec 64), BitVec.toUInt bl1 - ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt b3 = BitVec.toUInt bl - BitVec.toUInt dl - (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toUInt b3 ∧ BitVec.toUInt b3 ≤ (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt b3 ∧ BitVec.toUInt b3 ≤ (1 : ℤ)) ∧ (∀(bh1 : BitVec 64) (b'1 : BitVec 64), BitVec.toUInt bh1 - ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt b'1 = BitVec.toUInt bh - BitVec.toUInt dh - BitVec.toUInt b3 ∧ (0 : ℤ) ≤ BitVec.toUInt b'1 ∧ BitVec.toUInt b'1 ≤ (1 : ℤ) → (∀(o4 : BitVec 64), BitVec.toUInt o4 = (BitVec.toUInt o1 + (1 : ℤ)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → BitVec.toUInt o4 * BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt o4 * BitVec.toUInt dh + BitVec.toUInt bl1 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt bh1 = BitVec.toUInt ul + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt um + ((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt uh ∧ (0 : ℤ) ≤ BitVec.toUInt bl1 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt bh1 ∧ BitVec.toUInt bl1 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt bh1 < BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh))) else BitVec.toUInt o1 * BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt o1 * BitVec.toUInt dh + BitVec.toUInt bl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt bh = BitVec.toUInt ul + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt um + ((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt uh ∧ (0 : ℤ) ≤ BitVec.toUInt bl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt bh ∧ BitVec.toUInt bl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt bh < BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh))))))))))))
  := sorry
end div_Div_div3by2_invqtvc
