import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace conjugate_Conjugate_conjugateqtvc
noncomputable def is_partition (a : List ℤ) := (0 : ℤ) < Int.ofNat (List.length a) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ j ∧ j < Int.ofNat (List.length a) → a[Int.toNat j]! ≤ a[Int.toNat i]!) ∧ a[Int.toNat (Int.ofNat (List.length a) - (1 : ℤ))]! = (0 : ℤ)
noncomputable def numofgt (a : List ℤ) (n : ℤ) (v : ℤ) := ((0 : ℤ) ≤ n ∧ n < Int.ofNat (List.length a)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < n → v < a[Int.toNat j]!) ∧ a[Int.toNat n]! ≤ v
noncomputable def is_conjugate (a : List ℤ) (b : List ℤ) := a[(0 : ℕ)]! < Int.ofNat (List.length b) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length b) → numofgt a (b[Int.toNat j]!) j)
theorem conjugate'vc (a : List ℤ) (fact0 : is_partition a) : (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length a) ∧ (let o1 : ℤ := a[(0 : ℕ)]! + (1 : ℤ); (0 : ℤ) ≤ o1 ∧ (∀(b : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o1 → b[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length b) = o1 → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length a)) ∧ (∀(j : ℤ), a[(0 : ℕ)]! ≤ j ∧ j < Int.ofNat (List.length b) → numofgt a (b[Int.toNat j]!) j)) ∧ (∀(partc : ℤ) (b1 : List ℤ), List.length b1 = List.length b → ((0 : ℤ) ≤ partc ∧ partc < Int.ofNat (List.length a)) ∧ (∀(j : ℤ), a[Int.toNat partc]! ≤ j ∧ j < Int.ofNat (List.length b1) → numofgt a (b1[Int.toNat j]!) j) → ((0 : ℤ) ≤ partc ∧ partc < Int.ofNat (List.length a)) ∧ (if ¬a[Int.toNat partc]! = (0 : ℤ) then ((0 : ℤ) ≤ partc ∧ partc < Int.ofNat (List.length a)) ∧ (let edge : ℤ := a[Int.toNat partc]!; ((partc ≤ partc + (1 : ℤ) ∧ partc + (1 : ℤ) < Int.ofNat (List.length a)) ∧ (∀(j : ℤ), partc ≤ j ∧ j < partc + (1 : ℤ) → a[Int.toNat j]! = edge)) ∧ (∀(partc1 : ℤ), (partc ≤ partc1 ∧ partc1 < Int.ofNat (List.length a)) ∧ (∀(j : ℤ), partc ≤ j ∧ j < partc1 → a[Int.toNat j]! = edge) → ((0 : ℤ) ≤ partc1 ∧ partc1 < Int.ofNat (List.length a)) ∧ (if a[Int.toNat partc1]! = edge then ((0 : ℤ) ≤ Int.ofNat (List.length a) - partc1 ∧ Int.ofNat (List.length a) - (partc1 + (1 : ℤ)) < Int.ofNat (List.length a) - partc1) ∧ (partc ≤ partc1 + (1 : ℤ) ∧ partc1 + (1 : ℤ) < Int.ofNat (List.length a)) ∧ (∀(j : ℤ), partc ≤ j ∧ j < partc1 + (1 : ℤ) → a[Int.toNat j]! = edge) else let o2 : ℤ := edge - (1 : ℤ); ((0 : ℤ) ≤ partc1 ∧ partc1 < Int.ofNat (List.length a)) ∧ (let o3 : ℤ := a[Int.toNat partc1]!; (o3 ≤ o2 + (1 : ℤ) → (∀(j : ℤ), a[Int.toNat partc1]! ≤ j ∧ j < o3 → b1[Int.toNat j]! = partc1) ∧ (∀(b2 : List ℤ), List.length b2 = List.length b1 → (∀(i : ℤ), (o3 ≤ i ∧ i ≤ o2) ∧ (∀(j : ℤ), edge ≤ j ∧ j < Int.ofNat (List.length b2) → b2[Int.toNat j]! = b1[Int.toNat j]!) ∧ (∀(j : ℤ), a[Int.toNat partc1]! ≤ j ∧ j < i → b2[Int.toNat j]! = partc1) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length b2)) ∧ (List.length (List.set b2 (Int.toNat i) partc1) = List.length b2 → getElem! (List.set b2 (Int.toNat i) partc1) ∘ Int.toNat = Function.update (getElem! b2 ∘ Int.toNat) i partc1 → (∀(j : ℤ), edge ≤ j ∧ j < Int.ofNat (List.length (List.set b2 (Int.toNat i) partc1)) → (List.set b2 (Int.toNat i) partc1)[Int.toNat j]! = b1[Int.toNat j]!) ∧ (∀(j : ℤ), a[Int.toNat partc1]! ≤ j ∧ j < i + (1 : ℤ) → (List.set b2 (Int.toNat i) partc1)[Int.toNat j]! = partc1))) ∧ ((∀(j : ℤ), edge ≤ j ∧ j < Int.ofNat (List.length b2) → b2[Int.toNat j]! = b1[Int.toNat j]!) ∧ (∀(j : ℤ), a[Int.toNat partc1]! ≤ j ∧ j < o2 + (1 : ℤ) → b2[Int.toNat j]! = partc1) → ((0 : ℤ) ≤ Int.ofNat (List.length a) - partc ∧ Int.ofNat (List.length a) - partc1 < Int.ofNat (List.length a) - partc) ∧ ((0 : ℤ) ≤ partc1 ∧ partc1 < Int.ofNat (List.length a)) ∧ (∀(j : ℤ), a[Int.toNat partc1]! ≤ j ∧ j < Int.ofNat (List.length b2) → numofgt a (b2[Int.toNat j]!) j)))) ∧ (o2 + (1 : ℤ) < o3 → ((0 : ℤ) ≤ Int.ofNat (List.length a) - partc ∧ Int.ofNat (List.length a) - partc1 < Int.ofNat (List.length a) - partc) ∧ ((0 : ℤ) ≤ partc1 ∧ partc1 < Int.ofNat (List.length a)) ∧ (∀(j : ℤ), a[Int.toNat partc1]! ≤ j ∧ j < Int.ofNat (List.length b1) → numofgt a (b1[Int.toNat j]!) j)))))) else is_conjugate a b1))))
  := sorry
end conjugate_Conjugate_conjugateqtvc
