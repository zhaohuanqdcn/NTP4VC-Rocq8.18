import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
open Classical
open Lean4Why3
namespace sub_1_Sub_1_wmpn_decr_1qtvc
theorem wmpn_decr_1'vc (x : C.ptr (BitVec 64)) (sz : BitVec 32) (fact0 : C.valid x (BitVec.toInt sz)) (fact1 : (0 : ℤ) < BitVec.toInt sz) (fact2 : (0 : ℤ) ≤ Lemmas.value x (BitVec.toInt sz) - (1 : ℤ)) (fact3 : C.writable x = true) : C.min x ≤ C.offset x + (0 : ℤ) ∧ C.offset x + (0 : ℤ) ≤ C.max x ∧ (∀(o1 : C.ptr (BitVec 64)), C.offset o1 = C.offset x + (0 : ℤ) ∧ C.plength o1 = C.plength x ∧ C.pelts o1 = C.pelts x ∧ C.data o1 = C.data x ∧ C.min o1 = C.min x ∧ C.max o1 = C.max x ∧ C.zone1 o1 = C.zone1 x ∧ C.writable o1 = C.writable x → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt sz) ∧ ¬(0 : BitVec 32) = sz ∧ C.offset o1 = C.offset x + (0 : ℤ) ∧ C.pelts o1 = C.pelts x ∧ C.plength o1 = C.plength x ∧ (C.min o1 = C.min x ∧ C.max o1 = C.max x) ∧ ¬(1 : ℤ) = (0 : ℤ) ∧ ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ (1 : ℤ)) ∧ Lemmas.value x (0 : ℤ) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (0 : ℕ) * (1 : ℤ) = Lemmas.value x (0 : ℤ) - (1 : ℤ) ∧ C.writable o1 = true) ∧ (∀(xp : C.ptr (BitVec 64)) (i : BitVec 32) (lx : BitVec 64) (b : BitVec 64) (x1 : C.ptr (BitVec 64)), List.length (C.data x1) = List.length (C.data x) ∧ C.offset x1 = C.offset x ∧ C.min x1 = C.min x ∧ C.max x1 = C.max x ∧ C.writable x1 = C.writable x ∧ C.zone1 x1 = C.zone1 x → ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sz) ∧ (i = sz → ¬BitVec.toUInt lx = (0 : ℤ)) ∧ C.offset xp = C.offset x1 + BitVec.toInt i ∧ C.pelts xp = C.pelts x1 ∧ C.plength xp = C.plength x1 ∧ (C.min xp = C.min x1 ∧ C.max xp = C.max x1) ∧ (¬BitVec.toUInt lx = (0 : ℤ)) = (BitVec.toUInt b = (0 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ Lemmas.value x1 (BitVec.toInt i) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt b = Lemmas.value x (BitVec.toInt i) - (1 : ℤ) ∧ C.writable xp = true ∧ (∀(j : ℤ), BitVec.toInt i ≤ j ∧ j < BitVec.toInt sz → C.pelts x1 (C.offset x1 + j) = C.pelts x (C.offset x1 + j)) ∧ (∀(j : ℤ), j < C.offset x1 ∨ C.offset x1 + BitVec.toInt sz ≤ j → C.pelts x1 j = C.pelts x j) → (∀(o2 : Bool), (BitVec.toUInt lx = BitVec.toUInt (0 : BitVec 64) → o2 = true) ∧ (o2 = true → lx = (0 : BitVec 64)) → (if o2 = true then (C.min xp ≤ C.offset xp ∧ C.offset xp < C.max xp) ∧ (∀(res : BitVec 64), BitVec.toUInt res = (BitVec.toUInt (C.pelts xp (C.offset xp)) - (1 : ℤ)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (∀(o3 : Bool), (BitVec.toUInt (C.pelts xp (C.offset xp)) = BitVec.toUInt (0 : BitVec 64) → o3 = true) ∧ (o3 = true → C.pelts xp (C.offset xp) = (0 : BitVec 64)) → (if o3 = true then ((C.min xp ≤ C.offset xp ∧ C.offset xp < C.max xp) ∧ C.writable xp = true) ∧ (∀(xp1 : C.ptr (BitVec 64)) (x2 : C.ptr (BitVec 64)), C.data xp1 = C.data x2 ∧ List.length (C.data x2) = List.length (C.data xp) ∧ C.offset xp1 = C.offset xp ∧ C.min xp1 = C.min xp ∧ C.max xp1 = C.max xp ∧ C.writable xp1 = C.writable xp ∧ C.zone1 xp1 = C.zone1 xp → C.data xp1 = C.data x2 ∧ List.length (C.data x2) = List.length (C.data xp) ∧ C.offset xp1 = C.offset xp ∧ C.min xp1 = C.min xp ∧ C.max xp1 = C.max xp ∧ C.writable xp1 = C.writable xp ∧ C.zone1 xp1 = C.zone1 xp → List.length (C.data x2) = List.length (C.data x1) ∧ C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.max x2 = C.max x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → C.pelts xp1 = Function.update (C.pelts xp) (C.offset xp1) res → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt i + (1 : ℤ) → (C.min xp1 ≤ C.offset xp1 + (1 : ℤ) ∧ C.offset xp1 + (1 : ℤ) ≤ C.max xp1) ∧ (∀(o5 : C.ptr (BitVec 64)), C.offset o5 = C.offset xp1 + (1 : ℤ) ∧ C.plength o5 = C.plength xp1 ∧ C.pelts o5 = C.pelts xp1 ∧ C.data o5 = C.data xp1 ∧ C.min o5 = C.min xp1 ∧ C.max o5 = C.max xp1 ∧ C.zone1 o5 = C.zone1 xp1 ∧ C.writable o5 = C.writable xp1 → ((0 : ℤ) ≤ BitVec.toInt sz - BitVec.toInt i ∧ BitVec.toInt sz - BitVec.toInt o4 < BitVec.toInt sz - BitVec.toInt i) ∧ ((0 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ BitVec.toInt sz) ∧ (o4 = sz → ¬BitVec.toUInt (C.pelts xp (C.offset xp)) = (0 : ℤ)) ∧ C.offset o5 = C.offset x2 + BitVec.toInt o4 ∧ C.pelts o5 = C.pelts x2 ∧ C.plength o5 = C.plength x2 ∧ (C.min o5 = C.min x2 ∧ C.max o5 = C.max x2) ∧ (¬BitVec.toUInt (C.pelts xp (C.offset xp)) = (0 : ℤ)) = (BitVec.toUInt (1 : BitVec 64) = (0 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toUInt (1 : BitVec 64) ∧ BitVec.toUInt (1 : BitVec 64) ≤ (1 : ℤ)) ∧ Lemmas.value x2 (BitVec.toInt o4) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o4)) * BitVec.toUInt (1 : BitVec 64) = Lemmas.value x (BitVec.toInt o4) - (1 : ℤ) ∧ C.writable o5 = true ∧ (∀(j : ℤ), BitVec.toInt o4 ≤ j ∧ j < BitVec.toInt sz → C.pelts x2 (C.offset x2 + j) = C.pelts x (C.offset x2 + j)) ∧ (∀(j : ℤ), j < C.offset x2 ∨ C.offset x2 + BitVec.toInt sz ≤ j → C.pelts x2 j = C.pelts x j)))) else ((C.min xp ≤ C.offset xp ∧ C.offset xp < C.max xp) ∧ C.writable xp = true) ∧ (∀(xp1 : C.ptr (BitVec 64)) (x2 : C.ptr (BitVec 64)), C.data xp1 = C.data x2 ∧ List.length (C.data x2) = List.length (C.data xp) ∧ C.offset xp1 = C.offset xp ∧ C.min xp1 = C.min xp ∧ C.max xp1 = C.max xp ∧ C.writable xp1 = C.writable xp ∧ C.zone1 xp1 = C.zone1 xp → C.data xp1 = C.data x2 ∧ List.length (C.data x2) = List.length (C.data xp) ∧ C.offset xp1 = C.offset xp ∧ C.min xp1 = C.min xp ∧ C.max xp1 = C.max xp ∧ C.writable xp1 = C.writable xp ∧ C.zone1 xp1 = C.zone1 xp → List.length (C.data x2) = List.length (C.data x1) ∧ C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.max x2 = C.max x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → C.pelts xp1 = Function.update (C.pelts xp) (C.offset xp1) res → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt i + (1 : ℤ) → (C.min xp1 ≤ C.offset xp1 + (1 : ℤ) ∧ C.offset xp1 + (1 : ℤ) ≤ C.max xp1) ∧ (∀(o5 : C.ptr (BitVec 64)), C.offset o5 = C.offset xp1 + (1 : ℤ) ∧ C.plength o5 = C.plength xp1 ∧ C.pelts o5 = C.pelts xp1 ∧ C.data o5 = C.data xp1 ∧ C.min o5 = C.min xp1 ∧ C.max o5 = C.max xp1 ∧ C.zone1 o5 = C.zone1 xp1 ∧ C.writable o5 = C.writable xp1 → ((0 : ℤ) ≤ BitVec.toInt sz - BitVec.toInt i ∧ BitVec.toInt sz - BitVec.toInt o4 < BitVec.toInt sz - BitVec.toInt i) ∧ ((0 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ BitVec.toInt sz) ∧ (o4 = sz → ¬BitVec.toUInt (C.pelts xp (C.offset xp)) = (0 : ℤ)) ∧ C.offset o5 = C.offset x2 + BitVec.toInt o4 ∧ C.pelts o5 = C.pelts x2 ∧ C.plength o5 = C.plength x2 ∧ (C.min o5 = C.min x2 ∧ C.max o5 = C.max x2) ∧ (¬BitVec.toUInt (C.pelts xp (C.offset xp)) = (0 : ℤ)) = (BitVec.toUInt (0 : BitVec 64) = (0 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toUInt (0 : BitVec 64) ∧ BitVec.toUInt (0 : BitVec 64) ≤ (1 : ℤ)) ∧ Lemmas.value x2 (BitVec.toInt o4) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o4)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt o4) - (1 : ℤ) ∧ C.writable o5 = true ∧ (∀(j : ℤ), BitVec.toInt o4 ≤ j ∧ j < BitVec.toInt sz → C.pelts x2 (C.offset x2 + j) = C.pelts x (C.offset x2 + j)) ∧ (∀(j : ℤ), j < C.offset x2 ∨ C.offset x2 + BitVec.toInt sz ≤ j → C.pelts x2 j = C.pelts x j))))))) else Lemmas.value x1 (BitVec.toInt sz) = Lemmas.value x (BitVec.toInt sz) - (1 : ℤ) ∧ (∀(j : ℤ), j < C.offset x1 ∨ C.offset x1 + BitVec.toInt sz ≤ j → C.pelts x1 j = C.pelts x j)))))
  := sorry
end sub_1_Sub_1_wmpn_decr_1qtvc
