import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
import pearl.verifythis_2021_lexicographic_permutations_2_vcg.lean.verifythis_2021_lexicographic_permutations_2.ArrayListConversions
import Why3.array.IntArraySorted
import pearl.verifythis_2021_lexicographic_permutations_2_vcg.lean.verifythis_2021_lexicographic_permutations_2.BoxedIntArrays
import Why3.queue.Queue
open Classical
open Lean4Why3
namespace verifythis_2021_lexicographic_permutations_2_Permut_permutqtvc
noncomputable def sorted_sub (a : List ℤ) (l : ℤ) (u : ℤ) := ∀(i1 : ℤ) (i2 : ℤ), l ≤ i1 ∧ i1 < i2 ∧ i2 < u → a[Int.toNat i2]! ≤ a[Int.toNat i1]!
noncomputable def sorted (a : List ℤ) := ∀(i1 : ℤ) (i2 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < i2 ∧ i2 < Int.ofNat (List.length a) → a[Int.toNat i2]! ≤ a[Int.toNat i1]!
noncomputable def le (a1 : List ℤ) (a2 : List ℤ) := List.length a1 = List.length a2 ∧ (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ Int.ofNat (List.length a1)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → a1[Int.toNat j]! = a2[Int.toNat j]!) ∧ (i < Int.ofNat (List.length a1) → a1[Int.toNat i]! < a2[Int.toNat i]!))
noncomputable def lt (a1 : List ℤ) (a2 : List ℤ) := le a1 a2 ∧ ¬a1 = a2
axiom find_eq : List ℤ -> List ℤ -> ℤ -> ℤ
axiom find_eq'def (a1 : List ℤ) (a2 : List ℤ) (i : ℤ) (fact0 : List.length a1 = List.length a2) (fact1 : (0 : ℤ) ≤ i) (fact2 : i ≤ Int.ofNat (List.length a1)) (fact3 : List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a1) = List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a2)) : if i = Int.ofNat (List.length a1) ∨ ¬a1[Int.toNat i]! = a2[Int.toNat i]! then find_eq a1 a2 i = i else find_eq a1 a2 i = find_eq a1 a2 (i + (1 : ℤ))
axiom find_eq'spec'1 (a1 : List ℤ) (a2 : List ℤ) (i : ℤ) (fact0 : List.length a1 = List.length a2) (fact1 : (0 : ℤ) ≤ i) (fact2 : i ≤ Int.ofNat (List.length a1)) (fact3 : List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a1) = List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a2)) : (0 : ℤ) ≤ find_eq a1 a2 i ∧ find_eq a1 a2 i ≤ Int.ofNat (List.length a1)
axiom find_eq'spec'0 (a1 : List ℤ) (a2 : List ℤ) (i : ℤ) (fact0 : List.length a1 = List.length a2) (fact1 : (0 : ℤ) ≤ i) (fact2 : i ≤ Int.ofNat (List.length a1)) (fact3 : List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a1) = List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a2)) : List.drop (0 : ℕ) (List.take (Int.toNat (find_eq a1 a2 i) - (0 : ℕ)) a1) = List.drop (0 : ℕ) (List.take (Int.toNat (find_eq a1 a2 i) - (0 : ℕ)) a2)
axiom find_eq'spec (a1 : List ℤ) (a2 : List ℤ) (i : ℤ) (fact0 : List.length a1 = List.length a2) (fact1 : (0 : ℤ) ≤ i) (fact2 : i ≤ Int.ofNat (List.length a1)) (fact3 : List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a1) = List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a2)) (fact4 : find_eq a1 a2 i < Int.ofNat (List.length a1)) : ¬a1[Int.toNat (find_eq a1 a2 i)]! = a2[Int.toNat (find_eq a1 a2 i)]!
noncomputable def find_le (a1 : List ℤ) (a2 : List ℤ) := if List.length a1 = List.length a2 then let i : ℤ := find_eq a1 a2 (0 : ℤ); if i = Int.ofNat (List.length a1) then true else if a1[Int.toNat i]! < a2[Int.toNat i]! then true else false else false
axiom find_le'spec (a1 : List ℤ) (a2 : List ℤ) : (find_le a1 a2 = true) = le a1 a2
axiom as_num : ℤ -> List ℤ -> ℤ -> ℤ
axiom as_num'def (base : ℤ) (a : List ℤ) (i : ℤ) (fact0 : BoxedIntArrays.boxed base a) (fact1 : (0 : ℤ) ≤ i) (fact2 : i ≤ Int.ofNat (List.length a)) : if i = Int.ofNat (List.length a) then as_num base a i = (0 : ℤ) else as_num base a i = a[Int.toNat i]! * HPow.hPow base (Int.toNat (Int.ofNat (List.length a) - (1 : ℤ) - i)) + as_num base a (i + (1 : ℤ))
axiom as_num'spec (base : ℤ) (a : List ℤ) (i : ℤ) (fact0 : BoxedIntArrays.boxed base a) (fact1 : (0 : ℤ) ≤ i) (fact2 : i ≤ Int.ofNat (List.length a)) : (2 : ℤ) * abs (as_num base a i) < HPow.hPow base (Int.toNat (Int.ofNat (List.length a) - i))
axiom as_number : ℤ -> List ℤ -> ℤ
axiom as_number'def (base : ℤ) (a : List ℤ) (fact0 : BoxedIntArrays.boxed base a) : as_number base a = as_num base a (0 : ℤ)
axiom as_number'spec (base : ℤ) (a : List ℤ) (fact0 : BoxedIntArrays.boxed base a) : abs (as_number base a) ≤ BoxedIntArrays.maxi base a
theorem permut'vc (a : List ℤ) : let base : ℤ := BoxedIntArrays.greater a; (0 : ℤ) ≤ base ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → (2 : ℤ) * abs (a[Int.toNat i]!) < base) → (∀(res : Queue.t (List ℤ)), Queue.seq res = ([] : List (List ℤ)) → (if Int.ofNat (List.length a) = (0 : ℤ) then ∀(res1 : Queue.t (List ℤ)), Queue.seq res1 = Queue.seq res ++ [([] : List ℤ)] → (∀(i1 : ℤ) (i2 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < i2 ∧ i2 < Int.ofNat (List.length (Queue.seq res1)) → lt (ArrayListConversions.of_list ((Queue.seq res1)[Int.toNat i1]!)) (ArrayListConversions.of_list ((Queue.seq res1)[Int.toNat i2]!))) ∧ (∀(a' : List ℤ), List.Perm a a' → ArrayListConversions.to_list_from (0 : ℤ) a' ∈ Queue.seq res1) else ∀(a1 : List ℤ), List.length a1 = List.length a → List.Perm a1 a ∧ IntArraySorted.sorted a1 → (List.Perm a1 a ∧ BoxedIntArrays.boxed base a1 ∧ (∀(a' : List ℤ), List.Perm a' a1 → lt a' a1 → ArrayListConversions.to_list_from (0 : ℤ) a' ∈ Queue.seq res) ∧ (∀(a' : List ℤ), ArrayListConversions.to_list_from (0 : ℤ) a' ∈ Queue.seq res → lt a' a1) ∧ (∀(i1 : ℤ) (i2 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < i2 ∧ i2 < Int.ofNat (List.length (Queue.seq res)) → lt (ArrayListConversions.of_list ((Queue.seq res)[Int.toNat i1]!)) (ArrayListConversions.of_list ((Queue.seq res)[Int.toNat i2]!)))) ∧ (∀(cont_int : ℤ) (cont : Bool) (res1 : Queue.t (List ℤ)) (a2 : List ℤ), List.length a2 = List.length a1 → List.Perm a2 a ∧ BoxedIntArrays.boxed base a2 ∧ (cont_int = (1 : ℤ)) = (cont = true) ∧ (cont = true → (∀(a' : List ℤ), List.Perm a' a2 → lt a' a2 → ArrayListConversions.to_list_from (0 : ℤ) a' ∈ Queue.seq res1)) ∧ (¬cont = true → (∀(a' : List ℤ), List.Perm a' a2 → le a' a2 → ArrayListConversions.to_list_from (0 : ℤ) a' ∈ Queue.seq res1)) ∧ (cont = true → (∀(a' : List ℤ), ArrayListConversions.to_list_from (0 : ℤ) a' ∈ Queue.seq res1 → lt a' a2)) ∧ (¬cont = true → (∀(a' : List ℤ), List.Perm a2 a' → le a2 a' → a2 = a')) ∧ (∀(i1 : ℤ) (i2 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < i2 ∧ i2 < Int.ofNat (List.length (Queue.seq res1)) → lt (ArrayListConversions.of_list ((Queue.seq res1)[Int.toNat i1]!)) (ArrayListConversions.of_list ((Queue.seq res1)[Int.toNat i2]!))) → (if cont = true then ∀(res2 : Queue.t (List ℤ)), Queue.seq res2 = Queue.seq res1 ++ [ArrayListConversions.to_list_from (0 : ℤ) a2] → (∀(a3 : List ℤ), List.length a3 = List.length a2 → (∀(o1 : Bool), List.Perm a3 a2 ∧ (¬o1 = true → a3 = a2 ∧ (∀(a' : List ℤ), List.Perm a3 a' → le a3 a' → a3 = a')) ∧ (o1 = true → lt a2 a3 ∧ (∀(a' : List ℤ), List.Perm a2 a' → lt a2 a' → le a3 a')) → (if o1 = true then ((0 : ℤ) ≤ cont_int ∧ cont_int < cont_int ∨ (0 : ℤ) ≤ BoxedIntArrays.maxi base a2 - as_number base a2 ∧ BoxedIntArrays.maxi base a3 - as_number base a3 < BoxedIntArrays.maxi base a2 - as_number base a2) ∧ List.Perm a3 a ∧ BoxedIntArrays.boxed base a3 ∧ (cont_int = (1 : ℤ)) = (o1 = true) ∧ (o1 = true → (∀(a' : List ℤ), List.Perm a' a3 → lt a' a3 → ArrayListConversions.to_list_from (0 : ℤ) a' ∈ Queue.seq res2)) ∧ (¬o1 = true → (∀(a' : List ℤ), List.Perm a' a3 → le a' a3 → ArrayListConversions.to_list_from (0 : ℤ) a' ∈ Queue.seq res2)) ∧ (o1 = true → (∀(a' : List ℤ), ArrayListConversions.to_list_from (0 : ℤ) a' ∈ Queue.seq res2 → lt a' a3)) ∧ (¬o1 = true → (∀(a' : List ℤ), List.Perm a3 a' → le a3 a' → a3 = a')) ∧ (∀(i1 : ℤ) (i2 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < i2 ∧ i2 < Int.ofNat (List.length (Queue.seq res2)) → lt (ArrayListConversions.of_list ((Queue.seq res2)[Int.toNat i1]!)) (ArrayListConversions.of_list ((Queue.seq res2)[Int.toNat i2]!))) else ((0 : ℤ) ≤ cont_int ∧ (0 : ℤ) < cont_int ∨ cont_int = (0 : ℤ) ∧ (0 : ℤ) ≤ BoxedIntArrays.maxi base a2 - as_number base a2 ∧ BoxedIntArrays.maxi base a3 - as_number base a3 < BoxedIntArrays.maxi base a2 - as_number base a2) ∧ List.Perm a3 a ∧ BoxedIntArrays.boxed base a3 ∧ ((0 : ℤ) = (1 : ℤ)) = (o1 = true) ∧ (o1 = true → (∀(a' : List ℤ), List.Perm a' a3 → lt a' a3 → ArrayListConversions.to_list_from (0 : ℤ) a' ∈ Queue.seq res2)) ∧ (¬o1 = true → (∀(a' : List ℤ), List.Perm a' a3 → le a' a3 → ArrayListConversions.to_list_from (0 : ℤ) a' ∈ Queue.seq res2)) ∧ (o1 = true → (∀(a' : List ℤ), ArrayListConversions.to_list_from (0 : ℤ) a' ∈ Queue.seq res2 → lt a' a3)) ∧ (¬o1 = true → (∀(a' : List ℤ), List.Perm a3 a' → le a3 a' → a3 = a')) ∧ (∀(i1 : ℤ) (i2 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < i2 ∧ i2 < Int.ofNat (List.length (Queue.seq res2)) → lt (ArrayListConversions.of_list ((Queue.seq res2)[Int.toNat i1]!)) (ArrayListConversions.of_list ((Queue.seq res2)[Int.toNat i2]!)))))) else (∀(i1 : ℤ) (i2 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < i2 ∧ i2 < Int.ofNat (List.length (Queue.seq res1)) → lt (ArrayListConversions.of_list ((Queue.seq res1)[Int.toNat i1]!)) (ArrayListConversions.of_list ((Queue.seq res1)[Int.toNat i2]!))) ∧ (∀(a' : List ℤ), List.Perm a2 a' → ArrayListConversions.to_list_from (0 : ℤ) a' ∈ Queue.seq res1)))))
  := sorry
end verifythis_2021_lexicographic_permutations_2_Permut_permutqtvc
