import Why3.Base
import Why3.why3.Ref.Ref
import Why3.exn.Exn
open Classical
open Lean4Why3
namespace verifythis_2019_ghc_sort_Top_cutpointsqtvc
axiom Trans (x : ℤ) (y : ℤ) (z : ℤ) (fact0 : x < y) (fact1 : y < z) : x < z
inductive sorted : List ℤ -> Prop where
 | Sorted_Nil : sorted ([] : List ℤ)
 | Sorted_One (x : ℤ) : sorted (List.cons x ([] : List ℤ))
 | Sorted_Two (x : ℤ) (y : ℤ) (l : List ℤ) : x < y → sorted (List.cons y l) → sorted (List.cons x (List.cons y l))
axiom sorted_mem (l : List ℤ) (x : ℤ) : ((∀(y : ℤ), y ∈ l → x < y) ∧ sorted l) = sorted (List.cons x l)
axiom sorted_append (l1 : List ℤ) (l2 : List ℤ) : (sorted l1 ∧ sorted l2 ∧ (∀(x : ℤ) (y : ℤ), x ∈ l1 → y ∈ l2 → x < y)) = sorted (l1 ++ l2)
axiom Trans1 (x : ℤ) (y : ℤ) (z : ℤ) (fact0 : x ≤ y) (fact1 : y ≤ z) : x ≤ z
inductive sorted1 : List ℤ -> Prop where
 | Sorted_Nil1 : sorted1 ([] : List ℤ)
 | Sorted_One1 (x : ℤ) : sorted1 (List.cons x ([] : List ℤ))
 | Sorted_Two1 (x : ℤ) (y : ℤ) (l : List ℤ) : x ≤ y → sorted1 (List.cons y l) → sorted1 (List.cons x (List.cons y l))
axiom sorted_mem1 (l : List ℤ) (x : ℤ) : ((∀(y : ℤ), y ∈ l → x ≤ y) ∧ sorted1 l) = sorted1 (List.cons x l)
axiom sorted_append1 (l1 : List ℤ) (l2 : List ℤ) : (sorted1 l1 ∧ sorted1 l2 ∧ (∀(x : ℤ) (y : ℤ), x ∈ l1 → y ∈ l2 → x ≤ y)) = sorted1 (l1 ++ l2)
inductive sorted2 : List ℤ -> Prop where
 | Sorted_Nil2 : sorted2 ([] : List ℤ)
 | Sorted_One2 (x : ℤ) : sorted2 (List.cons x ([] : List ℤ))
 | Sorted_Two2 (y : ℤ) (x : ℤ) (l : List ℤ) : y ≤ x → sorted2 (List.cons y l) → sorted2 (List.cons x (List.cons y l))
axiom sorted_mem2 (l : List ℤ) (x : ℤ) : ((∀(y : ℤ), y ∈ l → y ≤ x) ∧ sorted2 l) = sorted2 (List.cons x l)
axiom sorted_append2 (l1 : List ℤ) (l2 : List ℤ) : (sorted2 l1 ∧ sorted2 l2 ∧ (∀(x : ℤ) (y : ℤ), x ∈ l1 → y ∈ l2 → y ≤ x)) = sorted2 (l1 ++ l2)
noncomputable def compat (s : List ℤ) (t : List ℤ) := match (s, t) with | (List.cons x _, List.cons y _) => x ≤ y | (_, _) => True
axiom rev_append_sorted_incr (s : List ℤ) (t : List ℤ) : sorted1 (List.reverse s ++ t) = (sorted2 s ∧ sorted1 t ∧ compat s t)
axiom rev_append_sorted_decr (s : List ℤ) (t : List ℤ) : sorted2 (List.reverse s ++ t) = (sorted1 s ∧ sorted2 t ∧ compat t s)
noncomputable def eqb (b1 : Bool) (b2 : Bool) := Bool.imp b1 b2 && Bool.imp b2 b1
axiom eqb'spec (b1 : Bool) (b2 : Bool) : (eqb b1 b2 = true) = (b1 = b2)
axiom list_seq : Type
axiom inhabited_axiom_list_seq : Inhabited list_seq
attribute [instance] inhabited_axiom_list_seq
axiom list : list_seq -> List ℤ
axiom seq : list_seq -> List ℤ
axiom list_seq'invariant (self : list_seq) : seq self = List.reverse (list self)
noncomputable def list_seq'eq (a : list_seq) (b : list_seq) := list a = list b ∧ seq a = seq b
axiom list_seq'inj (a : list_seq) (b : list_seq) (fact0 : list_seq'eq a b) : a = b
axiom nil : list_seq
axiom nil'def : list nil = ([] : List ℤ) ∧ seq nil = ([] : List ℤ)
theorem cutpoints'vc (s : List ℤ) (fact0 : (0 : ℤ) < Int.ofNat (List.length s)) : let n : ℤ := Int.ofNat (List.length s); ∀(o1 : list_seq), list o1 = List.cons (0 : ℤ) (list nil) → ((1 : ℤ) = (0 : ℤ) + (1 : ℤ) ∧ ((0 : ℤ) < (1 : ℤ) ∧ (1 : ℤ) ≤ n + (1 : ℤ)) ∧ (0 : ℤ) < Int.ofNat (List.length (seq o1)) ∧ (seq o1)[(0 : ℕ)]! = (0 : ℤ) ∧ (seq o1)[Int.toNat (Int.ofNat (List.length (seq o1)) - (1 : ℤ))]! = (0 : ℤ) ∧ (∀(z : ℤ), z ∈ list o1 → (0 : ℤ) ≤ z ∧ z ≤ n) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length (seq o1)) - (1 : ℤ) → (let ck : ℤ := (seq o1)[Int.toNat k]!; let ck1 : ℤ := (seq o1)[Int.toNat (k + (1 : ℤ))]!; (∀(z1 : ℤ) (z2 : ℤ), ck ≤ z1 ∧ z1 < z2 ∧ z2 < ck1 → s[Int.toNat z1]! < s[Int.toNat z2]!) ∨ (∀(z1 : ℤ) (z2 : ℤ), ck ≤ z1 ∧ z1 < z2 ∧ z2 < ck1 → s[Int.toNat z2]! ≤ s[Int.toNat z1]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length (seq o1)) → (seq o1)[Int.toNat i]! ≤ (seq o1)[Int.toNat j]!)) ∧ (∀(cut : list_seq), ((0 : ℤ) < (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ) ∧ (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ) ≤ n + (1 : ℤ)) ∧ (0 : ℤ) < Int.ofNat (List.length (seq cut)) ∧ (seq cut)[(0 : ℕ)]! = (0 : ℤ) ∧ (∀(z : ℤ), z ∈ list cut → (0 : ℤ) ≤ z ∧ z ≤ n) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length (seq cut)) - (1 : ℤ) → (let ck : ℤ := (seq cut)[Int.toNat k]!; let ck1 : ℤ := (seq cut)[Int.toNat (k + (1 : ℤ))]!; (∀(z1 : ℤ) (z2 : ℤ), ck ≤ z1 ∧ z1 < z2 ∧ z2 < ck1 → s[Int.toNat z1]! < s[Int.toNat z2]!) ∨ (∀(z1 : ℤ) (z2 : ℤ), ck ≤ z1 ∧ z1 < z2 ∧ z2 < ck1 → s[Int.toNat z2]! ≤ s[Int.toNat z1]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length (seq cut)) → (seq cut)[Int.toNat i]! ≤ (seq cut)[Int.toNat j]!) → (if (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ) < n then ((0 : ℤ) ≤ (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ) ∧ (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ) < Int.ofNat (List.length s)) ∧ ((0 : ℤ) ≤ (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! ∧ (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! < Int.ofNat (List.length s)) ∧ (((seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ) ≤ (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ) ∧ (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ) ≤ n) ∧ ((∀(z1 : ℤ) (z2 : ℤ), (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! ≤ z1 ∧ z1 < z2 ∧ z2 < (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ) → s[Int.toNat z1]! < s[Int.toNat z2]!) ∨ (∀(z1 : ℤ) (z2 : ℤ), (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! ≤ z1 ∧ z1 < z2 ∧ z2 < (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ) → s[Int.toNat z2]! ≤ s[Int.toNat z1]!))) ∧ (∀(y : ℤ), ((seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ) ≤ y ∧ y ≤ n) ∧ ((∀(z1 : ℤ) (z2 : ℤ), (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! ≤ z1 ∧ z1 < z2 ∧ z2 < y → s[Int.toNat z1]! < s[Int.toNat z2]!) ∨ (∀(z1 : ℤ) (z2 : ℤ), (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! ≤ z1 ∧ z1 < z2 ∧ z2 < y → s[Int.toNat z2]! ≤ s[Int.toNat z1]!)) → (y < n → ((0 : ℤ) ≤ y ∧ y < Int.ofNat (List.length s)) ∧ (let o2 : ℤ := y - (1 : ℤ); (0 : ℤ) ≤ o2 ∧ o2 < Int.ofNat (List.length s))) ∧ (∀(o2 : Bool), (if y < n then let o3 : Bool := (if s[Int.toNat (y - (1 : ℤ))]! < s[Int.toNat y]! then true else false); o2 = eqb o3 (if s[Int.toNat ((seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]!)]! < s[Int.toNat ((seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ))]! then true else false) ∧ (o2 = true) = (o3 = (if s[Int.toNat ((seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]!)]! < s[Int.toNat ((seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ))]! then true else false)) else o2 = false) → (if o2 = true then ((0 : ℤ) ≤ n - y ∧ n - (y + (1 : ℤ)) < n - y) ∧ ((seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ) ≤ y + (1 : ℤ) ∧ y + (1 : ℤ) ≤ n) ∧ ((∀(z1 : ℤ) (z2 : ℤ), (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! ≤ z1 ∧ z1 < z2 ∧ z2 < y + (1 : ℤ) → s[Int.toNat z1]! < s[Int.toNat z2]!) ∨ (∀(z1 : ℤ) (z2 : ℤ), (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! ≤ z1 ∧ z1 < z2 ∧ z2 < y + (1 : ℤ) → s[Int.toNat z2]! ≤ s[Int.toNat z1]!)) else ∀(o3 : list_seq), list o3 = List.cons y (list cut) → ((0 : ℤ) ≤ n - ((seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ)) ∧ n - (y + (1 : ℤ)) < n - ((seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! + (1 : ℤ))) ∧ ((0 : ℤ) < y + (1 : ℤ) ∧ y + (1 : ℤ) ≤ n + (1 : ℤ)) ∧ (0 : ℤ) < Int.ofNat (List.length (seq o3)) ∧ (seq o3)[(0 : ℕ)]! = (0 : ℤ) ∧ (seq o3)[Int.toNat (Int.ofNat (List.length (seq o3)) - (1 : ℤ))]! = y ∧ (∀(z : ℤ), z ∈ list o3 → (0 : ℤ) ≤ z ∧ z ≤ n) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length (seq o3)) - (1 : ℤ) → (let ck : ℤ := (seq o3)[Int.toNat k]!; let ck1 : ℤ := (seq o3)[Int.toNat (k + (1 : ℤ))]!; (∀(z1 : ℤ) (z2 : ℤ), ck ≤ z1 ∧ z1 < z2 ∧ z2 < ck1 → s[Int.toNat z1]! < s[Int.toNat z2]!) ∨ (∀(z1 : ℤ) (z2 : ℤ), ck ≤ z1 ∧ z1 < z2 ∧ z2 < ck1 → s[Int.toNat z2]! ≤ s[Int.toNat z1]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length (seq o3)) → (seq o3)[Int.toNat i]! ≤ (seq o3)[Int.toNat j]!)))) else if (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! < n then ∀(o2 : list_seq), list o2 = List.cons n (list cut) → (seq o2)[(0 : ℕ)]! = (0 : ℤ) ∧ (seq o2)[Int.toNat (Int.ofNat (List.length (seq o2)) - (1 : ℤ))]! = Int.ofNat (List.length s) ∧ (2 : ℤ) ≤ Int.ofNat (List.length (list o2)) ∧ (∀(z : ℤ), z ∈ list o2 → (0 : ℤ) ≤ z ∧ z ≤ Int.ofNat (List.length s)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length (seq o2)) - (1 : ℤ) → (let ck : ℤ := (seq o2)[Int.toNat k]!; let ck1 : ℤ := (seq o2)[Int.toNat (k + (1 : ℤ))]!; (∀(z1 : ℤ) (z2 : ℤ), ck ≤ z1 ∧ z1 < z2 ∧ z2 < ck1 → s[Int.toNat z1]! < s[Int.toNat z2]!) ∨ (∀(z1 : ℤ) (z2 : ℤ), ck ≤ z1 ∧ z1 < z2 ∧ z2 < ck1 → s[Int.toNat z2]! ≤ s[Int.toNat z1]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length (seq o2)) → (seq o2)[Int.toNat i]! ≤ (seq o2)[Int.toNat j]!) else (seq cut)[(0 : ℕ)]! = (0 : ℤ) ∧ (seq cut)[Int.toNat (Int.ofNat (List.length (seq cut)) - (1 : ℤ))]! = Int.ofNat (List.length s) ∧ (2 : ℤ) ≤ Int.ofNat (List.length (list cut)) ∧ (∀(z : ℤ), z ∈ list cut → (0 : ℤ) ≤ z ∧ z ≤ Int.ofNat (List.length s)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length (seq cut)) - (1 : ℤ) → (let ck : ℤ := (seq cut)[Int.toNat k]!; let ck1 : ℤ := (seq cut)[Int.toNat (k + (1 : ℤ))]!; (∀(z1 : ℤ) (z2 : ℤ), ck ≤ z1 ∧ z1 < z2 ∧ z2 < ck1 → s[Int.toNat z1]! < s[Int.toNat z2]!) ∨ (∀(z1 : ℤ) (z2 : ℤ), ck ≤ z1 ∧ z1 < z2 ∧ z2 < ck1 → s[Int.toNat z2]! ≤ s[Int.toNat z1]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length (seq cut)) → (seq cut)[Int.toNat i]! ≤ (seq cut)[Int.toNat j]!)))
  := sorry
end verifythis_2019_ghc_sort_Top_cutpointsqtvc
