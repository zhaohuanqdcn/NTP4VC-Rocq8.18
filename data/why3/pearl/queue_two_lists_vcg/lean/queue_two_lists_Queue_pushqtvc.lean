import Why3.Base
open Classical
open Lean4Why3
namespace queue_two_lists_Queue_pushqtvc
axiom t : Type -> Type
axiom inhabited_axiom_t {α : Type} [Inhabited α] : Inhabited (t α)
attribute [instance] inhabited_axiom_t
axiom front :  {α : Type} -> [Inhabited α] -> t α -> List α
axiom rear :  {α : Type} -> [Inhabited α] -> t α -> List α
axiom seq :  {α : Type} -> [Inhabited α] -> t α -> List α
axiom t'invariant {α : Type} [Inhabited α] (self : t α) : Int.ofNat (List.length (seq self)) = Int.ofNat (List.length (front self)) + Int.ofNat (List.length (rear self)) ∧ ((0 : ℤ) < Int.ofNat (List.length (front self)) → (0 : ℤ) < Int.ofNat (List.length (rear self))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length (seq self)) → (seq self)[Int.toNat i]! = (let n : ℤ := Int.ofNat (List.length (rear self)); if i < n then (rear self)[Int.toNat i]! else (front self)[Int.toNat (Int.ofNat (List.length (front self)) - (1 : ℤ) - (i - n))]!))
noncomputable def t'eq {α : Type} [Inhabited α] (a : t α) (b : t α) := front a = front b ∧ rear a = rear b ∧ seq a = seq b
axiom t'inj {α : Type} [Inhabited α] (a : t α) (b : t α) (fact0 : t'eq a b) : a = b
theorem push'vc {α : Type} [Inhabited α] (q : t α) (x : α) : match rear q with | ([] : List α) => (match front q with | ([] : List α) => (let o1 : List α := seq q ++ [x]; Int.ofNat (List.length o1) = (1 : ℤ) + Int.ofNat (List.length (seq q)) ∧ o1[List.length (seq q)]! = x ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length (seq q)) → o1[Int.toNat i]! = (seq q)[Int.toNat i]!) → (∀(q1 : t α), (Int.ofNat (List.length o1) = Int.ofNat (List.length (front q)) + Int.ofNat (List.length (List.cons x ([] : List α))) ∧ ((0 : ℤ) < Int.ofNat (List.length (front q)) → (0 : ℤ) < Int.ofNat (List.length (List.cons x ([] : List α)))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o1) → o1[Int.toNat i]! = (let n : ℤ := Int.ofNat (List.length (List.cons x ([] : List α))); if i < n then (List.cons x ([] : List α))[Int.toNat i]! else (front q)[Int.toNat (Int.ofNat (List.length (front q)) - (1 : ℤ) - (i - n))]!))) ∧ (o1 = seq q1 ∧ List.cons x ([] : List α) = rear q1 ∧ front q = front q1 → seq q1 = seq q ++ [x]))) | _ => (let o1 : List α := seq q ++ [x]; Int.ofNat (List.length o1) = (1 : ℤ) + Int.ofNat (List.length (seq q)) ∧ o1[List.length (seq q)]! = x ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length (seq q)) → o1[Int.toNat i]! = (seq q)[Int.toNat i]!) → (∀(q1 : t α), (Int.ofNat (List.length o1) = Int.ofNat (List.length (List.cons x (front q))) + Int.ofNat (List.length (rear q)) ∧ ((0 : ℤ) < Int.ofNat (List.length (List.cons x (front q))) → (0 : ℤ) < Int.ofNat (List.length (rear q))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o1) → o1[Int.toNat i]! = (let n : ℤ := Int.ofNat (List.length (rear q)); if i < n then (rear q)[Int.toNat i]! else (List.cons x (front q))[Int.toNat (Int.ofNat (List.length (List.cons x (front q))) - (1 : ℤ) - (i - n))]!))) ∧ (o1 = seq q1 ∧ rear q = rear q1 ∧ List.cons x (front q) = front q1 → seq q1 = seq q ++ [x])))) | _ => (let o1 : List α := seq q ++ [x]; Int.ofNat (List.length o1) = (1 : ℤ) + Int.ofNat (List.length (seq q)) ∧ o1[List.length (seq q)]! = x ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length (seq q)) → o1[Int.toNat i]! = (seq q)[Int.toNat i]!) → (∀(q1 : t α), (Int.ofNat (List.length o1) = Int.ofNat (List.length (List.cons x (front q))) + Int.ofNat (List.length (rear q)) ∧ ((0 : ℤ) < Int.ofNat (List.length (List.cons x (front q))) → (0 : ℤ) < Int.ofNat (List.length (rear q))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o1) → o1[Int.toNat i]! = (let n : ℤ := Int.ofNat (List.length (rear q)); if i < n then (rear q)[Int.toNat i]! else (List.cons x (front q))[Int.toNat (Int.ofNat (List.length (List.cons x (front q))) - (1 : ℤ) - (i - n))]!))) ∧ (o1 = seq q1 ∧ rear q = rear q1 ∧ List.cons x (front q) = front q1 → seq q1 = seq q ++ [x])))
  := sorry
end queue_two_lists_Queue_pushqtvc
