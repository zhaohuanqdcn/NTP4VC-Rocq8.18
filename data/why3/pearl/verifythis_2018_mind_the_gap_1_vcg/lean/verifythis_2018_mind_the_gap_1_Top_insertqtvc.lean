import Why3.Base
open Classical
open Lean4Why3
namespace verifythis_2018_mind_the_gap_1_Top_insertqtvc
axiom char : Type
axiom inhabited_axiom_char : Inhabited char
attribute [instance] inhabited_axiom_char
axiom any_char : char
axiom gap_buffer : Type
axiom inhabited_axiom_gap_buffer : Inhabited gap_buffer
attribute [instance] inhabited_axiom_gap_buffer
axiom a : gap_buffer -> List char
axiom l : gap_buffer -> ℤ
axiom r : gap_buffer -> ℤ
axiom content : gap_buffer -> List char
axiom gap_buffer'invariant (self : gap_buffer) : (0 : ℤ) ≤ l self ∧ l self ≤ r self ∧ r self ≤ Int.ofNat (List.length (a self)) ∧ Int.ofNat (List.length (a self)) = Int.ofNat (List.length (content self)) + r self - l self ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < l self → (content self)[Int.toNat i]! = (getElem! (a self) ∘ Int.toNat) i) ∧ (∀(i : ℤ), l self ≤ i ∧ i < Int.ofNat (List.length (content self)) → (content self)[Int.toNat i]! = (getElem! (a self) ∘ Int.toNat) (i + r self - l self))
noncomputable def gap_buffer'eq (a1 : gap_buffer) (b : gap_buffer) := a a1 = a b ∧ l a1 = l b ∧ r a1 = r b ∧ content a1 = content b
axiom gap_buffer'inj (a1 : gap_buffer) (b : gap_buffer) (fact0 : gap_buffer'eq a1 b) : a1 = b
theorem insert'vc (g : gap_buffer) (x : char) : if l g = r g then ∀(g1 : gap_buffer), content g = content g1 ∧ l g = l g1 → (l g1 = l g ∧ content g1 = content g) ∧ l g1 < r g1 → (let o1 : ℤ := l g1; let o2 : List char := content g1; ((0 : ℤ) ≤ o1 ∧ o1 ≤ Int.ofNat (List.length o2)) ∧ (let o3 : List char := List.drop (Int.toNat o1) o2; let o4 : List char := List.cons x o3; Int.ofNat (List.length o4) = (1 : ℤ) + Int.ofNat (List.length o3) ∧ o4[(0 : ℕ)]! = x ∧ (∀(i : ℤ), (0 : ℤ) < i ∧ i ≤ Int.ofNat (List.length o3) → o4[Int.toNat i]! = o3[Int.toNat (i - (1 : ℤ))]!) → (let o5 : ℤ := l g1; let o6 : List char := content g1; ((0 : ℤ) ≤ o5 ∧ o5 ≤ Int.ofNat (List.length o6)) ∧ (let o7 : List char := List.take (Int.toNat o5) o6; let o8 : List char := o7 ++ o4; Int.ofNat (List.length o8) = Int.ofNat (List.length o7) + Int.ofNat (List.length o4) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o7) → o8[Int.toNat i]! = o7[Int.toNat i]!) ∧ (∀(i : ℤ), Int.ofNat (List.length o7) ≤ i ∧ i < Int.ofNat (List.length o8) → o8[Int.toNat i]! = o4[Int.toNat (i - Int.ofNat (List.length o7))]!) → ((0 : ℤ) ≤ l g1 ∧ l g1 < Int.ofNat (List.length (a g1))) ∧ (List.length (List.set (a g1) (Int.toNat (l g1)) x) = List.length (a g1) → List.length (List.set (a g1) (Int.toNat (l g1)) x) = List.length (a g1) → getElem! (List.set (a g1) (Int.toNat (l g1)) x) ∘ Int.toNat = Function.update (getElem! (a g1) ∘ Int.toNat) (l g1) x → (∀(g2 : gap_buffer), (((0 : ℤ) ≤ l g1 + (1 : ℤ) ∧ l g1 + (1 : ℤ) ≤ r g1 ∧ r g1 ≤ Int.ofNat (List.length (List.set (a g1) (Int.toNat (l g1)) x))) ∧ Int.ofNat (List.length (List.set (a g1) (Int.toNat (l g1)) x)) = Int.ofNat (List.length o8) + r g1 - (l g1 + (1 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < l g1 + (1 : ℤ) → o8[Int.toNat i]! = (getElem! (List.set (a g1) (Int.toNat (l g1)) x) ∘ Int.toNat) i) ∧ (∀(i : ℤ), l g1 + (1 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o8) → o8[Int.toNat i]! = (getElem! (List.set (a g1) (Int.toNat (l g1)) x) ∘ Int.toNat) (i + r g1 - (l g1 + (1 : ℤ))))) ∧ (o8 = content g2 ∧ r g1 = r g2 ∧ l g1 + (1 : ℤ) = l g2 ∧ List.set (a g1) (Int.toNat (l g1)) x = a g2 → l g2 = l g + (1 : ℤ) ∧ content g2 = List.take (Int.toNat (l g)) (content g) ++ List.cons x (List.drop (Int.toNat (l g)) (content g))))))))) else let o1 : ℤ := l g; let o2 : List char := content g; ((0 : ℤ) ≤ o1 ∧ o1 ≤ Int.ofNat (List.length o2)) ∧ (let o3 : List char := List.drop (Int.toNat o1) o2; let o4 : List char := List.cons x o3; Int.ofNat (List.length o4) = (1 : ℤ) + Int.ofNat (List.length o3) ∧ o4[(0 : ℕ)]! = x ∧ (∀(i : ℤ), (0 : ℤ) < i ∧ i ≤ Int.ofNat (List.length o3) → o4[Int.toNat i]! = o3[Int.toNat (i - (1 : ℤ))]!) → (let o5 : ℤ := l g; let o6 : List char := content g; ((0 : ℤ) ≤ o5 ∧ o5 ≤ Int.ofNat (List.length o6)) ∧ (let o7 : List char := List.take (Int.toNat o5) o6; let o8 : List char := o7 ++ o4; Int.ofNat (List.length o8) = Int.ofNat (List.length o7) + Int.ofNat (List.length o4) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o7) → o8[Int.toNat i]! = o7[Int.toNat i]!) ∧ (∀(i : ℤ), Int.ofNat (List.length o7) ≤ i ∧ i < Int.ofNat (List.length o8) → o8[Int.toNat i]! = o4[Int.toNat (i - Int.ofNat (List.length o7))]!) → ((0 : ℤ) ≤ l g ∧ l g < Int.ofNat (List.length (a g))) ∧ (List.length (List.set (a g) (Int.toNat (l g)) x) = List.length (a g) → List.length (List.set (a g) (Int.toNat (l g)) x) = List.length (a g) → getElem! (List.set (a g) (Int.toNat (l g)) x) ∘ Int.toNat = Function.update (getElem! (a g) ∘ Int.toNat) (l g) x → (∀(g1 : gap_buffer), (((0 : ℤ) ≤ l g + (1 : ℤ) ∧ l g + (1 : ℤ) ≤ r g ∧ r g ≤ Int.ofNat (List.length (List.set (a g) (Int.toNat (l g)) x))) ∧ Int.ofNat (List.length (List.set (a g) (Int.toNat (l g)) x)) = Int.ofNat (List.length o8) + r g - (l g + (1 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < l g + (1 : ℤ) → o8[Int.toNat i]! = (getElem! (List.set (a g) (Int.toNat (l g)) x) ∘ Int.toNat) i) ∧ (∀(i : ℤ), l g + (1 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o8) → o8[Int.toNat i]! = (getElem! (List.set (a g) (Int.toNat (l g)) x) ∘ Int.toNat) (i + r g - (l g + (1 : ℤ))))) ∧ (o8 = content g1 ∧ r g = r g1 ∧ l g + (1 : ℤ) = l g1 ∧ List.set (a g) (Int.toNat (l g)) x = a g1 → l g1 = l g + (1 : ℤ) ∧ content g1 = List.take (Int.toNat (l g)) (content g) ++ List.cons x (List.drop (Int.toNat (l g)) (content g))))))))
  := sorry
end verifythis_2018_mind_the_gap_1_Top_insertqtvc
