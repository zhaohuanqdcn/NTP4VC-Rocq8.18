theory verifythis_fm2012_LRS_SuffixSort_sortqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut" "Why3STD.map_MapInjection" "./verifythis_fm2012_LRS_LCP"
begin
definition lt :: "int list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "lt a x y \<longleftrightarrow> (let n :: int = int (length a) in ((0 :: int) \<le> x \<and> x \<le> n) \<and> ((0 :: int) \<le> y \<and> y \<le> n) \<and> (\<exists>(l :: int). is_common_prefix a x y l \<and> y + l < n \<and> (x + l = n \<or> a ! nat (x + l) < a ! nat (y + l))))" for a x y
definition range :: "int list \<Rightarrow> _"
  where "range a \<longleftrightarrow> map_MapInjection.range (nth a o nat) (int (length a))" for a
definition le :: "int list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "le a x y \<longleftrightarrow> x = y \<or> lt a x y" for a x y
definition sorted_sub :: "int list \<Rightarrow> (int \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "sorted_sub a data l u \<longleftrightarrow> (\<forall>(i1 :: int) (i2 :: int). l \<le> i1 \<and> i1 \<le> i2 \<and> i2 < u \<longrightarrow> le a (data i1) (data i2))" for a data l u
definition sorted :: "int list \<Rightarrow> int list \<Rightarrow> _"
  where "sorted a data \<longleftrightarrow> sorted_sub a (nth data o nat) (0 :: int) (int (length data))" for a data
theorem sort'vc:
  fixes data :: "int list"
  fixes a :: "int list"
  assumes fact0: "length data = length a"
  assumes fact1: "range data"
  shows "let o1 :: int = int (length data) - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> (data <~~> data \<and> sorted_sub a (nth data o nat) (0 :: int) (0 :: int) \<and> range data) \<and> (\<forall>(data1 :: int list). length data1 = length data \<longrightarrow> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o1) \<and> data <~~> data1 \<and> sorted_sub a (nth data1 o nat) (0 :: int) i \<and> range data1 \<longrightarrow> (((0 :: int) \<le> i \<and> i \<le> i) \<and> range data1 \<and> data <~~> data1 \<and> sorted_sub a (nth data1 o nat) (0 :: int) i \<and> sorted_sub a (nth data1 o nat) i (i + (1 :: int)) \<and> (\<forall>(k1 :: int) (k2 :: int). ((0 :: int) \<le> k1 \<and> k1 < i) \<and> i + (1 :: int) \<le> k2 \<and> k2 \<le> i \<longrightarrow> le a (data1 ! nat k1) (data1 ! nat k2))) \<and> (\<forall>(j :: int) (data2 :: int list). length data2 = length data1 \<longrightarrow> ((0 :: int) \<le> j \<and> j \<le> i) \<and> range data2 \<and> data <~~> data2 \<and> sorted_sub a (nth data2 o nat) (0 :: int) j \<and> sorted_sub a (nth data2 o nat) j (i + (1 :: int)) \<and> (\<forall>(k1 :: int) (k2 :: int). ((0 :: int) \<le> k1 \<and> k1 < j) \<and> j + (1 :: int) \<le> k2 \<and> k2 \<le> i \<longrightarrow> le a (data2 ! nat k1) (data2 ! nat k2)) \<longrightarrow> ((0 :: int) < j \<longrightarrow> ((0 :: int) \<le> j \<and> j < int (length data2)) \<and> (let o2 :: int = data2 ! nat j; o3 :: int = j - (1 :: int) in ((0 :: int) \<le> o3 \<and> o3 < int (length data2)) \<and> (let o4 :: int = data2 ! nat o3 in ((0 :: int) \<le> o4 \<and> o4 \<le> int (length a)) \<and> (0 :: int) \<le> o2 \<and> o2 \<le> int (length a)))) \<and> (\<forall>(o2 :: bool). (if (0 :: int) < j then let o3 :: int = data2 ! nat j; o4 :: int = data2 ! nat (j - (1 :: int)) in \<exists>(o5 :: int). ((o5 = (0 :: int) \<longrightarrow> o4 = o3) \<and> (o5 < (0 :: int) \<longrightarrow> lt a o4 o3) \<and> ((0 :: int) < o5 \<longrightarrow> lt a o3 o4)) \<and> o2 = (if (0 :: int) < o5 then True else False) else o2 = False) \<longrightarrow> (if o2 = True then let b :: int = j - (1 :: int) in ((0 :: int) \<le> j \<and> j < int (length data2)) \<and> (let t :: int = data2 ! nat j in ((0 :: int) \<le> b \<and> b < int (length data2)) \<and> (let o3 :: int = data2 ! nat b in ((0 :: int) \<le> j \<and> j < int (length data2)) \<and> (length (data2[nat j := o3]) = length data2 \<longrightarrow> nth (data2[nat j := o3]) o nat = (nth data2 o nat)(j := o3) \<longrightarrow> ((0 :: int) \<le> b \<and> b < int (length (data2[nat j := o3]))) \<and> (length (data2[nat b := t, nat j := o3]) = length (data2[nat j := o3]) \<longrightarrow> nth (data2[nat b := t, nat j := o3]) o nat = (nth (data2[nat j := o3]) o nat)(b := t) \<longrightarrow> ((0 :: int) \<le> j \<and> j - (1 :: int) < j) \<and> ((0 :: int) \<le> j - (1 :: int) \<and> j - (1 :: int) \<le> i) \<and> range (data2[nat b := t, nat j := o3]) \<and> data <~~> data2[nat b := t, nat j := o3] \<and> sorted_sub a (nth (data2[nat b := t, nat j := o3]) o nat) (0 :: int) (j - (1 :: int)) \<and> sorted_sub a (nth (data2[nat b := t, nat j := o3]) o nat) (j - (1 :: int)) (i + (1 :: int)) \<and> (\<forall>(k1 :: int) (k2 :: int). ((0 :: int) \<le> k1 \<and> k1 < j - (1 :: int)) \<and> j - (1 :: int) + (1 :: int) \<le> k2 \<and> k2 \<le> i \<longrightarrow> le a (data2[nat b := t, nat j := o3] ! nat k1) (data2[nat b := t, nat j := o3] ! nat k2)))))) else data <~~> data2 \<and> sorted_sub a (nth data2 o nat) (0 :: int) (i + (1 :: int)) \<and> range data2)))) \<and> (data <~~> data1 \<and> sorted_sub a (nth data1 o nat) (0 :: int) (o1 + (1 :: int)) \<and> range data1 \<longrightarrow> sorted a data1 \<and> data <~~> data1))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> sorted a data \<and> data <~~> data)"
  sorry
end
