import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.add.Add
open Classical
open Lean4Why3
namespace mul_Mul_wmpn_mul_1_in_placeqtvc
theorem wmpn_mul_1_in_place'vc (x : C.ptr (BitVec 64)) (sz : BitVec 32) (y : BitVec 64) (fact0 : C.valid x (BitVec.toInt sz)) (fact1 : C.writable x = true) : C.min x ≤ C.offset x + (0 : ℤ) ∧ C.offset x + (0 : ℤ) ≤ C.max x ∧ (∀(o1 : C.ptr (BitVec 64)), C.offset o1 = C.offset x + (0 : ℤ) ∧ C.plength o1 = C.plength x ∧ C.pelts o1 = C.pelts x ∧ C.data o1 = C.data x ∧ C.min o1 = C.min x ∧ C.max o1 = C.max x ∧ C.zone1 o1 = C.zone1 x ∧ C.writable o1 = C.writable x → (((0 : ℤ) ≤ BitVec.toInt sz ∧ BitVec.toInt sz ≤ BitVec.toInt sz) ∧ (0 : ℤ) = BitVec.toInt sz - BitVec.toInt sz ∧ Lemmas.value x (0 : ℤ) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (0 : ℕ) * (0 : ℤ) = Lemmas.value x (0 : ℤ) * BitVec.toUInt y ∧ C.offset o1 = C.offset x + (0 : ℤ) ∧ C.plength o1 = C.plength x ∧ C.min o1 = C.min x ∧ C.max o1 = C.max x ∧ C.pelts o1 = C.pelts x ∧ C.writable o1 = true) ∧ (∀(i : BitVec 32) (up : C.ptr (BitVec 64)) (n : BitVec 32) (cl : BitVec 64) (x1 : C.ptr (BitVec 64)), List.length (C.data x1) = List.length (C.data x) ∧ C.offset x1 = C.offset x ∧ C.min x1 = C.min x ∧ C.max x1 = C.max x ∧ C.writable x1 = C.writable x ∧ C.zone1 x1 = C.zone1 x → ((0 : ℤ) ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ BitVec.toInt sz) ∧ BitVec.toInt i = BitVec.toInt sz - BitVec.toInt n ∧ Lemmas.value x1 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt cl = Lemmas.value x (BitVec.toInt i) * BitVec.toUInt y ∧ C.offset up = C.offset x1 + BitVec.toInt i ∧ C.plength up = C.plength x1 ∧ C.min up = C.min x1 ∧ C.max up = C.max x1 ∧ C.pelts up = C.pelts x1 ∧ C.writable up = true ∧ (∀(j : ℤ), j < C.offset x1 ∨ C.offset x1 + BitVec.toInt i ≤ j → C.pelts x1 j = C.pelts x j) → (∀(o2 : Bool), (BitVec.toInt n = BitVec.toInt (0 : BitVec 32) → o2 = true) ∧ (o2 = true → n = (0 : BitVec 32)) → (if ¬o2 = true then (C.min up ≤ C.offset up ∧ C.offset up < C.max up) ∧ (∀(l : BitVec 64) (h : BitVec 64), BitVec.toUInt l + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt h = BitVec.toUInt (C.pelts up (C.offset up)) * BitVec.toUInt y → (∀(lpl : BitVec 64), BitVec.toUInt lpl = (BitVec.toUInt l + BitVec.toUInt cl) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (∀(o3 : BitVec 64), (if BitVec.toUInt lpl < BitVec.toUInt cl then o3 = (1 : BitVec 64) else o3 = (0 : BitVec 64)) → uint'64_in_bounds (BitVec.toUInt o3 + BitVec.toUInt h) ∧ (∀(o4 : BitVec 64), BitVec.toUInt o4 = BitVec.toUInt o3 + BitVec.toUInt h → BitVec.toUInt lpl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt o4 = BitVec.toUInt (C.pelts up (C.offset up)) * BitVec.toUInt y + BitVec.toUInt cl)) ∧ (∀(cl1 : BitVec 64), BitVec.toUInt lpl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt cl1 = BitVec.toUInt (C.pelts up (C.offset up)) * BitVec.toUInt y + BitVec.toUInt cl → ((C.min up ≤ C.offset up ∧ C.offset up < C.max up) ∧ C.writable up = true) ∧ (∀(up1 : C.ptr (BitVec 64)) (x2 : C.ptr (BitVec 64)), C.data up1 = C.data x2 ∧ List.length (C.data x2) = List.length (C.data up) ∧ C.offset up1 = C.offset up ∧ C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → C.data up1 = C.data x2 ∧ List.length (C.data x2) = List.length (C.data up) ∧ C.offset up1 = C.offset up ∧ C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → List.length (C.data x2) = List.length (C.data x1) ∧ C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.max x2 = C.max x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → C.pelts up1 = Function.update (C.pelts up) (C.offset up1) lpl → (C.min up1 ≤ C.offset up1 + (1 : ℤ) ∧ C.offset up1 + (1 : ℤ) ≤ C.max up1) ∧ (∀(o3 : C.ptr (BitVec 64)), C.offset o3 = C.offset up1 + (1 : ℤ) ∧ C.plength o3 = C.plength up1 ∧ C.pelts o3 = C.pelts up1 ∧ C.data o3 = C.data up1 ∧ C.min o3 = C.min up1 ∧ C.max o3 = C.max up1 ∧ C.zone1 o3 = C.zone1 up1 ∧ C.writable o3 = C.writable up1 → int'32_in_bounds (BitVec.toInt n - (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt n - (1 : ℤ) → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt i + (1 : ℤ) → BitVec.toInt o4 < BitVec.toInt n ∧ ((0 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ BitVec.toInt sz) ∧ BitVec.toInt o5 = BitVec.toInt sz - BitVec.toInt o4 ∧ Lemmas.value x2 (BitVec.toInt o5) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o5)) * BitVec.toUInt cl1 = Lemmas.value x (BitVec.toInt o5) * BitVec.toUInt y ∧ C.offset o3 = C.offset x2 + BitVec.toInt o5 ∧ C.plength o3 = C.plength x2 ∧ C.min o3 = C.min x2 ∧ C.max o3 = C.max x2 ∧ C.pelts o3 = C.pelts x2 ∧ C.writable o3 = true ∧ (∀(j : ℤ), j < C.offset x2 ∨ C.offset x2 + BitVec.toInt o5 ≤ j → C.pelts x2 j = C.pelts x j)))))))) else Lemmas.value x1 (BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz)) * BitVec.toUInt cl = Lemmas.value x (BitVec.toInt sz) * BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset x1 ∨ C.offset x1 + BitVec.toInt sz ≤ j → C.pelts x1 j = C.pelts x j)))))
  := sorry
end mul_Mul_wmpn_mul_1_in_placeqtvc
