theory A_schedule_cpumask_A_schedule_cpumask
  imports "NTP4Verif.NTP4Verif" "Why3STD.Qed_Qed" "Why3STD.Memory_Memory" "../../lib/isabelle/Compound_Compound" "../../lib/isabelle/A_thread_variables_properties_A_thread_variables_properties" "Why3STD.Cint_Cint"
begin
consts l_idle_cpu :: "int \<Rightarrow> int"
consts l_sched_group_cpus :: "addr \<Rightarrow> addr"
consts l_sched_group_mask :: "addr \<Rightarrow> addr"
consts l_group_balance_mask :: "addr \<Rightarrow> addr"
consts l_group_balance_cpu :: "addr \<Rightarrow> int"
consts l_cpu_smt_mask :: "int \<Rightarrow> addr"
definition p_idle_core :: "(addr \<Rightarrow> addr) \<Rightarrow> (addr \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> _"
  where "p_idle_core mptr_0 mint_0 cpu_0 \<longleftrightarrow> (\<forall>(i :: int). \<not>mint_0 (shift (mptr_0 (shift (l_cpu_smt_mask cpu_0) (0 :: int))) i) = (0 :: int) \<longrightarrow> (0 :: int) \<le> i \<longrightarrow> i < l_size \<longrightarrow> \<not>l_idle_cpu i = (0 :: int))" for mptr_0 mint_0 cpu_0
axiomatization where Q_TL_idle_cpu:   "is_uint8 (l_idle_cpu cpu_0)"
  for cpu_0 :: "int"
axiomatization where Q_mask_refl:   "\<not>mint_0 (shift (mptr_0 (shift (l_cpu_smt_mask i) (0 :: int))) i) = (0 :: int)"
 if "(0 :: int) \<le> i"
 and "i < l_size"
  for i :: "int"
  and mint_0 :: "addr \<Rightarrow> int"
  and mptr_0 :: "addr \<Rightarrow> addr"
axiomatization where Q_mask_symm:   "\<not>mint_0 (shift (mptr_0 (shift (l_cpu_smt_mask i) (0 :: int))) j) = (0 :: int)"
 if "\<not>mint_0 (shift (mptr_0 (shift (l_cpu_smt_mask j) (0 :: int))) i) = (0 :: int)"
 and "(0 :: int) \<le> i"
 and "i < l_size"
 and "(0 :: int) \<le> j"
 and "j < l_size"
  for mint_0 :: "addr \<Rightarrow> int"
  and mptr_0 :: "addr \<Rightarrow> addr"
  and j :: "int"
  and i :: "int"
axiomatization where Q_mask_trans:   "\<not>mint_0 (shift (mptr_0 (shift (l_cpu_smt_mask i) (0 :: int))) j) = (0 :: int) \<longrightarrow> \<not>mint_0 (shift (mptr_0 (shift (l_cpu_smt_mask j) (0 :: int))) k) = (0 :: int) \<longrightarrow> (0 :: int) \<le> i \<longrightarrow> i < l_size \<longrightarrow> (0 :: int) \<le> j \<longrightarrow> j < l_size \<longrightarrow> (0 :: int) \<le> k \<longrightarrow> k < l_size \<longrightarrow> \<not>mint_0 (shift (mptr_0 (shift (l_cpu_smt_mask i) (0 :: int))) k) = (0 :: int)"
  for mptr_0 :: "addr \<Rightarrow> addr"
  and i :: "int"
  and mint_0 :: "addr \<Rightarrow> int"
  and j :: "int"
  and k :: "int"
end
