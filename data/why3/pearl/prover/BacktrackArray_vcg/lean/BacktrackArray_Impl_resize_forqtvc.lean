import Why3.Base
import pearl.prover.lib.lean.BacktrackArray.Types
import pearl.prover.lib.lean.Functions.Config
import pearl.prover.lib.lean.Functions.Func
import pearl.prover.lib.lean.Predicates.Pred
import pearl.prover.lib.lean.BacktrackArray.Logic
import pearl.prover.lib.lean.Choice.Choice
open Classical
open Lean4Why3
namespace BacktrackArray_Impl_resize_forqtvc
theorem resize_for'vc {α : Type} [Inhabited α] (tb : Types.t α) (x : ℤ) (fact0 : Logic.correct tb) (fact1 : Int.ofNat (List.length (Types.t.buffer tb)) ≤ x) : let o1 : List (List α) := Types.t.buffer tb; ∀(o2 : List (List α)), List.length o2 = List.length o1 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o2) → o2[Int.toNat i]! = o1[Int.toNat i]!) → (let tbc : Types.t α := Types.t.mk (Types.t.history tb) (Types.t.current_time tb) o2 (Types.t.inv tb); (∀(tbc1 : Types.t α) (tb1 : Types.t α), Types.t.inv tbc1 = Types.t.inv tb → Types.t.inv tb1 = Types.t.inv tb → ((0 : ℤ) < Int.ofNat (List.length (Types.t.buffer tbc1)) ∧ Int.ofNat (List.length (Types.t.buffer tbc1)) ≤ x) ∧ Logic.correct tbc1 ∧ Types.t.history tbc1 = Types.t.history tb1 ∧ Types.t.current_time tbc1 = Types.t.current_time tb1 ∧ Logic.func_of_array (Types.t.buffer tbc1) ([] : List α) = Logic.func_of_array (Types.t.buffer tb1) ([] : List α) → (∀(tb2 : Types.t α), Types.t.buffer tb2 = Types.t.buffer tb1 ∧ Types.t.inv tb2 = Types.t.inv tb1 → Types.t.history tb2 = List.cons (-(1 : ℤ)) (Types.t.history tb1) ∧ Types.t.current_time tb2 = Types.t.current_time tb1 + (1 : ℤ) → (∀(tbc2 : Types.t α), Types.t.buffer tbc2 = Types.t.buffer tbc1 ∧ Types.t.inv tbc2 = Types.t.inv tbc1 → Types.t.history tbc2 = List.cons (-(1 : ℤ)) (Types.t.history tbc1) ∧ Types.t.current_time tbc2 = Types.t.current_time tbc1 + (1 : ℤ) → (let size2 : ℤ := (2 : ℤ) * Int.ofNat (List.length (Types.t.buffer tbc1)); (0 : ℤ) ≤ size2 ∧ (∀(buf2 : List (List α)), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < size2 → buf2[Int.toNat i]! = ([] : List α)) ∧ Int.ofNat (List.length buf2) = size2 → (let buf1 : List (List α) := Types.t.buffer tbc2; (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length (Types.t.buffer tbc1)) ∧ (0 : ℤ) + Int.ofNat (List.length (Types.t.buffer tbc1)) ≤ Int.ofNat (List.length buf1)) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) + Int.ofNat (List.length (Types.t.buffer tbc1)) ≤ Int.ofNat (List.length buf2)) ∧ (∀(buf21 : List (List α)), List.length buf21 = List.length buf2 → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (0 : ℤ) ∨ (0 : ℤ) + Int.ofNat (List.length (Types.t.buffer tbc1)) ≤ i ∧ i < Int.ofNat (List.length buf21) → buf21[Int.toNat i]! = buf2[Int.toNat i]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (0 : ℤ) + Int.ofNat (List.length (Types.t.buffer tbc1)) → buf21[Int.toNat i]! = buf1[Int.toNat ((0 : ℤ) + i - (0 : ℤ))]!) → (∀(tbc3 : Types.t α), Types.t.history tbc3 = Types.t.history tbc2 ∧ Types.t.current_time tbc3 = Types.t.current_time tbc2 ∧ Types.t.buffer tbc3 = buf21 ∧ Types.t.inv tbc3 = Types.t.inv tbc2 → (if x < size2 then Logic.correct tbc3 ∧ (Types.t.history tbc3 = Types.t.history tb2 ∧ Types.t.current_time tbc3 = Types.t.current_time tb2 ∧ Logic.func_of_array (Types.t.buffer tbc3) ([] : List α) = Logic.func_of_array (Types.t.buffer tb2) ([] : List α)) ∧ Int.ofNat (List.length (Types.t.buffer tbc3)) = size2 ∧ x < size2 ∧ Int.ofNat (List.length (Types.t.buffer tbc1)) ≤ size2 ∧ Logic.precede tbc1 tbc3 else (((0 : ℤ) ≤ x - Int.ofNat (List.length (Types.t.buffer tbc1)) ∧ x - size2 < x - Int.ofNat (List.length (Types.t.buffer tbc1))) ∧ ((0 : ℤ) < size2 ∧ size2 ≤ x) ∧ Logic.correct tbc3 ∧ (Types.t.history tbc3 = Types.t.history tb2 ∧ Types.t.current_time tbc3 = Types.t.current_time tb2 ∧ Logic.func_of_array (Types.t.buffer tbc3) ([] : List α) = Logic.func_of_array (Types.t.buffer tb2) ([] : List α)) ∧ Int.ofNat (List.length (Types.t.buffer tbc3)) = size2) ∧ (∀(tbc4 : Types.t α) (tb3 : Types.t α), Types.t.inv tbc4 = Types.t.inv tbc3 → Types.t.buffer tb3 = Types.t.buffer tb2 ∧ Types.t.inv tb3 = Types.t.inv tb2 → Logic.correct tbc4 ∧ (Types.t.history tbc4 = Types.t.history tb3 ∧ Types.t.current_time tbc4 = Types.t.current_time tb3 ∧ Logic.func_of_array (Types.t.buffer tbc4) ([] : List α) = Logic.func_of_array (Types.t.buffer tb3) ([] : List α)) ∧ x < Int.ofNat (List.length (Types.t.buffer tbc4)) ∧ size2 ≤ Int.ofNat (List.length (Types.t.buffer tbc4)) ∧ Logic.precede tbc3 tbc4 → Logic.correct tbc4 ∧ (Types.t.history tbc4 = Types.t.history tb3 ∧ Types.t.current_time tbc4 = Types.t.current_time tb3 ∧ Logic.func_of_array (Types.t.buffer tbc4) ([] : List α) = Logic.func_of_array (Types.t.buffer tb3) ([] : List α)) ∧ x < Int.ofNat (List.length (Types.t.buffer tbc4)) ∧ List.length (Types.t.buffer tbc1) ≤ List.length (Types.t.buffer tbc4) ∧ Logic.precede tbc1 tbc4)))))))))) ∧ (let len : ℤ := Int.ofNat (List.length (Types.t.buffer tb)); (((0 : ℤ) < len ∧ len ≤ x) ∧ Logic.correct tbc ∧ Logic.func_of_array o2 ([] : List α) = Logic.func_of_array (Types.t.buffer tb) ([] : List α) ∧ Int.ofNat (List.length o2) = len) ∧ (∀(tbc1 : Types.t α) (tb1 : Types.t α), Types.t.inv tbc1 = Types.t.inv tb → Types.t.buffer tb1 = Types.t.buffer tb ∧ Types.t.inv tb1 = Types.t.inv tb → Logic.correct tbc1 ∧ (Types.t.history tbc1 = Types.t.history tb1 ∧ Types.t.current_time tbc1 = Types.t.current_time tb1 ∧ Logic.func_of_array (Types.t.buffer tbc1) ([] : List α) = Logic.func_of_array (Types.t.buffer tb1) ([] : List α)) ∧ x < Int.ofNat (List.length (Types.t.buffer tbc1)) ∧ len ≤ Int.ofNat (List.length (Types.t.buffer tbc1)) ∧ Logic.precede tbc tbc1 → (0 : ℤ) ≤ Int.ofNat (List.length (Types.t.buffer tbc1)) ∧ (∀(buf2 : List (List α)), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length (Types.t.buffer tbc1)) → buf2[Int.toNat i]! = ([] : List α)) ∧ List.length buf2 = List.length (Types.t.buffer tbc1) → (let buf1 : List (List α) := Types.t.buffer tb1; (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ len ∧ (0 : ℤ) + len ≤ Int.ofNat (List.length buf1)) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) + len ≤ Int.ofNat (List.length buf2)) ∧ (∀(buf21 : List (List α)), List.length buf21 = List.length buf2 → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (0 : ℤ) ∨ (0 : ℤ) + len ≤ i ∧ i < Int.ofNat (List.length buf21) → buf21[Int.toNat i]! = buf2[Int.toNat i]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (0 : ℤ) + len → buf21[Int.toNat i]! = buf1[Int.toNat ((0 : ℤ) + i - (0 : ℤ))]!) → (∀(tb2 : Types.t α), Types.t.history tb2 = Types.t.history tb1 ∧ Types.t.current_time tb2 = Types.t.current_time tb1 ∧ Types.t.buffer tb2 = buf21 ∧ Types.t.inv tb2 = Types.t.inv tb1 → x < Int.ofNat (List.length (Types.t.buffer tb2)) ∧ Logic.precede tb tb2 ∧ Logic.correct tb2 ∧ Types.timestamp.table (Logic.current_timestamp tb2) = Types.timestamp.table (Logic.current_timestamp tb))))))))
  := sorry
end BacktrackArray_Impl_resize_forqtvc
