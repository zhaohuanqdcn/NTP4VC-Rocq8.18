import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
open Classical
open Lean4Why3
namespace verifythis_2017_pair_insertion_sort_Challenge1_pair_insertion_sortqtvc
theorem pair_insertion_sort'vc (a : List ℤ) : (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length a) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l < (0 : ℤ) → a[Int.toNat k]! ≤ a[Int.toNat l]!) ∧ List.Perm a a ∧ (∀(i : ℤ) (a1 : List ℤ), List.length a1 = List.length a → ((0 : ℤ) ≤ i ∧ i ≤ Int.ofNat (List.length a1)) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l < i → a1[Int.toNat k]! ≤ a1[Int.toNat l]!) ∧ List.Perm a a1 → (if i < Int.ofNat (List.length a1) - (1 : ℤ) then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (let o1 : ℤ := a1[Int.toNat i]!; let o2 : ℤ := i + (1 : ℤ); ((0 : ℤ) ≤ o2 ∧ o2 < Int.ofNat (List.length a1)) ∧ (let o3 : ℤ := a1[Int.toNat o2]!; if o1 < o3 then let o4 : ℤ := i - (1 : ℤ); ((-(1 : ℤ) ≤ o4 ∧ o4 < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ o4 → a1[Int.toNat k]! ≤ a1[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ o4 → o4 + (2 : ℤ) < l ∧ l < i + (2 : ℤ) → a1[Int.toNat k]! ≤ a1[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), o4 + (2 : ℤ) < k ∧ k ≤ l ∧ l < i + (2 : ℤ) → a1[Int.toNat k]! ≤ a1[Int.toNat l]!) ∧ (∀(l : ℤ), o4 + (2 : ℤ) < l ∧ l < i + (2 : ℤ) → o3 < a1[Int.toNat l]!) ∧ List.Perm a (List.set (List.set a1 (Int.toNat (o4 + (1 : ℤ))) o1) (Int.toNat (o4 + (2 : ℤ))) o3)) ∧ (∀(j : ℤ) (a2 : List ℤ), List.length a2 = List.length a1 → (-(1 : ℤ) ≤ j ∧ j < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ j → a2[Int.toNat k]! ≤ a2[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j → j + (2 : ℤ) < l ∧ l < i + (2 : ℤ) → a2[Int.toNat k]! ≤ a2[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), j + (2 : ℤ) < k ∧ k ≤ l ∧ l < i + (2 : ℤ) → a2[Int.toNat k]! ≤ a2[Int.toNat l]!) ∧ (∀(l : ℤ), j + (2 : ℤ) < l ∧ l < i + (2 : ℤ) → o3 < a2[Int.toNat l]!) ∧ List.Perm a (List.set (List.set a2 (Int.toNat (j + (1 : ℤ))) o1) (Int.toNat (j + (2 : ℤ))) o3) → ((0 : ℤ) ≤ j → (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a2)) ∧ (∀(o5 : Bool), (if (0 : ℤ) ≤ j then o5 = (if o3 < a2[Int.toNat j]! then true else false) else o5 = false) → (if o5 = true then ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a2)) ∧ (let o6 : ℤ := a2[Int.toNat j]!; let o7 : ℤ := j + (2 : ℤ); ((0 : ℤ) ≤ o7 ∧ o7 < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat o7) o6) = List.length a2 → getElem! (List.set a2 (Int.toNat o7) o6) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) o7 o6 → ((0 : ℤ) ≤ j ∧ j - (1 : ℤ) < j) ∧ (-(1 : ℤ) ≤ j - (1 : ℤ) ∧ j - (1 : ℤ) < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ j - (1 : ℤ) → (List.set a2 (Int.toNat o7) o6)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o7) o6)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j - (1 : ℤ) → j - (1 : ℤ) + (2 : ℤ) < l ∧ l < i + (2 : ℤ) → (List.set a2 (Int.toNat o7) o6)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o7) o6)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), j - (1 : ℤ) + (2 : ℤ) < k ∧ k ≤ l ∧ l < i + (2 : ℤ) → (List.set a2 (Int.toNat o7) o6)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o7) o6)[Int.toNat l]!) ∧ (∀(l : ℤ), j - (1 : ℤ) + (2 : ℤ) < l ∧ l < i + (2 : ℤ) → o3 < (List.set a2 (Int.toNat o7) o6)[Int.toNat l]!) ∧ List.Perm a (List.set (List.set (List.set a2 (Int.toNat o7) o6) (Int.toNat (j - (1 : ℤ) + (1 : ℤ))) o1) (Int.toNat (j - (1 : ℤ) + (2 : ℤ))) o3))) else let o6 : ℤ := j + (2 : ℤ); ((0 : ℤ) ≤ o6 ∧ o6 < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat o6) o3) = List.length a2 → getElem! (List.set a2 (Int.toNat o6) o3) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) o6 o3 → ((-(1 : ℤ) ≤ j ∧ j < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ j → (List.set a2 (Int.toNat o6) o3)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o6) o3)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j → j + (1 : ℤ) < l ∧ l < i + (2 : ℤ) → (List.set a2 (Int.toNat o6) o3)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o6) o3)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), j + (1 : ℤ) < k ∧ k ≤ l ∧ l < i + (2 : ℤ) → (List.set a2 (Int.toNat o6) o3)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o6) o3)[Int.toNat l]!) ∧ (∀(l : ℤ), j + (1 : ℤ) < l ∧ l < i + (2 : ℤ) → o1 ≤ (List.set a2 (Int.toNat o6) o3)[Int.toNat l]!) ∧ List.Perm a (List.set (List.set a2 (Int.toNat o6) o3) (Int.toNat (j + (1 : ℤ))) o1)) ∧ (∀(j1 : ℤ) (a3 : List ℤ), List.length a3 = List.length (List.set a2 (Int.toNat o6) o3) → (-(1 : ℤ) ≤ j1 ∧ j1 < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ j1 → a3[Int.toNat k]! ≤ a3[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j1 → j1 + (1 : ℤ) < l ∧ l < i + (2 : ℤ) → a3[Int.toNat k]! ≤ a3[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), j1 + (1 : ℤ) < k ∧ k ≤ l ∧ l < i + (2 : ℤ) → a3[Int.toNat k]! ≤ a3[Int.toNat l]!) ∧ (∀(l : ℤ), j1 + (1 : ℤ) < l ∧ l < i + (2 : ℤ) → o1 ≤ a3[Int.toNat l]!) ∧ List.Perm a (List.set a3 (Int.toNat (j1 + (1 : ℤ))) o1) → ((0 : ℤ) ≤ j1 → (0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a3)) ∧ (∀(o7 : Bool), (if (0 : ℤ) ≤ j1 then o7 = (if o1 < a3[Int.toNat j1]! then true else false) else o7 = false) → (if o7 = true then ((0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a3)) ∧ (let o8 : ℤ := a3[Int.toNat j1]!; let o9 : ℤ := j1 + (1 : ℤ); ((0 : ℤ) ≤ o9 ∧ o9 < Int.ofNat (List.length a3)) ∧ (List.length (List.set a3 (Int.toNat o9) o8) = List.length a3 → getElem! (List.set a3 (Int.toNat o9) o8) ∘ Int.toNat = Function.update (getElem! a3 ∘ Int.toNat) o9 o8 → ((0 : ℤ) ≤ j1 ∧ j1 - (1 : ℤ) < j1) ∧ (-(1 : ℤ) ≤ j1 - (1 : ℤ) ∧ j1 - (1 : ℤ) < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ j1 - (1 : ℤ) → (List.set a3 (Int.toNat o9) o8)[Int.toNat k]! ≤ (List.set a3 (Int.toNat o9) o8)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j1 - (1 : ℤ) → j1 - (1 : ℤ) + (1 : ℤ) < l ∧ l < i + (2 : ℤ) → (List.set a3 (Int.toNat o9) o8)[Int.toNat k]! ≤ (List.set a3 (Int.toNat o9) o8)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), j1 - (1 : ℤ) + (1 : ℤ) < k ∧ k ≤ l ∧ l < i + (2 : ℤ) → (List.set a3 (Int.toNat o9) o8)[Int.toNat k]! ≤ (List.set a3 (Int.toNat o9) o8)[Int.toNat l]!) ∧ (∀(l : ℤ), j1 - (1 : ℤ) + (1 : ℤ) < l ∧ l < i + (2 : ℤ) → o1 ≤ (List.set a3 (Int.toNat o9) o8)[Int.toNat l]!) ∧ List.Perm a (List.set (List.set a3 (Int.toNat o9) o8) (Int.toNat (j1 - (1 : ℤ) + (1 : ℤ))) o1))) else let o8 : ℤ := j1 + (1 : ℤ); ((0 : ℤ) ≤ o8 ∧ o8 < Int.ofNat (List.length a3)) ∧ (List.length (List.set a3 (Int.toNat o8) o1) = List.length a3 → getElem! (List.set a3 (Int.toNat o8) o1) ∘ Int.toNat = Function.update (getElem! a3 ∘ Int.toNat) o8 o1 → ((0 : ℤ) ≤ Int.ofNat (List.length a1) - i ∧ Int.ofNat (List.length (List.set a3 (Int.toNat o8) o1)) - (i + (2 : ℤ)) < Int.ofNat (List.length a1) - i) ∧ ((0 : ℤ) ≤ i + (2 : ℤ) ∧ i + (2 : ℤ) ≤ Int.ofNat (List.length (List.set a3 (Int.toNat o8) o1))) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l < i + (2 : ℤ) → (List.set a3 (Int.toNat o8) o1)[Int.toNat k]! ≤ (List.set a3 (Int.toNat o8) o1)[Int.toNat l]!) ∧ List.Perm a (List.set a3 (Int.toNat o8) o1))))))))) else let o4 : ℤ := i - (1 : ℤ); ((-(1 : ℤ) ≤ o4 ∧ o4 < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ o4 → a1[Int.toNat k]! ≤ a1[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ o4 → o4 + (2 : ℤ) < l ∧ l < i + (2 : ℤ) → a1[Int.toNat k]! ≤ a1[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), o4 + (2 : ℤ) < k ∧ k ≤ l ∧ l < i + (2 : ℤ) → a1[Int.toNat k]! ≤ a1[Int.toNat l]!) ∧ (∀(l : ℤ), o4 + (2 : ℤ) < l ∧ l < i + (2 : ℤ) → o1 < a1[Int.toNat l]!) ∧ List.Perm a (List.set (List.set a1 (Int.toNat (o4 + (1 : ℤ))) o3) (Int.toNat (o4 + (2 : ℤ))) o1)) ∧ (∀(j : ℤ) (a2 : List ℤ), List.length a2 = List.length a1 → (-(1 : ℤ) ≤ j ∧ j < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ j → a2[Int.toNat k]! ≤ a2[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j → j + (2 : ℤ) < l ∧ l < i + (2 : ℤ) → a2[Int.toNat k]! ≤ a2[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), j + (2 : ℤ) < k ∧ k ≤ l ∧ l < i + (2 : ℤ) → a2[Int.toNat k]! ≤ a2[Int.toNat l]!) ∧ (∀(l : ℤ), j + (2 : ℤ) < l ∧ l < i + (2 : ℤ) → o1 < a2[Int.toNat l]!) ∧ List.Perm a (List.set (List.set a2 (Int.toNat (j + (1 : ℤ))) o3) (Int.toNat (j + (2 : ℤ))) o1) → ((0 : ℤ) ≤ j → (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a2)) ∧ (∀(o5 : Bool), (if (0 : ℤ) ≤ j then o5 = (if o1 < a2[Int.toNat j]! then true else false) else o5 = false) → (if o5 = true then ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a2)) ∧ (let o6 : ℤ := a2[Int.toNat j]!; let o7 : ℤ := j + (2 : ℤ); ((0 : ℤ) ≤ o7 ∧ o7 < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat o7) o6) = List.length a2 → getElem! (List.set a2 (Int.toNat o7) o6) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) o7 o6 → ((0 : ℤ) ≤ j ∧ j - (1 : ℤ) < j) ∧ (-(1 : ℤ) ≤ j - (1 : ℤ) ∧ j - (1 : ℤ) < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ j - (1 : ℤ) → (List.set a2 (Int.toNat o7) o6)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o7) o6)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j - (1 : ℤ) → j - (1 : ℤ) + (2 : ℤ) < l ∧ l < i + (2 : ℤ) → (List.set a2 (Int.toNat o7) o6)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o7) o6)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), j - (1 : ℤ) + (2 : ℤ) < k ∧ k ≤ l ∧ l < i + (2 : ℤ) → (List.set a2 (Int.toNat o7) o6)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o7) o6)[Int.toNat l]!) ∧ (∀(l : ℤ), j - (1 : ℤ) + (2 : ℤ) < l ∧ l < i + (2 : ℤ) → o1 < (List.set a2 (Int.toNat o7) o6)[Int.toNat l]!) ∧ List.Perm a (List.set (List.set (List.set a2 (Int.toNat o7) o6) (Int.toNat (j - (1 : ℤ) + (1 : ℤ))) o3) (Int.toNat (j - (1 : ℤ) + (2 : ℤ))) o1))) else let o6 : ℤ := j + (2 : ℤ); ((0 : ℤ) ≤ o6 ∧ o6 < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat o6) o1) = List.length a2 → getElem! (List.set a2 (Int.toNat o6) o1) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) o6 o1 → ((-(1 : ℤ) ≤ j ∧ j < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ j → (List.set a2 (Int.toNat o6) o1)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o6) o1)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j → j + (1 : ℤ) < l ∧ l < i + (2 : ℤ) → (List.set a2 (Int.toNat o6) o1)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o6) o1)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), j + (1 : ℤ) < k ∧ k ≤ l ∧ l < i + (2 : ℤ) → (List.set a2 (Int.toNat o6) o1)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o6) o1)[Int.toNat l]!) ∧ (∀(l : ℤ), j + (1 : ℤ) < l ∧ l < i + (2 : ℤ) → o3 ≤ (List.set a2 (Int.toNat o6) o1)[Int.toNat l]!) ∧ List.Perm a (List.set (List.set a2 (Int.toNat o6) o1) (Int.toNat (j + (1 : ℤ))) o3)) ∧ (∀(j1 : ℤ) (a3 : List ℤ), List.length a3 = List.length (List.set a2 (Int.toNat o6) o1) → (-(1 : ℤ) ≤ j1 ∧ j1 < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ j1 → a3[Int.toNat k]! ≤ a3[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j1 → j1 + (1 : ℤ) < l ∧ l < i + (2 : ℤ) → a3[Int.toNat k]! ≤ a3[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), j1 + (1 : ℤ) < k ∧ k ≤ l ∧ l < i + (2 : ℤ) → a3[Int.toNat k]! ≤ a3[Int.toNat l]!) ∧ (∀(l : ℤ), j1 + (1 : ℤ) < l ∧ l < i + (2 : ℤ) → o3 ≤ a3[Int.toNat l]!) ∧ List.Perm a (List.set a3 (Int.toNat (j1 + (1 : ℤ))) o3) → ((0 : ℤ) ≤ j1 → (0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a3)) ∧ (∀(o7 : Bool), (if (0 : ℤ) ≤ j1 then o7 = (if o3 < a3[Int.toNat j1]! then true else false) else o7 = false) → (if o7 = true then ((0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a3)) ∧ (let o8 : ℤ := a3[Int.toNat j1]!; let o9 : ℤ := j1 + (1 : ℤ); ((0 : ℤ) ≤ o9 ∧ o9 < Int.ofNat (List.length a3)) ∧ (List.length (List.set a3 (Int.toNat o9) o8) = List.length a3 → getElem! (List.set a3 (Int.toNat o9) o8) ∘ Int.toNat = Function.update (getElem! a3 ∘ Int.toNat) o9 o8 → ((0 : ℤ) ≤ j1 ∧ j1 - (1 : ℤ) < j1) ∧ (-(1 : ℤ) ≤ j1 - (1 : ℤ) ∧ j1 - (1 : ℤ) < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ j1 - (1 : ℤ) → (List.set a3 (Int.toNat o9) o8)[Int.toNat k]! ≤ (List.set a3 (Int.toNat o9) o8)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j1 - (1 : ℤ) → j1 - (1 : ℤ) + (1 : ℤ) < l ∧ l < i + (2 : ℤ) → (List.set a3 (Int.toNat o9) o8)[Int.toNat k]! ≤ (List.set a3 (Int.toNat o9) o8)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), j1 - (1 : ℤ) + (1 : ℤ) < k ∧ k ≤ l ∧ l < i + (2 : ℤ) → (List.set a3 (Int.toNat o9) o8)[Int.toNat k]! ≤ (List.set a3 (Int.toNat o9) o8)[Int.toNat l]!) ∧ (∀(l : ℤ), j1 - (1 : ℤ) + (1 : ℤ) < l ∧ l < i + (2 : ℤ) → o3 ≤ (List.set a3 (Int.toNat o9) o8)[Int.toNat l]!) ∧ List.Perm a (List.set (List.set a3 (Int.toNat o9) o8) (Int.toNat (j1 - (1 : ℤ) + (1 : ℤ))) o3))) else let o8 : ℤ := j1 + (1 : ℤ); ((0 : ℤ) ≤ o8 ∧ o8 < Int.ofNat (List.length a3)) ∧ (List.length (List.set a3 (Int.toNat o8) o3) = List.length a3 → getElem! (List.set a3 (Int.toNat o8) o3) ∘ Int.toNat = Function.update (getElem! a3 ∘ Int.toNat) o8 o3 → ((0 : ℤ) ≤ Int.ofNat (List.length a1) - i ∧ Int.ofNat (List.length (List.set a3 (Int.toNat o8) o3)) - (i + (2 : ℤ)) < Int.ofNat (List.length a1) - i) ∧ ((0 : ℤ) ≤ i + (2 : ℤ) ∧ i + (2 : ℤ) ≤ Int.ofNat (List.length (List.set a3 (Int.toNat o8) o3))) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l < i + (2 : ℤ) → (List.set a3 (Int.toNat o8) o3)[Int.toNat k]! ≤ (List.set a3 (Int.toNat o8) o3)[Int.toNat l]!) ∧ List.Perm a (List.set a3 (Int.toNat o8) o3))))))))))) else if i = Int.ofNat (List.length a1) - (1 : ℤ) then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (let y : ℤ := a1[Int.toNat i]!; let o1 : ℤ := i - (1 : ℤ); ((-(1 : ℤ) ≤ o1 ∧ o1 < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ o1 → a1[Int.toNat k]! ≤ a1[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ o1 → o1 + (1 : ℤ) < l ∧ l < Int.ofNat (List.length a1) → a1[Int.toNat k]! ≤ a1[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), o1 + (1 : ℤ) < k ∧ k ≤ l ∧ l < Int.ofNat (List.length a1) → a1[Int.toNat k]! ≤ a1[Int.toNat l]!) ∧ (∀(l : ℤ), o1 + (1 : ℤ) < l ∧ l < Int.ofNat (List.length a1) → y < a1[Int.toNat l]!) ∧ List.Perm a (List.set a1 (Int.toNat (o1 + (1 : ℤ))) y)) ∧ (∀(j : ℤ) (a2 : List ℤ), List.length a2 = List.length a1 → (-(1 : ℤ) ≤ j ∧ j < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ j → a2[Int.toNat k]! ≤ a2[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j → j + (1 : ℤ) < l ∧ l < Int.ofNat (List.length a2) → a2[Int.toNat k]! ≤ a2[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), j + (1 : ℤ) < k ∧ k ≤ l ∧ l < Int.ofNat (List.length a2) → a2[Int.toNat k]! ≤ a2[Int.toNat l]!) ∧ (∀(l : ℤ), j + (1 : ℤ) < l ∧ l < Int.ofNat (List.length a2) → y < a2[Int.toNat l]!) ∧ List.Perm a (List.set a2 (Int.toNat (j + (1 : ℤ))) y) → ((0 : ℤ) ≤ j → (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a2)) ∧ (∀(o2 : Bool), (if (0 : ℤ) ≤ j then o2 = (if y < a2[Int.toNat j]! then true else false) else o2 = false) → (if o2 = true then ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a2)) ∧ (let o3 : ℤ := a2[Int.toNat j]!; let o4 : ℤ := j + (1 : ℤ); ((0 : ℤ) ≤ o4 ∧ o4 < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat o4) o3) = List.length a2 → getElem! (List.set a2 (Int.toNat o4) o3) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) o4 o3 → ((0 : ℤ) ≤ j ∧ j - (1 : ℤ) < j) ∧ (-(1 : ℤ) ≤ j - (1 : ℤ) ∧ j - (1 : ℤ) < i) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l ≤ j - (1 : ℤ) → (List.set a2 (Int.toNat o4) o3)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o4) o3)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ j - (1 : ℤ) → j - (1 : ℤ) + (1 : ℤ) < l ∧ l < Int.ofNat (List.length (List.set a2 (Int.toNat o4) o3)) → (List.set a2 (Int.toNat o4) o3)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o4) o3)[Int.toNat l]!) ∧ (∀(k : ℤ) (l : ℤ), j - (1 : ℤ) + (1 : ℤ) < k ∧ k ≤ l ∧ l < Int.ofNat (List.length (List.set a2 (Int.toNat o4) o3)) → (List.set a2 (Int.toNat o4) o3)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o4) o3)[Int.toNat l]!) ∧ (∀(l : ℤ), j - (1 : ℤ) + (1 : ℤ) < l ∧ l < Int.ofNat (List.length (List.set a2 (Int.toNat o4) o3)) → y < (List.set a2 (Int.toNat o4) o3)[Int.toNat l]!) ∧ List.Perm a (List.set (List.set a2 (Int.toNat o4) o3) (Int.toNat (j - (1 : ℤ) + (1 : ℤ))) y))) else let o3 : ℤ := j + (1 : ℤ); ((0 : ℤ) ≤ o3 ∧ o3 < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat o3) y) = List.length a2 → getElem! (List.set a2 (Int.toNat o3) y) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) o3 y → (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l < Int.ofNat (List.length (List.set a2 (Int.toNat o3) y)) → (List.set a2 (Int.toNat o3) y)[Int.toNat k]! ≤ (List.set a2 (Int.toNat o3) y)[Int.toNat l]!) ∧ List.Perm a (List.set a2 (Int.toNat o3) y)))))) else (∀(k : ℤ) (l : ℤ), (0 : ℤ) ≤ k ∧ k ≤ l ∧ l < Int.ofNat (List.length a1) → a1[Int.toNat k]! ≤ a1[Int.toNat l]!) ∧ List.Perm a a1))
  := sorry
end verifythis_2017_pair_insertion_sort_Challenge1_pair_insertion_sortqtvc
