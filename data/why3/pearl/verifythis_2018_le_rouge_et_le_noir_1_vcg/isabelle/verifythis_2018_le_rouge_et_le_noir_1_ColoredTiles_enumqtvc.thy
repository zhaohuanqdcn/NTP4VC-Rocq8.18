theory verifythis_2018_le_rouge_et_le_noir_1_ColoredTiles_enumqtvc
  imports "NTP4Verif.NTP4Verif"
begin
datatype  color = Red | Black
typedecl  coloring
definition tworedneighbors :: "color list \<Rightarrow> int \<Rightarrow> _"
  where "tworedneighbors c i \<longleftrightarrow> c ! nat (i - (2 :: int)) = Red \<and> c ! nat (i - (1 :: int)) = Red \<and> (2 :: int) \<le> i \<or> c ! nat (i - (1 :: int)) = Red \<and> c ! nat (i + (1 :: int)) = Red \<and> (1 :: int) \<le> i \<and> i \<le> int (length c) - (2 :: int) \<or> c ! nat (i + (1 :: int)) = Red \<and> c ! nat (i + (2 :: int)) = Red \<and> i \<le> int (length c) - (3 :: int)" for c i
definition valid :: "color list \<Rightarrow> _"
  where "valid c \<longleftrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length c) \<longrightarrow> c ! nat i = Red \<longrightarrow> tworedneighbors c i)" for c
consts first_black_tile :: "color list \<Rightarrow> int"
axiomatization where first_black_tile'def:   "if int (length c) = (0 :: int) then first_black_tile c = (0 :: int) else (case c ! (0 :: nat) of Black \<Rightarrow> first_black_tile c = (0 :: int) | Red \<Rightarrow> first_black_tile c = (1 :: int) + first_black_tile (drop (1 :: nat) c))"
  for c :: "color list"
axiomatization where first_black_tile'spec'2'0:   "(0 :: int) \<le> first_black_tile c"
  for c :: "color list"
axiomatization where first_black_tile'spec'2'1:   "first_black_tile c \<le> int (length c)"
  for c :: "color list"
axiomatization where first_black_tile'spec'1:   "c ! nat j = Red"
 if "(0 :: int) \<le> j"
 and "j < first_black_tile c"
 and "first_black_tile c \<le> int (length c)"
  for j :: "int"
  and c :: "color list"
axiomatization where first_black_tile'spec'0:   "c ! nat (first_black_tile c) = Black"
 if "first_black_tile c < int (length c)"
  for c :: "color list"
axiomatization where first_black_tile'spec:   "first_black_tile c = (0 :: int) \<or> (3 :: int) \<le> first_black_tile c"
 if "valid c"
  for c :: "color list"
consts addleft :: "int \<Rightarrow> color list \<Rightarrow> color list"
axiomatization where addleft'def:   "if nr \<le> (0 :: int) then addleft nr c = Cons Black c else addleft nr c = Cons Red (addleft (nr - (1 :: int)) c)"
  for nr :: "int"
  and c :: "color list"
axiomatization where addleft'spec:   "int (length (addleft nr c)) = int (length c) + nr + (1 :: int)"
 if "(0 :: int) \<le> nr"
  for nr :: "int"
  and c :: "color list"
consts addleft_closure :: "int \<Rightarrow> color list \<Rightarrow> color list"
axiomatization where addleft_closure_def:   "addleft_closure y y1 = addleft y y1"
  for y :: "int"
  and y1 :: "color list"
definition mapaddleft :: "color list fset \<Rightarrow> int \<Rightarrow> color list fset"
  where "mapaddleft s nr = addleft_closure nr |`| s" for s nr
definition reciprocal :: "('a \<Rightarrow> 'b) \<Rightarrow> ('b \<Rightarrow> 'a) \<Rightarrow> _"
  where "reciprocal f g \<longleftrightarrow> (\<forall>(y :: 'a). g (f y) = y)" for f g
definition rmleft :: "int \<Rightarrow> color list \<Rightarrow> color list"
  where "rmleft nr c = drop (nat (nr + (1 :: int))) c" for nr c
consts fc :: "int \<Rightarrow> color"
consts fc1 :: "int \<Rightarrow> color"
consts fc2 :: "int \<Rightarrow> color"
consts fc3 :: "int \<Rightarrow> color"
consts fc4 :: "int \<Rightarrow> color"
consts fc5 :: "int \<Rightarrow> color"
consts fc6 :: "int \<Rightarrow> color"
axiomatization where fc'def:   "fc y0 = Black"
  for y0 :: "int"
axiomatization where fc'def1:   "fc1 y0 = Black"
  for y0 :: "int"
axiomatization where fc'def2:   "fc2 y0 = Black"
  for y0 :: "int"
axiomatization where fc'def3:   "fc3 y0 = Red"
  for y0 :: "int"
axiomatization where fc'def4:   "fc4 y0 = Black"
  for y0 :: "int"
axiomatization where fc'def5:   "fc5 y0 = Red"
  for y0 :: "int"
axiomatization where fc'def6:   "fc6 y0 = Red"
  for y0 :: "int"
theorem enum'vc:
  shows "(0 :: int) \<le> (51 :: int)"
  and "\<forall>(count :: int list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (51 :: int) \<longrightarrow> count ! nat i = (0 :: int)) \<and> int (length count) = (51 :: int) \<longrightarrow> (0 :: int) \<le> (51 :: int) \<and> (\<forall>(sets :: color list fset list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (51 :: int) \<longrightarrow> sets ! nat i = fempty) \<and> int (length sets) = (51 :: int) \<longrightarrow> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length count)) \<and> (length (count[nat (0 :: int) := 1 :: int]) = length count \<longrightarrow> nth (count[nat (0 :: int) := 1 :: int]) o nat = (nth count o nat)(0 :: int := 1 :: int) \<longrightarrow> (let o1 :: color list fset = finsert (create_list (0 :: int) fc) fempty in ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length sets)) \<and> (length (sets[nat (0 :: int) := o1]) = length sets \<longrightarrow> nth (sets[nat (0 :: int) := o1]) o nat = (nth sets o nat)(0 :: int := o1) \<longrightarrow> ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) < int (length (count[nat (0 :: int) := 1 :: int]))) \<and> (length (count[nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int]) = length (count[nat (0 :: int) := 1 :: int]) \<longrightarrow> nth (count[nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int]) o nat = (nth (count[nat (0 :: int) := 1 :: int]) o nat)(1 :: int := 1 :: int) \<longrightarrow> (let o2 :: color list fset = finsert (create_list (1 :: int) fc1) fempty in ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) < int (length (sets[nat (0 :: int) := o1]))) \<and> (length (sets[nat (1 :: int) := o2, nat (0 :: int) := o1]) = length (sets[nat (0 :: int) := o1]) \<longrightarrow> nth (sets[nat (1 :: int) := o2, nat (0 :: int) := o1]) o nat = (nth (sets[nat (0 :: int) := o1]) o nat)(1 :: int := o2) \<longrightarrow> ((0 :: int) \<le> (2 :: int) \<and> (2 :: int) < int (length (count[nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int]))) \<and> (length (count[nat (2 :: int) := 1 :: int, nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int]) = length (count[nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int]) \<longrightarrow> nth (count[nat (2 :: int) := 1 :: int, nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int]) o nat = (nth (count[nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int]) o nat)(2 :: int := 1 :: int) \<longrightarrow> (let o3 :: color list fset = finsert (create_list (2 :: int) fc2) fempty in ((0 :: int) \<le> (2 :: int) \<and> (2 :: int) < int (length (sets[nat (1 :: int) := o2, nat (0 :: int) := o1]))) \<and> (length (sets[nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1]) = length (sets[nat (1 :: int) := o2, nat (0 :: int) := o1]) \<longrightarrow> nth (sets[nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1]) o nat = (nth (sets[nat (1 :: int) := o2, nat (0 :: int) := o1]) o nat)(2 :: int := o3) \<longrightarrow> ((0 :: int) \<le> (3 :: int) \<and> (3 :: int) < int (length (count[nat (2 :: int) := 1 :: int, nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int]))) \<and> (length (count[nat (3 :: int) := 2 :: int, nat (2 :: int) := 1 :: int, nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int]) = length (count[nat (2 :: int) := 1 :: int, nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int]) \<longrightarrow> nth (count[nat (3 :: int) := 2 :: int, nat (2 :: int) := 1 :: int, nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int]) o nat = (nth (count[nat (2 :: int) := 1 :: int, nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int]) o nat)(3 :: int := 2 :: int) \<longrightarrow> (let o4 :: color list fset = finsert (create_list (3 :: int) fc3) (finsert (create_list (3 :: int) fc4) fempty) in ((0 :: int) \<le> (3 :: int) \<and> (3 :: int) < int (length (sets[nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1]))) \<and> (length (sets[nat (3 :: int) := o4, nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1]) = length (sets[nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1]) \<longrightarrow> nth (sets[nat (3 :: int) := o4, nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1]) o nat = (nth (sets[nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1]) o nat)(3 :: int := o4) \<longrightarrow> ((4 :: int) \<le> (50 :: int) + (1 :: int) \<longrightarrow> ((\<forall>(c :: color list). (0 :: int) \<le> int (length c) \<and> int (length c) < (4 :: int) \<longrightarrow> valid c \<longrightarrow> c |\<in>| sets[nat (3 :: int) := o4, nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1] ! length c) \<and> (\<forall>(c :: color list) (i :: int). (0 :: int) \<le> i \<and> i < (4 :: int) \<longrightarrow> c |\<in>| sets[nat (3 :: int) := o4, nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1] ! nat i \<longrightarrow> int (length c) = i \<and> valid c) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (4 :: int) \<longrightarrow> count[nat (3 :: int) := 2 :: int, nat (2 :: int) := 1 :: int, nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int] ! nat i = int (fcard (sets[nat (3 :: int) := o4, nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1] ! nat i)))) \<and> (\<forall>(sets1 :: color list fset list) (count1 :: int list). length sets1 = length (sets[nat (3 :: int) := o4, nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1]) \<longrightarrow> length count1 = length (count[nat (3 :: int) := 2 :: int, nat (2 :: int) := 1 :: int, nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int]) \<longrightarrow> (\<forall>(n :: int). ((4 :: int) \<le> n \<and> n \<le> (50 :: int)) \<and> (\<forall>(c :: color list). (0 :: int) \<le> int (length c) \<and> int (length c) < n \<longrightarrow> valid c \<longrightarrow> c |\<in>| sets1 ! length c) \<and> (\<forall>(c :: color list) (i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> c |\<in>| sets1 ! nat i \<longrightarrow> int (length c) = i \<and> valid c) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> count1 ! nat i = int (fcard (sets1 ! nat i))) \<longrightarrow> (let o5 :: int = n - (1 :: int) in ((0 :: int) \<le> o5 \<and> o5 < int (length count1)) \<and> (let o6 :: int = count1 ! nat o5 in ((0 :: int) \<le> n \<and> n < int (length count1)) \<and> (length (count1[nat n := o6]) = length count1 \<longrightarrow> nth (count1[nat n := o6]) o nat = (nth count1 o nat)(n := o6) \<longrightarrow> (let o7 :: int = n - (1 :: int) in ((0 :: int) \<le> o7 \<and> o7 < int (length sets1)) \<and> (let o8 :: color list fset = mapaddleft (sets1 ! nat o7) (0 :: int) in ((0 :: int) \<le> n \<and> n < int (length sets1)) \<and> (length (sets1[nat n := o8]) = length sets1 \<longrightarrow> nth (sets1[nat n := o8]) o nat = (nth sets1 o nat)(n := o8) \<longrightarrow> (let o9 :: int = n - (1 :: int) in ((3 :: int) \<le> o9 + (1 :: int) \<longrightarrow> ((\<forall>(c :: color list). (0 :: int) \<le> int (length c) \<and> int (length c) < n \<longrightarrow> valid c \<longrightarrow> c |\<in>| sets1[nat n := o8] ! length c) \<and> (\<forall>(c :: color list) (i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> c |\<in>| sets1[nat n := o8] ! nat i \<longrightarrow> int (length c) = i \<and> valid c) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> count1[nat n := o6] ! nat i = int (fcard (sets1[nat n := o8] ! nat i))) \<and> (\<forall>(c :: color list). c |\<in>| sets1[nat n := o8] ! nat n \<longleftrightarrow> int (length c) = n \<and> valid c \<and> first_black_tile c < (3 :: int)) \<and> count1[nat n := o6] ! nat n = int (fcard (sets1[nat n := o8] ! nat n))) \<and> (\<forall>(sets2 :: color list fset list) (count2 :: int list). length sets2 = length (sets1[nat n := o8]) \<longrightarrow> length count2 = length (count1[nat n := o6]) \<longrightarrow> (\<forall>(k :: int). ((3 :: int) \<le> k \<and> k \<le> o9) \<and> (\<forall>(c :: color list). (0 :: int) \<le> int (length c) \<and> int (length c) < n \<longrightarrow> valid c \<longrightarrow> c |\<in>| sets2 ! length c) \<and> (\<forall>(c :: color list) (i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> c |\<in>| sets2 ! nat i \<longrightarrow> int (length c) = i \<and> valid c) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> count2 ! nat i = int (fcard (sets2 ! nat i))) \<and> (\<forall>(c :: color list). c |\<in>| sets2 ! nat n \<longleftrightarrow> int (length c) = n \<and> valid c \<and> first_black_tile c < k) \<and> count2 ! nat n = int (fcard (sets2 ! nat n)) \<longrightarrow> (let o10 :: int = n - k - (1 :: int) in ((0 :: int) \<le> o10 \<and> o10 < int (length count2)) \<and> ((0 :: int) \<le> n \<and> n < int (length count2)) \<and> (let o11 :: int = count2 ! nat n + count2 ! nat o10 in ((0 :: int) \<le> n \<and> n < int (length count2)) \<and> (length (count2[nat n := o11]) = length count2 \<longrightarrow> nth (count2[nat n := o11]) o nat = (nth count2 o nat)(n := o11) \<longrightarrow> (let o12 :: int = n - k - (1 :: int) in ((0 :: int) \<le> o12 \<and> o12 < int (length sets2)) \<and> (let ns :: color list fset = mapaddleft (sets2 ! nat o12) k in ((0 :: int) \<le> n \<and> n < int (length sets2)) \<and> (let o13 :: color list fset = sets2 ! nat n in (\<forall>(x :: color list). x |\<in>| o13 \<longrightarrow> \<not>x |\<in>| ns) \<and> (let o14 :: color list fset = o13 |\<union>| ns in int (fcard o14) = int (fcard o13) + int (fcard ns) \<longrightarrow> ((0 :: int) \<le> n \<and> n < int (length sets2)) \<and> (length (sets2[nat n := o14]) = length sets2 \<longrightarrow> nth (sets2[nat n := o14]) o nat = (nth sets2 o nat)(n := o14) \<longrightarrow> (\<forall>(c :: color list). (0 :: int) \<le> int (length c) \<and> int (length c) < n \<longrightarrow> valid c \<longrightarrow> c |\<in>| sets2[nat n := o14] ! length c) \<and> (\<forall>(c :: color list) (i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> c |\<in>| sets2[nat n := o14] ! nat i \<longrightarrow> int (length c) = i \<and> valid c) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> count2[nat n := o11] ! nat i = int (fcard (sets2[nat n := o14] ! nat i))) \<and> (\<forall>(c :: color list). c |\<in>| sets2[nat n := o14] ! nat n \<longleftrightarrow> int (length c) = n \<and> valid c \<and> first_black_tile c < k + (1 :: int)) \<and> count2[nat n := o11] ! nat n = int (fcard (sets2[nat n := o14] ! nat n))))))))))) \<and> ((\<forall>(c :: color list). (0 :: int) \<le> int (length c) \<and> int (length c) < n \<longrightarrow> valid c \<longrightarrow> c |\<in>| sets2 ! length c) \<and> (\<forall>(c :: color list) (i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> c |\<in>| sets2 ! nat i \<longrightarrow> int (length c) = i \<and> valid c) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> count2 ! nat i = int (fcard (sets2 ! nat i))) \<and> (\<forall>(c :: color list). c |\<in>| sets2 ! nat n \<longleftrightarrow> int (length c) = n \<and> valid c \<and> first_black_tile c < o9 + (1 :: int)) \<and> count2 ! nat n = int (fcard (sets2 ! nat n)) \<longrightarrow> (let o10 :: int \<Rightarrow> color = fc5 in (0 :: int) \<le> n \<and> (let r :: color list = create_list n o10 in int (length r) = n \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> r ! nat i = o10 i) \<longrightarrow> (let sr :: color list fset = finsert r fempty in ((0 :: int) \<le> n \<and> n < int (length count2)) \<and> (let o11 :: int = count2 ! nat n + (1 :: int) in ((0 :: int) \<le> n \<and> n < int (length count2)) \<and> (length (count2[nat n := o11]) = length count2 \<longrightarrow> nth (count2[nat n := o11]) o nat = (nth count2 o nat)(n := o11) \<longrightarrow> ((0 :: int) \<le> n \<and> n < int (length sets2)) \<and> (let o12 :: color list fset = sets2 ! nat n in (\<forall>(x :: color list). x |\<in>| o12 \<longrightarrow> \<not>x |\<in>| sr) \<and> (let o13 :: color list fset = o12 |\<union>| sr in int (fcard o13) = int (fcard o12) + int (fcard sr) \<longrightarrow> ((0 :: int) \<le> n \<and> n < int (length sets2)) \<and> (length (sets2[nat n := o13]) = length sets2 \<longrightarrow> nth (sets2[nat n := o13]) o nat = (nth sets2 o nat)(n := o13) \<longrightarrow> (\<forall>(c :: color list). (0 :: int) \<le> int (length c) \<and> int (length c) < n + (1 :: int) \<longrightarrow> valid c \<longrightarrow> c |\<in>| sets2[nat n := o13] ! length c) \<and> (\<forall>(c :: color list) (i :: int). (0 :: int) \<le> i \<and> i < n + (1 :: int) \<longrightarrow> c |\<in>| sets2[nat n := o13] ! nat i \<longrightarrow> int (length c) = i \<and> valid c) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n + (1 :: int) \<longrightarrow> count2[nat n := o11] ! nat i = int (fcard (sets2[nat n := o13] ! nat i)))))))))))))) \<and> (o9 + (1 :: int) < (3 :: int) \<longrightarrow> (let o10 :: int \<Rightarrow> color = fc6 in (0 :: int) \<le> n \<and> (let r :: color list = create_list n o10 in int (length r) = n \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> r ! nat i = o10 i) \<longrightarrow> (let sr :: color list fset = finsert r fempty in ((0 :: int) \<le> n \<and> n < int (length (count1[nat n := o6]))) \<and> (let o11 :: int = count1[nat n := o6] ! nat n + (1 :: int) in ((0 :: int) \<le> n \<and> n < int (length (count1[nat n := o6]))) \<and> (length (count1[nat n := o11, nat n := o6]) = length (count1[nat n := o6]) \<longrightarrow> nth (count1[nat n := o11, nat n := o6]) o nat = (nth (count1[nat n := o6]) o nat)(n := o11) \<longrightarrow> ((0 :: int) \<le> n \<and> n < int (length (sets1[nat n := o8]))) \<and> (let o12 :: color list fset = sets1[nat n := o8] ! nat n in (\<forall>(x :: color list). x |\<in>| o12 \<longrightarrow> \<not>x |\<in>| sr) \<and> (let o13 :: color list fset = o12 |\<union>| sr in int (fcard o13) = int (fcard o12) + int (fcard sr) \<longrightarrow> ((0 :: int) \<le> n \<and> n < int (length (sets1[nat n := o8]))) \<and> (length (sets1[nat n := o13, nat n := o8]) = length (sets1[nat n := o8]) \<longrightarrow> nth (sets1[nat n := o13, nat n := o8]) o nat = (nth (sets1[nat n := o8]) o nat)(n := o13) \<longrightarrow> (\<forall>(c :: color list). (0 :: int) \<le> int (length c) \<and> int (length c) < n + (1 :: int) \<longrightarrow> valid c \<longrightarrow> c |\<in>| sets1[nat n := o13, nat n := o8] ! length c) \<and> (\<forall>(c :: color list) (i :: int). (0 :: int) \<le> i \<and> i < n + (1 :: int) \<longrightarrow> c |\<in>| sets1[nat n := o13, nat n := o8] ! nat i \<longrightarrow> int (length c) = i \<and> valid c) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n + (1 :: int) \<longrightarrow> count1[nat n := o11, nat n := o6] ! nat i = int (fcard (sets1[nat n := o13, nat n := o8] ! nat i)))))))))))))))))))) \<and> ((\<forall>(c :: color list). (0 :: int) \<le> int (length c) \<and> int (length c) < (50 :: int) + (1 :: int) \<longrightarrow> valid c \<longrightarrow> c |\<in>| sets1 ! length c) \<and> (\<forall>(c :: color list) (i :: int). (0 :: int) \<le> i \<and> i < (50 :: int) + (1 :: int) \<longrightarrow> c |\<in>| sets1 ! nat i \<longrightarrow> int (length c) = i \<and> valid c) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (50 :: int) + (1 :: int) \<longrightarrow> count1 ! nat i = int (fcard (sets1 ! nat i))) \<longrightarrow> (int (length count1) = (51 :: int) \<and> (51 :: int) = int (length sets1)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (50 :: int) \<longrightarrow> (\<forall>(c :: color list). int (length c) = i \<longrightarrow> valid c \<longleftrightarrow> c |\<in>| sets1 ! nat i)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (50 :: int) \<longrightarrow> count1 ! nat i = int (fcard (sets1 ! nat i)))))) \<and> ((50 :: int) + (1 :: int) < (4 :: int) \<longrightarrow> (int (length (count[nat (3 :: int) := 2 :: int, nat (2 :: int) := 1 :: int, nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int])) = (51 :: int) \<and> (51 :: int) = int (length (sets[nat (3 :: int) := o4, nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1]))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (50 :: int) \<longrightarrow> (\<forall>(c :: color list). int (length c) = i \<longrightarrow> valid c \<longleftrightarrow> c |\<in>| sets[nat (3 :: int) := o4, nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1] ! nat i)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (50 :: int) \<longrightarrow> count[nat (3 :: int) := 2 :: int, nat (2 :: int) := 1 :: int, nat (1 :: int) := 1 :: int, nat (0 :: int) := 1 :: int] ! nat i = int (fcard (sets[nat (3 :: int) := o4, nat (2 :: int) := o3, nat (1 :: int) := o2, nat (0 :: int) := o1] ! nat i)))))))))))))))))"
  sorry
end
