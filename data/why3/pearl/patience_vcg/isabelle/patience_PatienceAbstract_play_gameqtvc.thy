theory patience_PatienceAbstract_play_gameqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "./patience_PigeonHole"
begin
typedecl  card
datatype  state = state'mk (num_stacks: "int") (num_elts: "int") ("values": "int \<Rightarrow> int") (stack_sizes: "int \<Rightarrow> int") (stacks1: "int \<Rightarrow> int \<Rightarrow> int") (positions: "int \<Rightarrow> int \<times> int") (preds: "int \<Rightarrow> int")
definition inv :: "state \<Rightarrow> _"
  where "inv s \<longleftrightarrow> ((0 :: int) \<le> num_stacks s \<and> num_stacks s \<le> num_elts s) \<and> ((0 :: int) < num_elts s \<longrightarrow> (0 :: int) < num_stacks s) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_stacks s \<longrightarrow> (1 :: int) \<le> stack_sizes s i \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < stack_sizes s i \<longrightarrow> (0 :: int) \<le> stacks1 s i j \<and> stacks1 s i j < num_elts s)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_elts s \<longrightarrow> (case positions s i of (is, ip) \<Rightarrow> ((0 :: int) \<le> is \<and> is < num_stacks s) \<and> ((0 :: int) \<le> ip \<and> ip < stack_sizes s is) \<and> stacks1 s is ip = i)) \<and> (\<forall>(is :: int). (0 :: int) \<le> is \<and> is < num_stacks s \<longrightarrow> (\<forall>(ip :: int). (0 :: int) \<le> ip \<and> ip < stack_sizes s is \<longrightarrow> (is, ip) = positions s (stacks1 s is ip))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_stacks s \<longrightarrow> (let stack_i :: int \<Rightarrow> int = stacks1 s i in \<forall>(j :: int) (k :: int). (0 :: int) \<le> j \<and> j < k \<and> k < stack_sizes s i \<longrightarrow> stack_i j < stack_i k)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_stacks s \<longrightarrow> (let stack_i :: int \<Rightarrow> int = stacks1 s i in \<forall>(j :: int) (k :: int). (0 :: int) \<le> j \<and> j \<le> k \<and> k < stack_sizes s i \<longrightarrow> values s (stack_i k) \<le> values s (stack_i j))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_elts s \<longrightarrow> (let pred :: int = preds s i in (-(1 :: int) \<le> pred \<and> pred < num_elts s) \<and> pred < i \<and> (case positions s i of (is, x_ip) \<Rightarrow> (if pred < (0 :: int) then is = (0 :: int) else values s pred < values s i \<and> (0 :: int) < is \<and> (case positions s pred of (ps, x_pp) \<Rightarrow> ps = is - (1 :: int))))))" for s
datatype 'a seq = seq'mk (seqlen: "int") (seqval: "int \<Rightarrow> 'a")
definition increasing_subsequence :: "int seq \<Rightarrow> int list \<Rightarrow> _"
  where "increasing_subsequence s l \<longleftrightarrow> ((0 :: int) \<le> seqlen s \<and> seqlen s \<le> int (length l)) \<and> ((\<forall>(i :: int). (0 :: int) \<le> i \<and> i < seqlen s \<longrightarrow> (0 :: int) \<le> seqval s i \<and> seqval s i < int (length l)) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < j \<and> j < seqlen s \<longrightarrow> seqval s i < seqval s j)) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < j \<and> j < seqlen s \<longrightarrow> l ! nat (seqval s i) < l ! nat (seqval s j))" for s l
theorem play_game'vc:
  fixes input :: "int list"
  shows "let o1 :: int \<Rightarrow> int = (const :: int \<Rightarrow> int \<Rightarrow> int) (-(1 :: int)) in inv (state'mk (0 :: int) (0 :: int) o1 ((const :: int \<Rightarrow> int \<Rightarrow> int) (0 :: int)) ((const :: (int \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int) ((const :: int \<Rightarrow> int \<Rightarrow> int) (-(1 :: int)))) ((const :: int \<times> int \<Rightarrow> int \<Rightarrow> int \<times> int) (-(1 :: int), -(1 :: int))) ((const :: int \<Rightarrow> int \<Rightarrow> int) (-(1 :: int)))) \<and> (\<forall>(s :: state). inv s \<and> num_elts s = (0 :: int) + int (length input) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (0 :: int) \<longrightarrow> values s i = o1 i) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_elts s \<longrightarrow> values s i = input ! nat (i - (0 :: int))) \<longrightarrow> (let ns :: int = num_stacks s in if ns = (0 :: int) then (\<exists>(s1 :: int seq). seqlen s1 = num_stacks s \<and> increasing_subsequence s1 input) \<and> (\<forall>(s1 :: int seq). increasing_subsequence s1 input \<longrightarrow> seqlen s1 \<le> num_stacks s) else let o2 :: int = stacks1 s (ns - (1 :: int)) (stack_sizes s (ns - (1 :: int)) - (1 :: int)); o3 :: int \<Rightarrow> int = (const :: int \<Rightarrow> int \<Rightarrow> int) (-(1 :: int)); o4 :: int = ns - (1 :: int) in ((0 :: int) - (1 :: int) \<le> o4 \<longrightarrow> ((-(1 :: int) \<le> o2 \<and> o2 < num_elts s) \<and> ((0 :: int) \<le> o4 \<longrightarrow> (0 :: int) \<le> o2 \<and> (case positions s o2 of (is, _) \<Rightarrow> is = o4)) \<and> (o4 + (1 :: int) < ns \<longrightarrow> o2 < o3 (o4 + (1 :: int))) \<and> ((0 :: int) \<le> o4 \<and> o4 < ns - (1 :: int) \<longrightarrow> values s o2 < values s (o3 (o4 + (1 :: int)))) \<and> (\<forall>(j :: int). o4 < j \<and> j < ns \<longrightarrow> (0 :: int) \<le> o3 j \<and> o3 j < num_elts s) \<and> (\<forall>(j :: int) (k :: int). o4 < j \<and> j < k \<and> k < ns \<longrightarrow> o3 j < o3 k) \<and> (\<forall>(j :: int) (k :: int). o4 < j \<and> j < k \<and> k < ns \<longrightarrow> values s (o3 j) < values s (o3 k))) \<and> (\<forall>(seq1 :: int \<Rightarrow> int) (idx :: int). (\<forall>(i :: int). (i \<le> o4 \<and> (0 :: int) \<le> i) \<and> (-(1 :: int) \<le> idx \<and> idx < num_elts s) \<and> ((0 :: int) \<le> i \<longrightarrow> (0 :: int) \<le> idx \<and> (case positions s idx of (is, _) \<Rightarrow> is = i)) \<and> (i + (1 :: int) < ns \<longrightarrow> idx < seq1 (i + (1 :: int))) \<and> ((0 :: int) \<le> i \<and> i < ns - (1 :: int) \<longrightarrow> values s idx < values s (seq1 (i + (1 :: int)))) \<and> (\<forall>(j :: int). i < j \<and> j < ns \<longrightarrow> (0 :: int) \<le> seq1 j \<and> seq1 j < num_elts s) \<and> (\<forall>(j :: int) (k :: int). i < j \<and> j < k \<and> k < ns \<longrightarrow> seq1 j < seq1 k) \<and> (\<forall>(j :: int) (k :: int). i < j \<and> j < k \<and> k < ns \<longrightarrow> values s (seq1 j) < values s (seq1 k)) \<longrightarrow> (-(1 :: int) \<le> preds s idx \<and> preds s idx < num_elts s) \<and> ((0 :: int) \<le> i - (1 :: int) \<longrightarrow> (0 :: int) \<le> preds s idx \<and> (case positions s (preds s idx) of (is, _) \<Rightarrow> is = i - (1 :: int))) \<and> (i - (1 :: int) + (1 :: int) < ns \<longrightarrow> preds s idx < (seq1(i := idx)) (i - (1 :: int) + (1 :: int))) \<and> ((0 :: int) \<le> i - (1 :: int) \<and> i - (1 :: int) < ns - (1 :: int) \<longrightarrow> values s (preds s idx) < values s ((seq1(i := idx)) (i - (1 :: int) + (1 :: int)))) \<and> (\<forall>(j :: int). i - (1 :: int) < j \<and> j < ns \<longrightarrow> (0 :: int) \<le> (seq1(i := idx)) j \<and> (seq1(i := idx)) j < num_elts s) \<and> (\<forall>(j :: int) (k :: int). i - (1 :: int) < j \<and> j < k \<and> k < ns \<longrightarrow> (seq1(i := idx)) j < (seq1(i := idx)) k) \<and> (\<forall>(j :: int) (k :: int). i - (1 :: int) < j \<and> j < k \<and> k < ns \<longrightarrow> values s ((seq1(i := idx)) j) < values s ((seq1(i := idx)) k))) \<and> ((-(1 :: int) \<le> idx \<and> idx < num_elts s) \<and> ((0 :: int) \<le> (0 :: int) - (1 :: int) \<longrightarrow> (0 :: int) \<le> idx \<and> (case positions s idx of (is, _) \<Rightarrow> is = (0 :: int) - (1 :: int))) \<and> ((0 :: int) - (1 :: int) + (1 :: int) < ns \<longrightarrow> idx < seq1 ((0 :: int) - (1 :: int) + (1 :: int))) \<and> ((0 :: int) \<le> (0 :: int) - (1 :: int) \<and> (0 :: int) - (1 :: int) < ns - (1 :: int) \<longrightarrow> values s idx < values s (seq1 ((0 :: int) - (1 :: int) + (1 :: int)))) \<and> (\<forall>(j :: int). (0 :: int) - (1 :: int) < j \<and> j < ns \<longrightarrow> (0 :: int) \<le> seq1 j \<and> seq1 j < num_elts s) \<and> (\<forall>(j :: int) (k :: int). (0 :: int) - (1 :: int) < j \<and> j < k \<and> k < ns \<longrightarrow> seq1 j < seq1 k) \<and> (\<forall>(j :: int) (k :: int). (0 :: int) - (1 :: int) < j \<and> j < k \<and> k < ns \<longrightarrow> values s (seq1 j) < values s (seq1 k)) \<longrightarrow> (\<exists>(s1 :: int seq). seqlen s1 = num_stacks s \<and> increasing_subsequence s1 input) \<and> (\<forall>(s1 :: int seq). increasing_subsequence s1 input \<longrightarrow> seqlen s1 \<le> num_stacks s)))) \<and> (o4 < (0 :: int) - (1 :: int) \<longrightarrow> (\<exists>(s1 :: int seq). seqlen s1 = num_stacks s \<and> increasing_subsequence s1 input) \<and> (\<forall>(s1 :: int seq). increasing_subsequence s1 input \<longrightarrow> seqlen s1 \<le> num_stacks s))))"
  sorry
end
