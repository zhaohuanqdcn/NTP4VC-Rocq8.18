import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
open Classical
open Lean4Why3
namespace mjrty_Mjrty_mjrtyqtvc
axiom fc :  {α : Type} -> [Inhabited α] -> List α -> α -> ℤ -> Bool
axiom fc'def {α : Type} [Inhabited α] (a : List α) (v : α) (i : ℤ) : (fc a v i = true) = (a[Int.toNat i]! = v)
axiom candidate : Type
axiom inhabited_axiom_candidate : Inhabited candidate
attribute [instance] inhabited_axiom_candidate
theorem mjrty'vc (a : List candidate) (fact0 : (1 : ℤ) ≤ Int.ofNat (List.length a)) : let n : ℤ := Int.ofNat (List.length a); ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length a)) ∧ (let o1 : candidate := a[(0 : ℕ)]!; let o2 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.count o1 (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a)))) ∧ (2 : ℤ) * (Int.ofNat (List.count o1 (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a))) - (0 : ℤ)) ≤ (0 : ℤ) - (0 : ℤ) ∧ (∀(c : candidate), ¬c = o1 → (2 : ℤ) * Int.ofNat (List.count c (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a))) ≤ (0 : ℤ) - (0 : ℤ))) ∧ (∀(k : ℤ) (cand : candidate), (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o2) ∧ ((0 : ℤ) ≤ k ∧ k ≤ Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a)))) ∧ (2 : ℤ) * (Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a))) - k) ≤ i - k ∧ (∀(c : candidate), ¬c = cand → (2 : ℤ) * Int.ofNat (List.count c (List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a))) ≤ i - k) → (if k = (0 : ℤ) then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ Int.ofNat (List.count (a[Int.toNat i]!) (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a)))) ∧ (2 : ℤ) * (Int.ofNat (List.count (a[Int.toNat i]!) (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) - (1 : ℤ)) ≤ i + (1 : ℤ) - (1 : ℤ) ∧ (∀(c : candidate), ¬c = a[Int.toNat i]! → (2 : ℤ) * Int.ofNat (List.count c (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ≤ i + (1 : ℤ) - (1 : ℤ)) else ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if cand = a[Int.toNat i]! then ((0 : ℤ) ≤ k + (1 : ℤ) ∧ k + (1 : ℤ) ≤ Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a)))) ∧ (2 : ℤ) * (Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) - (k + (1 : ℤ))) ≤ i + (1 : ℤ) - (k + (1 : ℤ)) ∧ (∀(c : candidate), ¬c = cand → (2 : ℤ) * Int.ofNat (List.count c (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ≤ i + (1 : ℤ) - (k + (1 : ℤ))) else ((0 : ℤ) ≤ k - (1 : ℤ) ∧ k - (1 : ℤ) ≤ Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a)))) ∧ (2 : ℤ) * (Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) - (k - (1 : ℤ))) ≤ i + (1 : ℤ) - (k - (1 : ℤ)) ∧ (∀(c : candidate), ¬c = cand → (2 : ℤ) * Int.ofNat (List.count c (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ≤ i + (1 : ℤ) - (k - (1 : ℤ)))))) ∧ (((0 : ℤ) ≤ k ∧ k ≤ Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (Int.toNat (o2 + (1 : ℤ)) - (0 : ℕ)) a)))) ∧ (2 : ℤ) * (Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (Int.toNat (o2 + (1 : ℤ)) - (0 : ℕ)) a))) - k) ≤ o2 + (1 : ℤ) - k ∧ (∀(c : candidate), ¬c = cand → (2 : ℤ) * Int.ofNat (List.count c (List.drop (0 : ℕ) (List.take (Int.toNat (o2 + (1 : ℤ)) - (0 : ℕ)) a))) ≤ o2 + (1 : ℤ) - k) → (if k = (0 : ℤ) then ∀(c : candidate), (2 : ℤ) * Int.ofNat (List.count c (List.drop (0 : ℕ) (List.take (List.length a - (0 : ℕ)) a))) ≤ Int.ofNat (List.length a) else if n < (2 : ℤ) * k then Int.ofNat (List.length a) < (2 : ℤ) * Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (List.length a - (0 : ℕ)) a))) else let o3 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → ((0 : ℤ) = Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a))) ∧ (2 : ℤ) * (0 : ℤ) ≤ n) ∧ (∀(k1 : ℤ), (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o3) ∧ k1 = Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a))) ∧ (2 : ℤ) * k1 ≤ n → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if a[Int.toNat i]! = cand then if n < (2 : ℤ) * (k1 + (1 : ℤ)) then Int.ofNat (List.length a) < (2 : ℤ) * Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (List.length a - (0 : ℕ)) a))) else k1 + (1 : ℤ) = Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ∧ (2 : ℤ) * (k1 + (1 : ℤ)) ≤ n else k1 = Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (Int.toNat (i + (1 : ℤ)) - (0 : ℕ)) a))) ∧ (2 : ℤ) * k1 ≤ n)) ∧ (k1 = Int.ofNat (List.count cand (List.drop (0 : ℕ) (List.take (Int.toNat (o3 + (1 : ℤ)) - (0 : ℕ)) a))) ∧ (2 : ℤ) * k1 ≤ n → (∀(c : candidate), (2 : ℤ) * Int.ofNat (List.count c (List.drop (0 : ℕ) (List.take (List.length a - (0 : ℕ)) a))) ≤ Int.ofNat (List.length a))))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → (∀(c : candidate), (2 : ℤ) * Int.ofNat (List.count c (List.drop (0 : ℕ) (List.take (List.length a - (0 : ℕ)) a))) ≤ Int.ofNat (List.length a))))))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → (∀(c : candidate), (2 : ℤ) * Int.ofNat (List.count c (List.drop (0 : ℕ) (List.take (List.length a - (0 : ℕ)) a))) ≤ Int.ofNat (List.length a))))
  := sorry
end mjrty_Mjrty_mjrtyqtvc
