theory powm_Powm_wmpn_redc_1qtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.c_C" "mach.int_Unsigned" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/sub_1_Sub_1"
begin
definition redc :: "int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "redc ur u n m \<longleftrightarrow> ur emod m = ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i n * u emod m" for ur u n m
theorem wmpn_redc_1'vc:
  fixes n :: "32 word"
  fixes mp :: "64 word ptr"
  fixes up :: "64 word ptr"
  fixes rp :: "64 word ptr"
  fixes invm :: "64 word"
  assumes fact0: "(0 :: int) < sint n"
  assumes fact1: "valid mp (sint n)"
  assumes fact2: "valid up ((2 :: int) * sint n)"
  assumes fact3: "valid rp (sint n)"
  assumes fact4: "odd (value mp (sint n))"
  assumes fact5: "value mp (sint n) * uint invm emod ((18446744073709551615 :: int) + (1 :: int)) = (18446744073709551615 :: int) + (1 :: int) - (1 :: int)"
  assumes fact6: "writable up = True"
  assumes fact7: "writable rp = True"
  shows "c_C.min up \<le> offset up + (0 :: int)"
  and "offset up + (0 :: int) \<le> c_C.max up"
  and "\<forall>(o1 :: 64 word ptr). offset o1 = offset up + (0 :: int) \<and> plength o1 = plength up \<and> pelts o1 = pelts up \<and> data o1 = data up \<and> c_C.min o1 = c_C.min up \<and> c_C.max o1 = c_C.max up \<and> zone1 o1 = zone1 up \<and> writable o1 = writable up \<longrightarrow> (let vm :: int = value mp (sint n) in int'32_in_bounds (sint n - (1 :: int)) \<and> (\<forall>(o2 :: 32 word). sint o2 = sint n - (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint o2 + (1 :: int) \<longrightarrow> (offset o1 = offset up + (0 :: int) \<and> pelts o1 = pelts up \<and> c_C.min o1 = c_C.min up \<and> c_C.max o1 = c_C.max up \<and> plength o1 = plength up \<and> writable o1 = True \<and> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (0 :: int) * value o1 (sint n + sint n - (0 :: int)) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * value up (0 :: int) = value up (sint n + sint n) + vm * (0 :: int) \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (0 :: int)) \<and> (((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (0 :: int) * value o1 (sint n + sint n - (0 :: int)) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * value up (0 :: int)) emod vm = value up (sint n + sint n) emod vm) \<and> (\<forall>(added :: int) (u :: 64 word ptr) (up1 :: 64 word ptr). length (data up1) = length (data up) \<and> offset up1 = offset up \<and> c_C.min up1 = c_C.min up \<and> c_C.max up1 = c_C.max up \<and> writable up1 = writable up \<and> zone1 up1 = zone1 up \<longrightarrow> (\<forall>(j :: 32 word). let j1 :: int = sint j in ((0 :: int) \<le> j1 \<and> j1 \<le> sint o2) \<and> offset u = offset up1 + j1 \<and> pelts u = pelts up1 \<and> c_C.min u = c_C.min up1 \<and> c_C.max u = c_C.max up1 \<and> plength u = plength up1 \<and> writable u = True \<and> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i j1 * value u (sint n + sint n - j1) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * value up1 j1 = value up (sint n + sint n) + vm * added \<and> ((0 :: int) \<le> added \<and> added < ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i j1) \<and> (((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i j1 * value u (sint n + sint n - j1) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * value up1 j1) emod vm = value up (sint n + sint n) emod vm \<longrightarrow> (c_C.min u \<le> offset u \<and> offset u < c_C.max u) \<and> (\<forall>(m :: 64 word). uint m = uint (pelts u (offset u)) * uint invm emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> int'32_in_bounds (sint n + sint n) \<and> (\<forall>(o3 :: 32 word). sint o3 = sint n + sint n \<longrightarrow> int'32_in_bounds (sint o3 - sint j) \<and> (\<forall>(nnj :: 32 word). sint nnj = sint o3 - sint j \<longrightarrow> (valid mp (sint n) \<and> valid u (sint n) \<and> writable u = True) \<and> (\<forall>(u1 :: 64 word ptr) (up2 :: 64 word ptr). data u1 = data up2 \<and> length (data up2) = length (data u) \<and> offset u1 = offset u \<and> c_C.min u1 = c_C.min u \<and> c_C.max u1 = c_C.max u \<and> writable u1 = writable u \<and> zone1 u1 = zone1 u \<longrightarrow> data u1 = data up2 \<and> length (data up2) = length (data u) \<and> offset u1 = offset u \<and> c_C.min u1 = c_C.min u \<and> c_C.max u1 = c_C.max u \<and> writable u1 = writable u \<and> zone1 u1 = zone1 u \<longrightarrow> length (data up2) = length (data up1) \<and> offset up2 = offset up1 \<and> c_C.min up2 = c_C.min up1 \<and> c_C.max up2 = c_C.max up1 \<and> writable up2 = writable up1 \<and> zone1 up2 = zone1 up1 \<longrightarrow> (\<forall>(o4 :: 64 word). value u1 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint o4 = value u (sint n) + value mp (sint n) * uint m \<and> (\<forall>(j2 :: int). j2 < offset u1 \<or> offset u1 + sint n \<le> j2 \<longrightarrow> pelts u1 j2 = pelts u j2) \<longrightarrow> ((c_C.min u1 \<le> offset u1 \<and> offset u1 < c_C.max u1) \<and> writable u1 = True) \<and> (\<forall>(u2 :: 64 word ptr) (up3 :: 64 word ptr). data u2 = data up3 \<and> length (data up3) = length (data u1) \<and> offset u2 = offset u1 \<and> c_C.min u2 = c_C.min u1 \<and> c_C.max u2 = c_C.max u1 \<and> writable u2 = writable u1 \<and> zone1 u2 = zone1 u1 \<longrightarrow> data u2 = data up3 \<and> length (data up3) = length (data u1) \<and> offset u2 = offset u1 \<and> c_C.min u2 = c_C.min u1 \<and> c_C.max u2 = c_C.max u1 \<and> writable u2 = writable u1 \<and> zone1 u2 = zone1 u1 \<longrightarrow> length (data up3) = length (data up2) \<and> offset up3 = offset up2 \<and> c_C.min up3 = c_C.min up2 \<and> c_C.max up3 = c_C.max up2 \<and> writable up3 = writable up2 \<and> zone1 up3 = zone1 up2 \<longrightarrow> pelts u2 = (pelts u1)(offset u2 := o4) \<longrightarrow> (c_C.min u2 \<le> offset u2 + (1 :: int) \<and> offset u2 + (1 :: int) \<le> c_C.max u2) \<and> (\<forall>(o5 :: 64 word ptr). offset o5 = offset u2 + (1 :: int) \<and> plength o5 = plength u2 \<and> pelts o5 = pelts u2 \<and> data o5 = data u2 \<and> c_C.min o5 = c_C.min u2 \<and> c_C.max o5 = c_C.max u2 \<and> zone1 o5 = zone1 u2 \<and> writable o5 = writable u2 \<longrightarrow> offset o5 = offset up3 + (j1 + (1 :: int)) \<and> pelts o5 = pelts up3 \<and> c_C.min o5 = c_C.min up3 \<and> c_C.max o5 = c_C.max up3 \<and> plength o5 = plength up3 \<and> writable o5 = True \<and> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (j1 + (1 :: int)) * value o5 (sint n + sint n - (j1 + (1 :: int))) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * value up3 (j1 + (1 :: int)) = value up (sint n + sint n) + vm * (added + uint m * ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint j) \<and> ((0 :: int) \<le> added + uint m * ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint j \<and> added + uint m * ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint j < ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (j1 + (1 :: int))) \<and> (((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (j1 + (1 :: int)) * value o5 (sint n + sint n - (j1 + (1 :: int))) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * value up3 (j1 + (1 :: int))) emod vm = value up (sint n + sint n) emod vm)))))))) \<and> (offset u = offset up1 + (sint o2 + (1 :: int)) \<and> pelts u = pelts up1 \<and> c_C.min u = c_C.min up1 \<and> c_C.max u = c_C.max up1 \<and> plength u = plength up1 \<and> writable u = True \<and> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint o2 + (1 :: int)) * value u (sint n + sint n - (sint o2 + (1 :: int))) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * value up1 (sint o2 + (1 :: int)) = value up (sint n + sint n) + vm * added \<and> ((0 :: int) \<le> added \<and> added < ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint o2 + (1 :: int))) \<and> (((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint o2 + (1 :: int)) * value u (sint n + sint n - (sint o2 + (1 :: int))) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * value up1 (sint o2 + (1 :: int))) emod vm = value up (sint n + sint n) emod vm \<longrightarrow> int'32_in_bounds (-sint n) \<and> (\<forall>(o3 :: 32 word). sint o3 = -sint n \<longrightarrow> (c_C.min u \<le> offset u + sint o3 \<and> offset u + sint o3 \<le> c_C.max u) \<and> (\<forall>(u' :: 64 word ptr). offset u' = offset u + sint o3 \<and> plength u' = plength u \<and> pelts u' = pelts u \<and> data u' = data u \<and> c_C.min u' = c_C.min u \<and> c_C.max u' = c_C.max u \<and> zone1 u' = zone1 u \<and> writable u' = writable u \<longrightarrow> int'32_in_bounds (-sint n) \<and> (\<forall>(o4 :: 32 word). sint o4 = -sint n \<longrightarrow> (c_C.min u \<le> offset u + sint o4 \<and> offset u + sint o4 \<le> c_C.max u) \<and> (\<forall>(o5 :: 64 word ptr). offset o5 = offset u + sint o4 \<and> plength o5 = plength u \<and> pelts o5 = pelts u \<and> data o5 = data u \<and> c_C.min o5 = c_C.min u \<and> c_C.max o5 = c_C.max u \<and> zone1 o5 = zone1 u \<and> writable o5 = writable u \<longrightarrow> (valid u (sint n) \<and> valid o5 (sint n) \<and> valid rp (sint n) \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(o6 :: 64 word). ((0 :: int) \<le> uint o6 \<and> uint o6 \<le> (1 :: int)) \<and> value rp1 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint o6 = value u (sint n) + value o5 (sint n) \<and> (\<forall>(j :: int). j < offset rp1 \<or> offset rp1 + sint n \<le> j \<longrightarrow> pelts rp1 j = pelts rp j) \<longrightarrow> (\<forall>(o7 :: bool). (uint o6 = uint (0 :: 64 word) \<longrightarrow> o7 = True) \<and> (o7 = True \<longrightarrow> o6 = (0 :: 64 word)) \<longrightarrow> (if \<not>o7 = True then ((0 :: int) \<le> sint n \<and> valid rp1 (sint n) \<and> valid mp (sint n) \<and> writable rp1 = True) \<and> (\<forall>(rp2 :: 64 word ptr). length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> (\<forall>(b :: 64 word). value rp2 (sint n) - ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint b = value rp1 (sint n) - value mp (sint n) \<and> ((0 :: int) \<le> uint b \<and> uint b \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset rp2 \<or> offset rp2 + sint n \<le> j \<longrightarrow> pelts rp2 j = pelts rp1 j) \<longrightarrow> value rp2 (sint n) emod vm = (value rp1 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint o6) emod vm \<and> (\<forall>(j :: int). j < offset rp2 \<or> offset rp2 + sint n \<le> j \<longrightarrow> pelts rp2 j = pelts rp1 j) \<and> (value up ((2 :: int) * sint n) < ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * vm \<longrightarrow> value rp2 (sint n) < (2 :: int) * vm))) else value rp1 (sint n) emod vm = (value rp1 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint o6) emod vm \<and> (value up ((2 :: int) * sint n) < ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * vm \<longrightarrow> value rp1 (sint n) < (2 :: int) * vm))) \<and> (\<forall>(rp2 :: 64 word ptr). length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> value rp2 (sint n) emod vm = (value rp1 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint o6) emod vm \<and> (\<forall>(j :: int). j < offset rp2 \<or> offset rp2 + sint n \<le> j \<longrightarrow> pelts rp2 j = pelts rp1 j) \<and> (value up ((2 :: int) * sint n) < ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * vm \<longrightarrow> value rp2 (sint n) < (2 :: int) * vm) \<longrightarrow> redc (value up ((2 :: int) * sint n)) (value rp2 (sint n)) (sint n) (value mp (sint n)) \<and> (\<forall>(j :: int). j < offset rp2 \<or> offset rp2 + sint n \<le> j \<longrightarrow> pelts rp2 j = pelts rp j) \<and> (value up ((2 :: int) * sint n) < ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * value mp (sint n) \<longrightarrow> value rp2 (sint n) < (2 :: int) * value mp (sint n)))))))))))) \<and> (sint o2 + (1 :: int) < (0 :: int) \<longrightarrow> int'32_in_bounds (-sint n) \<and> (\<forall>(o3 :: 32 word). sint o3 = -sint n \<longrightarrow> (c_C.min o1 \<le> offset o1 + sint o3 \<and> offset o1 + sint o3 \<le> c_C.max o1) \<and> (\<forall>(u' :: 64 word ptr). offset u' = offset o1 + sint o3 \<and> plength u' = plength o1 \<and> pelts u' = pelts o1 \<and> data u' = data o1 \<and> c_C.min u' = c_C.min o1 \<and> c_C.max u' = c_C.max o1 \<and> zone1 u' = zone1 o1 \<and> writable u' = writable o1 \<longrightarrow> int'32_in_bounds (-sint n) \<and> (\<forall>(o4 :: 32 word). sint o4 = -sint n \<longrightarrow> (c_C.min o1 \<le> offset o1 + sint o4 \<and> offset o1 + sint o4 \<le> c_C.max o1) \<and> (\<forall>(o5 :: 64 word ptr). offset o5 = offset o1 + sint o4 \<and> plength o5 = plength o1 \<and> pelts o5 = pelts o1 \<and> data o5 = data o1 \<and> c_C.min o5 = c_C.min o1 \<and> c_C.max o5 = c_C.max o1 \<and> zone1 o5 = zone1 o1 \<and> writable o5 = writable o1 \<longrightarrow> (valid o1 (sint n) \<and> valid o5 (sint n) \<and> valid rp (sint n) \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(o6 :: 64 word). ((0 :: int) \<le> uint o6 \<and> uint o6 \<le> (1 :: int)) \<and> value rp1 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint o6 = value o1 (sint n) + value o5 (sint n) \<and> (\<forall>(j :: int). j < offset rp1 \<or> offset rp1 + sint n \<le> j \<longrightarrow> pelts rp1 j = pelts rp j) \<longrightarrow> (\<forall>(o7 :: bool). (uint o6 = uint (0 :: 64 word) \<longrightarrow> o7 = True) \<and> (o7 = True \<longrightarrow> o6 = (0 :: 64 word)) \<longrightarrow> (if \<not>o7 = True then ((0 :: int) \<le> sint n \<and> valid rp1 (sint n) \<and> valid mp (sint n) \<and> writable rp1 = True) \<and> (\<forall>(rp2 :: 64 word ptr). length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> (\<forall>(b :: 64 word). value rp2 (sint n) - ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint b = value rp1 (sint n) - value mp (sint n) \<and> ((0 :: int) \<le> uint b \<and> uint b \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset rp2 \<or> offset rp2 + sint n \<le> j \<longrightarrow> pelts rp2 j = pelts rp1 j) \<longrightarrow> value rp2 (sint n) emod vm = (value rp1 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint o6) emod vm \<and> (\<forall>(j :: int). j < offset rp2 \<or> offset rp2 + sint n \<le> j \<longrightarrow> pelts rp2 j = pelts rp1 j) \<and> (value up ((2 :: int) * sint n) < ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * vm \<longrightarrow> value rp2 (sint n) < (2 :: int) * vm))) else value rp1 (sint n) emod vm = (value rp1 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint o6) emod vm \<and> (value up ((2 :: int) * sint n) < ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * vm \<longrightarrow> value rp1 (sint n) < (2 :: int) * vm))) \<and> (\<forall>(rp2 :: 64 word ptr). length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> value rp2 (sint n) emod vm = (value rp1 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint o6) emod vm \<and> (\<forall>(j :: int). j < offset rp2 \<or> offset rp2 + sint n \<le> j \<longrightarrow> pelts rp2 j = pelts rp1 j) \<and> (value up ((2 :: int) * sint n) < ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * vm \<longrightarrow> value rp2 (sint n) < (2 :: int) * vm) \<longrightarrow> redc (value up ((2 :: int) * sint n)) (value rp2 (sint n)) (sint n) (value mp (sint n)) \<and> (\<forall>(j :: int). j < offset rp2 \<or> offset rp2 + sint n \<le> j \<longrightarrow> pelts rp2 j = pelts rp j) \<and> (value up ((2 :: int) * sint n) < ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * value mp (sint n) \<longrightarrow> value rp2 (sint n) < (2 :: int) * value mp (sint n))))))))))))"
  sorry
end
