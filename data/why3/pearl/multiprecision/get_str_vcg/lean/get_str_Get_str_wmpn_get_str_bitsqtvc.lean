import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import Why3.mach.c.UChar
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.powm.Powm
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.valuation.Valuation
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.sub_1.Sub_1
import pearl.multiprecision.lib.lean.stringlemmas.String_lemmas
import pearl.multiprecision.lib.lean.base_info.BaseInfo
open Classical
open Lean4Why3
namespace get_str_Get_str_wmpn_get_str_bitsqtvc
theorem wmpn_get_str_bits'vc (un : BitVec 32) (up : C.ptr (BitVec 64)) (bits : BitVec 32) (sp : C.ptr (BitVec 8)) (ub : BitVec 32) (fact0 : (1 : ℤ) ≤ BitVec.toInt un) (fact1 : C.valid up (BitVec.toInt un)) (fact2 : (1 : ℤ) ≤ BitVec.toUInt bits) (fact3 : BitVec.toUInt bits ≤ (8 : ℤ)) (fact4 : C.valid sp ((BitVec.toInt ub + BitVec.toUInt bits - (1 : ℤ)) / BitVec.toUInt bits)) (fact5 : (0 : ℤ) ≤ BitVec.toInt ub) (fact6 : Lemmas.value up (BitVec.toInt un) < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt ub))) (fact7 : (0 : ℤ) < BitVec.toUInt (C.pelts up (C.offset up + BitVec.toInt un - (1 : ℤ)))) (fact8 : (64 : ℤ) * BitVec.toInt un + (7 : ℤ) ≤ (2147483647 : ℤ)) (fact9 : C.writable sp = true) : int'32_in_bounds (BitVec.toInt un - (1 : ℤ)) ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = BitVec.toInt un - (1 : ℤ) → (C.min up ≤ C.offset up + BitVec.toInt o1 ∧ C.offset up + BitVec.toInt o1 < C.max up) ∧ (let um : BitVec 64 := C.pelts up (C.offset up + BitVec.toInt o1); (0 : ℤ) < BitVec.toUInt um ∧ (∀(sb : BitVec 64), ((1 : ℤ) ≤ BitVec.toUInt sb ∧ BitVec.toUInt sb ≤ (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt sb - (1 : ℤ))) ≤ BitVec.toUInt um ∧ BitVec.toUInt um < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt sb)) → BitVec.toUInt bits ≤ (2147483647 : ℤ) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toUInt bits → BitVec.toUInt sb ≤ (2147483647 : ℤ) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toUInt sb → int'32_in_bounds (BitVec.toInt un - (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt un - (1 : ℤ) → int'32_in_bounds ((64 : ℤ) * BitVec.toInt o4) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = (64 : ℤ) * BitVec.toInt o4 → int'32_in_bounds (BitVec.toInt o5 + BitVec.toInt o3) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt o5 + BitVec.toInt o3 → int'32_in_bounds (BitVec.toInt o6 + BitVec.toInt o2) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt o6 + BitVec.toInt o2 → int'32_in_bounds (BitVec.toInt o7 - (1 : ℤ)) ∧ (∀(e : BitVec 32), BitVec.toInt e = BitVec.toInt o7 - (1 : ℤ) → BitVec.toUInt bits ≤ (2147483647 : ℤ) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toUInt bits → (¬BitVec.toInt o8 = (0 : ℤ) ∧ int'32_in_bounds (Int.tdiv (BitVec.toInt e) (BitVec.toInt o8))) ∧ (∀(sn : BitVec 32), BitVec.toInt sn = Int.tdiv (BitVec.toInt e) (BitVec.toInt o8) → (∀(o9 : BitVec 64), BitVec.toUInt o9 = BitVec.toUInt bits → (((0 : ℤ) ≤ BitVec.toUInt o9 ∧ BitVec.toUInt o9 < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o9)) * BitVec.toUInt (1 : BitVec 64) ≤ (18446744073709551615 : ℤ)) ∧ (∀(b : BitVec 64), BitVec.toUInt b = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o9)) * BitVec.toUInt (1 : BitVec 64) → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt un) ∧ ((0 : ℤ) ≤ BitVec.toInt sn ∧ BitVec.toInt sn ≤ BitVec.toInt sn) ∧ (BitVec.toInt sn - BitVec.toInt sn) * BitVec.toUInt bits = (0 : ℤ) ∧ ((0 : ℤ) < BitVec.toInt sn → (0 : ℤ) = (64 : ℤ) * (0 : ℤ) + (0 : ℤ)) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < (64 : ℤ) ∨ (0 : BitVec 32) = un) ∧ String_lemmas.in_base (BitVec.toUInt b) (C.pelts sp) (C.offset sp + BitVec.toInt sn) (C.offset sp + BitVec.toInt sn) ∧ (String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp + BitVec.toInt sn) (C.offset sp + BitVec.toInt sn) = Powm.valueb up (0 : ℤ) ∧ (0 : ℤ) ≤ (64 : ℤ) * BitVec.toInt un ∨ BitVec.toInt sn = (0 : ℤ) ∧ String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toInt sn) = Lemmas.value up (BitVec.toInt un))) ∧ (∀(shift : BitVec 64) (j : BitVec 32) (i : BitVec 32) (sp1 : C.ptr (BitVec 8)), List.length (C.data sp1) = List.length (C.data sp) ∧ C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.max sp1 = C.max sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt un) ∧ ((0 : ℤ) ≤ BitVec.toInt j ∧ BitVec.toInt j ≤ BitVec.toInt sn) ∧ ((0 : ℤ) < BitVec.toInt j → (BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt i + BitVec.toUInt shift) ∧ ((0 : ℤ) ≤ BitVec.toUInt shift ∧ BitVec.toUInt shift < (64 : ℤ) ∨ i = un) ∧ String_lemmas.in_base (BitVec.toUInt b) (C.pelts sp1) (C.offset sp1 + BitVec.toInt j) (C.offset sp1 + BitVec.toInt sn) ∧ (String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp1) (C.offset sp1 + BitVec.toInt j) (C.offset sp1 + BitVec.toInt sn) = Powm.valueb up ((BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits) ∧ (BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits ≤ (64 : ℤ) * BitVec.toInt un ∨ BitVec.toInt j = (0 : ℤ) ∧ String_lemmas.svalue (BitVec.toUInt b) sp1 (BitVec.toInt sn) = Lemmas.value up (BitVec.toInt un)) ∧ (∀(k : ℤ), k < C.offset sp1 ∨ C.offset sp1 + BitVec.toInt sn ≤ k → C.pelts sp1 k = C.pelts sp k) → (if (0 : ℤ) < BitVec.toInt j then int'32_in_bounds (BitVec.toInt j - (1 : ℤ)) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt j - (1 : ℤ) → (C.min up ≤ C.offset up + BitVec.toInt i ∧ C.offset up + BitVec.toInt i < C.max up) ∧ ((0 : ℤ) ≤ BitVec.toUInt shift ∧ BitVec.toUInt shift < (64 : ℤ)) ∧ (∀(o11 : BitVec 64), BitVec.toUInt o11 = BitVec.toUInt (C.pelts up (C.offset up + BitVec.toInt i)) / HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt shift)) → ¬HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt shift)) = (0 : ℤ) ∧ (∀(o12 : BitVec 64), BitVec.toUInt o12 = BitVec.toUInt bits → uint'64_in_bounds (BitVec.toUInt shift + BitVec.toUInt o12) ∧ (∀(o13 : BitVec 64), BitVec.toUInt o13 = BitVec.toUInt shift + BitVec.toUInt o12 → (if (64 : ℤ) ≤ BitVec.toUInt o13 then int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o14 : BitVec 32), BitVec.toInt o14 = BitVec.toInt i + (1 : ℤ) → (if BitVec.toInt o14 < BitVec.toInt un then uint'64_in_bounds (BitVec.toUInt o13 - (64 : ℤ)) ∧ (∀(o15 : BitVec 64), BitVec.toUInt o15 = BitVec.toUInt o13 - (64 : ℤ) → (C.min up ≤ C.offset up + BitVec.toInt o14 ∧ C.offset up + BitVec.toInt o14 < C.max up) ∧ (∀(o16 : BitVec 64), BitVec.toUInt o16 = BitVec.toUInt bits → uint'64_in_bounds (BitVec.toUInt o16 - BitVec.toUInt o15) ∧ (∀(o17 : BitVec 64), BitVec.toUInt o17 = BitVec.toUInt o16 - BitVec.toUInt o15 → ((0 : ℤ) ≤ BitVec.toUInt o17 ∧ BitVec.toUInt o17 < (64 : ℤ)) ∧ (∀(high : BitVec 64), BitVec.toUInt high = BitVec.toUInt (C.pelts up (C.offset up + BitVec.toInt o14)) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o17)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → uint'64_in_bounds (BitVec.toUInt o11 + BitVec.toUInt high) ∧ (∀(o18 : BitVec 64), BitVec.toUInt o18 = BitVec.toUInt o11 + BitVec.toUInt high → (¬BitVec.toUInt b = (0 : ℤ) ∧ uint'64_in_bounds (Int.tmod (BitVec.toUInt o18) (BitVec.toUInt b))) ∧ (∀(sj : BitVec 64), BitVec.toUInt sj = Int.tmod (BitVec.toUInt o18) (BitVec.toUInt b) → ((0 : ℤ) ≤ BitVec.toUInt sj ∧ BitVec.toUInt sj ≤ (255 : ℤ)) ∧ (∀(o19 : BitVec 8), BitVec.toInt o19 = BitVec.toUInt sj → ((C.min sp1 ≤ C.offset sp1 + BitVec.toInt o10 ∧ C.offset sp1 + BitVec.toInt o10 < C.max sp1) ∧ C.writable sp1 = true) ∧ (∀(sp2 : C.ptr (BitVec 8)), List.length (C.data sp2) = List.length (C.data sp1) ∧ C.offset sp2 = C.offset sp1 ∧ C.min sp2 = C.min sp1 ∧ C.max sp2 = C.max sp1 ∧ C.writable sp2 = C.writable sp1 ∧ C.zone1 sp2 = C.zone1 sp1 → C.pelts sp2 = Function.update (C.pelts sp1) (C.offset sp2 + BitVec.toInt o10) o19 ∧ C.pelts sp2 (C.offset sp2 + BitVec.toInt o10) = o19 → BitVec.toInt o10 < BitVec.toInt j ∧ ((0 : ℤ) ≤ BitVec.toInt o14 ∧ BitVec.toInt o14 ≤ BitVec.toInt un) ∧ ((0 : ℤ) ≤ BitVec.toInt o10 ∧ BitVec.toInt o10 ≤ BitVec.toInt sn) ∧ (BitVec.toInt sn - BitVec.toInt o10) * BitVec.toUInt bits = (BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits ∧ ((0 : ℤ) < BitVec.toInt o10 → (BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt o14 + BitVec.toUInt o15) ∧ ((0 : ℤ) ≤ BitVec.toUInt o15 ∧ BitVec.toUInt o15 < (64 : ℤ) ∨ o14 = un) ∧ String_lemmas.in_base (BitVec.toUInt b) (C.pelts sp2) (C.offset sp2 + BitVec.toInt o10) (C.offset sp2 + BitVec.toInt sn) ∧ (String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp2) (C.offset sp2 + BitVec.toInt o10) (C.offset sp2 + BitVec.toInt sn) = Powm.valueb up ((BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits) ∧ (BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits ≤ (64 : ℤ) * BitVec.toInt un ∨ BitVec.toInt o10 = (0 : ℤ) ∧ String_lemmas.svalue (BitVec.toUInt b) sp2 (BitVec.toInt sn) = Lemmas.value up (BitVec.toInt un)) ∧ (∀(k : ℤ), k < C.offset sp2 ∨ C.offset sp2 + BitVec.toInt sn ≤ k → C.pelts sp2 k = C.pelts sp k))))))))) else (¬BitVec.toUInt b = (0 : ℤ) ∧ uint'64_in_bounds (Int.tmod (BitVec.toUInt o11) (BitVec.toUInt b))) ∧ (∀(sj : BitVec 64), BitVec.toUInt sj = Int.tmod (BitVec.toUInt o11) (BitVec.toUInt b) → ((0 : ℤ) ≤ BitVec.toUInt sj ∧ BitVec.toUInt sj ≤ (255 : ℤ)) ∧ (∀(o15 : BitVec 8), BitVec.toInt o15 = BitVec.toUInt sj → ((C.min sp1 ≤ C.offset sp1 + BitVec.toInt o10 ∧ C.offset sp1 + BitVec.toInt o10 < C.max sp1) ∧ C.writable sp1 = true) ∧ (∀(sp2 : C.ptr (BitVec 8)), List.length (C.data sp2) = List.length (C.data sp1) ∧ C.offset sp2 = C.offset sp1 ∧ C.min sp2 = C.min sp1 ∧ C.max sp2 = C.max sp1 ∧ C.writable sp2 = C.writable sp1 ∧ C.zone1 sp2 = C.zone1 sp1 → C.pelts sp2 = Function.update (C.pelts sp1) (C.offset sp2 + BitVec.toInt o10) o15 ∧ C.pelts sp2 (C.offset sp2 + BitVec.toInt o10) = o15 → BitVec.toInt o10 < BitVec.toInt j ∧ ((0 : ℤ) ≤ BitVec.toInt o14 ∧ BitVec.toInt o14 ≤ BitVec.toInt un) ∧ ((0 : ℤ) ≤ BitVec.toInt o10 ∧ BitVec.toInt o10 ≤ BitVec.toInt sn) ∧ (BitVec.toInt sn - BitVec.toInt o10) * BitVec.toUInt bits = (BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits ∧ ((0 : ℤ) < BitVec.toInt o10 → (BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt o14 + BitVec.toUInt o13) ∧ ((0 : ℤ) ≤ BitVec.toUInt o13 ∧ BitVec.toUInt o13 < (64 : ℤ) ∨ o14 = un) ∧ String_lemmas.in_base (BitVec.toUInt b) (C.pelts sp2) (C.offset sp2 + BitVec.toInt o10) (C.offset sp2 + BitVec.toInt sn) ∧ (String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp2) (C.offset sp2 + BitVec.toInt o10) (C.offset sp2 + BitVec.toInt sn) = Powm.valueb up ((BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits) ∧ (BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits ≤ (64 : ℤ) * BitVec.toInt un ∨ BitVec.toInt o10 = (0 : ℤ) ∧ String_lemmas.svalue (BitVec.toUInt b) sp2 (BitVec.toInt sn) = Lemmas.value up (BitVec.toInt un)) ∧ (∀(k : ℤ), k < C.offset sp2 ∨ C.offset sp2 + BitVec.toInt sn ≤ k → C.pelts sp2 k = C.pelts sp k)))))) else (¬BitVec.toUInt b = (0 : ℤ) ∧ uint'64_in_bounds (Int.tmod (BitVec.toUInt o11) (BitVec.toUInt b))) ∧ (∀(sj : BitVec 64), BitVec.toUInt sj = Int.tmod (BitVec.toUInt o11) (BitVec.toUInt b) → ((0 : ℤ) ≤ BitVec.toUInt sj ∧ BitVec.toUInt sj ≤ (255 : ℤ)) ∧ (∀(o14 : BitVec 8), BitVec.toInt o14 = BitVec.toUInt sj → ((C.min sp1 ≤ C.offset sp1 + BitVec.toInt o10 ∧ C.offset sp1 + BitVec.toInt o10 < C.max sp1) ∧ C.writable sp1 = true) ∧ (∀(sp2 : C.ptr (BitVec 8)), List.length (C.data sp2) = List.length (C.data sp1) ∧ C.offset sp2 = C.offset sp1 ∧ C.min sp2 = C.min sp1 ∧ C.max sp2 = C.max sp1 ∧ C.writable sp2 = C.writable sp1 ∧ C.zone1 sp2 = C.zone1 sp1 → C.pelts sp2 = Function.update (C.pelts sp1) (C.offset sp2 + BitVec.toInt o10) o14 ∧ C.pelts sp2 (C.offset sp2 + BitVec.toInt o10) = o14 → BitVec.toInt o10 < BitVec.toInt j ∧ ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt un) ∧ ((0 : ℤ) ≤ BitVec.toInt o10 ∧ BitVec.toInt o10 ≤ BitVec.toInt sn) ∧ (BitVec.toInt sn - BitVec.toInt o10) * BitVec.toUInt bits = (BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits ∧ ((0 : ℤ) < BitVec.toInt o10 → (BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt i + BitVec.toUInt o13) ∧ ((0 : ℤ) ≤ BitVec.toUInt o13 ∧ BitVec.toUInt o13 < (64 : ℤ) ∨ i = un) ∧ String_lemmas.in_base (BitVec.toUInt b) (C.pelts sp2) (C.offset sp2 + BitVec.toInt o10) (C.offset sp2 + BitVec.toInt sn) ∧ (String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp2) (C.offset sp2 + BitVec.toInt o10) (C.offset sp2 + BitVec.toInt sn) = Powm.valueb up ((BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits) ∧ (BitVec.toInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits ≤ (64 : ℤ) * BitVec.toInt un ∨ BitVec.toInt o10 = (0 : ℤ) ∧ String_lemmas.svalue (BitVec.toUInt b) sp2 (BitVec.toInt sn) = Lemmas.value up (BitVec.toInt un)) ∧ (∀(k : ℤ), k < C.offset sp2 ∨ C.offset sp2 + BitVec.toInt sn ≤ k → C.pelts sp2 k = C.pelts sp k))))))))) else (0 : ℤ) ≤ BitVec.toInt sn ∧ (∀(result : BitVec 32), BitVec.toUInt result = BitVec.toInt sn → String_lemmas.in_base (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) (C.pelts sp1) (C.offset sp1) (C.offset sp1 + BitVec.toUInt result) ∧ String_lemmas.svalue (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) sp1 (BitVec.toUInt result) = Lemmas.value up (BitVec.toInt un) ∧ ((0 : ℤ) < BitVec.toUInt result ∧ BitVec.toUInt result ≤ (BitVec.toInt ub + BitVec.toUInt bits - (1 : ℤ)) / BitVec.toUInt bits) ∧ (0 : ℤ) < BitVec.toInt (C.pelts sp1 (C.offset sp1)) ∧ (∀(j1 : ℤ), j1 < C.offset sp1 ∨ C.offset sp1 + (BitVec.toInt ub + BitVec.toUInt bits - (1 : ℤ)) / BitVec.toUInt bits ≤ j1 → C.pelts sp1 j1 = C.pelts sp j1))))))))))))))))))
  := sorry
end get_str_Get_str_wmpn_get_str_bitsqtvc
