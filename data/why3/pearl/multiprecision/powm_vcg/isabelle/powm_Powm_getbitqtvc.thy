theory powm_Powm_getbitqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.c_C" "mach.int_Unsigned" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/sub_1_Sub_1"
begin
definition redc :: "int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "redc ur u n m \<longleftrightarrow> ur emod m = ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i n * u emod m" for ur u n m
definition valueb :: "64 word ptr \<Rightarrow> int \<Rightarrow> int"
  where "valueb p nbits = (if nbits < (0 :: int) then 0 :: int else let i :: int = nbits ediv (64 :: int) in value p i + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i i * (uint (pelts p (offset p + i)) emod (2 :: int) ^\<^sub>i (nbits - (64 :: int) * i)))" for p nbits
theorem getbit'vc:
  fixes p :: "64 word ptr"
  fixes pn :: "32 word"
  fixes bi :: "32 word"
  assumes fact0: "valid p (sint pn)"
  assumes fact1: "(1 :: int) \<le> sint bi"
  assumes fact2: "(sint bi + (63 :: int)) ediv (64 :: int) \<le> sint pn"
  shows "int'32_in_bounds (sint bi - (1 :: int))"
  and "\<forall>(o1 :: 32 word). sint o1 = sint bi - (1 :: int) \<longrightarrow> (\<not>(64 :: int) = (0 :: int) \<and> int'32_in_bounds (sint o1 cdiv (64 :: int))) \<and> (\<forall>(i :: 32 word). sint i = sint o1 cdiv (64 :: int) \<longrightarrow> int'32_in_bounds (sint bi - (1 :: int)) \<and> (\<forall>(o2 :: 32 word). sint o2 = sint bi - (1 :: int) \<longrightarrow> (0 :: int) \<le> sint o2 \<and> (\<forall>(o3 :: 64 word). uint o3 = sint o2 \<longrightarrow> (\<not>(64 :: int) = (0 :: int) \<and> uint'64_in_bounds (uint o3 cmod (64 :: int))) \<and> (\<forall>(mi :: 64 word). uint mi = uint o3 cmod (64 :: int) \<longrightarrow> (c_C.min p \<le> offset p + sint i \<and> offset p + sint i < c_C.max p) \<and> int'32_in_bounds (sint i + (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint i + (1 :: int) \<longrightarrow> (c_C.min p \<le> offset p + sint o4 \<and> offset p + sint o4 \<le> c_C.max p) \<and> (\<forall>(p' :: 64 word ptr). offset p' = offset p + sint o4 \<and> plength p' = plength p \<and> pelts p' = pelts p \<and> data p' = data p \<and> c_C.min p' = c_C.min p \<and> c_C.max p' = c_C.max p \<and> zone1 p' = zone1 p \<and> writable p' = writable p \<longrightarrow> ((0 :: int) \<le> uint mi \<and> uint mi < (64 :: int)) \<and> (\<forall>(lps :: 64 word). uint lps = uint (pelts p (offset p + sint i)) ediv (2 :: int) ^\<^sub>i uint mi \<longrightarrow> \<not>(2 :: int) ^\<^sub>i uint mi = (0 :: int) \<and> (\<not>(2 :: int) = (0 :: int) \<and> uint'64_in_bounds (uint lps cmod (2 :: int))) \<and> (\<forall>(res :: 64 word). uint res = uint lps cmod (2 :: int) \<longrightarrow> \<not>(2 :: int) = (0 :: int) \<and> (\<not>(2 :: int) = (0 :: int) \<and> uint'64_in_bounds (uint lps cmod (2 :: int))) \<and> (\<forall>(result :: 64 word). uint result = uint lps cmod (2 :: int) \<longrightarrow> ((0 :: int) \<le> uint result \<and> uint result \<le> (1 :: int)) \<and> uint result = value p (sint pn) ediv (2 :: int) ^\<^sub>i (sint bi - (1 :: int)) emod (2 :: int) \<and> valueb p (sint bi) = valueb p (sint bi - (1 :: int)) + (2 :: int) ^\<^sub>i (sint bi - (1 :: int)) * uint result)))))))))"
  sorry
end
