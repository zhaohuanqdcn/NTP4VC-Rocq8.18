import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace all_distinct_AllDistinct_all_distinctqtvc
theorem all_distinct'vc (m : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ m) (fact1 : ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → (0 : ℤ) ≤ a[Int.toNat i]! ∧ a[Int.toNat i]! < m) : (0 : ℤ) ≤ m ∧ (∀(dejavu : List Bool), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < m → dejavu[Int.toNat i]! = false) ∧ Int.ofNat (List.length dejavu) = m → (let o1 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → ((∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < (0 : ℤ) → (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → ¬i = j → ¬a[Int.toNat i]! = a[Int.toNat j]!) ∧ (∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < m → (dejavu[Int.toNat x]! = true) = (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < (0 : ℤ)) ∧ a[Int.toNat i]! = x))) ∧ (∀(dejavu1 : List Bool), List.length dejavu1 = List.length dejavu → (∀(k : ℤ), ((0 : ℤ) ≤ k ∧ k ≤ o1) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < k → (0 : ℤ) ≤ j ∧ j < k → ¬i = j → ¬a[Int.toNat i]! = a[Int.toNat j]!) ∧ (∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < m → (dejavu1[Int.toNat x]! = true) = (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < k) ∧ a[Int.toNat i]! = x)) → ((0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length a)) ∧ (let v : ℤ := a[Int.toNat k]!; ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length dejavu1)) ∧ (if dejavu1[Int.toNat v]! = true then ¬(∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a) → ¬i = j → ¬a[Int.toNat i]! = a[Int.toNat j]!) else let o2 : Bool := true; ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length dejavu1)) ∧ (List.length (List.set dejavu1 (Int.toNat v) o2) = List.length dejavu1 → getElem! (List.set dejavu1 (Int.toNat v) o2) ∘ Int.toNat = Function.update (getElem! dejavu1 ∘ Int.toNat) v o2 → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < k + (1 : ℤ) → (0 : ℤ) ≤ j ∧ j < k + (1 : ℤ) → ¬i = j → ¬a[Int.toNat i]! = a[Int.toNat j]!) ∧ (∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < m → ((List.set dejavu1 (Int.toNat v) o2)[Int.toNat x]! = true) = (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < k + (1 : ℤ)) ∧ a[Int.toNat i]! = x)))))) ∧ ((∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < o1 + (1 : ℤ) → (0 : ℤ) ≤ j ∧ j < o1 + (1 : ℤ) → ¬i = j → ¬a[Int.toNat i]! = a[Int.toNat j]!) ∧ (∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < m → (dejavu1[Int.toNat x]! = true) = (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < o1 + (1 : ℤ)) ∧ a[Int.toNat i]! = x)) → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a) → ¬i = j → ¬a[Int.toNat i]! = a[Int.toNat j]!)))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a) → ¬i = j → ¬a[Int.toNat i]! = a[Int.toNat j]!))))
  := sorry
end all_distinct_AllDistinct_all_distinctqtvc
