theory conjugate_Conjugate_conjugateqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref"
begin
definition is_partition :: "int list \<Rightarrow> _"
  where "is_partition a \<longleftrightarrow> (0 :: int) < int (length a) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> j \<and> j < int (length a) \<longrightarrow> a ! nat j \<le> a ! nat i) \<and> a ! nat (int (length a) - (1 :: int)) = (0 :: int)" for a
definition numofgt :: "int list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "numofgt a n v \<longleftrightarrow> ((0 :: int) \<le> n \<and> n < int (length a)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < n \<longrightarrow> v < a ! nat j) \<and> a ! nat n \<le> v" for a n v
definition is_conjugate :: "int list \<Rightarrow> int list \<Rightarrow> _"
  where "is_conjugate a b \<longleftrightarrow> a ! (0 :: nat) < int (length b) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length b) \<longrightarrow> numofgt a (b ! nat j) j)" for a b
theorem conjugate'vc:
  fixes a :: "int list"
  assumes fact0: "is_partition a"
  shows "(0 :: int) \<le> (0 :: int)"
  and "(0 :: int) < int (length a)"
  and "let o1 :: int = a ! (0 :: nat) + (1 :: int) in (0 :: int) \<le> o1 \<and> (\<forall>(b :: int list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < o1 \<longrightarrow> b ! nat i = (0 :: int)) \<and> int (length b) = o1 \<longrightarrow> (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length a)) \<and> (\<forall>(j :: int). a ! (0 :: nat) \<le> j \<and> j < int (length b) \<longrightarrow> numofgt a (b ! nat j) j)) \<and> (\<forall>(partc :: int) (b1 :: int list). length b1 = length b \<longrightarrow> ((0 :: int) \<le> partc \<and> partc < int (length a)) \<and> (\<forall>(j :: int). a ! nat partc \<le> j \<and> j < int (length b1) \<longrightarrow> numofgt a (b1 ! nat j) j) \<longrightarrow> ((0 :: int) \<le> partc \<and> partc < int (length a)) \<and> (if \<not>a ! nat partc = (0 :: int) then ((0 :: int) \<le> partc \<and> partc < int (length a)) \<and> (let edge :: int = a ! nat partc in ((partc \<le> partc + (1 :: int) \<and> partc + (1 :: int) < int (length a)) \<and> (\<forall>(j :: int). partc \<le> j \<and> j < partc + (1 :: int) \<longrightarrow> a ! nat j = edge)) \<and> (\<forall>(partc1 :: int). (partc \<le> partc1 \<and> partc1 < int (length a)) \<and> (\<forall>(j :: int). partc \<le> j \<and> j < partc1 \<longrightarrow> a ! nat j = edge) \<longrightarrow> ((0 :: int) \<le> partc1 \<and> partc1 < int (length a)) \<and> (if a ! nat partc1 = edge then ((0 :: int) \<le> int (length a) - partc1 \<and> int (length a) - (partc1 + (1 :: int)) < int (length a) - partc1) \<and> (partc \<le> partc1 + (1 :: int) \<and> partc1 + (1 :: int) < int (length a)) \<and> (\<forall>(j :: int). partc \<le> j \<and> j < partc1 + (1 :: int) \<longrightarrow> a ! nat j = edge) else let o2 :: int = edge - (1 :: int) in ((0 :: int) \<le> partc1 \<and> partc1 < int (length a)) \<and> (let o3 :: int = a ! nat partc1 in (o3 \<le> o2 + (1 :: int) \<longrightarrow> (\<forall>(j :: int). a ! nat partc1 \<le> j \<and> j < o3 \<longrightarrow> b1 ! nat j = partc1) \<and> (\<forall>(b2 :: int list). length b2 = length b1 \<longrightarrow> (\<forall>(i :: int). (o3 \<le> i \<and> i \<le> o2) \<and> (\<forall>(j :: int). edge \<le> j \<and> j < int (length b2) \<longrightarrow> b2 ! nat j = b1 ! nat j) \<and> (\<forall>(j :: int). a ! nat partc1 \<le> j \<and> j < i \<longrightarrow> b2 ! nat j = partc1) \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length b2)) \<and> (length (b2[nat i := partc1]) = length b2 \<longrightarrow> nth (b2[nat i := partc1]) o nat = (nth b2 o nat)(i := partc1) \<longrightarrow> (\<forall>(j :: int). edge \<le> j \<and> j < int (length (b2[nat i := partc1])) \<longrightarrow> b2[nat i := partc1] ! nat j = b1 ! nat j) \<and> (\<forall>(j :: int). a ! nat partc1 \<le> j \<and> j < i + (1 :: int) \<longrightarrow> b2[nat i := partc1] ! nat j = partc1))) \<and> ((\<forall>(j :: int). edge \<le> j \<and> j < int (length b2) \<longrightarrow> b2 ! nat j = b1 ! nat j) \<and> (\<forall>(j :: int). a ! nat partc1 \<le> j \<and> j < o2 + (1 :: int) \<longrightarrow> b2 ! nat j = partc1) \<longrightarrow> ((0 :: int) \<le> int (length a) - partc \<and> int (length a) - partc1 < int (length a) - partc) \<and> ((0 :: int) \<le> partc1 \<and> partc1 < int (length a)) \<and> (\<forall>(j :: int). a ! nat partc1 \<le> j \<and> j < int (length b2) \<longrightarrow> numofgt a (b2 ! nat j) j)))) \<and> (o2 + (1 :: int) < o3 \<longrightarrow> ((0 :: int) \<le> int (length a) - partc \<and> int (length a) - partc1 < int (length a) - partc) \<and> ((0 :: int) \<le> partc1 \<and> partc1 < int (length a)) \<and> (\<forall>(j :: int). a ! nat partc1 \<le> j \<and> j < int (length b1) \<longrightarrow> numofgt a (b1 ! nat j) j)))))) else is_conjugate a b1)))"
  sorry
end
