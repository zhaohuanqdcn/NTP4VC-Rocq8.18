From Stdlib Require Import Strings.String.
From Stdlib Require Import String Ascii.
From Stdlib Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Stdlib Require Classical.
From Stdlib Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Stdlib Require Import Sorting.Sorted.
From Stdlib Require Import Reals.Rbasic_fun.
From Stdlib Require Import Reals.Abstract.ConstructiveAbs.
From Stdlib Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Stdlib Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Stdlib Require Import ZArith.Zeuclid.
From Stdlib Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Stdlib Require Import Reals.
Require Import Why3.Base.
Require Import Why3.why3.Ref.Ref.
Require Import Why3.map.Const.
Require Import Why3.map.MapEq.
Require Import Why3.real.Truncate.
Require Import Why3.mach.c.C.
Require Import Why3.mach.int.Unsigned.
Require Import multiprecision.types.Config.
Require Import multiprecision.types.Types.
Require Import multiprecision.types.Int32Eq.
Require Import multiprecision.types.UInt64Eq.
Require Import multiprecision.lemmas.Lemmas.
Require Import multiprecision.compare.Compare.
Require Import multiprecision.util.Util.
Require Import multiprecision.ptralias.Alias.
Require Import multiprecision.util.UtilOld.
Require Import multiprecision.add_1.Add_1.
Require Import multiprecision.add.Add.
Require Import multiprecision.add.AddOld.
Require Import multiprecision.sub_1.Sub_1.
Require Import multiprecision.sub.SubOld.
Require Import multiprecision.mul.Mul.
Require Import multiprecision.logical.LogicalUtil.
Require Import multiprecision.logical.Logical.
Require Import multiprecision.logical.LogicalOld.
Require Import multiprecision.div.Div.
Require Import multiprecision.sqrt.Sqrt1.
Require Import Why3.mach.fxp.Fxp.
Open Scope Z_scope.
Theorem wmpn_sqrtrem2'vc (rp : ptr (bv 64%N)) (sp : ptr (bv 64%N)) (np : ptr (bv 64%N)) (fact0 : valid rp 1%Z) (fact1 : valid sp 1%Z) (fact2 : valid np 2%Z) (fact3 : Z.pow 2%Z (64%Z - 2%Z) ≤ bv_unsigned (pelts np (offset np + 1%Z))) (fact4 : writable sp = true) (fact5 : writable rp = true) : min np ≤ offset np ∧ offset np < C.max np ∧ (let np0 : bv 64%N := pelts np (offset np) in (min np ≤ offset np + 1%Z ∧ offset np + 1%Z < C.max np) ∧ (min np ≤ offset np + 1%Z ∧ offset np + 1%Z < C.max np) ∧ (let o1 : bv 64%N := pelts np (offset np + 1%Z) in (valid rp 1%Z ∧ 4611686018427387904%Z ≤ bv_unsigned o1 ∧ writable rp = true) ∧ (∀(rp1 : ptr (bv 64%N)), length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> (∀(o2 : bv 64%N), (bv_unsigned o2 * bv_unsigned o2 ≤ bv_unsigned o1 ∧ bv_unsigned o1 < (bv_unsigned o2 + 1%Z) * (bv_unsigned o2 + 1%Z)) ∧ bv_unsigned o2 * bv_unsigned o2 + bv_unsigned (pelts rp1 (offset rp1)) = bv_unsigned o1 ∧ bv_unsigned (pelts rp1 (offset rp1)) ≤ 2%Z * bv_unsigned o2 -> (min rp1 ≤ offset rp1 ∧ offset rp1 < C.max rp1) ∧ (let o3 : bv 64%N := pelts rp1 (offset rp1) in uint'64_in_bounds 64%Z ∧ (∀(o4 : bv 64%N), bv_unsigned o4 = 64%Z -> (¬ 2%Z = 0%Z ∧ uint'64_in_bounds (Z.rem (bv_unsigned o4) 2%Z)) ∧ (∀(prec : bv 64%N), bv_unsigned prec = Z.rem (bv_unsigned o4) 2%Z -> uint'64_in_bounds (bv_unsigned prec + 1%Z) ∧ (∀(o5 : bv 64%N), bv_unsigned o5 = bv_unsigned prec + 1%Z -> (0%Z ≤ bv_unsigned o5 ∧ bv_unsigned o5 < 64%Z) ∧ (∀(nph : bv 64%N), bv_unsigned nph = ZEuclid.div (bv_unsigned np0) (Z.pow 2%Z (bv_unsigned o5)) -> uint'64_in_bounds (bv_unsigned prec - 1%Z) ∧ (∀(o6 : bv 64%N), bv_unsigned o6 = bv_unsigned prec - 1%Z -> ((0%Z ≤ bv_unsigned o6 ∧ bv_unsigned o6 < 64%Z) ∧ Z.pow 2%Z (bv_unsigned o6) * bv_unsigned o3 ≤ 18446744073709551615%Z) ∧ (∀(o7 : bv 64%N), bv_unsigned o7 = Z.pow 2%Z (bv_unsigned o6) * bv_unsigned o3 -> uint'64_in_bounds (bv_unsigned o7 + bv_unsigned nph) ∧ (∀(o8 : bv 64%N), bv_unsigned o8 = bv_unsigned o7 + bv_unsigned nph -> (¬ bv_unsigned o2 = 0%Z ∧ uint'64_in_bounds (Z.rem (bv_unsigned o8) (bv_unsigned o2))) ∧ (∀(o9 : bv 64%N), bv_unsigned o9 = Z.rem (bv_unsigned o8) (bv_unsigned o2) -> ((0%Z ≤ bv_unsigned prec ∧ bv_unsigned prec < 64%Z) ∧ (∀(rq : bv 64%N), bv_unsigned rq = ZEuclid.div (bv_unsigned o9) (Z.pow 2%Z (bv_unsigned prec)) -> uint'64_in_bounds (bv_unsigned o9 - bv_unsigned rq) ∧ (∀(o10 : bv 64%N), bv_unsigned o10 = bv_unsigned o9 - bv_unsigned rq -> (if decide (bv_unsigned o9 = Z.pow 2%Z (bv_unsigned prec)) then bv_unsigned o10 = Z.pow 2%Z (bv_unsigned prec) - 1%Z else o10 = o9) ∧ bv_unsigned o10 < Z.pow 2%Z (bv_unsigned prec)))) ∧ (∀(q : bv 64%N), (if decide (bv_unsigned o9 = Z.pow 2%Z (bv_unsigned prec)) then bv_unsigned q = Z.pow 2%Z (bv_unsigned prec) - 1%Z else q = o9) ∧ bv_unsigned q < Z.pow 2%Z (bv_unsigned prec) -> uint'64_in_bounds (bv_unsigned q * bv_unsigned o2) ∧ (∀(o10 : bv 64%N), bv_unsigned o10 = bv_unsigned q * bv_unsigned o2 -> uint'64_in_bounds (bv_unsigned o8 - bv_unsigned o10) ∧ (∀(u : bv 64%N), bv_unsigned u = bv_unsigned o8 - bv_unsigned o10 -> ((0%Z ≤ bv_unsigned prec ∧ bv_unsigned prec < 64%Z) ∧ Z.pow 2%Z (bv_unsigned prec) * bv_unsigned o2 ≤ 18446744073709551615%Z) ∧ (∀(o11 : bv 64%N), bv_unsigned o11 = Z.pow 2%Z (bv_unsigned prec) * bv_unsigned o2 -> uint'64_in_bounds (bv_unsigned o11 + bv_unsigned q) ∧ (∀(o12 : bv 64%N), bv_unsigned o12 = bv_unsigned o11 + bv_unsigned q -> uint'64_in_bounds (bv_unsigned prec - 1%Z) ∧ (∀(o13 : bv 64%N), bv_unsigned o13 = bv_unsigned prec - 1%Z -> (0%Z ≤ bv_unsigned o13 ∧ bv_unsigned o13 < 64%Z) ∧ (∀(uh : bv 64%N), bv_unsigned uh = ZEuclid.div (bv_unsigned u) (Z.pow 2%Z (bv_unsigned o13)) -> bv_unsigned uh ≤ 9223372036854775807%Z ∧ (∀(o14 : bv 64%N), bv_signed o14 = bv_unsigned uh -> uint'64_in_bounds (bv_unsigned prec + 1%Z) ∧ (∀(o15 : bv 64%N), bv_unsigned o15 = bv_unsigned prec + 1%Z -> ((0%Z ≤ bv_unsigned o15 ∧ bv_unsigned o15 < 64%Z) ∧ Z.pow 2%Z (bv_unsigned o15) * bv_unsigned (1%bv : bv 64%N) ≤ 18446744073709551615%Z) ∧ (∀(o16 : bv 64%N), bv_unsigned o16 = Z.pow 2%Z (bv_unsigned o15) * bv_unsigned (1%bv : bv 64%N) -> (¬ bv_unsigned o16 = 0%Z ∧ uint'64_in_bounds (Z.quot (bv_unsigned np0) (bv_unsigned o16))) ∧ (∀(npl : bv 64%N), bv_unsigned npl = Z.quot (bv_unsigned np0) (bv_unsigned o16) -> uint'64_in_bounds (bv_unsigned prec + 1%Z) ∧ (∀(o17 : bv 64%N), bv_unsigned o17 = bv_unsigned prec + 1%Z -> (0%Z ≤ bv_unsigned o17 ∧ bv_unsigned o17 < 64%Z) ∧ (∀(ul : bv 64%N), bv_unsigned ul = ZEuclid.modulo (bv_unsigned u * Z.pow 2%Z (bv_unsigned o17)) (18446744073709551615%Z + 1%Z) ∧ bv_unsigned ul ≤ 18446744073709551615%Z + 1%Z - Z.pow 2%Z (bv_unsigned o17) -> uint'64_in_bounds (bv_unsigned ul + bv_unsigned npl) ∧ (∀(o18 : bv 64%N), bv_unsigned o18 = bv_unsigned ul + bv_unsigned npl -> uint'64_in_bounds (bv_unsigned q * bv_unsigned q) ∧ (∀(q2 : bv 64%N), bv_unsigned q2 = bv_unsigned q * bv_unsigned q -> (if decide (bv_unsigned o18 < bv_unsigned q2) then int'64_in_bounds (bv_signed o14 - 1%Z) ∧ (∀(o19 : bv 64%N), bv_signed o19 = bv_signed o14 - 1%Z -> (∀(o20 : bv 64%N), bv_unsigned o20 = ZEuclid.modulo (bv_unsigned o18 - bv_unsigned q2) (18446744073709551615%Z + 1%Z) -> bv_unsigned o20 + (18446744073709551615%Z + 1%Z) * bv_signed o19 = bv_unsigned o18 + (18446744073709551615%Z + 1%Z) * bv_signed o14 - bv_unsigned q2)) else ∀(o19 : bv 64%N), bv_unsigned o19 = ZEuclid.modulo (bv_unsigned o18 - bv_unsigned q2) (18446744073709551615%Z + 1%Z) -> bv_unsigned o19 + (18446744073709551615%Z + 1%Z) * bv_signed o14 = bv_unsigned o18 + (18446744073709551615%Z + 1%Z) * bv_signed o14 - bv_unsigned q2) ∧ (∀(cc : bv 64%N) (rp0 : bv 64%N), bv_unsigned rp0 + (18446744073709551615%Z + 1%Z) * bv_signed cc = bv_unsigned o18 + (18446744073709551615%Z + 1%Z) * bv_signed o14 - bv_unsigned q2 -> (if decide (bv_signed cc < 0%Z) then (∀(o19 : bv 64%N), bv_unsigned o19 = ZEuclid.modulo (bv_unsigned rp0 + bv_unsigned o12) (18446744073709551615%Z + 1%Z) -> (if decide (bv_unsigned o19 < bv_unsigned o12) then int'64_in_bounds (bv_signed cc + 1%Z) ∧ (∀(o20 : bv 64%N), bv_signed o20 = bv_signed cc + 1%Z -> bv_unsigned o19 + (18446744073709551615%Z + 1%Z) * bv_signed o20 = bv_unsigned rp0 + (18446744073709551615%Z + 1%Z) * bv_signed cc + bv_unsigned o12 ∧ (0%Z ≤ bv_signed o20 ∨ bv_unsigned o19 = bv_unsigned rp0 + bv_unsigned o12)) else bv_unsigned o19 + (18446744073709551615%Z + 1%Z) * bv_signed cc = bv_unsigned rp0 + (18446744073709551615%Z + 1%Z) * bv_signed cc + bv_unsigned o12 ∧ (0%Z ≤ bv_signed cc ∨ bv_unsigned o19 = bv_unsigned rp0 + bv_unsigned o12))) ∧ (∀(cc1 : bv 64%N) (rp01 : bv 64%N), bv_unsigned rp01 + (18446744073709551615%Z + 1%Z) * bv_signed cc1 = bv_unsigned rp0 + (18446744073709551615%Z + 1%Z) * bv_signed cc + bv_unsigned o12 ∧ (0%Z ≤ bv_signed cc1 ∨ bv_unsigned rp01 = bv_unsigned rp0 + bv_unsigned o12) -> uint'64_in_bounds (bv_unsigned o12 - 1%Z) ∧ (∀(o19 : bv 64%N), bv_unsigned o19 = bv_unsigned o12 - 1%Z -> (∀(o20 : bv 64%N), bv_unsigned o20 = ZEuclid.modulo (bv_unsigned rp01 + bv_unsigned o19) (18446744073709551615%Z + 1%Z) -> (if decide (bv_unsigned o20 < bv_unsigned o19) then int'64_in_bounds (bv_signed cc1 + 1%Z) ∧ (∀(o21 : bv 64%N), bv_signed o21 = bv_signed cc1 + 1%Z -> bv_unsigned o20 + (18446744073709551615%Z + 1%Z) * bv_signed o21 = bv_unsigned rp01 + (18446744073709551615%Z + 1%Z) * bv_signed cc1 + bv_unsigned o19 ∧ 0%Z ≤ bv_signed o21) else bv_unsigned o20 + (18446744073709551615%Z + 1%Z) * bv_signed cc1 = bv_unsigned rp01 + (18446744073709551615%Z + 1%Z) * bv_signed cc1 + bv_unsigned o19 ∧ 0%Z ≤ bv_signed cc1)) ∧ (∀(cc2 : bv 64%N) (rp02 : bv 64%N), bv_unsigned rp02 + (18446744073709551615%Z + 1%Z) * bv_signed cc2 = bv_unsigned rp01 + (18446744073709551615%Z + 1%Z) * bv_signed cc1 + bv_unsigned o19 ∧ 0%Z ≤ bv_signed cc2 -> ((min rp1 ≤ offset rp1 ∧ offset rp1 < C.max rp1) ∧ writable rp1 = true) ∧ (∀(rp2 : ptr (bv 64%N)), length (data rp2) = length (data rp1) ∧ offset rp2 = offset rp1 ∧ min rp2 = min rp1 ∧ C.max rp2 = C.max rp1 ∧ writable rp2 = writable rp1 ∧ zone1 rp2 = zone1 rp1 -> pelts rp2 = fun_updt (pelts rp1) (offset rp2) rp02 -> ((min sp ≤ offset sp ∧ offset sp < C.max sp) ∧ writable sp = true) ∧ (∀(sp1 : ptr (bv 64%N)), length (data sp1) = length (data sp) ∧ offset sp1 = offset sp ∧ min sp1 = min sp ∧ C.max sp1 = C.max sp ∧ writable sp1 = writable sp ∧ zone1 sp1 = zone1 sp -> pelts sp1 = fun_updt (pelts sp) (offset sp1) o19 -> 0%Z ≤ bv_signed cc2 ∧ (∀(result : bv 64%N), bv_unsigned result = bv_signed cc2 -> value np 2%Z = bv_unsigned (pelts sp1 (offset sp1)) * bv_unsigned (pelts sp1 (offset sp1)) + bv_unsigned result * (18446744073709551615%Z + 1%Z) + bv_unsigned (pelts rp2 (offset rp2)) ∧ bv_unsigned (pelts rp2 (offset rp2)) + bv_unsigned result * (18446744073709551615%Z + 1%Z) ≤ 2%Z * bv_unsigned (pelts sp1 (offset sp1)) ∧ 0%Z ≤ bv_unsigned result ∧ bv_unsigned result ≤ 1%Z)))))) else ((min rp1 ≤ offset rp1 ∧ offset rp1 < C.max rp1) ∧ writable rp1 = true) ∧ (∀(rp2 : ptr (bv 64%N)), length (data rp2) = length (data rp1) ∧ offset rp2 = offset rp1 ∧ min rp2 = min rp1 ∧ C.max rp2 = C.max rp1 ∧ writable rp2 = writable rp1 ∧ zone1 rp2 = zone1 rp1 -> pelts rp2 = fun_updt (pelts rp1) (offset rp2) rp0 -> ((min sp ≤ offset sp ∧ offset sp < C.max sp) ∧ writable sp = true) ∧ (∀(sp1 : ptr (bv 64%N)), length (data sp1) = length (data sp) ∧ offset sp1 = offset sp ∧ min sp1 = min sp ∧ C.max sp1 = C.max sp ∧ writable sp1 = writable sp ∧ zone1 sp1 = zone1 sp -> pelts sp1 = fun_updt (pelts sp) (offset sp1) o12 -> 0%Z ≤ bv_signed cc ∧ (∀(result : bv 64%N), bv_unsigned result = bv_signed cc -> value np 2%Z = bv_unsigned (pelts sp1 (offset sp1)) * bv_unsigned (pelts sp1 (offset sp1)) + bv_unsigned result * (18446744073709551615%Z + 1%Z) + bv_unsigned (pelts rp2 (offset rp2)) ∧ bv_unsigned (pelts rp2 (offset rp2)) + bv_unsigned result * (18446744073709551615%Z + 1%Z) ≤ 2%Z * bv_unsigned (pelts sp1 (offset sp1)) ∧ 0%Z ≤ bv_unsigned result ∧ bv_unsigned result ≤ 1%Z))))))))))))))))))))))))))))))))).
Admitted.
