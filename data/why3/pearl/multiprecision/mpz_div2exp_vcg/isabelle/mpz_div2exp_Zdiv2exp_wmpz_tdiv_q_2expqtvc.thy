theory mpz_div2exp_Zdiv2exp_wmpz_tdiv_q_2expqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/mpz_Z" "../../lib/isabelle/mpz_Zutil"
begin
theorem wmpz_tdiv_q_2exp'vc:
  fixes mpz :: "mpz_memo"
  fixes r :: "mpz_ptr"
  fixes u :: "mpz_ptr"
  fixes cnt :: "64 word"
  assumes fact0: "(1 :: int) \<le> alloc mpz r"
  assumes fact1: "(1 :: int) \<le> alloc mpz u"
  assumes fact2: "readers mpz r = (0 :: int)"
  assumes fact3: "readers mpz u = (0 :: int)"
  assumes fact4: "abs_size mpz u + uint cnt cdiv (64 :: int) + (1 :: int) \<le> (2147483647 :: int)"
  shows "-(2 :: int) < readers mpz u"
  and "\<forall>(un :: 32 word). sint un = sgn mpz u * abs_size mpz u \<longrightarrow> (\<not>(64 :: int) = (0 :: int) \<and> uint'64_in_bounds (uint cnt cdiv (64 :: int))) \<and> (\<forall>(o1 :: 64 word). uint o1 = uint cnt cdiv (64 :: int) \<longrightarrow> uint o1 \<le> (2147483647 :: int) \<and> (\<forall>(limb_cnt :: 32 word). sint limb_cnt = uint o1 \<longrightarrow> -(2147483648 :: int) < sint un \<and> (\<forall>(o2 :: 32 word). sint o2 = abs (sint un) \<longrightarrow> int'32_in_bounds (sint o2 - sint limb_cnt) \<and> (\<forall>(o3 :: 32 word). sint o3 = sint o2 - sint limb_cnt \<longrightarrow> (if sint o3 \<le> (0 :: int) then (-(1 :: int) \<le> readers mpz r \<and> readers mpz r \<le> (0 :: int)) \<and> (\<forall>(mpz1 :: mpz_memo). alloc mpz1 = alloc mpz \<and> sgn mpz1 = sgn mpz \<and> readers mpz1 = readers mpz \<and> zones mpz1 = zones mpz \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> mpz_unchanged y mpz1 mpz) \<and> abs_size mpz1 r = (0 :: int) \<and> abs_value_of mpz1 r = (0 :: int) \<longrightarrow> value_of r mpz1 = value_of u mpz cdiv (2 :: int) ^\<^sub>i uint cnt \<and> (\<forall>(x :: mpz_ptr). \<not>x = r \<longrightarrow> mpz_unchanged x mpz1 mpz) \<and> readers mpz1 r = (0 :: int) \<and> readers mpz1 u = (0 :: int)) else (readers mpz r = (0 :: int) \<and> (1 :: int) \<le> alloc mpz r) \<and> (\<forall>(mpz1 :: mpz_memo). sgn mpz1 = sgn mpz \<longrightarrow> (\<forall>(rp :: 64 word ptr). (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> mpz_unchanged y mpz1 mpz) \<and> readers mpz1 r = -(1 :: int) \<and> abs_value_of mpz1 r = value rp (abs_size mpz1 r) \<and> zones mpz1 r = zone1 rp \<and> offset rp = (0 :: int) \<and> plength rp = alloc mpz1 r \<and> c_C.min rp = (0 :: int) \<and> c_C.max rp = plength rp \<and> writable rp = True \<and> abs_size mpz1 r = abs_size mpz r \<and> value rp (abs_size mpz r) = abs_value_of mpz r \<and> (if alloc mpz r < sint o3 then alloc mpz1 r = sint o3 else alloc mpz1 r = alloc mpz r) \<longrightarrow> (\<not>(64 :: int) = (0 :: int) \<and> uint'64_in_bounds (uint cnt cmod (64 :: int))) \<and> (\<forall>(c :: 64 word). uint c = uint cnt cmod (64 :: int) \<longrightarrow> (mpz_eq u r \<longleftrightarrow> u = r) \<longrightarrow> (if mpz_eq u r then (c_C.min rp \<le> offset rp + sint limb_cnt \<and> offset rp + sint limb_cnt \<le> c_C.max rp) \<and> (\<forall>(up :: 64 word ptr). offset up = offset rp + sint limb_cnt \<and> plength up = plength rp \<and> pelts up = pelts rp \<and> data up = data rp \<and> c_C.min up = c_C.min rp \<and> c_C.max up = c_C.max rp \<and> zone1 up = zone1 rp \<and> writable up = writable rp \<longrightarrow> (\<forall>(o4 :: bool). (uint c = uint (0 :: 64 word) \<longrightarrow> o4 = True) \<and> (o4 = True \<longrightarrow> c = (0 :: 64 word)) \<longrightarrow> (if \<not>o4 = True then (((0 :: int) < uint c \<and> uint c < (64 :: int)) \<and> valid up (sint o3) \<and> valid rp (sint o3) \<and> (0 :: int) < sint o3 \<and> writable rp = True \<and> (offset rp \<le> offset up \<or> offset up + sint o3 \<le> offset rp)) \<and> (\<forall>(up1 :: 64 word ptr) (rp1 :: 64 word ptr). data up1 = data rp1 \<and> length (data rp1) = length (data up) \<and> offset up1 = offset up \<and> c_C.min up1 = c_C.min up \<and> c_C.max up1 = c_C.max up \<and> writable up1 = writable up \<and> zone1 up1 = zone1 up \<longrightarrow> length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(x_m :: 64 word). uint x_m + ((18446744073709551615 :: int) + (1 :: int)) * value rp1 (sint o3) = value up (sint o3) * (2 :: int) ^\<^sub>i ((64 :: int) - uint c) \<and> (\<forall>(j :: int). j < offset rp1 \<or> offset rp1 + sint o3 \<le> j \<longrightarrow> pelts rp1 j = pelts rp j) \<and> (c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> plength rp1 = plength rp) \<and> c_C.min up1 = c_C.min up \<and> c_C.max up1 = c_C.max up \<and> plength up1 = plength up \<longrightarrow> \<not>(18446744073709551615 :: int) + (1 :: int) = (0 :: int) \<and> int'32_in_bounds (sint o3 - (1 :: int)) \<and> (\<forall>(o5 :: 32 word). sint o5 = sint o3 - (1 :: int) \<longrightarrow> (c_C.min rp1 \<le> offset rp1 + sint o5 \<and> offset rp1 + sint o5 < c_C.max rp1) \<and> (let o6 :: 64 word = pelts rp1 (offset rp1 + sint o5) in \<forall>(o7 :: bool). (uint o6 = uint (0 :: 64 word) \<longrightarrow> o7 = True) \<and> (o7 = True \<longrightarrow> o6 = (0 :: 64 word)) \<longrightarrow> (\<forall>(o8 :: 32 word). (if o7 = True then o8 = (1 :: 32 word) else o8 = (0 :: 32 word)) \<longrightarrow> int'32_in_bounds (sint o3 - sint o8) \<and> (\<forall>(o9 :: 32 word). sint o9 = sint o3 - sint o8 \<longrightarrow> -(2 :: int) < readers mpz1 u \<and> (\<forall>(o10 :: 32 word). sint o10 = sgn mpz1 u * abs_size mpz1 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o10 \<longrightarrow> int'32_in_bounds (-sint o9)) \<and> ((\<not>(0 :: int) \<le> sint o10 \<longrightarrow> (\<exists>(nrn :: 32 word). sint nrn = -sint o9)) \<longrightarrow> -(2 :: int) < readers mpz1 u \<and> (\<forall>(o11 :: 32 word). sint o11 = sgn mpz1 u * abs_size mpz1 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o11 \<longrightarrow> int'32_in_bounds (-sint o9)) \<and> (\<forall>(o12 :: 32 word). (if (0 :: int) \<le> sint o11 then o12 = o9 else sint o12 = -sint o9) \<longrightarrow> (zones mpz1 r = zone1 rp1 \<and> readers mpz1 r = -(1 :: int) \<and> offset rp1 = (0 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs (sint o12) \<le> plength rp1 \<and> plength rp1 = alloc mpz1 r \<and> (\<not>sint o12 = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint o12) - (1 :: int)) \<le> value rp1 (abs (sint o12)))) \<and> (\<forall>(mpz2 :: mpz_memo). alloc mpz2 = alloc mpz1 \<and> readers mpz2 = readers mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> mpz_unchanged y mpz2 mpz1) \<and> (sgn mpz2 r = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint o12) \<and> (sgn mpz2 r = -(1 :: int) \<longleftrightarrow> sint o12 < (0 :: int)) \<and> abs_size mpz2 r = abs (sint o12) \<and> abs_value_of mpz2 r = value rp1 (abs (sint o12)) \<longrightarrow> (zones mpz2 r = zone1 rp1 \<and> readers mpz2 r = -(1 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs_value_of mpz2 r = value rp1 (abs_size mpz2 r)) \<and> (\<forall>(mpz3 :: mpz_memo). abs_value_of mpz3 = abs_value_of mpz2 \<and> alloc mpz3 = alloc mpz2 \<and> abs_size mpz3 = abs_size mpz2 \<and> sgn mpz3 = sgn mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> readers mpz3 r = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> readers mpz3 y = readers mpz2 y) \<longrightarrow> value_of r mpz3 = value_of u mpz cdiv (2 :: int) ^\<^sub>i uint cnt \<and> (\<forall>(x :: mpz_ptr). \<not>x = r \<longrightarrow> mpz_unchanged x mpz3 mpz) \<and> readers mpz3 r = (0 :: int) \<and> readers mpz3 u = (0 :: int))))))))))))) else (valid up (sint o3) \<and> valid rp (sint o3) \<and> writable rp = True \<and> (offset rp \<le> offset up \<or> offset up + sint o3 \<le> offset rp)) \<and> (\<forall>(up1 :: 64 word ptr) (rp1 :: 64 word ptr). data up1 = data rp1 \<and> length (data rp1) = length (data up) \<and> offset up1 = offset up \<and> c_C.min up1 = c_C.min up \<and> c_C.max up1 = c_C.max up \<and> writable up1 = writable up \<and> zone1 up1 = zone1 up \<longrightarrow> length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> map_eq_sub_shift (pelts rp1) (pelts up) (offset rp1) (offset up1) (sint o3) \<and> (\<forall>(j :: int). j < offset rp1 \<or> offset rp1 + sint o3 \<le> j \<longrightarrow> pelts rp1 j = pelts rp j) \<longrightarrow> -(2 :: int) < readers mpz1 u \<and> (\<forall>(o5 :: 32 word). sint o5 = sgn mpz1 u * abs_size mpz1 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o5 \<longrightarrow> int'32_in_bounds (-sint o3)) \<and> ((\<not>(0 :: int) \<le> sint o5 \<longrightarrow> (\<exists>(nrn :: 32 word). sint nrn = -sint o3)) \<longrightarrow> -(2 :: int) < readers mpz1 u \<and> (\<forall>(o6 :: 32 word). sint o6 = sgn mpz1 u * abs_size mpz1 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o6 \<longrightarrow> int'32_in_bounds (-sint o3)) \<and> (\<forall>(o7 :: 32 word). (if (0 :: int) \<le> sint o6 then o7 = o3 else sint o7 = -sint o3) \<longrightarrow> (zones mpz1 r = zone1 rp1 \<and> readers mpz1 r = -(1 :: int) \<and> offset rp1 = (0 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs (sint o7) \<le> plength rp1 \<and> plength rp1 = alloc mpz1 r \<and> (\<not>sint o7 = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint o7) - (1 :: int)) \<le> value rp1 (abs (sint o7)))) \<and> (\<forall>(mpz2 :: mpz_memo). alloc mpz2 = alloc mpz1 \<and> readers mpz2 = readers mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> mpz_unchanged y mpz2 mpz1) \<and> (sgn mpz2 r = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint o7) \<and> (sgn mpz2 r = -(1 :: int) \<longleftrightarrow> sint o7 < (0 :: int)) \<and> abs_size mpz2 r = abs (sint o7) \<and> abs_value_of mpz2 r = value rp1 (abs (sint o7)) \<longrightarrow> (zones mpz2 r = zone1 rp1 \<and> readers mpz2 r = -(1 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs_value_of mpz2 r = value rp1 (abs_size mpz2 r)) \<and> (\<forall>(mpz3 :: mpz_memo). abs_value_of mpz3 = abs_value_of mpz2 \<and> alloc mpz3 = alloc mpz2 \<and> abs_size mpz3 = abs_size mpz2 \<and> sgn mpz3 = sgn mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> readers mpz3 r = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> readers mpz3 y = readers mpz2 y) \<longrightarrow> value_of r mpz3 = value_of u mpz cdiv (2 :: int) ^\<^sub>i uint cnt \<and> (\<forall>(x :: mpz_ptr). \<not>x = r \<longrightarrow> mpz_unchanged x mpz3 mpz) \<and> readers mpz3 r = (0 :: int) \<and> readers mpz3 u = (0 :: int))))))))))) else mpz_unchanged u mpz1 mpz \<and> (readers mpz1 u = readers mpz u \<and> (-(2 :: int) < readers mpz1 u \<longrightarrow> abs_value_of mpz1 u = abs_value_of mpz u \<and> alloc mpz1 u = alloc mpz u \<and> abs_size mpz1 u = abs_size mpz u \<and> sgn mpz1 u = sgn mpz u \<and> readers mpz1 u = readers mpz u \<and> zones mpz1 u = zones mpz u) \<longrightarrow> (0 :: int) \<le> readers mpz1 u \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> (\<forall>(up0 :: 64 word ptr). readers mpz2 u = readers mpz1 u + (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>u = y \<longrightarrow> readers mpz2 y = readers mpz1 y) \<and> value up0 (abs_size mpz2 u) = abs_value_of mpz2 u \<and> plength up0 = alloc mpz2 u \<and> offset up0 = (0 :: int) \<and> c_C.min up0 = (0 :: int) \<and> c_C.max up0 = plength up0 \<and> zone1 up0 = zones mpz2 u \<longrightarrow> (c_C.min up0 \<le> offset up0 + sint limb_cnt \<and> offset up0 + sint limb_cnt \<le> c_C.max up0) \<and> (\<forall>(up :: 64 word ptr). offset up = offset up0 + sint limb_cnt \<and> plength up = plength up0 \<and> pelts up = pelts up0 \<and> data up = data up0 \<and> c_C.min up = c_C.min up0 \<and> c_C.max up = c_C.max up0 \<and> zone1 up = zone1 up0 \<and> writable up = writable up0 \<longrightarrow> (\<forall>(o4 :: bool). (uint c = uint (0 :: 64 word) \<longrightarrow> o4 = True) \<and> (o4 = True \<longrightarrow> c = (0 :: 64 word)) \<longrightarrow> (if \<not>o4 = True then (valid up (sint o3) \<and> valid rp (sint o3) \<and> ((0 :: int) < uint c \<and> uint c < (64 :: int)) \<and> (0 :: int) < sint o3 \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(x_m :: 64 word). uint x_m + ((18446744073709551615 :: int) + (1 :: int)) * value rp1 (sint o3) = value up (sint o3) * (2 :: int) ^\<^sub>i ((64 :: int) - uint c) \<longrightarrow> \<not>(18446744073709551615 :: int) + (1 :: int) = (0 :: int) \<and> int'32_in_bounds (sint o3 - (1 :: int)) \<and> (\<forall>(o5 :: 32 word). sint o5 = sint o3 - (1 :: int) \<longrightarrow> (c_C.min rp1 \<le> offset rp1 + sint o5 \<and> offset rp1 + sint o5 < c_C.max rp1) \<and> (let o6 :: 64 word = pelts rp1 (offset rp1 + sint o5) in \<forall>(o7 :: bool). (uint o6 = uint (0 :: 64 word) \<longrightarrow> o7 = True) \<and> (o7 = True \<longrightarrow> o6 = (0 :: 64 word)) \<longrightarrow> (\<forall>(o8 :: 32 word). (if o7 = True then o8 = (1 :: 32 word) else o8 = (0 :: 32 word)) \<longrightarrow> int'32_in_bounds (sint o3 - sint o8) \<and> (\<forall>(o9 :: 32 word). sint o9 = sint o3 - sint o8 \<longrightarrow> (zones mpz2 u = zone1 up0 \<and> (1 :: int) \<le> readers mpz2 u \<and> c_C.min up0 = (0 :: int) \<and> c_C.max up0 = plength up0) \<and> (\<forall>(mpz3 :: mpz_memo). abs_value_of mpz3 = abs_value_of mpz2 \<and> alloc mpz3 = alloc mpz2 \<and> abs_size mpz3 = abs_size mpz2 \<and> sgn mpz3 = sgn mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> readers mpz3 u = readers mpz2 u - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = u \<longrightarrow> readers mpz3 y = readers mpz2 y) \<longrightarrow> -(2 :: int) < readers mpz3 u \<and> (\<forall>(o10 :: 32 word). sint o10 = sgn mpz3 u * abs_size mpz3 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o10 \<longrightarrow> int'32_in_bounds (-sint o9)) \<and> ((\<not>(0 :: int) \<le> sint o10 \<longrightarrow> (\<exists>(nrn :: 32 word). sint nrn = -sint o9)) \<longrightarrow> -(2 :: int) < readers mpz3 u \<and> (\<forall>(o11 :: 32 word). sint o11 = sgn mpz3 u * abs_size mpz3 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o11 \<longrightarrow> int'32_in_bounds (-sint o9)) \<and> (\<forall>(o12 :: 32 word). (if (0 :: int) \<le> sint o11 then o12 = o9 else sint o12 = -sint o9) \<longrightarrow> (zones mpz3 r = zone1 rp1 \<and> readers mpz3 r = -(1 :: int) \<and> offset rp1 = (0 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs (sint o12) \<le> plength rp1 \<and> plength rp1 = alloc mpz3 r \<and> (\<not>sint o12 = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint o12) - (1 :: int)) \<le> value rp1 (abs (sint o12)))) \<and> (\<forall>(mpz4 :: mpz_memo). alloc mpz4 = alloc mpz3 \<and> readers mpz4 = readers mpz3 \<and> zones mpz4 = zones mpz3 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> mpz_unchanged y mpz4 mpz3) \<and> (sgn mpz4 r = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint o12) \<and> (sgn mpz4 r = -(1 :: int) \<longleftrightarrow> sint o12 < (0 :: int)) \<and> abs_size mpz4 r = abs (sint o12) \<and> abs_value_of mpz4 r = value rp1 (abs (sint o12)) \<longrightarrow> (zones mpz4 r = zone1 rp1 \<and> readers mpz4 r = -(1 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs_value_of mpz4 r = value rp1 (abs_size mpz4 r)) \<and> (\<forall>(mpz5 :: mpz_memo). abs_value_of mpz5 = abs_value_of mpz4 \<and> alloc mpz5 = alloc mpz4 \<and> abs_size mpz5 = abs_size mpz4 \<and> sgn mpz5 = sgn mpz4 \<and> zones mpz5 = zones mpz4 \<longrightarrow> readers mpz5 r = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> readers mpz5 y = readers mpz4 y) \<longrightarrow> value_of r mpz5 = value_of u mpz cdiv (2 :: int) ^\<^sub>i uint cnt \<and> (\<forall>(x :: mpz_ptr). \<not>x = r \<longrightarrow> mpz_unchanged x mpz5 mpz) \<and> readers mpz5 r = (0 :: int) \<and> readers mpz5 u = (0 :: int)))))))))))))) else (valid up (sint o3) \<and> valid rp (sint o3) \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> map_eq_sub_shift (pelts rp1) (pelts up) (offset rp1) (offset up) (sint o3) \<and> (\<forall>(j :: int). j < offset rp1 \<or> offset rp1 + sint o3 \<le> j \<longrightarrow> pelts rp1 j = pelts rp j) \<longrightarrow> (zones mpz2 u = zone1 up0 \<and> (1 :: int) \<le> readers mpz2 u \<and> c_C.min up0 = (0 :: int) \<and> c_C.max up0 = plength up0) \<and> (\<forall>(mpz3 :: mpz_memo). abs_value_of mpz3 = abs_value_of mpz2 \<and> alloc mpz3 = alloc mpz2 \<and> abs_size mpz3 = abs_size mpz2 \<and> sgn mpz3 = sgn mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> readers mpz3 u = readers mpz2 u - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = u \<longrightarrow> readers mpz3 y = readers mpz2 y) \<longrightarrow> -(2 :: int) < readers mpz3 u \<and> (\<forall>(o5 :: 32 word). sint o5 = sgn mpz3 u * abs_size mpz3 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o5 \<longrightarrow> int'32_in_bounds (-sint o3)) \<and> ((\<not>(0 :: int) \<le> sint o5 \<longrightarrow> (\<exists>(nrn :: 32 word). sint nrn = -sint o3)) \<longrightarrow> -(2 :: int) < readers mpz3 u \<and> (\<forall>(o6 :: 32 word). sint o6 = sgn mpz3 u * abs_size mpz3 u \<longrightarrow> (\<not>(0 :: int) \<le> sint o6 \<longrightarrow> int'32_in_bounds (-sint o3)) \<and> (\<forall>(o7 :: 32 word). (if (0 :: int) \<le> sint o6 then o7 = o3 else sint o7 = -sint o3) \<longrightarrow> (zones mpz3 r = zone1 rp1 \<and> readers mpz3 r = -(1 :: int) \<and> offset rp1 = (0 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs (sint o7) \<le> plength rp1 \<and> plength rp1 = alloc mpz3 r \<and> (\<not>sint o7 = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint o7) - (1 :: int)) \<le> value rp1 (abs (sint o7)))) \<and> (\<forall>(mpz4 :: mpz_memo). alloc mpz4 = alloc mpz3 \<and> readers mpz4 = readers mpz3 \<and> zones mpz4 = zones mpz3 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> mpz_unchanged y mpz4 mpz3) \<and> (sgn mpz4 r = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint o7) \<and> (sgn mpz4 r = -(1 :: int) \<longleftrightarrow> sint o7 < (0 :: int)) \<and> abs_size mpz4 r = abs (sint o7) \<and> abs_value_of mpz4 r = value rp1 (abs (sint o7)) \<longrightarrow> (zones mpz4 r = zone1 rp1 \<and> readers mpz4 r = -(1 :: int) \<and> c_C.min rp1 = (0 :: int) \<and> c_C.max rp1 = plength rp1 \<and> abs_value_of mpz4 r = value rp1 (abs_size mpz4 r)) \<and> (\<forall>(mpz5 :: mpz_memo). abs_value_of mpz5 = abs_value_of mpz4 \<and> alloc mpz5 = alloc mpz4 \<and> abs_size mpz5 = abs_size mpz4 \<and> sgn mpz5 = sgn mpz4 \<and> zones mpz5 = zones mpz4 \<longrightarrow> readers mpz5 r = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = r \<longrightarrow> readers mpz5 y = readers mpz4 y) \<longrightarrow> value_of r mpz5 = value_of u mpz cdiv (2 :: int) ^\<^sub>i uint cnt \<and> (\<forall>(x :: mpz_ptr). \<not>x = r \<longrightarrow> mpz_unchanged x mpz5 mpz) \<and> readers mpz5 r = (0 :: int) \<and> readers mpz5 u = (0 :: int))))))))))))))))))))))))"
  sorry
end
