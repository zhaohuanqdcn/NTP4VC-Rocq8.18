theory mjrty_Mjrty_mjrtyqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_NumOf"
begin
consts fc :: "'a list \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> bool"
axiomatization where fc'def:   "fc a v i = True \<longleftrightarrow> a ! nat i = v"
  for a :: "'a list"
  and v :: "'a"
  and i :: "int"
typedecl  candidate
theorem mjrty'vc:
  fixes a :: "candidate list"
  assumes fact0: "(1 :: int) \<le> int (length a)"
  shows "let n :: int = int (length a) in ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length a)) \<and> (let o1 :: candidate = a ! (0 :: nat); o2 :: int = n - (1 :: int) in ((0 :: int) \<le> o2 + (1 :: int) \<longrightarrow> (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> int (count_list (drop (0 :: nat) (take ((0 :: nat) - (0 :: nat)) a)) o1)) \<and> (2 :: int) * (int (count_list (drop (0 :: nat) (take ((0 :: nat) - (0 :: nat)) a)) o1) - (0 :: int)) \<le> (0 :: int) - (0 :: int) \<and> (\<forall>(c :: candidate). \<not>c = o1 \<longrightarrow> (2 :: int) * int (count_list (drop (0 :: nat) (take ((0 :: nat) - (0 :: nat)) a)) c) \<le> (0 :: int) - (0 :: int))) \<and> (\<forall>(k :: int) (cand :: candidate). (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o2) \<and> ((0 :: int) \<le> k \<and> k \<le> int (count_list (drop (0 :: nat) (take (nat i - (0 :: nat)) a)) cand)) \<and> (2 :: int) * (int (count_list (drop (0 :: nat) (take (nat i - (0 :: nat)) a)) cand) - k) \<le> i - k \<and> (\<forall>(c :: candidate). \<not>c = cand \<longrightarrow> (2 :: int) * int (count_list (drop (0 :: nat) (take (nat i - (0 :: nat)) a)) c) \<le> i - k) \<longrightarrow> (if k = (0 :: int) then ((0 :: int) \<le> i \<and> i < int (length a)) \<and> ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) \<le> int (count_list (drop (0 :: nat) (take (nat (i + (1 :: int)) - (0 :: nat)) a)) (a ! nat i))) \<and> (2 :: int) * (int (count_list (drop (0 :: nat) (take (nat (i + (1 :: int)) - (0 :: nat)) a)) (a ! nat i)) - (1 :: int)) \<le> i + (1 :: int) - (1 :: int) \<and> (\<forall>(c :: candidate). \<not>c = a ! nat i \<longrightarrow> (2 :: int) * int (count_list (drop (0 :: nat) (take (nat (i + (1 :: int)) - (0 :: nat)) a)) c) \<le> i + (1 :: int) - (1 :: int)) else ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if cand = a ! nat i then ((0 :: int) \<le> k + (1 :: int) \<and> k + (1 :: int) \<le> int (count_list (drop (0 :: nat) (take (nat (i + (1 :: int)) - (0 :: nat)) a)) cand)) \<and> (2 :: int) * (int (count_list (drop (0 :: nat) (take (nat (i + (1 :: int)) - (0 :: nat)) a)) cand) - (k + (1 :: int))) \<le> i + (1 :: int) - (k + (1 :: int)) \<and> (\<forall>(c :: candidate). \<not>c = cand \<longrightarrow> (2 :: int) * int (count_list (drop (0 :: nat) (take (nat (i + (1 :: int)) - (0 :: nat)) a)) c) \<le> i + (1 :: int) - (k + (1 :: int))) else ((0 :: int) \<le> k - (1 :: int) \<and> k - (1 :: int) \<le> int (count_list (drop (0 :: nat) (take (nat (i + (1 :: int)) - (0 :: nat)) a)) cand)) \<and> (2 :: int) * (int (count_list (drop (0 :: nat) (take (nat (i + (1 :: int)) - (0 :: nat)) a)) cand) - (k - (1 :: int))) \<le> i + (1 :: int) - (k - (1 :: int)) \<and> (\<forall>(c :: candidate). \<not>c = cand \<longrightarrow> (2 :: int) * int (count_list (drop (0 :: nat) (take (nat (i + (1 :: int)) - (0 :: nat)) a)) c) \<le> i + (1 :: int) - (k - (1 :: int)))))) \<and> (((0 :: int) \<le> k \<and> k \<le> int (count_list (drop (0 :: nat) (take (nat (o2 + (1 :: int)) - (0 :: nat)) a)) cand)) \<and> (2 :: int) * (int (count_list (drop (0 :: nat) (take (nat (o2 + (1 :: int)) - (0 :: nat)) a)) cand) - k) \<le> o2 + (1 :: int) - k \<and> (\<forall>(c :: candidate). \<not>c = cand \<longrightarrow> (2 :: int) * int (count_list (drop (0 :: nat) (take (nat (o2 + (1 :: int)) - (0 :: nat)) a)) c) \<le> o2 + (1 :: int) - k) \<longrightarrow> (if k = (0 :: int) then \<forall>(c :: candidate). (2 :: int) * int (count_list (drop (0 :: nat) (take (length a - (0 :: nat)) a)) c) \<le> int (length a) else if n < (2 :: int) * k then int (length a) < (2 :: int) * int (count_list (drop (0 :: nat) (take (length a - (0 :: nat)) a)) cand) else let o3 :: int = n - (1 :: int) in ((0 :: int) \<le> o3 + (1 :: int) \<longrightarrow> ((0 :: int) = int (count_list (drop (0 :: nat) (take ((0 :: nat) - (0 :: nat)) a)) cand) \<and> (2 :: int) * (0 :: int) \<le> n) \<and> (\<forall>(k1 :: int). (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o3) \<and> k1 = int (count_list (drop (0 :: nat) (take (nat i - (0 :: nat)) a)) cand) \<and> (2 :: int) * k1 \<le> n \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if a ! nat i = cand then if n < (2 :: int) * (k1 + (1 :: int)) then int (length a) < (2 :: int) * int (count_list (drop (0 :: nat) (take (length a - (0 :: nat)) a)) cand) else k1 + (1 :: int) = int (count_list (drop (0 :: nat) (take (nat (i + (1 :: int)) - (0 :: nat)) a)) cand) \<and> (2 :: int) * (k1 + (1 :: int)) \<le> n else k1 = int (count_list (drop (0 :: nat) (take (nat (i + (1 :: int)) - (0 :: nat)) a)) cand) \<and> (2 :: int) * k1 \<le> n)) \<and> (k1 = int (count_list (drop (0 :: nat) (take (nat (o3 + (1 :: int)) - (0 :: nat)) a)) cand) \<and> (2 :: int) * k1 \<le> n \<longrightarrow> (\<forall>(c :: candidate). (2 :: int) * int (count_list (drop (0 :: nat) (take (length a - (0 :: nat)) a)) c) \<le> int (length a))))) \<and> (o3 + (1 :: int) < (0 :: int) \<longrightarrow> (\<forall>(c :: candidate). (2 :: int) * int (count_list (drop (0 :: nat) (take (length a - (0 :: nat)) a)) c) \<le> int (length a))))))) \<and> (o2 + (1 :: int) < (0 :: int) \<longrightarrow> (\<forall>(c :: candidate). (2 :: int) * int (count_list (drop (0 :: nat) (take (length a - (0 :: nat)) a)) c) \<le> int (length a))))"
  sorry
end
