
(** {1 An Efficient Sudoku Solver }

    Author: Claude March√©       (Inria)
            Guillaume Melquiond (Inria) *)


(** {2 A theory of 9x9 grids} *)

module Grid

  use int.Int
  use map.Map

  (** A grid is a map from integers to integers *)
  type grid = map int int

  (** valid indexes are 0..80 *)
  predicate is_index (i:int) = 0 <= i < 81

  (** valid values are 0..9. 0 denotes an empty cell *)
  predicate valid_values (g:grid) =
    forall i. is_index i -> 0 <= g[i] <= 9

  (** extensional equality of grids and sub-grids *)
  predicate grid_eq_sub (g1 g2:grid) (a b:int) =
    forall j. a <= j < b -> g1[j] = g2[j]

  predicate grid_eq (g1 g2:grid) = grid_eq_sub g1 g2 0 81

  let ghost grid_eq_sub (g1 g2:grid) (a b:int) : unit
    requires { 0 <= a <= 81 }
    requires { 0 <= b <= 81 }
    requires { grid_eq g1 g2 }
    ensures  { grid_eq_sub g1 g2 a b }
  = ()

  (** {3 Grid "Chunks"}

   A chunk is either a column, a row or a square.

   A chunk is defined by a starting index s and a set of 9 offsets
   {o0,..,o8}, that thus denotes a set of 9 cells {s+o0,..,s+o8} in a
   grid.

   Each cell of the grid belongs to 3 chunks, one of each kind.  For
   each cell index, there is a unique starting index respectively for
   the column, the row and the square it belongs to.

  *)

  use array.Array

  type sudoku_chunks =
    { column_start : array int;
      column_offsets : array int;
      row_start : array int;
      row_offsets : array int;
      square_start : array int;
      square_offsets : array int;
    }

  (** Chunks must point to valid indexes of the grid *)
  predicate chunk_valid_indexes (start:array int) (offsets:array int) =
    start.length = 81 /\ offsets.length = 9 /\
    forall i o:int. is_index i /\ 0 <= o < 9 ->
      is_index(start[i] + offsets[o])

  (** Chunks (of the same kind column, row or square) with distinct
      starting cells must be disjoint *)
  predicate disjoint_chunks (start:array int) (offsets:array int) =
    start.length = 81 /\ offsets.length = 9 /\
    forall i1 i2 o:int.
       is_index i1 /\ is_index i2 /\ 0 <= o < 9 ->
       let s1 = start[i1] in
       let s2 = start[i2] in
       s1 <> s2 -> i1 <> s2 + offsets[o]

  (** A sudoku grid is well formed when chunks are valid and disjoint *)
  predicate well_formed_sudoku (s:sudoku_chunks) =
    chunk_valid_indexes s.column_start s.column_offsets /\
    chunk_valid_indexes s.row_start s.row_offsets /\
    chunk_valid_indexes s.square_start s.square_offsets /\
    disjoint_chunks s.column_start s.column_offsets /\
    disjoint_chunks s.row_start s.row_offsets /\
    disjoint_chunks s.square_start s.square_offsets

  (** {3 Valid Sudoku Solutions} *)

  (** `valid_chunk g i start offsets` is true whenever the chunk
  denoted by `start,offsets` from cell `i` is "valid" in grid `g`, in
  the sense that it contains at most one occurrence of each number
  between 1 and 9 *)

  predicate valid_chunk (g:grid) (i:int)
    (start:array int) (offsets:array int) =
    let s = start[i] in
    forall o1 o2 : int. 0 <= o1 < 9 /\ 0 <= o2 < 9 /\ o1 <> o2 ->
      let i1 = s + offsets[o1] in
      let i2 = s + offsets[o2] in
      1 <= Map.get g i1 <= 9 /\ 1 <= Map.get g i2 <= 9 ->
      Map.get g i1 <> Map.get g i2

  predicate valid_column (s:sudoku_chunks) (g:grid) (i:int) =
    valid_chunk g i s.column_start s.column_offsets

  predicate valid_row (s:sudoku_chunks) (g:grid) (i:int) =
    valid_chunk g i s.row_start s.row_offsets

  predicate valid_square (s:sudoku_chunks) (g:grid) (i:int) =
    valid_chunk g i s.square_start s.square_offsets

  (** `valid g` is true when all chunks are valid *)
  predicate valid (s:sudoku_chunks) (g : grid) =
    forall i : int. is_index i ->
      valid_column s g i /\ valid_row s g i /\ valid_square s g i

  (** `full g` is true when all cells are filled *)
  predicate full (g : grid) =
    forall i : int. is_index i -> 1 <= Map.get g i <= 9

  (** `included g1 g2` *)
  predicate included (g1 g2 : grid) =
    forall i : int. is_index i /\ 1 <= Map.get g1 i <= 9 ->
      Map.get g2 i = Map.get g1 i

  (** validity is monotonic w.r.t. inclusion *)
  let ghost subset_valid_chunk (g h : grid) (i : int) (s o : array int) : unit
    requires { included g h }
    requires { is_index i }
    requires { chunk_valid_indexes s o }
    requires { valid_chunk h i s o }
    ensures  { valid_chunk g i s o }
  = ()

  let ghost subset_valid (s : sudoku_chunks) (g h : grid) : unit
    requires { well_formed_sudoku s }
    requires { included g h }
    requires { valid s h }
    ensures  { valid s g }
  = ()

  (** A solution of a grid `data` is a full grid `sol`
     that is valid and includes `data` *)
  predicate is_solution_for (s:sudoku_chunks) (sol:grid) (data:grid) =
    included data sol /\ full sol /\ valid s sol


end

(** {2 A Sudoku Solver} *)

module Solver

  use Grid
  use array.Array
  use int.Int

  (** predicate for the loop invariant of next function *)
  predicate valid_chunk_up_to (g:grid) (i:int)
    (start:array int) (offsets:array int) (off:int) =
    let s = start[i] in
    forall o1 o2 : int.
      0 <= o1 < off /\ 0 <= o2 < off /\ o1 <> o2 ->
      let i1 = s + offsets[o1] in
      let i2 = s + offsets[o2] in
      1 <= Map.get g i1 <= 9 /\ 1 <= Map.get g i2 <= 9 ->
      Map.get g i1 <> Map.get g i2

  exception Invalid

  use array.Array

  (** `check_valid_chunk g i start offsets` checks the validity
      of the chunk that includes `i` *)
  let check_valid_chunk (g:array int) (i:int)
    (start:array int) (offsets:array int) : unit
    requires { g.length = 81 }
    requires { valid_values g.elts }
    requires { is_index i }
    requires { chunk_valid_indexes start offsets }
    ensures { valid_chunk g.elts i start offsets }
    raises { Invalid -> not (valid_chunk g.elts i start offsets) }
  =
    let s = start[i] in
    let b = Array.make 10 False in
    for off = 0 to 8 do
      invariant { valid_chunk_up_to g.elts i start offsets off }
      invariant { forall o:int. 0 <= o < off ->
         let v = g[s + offsets[o]] in
         1 <= v <= 9 -> b[v] = True }
      invariant { forall j:int. 1 <= j <= 9 ->
         b[j] = True ->
         exists o:int.
           0 <= o < off /\ Map.get g.elts (s + offsets[o]) = j }
      let v = g[s + offsets[off]] in
      if 1 <= v && v <= 9 then
         begin
           if b[v] then raise Invalid;
            b[v] <- True
         end
    done

  (** predicate for the loop invariant of next function *)
  predicate valid_up_to (s:sudoku_chunks) (g:grid) (i:int) =
    forall j : int. 0 <= j < i ->
      valid_column s g j /\ valid_row s g j /\ valid_square s g j

  (** `check_valid s g` checks if the (possibly partially filled) grid
      `g` is valid. (This function is not needed by the solver) *)
  let check_valid (s:sudoku_chunks) (g : array int) : bool
    requires { well_formed_sudoku s }
    requires { g.length = 81 }
    requires { valid_values g.elts }
    ensures { result <-> valid s g.elts }
  =
   try
    for i = 0 to 80 do
      invariant { valid_up_to s g.elts i }
      check_valid_chunk g i s.column_start s.column_offsets;
      check_valid_chunk g i s.row_start s.row_offsets;
      check_valid_chunk g i s.square_start s.square_offsets
    done;
    True
    with Invalid -> False
    end

  (** `full_up_to g i` is true when all cells `0..i-1` in grid `g` are
      non empty *)
  predicate full_up_to (g : grid) (i : int) = forall j :
  int. 0 <= j < i -> 1 <= Map.get g j <= 9

  let ghost full_up_to_change (g : grid) (i : int) (x : int) : unit
    requires { is_index i }
    requires { full_up_to g i }
    requires { 1 <= x <= 9 }
    ensures  { full_up_to (Map.set g i x) (i+1) }
  = ()

  let ghost full_up_to_frame (g1 g2:grid) (i:int) : unit
    requires { 0 <= i <= 81 }
    requires { grid_eq_sub g1 g2 0 i }
    requires { full_up_to g1 i }
    ensures  { full_up_to g2 i }
  = ()

  let ghost full_up_to_frame_all (g1 g2:grid) (i:int) : unit
    requires { 0 <= i <= 81 }
    requires { grid_eq g1 g2 }
    requires { full_up_to g1 i }
    ensures  { full_up_to g2 i }
  = ()

  let ghost valid_chunk_frame (start:array int) (offsets:array int) (g1 g2:grid) (i:int) : unit
    requires { chunk_valid_indexes start offsets }
    requires { 0 <= i < 81 }
    requires { grid_eq g1 g2 }
    requires { valid_chunk g1 i start offsets }
    ensures  { valid_chunk g2 i start offsets }
  = ()

  let ghost valid_up_to_frame (s:sudoku_chunks) (g1 g2:grid) (i:int) : unit
    requires { well_formed_sudoku s }
    requires { 0 <= i <= 81 }
    requires { grid_eq g1 g2 }
    requires { valid_up_to s g1 i }
    ensures  { valid_up_to s g2 i }
  = ()



(** how to prove the "hard" property : if

   `valid_up_to s g i`

and

  `h = g[i <- k`    (with 1 <= k <= 9)]

and

  `valid_column s h i /\ valid_row s h i /\ valid_square s h i`

then

  `valid_up_to s h (i+1)`

then the problem is that one should prove that for each `j` in `0..i-1` :

  `valid_column s h j /\ valid_row s h j /\ valid_square s h j`

this is true but with 2 different possible reasons:

  if `column_start j = column_start i` then
    `valid_column s h j` is true because `valid_column s h i` is true
  else
    `valid_column s h j` is true because `valid_column s g j` is true
    because `valid_column s h j` does not depend on `h[i]`

*)



  let ghost valid_unchanged_chunks (g : grid) (i1 i2 : int) (k : int) (start : array int) (offsets : array int) : unit
    requires { disjoint_chunks start offsets }
    requires { is_index i1 }
    requires { is_index i2 }
    requires { 1 <= k <= 9 }
    requires { let s1 = start[i1] in
               let s2 = start[i2] in
               s1 <> s2 }
    requires { valid_chunk g i2 start offsets }
    ensures  { let h = Map.set g i1 k in
               valid_chunk h i2 start offsets }
  = ()

  let ghost valid_changed_chunks (g : grid) (i1 i2 : int) (k : int) (start : array int) (offsets : array int) : unit
    requires { is_index i1 }
    requires { is_index i2 }
    requires { 1 <= k <= 9 }
    requires { let s1 = start[i1] in
               let s2 = start[i2] in
               let h = Map.set g i1 k in
               s1 = s2 /\ valid_chunk h i1 start offsets }
    ensures  { let h = Map.set g i1 k in
               valid_chunk h i2 start offsets }
  = ()


  let ghost valid_up_to_change (s:sudoku_chunks) (g:grid) (i x : int)
    requires {  well_formed_sudoku s }
    requires { is_index i }
    requires { valid_up_to s g i }
    requires { 1 <= x <= 9 }
    requires { valid_column s (Map.set g i x) i }
    requires { valid_row s (Map.set g i x) i }
    requires { valid_square s (Map.set g i x) i }
    ensures  { valid_up_to s (Map.set g i x) (i+1) }
  = ()


  (** {3 The main solver loop} *)
  exception SolutionFound

  let rec solve_aux (s:sudoku_chunks) (g : array int) (i : int)
    requires { well_formed_sudoku s }
    requires { g.length = 81 }
    requires { valid_values g.elts }
    requires { 0 <= i <= 81 }
    requires { valid_up_to s g.elts i }
    requires { full_up_to g.elts i }
    writes  { g }
    variant { 81 - i }
    ensures { grid_eq (old g).elts g.elts }
    ensures { forall h : grid. included g.elts h /\ full h -> not (valid s h) }
    raises { SolutionFound -> is_solution_for s g.elts (old g).elts }
  = if i = 81 then raise SolutionFound;
    (* assert { is_index i }; *)
    if g[i] <> 0 then
      try
        (* assert { 1 <= g[i] <= 9 }; *)
        check_valid_chunk g i s.column_start s.column_offsets;
        check_valid_chunk g i s.row_start s.row_offsets;
        check_valid_chunk g i s.square_start s.square_offsets;
        solve_aux s g (i + 1)
      with Invalid -> ()
      end
    else
      begin
      let ghost old_g = g.elts in
      for k = 1 to 9 do
        invariant { grid_eq old_g (Map.set g.elts i 0) }
        invariant { full_up_to g.elts i }
        invariant { (* for completeness *)
          forall k'. 1 <= k' < k ->
          let g' = Map.set old_g i k' in
          forall h : grid. included g' h /\ full h -> not (valid s h) }
        g[i] <- k;
        try
          check_valid_chunk g i s.column_start s.column_offsets;
          check_valid_chunk g i s.row_start s.row_offsets;
          check_valid_chunk g i s.square_start s.square_offsets;
            (* the hard part: see lemma valid_up_to_change *)
          valid_up_to_change s old_g i k;
          solve_aux s g (i + 1)
        with Invalid -> ()
        end
      done;
      g[i] <- 0
      end

  exception NoSolution

  let solve (s:sudoku_chunks) (g : array int)
    requires { well_formed_sudoku s }
    requires { g.length = 81 }
    requires { valid_values g.elts }
    writes   { g }
    ensures  { result = g }
    ensures  { is_solution_for s g.elts (old g).elts }
    raises   { NoSolution ->
      forall h : grid. included g.elts h /\ full h -> not (valid s h)  }
  =
    try solve_aux s g 0;
        raise NoSolution
    with SolutionFound -> g
    end

  let check_then_solve (s:sudoku_chunks) (g : array int)
    requires { well_formed_sudoku s }
    requires { g.length = 81 }
    requires { valid_values g.elts }
    writes   { g }
    ensures  { result = g }
    ensures  { is_solution_for s g.elts (old g).elts }
    raises   { NoSolution ->
      forall h : grid. included g.elts h /\ full h -> not (valid s h)  }
  =
    if check_valid s g then solve s g else raise NoSolution

end

(* Proof in progress
module RandomSolver

  (* a variant: solve using a random order of cells *)

  use Grid
  use array.Array
  use int.Int
  use random.Random

  use Solver

  let rec solve_aux (s:sudoku_chunks) (randoffset:int) (g : array int) (i : int)
    requires { well_formed_sudoku s }
    requires { 0 <= randoffset <= 80 }
    requires { g.length = 81 }
    requires { valid_values g.elts }
    requires { 0 <= i <= 81 }
    requires { valid_up_to s g.elts i }
    requires { full_up_to g.elts i }
    writes  { g }
    variant { 81 - i }
    ensures { grid_eq (old g).elts g.elts }
    ensures { forall h : grid. included g.elts h /\ full h -> not (valid s h) }
    raises { SolutionFound -> is_solution_for s g.elts (old g).elts }
  = if i = 81 then raise SolutionFound;
    (* assert { is_index i }; *)
    let j = i + randoffset in
    let j = if j >= 81 then j - 81 else j in
    (* assert { is_index j }; *)
    if g[j] <> 0 then
      try
        (* assert { 1 <= g[j] <= 9 }; *)
        Solver.check_valid_chunk g j s.column_start s.column_offsets;
        check_valid_chunk g j s.row_start s.row_offsets;
        check_valid_chunk g j s.square_start s.square_offsets;
        solve_aux s randoffset g (i + 1)
      with Invalid -> ()
      end
    else
      begin
      label L in
      for k = 1 to 9 do
        invariant { grid_eq (g at L).elts (Map.set g.elts j 0) }
        invariant { full_up_to g.elts i } (* TODO i -> j *)
        invariant { (* for completeness *)
          forall k'. 1 <= k' < k ->
          let g' = Map.set (g at L).elts i k' in (* TODO i -> j *)
          forall h : grid. included g' h /\ full h -> not (valid s h) }
        g[j] <- k;
        try
          check_valid_chunk g j s.column_start s.column_offsets;
          check_valid_chunk g j s.row_start s.row_offsets;
          check_valid_chunk g j s.square_start s.square_offsets;
            (* the hard part: see lemma valid_up_to_change *)
            (* TODO i -> j *)
          assert { let grid' = Map.set (g at L).elts i k in
            grid_eq grid' g.elts &&
            valid_chunk grid' i s.column_start s.column_offsets &&
            valid_chunk grid' i s.row_start s.row_offsets &&
            valid_chunk grid' i s.square_start s.square_offsets &&
            valid_up_to s grid' (i+1) };
          assert { valid_up_to s g.elts (i+1) };
          solve_aux s randoffset g (i + 1)
        with Invalid ->
          assert { (* for completeness *)
            not (valid s (Map.set (g at L).elts i k)) };
          assert { (* for completeness *)
            let g' = Map.set (g at L).elts i k in
            forall h : grid. included g' h /\ full h -> not (valid s h) }
        end
      done;
      g[j] <- 0;
      assert { (* for completeness *)
        forall h:grid. included (g at L).elts h /\ full h ->
          let k' = Map.get h i in
          let g' = Map.set (g at L).elts i k' in
          included g' h }
      end

  exception NoSolution

  let solve (s:sudoku_chunks) (g : array int)
    requires { well_formed_sudoku s }
    requires { g.length = 81 }
    requires { valid_values g.elts }
    writes   { g }
    ensures  { result = g }
    ensures  { is_solution_for s g.elts (old g).elts }
    raises   { NoSolution ->
      forall h : grid. included g.elts h /\ full h -> not (valid s h)  }
  =
    try
      let randoffset = 27 in
      solve_aux s randoffset g 0;
      raise NoSolution
    with SolutionFound -> g
    end

  let check_then_solve (s:sudoku_chunks) (g : array int)
    requires { well_formed_sudoku s }
    requires { g.length = 81 }
    requires { valid_values g.elts }
    writes   { g }
    ensures  { result = g }
    ensures  { is_solution_for s g.elts (old g).elts }
    raises   { NoSolution ->
      forall h : grid. included g.elts h /\ full h -> not (valid s h)  }
  =
    if check_valid s g then solve s g else raise NoSolution

end
*)

(***
Local Variables:
compile-command: "why3 ide --extra-config ../share/strategies.conf sudoku.mlw"
End:
*)

