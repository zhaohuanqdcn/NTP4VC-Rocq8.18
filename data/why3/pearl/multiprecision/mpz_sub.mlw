module Zsub

use int.Int
use int.Power
use map.Map
use mach.int.Int32GMP
use ref.Ref
use mach.c.C
use lemmas.Lemmas
use util.Util
use ptralias.Alias
use compare.Compare
use import mach.int.UInt64GMP as Limb
use types.Int32Eq
use types.UInt64Eq
use add.Add
use sub.Sub
use int.Abs
use mpz.Z
use mpz.Zutil

let partial wmpz_sub (w u v: mpz_ptr) : unit
  requires { mpz.alloc[w] >= 1 /\ mpz.alloc[u] >= 1 /\ mpz.alloc[v] >= 1 }
  requires { mpz.readers[w] = 0 /\ mpz.readers[u] = 0 /\ mpz.readers[v] = 0 }
  requires { mpz.abs_size[u] < max_int32 /\ mpz.abs_size[v] < max_int32 }
  ensures  { value_of w mpz = old (value_of u mpz - value_of v mpz) }
  ensures  { forall x. x <> w -> mpz_unchanged x mpz (old mpz) }
  ensures  { mpz.readers[w] = 0 /\ mpz.readers[u] = 0 /\ mpz.readers[v] = 0 }
=
  label Start in
  let ghost ou = pure { u } in
  let ghost ov = pure { v } in
  let ref u = u in
  let ref v = v in
  if (mpz_eq u v) then begin set_size_0 w; return (); end;
  let ref usize = size_of u in
  let ref vsize = - (size_of v) in
  let ref abs_usize = abs usize in
  let ref abs_vsize = abs vsize in
  let ghost ref swapped = false in
  begin
    ensures { mpz.abs_size[u] = abs_usize /\ mpz.abs_size[v] = abs_vsize }
    ensures { abs_vsize <= abs_usize < max_int32 }
    ensures { 0 <= abs_vsize <= mpz.alloc[v] }
    ensures { 0 <= abs_usize <= mpz.alloc[u] }
    ensures { mpz.alloc[u] > 0 /\ mpz.alloc[v] > 0 }
    ensures { mpz.readers[u] = 0 /\ mpz.readers[v] = 0 }
    ensures { swapped <-> old abs_usize < old abs_vsize }
    ensures { swapped ->
                abs_usize * (old mpz).sgn[u] = - usize /\
                abs_vsize * (old mpz).sgn[v] = vsize }
    ensures { not swapped ->
                abs_usize * (old mpz).sgn[u] = usize /\
                abs_vsize * (old mpz).sgn[v] = - vsize }
    ensures { swapped -> - value_of u mpz + value_of v mpz
              = old (value_of u mpz - value_of v mpz) }
    ensures { not swapped -> value_of u mpz - value_of v mpz
              = old (value_of u mpz - value_of v mpz) }
    ensures { mpz_unchanged u mpz (old mpz) }
    ensures { mpz_unchanged v mpz (old mpz) }
    ensures { not mpz_eq u v }
    if Int32.(<) abs_usize abs_vsize
    then begin
      mpz_ptr_swap u v;
      let ref tmp_size = vsize in
      vsize <- usize;
      usize <- tmp_size;
      tmp_size <- abs_vsize;
      abs_vsize <- abs_usize;
      abs_usize <- tmp_size;
      swapped <- true;
    end
  end;
  let ref wsize = Int32.(+) abs_usize 1 in
  let uw = mpz_eq u w in
  let vw = mpz_eq v w in
  label Realloc in
  let ompz = pure { mpz } in
  let wp = wmpz_realloc w wsize in
  label Op in
  if (bxor usize vsize < 0)
  then begin
     ensures { value wp (abs wsize)
               = old (abs(mpz.abs_value_of[u] - mpz.abs_value_of[v])) }
     ensures { sgn_value wp wsize
               = (value_of ou mpz - value_of ov mpz) at Start }
     ensures { uw \/ mpz.readers[u] = 0 }
     ensures { vw \/ mpz.readers[v] = 0 }
     ensures { mpz.readers[w] = -1 }
     ensures { forall x. x <> w -> mpz_unchanged x mpz (mpz at Start) }
     ensures { abs wsize <= plength wp }
     ensures { wsize <> 0 ->
               value wp (abs wsize) >= power radix (abs wsize - 1) }
     ensures { min wp = old min wp /\ max wp = old max wp
               /\ plength wp = old plength wp }
    if abs_usize <> abs_vsize
    then begin
      begin ensures { value wp abs_usize
                      = old (mpz.abs_value_of[u] - mpz.abs_value_of[v]) }
            ensures { uw \/ mpz.readers[u] = 0 }
            ensures { vw \/ mpz.readers[v] = 0 }
            ensures { mpz.readers[w] = -1 }
            ensures { forall x. x <> w -> mpz_unchanged x mpz (mpz at Start) }
            ensures { min wp = old min wp /\ max wp = old max wp
                      /\ plength wp = old plength wp }
      if uw
      then begin
        let vp = get_read_ptr v in
        let _b = sub_rx wp abs_usize vp abs_vsize in
        release_reader v vp
      end else if vw
      then begin
        let up = get_read_ptr u in
        let _b = sub_ry up abs_usize wp abs_vsize in
        release_reader u up
      end else begin
        let up = get_read_ptr u in
        let vp = get_read_ptr v in
        let _b = sub wp up abs_usize vp abs_vsize in
        release_reader u up;
        release_reader v vp
      end
      end;
      wsize <- abs_usize;
      normalize wp wsize;
      if usize < 0 then wsize <- -wsize;
    end
    else begin
      wsize <- abs_usize;
      if uw
      then begin
        let vp = get_read_ptr v in
        if wmpn_cmp wp vp abs_usize < 0
        then begin
          let _b = sub_n_ry vp wp abs_usize in
          label Norm in
          normalize wp wsize;
          if usize >= 0
          then wsize <- -wsize;
        end else begin
          let _b = sub_n_rx wp vp abs_usize in
          normalize wp wsize;
          if usize < 0 then wsize <- -wsize
        end;
        release_reader v vp
      end else if vw
      then begin
        let up = get_read_ptr u in
        if wmpn_cmp up wp abs_usize < 0
        then begin
          let _b = sub_n_rx wp up abs_usize in
          label Norm in
          normalize wp wsize;
          if usize >= 0 then wsize <- - wsize;
        end else begin
          let _b = sub_n_ry up wp abs_usize in
          normalize wp wsize;
          if usize < 0 then wsize <- - wsize
        end;
        release_reader u up
      end else begin
        let up = get_read_ptr u in
        let vp = get_read_ptr v in
        if wmpn_cmp up vp abs_usize < 0
        then begin
          let _b = sub_n wp vp up abs_usize in
          label Norm in
          normalize wp wsize;
          if usize >= 0 then wsize <- -wsize;
        end else begin
          let _b = sub_n wp up vp abs_usize in
          normalize wp wsize;
          if usize < 0 then wsize <- -wsize
        end;
        release_reader u up;
        release_reader v vp
      end
    end
  end
  else begin
    let ref cy = 0 in
    begin
          ensures { value wp (abs wsize)
                    = old (abs(mpz.abs_value_of[u] + mpz.abs_value_of[v])) }
          ensures { value wp wsize
                    = abs (value_of ou mpz - value_of ov mpz) at Start }
          ensures { uw \/ mpz.readers[u] = 0 }
          ensures { vw \/ mpz.readers[v] = 0 }
          ensures { mpz.readers[w] = -1 }
          ensures { forall x. x <> w -> mpz_unchanged x mpz (mpz at Start) }
          ensures { wsize <> 0 ->
                    value wp (abs wsize) >= power radix (abs wsize - 1) }
          ensures { min wp = old min wp /\ max wp = old max wp
                    /\ plength wp = old plength wp }
          ensures { abs_usize <= wsize <= plength wp }
    if uw
    then begin
        let vp = get_read_ptr v in
        cy <- add_rx wp abs_usize vp abs_vsize;
        release_reader v vp
      end
    else if vw
      then begin
        let up = get_read_ptr u in
        cy <- add_ry up abs_usize wp abs_vsize;
        release_reader u up
      end
      else begin
        let up = get_read_ptr u in
        let vp = get_read_ptr v in
        cy <- add wp up abs_usize vp abs_vsize;
        release_reader u up;
        release_reader v vp;
      end;
    label Set in
    set_ofs wp abs_usize cy;
    begin ensures { if cy = 0 then wsize = abs_usize
                              else wsize = abs_usize + 1 }
      wsize <- abs_usize + Limb.to_int32 cy;
    end;
    end;
    label Minus in
    if Int32.(<) usize 0
    then begin
      wsize <- Int32.(-_) wsize;
    end
    else begin
    end;
  end;
  set_size w wsize wp;
  release_writer w wp

use add_1.Add_1
use sub_1.Sub_1

let partial wmpz_sub_ui (w u: mpz_ptr) (v: uint64) : unit
  requires { mpz.alloc[w] >= 1 /\ mpz.alloc[u] >= 1 }
  requires { mpz.readers[w] = 0 /\ mpz.readers[u] = 0 }
  requires { mpz.abs_size[u] < max_int32 }
  ensures  { value_of w mpz = old (value_of u mpz - v) }
  ensures  { forall x. x <> w -> mpz_unchanged x mpz (old mpz) }
  ensures  { mpz.readers[w] = 0 /\ mpz.readers[u] = 0 }
=
  label Start in
  let usize = size_of u in
  if usize = 0
  then begin
    let wp = get_write_ptr w in
    C.set wp v;
    set_size w (-(if v <> 0 then 1 else 0)) wp;
    release_writer w wp;
    return ();
  end;
  let abs_usize = abs usize in
  let uw = mpz_eq u w in
  let ref wsize = abs_usize + 1 in
  let ghost ompz = pure { mpz } in
  let wp = wmpz_realloc w wsize in
  let ref cy = 0 in
  if usize < 0
  then begin
    begin ensures { value wp abs_usize + power radix abs_usize * cy
                    = old (- value_of u mpz + v) }
          ensures { 0 <= cy <= 1 }
          ensures { uw \/ mpz.readers[u] = 0 }
          ensures { mpz.readers[w] = -1 }
          ensures { forall x. x <> w -> mpz_unchanged x mpz (mpz at Start) }
      if uw
      then begin
        cy <- wmpn_add_1_in_place wp abs_usize v
      end else begin
        let up = get_read_ptr u in
        cy <- wmpn_add_1 wp up abs_usize v;
        release_reader u up;
      end
    end;
    label Carry in
    C.set_ofs wp abs_usize cy;
    wsize <- - (abs_usize + (Limb.to_int32 cy));
    end
  else begin
    begin ensures { sgn_value wp wsize = old (value_of u mpz - v) }
          ensures { abs wsize <= abs_usize + 1 }
          ensures { wsize <> 0
                    -> value wp (abs wsize) >= power radix (abs wsize - 1) }
          ensures { forall x. x <> w -> mpz_unchanged x mpz (mpz at Start) }
          ensures { uw \/ mpz.readers[u] = 0 }
          ensures { mpz.readers[w] = -1 }
      if uw then begin
        if (abs_usize = 1 && C.get wp < v)
        then begin
          C.set wp (v - C.get wp);
          wsize <- - 1;
        end else begin
          let (ghost _b) = wmpn_sub_1_in_place wp abs_usize v in
          wsize <- abs_usize
                   - (if C.get_ofs wp (abs_usize - 1) = 0 then 1 else 0);
        end;
      end else begin
        let up = get_read_ptr u in
        if (abs_usize = 1 && C.get up < v)
        then begin
          C.set wp (v - C.get up);
          wsize <- - 1;
        end else begin
          let (ghost _b) = wmpn_sub_1 wp up abs_usize v in
          wsize <- abs_usize
                   - (if C.get_ofs wp (abs_usize - 1) = 0 then 1 else 0);
        end;
        release_reader u up;
      end
    end;
  end;
  set_size w wsize wp;
  release_writer w wp


let partial wmpz_ui_sub (w: mpz_ptr) (uval: uint64) (v:mpz_ptr) : unit
  requires { mpz.alloc[w] >= 1 /\ mpz.alloc[v] >= 1 }
  requires { mpz.readers[w] = 0 /\ mpz.readers[v] = 0 }
  requires { mpz.abs_size[v] < max_int32 }
  ensures  { value_of w mpz = old (uval - value_of v mpz) }
  ensures  { forall x. x <> w -> mpz_unchanged x mpz (old mpz) }
  ensures  { mpz.readers[w] = 0 /\ mpz.readers[v] = 0 }
=
  label Start in
  let ref vsize = size_of v in
  let ref wsize = 0 in
  let vw = mpz_eq v w in
  let ompz = pure { mpz } in
  if vsize > 1
  then begin
    let wp = wmpz_realloc w vsize in
    if vw
    then begin
      let (ghost _b) = wmpn_sub_1_in_place wp vsize uval in ()
    end else begin
      unchanged v mpz ompz;
      let vp = get_read_ptr v in
      let (ghost _b) = wmpn_sub_1 wp vp vsize uval in
      release_reader v vp;
    end;
    wsize <- - (vsize - (if C.get_ofs wp (vsize - 1) = 0 then 1 else 0));
    set_size w wsize wp;
    release_writer w wp
  end else if vsize = 1 then begin
    let wp = get_write_ptr w in
    if vw
    then if uval >= C.get wp
      then begin
        C.set wp (uval - C.get wp);
        wsize <- (if C.get wp <> 0 then 1 else 0);
      end else begin
        C.set wp (C.get wp - uval);
        wsize <- -1;
      end
    else begin
      let vp = get_read_ptr v in
      if uval >= C.get vp
      then begin
        C.set wp (uval - C.get vp);
        wsize <- (if C.get wp <> 0 then 1 else 0);
      end else begin
        C.set wp (C.get vp - uval);
        wsize <- -1;
      end;
      release_reader v vp;
    end;
    set_size w wsize wp;
    release_writer w wp
  end else if vsize = 0 then begin
    let wp = get_write_ptr w in
    C.set wp uval;
    wsize <- (if uval <> 0 then 1 else 0);
    set_size w wsize wp;
    release_writer w wp
  end else begin
    label Opp in
    vsize <- -vsize;
    let wp = wmpz_realloc w (vsize+1) in
    if vw
    then begin
      let cy = wmpn_add_1_in_place wp vsize uval in
      C.set_ofs wp vsize cy;
      wsize <- vsize + (if cy <> 0 then 1 else 0);
    end else begin
      unchanged v mpz ompz;
      let vp = get_read_ptr v in
      let cy = wmpn_add_1 wp vp vsize uval in
      C.set_ofs wp vsize cy;
      wsize <- vsize + (if cy <> 0 then 1 else 0);
      release_reader v vp;
    end;
    set_size w wsize wp;
    release_writer w wp
  end

end
