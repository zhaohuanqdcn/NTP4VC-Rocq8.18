import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapExt
import pearl.verifythis_2016_tree_traversal_vcg.lean.verifythis_2016_tree_traversal.Memory
import pearl.verifythis_2016_tree_traversal_vcg.lean.verifythis_2016_tree_traversal.TreeShape
import Why3.bintree.Tree
import Why3.bintree.Size
open Classical
open Lean4Why3
namespace verifythis_2016_tree_traversal_Recursive_markTreeqtvc
theorem markTree'vc (memo : Memory.memory) (t : Tree.tree Memory.loc) (root : Memory.loc) (fact0 : TreeShape.is_tree (Memory.accessor memo) t root Memory.null) (fact1 : ¬root = Memory.null) : let o1 : Memory.loc := Memory.null; (∀(entered : Bool) (x : Memory.loc) (memo1 : Memory.memory) (mem0 : Memory.kind -> Memory.loc -> Memory.loc) (ph : TreeShape.phase), TreeShape.rotated mem0 (Memory.accessor memo1) ph x ∧ (ph = TreeShape.phase.Finish → entered = true) → (∀(o2 : Bool), (if entered = true then o2 = (if x = Memory.null then true else false) else o2 = false) → (if o2 = true then ph = TreeShape.phase.Finish else ¬x = Memory.null ∧ (∀(memo2 : Memory.memory), Memory.accessor memo2 = Memory.accessor memo1 → Memory.mark memo2 = Function.update (Memory.mark memo1) x true → ¬x = Memory.null ∧ (let o3 : Memory.loc := Memory.accessor memo2 Memory.kind.Left x; (o3 = Memory.null → ¬x = Memory.null) ∧ (∀(o4 : Bool), (if o3 = Memory.null then o4 = (if Memory.accessor memo2 Memory.kind.Right x = Memory.null then true else false) else o4 = false) → (if o4 = true then ¬x = Memory.null ∧ ¬ph = TreeShape.phase.Finish ∧ Memory.mark memo2 x = true ∧ (∀(l : Memory.loc), ¬l = x → Memory.mark memo2 l = Memory.mark memo1 l) ∧ (if Memory.accessor memo1 Memory.kind.Left x = Memory.null ∧ Memory.null = Memory.accessor memo1 Memory.kind.Right x then Memory.accessor memo2 = Memory.accessor memo1 else TreeShape.rotated mem0 (Memory.accessor memo2) (TreeShape.next_phase ph) x) else ¬x = Memory.null ∧ ¬x = Memory.null ∧ (let o5 : Memory.kind := Memory.kind.Left; ¬x = Memory.null ∧ (∀(memo3 : Memory.memory), Memory.mark memo3 = Memory.mark memo2 → Memory.accessor memo3 = Function.update (Memory.accessor memo2) o5 (Function.update (Memory.accessor memo2 o5) x (Memory.accessor memo2 Memory.kind.Right x)) → ¬x = Memory.null ∧ (let o6 : Memory.kind := Memory.kind.Right; ¬x = Memory.null ∧ (∀(memo4 : Memory.memory), Memory.mark memo4 = Memory.mark memo3 → Memory.accessor memo4 = Function.update (Memory.accessor memo3) o6 (Function.update (Memory.accessor memo3 o6) x (Memory.accessor memo3 Memory.kind.Parent x)) → (let o7 : Memory.kind := Memory.kind.Parent; ¬x = Memory.null ∧ (∀(memo5 : Memory.memory), Memory.mark memo5 = Memory.mark memo4 → Memory.accessor memo5 = Function.update (Memory.accessor memo4) o7 (Function.update (Memory.accessor memo4 o7) x (Memory.accessor memo2 Memory.kind.Left x)) → Memory.accessor memo2 Memory.kind.Left x = Memory.accessor memo5 Memory.kind.Parent x ∧ ¬ph = TreeShape.phase.Finish ∧ Memory.mark memo5 x = true ∧ (∀(l : Memory.loc), ¬l = x → Memory.mark memo5 l = Memory.mark memo1 l) ∧ (if Memory.accessor memo1 Memory.kind.Left x = Memory.null ∧ Memory.null = Memory.accessor memo1 Memory.kind.Right x then Memory.accessor memo5 = Memory.accessor memo1 else TreeShape.rotated mem0 (Memory.accessor memo5) (TreeShape.next_phase ph) x)))))))))))))) ∧ (∀(z : Memory.loc) (x : Memory.loc) (memo1 : Memory.memory) (t1 : Tree.tree Memory.loc), ¬x = Memory.null ∧ TreeShape.is_tree (Memory.accessor memo1) t1 x z → (let mem0 : Memory.kind -> Memory.loc -> Memory.loc := Memory.accessor memo1; ¬x = Memory.null ∧ (let x_lf : Memory.loc := Memory.accessor memo1 Memory.kind.Left x; ¬x = Memory.null ∧ (let x_rg : Memory.loc := Memory.accessor memo1 Memory.kind.Right x; (match t1 with | (Tree.tree.Empty : Tree.tree Memory.loc) => False | Tree.tree.Node l _ r => True) ∧ (∀(lf : Tree.tree Memory.loc) (rg : Tree.tree Memory.loc), (match t1 with | (Tree.tree.Empty : Tree.tree Memory.loc) => False | Tree.tree.Node l _ r => lf = l ∧ rg = r) → TreeShape.is_tree mem0 (Tree.tree.Node lf x rg) x z ∧ (¬x ∈ TreeShape.footprint lf ∧ ¬x ∈ TreeShape.footprint rg → (let o2 : TreeShape.phase := TreeShape.phase.GoLeft; TreeShape.rotated mem0 (Memory.accessor memo1) o2 x ∧ (∀(memo2 : Memory.memory), Memory.mark memo2 x = true ∧ (∀(l : Memory.loc), ¬l = x → Memory.mark memo2 l = Memory.mark memo1 l) ∧ (if Memory.accessor memo1 Memory.kind.Left x = Memory.null ∧ Memory.null = Memory.accessor memo1 Memory.kind.Right x then Memory.accessor memo2 = Memory.accessor memo1 else TreeShape.rotated mem0 (Memory.accessor memo2) (TreeShape.next_phase o2) x) → (∀(result : Bool), (if x_lf = Memory.null then result = (if x_rg = Memory.null then true else false) else result = false) → (result = true) = (x_lf = Memory.null ∧ x_rg = Memory.null) ∧ (result = true → lf = (Tree.tree.Empty : Tree.tree Memory.loc) ∧ rg = (Tree.tree.Empty : Tree.tree Memory.loc))) ∧ ((x_lf = Memory.null ∧ x_rg = Memory.null → lf = (Tree.tree.Empty : Tree.tree Memory.loc) ∧ rg = (Tree.tree.Empty : Tree.tree Memory.loc)) → (if ¬(x_lf = Memory.null ∧ x_rg = Memory.null) then (TreeShape.ext (TreeShape.footprint lf) mem0 (Memory.accessor memo2) ∧ TreeShape.is_tree mem0 lf x_lf x) ∧ (TreeShape.is_tree (Memory.accessor memo2) lf x_lf x → ((match t1 with | (Tree.tree.Empty : Tree.tree Memory.loc) => False | Tree.tree.Node f _ f1 => f = lf ∨ f1 = lf) ∧ ¬Memory.accessor memo2 Memory.kind.Parent x = Memory.null ∧ TreeShape.is_tree (Memory.accessor memo2) lf (Memory.accessor memo2 Memory.kind.Parent x) x) ∧ (∀(memo3 : Memory.memory), TreeShape.unchanged (Memory.accessor memo2) (Memory.accessor memo3) ∧ TreeShape.was_marked lf (Memory.mark memo2) (Memory.mark memo3) → (let o3 : TreeShape.phase := TreeShape.phase.GoRight; TreeShape.rotated mem0 (Memory.accessor memo3) o3 x ∧ (∀(memo4 : Memory.memory), Memory.mark memo4 x = true ∧ (∀(l : Memory.loc), ¬l = x → Memory.mark memo4 l = Memory.mark memo3 l) ∧ (if Memory.accessor memo3 Memory.kind.Left x = Memory.null ∧ Memory.null = Memory.accessor memo3 Memory.kind.Right x then Memory.accessor memo4 = Memory.accessor memo3 else TreeShape.rotated mem0 (Memory.accessor memo4) (TreeShape.next_phase o3) x) → (TreeShape.ext (TreeShape.footprint rg) mem0 (Memory.accessor memo4) ∧ TreeShape.is_tree mem0 rg x_rg x) ∧ (TreeShape.is_tree (Memory.accessor memo4) rg x_rg x → ((match t1 with | (Tree.tree.Empty : Tree.tree Memory.loc) => False | Tree.tree.Node f _ f1 => f = rg ∨ f1 = rg) ∧ ¬Memory.accessor memo4 Memory.kind.Parent x = Memory.null ∧ TreeShape.is_tree (Memory.accessor memo4) rg (Memory.accessor memo4 Memory.kind.Parent x) x) ∧ (∀(memo5 : Memory.memory), TreeShape.unchanged (Memory.accessor memo4) (Memory.accessor memo5) ∧ TreeShape.was_marked rg (Memory.mark memo4) (Memory.mark memo5) → (let o4 : TreeShape.phase := TreeShape.phase.GoBack; TreeShape.rotated mem0 (Memory.accessor memo5) o4 x ∧ (∀(memo6 : Memory.memory), Memory.mark memo6 x = true ∧ (∀(l : Memory.loc), ¬l = x → Memory.mark memo6 l = Memory.mark memo5 l) ∧ (if Memory.accessor memo5 Memory.kind.Left x = Memory.null ∧ Memory.null = Memory.accessor memo5 Memory.kind.Right x then Memory.accessor memo6 = Memory.accessor memo5 else TreeShape.rotated mem0 (Memory.accessor memo6) (TreeShape.next_phase o4) x) → TreeShape.unchanged (Memory.accessor memo1) (Memory.accessor memo6) ∧ Memory.accessor memo6 Memory.kind.Parent x = z ∧ TreeShape.was_marked t1 (Memory.mark memo1) (Memory.mark memo6))))))))) else TreeShape.unchanged (Memory.accessor memo1) (Memory.accessor memo2) ∧ Memory.accessor memo2 Memory.kind.Parent x = z ∧ TreeShape.was_marked t1 (Memory.mark memo1) (Memory.mark memo2))))))))))) ∧ (let mem0 : Memory.kind -> Memory.loc -> Memory.loc := Memory.accessor memo; (¬root = Memory.null ∧ TreeShape.is_tree (Memory.accessor memo) t root o1) ∧ (∀(memo1 : Memory.memory), TreeShape.unchanged (Memory.accessor memo) (Memory.accessor memo1) ∧ TreeShape.was_marked t (Memory.mark memo) (Memory.mark memo1) → TreeShape.rotated mem0 (Memory.accessor memo1) TreeShape.phase.Finish o1 ∧ (∀(x : Memory.loc), TreeShape.rotated mem0 (Memory.accessor memo1) TreeShape.phase.Finish x → TreeShape.rotated mem0 (Memory.accessor memo1) TreeShape.phase.Finish x ∧ (let o2 : Memory.loc := Memory.null; (TreeShape.ext (TreeShape.footprint t) mem0 (Memory.accessor memo1) ∧ TreeShape.is_tree mem0 t root o2) ∧ (TreeShape.is_tree (Memory.accessor memo1) t root o2 → TreeShape.is_tree (Memory.accessor memo1) t root Memory.null ∧ TreeShape.unchanged (Memory.accessor memo) (Memory.accessor memo1) ∧ TreeShape.was_marked t (Memory.mark memo) (Memory.mark memo1))))))
  := sorry
end verifythis_2016_tree_traversal_Recursive_markTreeqtvc
