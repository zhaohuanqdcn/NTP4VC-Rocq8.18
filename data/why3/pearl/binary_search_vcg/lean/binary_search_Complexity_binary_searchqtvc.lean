import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace binary_search_Complexity_binary_searchqtvc
axiom log2 : ℤ -> ℤ
axiom log2'def (n : ℤ) : if n ≤ (1 : ℤ) then log2 n = (0 : ℤ) else log2 n = (1 : ℤ) + log2 (Int.tdiv n (2 : ℤ))
noncomputable def f (n : ℤ) := if n = (0 : ℤ) then (0 : ℤ) else (1 : ℤ) + log2 n
theorem binary_search'vc (a : List ℤ) (v : ℤ) (fact0 : ∀(i1 : ℤ) (i2 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ i2 ∧ i2 < Int.ofNat (List.length a) → a[Int.toNat i1]! ≤ a[Int.toNat i2]!) : let o1 : ℤ := Int.ofNat (List.length a); (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ o1 ∧ o1 ≤ Int.ofNat (List.length a)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (0 : ℤ) ∨ o1 ≤ i ∧ i < Int.ofNat (List.length a) → ¬a[Int.toNat i]! = v) ∧ (0 : ℤ) - (0 : ℤ) + f (o1 - (0 : ℤ)) ≤ f (Int.ofNat (List.length a))) ∧ (∀(hi : ℤ) (lo : ℤ) (time : ℤ), ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ Int.ofNat (List.length a)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < lo ∨ hi ≤ i ∧ i < Int.ofNat (List.length a) → ¬a[Int.toNat i]! = v) ∧ time - (0 : ℤ) + f (hi - lo) ≤ f (Int.ofNat (List.length a)) → (if lo < hi then ¬(2 : ℤ) = (0 : ℤ) ∧ (let mid : ℤ := lo + Int.tdiv (hi - lo) (2 : ℤ); ((0 : ℤ) ≤ mid ∧ mid < Int.ofNat (List.length a)) ∧ (if a[Int.toNat mid]! < v then ((0 : ℤ) ≤ hi - lo ∧ hi - (mid + (1 : ℤ)) < hi - lo) ∧ ((0 : ℤ) ≤ mid + (1 : ℤ) ∧ mid + (1 : ℤ) ≤ hi ∧ hi ≤ Int.ofNat (List.length a)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < mid + (1 : ℤ) ∨ hi ≤ i ∧ i < Int.ofNat (List.length a) → ¬a[Int.toNat i]! = v) ∧ time + (1 : ℤ) - (0 : ℤ) + f (hi - (mid + (1 : ℤ))) ≤ f (Int.ofNat (List.length a)) else ((0 : ℤ) ≤ mid ∧ mid < Int.ofNat (List.length a)) ∧ (if v < a[Int.toNat mid]! then ((0 : ℤ) ≤ hi - lo ∧ mid - lo < hi - lo) ∧ ((0 : ℤ) ≤ lo ∧ lo ≤ mid ∧ mid ≤ Int.ofNat (List.length a)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < lo ∨ mid ≤ i ∧ i < Int.ofNat (List.length a) → ¬a[Int.toNat i]! = v) ∧ time + (1 : ℤ) - (0 : ℤ) + f (mid - lo) ≤ f (Int.ofNat (List.length a)) else (((0 : ℤ) ≤ mid ∧ mid < Int.ofNat (List.length a)) ∧ a[Int.toNat mid]! = v ∨ mid = -(1 : ℤ) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → ¬a[Int.toNat i]! = v)) ∧ time - (0 : ℤ) ≤ f (Int.ofNat (List.length a))))) else (((0 : ℤ) ≤ -(1 : ℤ) ∧ -(1 : ℤ) < Int.ofNat (List.length a)) ∧ a[Int.toNat (-(1 : ℤ))]! = v ∨ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → ¬a[Int.toNat i]! = v)) ∧ time - (0 : ℤ) ≤ f (Int.ofNat (List.length a))))
  := sorry
end binary_search_Complexity_binary_searchqtvc
