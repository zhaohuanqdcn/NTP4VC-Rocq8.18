import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace vstte10_queens_NQueens63_count_bt_queensqtvc
noncomputable def is_board (board : array63 (BitVec 63)) (pos : ℤ) := ∀(q : ℤ), (0 : ℤ) ≤ q ∧ q < pos → (0 : ℤ) ≤ BitVec.toInt ((array63_elts board)[Int.toNat q]!) ∧ BitVec.toInt ((array63_elts board)[Int.toNat q]!) < BitVec.toInt (array63_length board)
theorem count_bt_queens'vc (pos : BitVec 63) (board : array63 (BitVec 63)) (solutions : ℕ) (fact0 : (0 : ℤ) ≤ BitVec.toInt pos) (fact1 : BitVec.toInt pos ≤ BitVec.toInt (array63_length board)) (fact2 : is_board board (BitVec.toInt pos)) (fact3 : BitVec.toInt pos = BitVec.toInt (array63_length board) → pos = array63_length board) : if pos = array63_length board then ∀(o1 : ℕ), Int.ofNat o1 = Int.ofNat solutions + (1 : ℤ) → is_board board (BitVec.toInt pos) else (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt (array63_length board)) ∧ is_board board (BitVec.toInt pos)) ∧ (∀(i : BitVec 63) (board1 : array63 (BitVec 63)), array63_length board1 = array63_length board → ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt (array63_length board)) ∧ is_board board1 (BitVec.toInt pos) → (if BitVec.toInt i < BitVec.toInt (array63_length board) then ((0 : ℤ) ≤ BitVec.toInt pos ∧ BitVec.toInt pos < BitVec.toInt (array63_length board1)) ∧ (∀(board2 : array63 (BitVec 63)), array63_length board2 = array63_length board1 → array63_elts board2 = List.set (array63_elts board1) (Int.toNat (BitVec.toInt pos)) i → (((0 : ℤ) ≤ BitVec.toInt pos ∧ BitVec.toInt pos < BitVec.toInt (array63_length board2)) ∧ is_board board2 (BitVec.toInt pos + (1 : ℤ))) ∧ (∀(o1 : Bool), if o1 = true then int'63_in_bounds (BitVec.toInt pos + (1 : ℤ)) ∧ (∀(o2 : BitVec 63), BitVec.toInt o2 = BitVec.toInt pos + (1 : ℤ) → (((0 : ℤ) ≤ BitVec.toInt (array63_length board) - BitVec.toInt pos ∧ BitVec.toInt (array63_length board) - BitVec.toInt o2 < BitVec.toInt (array63_length board) - BitVec.toInt pos) ∧ array63_length board2 = array63_length board ∧ ((0 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 ≤ BitVec.toInt (array63_length board)) ∧ is_board board2 (BitVec.toInt o2)) ∧ (∀(board3 : array63 (BitVec 63)), array63_length board3 = array63_length board2 → is_board board3 (BitVec.toInt o2) → int'63_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o3 : BitVec 63), BitVec.toInt o3 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt (array63_length board) - BitVec.toInt i ∧ BitVec.toInt (array63_length board) - BitVec.toInt o3 < BitVec.toInt (array63_length board) - BitVec.toInt i) ∧ ((0 : ℤ) ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ BitVec.toInt (array63_length board)) ∧ is_board board3 (BitVec.toInt pos)))) else int'63_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o2 : BitVec 63), BitVec.toInt o2 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt (array63_length board) - BitVec.toInt i ∧ BitVec.toInt (array63_length board) - BitVec.toInt o2 < BitVec.toInt (array63_length board) - BitVec.toInt i) ∧ ((0 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 ≤ BitVec.toInt (array63_length board)) ∧ is_board board2 (BitVec.toInt pos)))) else is_board board1 (BitVec.toInt pos)))
  := sorry
end vstte10_queens_NQueens63_count_bt_queensqtvc
