import Why3.Base
open Classical
open Lean4Why3
namespace generate_all_trees_GenerateAllTrees_all_treesqtvc
inductive tree where
  | Empty : tree
  | Node : tree -> tree -> tree
axiom inhabited_axiom_tree : Inhabited tree
attribute [instance] inhabited_axiom_tree
noncomputable def size : tree -> ℤ
  | tree.Empty => (0 : ℤ)
  | (tree.Node l r) => (1 : ℤ) + size l + size r
noncomputable def all_trees (n : ℤ) (l : List tree) := List.Nodup l ∧ (∀(t : tree), (size t = n) = (t ∈ l))
theorem all_trees'vc (n : ℤ) (fact0 : (0 : ℤ) ≤ n) : let o1 : ℤ := n + (1 : ℤ); (0 : ℤ) ≤ o1 ∧ (∀(a : List (List tree)), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o1 → a[Int.toNat i]! = ([] : List tree)) ∧ Int.ofNat (List.length a) = o1 → (let o2 : List tree := List.cons tree.Empty ([] : List tree); ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length a)) ∧ (List.length (List.set a (0 : ℕ) o2) = List.length a → getElem! (List.set a (0 : ℕ) o2) ∘ Int.toNat = Function.update (getElem! a ∘ Int.toNat) (0 : ℤ) o2 → ((1 : ℤ) ≤ n + (1 : ℤ) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < (1 : ℤ) → all_trees k ((List.set a (0 : ℕ) o2)[Int.toNat k]!)) ∧ (∀(a1 : List (List tree)), List.length a1 = List.length (List.set a (0 : ℕ) o2) → (∀(i : ℤ), ((1 : ℤ) ≤ i ∧ i ≤ n) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i → all_trees k (a1[Int.toNat k]!)) → (let o3 : List tree := ([] : List tree); ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (List.length (List.set a1 (Int.toNat i) o3) = List.length a1 → getElem! (List.set a1 (Int.toNat i) o3) ∘ Int.toNat = Function.update (getElem! a1 ∘ Int.toNat) i o3 → (let o4 : ℤ := i - (1 : ℤ); ((0 : ℤ) ≤ o4 + (1 : ℤ) → ((∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i → all_trees k ((List.set a1 (Int.toNat i) o3)[Int.toNat k]!)) ∧ List.Nodup ((List.set a1 (Int.toNat i) o3)[Int.toNat i]!) ∧ (∀(t : tree), (t ∈ (List.set a1 (Int.toNat i) o3)[Int.toNat i]!) = (∃(l : tree) (r : tree), t = tree.Node l r ∧ size t = i ∧ size l < (0 : ℤ)))) ∧ (∀(a2 : List (List tree)), List.length a2 = List.length (List.set a1 (Int.toNat i) o3) → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j ≤ o4) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i → all_trees k (a2[Int.toNat k]!)) ∧ List.Nodup (a2[Int.toNat i]!) ∧ (∀(t : tree), (t ∈ a2[Int.toNat i]!) = (∃(l : tree) (r : tree), t = tree.Node l r ∧ size t = i ∧ size l < j)) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a2)) ∧ (let o5 : ℤ := i - (1 : ℤ) - j; ((0 : ℤ) ≤ o5 ∧ o5 < Int.ofNat (List.length a2)) ∧ (let o6 : ℤ := i - (1 : ℤ) - j; ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a2)) ∧ ((0 : ℤ) ≤ j ∧ all_trees j (a2[Int.toNat j]!) ∧ (0 : ℤ) ≤ o6 ∧ all_trees o6 (a2[Int.toNat o5]!)) ∧ (∀(o7 : List tree), List.Nodup o7 ∧ (∀(t : tree), (t ∈ o7) = (∃(l : tree) (r : tree), t = tree.Node l r ∧ size l = j ∧ size r = o6)) → (let o8 : List tree := o7 ++ a2[Int.toNat i]!; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat i) o8) = List.length a2 → getElem! (List.set a2 (Int.toNat i) o8) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) i o8 → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i → all_trees k ((List.set a2 (Int.toNat i) o8)[Int.toNat k]!)) ∧ List.Nodup ((List.set a2 (Int.toNat i) o8)[Int.toNat i]!) ∧ (∀(t : tree), (t ∈ (List.set a2 (Int.toNat i) o8)[Int.toNat i]!) = (∃(l : tree) (r : tree), t = tree.Node l r ∧ size t = i ∧ size l < j + (1 : ℤ))))))))) ∧ ((∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i → all_trees k (a2[Int.toNat k]!)) ∧ List.Nodup (a2[Int.toNat i]!) ∧ (∀(t : tree), (t ∈ a2[Int.toNat i]!) = (∃(l : tree) (r : tree), t = tree.Node l r ∧ size t = i ∧ size l < o4 + (1 : ℤ))) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i + (1 : ℤ) → all_trees k (a2[Int.toNat k]!))))) ∧ (o4 + (1 : ℤ) < (0 : ℤ) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i + (1 : ℤ) → all_trees k ((List.set a1 (Int.toNat i) o3)[Int.toNat k]!))))))) ∧ ((∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < n + (1 : ℤ) → all_trees k (a1[Int.toNat k]!)) → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ n → all_trees i (a1[Int.toNat i]!))))) ∧ (n + (1 : ℤ) < (1 : ℤ) → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ n → all_trees i ((List.set a (0 : ℕ) o2)[Int.toNat i]!))))))
  := sorry
end generate_all_trees_GenerateAllTrees_all_treesqtvc
