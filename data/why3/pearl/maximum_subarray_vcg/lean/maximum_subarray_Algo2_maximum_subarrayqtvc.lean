import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Sum
import pearl.maximum_subarray_vcg.lean.maximum_subarray.Spec
open Classical
open Lean4Why3
namespace maximum_subarray_Algo2_maximum_subarrayqtvc
theorem maximum_subarray'vc (a : List ℤ) : let n : ℤ := Int.ofNat (List.length a); let o1 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → ((((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ)) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ n) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) = List.sum (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a))) ∧ Spec.maxsublo a (0 : ℤ) (0 : ℤ)) ∧ (∀(ms : ℤ) (hi : ℤ) (lo : ℤ), (∀(l : ℤ), ((0 : ℤ) ≤ l ∧ l ≤ o1) ∧ (((0 : ℤ) ≤ lo ∧ lo ≤ l) ∧ (lo ≤ hi ∧ hi ≤ n) ∧ (0 : ℤ) ≤ ms ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ Spec.maxsublo a l ms → (let o2 : ℤ := l + (1 : ℤ); (o2 ≤ n + (1 : ℤ) → ((((0 : ℤ) ≤ lo ∧ lo ≤ l) ∧ (lo ≤ hi ∧ hi ≤ n) ∧ (0 : ℤ) ≤ ms ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ Spec.maxsublo a l ms ∧ (∀(h' : ℤ), l ≤ h' ∧ h' < o2 → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h' - Int.toNat l) a)) ≤ ms) ∧ (0 : ℤ) = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (o2 - (1 : ℤ)) - Int.toNat l) a))) ∧ (∀(s : ℤ) (ms1 : ℤ) (hi1 : ℤ) (lo1 : ℤ), (∀(h : ℤ), (o2 ≤ h ∧ h ≤ n) ∧ (((0 : ℤ) ≤ lo1 ∧ lo1 ≤ l) ∧ (lo1 ≤ hi1 ∧ hi1 ≤ n) ∧ (0 : ℤ) ≤ ms1 ∧ ms1 = List.sum (List.drop (Int.toNat lo1) (List.take (Int.toNat hi1 - Int.toNat lo1) a))) ∧ Spec.maxsublo a l ms1 ∧ (∀(h' : ℤ), l ≤ h' ∧ h' < h → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h' - Int.toNat l) a)) ≤ ms1) ∧ s = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (h - (1 : ℤ)) - Int.toNat l) a)) → (let o3 : ℤ := h - (1 : ℤ); ((0 : ℤ) ≤ o3 ∧ o3 < Int.ofNat (List.length a)) ∧ (if ms1 < s + a[Int.toNat o3]! then (((0 : ℤ) ≤ l ∧ l ≤ l) ∧ (l ≤ h ∧ h ≤ n) ∧ (0 : ℤ) ≤ s + a[Int.toNat o3]! ∧ s + a[Int.toNat o3]! = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a))) ∧ Spec.maxsublo a l (s + a[Int.toNat o3]!) ∧ (∀(h' : ℤ), l ≤ h' ∧ h' < h + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h' - Int.toNat l) a)) ≤ s + a[Int.toNat o3]!) ∧ s + a[Int.toNat o3]! = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (h + (1 : ℤ) - (1 : ℤ)) - Int.toNat l) a)) else (((0 : ℤ) ≤ lo1 ∧ lo1 ≤ l) ∧ (lo1 ≤ hi1 ∧ hi1 ≤ n) ∧ (0 : ℤ) ≤ ms1 ∧ ms1 = List.sum (List.drop (Int.toNat lo1) (List.take (Int.toNat hi1 - Int.toNat lo1) a))) ∧ Spec.maxsublo a l ms1 ∧ (∀(h' : ℤ), l ≤ h' ∧ h' < h + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h' - Int.toNat l) a)) ≤ ms1) ∧ s + a[Int.toNat o3]! = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (h + (1 : ℤ) - (1 : ℤ)) - Int.toNat l) a))))) ∧ ((((0 : ℤ) ≤ lo1 ∧ lo1 ≤ l) ∧ (lo1 ≤ hi1 ∧ hi1 ≤ n) ∧ (0 : ℤ) ≤ ms1 ∧ ms1 = List.sum (List.drop (Int.toNat lo1) (List.take (Int.toNat hi1 - Int.toNat lo1) a))) ∧ Spec.maxsublo a l ms1 ∧ (∀(h' : ℤ), l ≤ h' ∧ h' < n + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h' - Int.toNat l) a)) ≤ ms1) ∧ s = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (n + (1 : ℤ) - (1 : ℤ)) - Int.toNat l) a)) → (((0 : ℤ) ≤ lo1 ∧ lo1 ≤ l + (1 : ℤ)) ∧ (lo1 ≤ hi1 ∧ hi1 ≤ n) ∧ (0 : ℤ) ≤ ms1 ∧ ms1 = List.sum (List.drop (Int.toNat lo1) (List.take (Int.toNat hi1 - Int.toNat lo1) a))) ∧ Spec.maxsublo a (l + (1 : ℤ)) ms1))) ∧ (n + (1 : ℤ) < o2 → (((0 : ℤ) ≤ lo ∧ lo ≤ l + (1 : ℤ)) ∧ (lo ≤ hi ∧ hi ≤ n) ∧ (0 : ℤ) ≤ ms ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ Spec.maxsublo a (l + (1 : ℤ)) ms))) ∧ ((((0 : ℤ) ≤ lo ∧ lo ≤ o1 + (1 : ℤ)) ∧ (lo ≤ hi ∧ hi ≤ n) ∧ (0 : ℤ) ≤ ms ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ Spec.maxsublo a (o1 + (1 : ℤ)) ms → (((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ Int.ofNat (List.length a)) ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ Spec.maxsub a ms))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length a)) ∧ (0 : ℤ) = List.sum (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a))) ∧ Spec.maxsub a (0 : ℤ))
  := sorry
end maximum_subarray_Algo2_maximum_subarrayqtvc
