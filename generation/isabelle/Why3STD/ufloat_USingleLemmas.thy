theory ufloat_USingleLemmas
  imports "NTP4Verif.NTP4Verif" real_Sum ieee_float_RoundingMode ufloat_USingle ufloat_HelperLemmas
begin
axiomatization where uadd_single_error_propagation:   "abs (to_real r - (x + y)) \<le> (x_rel + y_rel + eps) * (x_factor + y_factor) + (((1 :: Real.real) + eps + y_rel) * x_abs + ((1 :: Real.real) + eps + x_rel) * y_abs)"
 if "abs (to_real x_f - x) \<le> x_rel * x_factor + x_abs"
 and "abs (to_real y_f - y) \<le> y_rel * y_factor + y_abs"
 and "abs x \<le> x_factor"
 and "abs y \<le> y_factor"
 and "(0 :: Real.real) \<le> x_rel"
 and "(0 :: Real.real) \<le> y_rel"
 and "(0 :: Real.real) \<le> x_abs"
 and "(0 :: Real.real) \<le> y_abs"
 and "r = uadd x_f y_f"
  for x_f :: "usingle"
  and x :: "real"
  and x_rel :: "real"
  and x_factor :: "real"
  and x_abs :: "real"
  and y_f :: "usingle"
  and y :: "real"
  and y_rel :: "real"
  and y_factor :: "real"
  and y_abs :: "real"
  and r :: "usingle"
axiomatization where usub_single_error_propagation:   "abs (to_real r - (x - y)) \<le> (x_rel + y_rel + eps) * (x_factor + y_factor) + (((1 :: Real.real) + eps + y_rel) * x_abs + ((1 :: Real.real) + eps + x_rel) * y_abs)"
 if "abs (to_real x_f - x) \<le> x_rel * x_factor + x_abs"
 and "abs (to_real y_f - y) \<le> y_rel * y_factor + y_abs"
 and "abs x \<le> x_factor"
 and "abs y \<le> y_factor"
 and "(0 :: Real.real) \<le> x_abs"
 and "(0 :: Real.real) \<le> y_abs"
 and "(0 :: Real.real) \<le> x_rel"
 and "(0 :: Real.real) \<le> y_rel"
 and "r = usub x_f y_f"
  for x_f :: "usingle"
  and x :: "real"
  and x_rel :: "real"
  and x_factor :: "real"
  and x_abs :: "real"
  and y_f :: "usingle"
  and y :: "real"
  and y_rel :: "real"
  and y_factor :: "real"
  and y_abs :: "real"
  and r :: "usingle"
axiomatization where umul_single_error_propagation:   "abs (to_real r - x * y) \<le> (eps + (x_rel + y_rel + x_rel * y_rel) * ((1 :: Real.real) + eps)) * (x_factor * y_factor) + (((y_abs + y_abs * x_rel) * x_factor + (x_abs + x_abs * y_rel) * y_factor + x_abs * y_abs) * ((1 :: Real.real) + eps) + eta)"
 if "abs (to_real x_f - x) \<le> x_rel * x_factor + x_abs"
 and "abs (to_real y_f - y) \<le> y_rel * y_factor + y_abs"
 and "abs x \<le> x_factor"
 and "abs y \<le> y_factor"
 and "(0 :: Real.real) \<le> x_rel"
 and "(0 :: Real.real) \<le> y_rel"
 and "(0 :: Real.real) \<le> x_abs"
 and "(0 :: Real.real) \<le> y_abs"
 and "r = umul x_f y_f"
  for x_f :: "usingle"
  and x :: "real"
  and x_rel :: "real"
  and x_factor :: "real"
  and x_abs :: "real"
  and y_f :: "usingle"
  and y :: "real"
  and y_rel :: "real"
  and y_factor :: "real"
  and y_abs :: "real"
  and r :: "usingle"
axiomatization where log_single_error_propagation:   "abs (to_real logx_f - ln x_exact) \<le> log_rel * abs (ln x_exact) + (-ln ((1 :: Real.real) - (x_rel * x_factor + x_abs) / x_exact) * ((1 :: Real.real) + log_rel) + log_abs)"
 if "abs (to_real x_f - x_exact) \<le> x_rel * x_factor + x_abs"
 and "abs (to_real logx_f - ln (to_real x_f)) \<le> log_rel * abs (ln (to_real x_f)) + log_abs"
 and "(0 :: Real.real) < x_exact"
 and "x_exact \<le> x_factor"
 and "(0 :: Real.real) < x_exact - x_rel * x_factor - x_abs"
 and "(0 :: Real.real) \<le> log_rel"
  for x_f :: "usingle"
  and x_exact :: "real"
  and x_rel :: "real"
  and x_factor :: "real"
  and x_abs :: "real"
  and logx_f :: "usingle"
  and log_rel :: "real"
  and log_abs :: "real"
axiomatization where log2_single_error_propagation:   "abs (to_real log2x_f - log (2) x_exact) \<le> log_rel * abs (log (2) x_exact) + (-log (2) ((1 :: Real.real) - (x_rel * x_factor + x_abs) / x_exact) * ((1 :: Real.real) + log_rel) + log_abs)"
 if "abs (to_real x_f - x_exact) \<le> x_rel * x_factor + x_abs"
 and "abs (to_real log2x_f - log (2) (to_real x_f)) \<le> log_rel * abs (log (2) (to_real x_f)) + log_abs"
 and "(0 :: Real.real) < x_exact"
 and "x_exact \<le> x_factor"
 and "(0 :: Real.real) < x_exact - x_rel * x_factor - x_abs"
 and "(0 :: Real.real) \<le> log_rel"
  for x_f :: "usingle"
  and x_exact :: "real"
  and x_rel :: "real"
  and x_factor :: "real"
  and x_abs :: "real"
  and log2x_f :: "usingle"
  and log_rel :: "real"
  and log_abs :: "real"
axiomatization where log10_single_error_propagation:   "abs (to_real log10x_f - log (10) x_exact) \<le> log_rel * abs (log (10) x_exact) + (-log (10) ((1 :: Real.real) - (x_rel * x_factor + x_abs) / x_exact) * ((1 :: Real.real) + log_rel) + log_abs)"
 if "abs (to_real x_f - x_exact) \<le> x_rel * x_factor + x_abs"
 and "abs (to_real log10x_f - log (10) (to_real x_f)) \<le> log_rel * abs (log (10) (to_real x_f)) + log_abs"
 and "(0 :: Real.real) < x_exact"
 and "x_exact \<le> x_factor"
 and "(0 :: Real.real) < x_exact - x_rel * x_factor - x_abs"
 and "(0 :: Real.real) \<le> log_rel"
  for x_f :: "usingle"
  and x_exact :: "real"
  and x_rel :: "real"
  and x_factor :: "real"
  and x_abs :: "real"
  and log10x_f :: "usingle"
  and log_rel :: "real"
  and log_abs :: "real"
axiomatization where exp_single_error_propagation:   "abs (to_real expx_f - exp x_exact) \<le> (exp_rel + (exp (x_rel * x_factor + x_abs) - (1 :: Real.real)) * ((1 :: Real.real) + exp_rel)) * exp x_exact + exp_abs"
 if "abs (to_real x_f - x_exact) \<le> x_rel * x_factor + x_abs"
 and "abs (to_real expx_f - exp (to_real x_f)) \<le> exp_rel * exp (to_real x_f) + exp_abs"
 and "x_exact \<le> x_factor"
 and "(0 :: Real.real) \<le> exp_rel"
 and "exp_rel \<le> (1 :: Real.real)"
  for x_f :: "usingle"
  and x_exact :: "real"
  and x_rel :: "real"
  and x_factor :: "real"
  and x_abs :: "real"
  and expx_f :: "usingle"
  and exp_rel :: "real"
  and exp_abs :: "real"
axiomatization where sin_single_error_propagation:   "abs (to_real sinx_f - sin x_exact) \<le> sin_rel * abs (sin x_exact) + ((x_rel * x_factor + x_abs) * ((1 :: Real.real) + sin_rel) + sin_abs)"
 if "abs (to_real x_f - x_exact) \<le> x_rel * x_factor + x_abs"
 and "abs (to_real sinx_f - sin (to_real x_f)) \<le> sin_rel * abs (sin (to_real x_f)) + sin_abs"
 and "x_exact \<le> x_factor"
 and "(0 :: Real.real) \<le> sin_rel"
  for x_f :: "usingle"
  and x_exact :: "real"
  and x_rel :: "real"
  and x_factor :: "real"
  and x_abs :: "real"
  and sinx_f :: "usingle"
  and sin_rel :: "real"
  and sin_abs :: "real"
axiomatization where cos_single_error_propagation:   "abs (to_real cosx_f - cos x_exact) \<le> cos_rel * abs (cos x_exact) + ((x_rel * x_factor + x_abs) * ((1 :: Real.real) + cos_rel) + cos_abs)"
 if "abs (to_real x_f - x_exact) \<le> x_rel * x_factor + x_abs"
 and "abs (to_real cosx_f - cos (to_real x_f)) \<le> cos_rel * abs (cos (to_real x_f)) + cos_abs"
 and "x_exact \<le> x_factor"
 and "(0 :: Real.real) \<le> cos_rel"
  for x_f :: "usingle"
  and x_exact :: "real"
  and x_rel :: "real"
  and x_factor :: "real"
  and x_abs :: "real"
  and cosx_f :: "usingle"
  and cos_rel :: "real"
  and cos_abs :: "real"
consts real_fun :: "(int \<Rightarrow> usingle) \<Rightarrow> int \<Rightarrow> real"
axiomatization where real_fun'def:   "real_fun f i = to_real (f i)"
  for f :: "int \<Rightarrow> usingle"
  and i :: "int"
axiomatization where sum_single_error_propagation:   "abs (to_real x - sum f_exact (0 :: int) n) \<le> (f_rel + sum_rel * ((1 :: Real.real) + f_rel)) * sum f_factor (0 :: int) n + (f_abs * real_of_int n * ((1 :: Real.real) + sum_rel) + sum_abs)"
 if "\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> abs (real_fun f i - f_exact i) \<le> f_rel * f_factor i + f_abs"
 and "\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> f_factor i - f_rel * f_factor i - f_abs \<le> f_factor' i \<and> f_factor' i \<le> f_factor i + f_rel * f_factor i + f_abs"
 and "abs (to_real x - sum (real_fun f) (0 :: int) n) \<le> sum_rel * sum f_factor' (0 :: int) n + sum_abs"
 and "(0 :: Real.real) \<le> sum_rel"
 and "(0 :: int) \<le> n"
  for n :: "int"
  and f :: "int \<Rightarrow> usingle"
  and f_exact :: "int \<Rightarrow> real"
  and f_rel :: "real"
  and f_factor :: "int \<Rightarrow> real"
  and f_abs :: "real"
  and f_factor' :: "int \<Rightarrow> real"
  and x :: "usingle"
  and sum_rel :: "real"
  and sum_abs :: "real"
consts udiv_closure :: "usingle \<Rightarrow> usingle \<Rightarrow> usingle"
axiomatization where udiv_exact_single_error_propagation:   "abs (to_real r - x / to_real y_f) \<le> x_rel * (x_factor / abs (to_real y_f)) + (x_abs / abs (to_real y_f) + eta)"
 if "abs (to_real x_f - x) \<le> x_rel * x_factor + x_abs"
 and "abs x \<le> x_factor"
 and "(0 :: Real.real) \<le> x_rel"
 and "(0 :: Real.real) \<le> x_abs"
 and "\<not>(0 :: Real.real) = to_real y_f"
 and "is_exact udiv_closure x_f y_f"
 and "r = infix_slslsldot x_f y_f"
  for x_f :: "usingle"
  and x :: "real"
  and x_rel :: "real"
  and x_factor :: "real"
  and x_abs :: "real"
  and y_f :: "usingle"
  and r :: "usingle"
end
