import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.real.Truncate
import Why3.mach.c.C
import Why3.mach.int.Unsigned
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub_1.Sub_1
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.sqrt.Sqrt1
import Why3.mach.fxp.Fxp
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.valuation.Valuation
open Classical
open Lean4Why3
namespace sqrtrem_Sqrt_wmpn_dc_sqrtremqtvc
theorem wmpn_dc_sqrtrem'vc (np : C.ptr (BitVec 64)) (n : BitVec 32) (sp : C.ptr (BitVec 64)) (scratch : C.ptr (BitVec 64)) (o1 : Bool) (fact0 : C.valid np (BitVec.toInt n + BitVec.toInt n)) (fact1 : C.valid sp (BitVec.toInt n)) (fact2 : (1 : ℤ) ≤ BitVec.toInt n) (fact3 : C.valid scratch ((1 : ℤ) + BitVec.toInt n / (2 : ℤ))) (fact4 : HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (2 : ℤ))) ≤ BitVec.toUInt (C.pelts np (C.offset np + BitVec.toInt n + BitVec.toInt n - (1 : ℤ)))) (fact5 : C.writable sp = true) (fact6 : C.writable scratch = true) (fact7 : C.writable np = true) (fact8 : (4 : ℤ) * BitVec.toInt n < (2147483647 : ℤ)) (fact9 : BitVec.toInt n = BitVec.toInt (1 : BitVec 32) → o1 = true) (fact10 : o1 = true → n = (1 : BitVec 32)) : if o1 = true then (C.valid scratch (1 : ℤ) ∧ C.valid sp (1 : ℤ) ∧ C.valid np (2 : ℤ) ∧ HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (2 : ℤ))) ≤ BitVec.toUInt (C.pelts np (C.offset np + (1 : ℤ))) ∧ C.writable sp = true ∧ C.writable scratch = true) ∧ (∀(scratch1 : C.ptr (BitVec 64)) (sp1 : C.ptr (BitVec 64)), List.length (C.data scratch1) = List.length (C.data scratch) ∧ C.offset scratch1 = C.offset scratch ∧ C.min scratch1 = C.min scratch ∧ C.max scratch1 = C.max scratch ∧ C.writable scratch1 = C.writable scratch ∧ C.zone1 scratch1 = C.zone1 scratch → List.length (C.data sp1) = List.length (C.data sp) ∧ C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.max sp1 = C.max sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → (∀(r : BitVec 64), Lemmas.value np (2 : ℤ) = BitVec.toUInt (C.pelts sp1 (C.offset sp1)) * BitVec.toUInt (C.pelts sp1 (C.offset sp1)) + BitVec.toUInt r * ((18446744073709551615 : ℤ) + (1 : ℤ)) + BitVec.toUInt (C.pelts scratch1 (C.offset scratch1)) ∧ BitVec.toUInt (C.pelts scratch1 (C.offset scratch1)) + BitVec.toUInt r * ((18446744073709551615 : ℤ) + (1 : ℤ)) ≤ (2 : ℤ) * BitVec.toUInt (C.pelts sp1 (C.offset sp1)) ∧ (0 : ℤ) ≤ BitVec.toUInt r ∧ BitVec.toUInt r ≤ (1 : ℤ) → (C.min scratch1 ≤ C.offset scratch1 ∧ C.offset scratch1 < C.max scratch1) ∧ ((C.min np ≤ C.offset np ∧ C.offset np < C.max np) ∧ C.writable np = true) ∧ (∀(np1 : C.ptr (BitVec 64)), List.length (C.data np1) = List.length (C.data np) ∧ C.offset np1 = C.offset np ∧ C.min np1 = C.min np ∧ C.max np1 = C.max np ∧ C.writable np1 = C.writable np ∧ C.zone1 np1 = C.zone1 np → C.pelts np1 = Function.update (C.pelts np) (C.offset np1) (C.pelts scratch1 (C.offset scratch1)) → Lemmas.value sp1 (BitVec.toInt n) * Lemmas.value sp1 (BitVec.toInt n) + Lemmas.value np1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt r = Lemmas.value np (BitVec.toInt n + BitVec.toInt n) ∧ Lemmas.value np1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt r ≤ (2 : ℤ) * Lemmas.value sp1 (BitVec.toInt n) ∧ HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (1 : ℤ))) ≤ BitVec.toUInt (C.pelts sp1 (C.offset sp1 + BitVec.toInt n - (1 : ℤ))) ∧ ((0 : ℤ) ≤ BitVec.toUInt r ∧ BitVec.toUInt r ≤ (1 : ℤ)) ∧ C.max np1 = C.max np ∧ C.min np1 = C.min np ∧ C.plength np1 = C.plength np ∧ C.max scratch1 = C.max scratch ∧ C.min scratch1 = C.min scratch ∧ C.plength scratch1 = C.plength scratch ∧ C.max sp1 = C.max sp ∧ C.min sp1 = C.min sp ∧ C.plength sp1 = C.plength sp))) else (¬(2 : ℤ) = (0 : ℤ) ∧ int'32_in_bounds (Int.tdiv (BitVec.toInt n) (2 : ℤ))) ∧ (∀(l : BitVec 32), BitVec.toInt l = Int.tdiv (BitVec.toInt n) (2 : ℤ) → int'32_in_bounds (BitVec.toInt n - BitVec.toInt l) ∧ (∀(h : BitVec 32), BitVec.toInt h = BitVec.toInt n - BitVec.toInt l → (let vn : ℤ := Lemmas.value np (BitVec.toInt n + BitVec.toInt n); int'32_in_bounds (BitVec.toInt l + BitVec.toInt l) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toInt l + BitVec.toInt l → ((0 : ℤ) ≤ BitVec.toInt o2 ∧ (C.min np ≤ C.offset np + BitVec.toInt o2 ∧ C.offset np + BitVec.toInt o2 ≤ C.max np) ∧ C.writable np = true) ∧ (∀(np1 : C.ptr (BitVec 64)), C.offset np1 = C.offset np ∧ C.min np1 = C.min np ∧ C.writable np1 = C.writable np ∧ C.zone1 np1 = C.zone1 np → (∀(np' : C.ptr (BitVec 64)), C.writable np' = true ∧ C.offset np' = C.offset np1 + BitVec.toInt o2 ∧ C.max np1 = C.offset np1 + BitVec.toInt o2 ∧ C.min np' = C.offset np1 + BitVec.toInt o2 ∧ C.max np' = C.max np ∧ C.zone1 np' = C.zone1 np1 ∧ C.pelts np1 = C.pelts np ∧ C.plength np1 = C.plength np ∧ C.pelts np' = C.pelts np ∧ C.plength np' = C.plength np → (let n0 : ℤ := Lemmas.value np1 (BitVec.toInt l); let n1 : ℤ := Lemmas.value_sub (C.pelts np1) (C.offset np1 + BitVec.toInt l) (C.offset np1 + BitVec.toInt l + BitVec.toInt l); HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt n)) ≤ (4 : ℤ) * vn ∧ (HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt n)) ≤ (4 : ℤ) * vn → ((0 : ℤ) ≤ BitVec.toInt l ∧ (C.min sp ≤ C.offset sp + BitVec.toInt l ∧ C.offset sp + BitVec.toInt l ≤ C.max sp) ∧ C.writable sp = true) ∧ (∀(sp1 : C.ptr (BitVec 64)), C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → (∀(spl : C.ptr (BitVec 64)), C.writable spl = true ∧ C.offset spl = C.offset sp1 + BitVec.toInt l ∧ C.max sp1 = C.offset sp1 + BitVec.toInt l ∧ C.min spl = C.offset sp1 + BitVec.toInt l ∧ C.max spl = C.max sp ∧ C.zone1 spl = C.zone1 sp1 ∧ C.pelts sp1 = C.pelts sp ∧ C.plength sp1 = C.plength sp ∧ C.pelts spl = C.pelts sp ∧ C.plength spl = C.plength sp → (BitVec.toInt h < BitVec.toInt n ∧ C.valid np' (BitVec.toInt h + BitVec.toInt h) ∧ C.valid spl (BitVec.toInt h) ∧ (1 : ℤ) ≤ BitVec.toInt h ∧ C.valid scratch ((1 : ℤ) + BitVec.toInt h / (2 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (2 : ℤ))) ≤ BitVec.toUInt (C.pelts np' (C.offset np' + BitVec.toInt h + BitVec.toInt h - (1 : ℤ))) ∧ (C.writable spl = true ∧ C.writable scratch = true ∧ C.writable np' = true) ∧ (4 : ℤ) * BitVec.toInt h < (2147483647 : ℤ)) ∧ (∀(spl1 : C.ptr (BitVec 64)) (np'1 : C.ptr (BitVec 64)) (scratch1 : C.ptr (BitVec 64)), C.offset spl1 = C.offset spl ∧ C.writable spl1 = C.writable spl ∧ C.zone1 spl1 = C.zone1 spl → C.offset np'1 = C.offset np' ∧ C.min np'1 = C.min np' ∧ C.writable np'1 = C.writable np' ∧ C.zone1 np'1 = C.zone1 np' → C.offset scratch1 = C.offset scratch ∧ C.writable scratch1 = C.writable scratch ∧ C.zone1 scratch1 = C.zone1 scratch → (∀(o3 : BitVec 64), Lemmas.value spl1 (BitVec.toInt h) * Lemmas.value spl1 (BitVec.toInt h) + Lemmas.value np'1 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toUInt o3 = Lemmas.value np' (BitVec.toInt h + BitVec.toInt h) ∧ Lemmas.value np'1 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toUInt o3 ≤ (2 : ℤ) * Lemmas.value spl1 (BitVec.toInt h) ∧ HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (1 : ℤ))) ≤ BitVec.toUInt (C.pelts spl1 (C.offset spl1 + BitVec.toInt h - (1 : ℤ))) ∧ ((0 : ℤ) ≤ BitVec.toUInt o3 ∧ BitVec.toUInt o3 ≤ (1 : ℤ)) ∧ C.max np'1 = C.max np' ∧ C.min np'1 = C.min np' ∧ C.plength np'1 = C.plength np' ∧ C.max scratch1 = C.max scratch ∧ C.min scratch1 = C.min scratch ∧ C.plength scratch1 = C.plength scratch ∧ C.max spl1 = C.max spl ∧ C.min spl1 = C.min spl ∧ C.plength spl1 = C.plength spl → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt l)) ≤ (2 : ℤ) * Lemmas.value spl1 (BitVec.toInt h) ∧ (HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt l)) ≤ (2 : ℤ) * Lemmas.value spl1 (BitVec.toInt h) → (let r' : ℤ := Lemmas.value np'1 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toUInt o3; (∀(o4 : Bool), (BitVec.toUInt o3 = BitVec.toUInt (0 : BitVec 64) → o4 = true) ∧ (o4 = true → o3 = (0 : BitVec 64)) → (if ¬o4 = true then ((0 : ℤ) ≤ BitVec.toInt h ∧ C.valid np'1 (BitVec.toInt h) ∧ C.valid spl1 (BitVec.toInt h) ∧ C.writable np'1 = true) ∧ (∀(np'2 : C.ptr (BitVec 64)), List.length (C.data np'2) = List.length (C.data np'1) ∧ C.offset np'2 = C.offset np'1 ∧ C.min np'2 = C.min np'1 ∧ C.max np'2 = C.max np'1 ∧ C.writable np'2 = C.writable np'1 ∧ C.zone1 np'2 = C.zone1 np'1 → (∀(b : BitVec 64), Lemmas.value np'2 (BitVec.toInt h) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toUInt b = Lemmas.value np'1 (BitVec.toInt h) - Lemmas.value spl1 (BitVec.toInt h) ∧ ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset np'2 ∨ C.offset np'2 + BitVec.toInt h ≤ j → C.pelts np'2 j = C.pelts np'1 j) → BitVec.toUInt o3 = (1 : ℤ) ∧ Lemmas.value np'2 (BitVec.toInt h) = r' - Lemmas.value spl1 (BitVec.toInt h) ∨ BitVec.toUInt o3 = (0 : ℤ) ∧ Lemmas.value np'2 (BitVec.toInt h) = r')) else BitVec.toUInt o3 = (1 : ℤ) ∧ Lemmas.value np'1 (BitVec.toInt h) = r' - Lemmas.value spl1 (BitVec.toInt h) ∨ BitVec.toUInt o3 = (0 : ℤ) ∧ Lemmas.value np'1 (BitVec.toInt h) = r')) ∧ (∀(np'2 : C.ptr (BitVec 64)), List.length (C.data np'2) = List.length (C.data np'1) ∧ C.offset np'2 = C.offset np'1 ∧ C.min np'2 = C.min np'1 ∧ C.max np'2 = C.max np'1 ∧ C.writable np'2 = C.writable np'1 ∧ C.zone1 np'2 = C.zone1 np'1 → BitVec.toUInt o3 = (1 : ℤ) ∧ Lemmas.value np'2 (BitVec.toInt h) = r' - Lemmas.value spl1 (BitVec.toInt h) ∨ BitVec.toUInt o3 = (0 : ℤ) ∧ Lemmas.value np'2 (BitVec.toInt h) = r' → (C.zone1 np1 = C.zone1 np'2 ∧ C.max np1 = C.min np'2 ∧ C.writable np1 = true ∧ C.writable np'2 = true) ∧ (∀(np2 : C.ptr (BitVec 64)), List.length (C.data np2) = List.length (C.data np1) ∧ C.offset np2 = C.offset np1 ∧ C.min np2 = C.min np1 ∧ C.writable np2 = C.writable np1 ∧ C.zone1 np2 = C.zone1 np1 → C.max np2 = C.max np'2 ∧ C.plength np2 = C.plength np1 ∧ (∀(i : ℤ), C.min np1 ≤ i ∧ i < C.max np1 → C.pelts np2 i = C.pelts np1 i) ∧ (∀(i : ℤ), C.min np'2 ≤ i ∧ i < C.max np'2 → C.pelts np2 i = C.pelts np'2 i) → ((0 : ℤ) ≤ BitVec.toInt l ∧ (C.min np2 ≤ C.offset np2 + BitVec.toInt l ∧ C.offset np2 + BitVec.toInt l ≤ C.max np2) ∧ C.writable np2 = true) ∧ (∀(np3 : C.ptr (BitVec 64)), C.offset np3 = C.offset np2 ∧ C.min np3 = C.min np2 ∧ C.writable np3 = C.writable np2 ∧ C.zone1 np3 = C.zone1 np2 → (∀(npl : C.ptr (BitVec 64)), C.writable npl = true ∧ C.offset npl = C.offset np3 + BitVec.toInt l ∧ C.max np3 = C.offset np3 + BitVec.toInt l ∧ C.min npl = C.offset np3 + BitVec.toInt l ∧ C.max npl = C.max np2 ∧ C.zone1 npl = C.zone1 np3 ∧ C.pelts np3 = C.pelts np2 ∧ C.plength np3 = C.plength np2 ∧ C.pelts npl = C.pelts np2 ∧ C.plength npl = C.plength np2 → (((1 : ℤ) ≤ BitVec.toInt h ∧ BitVec.toInt h ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ (2147483647 : ℤ) - (1 : ℤ)) ∧ C.valid npl (BitVec.toInt n) ∧ C.valid spl1 (BitVec.toInt h) ∧ C.valid scratch1 (BitVec.toInt n - BitVec.toInt h + (1 : ℤ)) ∧ (C.writable npl = true ∧ C.writable scratch1 = true) ∧ (0 : ℤ) < BitVec.toUInt (C.pelts spl1 (C.offset spl1 + BitVec.toInt h - (1 : ℤ)))) ∧ (∀(npl1 : C.ptr (BitVec 64)) (scratch2 : C.ptr (BitVec 64)), List.length (C.data npl1) = List.length (C.data npl) ∧ C.offset npl1 = C.offset npl ∧ C.min npl1 = C.min npl ∧ C.max npl1 = C.max npl ∧ C.writable npl1 = C.writable npl ∧ C.zone1 npl1 = C.zone1 npl → List.length (C.data scratch2) = List.length (C.data scratch1) ∧ C.offset scratch2 = C.offset scratch1 ∧ C.min scratch2 = C.min scratch1 ∧ C.max scratch2 = C.max scratch1 ∧ C.writable scratch2 = C.writable scratch1 ∧ C.zone1 scratch2 = C.zone1 scratch1 → Lemmas.value npl (BitVec.toInt n) = Lemmas.value scratch2 (BitVec.toInt n - BitVec.toInt h + (1 : ℤ)) * Lemmas.value spl1 (BitVec.toInt h) + Lemmas.value npl1 (BitVec.toInt h) ∧ Lemmas.value npl1 (BitVec.toInt h) < Lemmas.value spl1 (BitVec.toInt h) → (C.min scratch2 ≤ C.offset scratch2 + BitVec.toInt l ∧ C.offset scratch2 + BitVec.toInt l < C.max scratch2) ∧ (let sl : BitVec 64 := C.pelts scratch2 (C.offset scratch2 + BitVec.toInt l); uint'64_in_bounds (BitVec.toUInt o3 + BitVec.toUInt sl) ∧ (∀(o4 : BitVec 64), BitVec.toUInt o4 = BitVec.toUInt o3 + BitVec.toUInt sl → (C.min scratch2 ≤ C.offset scratch2 ∧ C.offset scratch2 < C.max scratch2) ∧ (let sh : BitVec 64 := C.pelts scratch2 (C.offset scratch2); (¬(2 : ℤ) = (0 : ℤ) ∧ uint'64_in_bounds (Int.tmod (BitVec.toUInt sh) (2 : ℤ))) ∧ (∀(o5 : BitVec 64), BitVec.toUInt o5 = Int.tmod (BitVec.toUInt sh) (2 : ℤ) → BitVec.toUInt o5 ≤ (9223372036854775807 : ℤ) ∧ (∀(o6 : BitVec 64), BitVec.toInt o6 = BitVec.toUInt o5 → (C.valid scratch2 (BitVec.toInt l) ∧ C.valid sp1 (BitVec.toInt l) ∧ ((0 : ℤ) < (1 : ℤ) ∧ (1 : ℤ) < (64 : ℤ)) ∧ (0 : ℤ) < BitVec.toInt l ∧ C.writable sp1 = true) ∧ (∀(scratch3 : C.ptr (BitVec 64)) (sp2 : C.ptr (BitVec 64)), C.offset scratch3 = C.offset scratch2 ∧ C.writable scratch3 = C.writable scratch2 ∧ C.zone1 scratch3 = C.zone1 scratch2 → C.offset sp2 = C.offset sp1 ∧ C.writable sp2 = C.writable sp1 ∧ C.zone1 sp2 = C.zone1 sp1 → (∀(r : BitVec 64), BitVec.toUInt r + ((18446744073709551615 : ℤ) + (1 : ℤ)) * Lemmas.value sp2 (BitVec.toInt l) = Lemmas.value scratch3 (BitVec.toInt l) * HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (1 : ℤ))) ∧ (∀(j : ℤ), j < C.offset sp2 ∨ C.offset sp2 + BitVec.toInt l ≤ j → C.pelts sp2 j = C.pelts sp1 j) ∧ C.pelts scratch3 = C.pelts scratch2 ∧ (C.min scratch3 = C.min scratch2 ∧ C.max scratch3 = C.max scratch2 ∧ C.plength scratch3 = C.plength scratch2) ∧ C.min sp2 = C.min sp1 ∧ C.max sp2 = C.max sp1 ∧ C.plength sp2 = C.plength sp1 → int'32_in_bounds (BitVec.toInt l - (1 : ℤ)) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt l - (1 : ℤ) → (C.min sp2 ≤ C.offset sp2 + BitVec.toInt o7 ∧ C.offset sp2 + BitVec.toInt o7 < C.max sp2) ∧ (let st : BitVec 64 := C.pelts sp2 (C.offset sp2 + BitVec.toInt o7); uint'64_in_bounds (64 : ℤ) ∧ (∀(o8 : BitVec 64), BitVec.toUInt o8 = (64 : ℤ) → uint'64_in_bounds (BitVec.toUInt o8 - (1 : ℤ)) ∧ (∀(o9 : BitVec 64), BitVec.toUInt o9 = BitVec.toUInt o8 - (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt o9 ∧ BitVec.toUInt o9 < (64 : ℤ)) ∧ (∀(ql : BitVec 64), BitVec.toUInt ql = BitVec.toUInt o4 * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o9)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) ∧ BitVec.toUInt ql ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o9)) → ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < (64 : ℤ)) ∧ (∀(qh : BitVec 64), BitVec.toUInt qh = BitVec.toUInt o4 / HPow.hPow (2 : ℤ) (1 : ℕ) → uint'64_in_bounds (BitVec.toUInt st + BitVec.toUInt ql) ∧ (∀(o10 : BitVec 64), BitVec.toUInt o10 = BitVec.toUInt st + BitVec.toUInt ql → int'32_in_bounds (BitVec.toInt l - (1 : ℤ)) ∧ (∀(o11 : BitVec 32), BitVec.toInt o11 = BitVec.toInt l - (1 : ℤ) → ((C.min sp2 ≤ C.offset sp2 + BitVec.toInt o11 ∧ C.offset sp2 + BitVec.toInt o11 < C.max sp2) ∧ C.writable sp2 = true) ∧ (∀(sp3 : C.ptr (BitVec 64)), List.length (C.data sp3) = List.length (C.data sp2) ∧ C.offset sp3 = C.offset sp2 ∧ C.min sp3 = C.min sp2 ∧ C.max sp3 = C.max sp2 ∧ C.writable sp3 = C.writable sp2 ∧ C.zone1 sp3 = C.zone1 sp2 → C.pelts sp3 = Function.update (C.pelts sp2) (C.offset sp3 + BitVec.toInt o11) o10 ∧ C.pelts sp3 (C.offset sp3 + BitVec.toInt o11) = o10 → ((BitVec.toInt o6 = (0 : ℤ) → o6 = (0 : BitVec 64)) → (if ¬o6 = (0 : BitVec 64) then (C.valid npl1 (BitVec.toInt h) ∧ C.valid spl1 (BitVec.toInt h) ∧ C.writable npl1 = true) ∧ (∀(npl2 : C.ptr (BitVec 64)), List.length (C.data npl2) = List.length (C.data npl1) ∧ C.offset npl2 = C.offset npl1 ∧ C.min npl2 = C.min npl1 ∧ C.max npl2 = C.max npl1 ∧ C.writable npl2 = C.writable npl1 ∧ C.zone1 npl2 = C.zone1 npl1 → (∀(c' : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt c' ∧ BitVec.toUInt c' ≤ (1 : ℤ)) ∧ Lemmas.value npl2 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toUInt c' = Lemmas.value npl1 (BitVec.toInt h) + Lemmas.value spl1 (BitVec.toInt h) ∧ (∀(j : ℤ), j < C.offset npl2 ∨ C.offset npl2 + BitVec.toInt h ≤ j → C.pelts npl2 j = C.pelts npl1 j) → BitVec.toUInt c' ≤ (9223372036854775807 : ℤ) ∧ (∀(o12 : BitVec 64), BitVec.toInt o12 = BitVec.toUInt c' → n1 + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt l)) * r' = (2 : ℤ) * Lemmas.value spl1 (BitVec.toInt h) * (Lemmas.value sp3 (BitVec.toInt l) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt l)) * BitVec.toUInt qh) + Lemmas.value npl2 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toInt o12 ∧ ((0 : ℤ) ≤ BitVec.toInt o12 ∧ BitVec.toInt o12 ≤ (1 : ℤ)) ∧ (0 : ℤ) ≤ Lemmas.value npl2 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toInt o12 ∧ Lemmas.value npl2 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toInt o12 < (2 : ℤ) * Lemmas.value spl1 (BitVec.toInt h)))) else n1 + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt l)) * r' = (2 : ℤ) * Lemmas.value spl1 (BitVec.toInt h) * (Lemmas.value sp3 (BitVec.toInt l) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt l)) * BitVec.toUInt qh) + Lemmas.value npl1 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toInt o6 ∧ ((0 : ℤ) ≤ BitVec.toInt o6 ∧ BitVec.toInt o6 ≤ (1 : ℤ)) ∧ (0 : ℤ) ≤ Lemmas.value npl1 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toInt o6 ∧ Lemmas.value npl1 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toInt o6 < (2 : ℤ) * Lemmas.value spl1 (BitVec.toInt h))) ∧ (∀(c : BitVec 64) (npl2 : C.ptr (BitVec 64)), List.length (C.data npl2) = List.length (C.data npl1) ∧ C.offset npl2 = C.offset npl1 ∧ C.min npl2 = C.min npl1 ∧ C.max npl2 = C.max npl1 ∧ C.writable npl2 = C.writable npl1 ∧ C.zone1 npl2 = C.zone1 npl1 → n1 + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt l)) * r' = (2 : ℤ) * Lemmas.value spl1 (BitVec.toInt h) * (Lemmas.value sp3 (BitVec.toInt l) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt l)) * BitVec.toUInt qh) + Lemmas.value npl2 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toInt c ∧ ((0 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (1 : ℤ)) ∧ (0 : ℤ) ≤ Lemmas.value npl2 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toInt c ∧ Lemmas.value npl2 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toInt c < (2 : ℤ) * Lemmas.value spl1 (BitVec.toInt h) → (let dq : ℤ := Lemmas.value sp3 (BitVec.toInt l) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt l)) * BitVec.toUInt qh; let r'' : ℤ := Lemmas.value npl2 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toInt c; (C.zone1 np3 = C.zone1 npl2 ∧ C.max np3 = C.min npl2 ∧ C.writable np3 = true ∧ C.writable npl2 = true) ∧ (∀(np4 : C.ptr (BitVec 64)), List.length (C.data np4) = List.length (C.data np3) ∧ C.offset np4 = C.offset np3 ∧ C.min np4 = C.min np3 ∧ C.writable np4 = C.writable np3 ∧ C.zone1 np4 = C.zone1 np3 → C.max np4 = C.max npl2 ∧ C.plength np4 = C.plength np3 ∧ (∀(i : ℤ), C.min np3 ≤ i ∧ i < C.max np3 → C.pelts np4 i = C.pelts np3 i) ∧ (∀(i : ℤ), C.min npl2 ≤ i ∧ i < C.max npl2 → C.pelts np4 i = C.pelts npl2 i) → ((0 : ℤ) ≤ BitVec.toInt n ∧ (C.min np4 ≤ C.offset np4 + BitVec.toInt n ∧ C.offset np4 + BitVec.toInt n ≤ C.max np4) ∧ C.writable np4 = true) ∧ (∀(np5 : C.ptr (BitVec 64)), C.offset np5 = C.offset np4 ∧ C.min np5 = C.min np4 ∧ C.writable np5 = C.writable np4 ∧ C.zone1 np5 = C.zone1 np4 → (∀(npn : C.ptr (BitVec 64)), C.writable npn = true ∧ C.offset npn = C.offset np5 + BitVec.toInt n ∧ C.max np5 = C.offset np5 + BitVec.toInt n ∧ C.min npn = C.offset np5 + BitVec.toInt n ∧ C.max npn = C.max np4 ∧ C.zone1 npn = C.zone1 np5 ∧ C.pelts np5 = C.pelts np4 ∧ C.plength np5 = C.plength np4 ∧ C.pelts npn = C.pelts np4 ∧ C.plength npn = C.plength np4 → (C.valid sp3 (BitVec.toInt l) ∧ C.valid sp3 (BitVec.toInt l) ∧ C.valid npn (BitVec.toInt l + BitVec.toInt l) ∧ C.writable npn = true ∧ ((0 : ℤ) < BitVec.toInt l ∧ BitVec.toInt l ≤ BitVec.toInt l) ∧ (8 : ℤ) * BitVec.toInt l < (2147483647 : ℤ) ∧ BitVec.toInt l ≤ BitVec.toInt (29 : BitVec 32) * HPow.hPow (2 : ℤ) (64 : ℕ) ∧ (0 : ℤ) ≤ (64 : ℤ) ∧ (64 : ℤ) ≤ (64 : ℤ)) ∧ (∀(npn1 : C.ptr (BitVec 64)), C.offset npn1 = C.offset npn ∧ C.writable npn1 = C.writable npn ∧ C.zone1 npn1 = C.zone1 npn → C.min npn1 = C.min npn ∧ C.max npn1 = C.max npn ∧ C.plength npn1 = C.plength npn ∧ Lemmas.value npn1 (BitVec.toInt l + BitVec.toInt l) = Lemmas.value sp3 (BitVec.toInt l) * Lemmas.value sp3 (BitVec.toInt l) ∧ (∀(j : ℤ), C.min npn1 ≤ j ∧ j < C.offset npn1 ∨ C.offset npn1 + BitVec.toInt l + BitVec.toInt l ≤ j ∧ j < C.max npn1 → C.pelts npn1 j = C.pelts npn j) → int'32_in_bounds ((2 : ℤ) * BitVec.toInt l) ∧ (∀(ll : BitVec 32), BitVec.toInt ll = (2 : ℤ) * BitVec.toInt l → ((0 : ℤ) ≤ BitVec.toInt ll ∧ C.valid np5 (BitVec.toInt ll) ∧ C.valid npn1 (BitVec.toInt ll) ∧ C.writable np5 = true) ∧ (∀(np6 : C.ptr (BitVec 64)), List.length (C.data np6) = List.length (C.data np5) ∧ C.offset np6 = C.offset np5 ∧ C.min np6 = C.min np5 ∧ C.max np6 = C.max np5 ∧ C.writable np6 = C.writable np5 ∧ C.zone1 np6 = C.zone1 np5 → (∀(bo : BitVec 64), Lemmas.value np6 (BitVec.toInt ll) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt ll)) * BitVec.toUInt bo = Lemmas.value np5 (BitVec.toInt ll) - Lemmas.value npn1 (BitVec.toInt ll) ∧ ((0 : ℤ) ≤ BitVec.toUInt bo ∧ BitVec.toUInt bo ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset np6 ∨ C.offset np6 + BitVec.toInt ll ≤ j → C.pelts np6 j = C.pelts np5 j) → uint'64_in_bounds (BitVec.toUInt qh + BitVec.toUInt bo) ∧ (∀(b : BitVec 64), BitVec.toUInt b = BitVec.toUInt qh + BitVec.toUInt bo → (∀(o12 : Bool), (BitVec.toInt l = BitVec.toInt h → o12 = true) ∧ (o12 = true → l = h) → (if o12 = true then BitVec.toUInt b ≤ (9223372036854775807 : ℤ) ∧ (∀(o13 : BitVec 64), BitVec.toInt o13 = BitVec.toUInt b → int'64_in_bounds (BitVec.toInt c - BitVec.toInt o13) ∧ (∀(o14 : BitVec 64), BitVec.toInt o14 = BitVec.toInt c - BitVec.toInt o13 → Lemmas.value np6 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toInt o14 = n0 + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt l)) * r'' - dq * dq ∧ -(1 : ℤ) ≤ BitVec.toInt o14 ∧ BitVec.toInt o14 ≤ (1 : ℤ))) else (C.min np6 ≤ C.offset np6 + BitVec.toInt ll ∧ C.offset np6 + BitVec.toInt ll ≤ C.max np6) ∧ (∀(nll : C.ptr (BitVec 64)), C.offset nll = C.offset np6 + BitVec.toInt ll ∧ C.plength nll = C.plength np6 ∧ C.pelts nll = C.pelts np6 ∧ C.data nll = C.data np6 ∧ C.min nll = C.min np6 ∧ C.max nll = C.max np6 ∧ C.zone1 nll = C.zone1 np6 ∧ C.writable nll = C.writable np6 → (C.valid nll (1 : ℤ) ∧ (0 : ℤ) < (1 : ℤ) ∧ C.writable nll = true) ∧ (∀(nll1 : C.ptr (BitVec 64)) (np7 : C.ptr (BitVec 64)), C.data nll1 = C.data np7 ∧ List.length (C.data np7) = List.length (C.data nll) ∧ C.offset nll1 = C.offset nll ∧ C.min nll1 = C.min nll ∧ C.max nll1 = C.max nll ∧ C.writable nll1 = C.writable nll ∧ C.zone1 nll1 = C.zone1 nll → List.length (C.data np7) = List.length (C.data np6) ∧ C.offset np7 = C.offset np6 ∧ C.min np7 = C.min np6 ∧ C.max np7 = C.max np6 ∧ C.writable np7 = C.writable np6 ∧ C.zone1 np7 = C.zone1 np6 → (∀(bo1 : BitVec 64), Lemmas.value nll1 (1 : ℤ) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (1 : ℕ) * BitVec.toUInt bo1 = Lemmas.value nll (1 : ℤ) - BitVec.toUInt b ∧ ((0 : ℤ) ≤ BitVec.toUInt bo1 ∧ BitVec.toUInt bo1 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset nll1 ∨ C.offset nll1 + (1 : ℤ) ≤ j → C.pelts nll1 j = C.pelts nll j) → BitVec.toUInt bo1 ≤ (9223372036854775807 : ℤ) ∧ (∀(o13 : BitVec 64), BitVec.toInt o13 = BitVec.toUInt bo1 → int'64_in_bounds (BitVec.toInt c - BitVec.toInt o13) ∧ (∀(o14 : BitVec 64), BitVec.toInt o14 = BitVec.toInt c - BitVec.toInt o13 → Lemmas.value np7 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toInt o14 = n0 + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt l)) * r'' - dq * dq ∧ -(1 : ℤ) ≤ BitVec.toInt o14 ∧ BitVec.toInt o14 ≤ (1 : ℤ)))))))) ∧ (∀(c1 : BitVec 64) (np7 : C.ptr (BitVec 64)), List.length (C.data np7) = List.length (C.data np6) ∧ C.offset np7 = C.offset np6 ∧ C.min np7 = C.min np6 ∧ C.max np7 = C.max np6 ∧ C.writable np7 = C.writable np6 ∧ C.zone1 np7 = C.zone1 np6 → Lemmas.value np7 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toInt c1 = n0 + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt l)) * r'' - dq * dq ∧ -(1 : ℤ) ≤ BitVec.toInt c1 ∧ BitVec.toInt c1 ≤ (1 : ℤ) → (if BitVec.toInt c1 < (0 : ℤ) then (C.valid spl1 (BitVec.toInt h) ∧ (0 : ℤ) < BitVec.toInt h ∧ C.writable spl1 = true) ∧ (∀(spl2 : C.ptr (BitVec 64)), List.length (C.data spl2) = List.length (C.data spl1) ∧ C.offset spl2 = C.offset spl1 ∧ C.min spl2 = C.min spl1 ∧ C.max spl2 = C.max spl1 ∧ C.writable spl2 = C.writable spl1 ∧ C.zone1 spl2 = C.zone1 spl1 → (∀(o12 : BitVec 64), Lemmas.value spl2 (BitVec.toInt h) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt h)) * BitVec.toUInt o12 = Lemmas.value spl1 (BitVec.toInt h) + BitVec.toUInt qh ∧ ((0 : ℤ) ≤ BitVec.toUInt o12 ∧ BitVec.toUInt o12 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset spl2 ∨ C.offset spl2 + BitVec.toInt h ≤ j → C.pelts spl2 j = C.pelts spl1 j) → (C.zone1 sp3 = C.zone1 spl2 ∧ C.max sp3 = C.min spl2 ∧ C.writable sp3 = true ∧ C.writable spl2 = true) ∧ (∀(sp4 : C.ptr (BitVec 64)), List.length (C.data sp4) = List.length (C.data sp3) ∧ C.offset sp4 = C.offset sp3 ∧ C.min sp4 = C.min sp3 ∧ C.writable sp4 = C.writable sp3 ∧ C.zone1 sp4 = C.zone1 sp3 → C.max sp4 = C.max spl2 ∧ C.plength sp4 = C.plength sp3 ∧ (∀(i : ℤ), C.min sp3 ≤ i ∧ i < C.max sp3 → C.pelts sp4 i = C.pelts sp3 i) ∧ (∀(i : ℤ), C.min spl2 ≤ i ∧ i < C.max spl2 → C.pelts sp4 i = C.pelts spl2 i) → (C.valid sp4 (BitVec.toInt n) ∧ C.valid np7 (BitVec.toInt n) ∧ C.writable np7 = true) ∧ (∀(np8 : C.ptr (BitVec 64)), List.length (C.data np8) = List.length (C.data np7) ∧ C.offset np8 = C.offset np7 ∧ C.min np8 = C.min np7 ∧ C.max np8 = C.max np7 ∧ C.writable np8 = C.writable np7 ∧ C.zone1 np8 = C.zone1 np7 → (∀(c' : BitVec 64), Lemmas.value np8 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt c' = Lemmas.value np7 (BitVec.toInt n) + Lemmas.value sp4 (BitVec.toInt n) * (2 : ℤ) ∧ (∀(j : ℤ), j < C.offset np8 ∨ C.offset np8 + BitVec.toInt n ≤ j → C.pelts np8 j = C.pelts np7 j) → uint'64_in_bounds ((2 : ℤ) * BitVec.toUInt o12) ∧ (∀(o13 : BitVec 64), BitVec.toUInt o13 = (2 : ℤ) * BitVec.toUInt o12 → uint'64_in_bounds (BitVec.toUInt o13 + BitVec.toUInt c') ∧ (∀(o14 : BitVec 64), BitVec.toUInt o14 = BitVec.toUInt o13 + BitVec.toUInt c' → BitVec.toUInt o14 ≤ (9223372036854775807 : ℤ) ∧ (∀(o15 : BitVec 64), BitVec.toInt o15 = BitVec.toUInt o14 → int'64_in_bounds (BitVec.toInt c1 + BitVec.toInt o15) ∧ (∀(o16 : BitVec 64), BitVec.toInt o16 = BitVec.toInt c1 + BitVec.toInt o15 → (C.valid np8 (BitVec.toInt n) ∧ (0 : ℤ) < BitVec.toInt n ∧ C.writable np8 = true) ∧ (∀(np9 : C.ptr (BitVec 64)), List.length (C.data np9) = List.length (C.data np8) ∧ C.offset np9 = C.offset np8 ∧ C.min np9 = C.min np8 ∧ C.max np9 = C.max np8 ∧ C.writable np9 = C.writable np8 ∧ C.zone1 np9 = C.zone1 np8 → (∀(o17 : BitVec 64), Lemmas.value np9 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt o17 = Lemmas.value np8 (BitVec.toInt n) - (1 : ℤ) ∧ ((0 : ℤ) ≤ BitVec.toUInt o17 ∧ BitVec.toUInt o17 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset np9 ∨ C.offset np9 + BitVec.toInt n ≤ j → C.pelts np9 j = C.pelts np8 j) → BitVec.toUInt o17 ≤ (9223372036854775807 : ℤ) ∧ (∀(o18 : BitVec 64), BitVec.toInt o18 = BitVec.toUInt o17 → int'64_in_bounds (BitVec.toInt o16 - BitVec.toInt o18) ∧ (∀(o19 : BitVec 64), BitVec.toInt o19 = BitVec.toInt o16 - BitVec.toInt o18 → (C.valid sp4 (BitVec.toInt n) ∧ (0 : ℤ) < BitVec.toInt n ∧ C.writable sp4 = true) ∧ (∀(sp5 : C.ptr (BitVec 64)), List.length (C.data sp5) = List.length (C.data sp4) ∧ C.offset sp5 = C.offset sp4 ∧ C.min sp5 = C.min sp4 ∧ C.max sp5 = C.max sp4 ∧ C.writable sp5 = C.writable sp4 ∧ C.zone1 sp5 = C.zone1 sp4 → (∀(bo1 : BitVec 64), Lemmas.value sp5 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt bo1 = Lemmas.value sp4 (BitVec.toInt n) - (1 : ℤ) ∧ ((0 : ℤ) ≤ BitVec.toUInt bo1 ∧ BitVec.toUInt bo1 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset sp5 ∨ C.offset sp5 + BitVec.toInt n ≤ j → C.pelts sp5 j = C.pelts sp4 j) → uint'64_in_bounds (BitVec.toUInt o12 - BitVec.toUInt bo1) ∧ (∀(o20 : BitVec 64), BitVec.toUInt o20 = BitVec.toUInt o12 - BitVec.toUInt bo1 → (C.zone1 np9 = C.zone1 npn1 ∧ C.max np9 = C.min npn1 ∧ C.writable np9 = true ∧ C.writable npn1 = true) ∧ (∀(np10 : C.ptr (BitVec 64)), List.length (C.data np10) = List.length (C.data np9) ∧ C.offset np10 = C.offset np9 ∧ C.min np10 = C.min np9 ∧ C.writable np10 = C.writable np9 ∧ C.zone1 np10 = C.zone1 np9 → C.max np10 = C.max npn1 ∧ C.plength np10 = C.plength np9 ∧ (∀(i : ℤ), C.min np9 ≤ i ∧ i < C.max np9 → C.pelts np10 i = C.pelts np9 i) ∧ (∀(i : ℤ), C.min npn1 ≤ i ∧ i < C.max npn1 → C.pelts np10 i = C.pelts npn1 i) → (0 : ℤ) ≤ BitVec.toInt o19 ∧ (∀(result : BitVec 64), BitVec.toUInt result = BitVec.toInt o19 → Lemmas.value sp5 (BitVec.toInt n) * Lemmas.value sp5 (BitVec.toInt n) + Lemmas.value np10 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt result = Lemmas.value np (BitVec.toInt n + BitVec.toInt n) ∧ Lemmas.value np10 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt result ≤ (2 : ℤ) * Lemmas.value sp5 (BitVec.toInt n) ∧ HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (1 : ℤ))) ≤ BitVec.toUInt (C.pelts sp5 (C.offset sp5 + BitVec.toInt n - (1 : ℤ))) ∧ ((0 : ℤ) ≤ BitVec.toUInt result ∧ BitVec.toUInt result ≤ (1 : ℤ)) ∧ C.max np10 = C.max np ∧ C.min np10 = C.min np ∧ C.plength np10 = C.plength np ∧ C.max scratch3 = C.max scratch ∧ C.min scratch3 = C.min scratch ∧ C.plength scratch3 = C.plength scratch ∧ C.max sp5 = C.max sp ∧ C.min sp5 = C.min sp ∧ C.plength sp5 = C.plength sp)))))))))))))))))) else (C.zone1 sp3 = C.zone1 spl1 ∧ C.max sp3 = C.min spl1 ∧ C.writable sp3 = true ∧ C.writable spl1 = true) ∧ (∀(sp4 : C.ptr (BitVec 64)), List.length (C.data sp4) = List.length (C.data sp3) ∧ C.offset sp4 = C.offset sp3 ∧ C.min sp4 = C.min sp3 ∧ C.writable sp4 = C.writable sp3 ∧ C.zone1 sp4 = C.zone1 sp3 → C.max sp4 = C.max spl1 ∧ C.plength sp4 = C.plength sp3 ∧ (∀(i : ℤ), C.min sp3 ≤ i ∧ i < C.max sp3 → C.pelts sp4 i = C.pelts sp3 i) ∧ (∀(i : ℤ), C.min spl1 ≤ i ∧ i < C.max spl1 → C.pelts sp4 i = C.pelts spl1 i) → (C.zone1 np7 = C.zone1 npn1 ∧ C.max np7 = C.min npn1 ∧ C.writable np7 = true ∧ C.writable npn1 = true) ∧ (∀(np8 : C.ptr (BitVec 64)), List.length (C.data np8) = List.length (C.data np7) ∧ C.offset np8 = C.offset np7 ∧ C.min np8 = C.min np7 ∧ C.writable np8 = C.writable np7 ∧ C.zone1 np8 = C.zone1 np7 → C.max np8 = C.max npn1 ∧ C.plength np8 = C.plength np7 ∧ (∀(i : ℤ), C.min np7 ≤ i ∧ i < C.max np7 → C.pelts np8 i = C.pelts np7 i) ∧ (∀(i : ℤ), C.min npn1 ≤ i ∧ i < C.max npn1 → C.pelts np8 i = C.pelts npn1 i) → (0 : ℤ) ≤ BitVec.toInt c1 ∧ (∀(result : BitVec 64), BitVec.toUInt result = BitVec.toInt c1 → Lemmas.value sp4 (BitVec.toInt n) * Lemmas.value sp4 (BitVec.toInt n) + Lemmas.value np8 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt result = Lemmas.value np (BitVec.toInt n + BitVec.toInt n) ∧ Lemmas.value np8 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt result ≤ (2 : ℤ) * Lemmas.value sp4 (BitVec.toInt n) ∧ HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (1 : ℤ))) ≤ BitVec.toUInt (C.pelts sp4 (C.offset sp4 + BitVec.toInt n - (1 : ℤ))) ∧ ((0 : ℤ) ≤ BitVec.toUInt result ∧ BitVec.toUInt result ≤ (1 : ℤ)) ∧ C.max np8 = C.max np ∧ C.min np8 = C.min np ∧ C.plength np8 = C.plength np ∧ C.max scratch3 = C.max scratch ∧ C.min scratch3 = C.min scratch ∧ C.plength scratch3 = C.plength scratch ∧ C.max sp4 = C.max sp ∧ C.min sp4 = C.min sp ∧ C.plength sp4 = C.plength sp))))))))))))))))))))))))))))))))))))))))))))))))))
  := sorry
end sqrtrem_Sqrt_wmpn_dc_sqrtremqtvc
