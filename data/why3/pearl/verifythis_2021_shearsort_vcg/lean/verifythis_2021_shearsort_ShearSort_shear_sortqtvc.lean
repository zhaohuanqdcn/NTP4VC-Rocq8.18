import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
import Why3.int.Sum
import Why3.map.MapExt
import Why3.map.MapPermut
import Why3.matrix.Matrix
open Classical
open Lean4Why3
namespace verifythis_2021_shearsort_ShearSort_shear_sortqtvc
axiom column :  {α : Type} -> [Inhabited α] -> Matrix.matrix α -> ℤ -> ℤ -> α
axiom column'def {α : Type} [Inhabited α] (m : Matrix.matrix α) (j : ℤ) (i : ℤ) : column m j i = Matrix.elts m i j
axiom moccf :  {α : Type} -> [Inhabited α] -> α -> (ℤ -> ℤ -> α) -> ℤ -> ℤ -> ℤ
axiom moccf'def {α : Type} [Inhabited α] (x : α) (e : ℤ -> ℤ -> α) (c : ℤ) (i : ℤ) : moccf x e c i = Int.ofNat (Lean4Why3.map_occ x (e i) (0 : ℤ) c)
noncomputable def mocc {α : Type} [Inhabited α] (x : α) (e : ℤ -> ℤ -> α) (r : ℤ) (c : ℤ) := int.Sum.sum (moccf x e c) (0 : ℤ) r
axiom compose :  {γ : Type} -> [Inhabited γ] ->  {β : Type} -> [Inhabited β] ->  {α : Type} -> [Inhabited α] -> (β -> γ) -> (α -> β) -> α -> γ
axiom compose'def {γ : Type} {α : Type} {β : Type} [Inhabited γ] [Inhabited α] [Inhabited β] (g : β -> γ) (f : α -> β) (x : α) : compose g f x = g (f x)
noncomputable def below_column (e : ℤ -> ℤ -> ℤ) (col : ℤ) (v : ℤ) (row : ℤ) := e row col ≤ v
noncomputable def above_column (e : ℤ -> ℤ -> ℤ) (col : ℤ) (v : ℤ) (row : ℤ) := v < e row col
axiom fc : ℤ -> ℤ
axiom fc1 : ℤ -> ℤ
axiom fc2 : ℤ -> ℤ -> ℤ
axiom fc3 : ℤ -> ℤ -> ℤ
axiom fc4 : ℤ -> ℤ -> ℤ
axiom fc5 : ℤ -> ℤ
axiom fc6 : ℤ -> ℤ
axiom fc7 : ℤ -> ℤ -> ℤ
axiom below_column_closure : (ℤ -> ℤ -> ℤ) -> ℤ -> ℤ -> ℤ -> Bool
axiom above_column_closure : (ℤ -> ℤ -> ℤ) -> ℤ -> ℤ -> ℤ -> Bool
axiom column_closure :  {α : Type} -> [Inhabited α] -> Matrix.matrix α -> ℤ -> ℤ -> α
axiom fc8 : ℤ -> ℤ
axiom fc9 : ℤ -> ℤ
axiom fc10 : ℤ -> ℤ -> ℤ
axiom fc11 : ℤ -> ℤ -> ℤ
axiom fc12 : ℤ -> ℤ -> ℤ
axiom fc13 : ℤ -> ℤ
axiom fc14 : ℤ -> ℤ
axiom fc15 : ℤ -> ℤ -> ℤ
axiom fc'def (x : ℤ) : fc x = (0 : ℤ)
axiom fc'def1 (x : ℤ) : fc1 x = (0 : ℤ)
axiom fc'def2 (n : ℤ) (x : ℤ) : fc2 n x = n
axiom fc'def3 (n : ℤ) (x : ℤ) : fc3 n x = n
axiom fc'def4 (n : ℤ) (x : ℤ) : fc4 n x = n
axiom fc'def5 (x : ℤ) : fc5 x = (0 : ℤ)
axiom fc'def6 (x : ℤ) : fc6 x = (0 : ℤ)
axiom fc'def7 (n : ℤ) (x : ℤ) : fc7 n x = n
axiom below_column_closure_def (y : ℤ -> ℤ -> ℤ) (y1 : ℤ) (y2 : ℤ) (y3 : ℤ) : (below_column_closure y y1 y2 y3 = true) = below_column y y1 y2 y3
axiom above_column_closure_def (y : ℤ -> ℤ -> ℤ) (y1 : ℤ) (y2 : ℤ) (y3 : ℤ) : (above_column_closure y y1 y2 y3 = true) = above_column y y1 y2 y3
axiom column_closure_def {α : Type} [Inhabited α] (y : Matrix.matrix α) (y1 : ℤ) : column_closure y y1 = column y y1
axiom fc'def8 (x : ℤ) : fc8 x = (0 : ℤ)
axiom fc'def9 (x : ℤ) : fc9 x = (0 : ℤ)
axiom fc'def10 (n : ℤ) (x : ℤ) : fc10 n x = n
axiom fc'def11 (n : ℤ) (x : ℤ) : fc11 n x = n
axiom fc'def12 (n : ℤ) (x : ℤ) : fc12 n x = n
axiom fc'def13 (x : ℤ) : fc13 x = (0 : ℤ)
axiom fc'def14 (x : ℤ) : fc14 x = (0 : ℤ)
axiom fc'def15 (n : ℤ) (x : ℤ) : fc15 n x = n
theorem shear_sort'vc (m : Matrix.matrix ℤ) : let n : ℤ := Matrix.rows m; let c : ℤ := Matrix.columns m; if ¬n = (0 : ℤ) then let o1 : ℤ := n - (1 : ℤ); (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ o1) ∧ o1 * HPow.hPow (2 : ℤ) (0 : ℕ) < n ∧ n ≤ HPow.hPow (2 : ℤ) (0 : ℕ) * (o1 + (1 : ℤ))) ∧ (∀(p : ℤ) (l : ℤ), ((0 : ℤ) ≤ l ∧ (0 : ℤ) ≤ p) ∧ (¬l = (0 : ℤ) → HPow.hPow (2 : ℤ) (Int.toNat (l - (1 : ℤ))) ≤ n) ∧ p * HPow.hPow (2 : ℤ) (Int.toNat l) < n ∧ n ≤ HPow.hPow (2 : ℤ) (Int.toNat l) * (p + (1 : ℤ)) → (if ¬p = (0 : ℤ) then ¬(2 : ℤ) = (0 : ℤ) ∧ ((0 : ℤ) ≤ p ∧ Int.tdiv p (2 : ℤ) < p) ∧ ((0 : ℤ) ≤ l + (1 : ℤ) ∧ (0 : ℤ) ≤ Int.tdiv p (2 : ℤ)) ∧ (¬l + (1 : ℤ) = (0 : ℤ) → HPow.hPow (2 : ℤ) (Int.toNat (l + (1 : ℤ) - (1 : ℤ))) ≤ n) ∧ Int.tdiv p (2 : ℤ) * HPow.hPow (2 : ℤ) (Int.toNat (l + (1 : ℤ))) < n ∧ n ≤ HPow.hPow (2 : ℤ) (Int.toNat (l + (1 : ℤ))) * (Int.tdiv p (2 : ℤ) + (1 : ℤ)) else (∀(ones : ℤ -> ℤ) (zeros : ℤ -> ℤ) (m1 : Matrix.matrix ℤ), Matrix.rows m1 = Matrix.rows m ∧ Matrix.columns m1 = Matrix.columns m → (∀(v : ℤ), (0 : ℤ) ≤ zeros v ∧ zeros v ≤ ones v ∧ ones v ≤ n) ∧ (∀(v : ℤ), ones v ≤ zeros v + (1 : ℤ)) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), ((0 : ℤ) ≤ i ∧ i < zeros v) ∧ (0 : ℤ) ≤ j ∧ j < c → Matrix.elts m1 i j ≤ v) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), (ones v ≤ i ∧ i < n) ∧ (0 : ℤ) ≤ j ∧ j < c → v < Matrix.elts m1 i j) → (∀(i : ℤ) (j1 : ℤ) (j2 : ℤ) (k : ℤ), ((0 : ℤ) ≤ i ∧ i < k ∧ k < n) ∧ ((0 : ℤ) ≤ j1 ∧ j1 < c) ∧ (0 : ℤ) ≤ j2 ∧ j2 < c → Matrix.elts m1 i j1 ≤ Matrix.elts m1 k j2)) ∧ ((0 : ℤ) ≤ l + (1 : ℤ) → ((∀(v : ℤ), (0 : ℤ) ≤ fc v ∧ fc1 v ≤ fc2 n v ∧ fc3 n v ≤ n) ∧ (∀(v : ℤ), fc4 n v ≤ fc5 v + n) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), ((0 : ℤ) ≤ i ∧ i < fc6 v) ∧ (0 : ℤ) ≤ j ∧ j < c → Matrix.elts m i j ≤ v) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), (fc7 n v ≤ i ∧ i < n) ∧ (0 : ℤ) ≤ j ∧ j < c → v < Matrix.elts m i j) ∧ (0 : ℤ) < n ∧ ((n - (1 : ℤ)) * HPow.hPow (2 : ℤ) (0 : ℕ) < n ∧ n ≤ n * HPow.hPow (2 : ℤ) (0 : ℕ)) ∧ (l < (0 : ℤ) → (∀(i : ℤ) (j : ℤ) (k : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (0 : ℤ) ≤ j ∧ j ≤ k ∧ k < c → (let a : ℤ := Matrix.elts m i j; let b : ℤ := Matrix.elts m i k; if Int.tmod i (2 : ℤ) = (0 : ℤ) then a ≤ b else b ≤ a)))) ∧ (∀(ones : ℤ -> ℤ) (zeros : ℤ -> ℤ) (k : ℤ) (m1 : Matrix.matrix ℤ), Matrix.rows m1 = Matrix.rows m ∧ Matrix.columns m1 = Matrix.columns m → (∀(ind : ℤ), ((0 : ℤ) ≤ ind ∧ ind ≤ l) ∧ (∀(v : ℤ), (0 : ℤ) ≤ zeros v ∧ zeros v ≤ ones v ∧ ones v ≤ n) ∧ (∀(v : ℤ), ones v ≤ zeros v + k) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), ((0 : ℤ) ≤ i ∧ i < zeros v) ∧ (0 : ℤ) ≤ j ∧ j < c → Matrix.elts m1 i j ≤ v) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), (ones v ≤ i ∧ i < n) ∧ (0 : ℤ) ≤ j ∧ j < c → v < Matrix.elts m1 i j) ∧ (0 : ℤ) < k ∧ ((k - (1 : ℤ)) * HPow.hPow (2 : ℤ) (Int.toNat ind) < n ∧ n ≤ k * HPow.hPow (2 : ℤ) (Int.toNat ind)) ∧ (l < ind → (∀(i : ℤ) (j : ℤ) (k1 : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (0 : ℤ) ≤ j ∧ j ≤ k1 ∧ k1 < c → (let a : ℤ := Matrix.elts m1 i j; let b : ℤ := Matrix.elts m1 i k1; if Int.tmod i (2 : ℤ) = (0 : ℤ) then a ≤ b else b ≤ a))) ∧ (∀(x : ℤ), mocc x (Matrix.elts m) n c = mocc x (Matrix.elts m1) n c) → (∀(m2 : Matrix.matrix ℤ), Matrix.rows m2 = Matrix.rows m1 ∧ Matrix.columns m2 = Matrix.columns m1 → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m2 → MapPermut.permut (Matrix.elts m2 i) (Matrix.elts m1 i) (0 : ℤ) (Matrix.columns m2)) ∧ (∀(i : ℤ) (j : ℤ) (k1 : ℤ), ((0 : ℤ) ≤ i ∧ i < Matrix.rows m2) ∧ (0 : ℤ) ≤ j ∧ j ≤ k1 ∧ k1 < Matrix.columns m2 → (let a : ℤ := Matrix.elts m2 i j; let b : ℤ := Matrix.elts m2 i k1; if Int.tmod i (2 : ℤ) = (0 : ℤ) then a ≤ b else b ≤ a)) → (let e : ℤ -> ℤ -> ℤ := Matrix.elts m2; ¬(2 : ℤ) = (0 : ℤ) ∧ (let kd : ℤ := Int.tdiv (k + (1 : ℤ)) (2 : ℤ); (∀(v : ℤ), let z : ℤ := zeros v; let o2 : ℤ := ones v; ((z ≤ z ∧ z ≤ o2) ∧ (z ≤ z ∧ o2 ≤ o2) ∧ z - z = (2 : ℤ) * (z - z + o2 - o2) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < c → z ≤ NumOf.numof (below_column_closure e j v) (0 : ℤ) z ∧ n - o2 ≤ NumOf.numof (above_column_closure e j v) (0 : ℤ) z + NumOf.numof (above_column_closure e j v) o2 n)) ∧ (∀(index : ℤ) (no : ℤ) (nz : ℤ), (z ≤ index ∧ index ≤ o2) ∧ (z ≤ nz ∧ no ≤ o2) ∧ index - z = (2 : ℤ) * (nz - z + o2 - no) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < c → nz ≤ NumOf.numof (below_column_closure e j v) (0 : ℤ) index ∧ n - no ≤ NumOf.numof (above_column_closure e j v) (0 : ℤ) index + NumOf.numof (above_column_closure e j v) o2 n) → (if index + (1 : ℤ) < o2 then (∀(r1 : ℤ -> ℤ) (r2 : ℤ -> ℤ) (b : Bool), (∀(j : ℤ) (k1 : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k1 ∧ k1 < c → (if b = true then r1 j ≤ r1 k1 else r1 k1 ≤ r1 j)) ∧ (∀(j : ℤ) (k1 : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k1 ∧ k1 < c → (if b = true then r2 k1 ≤ r2 j else r2 j ≤ r2 k1)) → (if ¬b = true then (((0 : ℤ) ≤ (if b = true then (0 : ℤ) else (1 : ℤ)) ∧ (if True then (0 : ℤ) else (1 : ℤ)) < (if b = true then (0 : ℤ) else (1 : ℤ))) ∧ (∀(j : ℤ) (k1 : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k1 ∧ k1 < c → r2 j ≤ r2 k1) ∧ (∀(j : ℤ) (k1 : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k1 ∧ k1 < c → r1 k1 ≤ r1 j)) ∧ (∀(result : Bool), (result = true → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < c → r2 i ≤ v ∨ r1 i ≤ v)) ∧ (¬result = true → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < c → v < r2 i ∨ v < r1 i)) → (result = true → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < c → r1 i ≤ v ∨ r2 i ≤ v)) ∧ (¬result = true → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < c → v < r1 i ∨ v < r2 i))) else (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ c) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → r1 j ≤ v ∧ v < r2 j)) ∧ (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ c) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → r1 j ≤ v ∧ v < r2 j) → (∀(o3 : Bool), (if ¬i = c then if r1 i ≤ v then o3 = (if v < r2 i then true else false) else o3 = false else o3 = false) → (if o3 = true then ((0 : ℤ) ≤ c - i ∧ c - (i + (1 : ℤ)) < c - i) ∧ ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ c) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → r1 j ≤ v ∧ v < r2 j) else ∀(result : Bool), (if i = c then result = true else result = (if r2 i ≤ v then true else false)) → (result = true → (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < c → r1 i1 ≤ v ∨ r2 i1 ≤ v)) ∧ (¬result = true → (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < c → v < r1 i1 ∨ v < r2 i1))))))) ∧ ¬(2 : ℤ) = (0 : ℤ) ∧ (let o3 : ℤ := Int.tmod index (2 : ℤ); let o4 : ℤ -> ℤ := e (index + (1 : ℤ)); let o5 : ℤ -> ℤ := e index; ((∀(j : ℤ) (k1 : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k1 ∧ k1 < c → (if o3 = (0 : ℤ) then o5 j ≤ o5 k1 else o5 k1 ≤ o5 j)) ∧ (∀(j : ℤ) (k1 : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k1 ∧ k1 < c → (if o3 = (0 : ℤ) then o4 k1 ≤ o4 j else o4 j ≤ o4 k1))) ∧ (∀(o6 : Bool), (o6 = true → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < c → o5 i ≤ v ∨ o4 i ≤ v)) ∧ (¬o6 = true → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < c → v < o5 i ∨ v < o4 i)) → (if o6 = true then ((0 : ℤ) ≤ o2 - index ∧ o2 - (index + (2 : ℤ)) < o2 - index) ∧ (z ≤ index + (2 : ℤ) ∧ index + (2 : ℤ) ≤ o2) ∧ (z ≤ nz + (1 : ℤ) ∧ no ≤ o2) ∧ index + (2 : ℤ) - z = (2 : ℤ) * (nz + (1 : ℤ) - z + o2 - no) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < c → nz + (1 : ℤ) ≤ NumOf.numof (below_column_closure e j v) (0 : ℤ) (index + (2 : ℤ)) ∧ n - no ≤ NumOf.numof (above_column_closure e j v) (0 : ℤ) (index + (2 : ℤ)) + NumOf.numof (above_column_closure e j v) o2 n) else ((0 : ℤ) ≤ o2 - index ∧ o2 - (index + (2 : ℤ)) < o2 - index) ∧ (z ≤ index + (2 : ℤ) ∧ index + (2 : ℤ) ≤ o2) ∧ (z ≤ nz ∧ no - (1 : ℤ) ≤ o2) ∧ index + (2 : ℤ) - z = (2 : ℤ) * (nz - z + o2 - (no - (1 : ℤ))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < c → nz ≤ NumOf.numof (below_column_closure e j v) (0 : ℤ) (index + (2 : ℤ)) ∧ n - (no - (1 : ℤ)) ≤ NumOf.numof (above_column_closure e j v) (0 : ℤ) (index + (2 : ℤ)) + NumOf.numof (above_column_closure e j v) o2 n)))) else ((0 : ℤ) ≤ nz ∧ nz ≤ no ∧ no ≤ n) ∧ no ≤ nz + kd ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < c → nz ≤ NumOf.numof (below_column_closure e j v) (0 : ℤ) n ∧ n - no ≤ NumOf.numof (above_column_closure e j v) (0 : ℤ) n)))) ∧ (∀(nzo : ℤ -> ℤ × ℤ), (∀(v : ℤ), match nzo v with | (nz, no) => ((0 : ℤ) ≤ nz ∧ nz ≤ no ∧ no ≤ n) ∧ no ≤ nz + kd ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < c → nz ≤ NumOf.numof (below_column_closure e j v) (0 : ℤ) n ∧ n - no ≤ NumOf.numof (above_column_closure e j v) (0 : ℤ) n)) → (∀(v : ℤ), let o2 : ℤ × ℤ := nzo v; (match o2 with | (nz, no) => ((0 : ℤ) ≤ nz ∧ nz ≤ no ∧ no ≤ n) ∧ no ≤ nz + kd ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < c → nz ≤ NumOf.numof (below_column_closure e j v) (0 : ℤ) n ∧ n - no ≤ NumOf.numof (above_column_closure e j v) (0 : ℤ) n)) → (∀(result : ℤ), (match o2 with | (x, _) => result = x) → result = (match nzo v with | (x, _) => x))) ∧ (∀(newz : ℤ -> ℤ), (∀(v : ℤ), newz v = (match nzo v with | (x, _) => x)) → (∀(v : ℤ), let o2 : ℤ × ℤ := nzo v; (match o2 with | (nz, no) => ((0 : ℤ) ≤ nz ∧ nz ≤ no ∧ no ≤ n) ∧ no ≤ nz + kd ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < c → nz ≤ NumOf.numof (below_column_closure e j v) (0 : ℤ) n ∧ n - no ≤ NumOf.numof (above_column_closure e j v) (0 : ℤ) n)) → (∀(result : ℤ), (match o2 with | (_, y) => result = y) → result = (match nzo v with | (_, y) => y))) ∧ (∀(newo : ℤ -> ℤ), (∀(v : ℤ), newo v = (match nzo v with | (_, y) => y)) → (ind = l → (∀(v : ℤ), (0 : ℤ) ≤ zeros v ∧ zeros v ≤ ones v ∧ ones v ≤ n) ∧ (∀(v : ℤ), ones v ≤ zeros v + (1 : ℤ)) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), ((0 : ℤ) ≤ i ∧ i < zeros v) ∧ (0 : ℤ) ≤ j ∧ j < c → Matrix.elts m2 i j ≤ v) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), (ones v ≤ i ∧ i < n) ∧ (0 : ℤ) ≤ j ∧ j < c → v < Matrix.elts m2 i j)) ∧ ((ind = l → (∀(i : ℤ) (j1 : ℤ) (j2 : ℤ) (k1 : ℤ), ((0 : ℤ) ≤ i ∧ i < k1 ∧ k1 < n) ∧ ((0 : ℤ) ≤ j1 ∧ j1 < c) ∧ (0 : ℤ) ≤ j2 ∧ j2 < c → Matrix.elts m2 i j1 ≤ Matrix.elts m2 k1 j2)) → (∀(m3 : Matrix.matrix ℤ), Matrix.rows m3 = Matrix.rows m2 ∧ Matrix.columns m3 = Matrix.columns m2 → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Matrix.columns m3 → MapPermut.permut (column m3 j) (column m2 j) (0 : ℤ) (Matrix.rows m3)) ∧ (∀(i : ℤ) (j : ℤ) (k1 : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ k1 ∧ k1 < Matrix.rows m3) ∧ (0 : ℤ) ≤ j ∧ j < Matrix.columns m3 → Matrix.elts m3 i j ≤ Matrix.elts m3 k1 j) → (let cl2 : ℤ -> ℤ -> ℤ := column_closure m3; let e1 : ℤ -> ℤ -> ℤ := Matrix.elts m3; (∀(v : ℤ) (i : ℤ) (j : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ ((0 : ℤ) < NumOf.numof (below_column_closure e1 j v) (i + (1 : ℤ)) n ∧ (0 : ℤ) ≤ j ∧ j < c) ∧ v < cl2 j i → (let o2 : ℤ := i + (1 : ℤ); ((0 : ℤ) ≤ n - i ∧ n - o2 < n - i) ∧ ((0 : ℤ) ≤ o2 ∧ o2 < n) ∧ ((0 : ℤ) < NumOf.numof (below_column_closure e1 j v) (o2 + (1 : ℤ)) n ∧ (0 : ℤ) ≤ j ∧ j < c) ∧ v < cl2 j o2)) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ ((0 : ℤ) < NumOf.numof (above_column_closure e1 j v) (0 : ℤ) i ∧ (0 : ℤ) ≤ j ∧ j < c) ∧ cl2 j i ≤ v → (let o2 : ℤ := i - (1 : ℤ); ((0 : ℤ) ≤ i ∧ o2 < i) ∧ ((0 : ℤ) ≤ o2 ∧ o2 < n) ∧ ((0 : ℤ) < NumOf.numof (above_column_closure e1 j v) (0 : ℤ) o2 ∧ (0 : ℤ) ≤ j ∧ j < c) ∧ cl2 j o2 ≤ v)) ∧ (∀(v : ℤ), (0 : ℤ) ≤ newz v ∧ newz v ≤ newo v ∧ newo v ≤ n) ∧ (∀(v : ℤ), newo v ≤ newz v + kd) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), ((0 : ℤ) ≤ i ∧ i < newz v) ∧ (0 : ℤ) ≤ j ∧ j < c → Matrix.elts m3 i j ≤ v) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), (newo v ≤ i ∧ i < n) ∧ (0 : ℤ) ≤ j ∧ j < c → v < Matrix.elts m3 i j) ∧ (0 : ℤ) < kd ∧ ((kd - (1 : ℤ)) * HPow.hPow (2 : ℤ) (Int.toNat (ind + (1 : ℤ))) < n ∧ n ≤ kd * HPow.hPow (2 : ℤ) (Int.toNat (ind + (1 : ℤ)))) ∧ (l < ind + (1 : ℤ) → (∀(i : ℤ) (j : ℤ) (k1 : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (0 : ℤ) ≤ j ∧ j ≤ k1 ∧ k1 < c → (let a : ℤ := Matrix.elts m3 i j; let b : ℤ := Matrix.elts m3 i k1; if Int.tmod i (2 : ℤ) = (0 : ℤ) then a ≤ b else b ≤ a))) ∧ (∀(x : ℤ), mocc x (Matrix.elts m) n c = mocc x (Matrix.elts m3) n c))))))))))) ∧ ((∀(v : ℤ), (0 : ℤ) ≤ zeros v ∧ zeros v ≤ ones v ∧ ones v ≤ n) ∧ (∀(v : ℤ), ones v ≤ zeros v + k) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), ((0 : ℤ) ≤ i ∧ i < zeros v) ∧ (0 : ℤ) ≤ j ∧ j < c → Matrix.elts m1 i j ≤ v) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), (ones v ≤ i ∧ i < n) ∧ (0 : ℤ) ≤ j ∧ j < c → v < Matrix.elts m1 i j) ∧ (0 : ℤ) < k ∧ ((k - (1 : ℤ)) * HPow.hPow (2 : ℤ) (Int.toNat (l + (1 : ℤ))) < n ∧ n ≤ k * HPow.hPow (2 : ℤ) (Int.toNat (l + (1 : ℤ)))) ∧ (l < l + (1 : ℤ) → (∀(i : ℤ) (j : ℤ) (k1 : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (0 : ℤ) ≤ j ∧ j ≤ k1 ∧ k1 < c → (let a : ℤ := Matrix.elts m1 i j; let b : ℤ := Matrix.elts m1 i k1; if Int.tmod i (2 : ℤ) = (0 : ℤ) then a ≤ b else b ≤ a))) ∧ (∀(x : ℤ), mocc x (Matrix.elts m) n c = mocc x (Matrix.elts m1) n c) → ((∀(v : ℤ), (0 : ℤ) ≤ zeros v ∧ zeros v ≤ ones v ∧ ones v ≤ n) ∧ (∀(v : ℤ), ones v ≤ zeros v + (1 : ℤ)) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), ((0 : ℤ) ≤ i ∧ i < zeros v) ∧ (0 : ℤ) ≤ j ∧ j < c → Matrix.elts m1 i j ≤ v) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), (ones v ≤ i ∧ i < n) ∧ (0 : ℤ) ≤ j ∧ j < c → v < Matrix.elts m1 i j)) ∧ ((∀(i : ℤ) (j1 : ℤ) (j2 : ℤ) (k1 : ℤ), ((0 : ℤ) ≤ i ∧ i < k1 ∧ k1 < n) ∧ ((0 : ℤ) ≤ j1 ∧ j1 < c) ∧ (0 : ℤ) ≤ j2 ∧ j2 < c → Matrix.elts m1 i j1 ≤ Matrix.elts m1 k1 j2) → (∀(i : ℤ) (j1 : ℤ) (j2 : ℤ) (k1 : ℤ), ((0 : ℤ) ≤ i ∧ i < k1 ∧ k1 < Matrix.rows m1) ∧ ((0 : ℤ) ≤ j1 ∧ j1 < Matrix.columns m1) ∧ (0 : ℤ) ≤ j2 ∧ j2 < Matrix.columns m1 → Matrix.elts m1 i j1 ≤ Matrix.elts m1 k1 j2) ∧ (∀(i : ℤ) (j : ℤ) (k1 : ℤ), ((0 : ℤ) ≤ i ∧ i < Matrix.rows m1) ∧ (0 : ℤ) ≤ j ∧ j ≤ k1 ∧ k1 < Matrix.columns m1 → (if Int.tmod i (2 : ℤ) = (0 : ℤ) then Matrix.elts m1 i j ≤ Matrix.elts m1 i k1 else Matrix.elts m1 i k1 ≤ Matrix.elts m1 i j)) ∧ (∀(x : ℤ), mocc x (Matrix.elts m) (Matrix.rows m1) (Matrix.columns m1) = mocc x (Matrix.elts m1) (Matrix.rows m1) (Matrix.columns m1)))))) ∧ (l + (1 : ℤ) < (0 : ℤ) → ((∀(v : ℤ), (0 : ℤ) ≤ fc8 v ∧ fc9 v ≤ fc10 n v ∧ fc11 n v ≤ n) ∧ (∀(v : ℤ), fc12 n v ≤ fc13 v + (1 : ℤ)) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), ((0 : ℤ) ≤ i ∧ i < fc14 v) ∧ (0 : ℤ) ≤ j ∧ j < c → Matrix.elts m i j ≤ v) ∧ (∀(v : ℤ) (i : ℤ) (j : ℤ), (fc15 n v ≤ i ∧ i < n) ∧ (0 : ℤ) ≤ j ∧ j < c → v < Matrix.elts m i j)) ∧ ((∀(i : ℤ) (j1 : ℤ) (j2 : ℤ) (k : ℤ), ((0 : ℤ) ≤ i ∧ i < k ∧ k < n) ∧ ((0 : ℤ) ≤ j1 ∧ j1 < c) ∧ (0 : ℤ) ≤ j2 ∧ j2 < c → Matrix.elts m i j1 ≤ Matrix.elts m k j2) → (∀(i : ℤ) (j1 : ℤ) (j2 : ℤ) (k : ℤ), ((0 : ℤ) ≤ i ∧ i < k ∧ k < Matrix.rows m) ∧ ((0 : ℤ) ≤ j1 ∧ j1 < Matrix.columns m) ∧ (0 : ℤ) ≤ j2 ∧ j2 < Matrix.columns m → Matrix.elts m i j1 ≤ Matrix.elts m k j2) ∧ (∀(i : ℤ) (j : ℤ) (k : ℤ), ((0 : ℤ) ≤ i ∧ i < Matrix.rows m) ∧ (0 : ℤ) ≤ j ∧ j ≤ k ∧ k < Matrix.columns m → (if Int.tmod i (2 : ℤ) = (0 : ℤ) then Matrix.elts m i j ≤ Matrix.elts m i k else Matrix.elts m i k ≤ Matrix.elts m i j)))))) else (∀(i : ℤ) (j1 : ℤ) (j2 : ℤ) (k : ℤ), ((0 : ℤ) ≤ i ∧ i < k ∧ k < Matrix.rows m) ∧ ((0 : ℤ) ≤ j1 ∧ j1 < Matrix.columns m) ∧ (0 : ℤ) ≤ j2 ∧ j2 < Matrix.columns m → Matrix.elts m i j1 ≤ Matrix.elts m k j2) ∧ (∀(i : ℤ) (j : ℤ) (k : ℤ), ((0 : ℤ) ≤ i ∧ i < Matrix.rows m) ∧ (0 : ℤ) ≤ j ∧ j ≤ k ∧ k < Matrix.columns m → (if Int.tmod i (2 : ℤ) = (0 : ℤ) then Matrix.elts m i j ≤ Matrix.elts m i k else Matrix.elts m i k ≤ Matrix.elts m i j))
  := sorry
end verifythis_2021_shearsort_ShearSort_shear_sortqtvc
