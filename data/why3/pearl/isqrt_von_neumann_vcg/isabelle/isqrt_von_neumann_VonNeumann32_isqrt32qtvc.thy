theory isqrt_von_neumann_VonNeumann32_isqrt32qtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.WellFounded_WellFounded" "Why3STD.Ref_Ref"
begin
definition sqr :: "32 word \<Rightarrow> 32 word"
  where "sqr x = x * x" for x
definition is_pow2 :: "32 word \<Rightarrow> 32 word \<Rightarrow> _"
  where "is_pow2 x n \<longleftrightarrow> x AND ((1 :: 32 word) << unat n) - (1 :: 32 word) = (0 :: 32 word)" for x n
theorem isqrt32'vc:
  fixes x :: "32 word"
  shows "(16 :: 32 word) \<le> (16 :: 32 word)"
  and "(32768 :: 32 word) = (if (16 :: 32 word) = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat ((16 :: 32 word) - (1 :: 32 word)))"
  and "(1073741824 :: 32 word) = sqr (32768 :: 32 word)"
  and "is_pow2 (0 :: 32 word) (16 :: 32 word)"
  and "(0 :: 32 word) < (65536 :: 32 word)"
  and "(0 :: 32 word) = (0 :: 32 word) * ((1 :: 32 word) << unat (16 :: 32 word))"
  and "x \<le> x"
  and "x - x = sqr (0 :: 32 word)"
  and "(0 :: 32 word) + ((1 :: 32 word) << unat (16 :: 32 word)) \<le> (65536 :: 32 word)"
  and "x \<le> sqr ((0 :: 32 word) + ((1 :: 32 word) << unat (16 :: 32 word))) - (1 :: 32 word)"
  and "\<forall>(res_g :: 32 word) (m :: 32 word) (num :: 32 word). m \<le> (16 :: 32 word) \<and> is_pow2 res_g m \<and> res_g < (65536 :: 32 word) \<and> num \<le> x \<and> x - num = sqr res_g \<and> res_g + ((1 :: 32 word) << unat m) \<le> (65536 :: 32 word) \<and> x \<le> sqr (res_g + ((1 :: 32 word) << unat m)) - (1 :: 32 word) \<longrightarrow> (if \<not>sqr (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) = (0 :: 32 word) then let b :: 32 word = res_g * ((1 :: 32 word) << unat m) OR sqr (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) in if num \<ge> b then uint (sqr (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) >> unat (2 :: 32 word)) < uint (sqr (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word)))) \<and> m - (1 :: 32 word) \<le> (16 :: 32 word) \<and> (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) >> unat (1 :: 32 word) = (if m - (1 :: 32 word) = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word) - (1 :: 32 word))) \<and> sqr (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) >> unat (2 :: 32 word) = sqr ((if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) >> unat (1 :: 32 word)) \<and> is_pow2 (res_g + (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word)))) (m - (1 :: 32 word)) \<and> res_g + (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) < (65536 :: 32 word) \<and> (res_g * ((1 :: 32 word) << unat m) >> unat (1 :: 32 word)) OR sqr (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) = (res_g + (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word)))) * ((1 :: 32 word) << unat (m - (1 :: 32 word))) \<and> num - b \<le> x \<and> x - (num - b) = sqr (res_g + (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word)))) \<and> res_g + (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) + ((1 :: 32 word) << unat (m - (1 :: 32 word))) \<le> (65536 :: 32 word) \<and> x \<le> sqr (res_g + (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) + ((1 :: 32 word) << unat (m - (1 :: 32 word)))) - (1 :: 32 word) else uint (sqr (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) >> unat (2 :: 32 word)) < uint (sqr (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word)))) \<and> m - (1 :: 32 word) \<le> (16 :: 32 word) \<and> (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) >> unat (1 :: 32 word) = (if m - (1 :: 32 word) = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word) - (1 :: 32 word))) \<and> sqr (if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) >> unat (2 :: 32 word) = sqr ((if m = (0 :: 32 word) then 0 :: 32 word else (1 :: 32 word) << unat (m - (1 :: 32 word))) >> unat (1 :: 32 word)) \<and> is_pow2 res_g (m - (1 :: 32 word)) \<and> res_g < (65536 :: 32 word) \<and> res_g * ((1 :: 32 word) << unat m) >> unat (1 :: 32 word) = res_g * ((1 :: 32 word) << unat (m - (1 :: 32 word))) \<and> num \<le> x \<and> x - num = sqr res_g \<and> res_g + ((1 :: 32 word) << unat (m - (1 :: 32 word))) \<le> (65536 :: 32 word) \<and> x \<le> sqr (res_g + ((1 :: 32 word) << unat (m - (1 :: 32 word)))) - (1 :: 32 word) else sqr (res_g * ((1 :: 32 word) << unat m)) \<le> x \<and> x \<le> sqr (res_g * ((1 :: 32 word) << unat m) + (1 :: 32 word)) - (1 :: 32 word))"
  sorry
end
