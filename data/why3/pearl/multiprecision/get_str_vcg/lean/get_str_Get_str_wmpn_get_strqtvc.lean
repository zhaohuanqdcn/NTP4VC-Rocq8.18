import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import Why3.mach.c.UChar
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.powm.Powm
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.valuation.Valuation
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.sub_1.Sub_1
import pearl.multiprecision.lib.lean.stringlemmas.String_lemmas
import pearl.multiprecision.lib.lean.base_info.BaseInfo
open Classical
open Lean4Why3
namespace get_str_Get_str_wmpn_get_strqtvc
theorem wmpn_get_str'vc (sz : BitVec 32) (un : BitVec 32) (sp : C.ptr (BitVec 8)) (up : C.ptr (BitVec 64)) (base : BitVec 32) (fact0 : (0 : ℤ) < BitVec.toInt sz) (fact1 : (0 : ℤ) < BitVec.toInt un) (fact2 : C.valid sp (BitVec.toInt sz)) (fact3 : C.valid up (BitVec.toInt un)) (fact4 : C.writable sp = true) (fact5 : C.writable up = true) (fact6 : HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt un)) ≤ HPow.hPow (BitVec.toInt base) (Int.toNat (BitVec.toInt sz - (1 : ℤ)))) (fact7 : (0 : ℤ) < BitVec.toUInt (C.pelts up (C.offset up + BitVec.toInt un - (1 : ℤ)))) (fact8 : (2 : ℤ) ≤ BitVec.toInt base) (fact9 : BitVec.toInt base ≤ (256 : ℤ)) (fact10 : (64 : ℤ) * BitVec.toInt un + (7 : ℤ) ≤ (2147483647 : ℤ)) : (0 : ℤ) ≤ BitVec.toInt base ∧ (∀(o1 : BitVec 64), BitVec.toUInt o1 = BitVec.toInt base → ((2 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (256 : ℤ)) ∧ (∀(bits : BitVec 32), ((0 : ℤ) ≤ BitVec.toUInt bits ∧ BitVec.toUInt bits ≤ (8 : ℤ)) ∧ (¬BitVec.toUInt bits = (0 : ℤ) → HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits)) = BitVec.toUInt o1) ∧ (BitVec.toUInt bits = (0 : ℤ) → (∀(n : ℤ), (0 : ℤ) ≤ n → ¬HPow.hPow (2 : ℤ) (Int.toNat n) = BitVec.toUInt o1)) → (BitVec.toUInt bits = (0 : ℤ) → bits = (0 : BitVec 32)) → (if ¬bits = (0 : BitVec 32) then int'32_in_bounds ((64 : ℤ) * BitVec.toInt un) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = (64 : ℤ) * BitVec.toInt un → ((1 : ℤ) ≤ BitVec.toInt un ∧ C.valid up (BitVec.toInt un) ∧ ((1 : ℤ) ≤ BitVec.toUInt bits ∧ BitVec.toUInt bits ≤ (8 : ℤ)) ∧ C.valid sp ((BitVec.toInt o2 + BitVec.toUInt bits - (1 : ℤ)) / BitVec.toUInt bits) ∧ (0 : ℤ) ≤ BitVec.toInt o2 ∧ Lemmas.value up (BitVec.toInt un) < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt o2)) ∧ (0 : ℤ) < BitVec.toUInt (C.pelts up (C.offset up + BitVec.toInt un - (1 : ℤ))) ∧ (64 : ℤ) * BitVec.toInt un + (7 : ℤ) ≤ (2147483647 : ℤ) ∧ C.writable sp = true) ∧ (∀(sp1 : C.ptr (BitVec 8)), List.length (C.data sp1) = List.length (C.data sp) ∧ C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.max sp1 = C.max sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → (∀(result : BitVec 32), String_lemmas.in_base (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) (C.pelts sp1) (C.offset sp1) (C.offset sp1 + BitVec.toUInt result) ∧ String_lemmas.svalue (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) sp1 (BitVec.toUInt result) = Lemmas.value up (BitVec.toInt un) ∧ ((0 : ℤ) < BitVec.toUInt result ∧ BitVec.toUInt result ≤ (BitVec.toInt o2 + BitVec.toUInt bits - (1 : ℤ)) / BitVec.toUInt bits) ∧ (0 : ℤ) < BitVec.toInt (C.pelts sp1 (C.offset sp1)) ∧ (∀(j : ℤ), j < C.offset sp1 ∨ C.offset sp1 + (BitVec.toInt o2 + BitVec.toUInt bits - (1 : ℤ)) / BitVec.toUInt bits ≤ j → C.pelts sp1 j = C.pelts sp j) → String_lemmas.in_base (BitVec.toInt base) (C.pelts sp1) (C.offset sp1) (C.offset sp1 + BitVec.toUInt result) ∧ String_lemmas.svalue (BitVec.toInt base) sp1 (BitVec.toUInt result) = Lemmas.value up (BitVec.toInt un) ∧ ((0 : ℤ) < BitVec.toUInt result ∧ BitVec.toUInt result < BitVec.toInt sz) ∧ (0 : ℤ) < BitVec.toInt (C.pelts sp1 (C.offset sp1))))) else (0 : ℤ) ≤ BitVec.toInt base ∧ (∀(o2 : BitVec 64), BitVec.toUInt o2 = BitVec.toInt base → ((2 : ℤ) ≤ BitVec.toUInt o2 ∧ BitVec.toUInt o2 ≤ (256 : ℤ)) ∧ (∀(info : BaseInfo.wmpn_base_info), BaseInfo.b info = BitVec.toUInt o2 → (C.valid up (BitVec.toInt un) ∧ (1 : ℤ) ≤ BitVec.toInt un ∧ BaseInfo.b info = BitVec.toInt base ∧ C.writable up = true ∧ C.writable sp = true ∧ (0 : ℤ) < BitVec.toUInt (C.pelts up (C.offset up + BitVec.toInt un - (1 : ℤ))) ∧ (0 : ℤ) < BitVec.toInt sz ∧ C.valid sp (BitVec.toInt sz) ∧ Lemmas.value up (BitVec.toInt un) < HPow.hPow (BitVec.toInt base) (Int.toNat (BitVec.toInt sz - (1 : ℤ)))) ∧ (∀(sp1 : C.ptr (BitVec 8)), List.length (C.data sp1) = List.length (C.data sp) ∧ C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.max sp1 = C.max sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → (∀(result : BitVec 32), ((0 : ℤ) ≤ BitVec.toUInt result ∧ BitVec.toUInt result < BitVec.toInt sz) ∧ String_lemmas.svalue (BitVec.toInt base) sp1 (BitVec.toUInt result) = Lemmas.value up (BitVec.toInt un) ∧ String_lemmas.in_base (BitVec.toInt base) (C.pelts sp1) (C.offset sp1) (C.offset sp1 + BitVec.toUInt result) ∧ (0 : ℤ) < BitVec.toInt (C.pelts sp1 (C.offset sp1)) ∧ (∀(j : ℤ), j < C.offset sp1 ∨ C.offset sp1 + BitVec.toInt sz ≤ j → C.pelts sp1 j = C.pelts sp j) → String_lemmas.in_base (BitVec.toInt base) (C.pelts sp1) (C.offset sp1) (C.offset sp1 + BitVec.toUInt result) ∧ String_lemmas.svalue (BitVec.toInt base) sp1 (BitVec.toUInt result) = Lemmas.value up (BitVec.toInt un) ∧ ((0 : ℤ) < BitVec.toUInt result ∧ BitVec.toUInt result < BitVec.toInt sz) ∧ (0 : ℤ) < BitVec.toInt (C.pelts sp1 (C.offset sp1)))))))))
  := sorry
end get_str_Get_str_wmpn_get_strqtvc
