import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
open Classical
open Lean4Why3
namespace binary_sort_BinarySort_binary_sortqtvc
theorem binary_sort'vc (a : List ℤ) : let o1 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((1 : ℤ) ≤ o1 + (1 : ℤ) → ((∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ j ∧ j < (1 : ℤ) → a[Int.toNat i]! ≤ a[Int.toNat j]!) ∧ List.permut_sub' a a (0 : ℕ) (List.length a)) ∧ (∀(a1 : List ℤ), List.length a1 = List.length a → (∀(k : ℤ), ((1 : ℤ) ≤ k ∧ k ≤ o1) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ j ∧ j < k → a1[Int.toNat i]! ≤ a1[Int.toNat j]!) ∧ List.permut_sub' a a1 (0 : ℕ) (List.length a1) → ((0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length a1)) ∧ (let v : ℤ := a1[Int.toNat k]!; (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ k ∧ k ≤ k) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (0 : ℤ) → a1[Int.toNat i]! ≤ v) ∧ (∀(i : ℤ), k ≤ i ∧ i < k → v < a1[Int.toNat i]!)) ∧ (∀(right1 : ℤ) (left1 : ℤ), ((0 : ℤ) ≤ left1 ∧ left1 ≤ right1 ∧ right1 ≤ k) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < left1 → a1[Int.toNat i]! ≤ v) ∧ (∀(i : ℤ), right1 ≤ i ∧ i < k → v < a1[Int.toNat i]!) → (if left1 < right1 then ¬(2 : ℤ) = (0 : ℤ) ∧ (let mid : ℤ := left1 + Int.tdiv (right1 - left1) (2 : ℤ); ((0 : ℤ) ≤ mid ∧ mid < Int.ofNat (List.length a1)) ∧ (if v < a1[Int.toNat mid]! then ((0 : ℤ) ≤ right1 - left1 ∧ mid - left1 < right1 - left1) ∧ ((0 : ℤ) ≤ left1 ∧ left1 ≤ mid ∧ mid ≤ k) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < left1 → a1[Int.toNat i]! ≤ v) ∧ (∀(i : ℤ), mid ≤ i ∧ i < k → v < a1[Int.toNat i]!) else ((0 : ℤ) ≤ right1 - left1 ∧ right1 - (mid + (1 : ℤ)) < right1 - left1) ∧ ((0 : ℤ) ≤ mid + (1 : ℤ) ∧ mid + (1 : ℤ) ≤ right1 ∧ right1 ≤ k) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < mid + (1 : ℤ) → a1[Int.toNat i]! ≤ v) ∧ (∀(i : ℤ), right1 ≤ i ∧ i < k → v < a1[Int.toNat i]!))) else let o2 : ℤ := k - left1; let o3 : ℤ := left1 + (1 : ℤ); (((0 : ℤ) ≤ left1 ∧ (0 : ℤ) ≤ o2 ∧ left1 + o2 ≤ Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ o3 ∧ o3 + o2 ≤ Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o3 ∨ o3 + o2 ≤ i ∧ i < Int.ofNat (List.length a2) → a2[Int.toNat i]! = a1[Int.toNat i]!) ∧ (∀(i : ℤ), o3 ≤ i ∧ i < o3 + o2 → a2[Int.toNat i]! = a1[Int.toNat (left1 + i - o3)]!) → ((0 : ℤ) ≤ left1 ∧ left1 < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat left1) v) = List.length a2 → getElem! (List.set a2 (Int.toNat left1) v) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) left1 v → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ j ∧ j < k + (1 : ℤ) → (List.set a2 (Int.toNat left1) v)[Int.toNat i]! ≤ (List.set a2 (Int.toNat left1) v)[Int.toNat j]!) ∧ List.permut_sub' a (List.set a2 (Int.toNat left1) v) (0 : ℕ) (List.length (List.set a2 (Int.toNat left1) v)))))))) ∧ ((∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ j ∧ j < o1 + (1 : ℤ) → a1[Int.toNat i]! ≤ a1[Int.toNat j]!) ∧ List.permut_sub' a a1 (0 : ℕ) (List.length a1) → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ j ∧ j < Int.ofNat (List.length a1) → a1[Int.toNat i]! ≤ a1[Int.toNat j]!) ∧ List.permut_sub' a a1 (0 : ℕ) (List.length a1)))) ∧ (o1 + (1 : ℤ) < (1 : ℤ) → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ j ∧ j < Int.ofNat (List.length a) → a[Int.toNat i]! ≤ a[Int.toNat j]!) ∧ List.permut_sub' a a (0 : ℕ) (List.length a))
  := sorry
end binary_sort_BinarySort_binary_sortqtvc
