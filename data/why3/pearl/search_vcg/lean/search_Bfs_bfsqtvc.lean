import Why3.Base
import Why3.why3.Ref.Ref
import pearl.search_vcg.lean.search.Path
open Classical
open Lean4Why3
namespace search_Bfs_bfsqtvc
theorem bfs'vc : let o1 : List Path.state := ([] : List Path.state); let o2 : Path.state := Path.start; let o3 : List Path.state := List.cons o2 o1; Int.ofNat (List.length o3) = (1 : ℤ) + Int.ofNat (List.length o1) ∧ o3[(0 : ℕ)]! = o2 ∧ (∀(i : ℤ), (0 : ℤ) < i ∧ i ≤ Int.ofNat (List.length o1) → o3[Int.toNat i]! = o1[Int.toNat (i - (1 : ℤ))]!) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o3) → Path.path Path.start (o3[Int.toNat i]!) (0 : ℤ)) ∧ (∀(t : Path.state), Path.path Path.start t (0 : ℤ) → t ∈ o3) ∧ (∀(t : Path.state) (n : ℤ), Path.path Path.start t n → Path.success t → (0 : ℤ) ≤ n)) ∧ (∀(p : ℤ) (cur : List Path.state), (0 : ℤ) ≤ p ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length cur) → Path.path Path.start (cur[Int.toNat i]!) p) ∧ (∀(t : Path.state), Path.path Path.start t p → t ∈ cur) ∧ (∀(t : Path.state) (n : ℤ), Path.path Path.start t n → Path.success t → p ≤ n) → (if (0 : ℤ) < Int.ofNat (List.length cur) then let o4 : ℤ := Int.ofNat (List.length cur) - (1 : ℤ); ((0 : ℤ) ≤ o4 + (1 : ℤ) → ((∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < Int.ofNat (List.length ([] : List Path.state)) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < (0 : ℤ)) ∧ Path.move (cur[Int.toNat j]!) (([] : List Path.state)[Int.toNat l]!))) ∧ (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length (Path.moves (cur[Int.toNat j]!))) → (Path.moves (cur[Int.toNat j]!))[Int.toNat k]! ∈ ([] : List Path.state)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → ¬Path.success (cur[Int.toNat j]!))) ∧ (∀(nxt : List Path.state), (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o4) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < Int.ofNat (List.length nxt) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < i) ∧ Path.move (cur[Int.toNat j]!) (nxt[Int.toNat l]!))) ∧ (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j < i → (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length (Path.moves (cur[Int.toNat j]!))) → (Path.moves (cur[Int.toNat j]!))[Int.toNat k]! ∈ nxt) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → ¬Path.success (cur[Int.toNat j]!)) → (let s : Path.state := cur[Int.toNat i]!; if Path.success s then Path.path Path.start s p else let o5 : List Path.state := Path.moves s; let o6 : List Path.state := o5 ++ nxt; Int.ofNat (List.length o6) = Int.ofNat (List.length o5) + Int.ofNat (List.length nxt) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length o5) → o6[Int.toNat i1]! = o5[Int.toNat i1]!) ∧ (∀(i1 : ℤ), Int.ofNat (List.length o5) ≤ i1 ∧ i1 < Int.ofNat (List.length o6) → o6[Int.toNat i1]! = nxt[Int.toNat (i1 - Int.ofNat (List.length o5))]!) → (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < Int.ofNat (List.length o6) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < i + (1 : ℤ)) ∧ Path.move (cur[Int.toNat j]!) (o6[Int.toNat l]!))) ∧ (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length (Path.moves (cur[Int.toNat j]!))) → (Path.moves (cur[Int.toNat j]!))[Int.toNat k]! ∈ o6) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → ¬Path.success (cur[Int.toNat j]!)))) ∧ ((∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < Int.ofNat (List.length nxt) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < o4 + (1 : ℤ)) ∧ Path.move (cur[Int.toNat j]!) (nxt[Int.toNat l]!))) ∧ (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j < o4 + (1 : ℤ) → (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length (Path.moves (cur[Int.toNat j]!))) → (Path.moves (cur[Int.toNat j]!))[Int.toNat k]! ∈ nxt) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < o4 + (1 : ℤ) → ¬Path.success (cur[Int.toNat j]!)) → (0 : ℤ) ≤ p + (1 : ℤ) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length nxt) → Path.path Path.start (nxt[Int.toNat i]!) (p + (1 : ℤ))) ∧ (∀(t : Path.state), Path.path Path.start t (p + (1 : ℤ)) → t ∈ nxt) ∧ (∀(t : Path.state) (n : ℤ), Path.path Path.start t n → Path.success t → p + (1 : ℤ) ≤ n)))) ∧ (o4 + (1 : ℤ) < (0 : ℤ) → (0 : ℤ) ≤ p + (1 : ℤ) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length ([] : List Path.state)) → Path.path Path.start (([] : List Path.state)[Int.toNat i]!) (p + (1 : ℤ))) ∧ (∀(t : Path.state), Path.path Path.start t (p + (1 : ℤ)) → t ∈ ([] : List Path.state)) ∧ (∀(t : Path.state) (n : ℤ), Path.path Path.start t n → Path.success t → p + (1 : ℤ) ≤ n)) else ∀(t : Path.state) (n : ℤ), Path.success t → ¬Path.path Path.start t n))
  := sorry
end search_Bfs_bfsqtvc
