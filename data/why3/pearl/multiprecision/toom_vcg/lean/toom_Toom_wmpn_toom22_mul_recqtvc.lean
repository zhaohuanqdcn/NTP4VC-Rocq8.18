import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.c.C
import Why3.mach.int.Unsigned
import pearl.multiprecision.lib.lean.valuation.Valuation
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub_1.Sub_1
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
open Classical
open Lean4Why3
namespace toom_Toom_wmpn_toom22_mul_recqtvc
theorem wmpn_toom22_mul_rec'vc (x : C.ptr (BitVec 64)) (sx : BitVec 32) (y : C.ptr (BitVec 64)) (sy : BitVec 32) (r : C.ptr (BitVec 64)) (scratch : C.ptr (BitVec 64)) (k : ℤ) (fact0 : C.valid x (BitVec.toInt sx)) (fact1 : C.valid y (BitVec.toInt sy)) (fact2 : C.valid r (BitVec.toInt sx + BitVec.toInt sy)) (fact3 : C.writable r = true) (fact4 : C.writable scratch = true) (fact5 : (0 : ℤ) < BitVec.toInt sy) (fact6 : BitVec.toInt sy ≤ BitVec.toInt sx) (fact7 : BitVec.toInt sx ≤ BitVec.toInt sy + BitVec.toInt sy) (fact8 : (8 : ℤ) * BitVec.toInt sx < (2147483647 : ℤ)) (fact9 : (0 : ℤ) ≤ k) (fact10 : k ≤ (64 : ℤ)) (fact11 : BitVec.toInt sx ≤ BitVec.toInt (29 : BitVec 32) * HPow.hPow (2 : ℤ) (Int.toNat k)) (fact12 : C.valid scratch ((2 : ℤ) * (BitVec.toInt sx + k))) : if BitVec.toInt sy ≤ BitVec.toInt (29 : BitVec 32) then (((0 : ℤ) < BitVec.toInt sy ∧ BitVec.toInt sy ≤ BitVec.toInt sx) ∧ C.valid x (BitVec.toInt sx) ∧ C.valid y (BitVec.toInt sy) ∧ C.valid r (BitVec.toInt sy + BitVec.toInt sx) ∧ C.writable r = true) ∧ (∀(r1 : C.ptr (BitVec 64)), List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → Lemmas.value r1 (BitVec.toInt sy + BitVec.toInt sx) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + (BitVec.toInt sy + BitVec.toInt sx) ≤ j → C.pelts r1 j = C.pelts r j) → Lemmas.value r1 (BitVec.toInt sx + BitVec.toInt sy) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), C.min r1 ≤ j ∧ j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sx + BitVec.toInt sy ≤ j ∧ j < C.max r1 → C.pelts r1 j = C.pelts r j) ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.plength r1 = C.plength r) else int'32_in_bounds ((5 : ℤ) * BitVec.toInt sy) ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = (5 : ℤ) * BitVec.toInt sy → int'32_in_bounds ((4 : ℤ) * BitVec.toInt sx) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = (4 : ℤ) * BitVec.toInt sx → (if BitVec.toInt o2 < BitVec.toInt o1 then (((0 : ℤ) ≤ k + k + (1 : ℤ) ∧ k + k < k + k + (1 : ℤ)) ∧ C.valid x (BitVec.toInt sx) ∧ C.valid y (BitVec.toInt sy) ∧ C.valid r (BitVec.toInt sx + BitVec.toInt sy) ∧ BitVec.toInt (29 : BitVec 32) < BitVec.toInt sy ∧ ((0 : ℤ) < k ∧ k ≤ (64 : ℤ)) ∧ BitVec.toInt sx ≤ BitVec.toInt (29 : BitVec 32) * HPow.hPow (2 : ℤ) (Int.toNat k) ∧ C.valid scratch ((2 : ℤ) * (BitVec.toInt sx + k)) ∧ (C.writable r = true ∧ C.writable scratch = true) ∧ (8 : ℤ) * BitVec.toInt sx < (2147483647 : ℤ) ∧ ((2 : ℤ) < BitVec.toInt sy ∧ BitVec.toInt sy ≤ BitVec.toInt sx ∧ BitVec.toInt sx < BitVec.toInt sy + BitVec.toInt sy - (1 : ℤ)) ∧ (4 : ℤ) * BitVec.toInt sx < (5 : ℤ) * BitVec.toInt sy) ∧ (∀(scratch1 : C.ptr (BitVec 64)) (r1 : C.ptr (BitVec 64)), C.offset scratch1 = C.offset scratch ∧ C.writable scratch1 = C.writable scratch ∧ C.zone1 scratch1 = C.zone1 scratch → C.offset r1 = C.offset r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.plength r1 = C.plength r ∧ C.min scratch1 = C.min scratch ∧ C.max scratch1 = C.max scratch ∧ C.plength scratch1 = C.plength scratch ∧ Lemmas.value r1 (BitVec.toInt sx + BitVec.toInt sy) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), C.min r1 ≤ j ∧ j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sx + BitVec.toInt sy ≤ j ∧ j < C.max r1 → C.pelts r1 j = C.pelts r j) ∧ (∀(j : ℤ), C.min scratch1 ≤ j ∧ j < C.offset scratch1 → C.pelts scratch1 j = C.pelts scratch j) → Lemmas.value r1 (BitVec.toInt sx + BitVec.toInt sy) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), C.min r1 ≤ j ∧ j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sx + BitVec.toInt sy ≤ j ∧ j < C.max r1 → C.pelts r1 j = C.pelts r j) ∧ (∀(j : ℤ), C.min scratch1 ≤ j ∧ j < C.offset scratch1 → C.pelts scratch1 j = C.pelts scratch j) ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.plength r1 = C.plength r ∧ C.min scratch1 = C.min scratch ∧ C.max scratch1 = C.max scratch ∧ C.plength scratch1 = C.plength scratch) else (((0 : ℤ) ≤ k + k + (1 : ℤ) ∧ k + k < k + k + (1 : ℤ)) ∧ C.valid x (BitVec.toInt sx) ∧ C.valid y (BitVec.toInt sy) ∧ C.valid r (BitVec.toInt sx + BitVec.toInt sy) ∧ (C.writable r = true ∧ C.writable scratch = true) ∧ BitVec.toInt (29 : BitVec 32) < BitVec.toInt sy ∧ ((0 : ℤ) < k ∧ k ≤ (64 : ℤ)) ∧ BitVec.toInt sx ≤ BitVec.toInt (29 : BitVec 32) * HPow.hPow (2 : ℤ) (Int.toNat k) ∧ C.valid scratch ((2 : ℤ) * (BitVec.toInt sx + k)) ∧ (8 : ℤ) * BitVec.toInt sx < (2147483647 : ℤ) ∧ ((4 : ℤ) < BitVec.toInt sy + (2 : ℤ) ∧ BitVec.toInt sy + (2 : ℤ) ≤ BitVec.toInt sx) ∧ BitVec.toInt sx + (6 : ℤ) ≤ (3 : ℤ) * BitVec.toInt sy) ∧ (∀(scratch1 : C.ptr (BitVec 64)) (r1 : C.ptr (BitVec 64)), C.offset scratch1 = C.offset scratch ∧ C.writable scratch1 = C.writable scratch ∧ C.zone1 scratch1 = C.zone1 scratch → C.offset r1 = C.offset r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.plength r1 = C.plength r ∧ C.min scratch1 = C.min scratch ∧ C.max scratch1 = C.max scratch ∧ C.plength scratch1 = C.plength scratch ∧ Lemmas.value r1 (BitVec.toInt sx + BitVec.toInt sy) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), C.min r1 ≤ j ∧ j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sx + BitVec.toInt sy ≤ j ∧ j < C.max r1 → C.pelts r1 j = C.pelts r j) ∧ (∀(j : ℤ), C.min scratch1 ≤ j ∧ j < C.offset scratch1 → C.pelts scratch1 j = C.pelts scratch j) → Lemmas.value r1 (BitVec.toInt sx + BitVec.toInt sy) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), C.min r1 ≤ j ∧ j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sx + BitVec.toInt sy ≤ j ∧ j < C.max r1 → C.pelts r1 j = C.pelts r j) ∧ (∀(j : ℤ), C.min scratch1 ≤ j ∧ j < C.offset scratch1 → C.pelts scratch1 j = C.pelts scratch j) ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.plength r1 = C.plength r ∧ C.min scratch1 = C.min scratch ∧ C.max scratch1 = C.max scratch ∧ C.plength scratch1 = C.plength scratch))))
  := sorry
end toom_Toom_wmpn_toom22_mul_recqtvc
