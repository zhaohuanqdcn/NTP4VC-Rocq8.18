import Why3.Base
import pearl.prover.lib.lean.Firstorder_term_impl.Types
import pearl.prover.lib.lean.Nat.Nat
import pearl.prover.lib.lean.Functions.Config
import pearl.prover.lib.lean.Functions.Func
import pearl.prover.lib.lean.OptionFuncs.Funcs
import pearl.prover.lib.lean.Sum.Sum
import pearl.prover.lib.lean.Firstorder_symbol_spec.Spec
import pearl.prover.lib.lean.Firstorder_symbol_impl.Types
import pearl.prover.lib.lean.Firstorder_symbol_impl.Logic
import pearl.prover.lib.lean.Firstorder_symbol_impl.Impl
import pearl.prover.lib.lean.Firstorder_term_spec.Spec
import pearl.prover.lib.lean.Firstorder_term_impl.Logic
open Classical
open Lean4Why3
namespace Firstorder_term_impl_Impl_bind_var_symbol_in_fo_term_listqtvc
theorem bind_var_symbol_in_fo_term_list'vc {ty'b0 : Type} {ty'b3 : Type} [Inhabited ty'b0] [Inhabited ty'b3] (t : Types.nl_fo_term_list ℤ ℤ) (i : ℤ) (bnd3 : ℤ -> Spec.fo_term ty'b0 ty'b3) (fr3 : ℤ -> Spec.fo_term ty'b0 ty'b3) (bnd0 : ℤ -> Spec.symbol ty'b0) (fr0 : ℤ -> Spec.symbol ty'b0) (x : ℤ) (fact0 : Logic.correct_indexes_fo_term_list t) (fact1 : Logic.bound_depth_of_symbol_in_fo_term_list t ≤ i) : (match t with | Types.nl_fo_term_list.NL_FONil => True | Types.nl_fo_term_list.NL_FOCons v0 v1 => (let o1 : ℤ -> Spec.fo_term ty'b0 ty'b3 := Spec.rename_subst_fo_term bnd3 Func.identity Func.identity; let o2 : ℤ -> Spec.fo_term ty'b0 ty'b3 := Spec.rename_subst_fo_term fr3 Func.identity Func.identity; let o3 : ℤ -> Spec.symbol ty'b0 := Spec.rename_subst_symbol bnd0 Func.identity; let o4 : ℤ -> Spec.symbol ty'b0 := Spec.rename_subst_symbol fr0 Func.identity; let o5 : ℤ := i + (0 : ℤ); (((0 : ℤ) ≤ Logic.nlsize_fo_term_list t ∧ Logic.nlsize_fo_term_list v1 < Logic.nlsize_fo_term_list t) ∧ Logic.correct_indexes_fo_term_list v1 ∧ Logic.bound_depth_of_symbol_in_fo_term_list v1 ≤ o5) ∧ (∀(o6 : Types.nl_fo_term_list ℤ ℤ), Logic.bound_depth_of_symbol_in_fo_term_list o6 ≤ o5 + (1 : ℤ) ∧ Logic.correct_indexes_fo_term_list o6 ∧ Logic.bound_depth_of_fo_term_in_fo_term_list v1 = Logic.bound_depth_of_fo_term_in_fo_term_list o6 ∧ Logic.nlmodel_fo_term_list o6 o4 o3 o2 o1 = Logic.nlmodel_fo_term_list v1 (Func.update o4 x (o3 o5)) o3 o2 o1 → ((0 : ℤ) ≤ Logic.nlsize_fo_term_list t ∧ Logic.nlsize_fo_term v0 < Logic.nlsize_fo_term_list t) ∧ Logic.correct_indexes_fo_term v0 ∧ Logic.bound_depth_of_symbol_in_fo_term v0 ≤ i + (0 : ℤ)))) ∧ (∀(result : Types.nl_fo_term_list ℤ ℤ), (match t with | Types.nl_fo_term_list.NL_FONil => result = Types.nl_fo_term_list.NL_FONil | Types.nl_fo_term_list.NL_FOCons v0 v1 => (let o1 : ℤ -> Spec.fo_term ty'b0 ty'b3 := Spec.rename_subst_fo_term bnd3 Func.identity Func.identity; let o2 : ℤ -> Spec.fo_term ty'b0 ty'b3 := Spec.rename_subst_fo_term fr3 Func.identity Func.identity; let o3 : ℤ -> Spec.symbol ty'b0 := Spec.rename_subst_symbol bnd0 Func.identity; let o4 : ℤ -> Spec.symbol ty'b0 := Spec.rename_subst_symbol fr0 Func.identity; let o5 : ℤ := i + (0 : ℤ); ∃(o6 : Types.nl_fo_term_list ℤ ℤ), (Logic.bound_depth_of_symbol_in_fo_term_list o6 ≤ o5 + (1 : ℤ) ∧ Logic.correct_indexes_fo_term_list o6 ∧ Logic.bound_depth_of_fo_term_in_fo_term_list v1 = Logic.bound_depth_of_fo_term_in_fo_term_list o6 ∧ Logic.nlmodel_fo_term_list o6 o4 o3 o2 o1 = Logic.nlmodel_fo_term_list v1 (Func.update o4 x (o3 o5)) o3 o2 o1) ∧ (let o7 : ℤ -> Spec.fo_term ty'b0 ty'b3 := Spec.rename_subst_fo_term bnd3 Func.identity Func.identity; let o8 : ℤ -> Spec.fo_term ty'b0 ty'b3 := Spec.rename_subst_fo_term fr3 Func.identity Func.identity; let o9 : ℤ -> Spec.symbol ty'b0 := Spec.rename_subst_symbol bnd0 Func.identity; let o10 : ℤ -> Spec.symbol ty'b0 := Spec.rename_subst_symbol fr0 Func.identity; let o11 : ℤ := i + (0 : ℤ); ∃(o12 : Types.nl_fo_term ℤ ℤ), (Logic.bound_depth_of_symbol_in_fo_term o12 ≤ o11 + (1 : ℤ) ∧ Logic.correct_indexes_fo_term o12 ∧ Logic.bound_depth_of_fo_term_in_fo_term v0 = Logic.bound_depth_of_fo_term_in_fo_term o12 ∧ Logic.nlmodel_fo_term o12 o10 o9 o8 o7 = Logic.nlmodel_fo_term v0 (Func.update o10 x (o9 o11)) o9 o8 o7) ∧ result = Types.nl_fo_term_list.NL_FOCons o12 o6))) → Logic.bound_depth_of_symbol_in_fo_term_list result ≤ i + (1 : ℤ) ∧ Logic.correct_indexes_fo_term_list result ∧ Logic.bound_depth_of_fo_term_in_fo_term_list t = Logic.bound_depth_of_fo_term_in_fo_term_list result ∧ Logic.nlmodel_fo_term_list result fr0 bnd0 fr3 bnd3 = Logic.nlmodel_fo_term_list t (Func.update fr0 x (bnd0 i)) bnd0 fr3 bnd3)
  := sorry
end Firstorder_term_impl_Impl_bind_var_symbol_in_fo_term_listqtvc
