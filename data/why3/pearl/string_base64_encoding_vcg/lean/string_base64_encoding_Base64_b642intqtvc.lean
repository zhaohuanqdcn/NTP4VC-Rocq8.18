import Why3.Base
import Why3.string.StringBuffer
open Classical
open Lean4Why3
namespace string_base64_encoding_Base64_b642intqtvc
noncomputable def int2b64 (i : ℤ) := if (0 : ℤ) ≤ i ∧ i ≤ (25 : ℤ) then BitVec.ofNat 8 (Int.toNat (i + (65 : ℤ))) else if (26 : ℤ) ≤ i ∧ i ≤ (51 : ℤ) then BitVec.ofNat 8 (Int.toNat (i - (26 : ℤ) + (97 : ℤ))) else if (52 : ℤ) ≤ i ∧ i ≤ (61 : ℤ) then BitVec.ofNat 8 (Int.toNat (i - (52 : ℤ) + (48 : ℤ))) else if i = (62 : ℤ) then BitVec.ofNat 8 (43 : ℕ) else if i = (63 : ℤ) then BitVec.ofNat 8 (47 : ℕ) else BitVec.ofNat 8 (0 : ℕ)
noncomputable def valid_b64_char (c : BitVec 8) := (65 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (90 : ℤ) ∨ (97 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (122 : ℤ) ∨ (48 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (57 : ℤ) ∨ BitVec.toInt c = (43 : ℤ) ∨ BitVec.toInt c = (47 : ℤ)
noncomputable def b642int (c : BitVec 8) := if (65 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (90 : ℤ) then BitVec.toInt c - (65 : ℤ) else if (97 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (122 : ℤ) then BitVec.toInt c - (97 : ℤ) + (26 : ℤ) else if (48 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (57 : ℤ) then BitVec.toInt c - (48 : ℤ) + (52 : ℤ) else if BitVec.toInt c = (43 : ℤ) then (62 : ℤ) else if BitVec.toInt c = (47 : ℤ) then (63 : ℤ) else if c = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) then (0 : ℤ) else (64 : ℤ)
theorem b642int'vc (c : BitVec 8) (q1' : BitVec 63) (o1 : Bool) (fact0 : valid_b64_char c ∨ c = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63)))) (fact1 : BitVec.toInt q1' = BitVec.toInt c) (fact2 : if (65 : ℤ) ≤ BitVec.toInt q1' then o1 = (if BitVec.toInt q1' ≤ (90 : ℤ) then true else false) else o1 = false) : (if o1 = true then ∀(o2 : BitVec 63), BitVec.toInt o2 = BitVec.toInt c → int'63_in_bounds (BitVec.toInt o2 - (65 : ℤ)) else ∀(o2 : Bool), (∃(q1_1 : BitVec 63), BitVec.toInt q1_1 = BitVec.toInt c ∧ (if (97 : ℤ) ≤ BitVec.toInt q1_1 then o2 = (if BitVec.toInt q1_1 ≤ (122 : ℤ) then true else false) else o2 = false)) → (if o2 = true then ∀(o3 : BitVec 63), BitVec.toInt o3 = BitVec.toInt c → int'63_in_bounds (BitVec.toInt o3 - (97 : ℤ)) ∧ (∀(o4 : BitVec 63), BitVec.toInt o4 = BitVec.toInt o3 - (97 : ℤ) → int'63_in_bounds (BitVec.toInt o4 + (26 : ℤ))) else ∀(o3 : Bool), (∃(q1_1 : BitVec 63), BitVec.toInt q1_1 = BitVec.toInt c ∧ (if (48 : ℤ) ≤ BitVec.toInt q1_1 then o3 = (if BitVec.toInt q1_1 ≤ (57 : ℤ) then true else false) else o3 = false)) → (if o3 = true then ∀(o4 : BitVec 63), BitVec.toInt o4 = BitVec.toInt c → int'63_in_bounds (BitVec.toInt o4 - (48 : ℤ)) ∧ (∀(o5 : BitVec 63), BitVec.toInt o5 = BitVec.toInt o4 - (48 : ℤ) → int'63_in_bounds (BitVec.toInt o5 + (52 : ℤ))) else ∀(o4 : BitVec 63), BitVec.toInt o4 = BitVec.toInt c → (BitVec.toInt o4 = (43 : ℤ) → o4 = (43 : BitVec 63)) → ¬o4 = (43 : BitVec 63) → (∀(o5 : BitVec 63), BitVec.toInt o5 = BitVec.toInt c → (BitVec.toInt o5 = (47 : ℤ) → o5 = (47 : BitVec 63)) → ¬o5 = (47 : BitVec 63) → c = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))))))) ∧ (∀(result : BitVec 63), (if o1 = true then ∃(o2 : BitVec 63), BitVec.toInt o2 = BitVec.toInt c ∧ BitVec.toInt result = BitVec.toInt o2 - (65 : ℤ) else ∃(o2 : Bool), (∃(q1_1 : BitVec 63), BitVec.toInt q1_1 = BitVec.toInt c ∧ (if (97 : ℤ) ≤ BitVec.toInt q1_1 then o2 = (if BitVec.toInt q1_1 ≤ (122 : ℤ) then true else false) else o2 = false)) ∧ (if o2 = true then ∃(o3 : BitVec 63), BitVec.toInt o3 = BitVec.toInt c ∧ (∃(o4 : BitVec 63), BitVec.toInt o4 = BitVec.toInt o3 - (97 : ℤ) ∧ BitVec.toInt result = BitVec.toInt o4 + (26 : ℤ)) else ∃(o3 : Bool), (∃(q1_1 : BitVec 63), BitVec.toInt q1_1 = BitVec.toInt c ∧ (if (48 : ℤ) ≤ BitVec.toInt q1_1 then o3 = (if BitVec.toInt q1_1 ≤ (57 : ℤ) then true else false) else o3 = false)) ∧ (if o3 = true then ∃(o4 : BitVec 63), BitVec.toInt o4 = BitVec.toInt c ∧ (∃(o5 : BitVec 63), BitVec.toInt o5 = BitVec.toInt o4 - (48 : ℤ) ∧ BitVec.toInt result = BitVec.toInt o5 + (52 : ℤ)) else ∃(o4 : BitVec 63), BitVec.toInt o4 = BitVec.toInt c ∧ (BitVec.toInt o4 = (43 : ℤ) → o4 = (43 : BitVec 63)) ∧ (if o4 = (43 : BitVec 63) then result = (62 : BitVec 63) else ∃(o5 : BitVec 63), BitVec.toInt o5 = BitVec.toInt c ∧ (BitVec.toInt o5 = (47 : ℤ) → o5 = (47 : BitVec 63)) ∧ (if o5 = (47 : BitVec 63) then result = (63 : BitVec 63) else c = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) ∧ result = (0 : BitVec 63)))))) → BitVec.toInt result = b642int c)
  := sorry
end string_base64_encoding_Base64_b642intqtvc
