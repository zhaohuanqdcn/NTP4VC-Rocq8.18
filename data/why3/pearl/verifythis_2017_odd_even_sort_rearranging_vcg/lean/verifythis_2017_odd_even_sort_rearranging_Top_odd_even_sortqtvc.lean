import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Sum
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
import Why3.array.IntArraySorted
open Classical
open Lean4Why3
namespace verifythis_2017_odd_even_sort_rearranging_Top_odd_even_sortqtvc
axiom array_max : List ℤ -> ℤ
axiom array_max'spec (j : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ j) (fact1 : j < Int.ofNat (List.length a)) : a[Int.toNat j]! ≤ array_max a
noncomputable def aux (a : ℤ -> ℤ) (m : ℤ) (i : ℤ) := i * (m - a i)
axiom aux_closure : (ℤ -> ℤ) -> ℤ -> ℤ -> ℤ
axiom aux_closure_def (y : ℤ -> ℤ) (y1 : ℤ) (y2 : ℤ) : aux_closure y y1 y2 = aux y y1 y2
noncomputable def entropy (a : List ℤ) (m : ℤ) := int.Sum.sum (aux_closure (getElem! a ∘ Int.toNat) m) (0 : ℤ) (Int.ofNat (List.length a))
theorem odd_even_sort'vc (a : List ℤ) (fact0 : (0 : ℤ) < Int.ofNat (List.length a)) : let m : ℤ := array_max a; (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a) → a[Int.toNat j]! ≤ m) → List.Perm a a ∧ (∀(ok : Bool) (a1 : List ℤ), List.length a1 = List.length a → List.Perm a a1 ∧ (ok = true → IntArraySorted.sorted a1) → (if ¬ok = true then (List.Perm a a1 ∧ ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ Int.ofNat (List.length a1)) ∧ Odd (1 : ℤ) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (1 : ℤ) → Odd j → a1[Int.toNat j]! ≤ a1[Int.toNat (j + (1 : ℤ))]!) ∧ (¬True → entropy a1 m < entropy a1 m)) ∧ (∀(i : ℤ) (ok1 : Bool) (a2 : List ℤ), List.length a2 = List.length a1 → List.Perm a a2 ∧ ((0 : ℤ) ≤ i ∧ i ≤ Int.ofNat (List.length a2)) ∧ Odd i ∧ (ok1 = true → entropy a2 m = entropy a1 m) ∧ (ok1 = true → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → Odd j → a2[Int.toNat j]! ≤ a2[Int.toNat (j + (1 : ℤ))]!)) ∧ (¬ok1 = true → entropy a2 m < entropy a1 m) → (if i < Int.ofNat (List.length a2) - (1 : ℤ) then let o1 : ℤ := i + (1 : ℤ); ((0 : ℤ) ≤ o1 ∧ o1 < Int.ofNat (List.length a2)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a2)) ∧ (if a2[Int.toNat o1]! < a2[Int.toNat i]! then let o2 : ℤ := i + (1 : ℤ); (a2[Int.toNat o2]! < a2[Int.toNat i]! ∧ (0 : ℤ) ≤ i ∧ i < o2 ∧ o2 < Int.ofNat (List.length a2)) ∧ (∀(a3 : List ℤ), List.length a3 = List.length a2 → Lean4Why3.arrayExchange a2 a3 i o2 ∧ entropy a3 m < entropy a2 m → ((0 : ℤ) ≤ Int.ofNat (List.length a2) - i ∧ Int.ofNat (List.length a3) - (i + (2 : ℤ)) < Int.ofNat (List.length a2) - i) ∧ List.Perm a a3 ∧ ((0 : ℤ) ≤ i + (2 : ℤ) ∧ i + (2 : ℤ) ≤ Int.ofNat (List.length a3)) ∧ Odd (i + (2 : ℤ)) ∧ (false = true → entropy a3 m = entropy a1 m) ∧ (false = true → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (2 : ℤ) → Odd j → a3[Int.toNat j]! ≤ a3[Int.toNat (j + (1 : ℤ))]!)) ∧ (¬false = true → entropy a3 m < entropy a1 m)) else ((0 : ℤ) ≤ Int.ofNat (List.length a2) - i ∧ Int.ofNat (List.length a2) - (i + (2 : ℤ)) < Int.ofNat (List.length a2) - i) ∧ List.Perm a a2 ∧ ((0 : ℤ) ≤ i + (2 : ℤ) ∧ i + (2 : ℤ) ≤ Int.ofNat (List.length a2)) ∧ Odd (i + (2 : ℤ)) ∧ (ok1 = true → entropy a2 m = entropy a1 m) ∧ (ok1 = true → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (2 : ℤ) → Odd j → a2[Int.toNat j]! ≤ a2[Int.toNat (j + (1 : ℤ))]!)) ∧ (¬ok1 = true → entropy a2 m < entropy a1 m)) else (List.Perm a a2 ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length a2)) ∧ Even (0 : ℤ) ∧ (ok1 = true → entropy a2 m = entropy a1 m) ∧ (ok1 = true → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a2) - (1 : ℤ)) ∧ Odd j → a2[Int.toNat j]! ≤ a2[Int.toNat (j + (1 : ℤ))]!)) ∧ (ok1 = true → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j < (0 : ℤ)) ∧ Even j → a2[Int.toNat j]! ≤ a2[Int.toNat (j + (1 : ℤ))]!)) ∧ (¬ok1 = true → entropy a2 m < entropy a1 m)) ∧ (∀(i1 : ℤ) (ok2 : Bool) (a3 : List ℤ), List.length a3 = List.length a2 → List.Perm a a3 ∧ ((0 : ℤ) ≤ i1 ∧ i1 ≤ Int.ofNat (List.length a3)) ∧ Even i1 ∧ (ok2 = true → entropy a3 m = entropy a1 m) ∧ (ok2 = true → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a3) - (1 : ℤ)) ∧ Odd j → a3[Int.toNat j]! ≤ a3[Int.toNat (j + (1 : ℤ))]!)) ∧ (ok2 = true → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j < i1) ∧ Even j → a3[Int.toNat j]! ≤ a3[Int.toNat (j + (1 : ℤ))]!)) ∧ (¬ok2 = true → entropy a3 m < entropy a1 m) → (if i1 < Int.ofNat (List.length a3) - (1 : ℤ) then let o1 : ℤ := i1 + (1 : ℤ); ((0 : ℤ) ≤ o1 ∧ o1 < Int.ofNat (List.length a3)) ∧ ((0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a3)) ∧ (if a3[Int.toNat o1]! < a3[Int.toNat i1]! then let o2 : ℤ := i1 + (1 : ℤ); (a3[Int.toNat o2]! < a3[Int.toNat i1]! ∧ (0 : ℤ) ≤ i1 ∧ i1 < o2 ∧ o2 < Int.ofNat (List.length a3)) ∧ (∀(a4 : List ℤ), List.length a4 = List.length a3 → Lean4Why3.arrayExchange a3 a4 i1 o2 ∧ entropy a4 m < entropy a3 m → ((0 : ℤ) ≤ Int.ofNat (List.length a3) - i1 ∧ Int.ofNat (List.length a4) - (i1 + (2 : ℤ)) < Int.ofNat (List.length a3) - i1) ∧ List.Perm a a4 ∧ ((0 : ℤ) ≤ i1 + (2 : ℤ) ∧ i1 + (2 : ℤ) ≤ Int.ofNat (List.length a4)) ∧ Even (i1 + (2 : ℤ)) ∧ (false = true → entropy a4 m = entropy a1 m) ∧ (false = true → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a4) - (1 : ℤ)) ∧ Odd j → a4[Int.toNat j]! ≤ a4[Int.toNat (j + (1 : ℤ))]!)) ∧ (false = true → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j < i1 + (2 : ℤ)) ∧ Even j → a4[Int.toNat j]! ≤ a4[Int.toNat (j + (1 : ℤ))]!)) ∧ (¬false = true → entropy a4 m < entropy a1 m)) else ((0 : ℤ) ≤ Int.ofNat (List.length a3) - i1 ∧ Int.ofNat (List.length a3) - (i1 + (2 : ℤ)) < Int.ofNat (List.length a3) - i1) ∧ List.Perm a a3 ∧ ((0 : ℤ) ≤ i1 + (2 : ℤ) ∧ i1 + (2 : ℤ) ≤ Int.ofNat (List.length a3)) ∧ Even (i1 + (2 : ℤ)) ∧ (ok2 = true → entropy a3 m = entropy a1 m) ∧ (ok2 = true → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a3) - (1 : ℤ)) ∧ Odd j → a3[Int.toNat j]! ≤ a3[Int.toNat (j + (1 : ℤ))]!)) ∧ (ok2 = true → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j < i1 + (2 : ℤ)) ∧ Even j → a3[Int.toNat j]! ≤ a3[Int.toNat (j + (1 : ℤ))]!)) ∧ (¬ok2 = true → entropy a3 m < entropy a1 m)) else ((0 : ℤ) ≤ entropy a1 m + (if ok = true then (0 : ℤ) else (1 : ℤ)) ∧ entropy a3 m + (if ok2 = true then (0 : ℤ) else (1 : ℤ)) < entropy a1 m + (if ok = true then (0 : ℤ) else (1 : ℤ))) ∧ List.Perm a a3 ∧ (ok2 = true → IntArraySorted.sorted a3))))) else IntArraySorted.sorted a1 ∧ List.Perm a a1))
  := sorry
end verifythis_2017_odd_even_sort_rearranging_Top_odd_even_sortqtvc
