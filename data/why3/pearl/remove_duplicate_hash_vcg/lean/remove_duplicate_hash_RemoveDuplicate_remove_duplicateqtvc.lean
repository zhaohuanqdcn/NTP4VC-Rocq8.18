import Why3.Base
import Why3.why3.Ref.Ref
import pearl.remove_duplicate_hash_vcg.lean.remove_duplicate_hash.Spec
open Classical
open Lean4Why3
namespace remove_duplicate_hash_RemoveDuplicate_remove_duplicateqtvc
axiom elt : Type
axiom inhabited_axiom_elt : Inhabited elt
attribute [instance] inhabited_axiom_elt
axiom set : Type
axiom inhabited_axiom_set : Inhabited set
attribute [instance] inhabited_axiom_set
axiom to_fset : set -> Finset elt
axiom choose1 : set -> elt
axiom choose'spec (s : set) (fact0 : ¬to_fset s = ∅) : choose1 s ∈ to_fset s
theorem remove_duplicate'vc (a : List elt) (s : set) (fact0 : (1 : ℤ) ≤ Int.ofNat (List.length a)) (fact1 : to_fset s = (∅ : Finset elt)) (fact2 : Int.ofNat (Finset.card (to_fset s)) = (0 : ℤ)) : let o1 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → (∀(x : elt), Spec.appears x a (0 : ℤ) = (x ∈ to_fset s)) ∧ (∀(s1 : set), (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ (∀(x : elt), Spec.appears x a i = (x ∈ to_fset s1)) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let o2 : elt := a[Int.toNat i]!; ∀(s2 : set), to_fset s2 = insert o2 (to_fset s1) ∧ (if o2 ∈ to_fset s1 then Finset.card (to_fset s2) = Finset.card (to_fset s1) else Int.ofNat (Finset.card (to_fset s2)) = Int.ofNat (Finset.card (to_fset s1)) + (1 : ℤ)) → (∀(x : elt), Spec.appears x a (i + (1 : ℤ)) = (x ∈ to_fset s2)))) ∧ ((∀(x : elt), Spec.appears x a (o1 + (1 : ℤ)) = (x ∈ to_fset s1)) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length a)) ∧ (let o2 : ℤ := Int.ofNat (Finset.card (to_fset s1)); (0 : ℤ) ≤ o2 ∧ (∀(r : List elt), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o2 → r[Int.toNat i]! = a[(0 : ℕ)]!) ∧ Int.ofNat (List.length r) = o2 → (∀(s2 : set), to_fset s2 = (∅ : Finset elt) → (let o3 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → ((∀(x : elt), Spec.appears x a (0 : ℤ) = (x ∈ to_fset s2)) ∧ (∀(x : elt), (x ∈ to_fset s2) = Spec.appears x r (0 : ℤ)) ∧ Spec.nodup r (0 : ℤ) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) = Int.ofNat (Finset.card (to_fset s2)) ∧ Finset.card (to_fset s2) ≤ List.length r) ∧ to_fset s2 ⊆ to_fset s1) ∧ (∀(j : ℤ) (r1 : List elt) (s3 : set), List.length r1 = List.length r → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o3) ∧ (∀(x : elt), Spec.appears x a i = (x ∈ to_fset s3)) ∧ (∀(x : elt), (x ∈ to_fset s3) = Spec.appears x r1 j) ∧ Spec.nodup r1 j ∧ ((0 : ℤ) ≤ j ∧ j = Int.ofNat (Finset.card (to_fset s3)) ∧ Finset.card (to_fset s3) ≤ List.length r1) ∧ to_fset s3 ⊆ to_fset s1 → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if ¬a[Int.toNat i]! ∈ to_fset s3 then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let o4 : elt := a[Int.toNat i]!; ∀(s4 : set), to_fset s4 = insert o4 (to_fset s3) ∧ (if o4 ∈ to_fset s3 then Finset.card (to_fset s4) = Finset.card (to_fset s3) else Int.ofNat (Finset.card (to_fset s4)) = Int.ofNat (Finset.card (to_fset s3)) + (1 : ℤ)) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let o5 : elt := a[Int.toNat i]!; ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length r1)) ∧ (List.length (List.set r1 (Int.toNat j) o5) = List.length r1 → getElem! (List.set r1 (Int.toNat j) o5) ∘ Int.toNat = Function.update (getElem! r1 ∘ Int.toNat) j o5 → (∀(x : elt), Spec.appears x a (i + (1 : ℤ)) = (x ∈ to_fset s4)) ∧ (∀(x : elt), (x ∈ to_fset s4) = Spec.appears x (List.set r1 (Int.toNat j) o5) (j + (1 : ℤ))) ∧ Spec.nodup (List.set r1 (Int.toNat j) o5) (j + (1 : ℤ)) ∧ ((0 : ℤ) ≤ j + (1 : ℤ) ∧ j + (1 : ℤ) = Int.ofNat (Finset.card (to_fset s4)) ∧ Finset.card (to_fset s4) ≤ List.length (List.set r1 (Int.toNat j) o5)) ∧ to_fset s4 ⊆ to_fset s1))) else (∀(x : elt), Spec.appears x a (i + (1 : ℤ)) = (x ∈ to_fset s3)) ∧ (∀(x : elt), (x ∈ to_fset s3) = Spec.appears x r1 j) ∧ Spec.nodup r1 j ∧ ((0 : ℤ) ≤ j ∧ j = Int.ofNat (Finset.card (to_fset s3)) ∧ Finset.card (to_fset s3) ≤ List.length r1) ∧ to_fset s3 ⊆ to_fset s1)) ∧ ((∀(x : elt), Spec.appears x a (o3 + (1 : ℤ)) = (x ∈ to_fset s3)) ∧ (∀(x : elt), (x ∈ to_fset s3) = Spec.appears x r1 j) ∧ Spec.nodup r1 j ∧ ((0 : ℤ) ≤ j ∧ j = Int.ofNat (Finset.card (to_fset s3)) ∧ Finset.card (to_fset s3) ≤ List.length r1) ∧ to_fset s3 ⊆ to_fset s1 → Spec.nodup r1 (Int.ofNat (List.length r1)) ∧ (∀(x : elt), Spec.appears x a (Int.ofNat (List.length a)) = Spec.appears x r1 (Int.ofNat (List.length r1)))))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → Spec.nodup r (Int.ofNat (List.length r)) ∧ (∀(x : elt), Spec.appears x a (Int.ofNat (List.length a)) = Spec.appears x r (Int.ofNat (List.length r))))))))))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length a)) ∧ (let o2 : ℤ := Int.ofNat (Finset.card (to_fset s)); (0 : ℤ) ≤ o2 ∧ (∀(r : List elt), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o2 → r[Int.toNat i]! = a[(0 : ℕ)]!) ∧ Int.ofNat (List.length r) = o2 → (∀(s1 : set), to_fset s1 = (∅ : Finset elt) → (let o3 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → ((∀(x : elt), Spec.appears x a (0 : ℤ) = (x ∈ to_fset s1)) ∧ (∀(x : elt), (x ∈ to_fset s1) = Spec.appears x r (0 : ℤ)) ∧ Spec.nodup r (0 : ℤ) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) = Int.ofNat (Finset.card (to_fset s1)) ∧ Finset.card (to_fset s1) ≤ List.length r) ∧ to_fset s1 ⊆ to_fset s) ∧ (∀(j : ℤ) (r1 : List elt) (s2 : set), List.length r1 = List.length r → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o3) ∧ (∀(x : elt), Spec.appears x a i = (x ∈ to_fset s2)) ∧ (∀(x : elt), (x ∈ to_fset s2) = Spec.appears x r1 j) ∧ Spec.nodup r1 j ∧ ((0 : ℤ) ≤ j ∧ j = Int.ofNat (Finset.card (to_fset s2)) ∧ Finset.card (to_fset s2) ≤ List.length r1) ∧ to_fset s2 ⊆ to_fset s → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if ¬a[Int.toNat i]! ∈ to_fset s2 then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let o4 : elt := a[Int.toNat i]!; ∀(s3 : set), to_fset s3 = insert o4 (to_fset s2) ∧ (if o4 ∈ to_fset s2 then Finset.card (to_fset s3) = Finset.card (to_fset s2) else Int.ofNat (Finset.card (to_fset s3)) = Int.ofNat (Finset.card (to_fset s2)) + (1 : ℤ)) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let o5 : elt := a[Int.toNat i]!; ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length r1)) ∧ (List.length (List.set r1 (Int.toNat j) o5) = List.length r1 → getElem! (List.set r1 (Int.toNat j) o5) ∘ Int.toNat = Function.update (getElem! r1 ∘ Int.toNat) j o5 → (∀(x : elt), Spec.appears x a (i + (1 : ℤ)) = (x ∈ to_fset s3)) ∧ (∀(x : elt), (x ∈ to_fset s3) = Spec.appears x (List.set r1 (Int.toNat j) o5) (j + (1 : ℤ))) ∧ Spec.nodup (List.set r1 (Int.toNat j) o5) (j + (1 : ℤ)) ∧ ((0 : ℤ) ≤ j + (1 : ℤ) ∧ j + (1 : ℤ) = Int.ofNat (Finset.card (to_fset s3)) ∧ Finset.card (to_fset s3) ≤ List.length (List.set r1 (Int.toNat j) o5)) ∧ to_fset s3 ⊆ to_fset s))) else (∀(x : elt), Spec.appears x a (i + (1 : ℤ)) = (x ∈ to_fset s2)) ∧ (∀(x : elt), (x ∈ to_fset s2) = Spec.appears x r1 j) ∧ Spec.nodup r1 j ∧ ((0 : ℤ) ≤ j ∧ j = Int.ofNat (Finset.card (to_fset s2)) ∧ Finset.card (to_fset s2) ≤ List.length r1) ∧ to_fset s2 ⊆ to_fset s)) ∧ ((∀(x : elt), Spec.appears x a (o3 + (1 : ℤ)) = (x ∈ to_fset s2)) ∧ (∀(x : elt), (x ∈ to_fset s2) = Spec.appears x r1 j) ∧ Spec.nodup r1 j ∧ ((0 : ℤ) ≤ j ∧ j = Int.ofNat (Finset.card (to_fset s2)) ∧ Finset.card (to_fset s2) ≤ List.length r1) ∧ to_fset s2 ⊆ to_fset s → Spec.nodup r1 (Int.ofNat (List.length r1)) ∧ (∀(x : elt), Spec.appears x a (Int.ofNat (List.length a)) = Spec.appears x r1 (Int.ofNat (List.length r1)))))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → Spec.nodup r (Int.ofNat (List.length r)) ∧ (∀(x : elt), Spec.appears x a (Int.ofNat (List.length a)) = Spec.appears x r (Int.ofNat (List.length r)))))))))
  := sorry
end remove_duplicate_hash_RemoveDuplicate_remove_duplicateqtvc
