import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace verifythis_2018_array_based_queuing_lock_1_Top_mainqtvc
axiom k : ℤ
axiom k'def : (0 : ℤ) < k
axiom n : ℤ
axiom n'def : (0 : ℤ) < n
axiom bounded_int : Type
axiom inhabited_axiom_bounded_int : Inhabited bounded_int
attribute [instance] inhabited_axiom_bounded_int
axiom bmodel : bounded_int -> ℤ
axiom bounded_int'invariant (self : bounded_int) : (0 : ℤ) ≤ bmodel self ∧ bmodel self < k * n
axiom bzero : bounded_int
axiom bzero'def : bmodel bzero = (0 : ℤ)
axiom bounded_int2 : Type
axiom inhabited_axiom_bounded_int2 : Inhabited bounded_int2
attribute [instance] inhabited_axiom_bounded_int2
axiom value : bounded_int2 -> bounded_int
axiom model : bounded_int2 -> ℤ
axiom bounded_int2'invariant (self : bounded_int2) : (0 : ℤ) ≤ model self ∧ model self < n ∧ model self = Int.tmod (bmodel (value self)) n
noncomputable def bounded_int2'eq (a : bounded_int2) (b : bounded_int2) := value a = value b ∧ model a = model b
axiom bounded_int2'inj (a : bounded_int2) (b : bounded_int2) (fact0 : bounded_int2'eq a b) : a = b
axiom ticket : Type
axiom inhabited_axiom_ticket : Inhabited ticket
attribute [instance] inhabited_axiom_ticket
axiom tvalue : ticket -> ℤ
axiom ticket'invariant (self : ticket) : (0 : ℤ) ≤ tvalue self ∧ tvalue self < n
noncomputable def ticket'eq (a : ticket) (b : ticket) := tvalue a = tvalue b
axiom ticket'inj (a : ticket) (b : ticket) (fact0 : ticket'eq a b) : a = b
inductive thread_state where
  | AcqFetched : ticket -> thread_state
  | Granted : ticket -> thread_state
  | RelSet : ticket -> thread_state
  | Released : ticket -> thread_state
axiom inhabited_axiom_thread_state : Inhabited thread_state
attribute [instance] inhabited_axiom_thread_state
noncomputable def ticket1 (s : thread_state) := match s with | thread_state.AcqFetched t => tvalue t | thread_state.Granted t => tvalue t | thread_state.RelSet t => tvalue t | thread_state.Released t => tvalue t
noncomputable def released (s : thread_state) := match s with | thread_state.Released _ => True | _ => False
inductive event where
  | Request : ℤ -> event
  | Acquire : ℤ -> event
axiom inhabited_axiom_event : Inhabited event
attribute [instance] inhabited_axiom_event
axiom hidden : Type
axiom inhabited_axiom_hidden : Inhabited hidden
attribute [instance] inhabited_axiom_hidden
theorem main'vc : (let o1 : ℤ := n; (0 : ℤ) ≤ o1 ∧ (∀(result : List Bool), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o1 → result[Int.toNat i]! = false) ∧ Int.ofNat (List.length result) = o1 → Int.ofNat (List.length result) = n)) ∧ (∀(pass : List Bool), Int.ofNat (List.length pass) = n → (∀(o1 : bounded_int2), model o1 = (0 : ℤ) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < n) ∧ (∀(o2 : ticket), tvalue o2 = (0 : ℤ) → (let o3 : ℤ := n; (0 : ℤ) ≤ o3 ∧ (∀(state : List thread_state), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o3 → state[Int.toNat i]! = thread_state.Released o2) ∧ Int.ofNat (List.length state) = o3 → (let o4 : ℤ := n; (0 : ℤ) ≤ o4 ∧ (∀(tmap : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o4 → tmap[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length tmap) = o4 → (let o5 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o5 + (1 : ℤ) → ((∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → (match state[Int.toNat j]! with | thread_state.Released t => tvalue t = j | _ => False)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → tmap[Int.toNat j]! = j)) ∧ (∀(tmap1 : List ℤ) (state1 : List thread_state), List.length tmap1 = List.length tmap → List.length state1 = List.length state → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o5) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → (match state1[Int.toNat j]! with | thread_state.Released t => tvalue t = j | _ => False)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → tmap1[Int.toNat j]! = j) → ((0 : ℤ) ≤ i ∧ i < n) ∧ (∀(o6 : ticket), tvalue o6 = i → (let o7 : thread_state := thread_state.Released o6; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length state1)) ∧ (List.length (List.set state1 (Int.toNat i) o7) = List.length state1 → getElem! (List.set state1 (Int.toNat i) o7) ∘ Int.toNat = Function.update (getElem! state1 ∘ Int.toNat) i o7 → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length tmap1)) ∧ (List.length (List.set tmap1 (Int.toNat i) i) = List.length tmap1 → getElem! (List.set tmap1 (Int.toNat i) i) ∘ Int.toNat = Function.update (getElem! tmap1 ∘ Int.toNat) i i → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → (match (List.set state1 (Int.toNat i) o7)[Int.toNat j]! with | thread_state.Released t => tvalue t = j | _ => False)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → (List.set tmap1 (Int.toNat i) i)[Int.toNat j]! = j)))))) ∧ ((∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < o5 + (1 : ℤ) → (match state1[Int.toNat j]! with | thread_state.Released t => tvalue t = j | _ => False)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < o5 + (1 : ℤ) → tmap1[Int.toNat j]! = j) → (∀(o6 : bounded_int2), model o6 = (0 : ℤ) → (∀(o7 : ticket), tvalue o7 = model o6 → (let o8 : ℤ := n - (1 : ℤ); ((1 : ℤ) ≤ o8 + (1 : ℤ) → (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j < (1 : ℤ) → ¬pass[Int.toNat j]! = true) ∧ (∀(pass1 : List Bool), List.length pass1 = List.length pass → (∀(i : ℤ), ((1 : ℤ) ≤ i ∧ i ≤ o8) ∧ (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j < i → ¬pass1[Int.toNat j]! = true) → (let o9 : Bool := false; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length pass1)) ∧ (List.length (List.set pass1 (Int.toNat i) o9) = List.length pass1 → getElem! (List.set pass1 (Int.toNat i) o9) ∘ Int.toNat = Function.update (getElem! pass1 ∘ Int.toNat) i o9 → (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → ¬(List.set pass1 (Int.toNat i) o9)[Int.toNat j]! = true)))) ∧ ((∀(j : ℤ), (1 : ℤ) ≤ j ∧ j < o8 + (1 : ℤ) → ¬pass1[Int.toNat j]! = true) → (let o9 : Bool := true; ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length pass1)) ∧ (List.length (List.set pass1 (0 : ℕ) o9) = List.length pass1 → getElem! (List.set pass1 (0 : ℕ) o9) ∘ Int.toNat = Function.update (getElem! pass1 ∘ Int.toNat) (0 : ℤ) o9 → ((∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (List.set pass1 (0 : ℕ) o9)[Int.toNat i]! = true → i = tvalue o7) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state1[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue o7 ∧ (List.set pass1 (0 : ℕ) o9)[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue o7 ∧ ¬(List.set pass1 (0 : ℕ) o9)[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 (state1[Int.toNat i]!))]! = i) ∧ (model o1 < tvalue o7 → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model o1 ∨ tvalue o7 ≤ i ∧ i < n → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model o1 ≤ i ∧ i < tvalue o7 → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue o7 < model o1 → (∀(i : ℤ), tvalue o7 ≤ i ∧ i < model o1 → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue o7 ∨ model o1 ≤ i ∧ i < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model o1 = tvalue o7 → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = released (state1[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state1[Int.toNat j]! with | thread_state.Granted x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))) ∧ (∀(current : ticket) (tmap2 : List ℤ) (state2 : List thread_state) (next : bounded_int2) (pass2 : List Bool), List.length tmap2 = List.length tmap1 → List.length state2 = List.length state1 → List.length pass2 = List.length (List.set pass1 (0 : ℕ) o9) → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass2[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state2[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass2[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass2[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 (state2[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = released (state2[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state2[Int.toNat j]! with | thread_state.Granted x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True)) → (∀(id1 : ℤ), (0 : ℤ) ≤ id1 ∧ id1 < n → ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state2)) ∧ (match state2[Int.toNat id1]! with | thread_state.AcqFetched ticket2 => (let o10 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o10 ∧ o10 < Int.ofNat (List.length pass2)) ∧ (if pass2[Int.toNat o10]! = true then let o11 : thread_state := thread_state.Granted ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state2)) ∧ (List.length (List.set state2 (Int.toNat id1) o11) = List.length state2 → getElem! (List.set state2 (Int.toNat id1) o11) ∘ Int.toNat = Function.update (getElem! state2 ∘ Int.toNat) id1 o11 → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass2[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set state2 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass2[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass2[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 ((List.set state2 (Int.toNat id1) o11)[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!) = released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set state2 (Int.toNat id1) o11)[Int.toNat j]! with | thread_state.Granted x => (match (List.set state2 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set state2 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))) else (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass2[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state2[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass2[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass2[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 (state2[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = released (state2[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state2[Int.toNat j]! with | thread_state.Granted x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True)))) | thread_state.Granted ticket2 => (∀(o10 : Bool), if o10 = true then let o11 : thread_state := thread_state.RelSet ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state2)) ∧ (List.length (List.set state2 (Int.toNat id1) o11) = List.length state2 → getElem! (List.set state2 (Int.toNat id1) o11) ∘ Int.toNat = Function.update (getElem! state2 ∘ Int.toNat) id1 o11 → (let o12 : Bool := false; let o13 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o13 ∧ o13 < Int.ofNat (List.length pass2)) ∧ (List.length (List.set pass2 (Int.toNat o13) o12) = List.length pass2 → getElem! (List.set pass2 (Int.toNat o13) o12) ∘ Int.toNat = Function.update (getElem! pass2 ∘ Int.toNat) o13 o12 → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (List.set pass2 (Int.toNat o13) o12)[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set state2 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ (List.set pass2 (Int.toNat o13) o12)[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬(List.set pass2 (Int.toNat o13) o12)[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 ((List.set state2 (Int.toNat id1) o11)[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!) = released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set state2 (Int.toNat id1) o11)[Int.toNat j]! with | thread_state.Granted x => (match (List.set state2 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set state2 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))))) else (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass2[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state2[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass2[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass2[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 (state2[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = released (state2[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state2[Int.toNat j]! with | thread_state.Granted x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))) | thread_state.RelSet ticket2 => (let o10 : thread_state := thread_state.Released ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state2)) ∧ (List.length (List.set state2 (Int.toNat id1) o10) = List.length state2 → getElem! (List.set state2 (Int.toNat id1) o10) ∘ Int.toNat = Function.update (getElem! state2 ∘ Int.toNat) id1 o10 → (let o11 : Bool := true; ∀(o12 : ticket), (let v : ℤ := tvalue ticket2 + (1 : ℤ); tvalue o12 = (if v = n then (0 : ℤ) else v)) → (let o13 : ℤ := tvalue o12; ((0 : ℤ) ≤ o13 ∧ o13 < Int.ofNat (List.length pass2)) ∧ (List.length (List.set pass2 (Int.toNat o13) o11) = List.length pass2 → getElem! (List.set pass2 (Int.toNat o13) o11) ∘ Int.toNat = Function.update (getElem! pass2 ∘ Int.toNat) o13 o11 → (∀(o14 : ticket), (let v : ℤ := tvalue current + (1 : ℤ); tvalue o14 = (if v = n then (0 : ℤ) else v)) → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (List.set pass2 (Int.toNat o13) o11)[Int.toNat i]! = true → i = tvalue o14) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set state2 (Int.toNat id1) o10)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue o14 ∧ (List.set pass2 (Int.toNat o13) o11)[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue o14 ∧ ¬(List.set pass2 (Int.toNat o13) o11)[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 ((List.set state2 (Int.toNat id1) o10)[Int.toNat i]!))]! = i) ∧ (model next < tvalue o14 → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue o14 ≤ i ∧ i < n → ¬released ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue o14 → released ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue o14 < model next → (∀(i : ℤ), tvalue o14 ≤ i ∧ i < model next → ¬released ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue o14 ∨ model next ≤ i ∧ i < n → released ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue o14 → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat i]!)]!) = released ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set state2 (Int.toNat id1) o10)[Int.toNat j]! with | thread_state.Granted x => (match (List.set state2 (Int.toNat id1) o10)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set state2 (Int.toNat id1) o10)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True)))))))) | thread_state.Released told => (∀(o10 : Bool), if o10 = true then ∀(ticket2 : ticket), tvalue ticket2 = model next → (let o11 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o11 ∧ o11 < Int.ofNat (List.length tmap2)) ∧ (let id2 : ℤ := tmap2[Int.toNat o11]!; ((0 : ℤ) ≤ id2 ∧ id2 < Int.ofNat (List.length state2)) ∧ (match state2[Int.toNat id2]! with | thread_state.Released _ => (let o12 : thread_state := thread_state.Released told; ((0 : ℤ) ≤ id2 ∧ id2 < Int.ofNat (List.length state2)) ∧ (List.length (List.set state2 (Int.toNat id2) o12) = List.length state2 → getElem! (List.set state2 (Int.toNat id2) o12) ∘ Int.toNat = Function.update (getElem! state2 ∘ Int.toNat) id2 o12 → (let o13 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o13 ∧ o13 < Int.ofNat (List.length tmap2)) ∧ (List.length (List.set tmap2 (Int.toNat o13) id1) = List.length tmap2 → getElem! (List.set tmap2 (Int.toNat o13) id1) ∘ Int.toNat = Function.update (getElem! tmap2 ∘ Int.toNat) o13 id1 → (let o14 : ℤ := tvalue told; ((0 : ℤ) ≤ o14 ∧ o14 < Int.ofNat (List.length (List.set tmap2 (Int.toNat o13) id1))) ∧ (List.length (List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2) = List.length (List.set tmap2 (Int.toNat o13) id1) → getElem! (List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2) ∘ Int.toNat = Function.update (getElem! (List.set tmap2 (Int.toNat o13) id1) ∘ Int.toNat) o14 id2 → (let o15 : thread_state := thread_state.AcqFetched ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length (List.set state2 (Int.toNat id2) o12))) ∧ (List.length (List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15) = List.length (List.set state2 (Int.toNat id2) o12) → getElem! (List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15) ∘ Int.toNat = Function.update (getElem! (List.set state2 (Int.toNat id2) o12) ∘ Int.toNat) id1 o15 → (∀(o16 : bounded_int2), (let v : ℤ := model next + (1 : ℤ); model o16 = (if v = n then (0 : ℤ) else v)) → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass2[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass2[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass2[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ (List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]! ∧ (List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat (ticket1 ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]!))]! = i) ∧ (model o16 < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model o16 ∨ tvalue current ≤ i ∧ i < n → ¬released ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model o16 ≤ i ∧ i < tvalue current → released ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!))) ∧ (tvalue current < model o16 → (∀(i : ℤ), tvalue current ≤ i ∧ i < model o16 → ¬released ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model o16 ≤ i ∧ i < n → released ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!))) ∧ (model o16 = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!) = released ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat j]! with | thread_state.Granted x => (match (List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))))))))))) | _ => False))) else (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass2[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state2[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass2[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass2[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 (state2[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = released (state2[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state2[Int.toNat j]! with | thread_state.Granted x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))))))))))) ∧ (o8 + (1 : ℤ) < (1 : ℤ) → (let o9 : Bool := true; ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length pass)) ∧ (List.length (List.set pass (0 : ℕ) o9) = List.length pass → getElem! (List.set pass (0 : ℕ) o9) ∘ Int.toNat = Function.update (getElem! pass ∘ Int.toNat) (0 : ℤ) o9 → ((∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (List.set pass (0 : ℕ) o9)[Int.toNat i]! = true → i = tvalue o7) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state1[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue o7 ∧ (List.set pass (0 : ℕ) o9)[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue o7 ∧ ¬(List.set pass (0 : ℕ) o9)[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 (state1[Int.toNat i]!))]! = i) ∧ (model o1 < tvalue o7 → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model o1 ∨ tvalue o7 ≤ i ∧ i < n → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model o1 ≤ i ∧ i < tvalue o7 → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue o7 < model o1 → (∀(i : ℤ), tvalue o7 ≤ i ∧ i < model o1 → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue o7 ∨ model o1 ≤ i ∧ i < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model o1 = tvalue o7 → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = released (state1[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state1[Int.toNat j]! with | thread_state.Granted x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))) ∧ (∀(current : ticket) (tmap2 : List ℤ) (state2 : List thread_state) (next : bounded_int2) (pass1 : List Bool), List.length tmap2 = List.length tmap1 → List.length state2 = List.length state1 → List.length pass1 = List.length (List.set pass (0 : ℕ) o9) → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass1[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state2[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass1[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass1[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 (state2[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = released (state2[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state2[Int.toNat j]! with | thread_state.Granted x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True)) → (∀(id1 : ℤ), (0 : ℤ) ≤ id1 ∧ id1 < n → ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state2)) ∧ (match state2[Int.toNat id1]! with | thread_state.AcqFetched ticket2 => (let o10 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o10 ∧ o10 < Int.ofNat (List.length pass1)) ∧ (if pass1[Int.toNat o10]! = true then let o11 : thread_state := thread_state.Granted ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state2)) ∧ (List.length (List.set state2 (Int.toNat id1) o11) = List.length state2 → getElem! (List.set state2 (Int.toNat id1) o11) ∘ Int.toNat = Function.update (getElem! state2 ∘ Int.toNat) id1 o11 → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass1[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set state2 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass1[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass1[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 ((List.set state2 (Int.toNat id1) o11)[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!) = released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set state2 (Int.toNat id1) o11)[Int.toNat j]! with | thread_state.Granted x => (match (List.set state2 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set state2 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))) else (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass1[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state2[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass1[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass1[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 (state2[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = released (state2[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state2[Int.toNat j]! with | thread_state.Granted x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True)))) | thread_state.Granted ticket2 => (∀(o10 : Bool), if o10 = true then let o11 : thread_state := thread_state.RelSet ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state2)) ∧ (List.length (List.set state2 (Int.toNat id1) o11) = List.length state2 → getElem! (List.set state2 (Int.toNat id1) o11) ∘ Int.toNat = Function.update (getElem! state2 ∘ Int.toNat) id1 o11 → (let o12 : Bool := false; let o13 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o13 ∧ o13 < Int.ofNat (List.length pass1)) ∧ (List.length (List.set pass1 (Int.toNat o13) o12) = List.length pass1 → getElem! (List.set pass1 (Int.toNat o13) o12) ∘ Int.toNat = Function.update (getElem! pass1 ∘ Int.toNat) o13 o12 → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (List.set pass1 (Int.toNat o13) o12)[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set state2 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ (List.set pass1 (Int.toNat o13) o12)[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬(List.set pass1 (Int.toNat o13) o12)[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 ((List.set state2 (Int.toNat id1) o11)[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat i]!)]!) = released ((List.set state2 (Int.toNat id1) o11)[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set state2 (Int.toNat id1) o11)[Int.toNat j]! with | thread_state.Granted x => (match (List.set state2 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set state2 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))))) else (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass1[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state2[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass1[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass1[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 (state2[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = released (state2[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state2[Int.toNat j]! with | thread_state.Granted x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))) | thread_state.RelSet ticket2 => (let o10 : thread_state := thread_state.Released ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state2)) ∧ (List.length (List.set state2 (Int.toNat id1) o10) = List.length state2 → getElem! (List.set state2 (Int.toNat id1) o10) ∘ Int.toNat = Function.update (getElem! state2 ∘ Int.toNat) id1 o10 → (let o11 : Bool := true; ∀(o12 : ticket), (let v : ℤ := tvalue ticket2 + (1 : ℤ); tvalue o12 = (if v = n then (0 : ℤ) else v)) → (let o13 : ℤ := tvalue o12; ((0 : ℤ) ≤ o13 ∧ o13 < Int.ofNat (List.length pass1)) ∧ (List.length (List.set pass1 (Int.toNat o13) o11) = List.length pass1 → getElem! (List.set pass1 (Int.toNat o13) o11) ∘ Int.toNat = Function.update (getElem! pass1 ∘ Int.toNat) o13 o11 → (∀(o14 : ticket), (let v : ℤ := tvalue current + (1 : ℤ); tvalue o14 = (if v = n then (0 : ℤ) else v)) → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (List.set pass1 (Int.toNat o13) o11)[Int.toNat i]! = true → i = tvalue o14) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set state2 (Int.toNat id1) o10)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue o14 ∧ (List.set pass1 (Int.toNat o13) o11)[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue o14 ∧ ¬(List.set pass1 (Int.toNat o13) o11)[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 ((List.set state2 (Int.toNat id1) o10)[Int.toNat i]!))]! = i) ∧ (model next < tvalue o14 → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue o14 ≤ i ∧ i < n → ¬released ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue o14 → released ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue o14 < model next → (∀(i : ℤ), tvalue o14 ≤ i ∧ i < model next → ¬released ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue o14 ∨ model next ≤ i ∧ i < n → released ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue o14 → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat i]!)]!) = released ((List.set state2 (Int.toNat id1) o10)[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set state2 (Int.toNat id1) o10)[Int.toNat j]! with | thread_state.Granted x => (match (List.set state2 (Int.toNat id1) o10)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set state2 (Int.toNat id1) o10)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True)))))))) | thread_state.Released told => (∀(o10 : Bool), if o10 = true then ∀(ticket2 : ticket), tvalue ticket2 = model next → (let o11 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o11 ∧ o11 < Int.ofNat (List.length tmap2)) ∧ (let id2 : ℤ := tmap2[Int.toNat o11]!; ((0 : ℤ) ≤ id2 ∧ id2 < Int.ofNat (List.length state2)) ∧ (match state2[Int.toNat id2]! with | thread_state.Released _ => (let o12 : thread_state := thread_state.Released told; ((0 : ℤ) ≤ id2 ∧ id2 < Int.ofNat (List.length state2)) ∧ (List.length (List.set state2 (Int.toNat id2) o12) = List.length state2 → getElem! (List.set state2 (Int.toNat id2) o12) ∘ Int.toNat = Function.update (getElem! state2 ∘ Int.toNat) id2 o12 → (let o13 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o13 ∧ o13 < Int.ofNat (List.length tmap2)) ∧ (List.length (List.set tmap2 (Int.toNat o13) id1) = List.length tmap2 → getElem! (List.set tmap2 (Int.toNat o13) id1) ∘ Int.toNat = Function.update (getElem! tmap2 ∘ Int.toNat) o13 id1 → (let o14 : ℤ := tvalue told; ((0 : ℤ) ≤ o14 ∧ o14 < Int.ofNat (List.length (List.set tmap2 (Int.toNat o13) id1))) ∧ (List.length (List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2) = List.length (List.set tmap2 (Int.toNat o13) id1) → getElem! (List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2) ∘ Int.toNat = Function.update (getElem! (List.set tmap2 (Int.toNat o13) id1) ∘ Int.toNat) o14 id2 → (let o15 : thread_state := thread_state.AcqFetched ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length (List.set state2 (Int.toNat id2) o12))) ∧ (List.length (List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15) = List.length (List.set state2 (Int.toNat id2) o12) → getElem! (List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15) ∘ Int.toNat = Function.update (getElem! (List.set state2 (Int.toNat id2) o12) ∘ Int.toNat) id1 o15 → (∀(o16 : bounded_int2), (let v : ℤ := model next + (1 : ℤ); model o16 = (if v = n then (0 : ℤ) else v)) → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass1[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass1[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass1[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ (List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]! ∧ (List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat (ticket1 ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]!))]! = i) ∧ (model o16 < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model o16 ∨ tvalue current ≤ i ∧ i < n → ¬released ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model o16 ≤ i ∧ i < tvalue current → released ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!))) ∧ (tvalue current < model o16 → (∀(i : ℤ), tvalue current ≤ i ∧ i < model o16 → ¬released ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model o16 ≤ i ∧ i < n → released ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!))) ∧ (model o16 = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!) = released ((List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap2 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat j]! with | thread_state.Granted x => (match (List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set (List.set state2 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))))))))))) | _ => False))) else (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass1[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state2[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass1[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass1[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap2[Int.toNat i]! ∧ tmap2[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap2[Int.toNat (ticket1 (state2[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state2[Int.toNat (tmap2[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state2[Int.toNat (tmap2[Int.toNat i]!)]!) = released (state2[Int.toNat (tmap2[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state2[Int.toNat j]! with | thread_state.Granted x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state2[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))))))))))))))) ∧ (o5 + (1 : ℤ) < (0 : ℤ) → (∀(o6 : bounded_int2), model o6 = (0 : ℤ) → (∀(o7 : ticket), tvalue o7 = model o6 → (let o8 : ℤ := n - (1 : ℤ); ((1 : ℤ) ≤ o8 + (1 : ℤ) → (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j < (1 : ℤ) → ¬pass[Int.toNat j]! = true) ∧ (∀(pass1 : List Bool), List.length pass1 = List.length pass → (∀(i : ℤ), ((1 : ℤ) ≤ i ∧ i ≤ o8) ∧ (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j < i → ¬pass1[Int.toNat j]! = true) → (let o9 : Bool := false; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length pass1)) ∧ (List.length (List.set pass1 (Int.toNat i) o9) = List.length pass1 → getElem! (List.set pass1 (Int.toNat i) o9) ∘ Int.toNat = Function.update (getElem! pass1 ∘ Int.toNat) i o9 → (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → ¬(List.set pass1 (Int.toNat i) o9)[Int.toNat j]! = true)))) ∧ ((∀(j : ℤ), (1 : ℤ) ≤ j ∧ j < o8 + (1 : ℤ) → ¬pass1[Int.toNat j]! = true) → (let o9 : Bool := true; ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length pass1)) ∧ (List.length (List.set pass1 (0 : ℕ) o9) = List.length pass1 → getElem! (List.set pass1 (0 : ℕ) o9) ∘ Int.toNat = Function.update (getElem! pass1 ∘ Int.toNat) (0 : ℤ) o9 → ((∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (List.set pass1 (0 : ℕ) o9)[Int.toNat i]! = true → i = tvalue o7) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue o7 ∧ (List.set pass1 (0 : ℕ) o9)[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue o7 ∧ ¬(List.set pass1 (0 : ℕ) o9)[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap[Int.toNat i]! ∧ tmap[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state[Int.toNat (tmap[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap[Int.toNat (ticket1 (state[Int.toNat i]!))]! = i) ∧ (model o1 < tvalue o7 → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model o1 ∨ tvalue o7 ≤ i ∧ i < n → ¬released (state[Int.toNat (tmap[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model o1 ≤ i ∧ i < tvalue o7 → released (state[Int.toNat (tmap[Int.toNat i]!)]!))) ∧ (tvalue o7 < model o1 → (∀(i : ℤ), tvalue o7 ≤ i ∧ i < model o1 → ¬released (state[Int.toNat (tmap[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue o7 ∨ model o1 ≤ i ∧ i < n → released (state[Int.toNat (tmap[Int.toNat i]!)]!))) ∧ (model o1 = tvalue o7 → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state[Int.toNat (tmap[Int.toNat i]!)]!) = released (state[Int.toNat (tmap[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state[Int.toNat j]! with | thread_state.Granted x => (match state[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))) ∧ (∀(current : ticket) (tmap1 : List ℤ) (state1 : List thread_state) (next : bounded_int2) (pass2 : List Bool), List.length tmap1 = List.length tmap → List.length state1 = List.length state → List.length pass2 = List.length (List.set pass1 (0 : ℕ) o9) → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass2[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state1[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass2[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass2[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 (state1[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = released (state1[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state1[Int.toNat j]! with | thread_state.Granted x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True)) → (∀(id1 : ℤ), (0 : ℤ) ≤ id1 ∧ id1 < n → ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state1)) ∧ (match state1[Int.toNat id1]! with | thread_state.AcqFetched ticket2 => (let o10 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o10 ∧ o10 < Int.ofNat (List.length pass2)) ∧ (if pass2[Int.toNat o10]! = true then let o11 : thread_state := thread_state.Granted ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state1)) ∧ (List.length (List.set state1 (Int.toNat id1) o11) = List.length state1 → getElem! (List.set state1 (Int.toNat id1) o11) ∘ Int.toNat = Function.update (getElem! state1 ∘ Int.toNat) id1 o11 → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass2[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set state1 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass2[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass2[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 ((List.set state1 (Int.toNat id1) o11)[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!) = released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set state1 (Int.toNat id1) o11)[Int.toNat j]! with | thread_state.Granted x => (match (List.set state1 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set state1 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))) else (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass2[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state1[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass2[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass2[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 (state1[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = released (state1[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state1[Int.toNat j]! with | thread_state.Granted x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True)))) | thread_state.Granted ticket2 => (∀(o10 : Bool), if o10 = true then let o11 : thread_state := thread_state.RelSet ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state1)) ∧ (List.length (List.set state1 (Int.toNat id1) o11) = List.length state1 → getElem! (List.set state1 (Int.toNat id1) o11) ∘ Int.toNat = Function.update (getElem! state1 ∘ Int.toNat) id1 o11 → (let o12 : Bool := false; let o13 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o13 ∧ o13 < Int.ofNat (List.length pass2)) ∧ (List.length (List.set pass2 (Int.toNat o13) o12) = List.length pass2 → getElem! (List.set pass2 (Int.toNat o13) o12) ∘ Int.toNat = Function.update (getElem! pass2 ∘ Int.toNat) o13 o12 → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (List.set pass2 (Int.toNat o13) o12)[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set state1 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ (List.set pass2 (Int.toNat o13) o12)[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬(List.set pass2 (Int.toNat o13) o12)[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 ((List.set state1 (Int.toNat id1) o11)[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!) = released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set state1 (Int.toNat id1) o11)[Int.toNat j]! with | thread_state.Granted x => (match (List.set state1 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set state1 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))))) else (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass2[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state1[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass2[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass2[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 (state1[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = released (state1[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state1[Int.toNat j]! with | thread_state.Granted x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))) | thread_state.RelSet ticket2 => (let o10 : thread_state := thread_state.Released ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state1)) ∧ (List.length (List.set state1 (Int.toNat id1) o10) = List.length state1 → getElem! (List.set state1 (Int.toNat id1) o10) ∘ Int.toNat = Function.update (getElem! state1 ∘ Int.toNat) id1 o10 → (let o11 : Bool := true; ∀(o12 : ticket), (let v : ℤ := tvalue ticket2 + (1 : ℤ); tvalue o12 = (if v = n then (0 : ℤ) else v)) → (let o13 : ℤ := tvalue o12; ((0 : ℤ) ≤ o13 ∧ o13 < Int.ofNat (List.length pass2)) ∧ (List.length (List.set pass2 (Int.toNat o13) o11) = List.length pass2 → getElem! (List.set pass2 (Int.toNat o13) o11) ∘ Int.toNat = Function.update (getElem! pass2 ∘ Int.toNat) o13 o11 → (∀(o14 : ticket), (let v : ℤ := tvalue current + (1 : ℤ); tvalue o14 = (if v = n then (0 : ℤ) else v)) → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (List.set pass2 (Int.toNat o13) o11)[Int.toNat i]! = true → i = tvalue o14) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set state1 (Int.toNat id1) o10)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue o14 ∧ (List.set pass2 (Int.toNat o13) o11)[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue o14 ∧ ¬(List.set pass2 (Int.toNat o13) o11)[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 ((List.set state1 (Int.toNat id1) o10)[Int.toNat i]!))]! = i) ∧ (model next < tvalue o14 → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue o14 ≤ i ∧ i < n → ¬released ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue o14 → released ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue o14 < model next → (∀(i : ℤ), tvalue o14 ≤ i ∧ i < model next → ¬released ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue o14 ∨ model next ≤ i ∧ i < n → released ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue o14 → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat i]!)]!) = released ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set state1 (Int.toNat id1) o10)[Int.toNat j]! with | thread_state.Granted x => (match (List.set state1 (Int.toNat id1) o10)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set state1 (Int.toNat id1) o10)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True)))))))) | thread_state.Released told => (∀(o10 : Bool), if o10 = true then ∀(ticket2 : ticket), tvalue ticket2 = model next → (let o11 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o11 ∧ o11 < Int.ofNat (List.length tmap1)) ∧ (let id2 : ℤ := tmap1[Int.toNat o11]!; ((0 : ℤ) ≤ id2 ∧ id2 < Int.ofNat (List.length state1)) ∧ (match state1[Int.toNat id2]! with | thread_state.Released _ => (let o12 : thread_state := thread_state.Released told; ((0 : ℤ) ≤ id2 ∧ id2 < Int.ofNat (List.length state1)) ∧ (List.length (List.set state1 (Int.toNat id2) o12) = List.length state1 → getElem! (List.set state1 (Int.toNat id2) o12) ∘ Int.toNat = Function.update (getElem! state1 ∘ Int.toNat) id2 o12 → (let o13 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o13 ∧ o13 < Int.ofNat (List.length tmap1)) ∧ (List.length (List.set tmap1 (Int.toNat o13) id1) = List.length tmap1 → getElem! (List.set tmap1 (Int.toNat o13) id1) ∘ Int.toNat = Function.update (getElem! tmap1 ∘ Int.toNat) o13 id1 → (let o14 : ℤ := tvalue told; ((0 : ℤ) ≤ o14 ∧ o14 < Int.ofNat (List.length (List.set tmap1 (Int.toNat o13) id1))) ∧ (List.length (List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2) = List.length (List.set tmap1 (Int.toNat o13) id1) → getElem! (List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2) ∘ Int.toNat = Function.update (getElem! (List.set tmap1 (Int.toNat o13) id1) ∘ Int.toNat) o14 id2 → (let o15 : thread_state := thread_state.AcqFetched ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length (List.set state1 (Int.toNat id2) o12))) ∧ (List.length (List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15) = List.length (List.set state1 (Int.toNat id2) o12) → getElem! (List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15) ∘ Int.toNat = Function.update (getElem! (List.set state1 (Int.toNat id2) o12) ∘ Int.toNat) id1 o15 → (∀(o16 : bounded_int2), (let v : ℤ := model next + (1 : ℤ); model o16 = (if v = n then (0 : ℤ) else v)) → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass2[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass2[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass2[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ (List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]! ∧ (List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat (ticket1 ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]!))]! = i) ∧ (model o16 < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model o16 ∨ tvalue current ≤ i ∧ i < n → ¬released ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model o16 ≤ i ∧ i < tvalue current → released ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!))) ∧ (tvalue current < model o16 → (∀(i : ℤ), tvalue current ≤ i ∧ i < model o16 → ¬released ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model o16 ≤ i ∧ i < n → released ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!))) ∧ (model o16 = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!) = released ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat j]! with | thread_state.Granted x => (match (List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))))))))))) | _ => False))) else (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass2[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state1[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass2[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass2[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 (state1[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = released (state1[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state1[Int.toNat j]! with | thread_state.Granted x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))))))))))) ∧ (o8 + (1 : ℤ) < (1 : ℤ) → (let o9 : Bool := true; ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length pass)) ∧ (List.length (List.set pass (0 : ℕ) o9) = List.length pass → getElem! (List.set pass (0 : ℕ) o9) ∘ Int.toNat = Function.update (getElem! pass ∘ Int.toNat) (0 : ℤ) o9 → ((∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (List.set pass (0 : ℕ) o9)[Int.toNat i]! = true → i = tvalue o7) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue o7 ∧ (List.set pass (0 : ℕ) o9)[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue o7 ∧ ¬(List.set pass (0 : ℕ) o9)[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap[Int.toNat i]! ∧ tmap[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state[Int.toNat (tmap[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap[Int.toNat (ticket1 (state[Int.toNat i]!))]! = i) ∧ (model o1 < tvalue o7 → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model o1 ∨ tvalue o7 ≤ i ∧ i < n → ¬released (state[Int.toNat (tmap[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model o1 ≤ i ∧ i < tvalue o7 → released (state[Int.toNat (tmap[Int.toNat i]!)]!))) ∧ (tvalue o7 < model o1 → (∀(i : ℤ), tvalue o7 ≤ i ∧ i < model o1 → ¬released (state[Int.toNat (tmap[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue o7 ∨ model o1 ≤ i ∧ i < n → released (state[Int.toNat (tmap[Int.toNat i]!)]!))) ∧ (model o1 = tvalue o7 → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state[Int.toNat (tmap[Int.toNat i]!)]!) = released (state[Int.toNat (tmap[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state[Int.toNat j]! with | thread_state.Granted x => (match state[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))) ∧ (∀(current : ticket) (tmap1 : List ℤ) (state1 : List thread_state) (next : bounded_int2) (pass1 : List Bool), List.length tmap1 = List.length tmap → List.length state1 = List.length state → List.length pass1 = List.length (List.set pass (0 : ℕ) o9) → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass1[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state1[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass1[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass1[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 (state1[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = released (state1[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state1[Int.toNat j]! with | thread_state.Granted x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True)) → (∀(id1 : ℤ), (0 : ℤ) ≤ id1 ∧ id1 < n → ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state1)) ∧ (match state1[Int.toNat id1]! with | thread_state.AcqFetched ticket2 => (let o10 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o10 ∧ o10 < Int.ofNat (List.length pass1)) ∧ (if pass1[Int.toNat o10]! = true then let o11 : thread_state := thread_state.Granted ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state1)) ∧ (List.length (List.set state1 (Int.toNat id1) o11) = List.length state1 → getElem! (List.set state1 (Int.toNat id1) o11) ∘ Int.toNat = Function.update (getElem! state1 ∘ Int.toNat) id1 o11 → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass1[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set state1 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass1[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass1[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 ((List.set state1 (Int.toNat id1) o11)[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!) = released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set state1 (Int.toNat id1) o11)[Int.toNat j]! with | thread_state.Granted x => (match (List.set state1 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set state1 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))) else (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass1[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state1[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass1[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass1[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 (state1[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = released (state1[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state1[Int.toNat j]! with | thread_state.Granted x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True)))) | thread_state.Granted ticket2 => (∀(o10 : Bool), if o10 = true then let o11 : thread_state := thread_state.RelSet ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state1)) ∧ (List.length (List.set state1 (Int.toNat id1) o11) = List.length state1 → getElem! (List.set state1 (Int.toNat id1) o11) ∘ Int.toNat = Function.update (getElem! state1 ∘ Int.toNat) id1 o11 → (let o12 : Bool := false; let o13 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o13 ∧ o13 < Int.ofNat (List.length pass1)) ∧ (List.length (List.set pass1 (Int.toNat o13) o12) = List.length pass1 → getElem! (List.set pass1 (Int.toNat o13) o12) ∘ Int.toNat = Function.update (getElem! pass1 ∘ Int.toNat) o13 o12 → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (List.set pass1 (Int.toNat o13) o12)[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set state1 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ (List.set pass1 (Int.toNat o13) o12)[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬(List.set pass1 (Int.toNat o13) o12)[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 ((List.set state1 (Int.toNat id1) o11)[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat i]!)]!) = released ((List.set state1 (Int.toNat id1) o11)[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set state1 (Int.toNat id1) o11)[Int.toNat j]! with | thread_state.Granted x => (match (List.set state1 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set state1 (Int.toNat id1) o11)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))))) else (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass1[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state1[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass1[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass1[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 (state1[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = released (state1[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state1[Int.toNat j]! with | thread_state.Granted x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))) | thread_state.RelSet ticket2 => (let o10 : thread_state := thread_state.Released ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length state1)) ∧ (List.length (List.set state1 (Int.toNat id1) o10) = List.length state1 → getElem! (List.set state1 (Int.toNat id1) o10) ∘ Int.toNat = Function.update (getElem! state1 ∘ Int.toNat) id1 o10 → (let o11 : Bool := true; ∀(o12 : ticket), (let v : ℤ := tvalue ticket2 + (1 : ℤ); tvalue o12 = (if v = n then (0 : ℤ) else v)) → (let o13 : ℤ := tvalue o12; ((0 : ℤ) ≤ o13 ∧ o13 < Int.ofNat (List.length pass1)) ∧ (List.length (List.set pass1 (Int.toNat o13) o11) = List.length pass1 → getElem! (List.set pass1 (Int.toNat o13) o11) ∘ Int.toNat = Function.update (getElem! pass1 ∘ Int.toNat) o13 o11 → (∀(o14 : ticket), (let v : ℤ := tvalue current + (1 : ℤ); tvalue o14 = (if v = n then (0 : ℤ) else v)) → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ (List.set pass1 (Int.toNat o13) o11)[Int.toNat i]! = true → i = tvalue o14) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set state1 (Int.toNat id1) o10)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue o14 ∧ (List.set pass1 (Int.toNat o13) o11)[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue o14 ∧ ¬(List.set pass1 (Int.toNat o13) o11)[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 ((List.set state1 (Int.toNat id1) o10)[Int.toNat i]!))]! = i) ∧ (model next < tvalue o14 → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue o14 ≤ i ∧ i < n → ¬released ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue o14 → released ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue o14 < model next → (∀(i : ℤ), tvalue o14 ≤ i ∧ i < model next → ¬released ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue o14 ∨ model next ≤ i ∧ i < n → released ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue o14 → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat i]!)]!) = released ((List.set state1 (Int.toNat id1) o10)[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set state1 (Int.toNat id1) o10)[Int.toNat j]! with | thread_state.Granted x => (match (List.set state1 (Int.toNat id1) o10)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set state1 (Int.toNat id1) o10)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True)))))))) | thread_state.Released told => (∀(o10 : Bool), if o10 = true then ∀(ticket2 : ticket), tvalue ticket2 = model next → (let o11 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o11 ∧ o11 < Int.ofNat (List.length tmap1)) ∧ (let id2 : ℤ := tmap1[Int.toNat o11]!; ((0 : ℤ) ≤ id2 ∧ id2 < Int.ofNat (List.length state1)) ∧ (match state1[Int.toNat id2]! with | thread_state.Released _ => (let o12 : thread_state := thread_state.Released told; ((0 : ℤ) ≤ id2 ∧ id2 < Int.ofNat (List.length state1)) ∧ (List.length (List.set state1 (Int.toNat id2) o12) = List.length state1 → getElem! (List.set state1 (Int.toNat id2) o12) ∘ Int.toNat = Function.update (getElem! state1 ∘ Int.toNat) id2 o12 → (let o13 : ℤ := tvalue ticket2; ((0 : ℤ) ≤ o13 ∧ o13 < Int.ofNat (List.length tmap1)) ∧ (List.length (List.set tmap1 (Int.toNat o13) id1) = List.length tmap1 → getElem! (List.set tmap1 (Int.toNat o13) id1) ∘ Int.toNat = Function.update (getElem! tmap1 ∘ Int.toNat) o13 id1 → (let o14 : ℤ := tvalue told; ((0 : ℤ) ≤ o14 ∧ o14 < Int.ofNat (List.length (List.set tmap1 (Int.toNat o13) id1))) ∧ (List.length (List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2) = List.length (List.set tmap1 (Int.toNat o13) id1) → getElem! (List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2) ∘ Int.toNat = Function.update (getElem! (List.set tmap1 (Int.toNat o13) id1) ∘ Int.toNat) o14 id2 → (let o15 : thread_state := thread_state.AcqFetched ticket2; ((0 : ℤ) ≤ id1 ∧ id1 < Int.ofNat (List.length (List.set state1 (Int.toNat id2) o12))) ∧ (List.length (List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15) = List.length (List.set state1 (Int.toNat id2) o12) → getElem! (List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15) ∘ Int.toNat = Function.update (getElem! (List.set state1 (Int.toNat id2) o12) ∘ Int.toNat) id1 o15 → (∀(o16 : bounded_int2), (let v : ℤ := model next + (1 : ℤ); model o16 = (if v = n then (0 : ℤ) else v)) → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass1[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match (List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass1[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass1[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ (List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]! ∧ (List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat (ticket1 ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]!))]! = i) ∧ (model o16 < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model o16 ∨ tvalue current ≤ i ∧ i < n → ¬released ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model o16 ≤ i ∧ i < tvalue current → released ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!))) ∧ (tvalue current < model o16 → (∀(i : ℤ), tvalue current ≤ i ∧ i < model o16 → ¬released ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model o16 ≤ i ∧ i < n → released ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!))) ∧ (model o16 = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat i]!)]!) = released ((List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat ((List.set (List.set tmap1 (Int.toNat o13) id1) (Int.toNat o14) id2)[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match (List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat j]! with | thread_state.Granted x => (match (List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match (List.set (List.set state1 (Int.toNat id2) o12) (Int.toNat id1) o15)[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True))))))))))) | _ => False))) else (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ pass1[Int.toNat i]! = true → i = tvalue current) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (match state1[Int.toNat i]! with | thread_state.Granted t => tvalue t = tvalue current ∧ pass1[Int.toNat (tvalue t)]! = true | thread_state.RelSet t => tvalue t = tvalue current ∧ ¬pass1[Int.toNat (tvalue t)]! = true | _ => True)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → (0 : ℤ) ≤ tmap1[Int.toNat i]! ∧ tmap1[Int.toNat i]! < n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → ticket1 (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = i) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → tmap1[Int.toNat (ticket1 (state1[Int.toNat i]!))]! = i) ∧ (model next < tvalue current → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < model next ∨ tvalue current ≤ i ∧ i < n → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), model next ≤ i ∧ i < tvalue current → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (tvalue current < model next → (∀(i : ℤ), tvalue current ≤ i ∧ i < model next → ¬released (state1[Int.toNat (tmap1[Int.toNat i]!)]!)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < tvalue current ∨ model next ≤ i ∧ i < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!))) ∧ (model next = tvalue current → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → released (state1[Int.toNat (tmap1[Int.toNat i]!)]!) = released (state1[Int.toNat (tmap1[Int.toNat j]!)]!))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < n → (match state1[Int.toNat j]! with | thread_state.Granted x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | thread_state.RelSet x => (match state1[Int.toNat i]! with | thread_state.Granted x1 => False | thread_state.RelSet x1 => False | _ => True) | _ => True)))))))))))))))))))))
  := sorry
end verifythis_2018_array_based_queuing_lock_1_Top_mainqtvc
