theory Firstorder_term_impl_Impl_nlsubst_fo_term_in_fo_termqtvc
  imports "NTP4Verif.NTP4Verif" "../../lib/isabelle/Firstorder_term_impl_Types" "../../lib/isabelle/Nat_Nat" "../../lib/isabelle/Functions_Config" "../../lib/isabelle/Functions_Func" "../../lib/isabelle/OptionFuncs_Funcs" "../../lib/isabelle/Sum_Sum" "../../lib/isabelle/Firstorder_symbol_spec_Spec" "../../lib/isabelle/Firstorder_symbol_impl_Types" "../../lib/isabelle/Firstorder_symbol_impl_Logic" "../../lib/isabelle/Firstorder_symbol_impl_Impl" "../../lib/isabelle/Firstorder_term_spec_Spec" "../../lib/isabelle/Firstorder_term_impl_Logic"
begin
theorem nlsubst_fo_term_in_fo_term'vc:
  fixes t :: "nlimpl_fo_term"
  fixes u :: "nlimpl_fo_term"
  fixes x :: "int"
  assumes fact0: "nlimpl_fo_term_ok t"
  assumes fact1: "nlimpl_fo_term_ok u"
  shows "let o1 :: (int, int) fo_term = subst_fo_term (model_fo_term_field t) subst_id_symbol (update (subst_id_fo_term :: int \<Rightarrow> (int, int) fo_term) x (model_fo_term_field u)) in (\<forall>(a :: int) (b :: int) (result :: int). (if a < b then result = b else result = a) \<longrightarrow> a \<le> result \<and> b \<le> result) \<and> (\<forall>(o2 :: int). nlfree_var_fo_term_set_abstraction_fo_term_field t \<le> o2 \<and> nlfree_var_fo_term_set_abstraction_fo_term_field u \<le> o2 \<longrightarrow> (\<forall>(a :: int) (b :: int) (result :: int). (if a < b then result = b else result = a) \<longrightarrow> a \<le> result \<and> b \<le> result) \<and> (\<forall>(o3 :: int). nlfree_var_symbol_set_abstraction_fo_term_field t \<le> o3 \<and> nlfree_var_symbol_set_abstraction_fo_term_field u \<le> o3 \<longrightarrow> (let o4 :: int \<Rightarrow> (int, int) fo_term = (const :: (int, int) fo_term \<Rightarrow> int \<Rightarrow> (int, int) fo_term) (Var_fo_term (-(1 :: int))); o5 :: int \<Rightarrow> (int, int) fo_term = (subst_id_fo_term :: int \<Rightarrow> (int, int) fo_term); o6 :: int \<Rightarrow> int symbol = (const :: int symbol \<Rightarrow> int \<Rightarrow> int symbol) (Var_symbol (-(1 :: int))); o7 :: int \<Rightarrow> int symbol = subst_id_symbol; o8 :: (int, int) nl_fo_term = nlrepr_fo_term_field u; o9 :: (int, int) nl_fo_term = nlrepr_fo_term_field t in (correct_indexes_fo_term o9 \<and> correct_indexes_fo_term o8 \<and> bound_depth_of_symbol_in_fo_term o8 = (0 :: int) \<and> bound_depth_of_fo_term_in_fo_term o8 = (0 :: int)) \<and> (\<forall>(o10 :: (int, int) nl_fo_term). correct_indexes_fo_term o10 \<and> bound_depth_of_symbol_in_fo_term o10 = bound_depth_of_symbol_in_fo_term o9 \<and> bound_depth_of_fo_term_in_fo_term o10 = bound_depth_of_fo_term_in_fo_term o9 \<and> nlmodel_fo_term o10 o7 o6 o5 o4 = nlmodel_fo_term o9 o7 o6 (update o5 x (nlmodel_fo_term o8 o7 ((const :: int symbol \<Rightarrow> int \<Rightarrow> int symbol) (Var_symbol (-(1 :: int)))) o5 ((const :: (int, int) fo_term \<Rightarrow> int \<Rightarrow> (int, int) fo_term) (Var_fo_term (-(1 :: int)))))) o4 \<longrightarrow> nlimpl_fo_term_ok (nlimpl_fo_term'mk o10 o3 o2 o1) \<and> o1 = subst_fo_term (model_fo_term_field t) subst_id_symbol (update (subst_id_fo_term :: int \<Rightarrow> (int, int) fo_term) x (model_fo_term_field u))))))"
  sorry
end
