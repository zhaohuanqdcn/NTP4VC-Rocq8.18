theory div_Div_reciprocal_word_3by2qtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_LogicalOld"
begin
definition reciprocal :: "64 word \<Rightarrow> 64 word \<Rightarrow> _"
  where "reciprocal v d \<longleftrightarrow> uint v = (((18446744073709551615 :: int) + (1 :: int)) * ((18446744073709551615 :: int) + (1 :: int)) - (1 :: int)) ediv uint d - ((18446744073709551615 :: int) + (1 :: int))" for v d
definition reciprocal_3by2 :: "64 word \<Rightarrow> 64 word \<Rightarrow> 64 word \<Rightarrow> _"
  where "reciprocal_3by2 v dh dl \<longleftrightarrow> uint v = (((18446744073709551615 :: int) + (1 :: int)) * ((18446744073709551615 :: int) + (1 :: int)) * ((18446744073709551615 :: int) + (1 :: int)) - (1 :: int)) ediv (uint dl + ((18446744073709551615 :: int) + (1 :: int)) * uint dh) - ((18446744073709551615 :: int) + (1 :: int))" for v dh dl
theorem reciprocal_word_3by2'vc:
  fixes dh :: "64 word"
  fixes dl :: "64 word"
  assumes fact0: "((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint dh"
  shows "((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint dh"
  and "\<forall>(o1 :: 64 word). reciprocal o1 dh \<longrightarrow> (\<forall>(o2 :: 64 word). uint o2 = uint dh * uint o1 emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(o3 :: 64 word). uint o3 = (uint o2 + uint dl) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (if uint o3 < uint dl then if uint dh \<le> uint o3 then uint'64_in_bounds (uint o1 - (1 :: int)) \<and> (\<forall>(o4 :: 64 word). uint o4 = uint o1 - (1 :: int) \<longrightarrow> uint'64_in_bounds (uint o3 - uint dh) \<and> (\<forall>(o5 :: 64 word). uint o5 = uint o3 - uint dh \<longrightarrow> uint'64_in_bounds (uint o4 - (1 :: int)) \<and> (\<forall>(o6 :: 64 word). uint o6 = uint o4 - (1 :: int) \<longrightarrow> (\<forall>(o7 :: 64 word). uint o7 = (uint o5 - uint dh) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(tl :: 64 word) (th :: 64 word). uint tl + ((18446744073709551615 :: int) + (1 :: int)) * uint th = uint o6 * uint dl \<longrightarrow> (\<forall>(o8 :: 64 word). uint o8 = (uint o7 + uint th) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (if uint o8 < uint th then \<forall>(o9 :: bool). (if uint dh < uint o8 then o9 = True else \<exists>(o10 :: bool). ((uint o8 = uint dh \<longrightarrow> o10 = True) \<and> (o10 = True \<longrightarrow> o8 = dh)) \<and> (if o10 = True then o9 = (if uint dl \<le> uint tl then True else False) else o9 = False)) \<longrightarrow> (if o9 = True then uint'64_in_bounds (uint o6 - (1 :: int)) \<and> (\<forall>(o10 :: 64 word). uint o10 = uint o6 - (1 :: int) \<longrightarrow> uint'64_in_bounds (uint o10 - (1 :: int)) \<and> (\<forall>(o11 :: 64 word). uint o11 = uint o10 - (1 :: int) \<longrightarrow> reciprocal_3by2 o11 dh dl)) else uint'64_in_bounds (uint o6 - (1 :: int)) \<and> (\<forall>(o10 :: 64 word). uint o10 = uint o6 - (1 :: int) \<longrightarrow> reciprocal_3by2 o10 dh dl)) else reciprocal_3by2 o6 dh dl))))))) else uint'64_in_bounds (uint o1 - (1 :: int)) \<and> (\<forall>(o4 :: 64 word). uint o4 = uint o1 - (1 :: int) \<longrightarrow> (\<forall>(o5 :: 64 word). uint o5 = (uint o3 - uint dh) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(tl :: 64 word) (th :: 64 word). uint tl + ((18446744073709551615 :: int) + (1 :: int)) * uint th = uint o4 * uint dl \<longrightarrow> (\<forall>(o6 :: 64 word). uint o6 = (uint o5 + uint th) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (if uint o6 < uint th then \<forall>(o7 :: bool). (if uint dh < uint o6 then o7 = True else \<exists>(o8 :: bool). ((uint o6 = uint dh \<longrightarrow> o8 = True) \<and> (o8 = True \<longrightarrow> o6 = dh)) \<and> (if o8 = True then o7 = (if uint dl \<le> uint tl then True else False) else o7 = False)) \<longrightarrow> (if o7 = True then uint'64_in_bounds (uint o4 - (1 :: int)) \<and> (\<forall>(o8 :: 64 word). uint o8 = uint o4 - (1 :: int) \<longrightarrow> uint'64_in_bounds (uint o8 - (1 :: int)) \<and> (\<forall>(o9 :: 64 word). uint o9 = uint o8 - (1 :: int) \<longrightarrow> reciprocal_3by2 o9 dh dl)) else uint'64_in_bounds (uint o4 - (1 :: int)) \<and> (\<forall>(o8 :: 64 word). uint o8 = uint o4 - (1 :: int) \<longrightarrow> reciprocal_3by2 o8 dh dl)) else reciprocal_3by2 o4 dh dl))))) else \<forall>(tl :: 64 word) (th :: 64 word). uint tl + ((18446744073709551615 :: int) + (1 :: int)) * uint th = uint o1 * uint dl \<longrightarrow> (\<forall>(o4 :: 64 word). uint o4 = (uint o3 + uint th) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (if uint o4 < uint th then \<forall>(o5 :: bool). (if uint dh < uint o4 then o5 = True else \<exists>(o6 :: bool). ((uint o4 = uint dh \<longrightarrow> o6 = True) \<and> (o6 = True \<longrightarrow> o4 = dh)) \<and> (if o6 = True then o5 = (if uint dl \<le> uint tl then True else False) else o5 = False)) \<longrightarrow> (if o5 = True then uint'64_in_bounds (uint o1 - (1 :: int)) \<and> (\<forall>(o6 :: 64 word). uint o6 = uint o1 - (1 :: int) \<longrightarrow> uint'64_in_bounds (uint o6 - (1 :: int)) \<and> (\<forall>(o7 :: 64 word). uint o7 = uint o6 - (1 :: int) \<longrightarrow> reciprocal_3by2 o7 dh dl)) else uint'64_in_bounds (uint o1 - (1 :: int)) \<and> (\<forall>(o6 :: 64 word). uint o6 = uint o1 - (1 :: int) \<longrightarrow> reciprocal_3by2 o6 dh dl)) else reciprocal_3by2 o1 dh dl)))))"
  sorry
end
