theory maximum_subarray_Algo4_maximum_subarrayqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_Sum" "./maximum_subarray_Spec"
begin
theorem maximum_subarray'vc:
  fixes a :: "int list"
  shows "let o1 :: int = int (length a) - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (0 :: int)) \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) = sum_list (drop (0 :: nat) (take ((0 :: nat) - (0 :: nat)) a))) \<and> (\<forall>(l' :: int) (h' :: int). (0 :: int) \<le> l' \<and> l' \<le> h' \<and> h' \<le> (0 :: int) \<longrightarrow> sum_list (drop (nat l') (take (nat h' - nat l') a)) \<le> (0 :: int)) \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) = sum_list (drop (0 :: nat) (take ((0 :: nat) - (0 :: nat)) a))) \<and> (\<forall>(l' :: int). (0 :: int) \<le> l' \<and> l' < (0 :: int) \<longrightarrow> sum_list (drop (nat l') (take ((0 :: nat) - nat l') a)) \<le> (0 :: int))) \<and> (\<forall>(s :: int) (l :: int) (ms :: int) (hi :: int) (lo :: int). (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o1) \<and> (((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> i) \<and> (0 :: int) \<le> ms \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> (\<forall>(l' :: int) (h' :: int). (0 :: int) \<le> l' \<and> l' \<le> h' \<and> h' \<le> i \<longrightarrow> sum_list (drop (nat l') (take (nat h' - nat l') a)) \<le> ms) \<and> (((0 :: int) \<le> l \<and> l \<le> i) \<and> s = sum_list (drop (nat l) (take (nat i - nat l) a))) \<and> (\<forall>(l' :: int). (0 :: int) \<le> l' \<and> l' < i \<longrightarrow> sum_list (drop (nat l') (take (nat i - nat l') a)) \<le> s) \<longrightarrow> (if s < (0 :: int) then ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if ms < a ! nat i then (((0 :: int) \<le> i \<and> i \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> (0 :: int) \<le> a ! nat i \<and> a ! nat i = sum_list (drop (nat i) (take (nat (i + (1 :: int)) - nat i) a))) \<and> (\<forall>(l' :: int) (h' :: int). (0 :: int) \<le> l' \<and> l' \<le> h' \<and> h' \<le> i + (1 :: int) \<longrightarrow> sum_list (drop (nat l') (take (nat h' - nat l') a)) \<le> a ! nat i) \<and> (((0 :: int) \<le> i \<and> i \<le> i + (1 :: int)) \<and> a ! nat i = sum_list (drop (nat i) (take (nat (i + (1 :: int)) - nat i) a))) \<and> (\<forall>(l' :: int). (0 :: int) \<le> l' \<and> l' < i + (1 :: int) \<longrightarrow> sum_list (drop (nat l') (take (nat (i + (1 :: int)) - nat l') a)) \<le> a ! nat i) else (((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> i + (1 :: int)) \<and> (0 :: int) \<le> ms \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> (\<forall>(l' :: int) (h' :: int). (0 :: int) \<le> l' \<and> l' \<le> h' \<and> h' \<le> i + (1 :: int) \<longrightarrow> sum_list (drop (nat l') (take (nat h' - nat l') a)) \<le> ms) \<and> (((0 :: int) \<le> i \<and> i \<le> i + (1 :: int)) \<and> a ! nat i = sum_list (drop (nat i) (take (nat (i + (1 :: int)) - nat i) a))) \<and> (\<forall>(l' :: int). (0 :: int) \<le> l' \<and> l' < i + (1 :: int) \<longrightarrow> sum_list (drop (nat l') (take (nat (i + (1 :: int)) - nat l') a)) \<le> a ! nat i)) else ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if ms < s + a ! nat i then (((0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> (0 :: int) \<le> s + a ! nat i \<and> s + a ! nat i = sum_list (drop (nat l) (take (nat (i + (1 :: int)) - nat l) a))) \<and> (\<forall>(l' :: int) (h' :: int). (0 :: int) \<le> l' \<and> l' \<le> h' \<and> h' \<le> i + (1 :: int) \<longrightarrow> sum_list (drop (nat l') (take (nat h' - nat l') a)) \<le> s + a ! nat i) \<and> (((0 :: int) \<le> l \<and> l \<le> i + (1 :: int)) \<and> s + a ! nat i = sum_list (drop (nat l) (take (nat (i + (1 :: int)) - nat l) a))) \<and> (\<forall>(l' :: int). (0 :: int) \<le> l' \<and> l' < i + (1 :: int) \<longrightarrow> sum_list (drop (nat l') (take (nat (i + (1 :: int)) - nat l') a)) \<le> s + a ! nat i) else (((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> i + (1 :: int)) \<and> (0 :: int) \<le> ms \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> (\<forall>(l' :: int) (h' :: int). (0 :: int) \<le> l' \<and> l' \<le> h' \<and> h' \<le> i + (1 :: int) \<longrightarrow> sum_list (drop (nat l') (take (nat h' - nat l') a)) \<le> ms) \<and> (((0 :: int) \<le> l \<and> l \<le> i + (1 :: int)) \<and> s + a ! nat i = sum_list (drop (nat l) (take (nat (i + (1 :: int)) - nat l) a))) \<and> (\<forall>(l' :: int). (0 :: int) \<le> l' \<and> l' < i + (1 :: int) \<longrightarrow> sum_list (drop (nat l') (take (nat (i + (1 :: int)) - nat l') a)) \<le> s + a ! nat i)))) \<and> ((((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> o1 + (1 :: int)) \<and> (0 :: int) \<le> ms \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> (\<forall>(l' :: int) (h' :: int). (0 :: int) \<le> l' \<and> l' \<le> h' \<and> h' \<le> o1 + (1 :: int) \<longrightarrow> sum_list (drop (nat l') (take (nat h' - nat l') a)) \<le> ms) \<and> (((0 :: int) \<le> l \<and> l \<le> o1 + (1 :: int)) \<and> s = sum_list (drop (nat l) (take (nat (o1 + (1 :: int)) - nat l) a))) \<and> (\<forall>(l' :: int). (0 :: int) \<le> l' \<and> l' < o1 + (1 :: int) \<longrightarrow> sum_list (drop (nat l') (take (nat (o1 + (1 :: int)) - nat l') a)) \<le> s) \<longrightarrow> (((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> int (length a)) \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> maxsub a ms))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> int (length a)) \<and> (0 :: int) = sum_list (drop (0 :: nat) (take ((0 :: nat) - (0 :: nat)) a))) \<and> maxsub a (0 :: int))"
  sorry
end
