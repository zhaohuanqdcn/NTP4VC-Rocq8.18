import Why3.Base
import Why3.why3.Ref.Ref
import Why3.exn.Exn
open Classical
open Lean4Why3
namespace verifythis_2019_cartesian_trees_Top_smaller_leftqtvc
axiom Trans (y : ℤ) (x : ℤ) (z : ℤ) (fact0 : y ≤ x) (fact1 : z ≤ y) : z ≤ x
inductive sorted : List ℤ -> Prop where
 | Sorted_Nil : sorted ([] : List ℤ)
 | Sorted_One (x : ℤ) : sorted (List.cons x ([] : List ℤ))
 | Sorted_Two (y : ℤ) (x : ℤ) (l : List ℤ) : y ≤ x → sorted (List.cons y l) → sorted (List.cons x (List.cons y l))
axiom sorted_mem (l : List ℤ) (x : ℤ) : ((∀(y : ℤ), y ∈ l → y ≤ x) ∧ sorted l) = sorted (List.cons x l)
axiom sorted_append (l1 : List ℤ) (l2 : List ℤ) : (sorted l1 ∧ sorted l2 ∧ (∀(x : ℤ) (y : ℤ), x ∈ l1 → y ∈ l2 → y ≤ x)) = sorted (l1 ++ l2)
axiom destruct :  {ty'xi : Type} -> [Inhabited ty'xi] -> List ty'xi -> ty'xi × List ty'xi
axiom destruct'def {ty'xi : Type} [Inhabited ty'xi] (l : List ty'xi) (fact0 : ¬is_nil l) : match l with | List.cons h t => destruct l = (h, t) | _ => False
axiom peek :  {ty'xi : Type} -> [Inhabited ty'xi] -> List ty'xi -> ty'xi
axiom peek'def {ty'xi : Type} [Inhabited ty'xi] (l : List ty'xi) (fact0 : ¬is_nil l) : match destruct l with | (h, _) => peek l = h
axiom peek'spec {ty'xi : Type} [Inhabited ty'xi] (l : List ty'xi) (fact0 : ¬is_nil l) : peek l ∈ l
axiom tail :  {ty'xi : Type} -> [Inhabited ty'xi] -> List ty'xi -> List ty'xi
axiom tail'def {ty'xi : Type} [Inhabited ty'xi] (l : List ty'xi) (fact0 : ¬is_nil l) : match destruct l with | (_, t) => tail l = t
theorem smaller_left'vc (s : List ℤ) : let n : ℤ := Int.ofNat (List.length s); (0 : ℤ) ≤ n ∧ (∀(left1 : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → left1[Int.toNat i]! = -(1 : ℤ)) ∧ Int.ofNat (List.length left1) = n → (let o1 : ℤ := Int.ofNat (List.length s) - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → ((∀(z : ℤ), z ∈ ([] : List ℤ) → (0 : ℤ) ≤ z ∧ z < (0 : ℤ)) ∧ (¬is_nil ([] : List ℤ) → peek ([] : List ℤ) = (0 : ℤ) - (1 : ℤ)) ∧ sorted ([] : List ℤ) ∧ (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < (0 : ℤ) → left1[Int.toNat y]! < y) ∧ (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < (0 : ℤ) → (0 : ℤ) ≤ left1[Int.toNat y]! → s[Int.toNat (left1[Int.toNat y]!)]! < s[Int.toNat y]!) ∧ (∀(z : ℤ), (0 : ℤ) ≤ z ∧ z < (0 : ℤ) → (∃(y : ℤ), (z ≤ y ∧ y < (0 : ℤ)) ∧ y ∈ ([] : List ℤ) ∧ s[Int.toNat y]! ≤ s[Int.toNat z]!)) ∧ (∀(y : ℤ) (z : ℤ), (0 : ℤ) ≤ y ∧ y < (0 : ℤ) → left1[Int.toNat y]! < z ∧ z < y → s[Int.toNat y]! ≤ s[Int.toNat z]!)) ∧ (∀(my_stack : List ℤ) (left2 : List ℤ), List.length left2 = List.length left1 → (∀(x : ℤ), ((0 : ℤ) ≤ x ∧ x ≤ o1) ∧ (∀(z : ℤ), z ∈ my_stack → (0 : ℤ) ≤ z ∧ z < x) ∧ (is_nil my_stack → x = (0 : ℤ)) ∧ (¬is_nil my_stack → peek my_stack = x - (1 : ℤ)) ∧ sorted my_stack ∧ (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < x → left2[Int.toNat y]! < y) ∧ (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < x → (0 : ℤ) ≤ left2[Int.toNat y]! → s[Int.toNat (left2[Int.toNat y]!)]! < s[Int.toNat y]!) ∧ (∀(z : ℤ), (0 : ℤ) ≤ z ∧ z < x → (∃(y : ℤ), (z ≤ y ∧ y < x) ∧ y ∈ my_stack ∧ s[Int.toNat y]! ≤ s[Int.toNat z]!)) ∧ (∀(y : ℤ) (z : ℤ), (0 : ℤ) ≤ y ∧ y < x → left2[Int.toNat y]! < z ∧ z < y → s[Int.toNat y]! ≤ s[Int.toNat z]!) → ((∀(z : ℤ), z ∈ my_stack → (0 : ℤ) ≤ z ∧ z < x) ∧ sorted my_stack ∧ (∀(z : ℤ), z ∈ my_stack → s[Int.toNat x]! ≤ s[Int.toNat z]! ∨ z ∈ my_stack) ∧ (∀(z : ℤ), ¬is_nil my_stack → z ∈ my_stack → z ≤ peek my_stack) ∧ (∀(z : ℤ), ¬is_nil my_stack → peek my_stack < z ∧ z < x → s[Int.toNat x]! ≤ s[Int.toNat z]!) ∧ (∀(z : ℤ), is_nil my_stack → (0 : ℤ) ≤ z ∧ z < x → s[Int.toNat x]! ≤ s[Int.toNat z]!)) ∧ (∀(my_stack1 : List ℤ), (∀(z : ℤ), z ∈ my_stack1 → (0 : ℤ) ≤ z ∧ z < x) ∧ sorted my_stack1 ∧ (∀(z : ℤ), z ∈ my_stack → s[Int.toNat x]! ≤ s[Int.toNat z]! ∨ z ∈ my_stack1) ∧ (∀(z : ℤ), ¬is_nil my_stack1 → z ∈ my_stack1 → z ≤ peek my_stack1) ∧ (∀(z : ℤ), ¬is_nil my_stack1 → peek my_stack1 < z ∧ z < x → s[Int.toNat x]! ≤ s[Int.toNat z]!) ∧ (∀(z : ℤ), is_nil my_stack1 → (0 : ℤ) ≤ z ∧ z < x → s[Int.toNat x]! ≤ s[Int.toNat z]!) → is_nil my_stack1 = (my_stack1 = ([] : List ℤ)) → (¬is_nil my_stack1 → ((0 : ℤ) ≤ x ∧ x < Int.ofNat (List.length s)) ∧ ¬is_nil my_stack1 ∧ (let o2 : ℤ := peek my_stack1; o2 ∈ my_stack1 → (0 : ℤ) ≤ o2 ∧ o2 < Int.ofNat (List.length s))) ∧ (∀(o2 : Bool), (if ¬is_nil my_stack1 then let o3 : ℤ := peek my_stack1; o3 ∈ my_stack1 ∧ o2 = (if s[Int.toNat x]! ≤ s[Int.toNat o3]! then true else false) else o2 = false) → (if o2 = true then ¬is_nil my_stack1 ∧ ((0 : ℤ) ≤ Int.ofNat (List.length my_stack1) ∧ List.length (tail my_stack1) < List.length my_stack1) ∧ (∀(z : ℤ), z ∈ tail my_stack1 → (0 : ℤ) ≤ z ∧ z < x) ∧ sorted (tail my_stack1) ∧ (∀(z : ℤ), z ∈ my_stack → s[Int.toNat x]! ≤ s[Int.toNat z]! ∨ z ∈ tail my_stack1) ∧ (∀(z : ℤ), ¬is_nil (tail my_stack1) → z ∈ tail my_stack1 → z ≤ peek (tail my_stack1)) ∧ (∀(z : ℤ), ¬is_nil (tail my_stack1) → peek (tail my_stack1) < z ∧ z < x → s[Int.toNat x]! ≤ s[Int.toNat z]!) ∧ (∀(z : ℤ), is_nil (tail my_stack1) → (0 : ℤ) ≤ z ∧ z < x → s[Int.toNat x]! ≤ s[Int.toNat z]!) else is_nil my_stack1 = (my_stack1 = ([] : List ℤ)) → (if is_nil my_stack1 then ((0 : ℤ) ≤ x ∧ x < Int.ofNat (List.length left2)) ∧ (List.length (List.set left2 (Int.toNat x) (-(1 : ℤ))) = List.length left2 → getElem! (List.set left2 (Int.toNat x) (-(1 : ℤ))) ∘ Int.toNat = Function.update (getElem! left2 ∘ Int.toNat) x (-(1 : ℤ)) → (∀(z : ℤ), z ∈ List.cons x my_stack1 → (0 : ℤ) ≤ z ∧ z < x + (1 : ℤ)) ∧ (is_nil (List.cons x my_stack1) → x + (1 : ℤ) = (0 : ℤ)) ∧ (¬is_nil (List.cons x my_stack1) → peek (List.cons x my_stack1) = x + (1 : ℤ) - (1 : ℤ)) ∧ sorted (List.cons x my_stack1) ∧ (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < x + (1 : ℤ) → (List.set left2 (Int.toNat x) (-(1 : ℤ)))[Int.toNat y]! < y) ∧ (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < x + (1 : ℤ) → (0 : ℤ) ≤ (List.set left2 (Int.toNat x) (-(1 : ℤ)))[Int.toNat y]! → s[Int.toNat ((List.set left2 (Int.toNat x) (-(1 : ℤ)))[Int.toNat y]!)]! < s[Int.toNat y]!) ∧ (∀(z : ℤ), (0 : ℤ) ≤ z ∧ z < x + (1 : ℤ) → (∃(y : ℤ), (z ≤ y ∧ y < x + (1 : ℤ)) ∧ y ∈ List.cons x my_stack1 ∧ s[Int.toNat y]! ≤ s[Int.toNat z]!)) ∧ (∀(y : ℤ) (z : ℤ), (0 : ℤ) ≤ y ∧ y < x + (1 : ℤ) → (List.set left2 (Int.toNat x) (-(1 : ℤ)))[Int.toNat y]! < z ∧ z < y → s[Int.toNat y]! ≤ s[Int.toNat z]!)) else ¬is_nil my_stack1 ∧ (let o3 : ℤ := peek my_stack1; o3 ∈ my_stack1 → ((0 : ℤ) ≤ x ∧ x < Int.ofNat (List.length left2)) ∧ (List.length (List.set left2 (Int.toNat x) o3) = List.length left2 → getElem! (List.set left2 (Int.toNat x) o3) ∘ Int.toNat = Function.update (getElem! left2 ∘ Int.toNat) x o3 → (∀(z : ℤ), z ∈ List.cons x my_stack1 → (0 : ℤ) ≤ z ∧ z < x + (1 : ℤ)) ∧ (is_nil (List.cons x my_stack1) → x + (1 : ℤ) = (0 : ℤ)) ∧ (¬is_nil (List.cons x my_stack1) → peek (List.cons x my_stack1) = x + (1 : ℤ) - (1 : ℤ)) ∧ sorted (List.cons x my_stack1) ∧ (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < x + (1 : ℤ) → (List.set left2 (Int.toNat x) o3)[Int.toNat y]! < y) ∧ (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < x + (1 : ℤ) → (0 : ℤ) ≤ (List.set left2 (Int.toNat x) o3)[Int.toNat y]! → s[Int.toNat ((List.set left2 (Int.toNat x) o3)[Int.toNat y]!)]! < s[Int.toNat y]!) ∧ (∀(z : ℤ), (0 : ℤ) ≤ z ∧ z < x + (1 : ℤ) → (∃(y : ℤ), (z ≤ y ∧ y < x + (1 : ℤ)) ∧ y ∈ List.cons x my_stack1 ∧ s[Int.toNat y]! ≤ s[Int.toNat z]!)) ∧ (∀(y : ℤ) (z : ℤ), (0 : ℤ) ≤ y ∧ y < x + (1 : ℤ) → (List.set left2 (Int.toNat x) o3)[Int.toNat y]! < z ∧ z < y → s[Int.toNat y]! ≤ s[Int.toNat z]!)))))))) ∧ ((∀(z : ℤ), z ∈ my_stack → (0 : ℤ) ≤ z ∧ z < o1 + (1 : ℤ)) ∧ (is_nil my_stack → o1 + (1 : ℤ) = (0 : ℤ)) ∧ (¬is_nil my_stack → peek my_stack = o1 + (1 : ℤ) - (1 : ℤ)) ∧ sorted my_stack ∧ (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < o1 + (1 : ℤ) → left2[Int.toNat y]! < y) ∧ (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < o1 + (1 : ℤ) → (0 : ℤ) ≤ left2[Int.toNat y]! → s[Int.toNat (left2[Int.toNat y]!)]! < s[Int.toNat y]!) ∧ (∀(z : ℤ), (0 : ℤ) ≤ z ∧ z < o1 + (1 : ℤ) → (∃(y : ℤ), (z ≤ y ∧ y < o1 + (1 : ℤ)) ∧ y ∈ my_stack ∧ s[Int.toNat y]! ≤ s[Int.toNat z]!)) ∧ (∀(y : ℤ) (z : ℤ), (0 : ℤ) ≤ y ∧ y < o1 + (1 : ℤ) → left2[Int.toNat y]! < z ∧ z < y → s[Int.toNat y]! ≤ s[Int.toNat z]!) → (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < Int.ofNat (List.length s) → left2[Int.toNat y]! < y) ∧ (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < Int.ofNat (List.length s) → (0 : ℤ) ≤ left2[Int.toNat y]! → s[Int.toNat (left2[Int.toNat y]!)]! < s[Int.toNat y]!) ∧ (∀(x : ℤ) (z : ℤ), (0 : ℤ) ≤ x ∧ x < Int.ofNat (List.length s) → left2[Int.toNat x]! < z ∧ z < x → s[Int.toNat x]! ≤ s[Int.toNat z]!) ∧ List.length left2 = List.length s))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < Int.ofNat (List.length s) → left1[Int.toNat y]! < y) ∧ (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < Int.ofNat (List.length s) → (0 : ℤ) ≤ left1[Int.toNat y]! → s[Int.toNat (left1[Int.toNat y]!)]! < s[Int.toNat y]!) ∧ (∀(x : ℤ) (z : ℤ), (0 : ℤ) ≤ x ∧ x < Int.ofNat (List.length s) → left1[Int.toNat x]! < z ∧ z < x → s[Int.toNat x]! ≤ s[Int.toNat z]!) ∧ List.length left1 = List.length s)))
  := sorry
end verifythis_2019_cartesian_trees_Top_smaller_leftqtvc
