theory sqrtrem_Sqrt_wmpn_sqrtremqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "Why3STD.real_Truncate" "mach.c_C" "mach.int_Unsigned" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_1_Sub_1" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/sqrt_Sqrt1" "mach.fxp_Fxp" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/valuation_Valuation"
begin
definition ceilhalf :: "int \<Rightarrow> int"
  where "ceilhalf n = (n + (1 :: int)) cdiv (2 :: int)" for n
axiomatization where ceilhalf'spec'0:   "n \<le> (2 :: int) * ceilhalf n"
  for n :: "int"
axiomatization where ceilhalf'spec:   "n < (2 :: int) * (ceilhalf n + (1 :: int))"
  for n :: "int"
theorem wmpn_sqrtrem'vc:
  fixes sp :: "64 word ptr"
  fixes n :: "32 word"
  fixes rp :: "64 word ptr"
  fixes np :: "64 word ptr"
  assumes fact0: "valid sp (ceilhalf (sint n))"
  assumes fact1: "valid rp (sint n)"
  assumes fact2: "valid np (sint n)"
  assumes fact3: "writable sp = True"
  assumes fact4: "writable rp = True"
  assumes fact5: "writable np = True"
  assumes fact6: "(1 :: int) \<le> sint n"
  assumes fact7: "(4 :: int) * sint n < (2147483647 :: int)"
  assumes fact8: "(0 :: int) < uint (pelts np (offset np + sint n - (1 :: int)))"
  shows "let o1 :: int = sint n; k :: int = ceilhalf o1 in o1 \<le> (2 :: int) * k \<and> o1 < (2 :: int) * (k + (1 :: int)) \<longrightarrow> int'32_in_bounds (sint n - (1 :: int)) \<and> (\<forall>(o2 :: 32 word). sint o2 = sint n - (1 :: int) \<longrightarrow> (c_C.min np \<le> offset np + sint o2 \<and> offset np + sint o2 < c_C.max np) \<and> (let high :: 64 word = pelts np (offset np + sint o2) in (0 :: int) < uint high \<and> (\<forall>(o3 :: 32 word). (2 :: int) ^\<^sub>i sint o3 * uint high \<le> (18446744073709551615 :: int) \<and> (18446744073709551615 :: int) < (2 :: int) * (2 :: int) ^\<^sub>i sint o3 * uint high \<and> (0 :: int) \<le> sint o3 \<and> sint o3 < (64 :: int) \<longrightarrow> (0 :: int) \<le> sint o3 \<and> (\<forall>(o4 :: 64 word). uint o4 = sint o3 \<longrightarrow> (\<not>(2 :: int) = (0 :: int) \<and> uint'64_in_bounds (uint o4 cdiv (2 :: int))) \<and> (\<forall>(o5 :: 64 word). uint o5 = uint o4 cdiv (2 :: int) \<longrightarrow> (\<forall>(o6 :: bool). (sint n = sint (1 :: 32 word) \<longrightarrow> o6 = True) \<and> (o6 = True \<longrightarrow> n = (1 :: 32 word)) \<longrightarrow> (if o6 = True then \<forall>(o7 :: bool). (uint o5 = uint (0 :: 64 word) \<longrightarrow> o7 = True) \<and> (o7 = True \<longrightarrow> o5 = (0 :: 64 word)) \<longrightarrow> (if o7 = True then (valid rp (1 :: int) \<and> (4611686018427387904 :: int) \<le> uint high \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(s :: 64 word). (uint s * uint s \<le> uint high \<and> uint high < (uint s + (1 :: int)) * (uint s + (1 :: int))) \<and> uint s * uint s + uint (pelts rp1 (offset rp1)) = uint high \<and> uint (pelts rp1 (offset rp1)) \<le> (2 :: int) * uint s \<longrightarrow> ((c_C.min sp \<le> offset sp \<and> offset sp < c_C.max sp) \<and> writable sp = True) \<and> (\<forall>(sp1 :: 64 word ptr). length (data sp1) = length (data sp) \<and> offset sp1 = offset sp \<and> c_C.min sp1 = c_C.min sp \<and> c_C.max sp1 = c_C.max sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> pelts sp1 = (pelts sp)(offset sp1 := s) \<longrightarrow> (c_C.min rp1 \<le> offset rp1 \<and> offset rp1 < c_C.max rp1) \<and> (let o8 :: 64 word = pelts rp1 (offset rp1) in \<forall>(o9 :: bool). (uint o8 = uint (0 :: 64 word) \<longrightarrow> o9 = True) \<and> (o9 = True \<longrightarrow> o8 = (0 :: 64 word)) \<longrightarrow> (\<forall>(res :: 32 word). (if o9 = True then res = (0 :: 32 word) else res = (1 :: 32 word)) \<longrightarrow> value np (sint n) = value sp1 (ceilhalf (sint n)) * value sp1 (ceilhalf (sint n)) + value rp1 (sint res) \<and> ((0 :: int) \<le> sint res \<and> sint res \<le> sint n) \<and> value rp1 (sint res) \<le> (2 :: int) * value sp1 (ceilhalf (sint n)) \<and> ((0 :: int) < sint res \<longrightarrow> (0 :: int) < uint (pelts rp1 (offset rp1 + sint res - (1 :: int)))) \<and> c_C.max rp1 = c_C.max rp \<and> c_C.min rp1 = c_C.min rp \<and> plength rp1 = plength rp \<and> c_C.max sp1 = c_C.max sp \<and> c_C.min sp1 = c_C.min sp \<and> plength sp1 = plength sp))))) else uint'64_in_bounds ((2 :: int) * uint o5) \<and> (\<forall>(o8 :: 64 word). uint o8 = (2 :: int) * uint o5 \<longrightarrow> (((0 :: int) \<le> uint o8 \<and> uint o8 < (64 :: int)) \<and> (2 :: int) ^\<^sub>i uint o8 * uint high \<le> (18446744073709551615 :: int)) \<and> (\<forall>(nh :: 64 word). uint nh = (2 :: int) ^\<^sub>i uint o8 * uint high \<longrightarrow> (valid rp (1 :: int) \<and> (4611686018427387904 :: int) \<le> uint nh \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(ncc :: 64 word). (uint ncc * uint ncc \<le> uint nh \<and> uint nh < (uint ncc + (1 :: int)) * (uint ncc + (1 :: int))) \<and> uint ncc * uint ncc + uint (pelts rp1 (offset rp1)) = uint nh \<and> uint (pelts rp1 (offset rp1)) \<le> (2 :: int) * uint ncc \<longrightarrow> ((0 :: int) \<le> uint o5 \<and> uint o5 < (64 :: int)) \<and> (\<forall>(cc :: 64 word). uint cc = uint ncc ediv (2 :: int) ^\<^sub>i uint o5 \<longrightarrow> ((c_C.min sp \<le> offset sp \<and> offset sp < c_C.max sp) \<and> writable sp = True) \<and> (\<forall>(sp1 :: 64 word ptr). length (data sp1) = length (data sp) \<and> offset sp1 = offset sp \<and> c_C.min sp1 = c_C.min sp \<and> c_C.max sp1 = c_C.max sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> pelts sp1 = (pelts sp)(offset sp1 := cc) \<longrightarrow> uint'64_in_bounds (uint cc * uint cc) \<and> (\<forall>(o9 :: 64 word). uint o9 = uint cc * uint cc \<longrightarrow> uint'64_in_bounds (uint high - uint o9) \<and> (\<forall>(o10 :: 64 word). uint o10 = uint high - uint o9 \<longrightarrow> ((c_C.min rp1 \<le> offset rp1 \<and> offset rp1 < c_C.max rp1) \<and> writable rp1 = True) \<and> (\<forall>(rp2 :: 64 word ptr). length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> pelts rp2 = (pelts rp1)(offset rp2 := o10) \<longrightarrow> (c_C.min rp2 \<le> offset rp2 \<and> offset rp2 < c_C.max rp2) \<and> (let o11 :: 64 word = pelts rp2 (offset rp2) in \<forall>(o12 :: bool). (uint o11 = uint (0 :: 64 word) \<longrightarrow> o12 = True) \<and> (o12 = True \<longrightarrow> o11 = (0 :: 64 word)) \<longrightarrow> (\<forall>(res :: 32 word). (if o12 = True then res = (0 :: 32 word) else res = (1 :: 32 word)) \<longrightarrow> value np (sint n) = value sp1 (ceilhalf (sint n)) * value sp1 (ceilhalf (sint n)) + value rp2 (sint res) \<and> ((0 :: int) \<le> sint res \<and> sint res \<le> sint n) \<and> value rp2 (sint res) \<le> (2 :: int) * value sp1 (ceilhalf (sint n)) \<and> ((0 :: int) < sint res \<longrightarrow> (0 :: int) < uint (pelts rp2 (offset rp2 + sint res - (1 :: int)))) \<and> c_C.max rp2 = c_C.max rp \<and> c_C.min rp2 = c_C.min rp \<and> plength rp2 = plength rp \<and> c_C.max sp1 = c_C.max sp \<and> c_C.min sp1 = c_C.min sp \<and> plength sp1 = plength sp)))))))))))) else int'32_in_bounds (sint n + (1 :: int)) \<and> (\<forall>(o7 :: 32 word). sint o7 = sint n + (1 :: int) \<longrightarrow> (\<not>(2 :: int) = (0 :: int) \<and> int'32_in_bounds (sint o7 cdiv (2 :: int))) \<and> (\<forall>(o8 :: 32 word). sint o8 = sint o7 cdiv (2 :: int) \<longrightarrow> (0 :: int) \<le> sint n \<and> (\<forall>(o9 :: 64 word). uint o9 = sint n \<longrightarrow> (\<not>(2 :: int) = (0 :: int) \<and> uint'64_in_bounds (uint o9 cmod (2 :: int))) \<and> (\<forall>(o10 :: 64 word). uint o10 = uint o9 cmod (2 :: int) \<longrightarrow> uint o10 \<le> (2147483647 :: int) \<and> (\<forall>(adj :: 32 word). sint adj = uint o10 \<longrightarrow> (0 :: int) \<le> sint o8 \<and> (\<forall>(o11 :: 32 word). uint o11 = sint o8 \<longrightarrow> (\<not>(2 :: int) = (0 :: int) \<and> uint'32_in_bounds (uint o11 cdiv (2 :: int))) \<and> (\<forall>(o12 :: 32 word). uint o12 = uint o11 cdiv (2 :: int) \<longrightarrow> uint'32_in_bounds (uint o12 + (1 :: int)) \<and> (\<forall>(o13 :: 32 word). uint o13 = uint o12 + (1 :: int) \<longrightarrow> (0 :: int) \<le> uint o13 \<and> (\<forall>(scratch :: 64 word ptr). plength scratch = uint o13 \<and> offset scratch = (0 :: int) \<and> c_C.min scratch = (0 :: int) \<and> c_C.max scratch = uint o13 \<and> writable scratch = True \<longrightarrow> (\<forall>(o14 :: bool). (sint adj = sint (0 :: 32 word) \<longrightarrow> o14 = True) \<and> (o14 = True \<longrightarrow> adj = (0 :: 32 word)) \<longrightarrow> (\<forall>(o15 :: bool). (if \<not>o14 = True then o15 = True else \<exists>(o16 :: bool). ((uint o5 = uint (0 :: 64 word) \<longrightarrow> o16 = True) \<and> (o16 = True \<longrightarrow> o5 = (0 :: 64 word))) \<and> o15 = (if o16 = True then False else True)) \<longrightarrow> (if o15 = True then (0 :: int) \<le> sint o8 \<and> (\<forall>(o16 :: 32 word). uint o16 = sint o8 \<longrightarrow> uint'32_in_bounds ((2 :: int) * uint o16) \<and> (\<forall>(o17 :: 32 word). uint o17 = (2 :: int) * uint o16 \<longrightarrow> (0 :: int) \<le> uint o17 \<and> (\<forall>(o18 :: 64 word ptr). plength o18 = uint o17 \<and> offset o18 = (0 :: int) \<and> c_C.min o18 = (0 :: int) \<and> c_C.max o18 = uint o17 \<and> writable o18 = True \<longrightarrow> ((c_C.min o18 \<le> offset o18 \<and> offset o18 < c_C.max o18) \<and> writable o18 = True) \<and> (\<forall>(tp :: 64 word ptr). length (data tp) = length (data o18) \<and> offset tp = offset o18 \<and> c_C.min tp = c_C.min o18 \<and> c_C.max tp = c_C.max o18 \<and> writable tp = writable o18 \<and> zone1 tp = zone1 o18 \<longrightarrow> length (data tp) = length (data o18) \<and> offset tp = offset o18 \<and> c_C.min tp = c_C.min o18 \<and> c_C.max tp = c_C.max o18 \<and> writable tp = writable o18 \<and> zone1 tp = zone1 o18 \<longrightarrow> pelts tp = (pelts o18)(offset tp := 0 :: 64 word) \<longrightarrow> (((0 :: int) \<le> sint adj \<and> (c_C.min tp \<le> offset tp + sint adj \<and> offset tp + sint adj \<le> c_C.max tp) \<and> writable tp = True) \<and> (\<forall>(tp1 :: 64 word ptr). offset tp1 = offset tp \<and> c_C.min tp1 = c_C.min tp \<and> writable tp1 = writable tp \<and> zone1 tp1 = zone1 tp \<longrightarrow> offset tp1 = offset tp \<and> c_C.min tp1 = c_C.min tp \<and> writable tp1 = writable tp \<and> zone1 tp1 = zone1 tp \<longrightarrow> (\<forall>(tpa :: 64 word ptr). writable tpa = True \<and> offset tpa = offset tp1 + sint adj \<and> c_C.max tp1 = offset tp1 + sint adj \<and> c_C.min tpa = offset tp1 + sint adj \<and> c_C.max tpa = c_C.max tp \<and> zone1 tpa = zone1 tp1 \<and> pelts tp1 = pelts tp \<and> plength tp1 = plength tp \<and> pelts tpa = pelts tp \<and> plength tpa = plength tp \<longrightarrow> (\<forall>(o19 :: bool). (uint o5 = uint (0 :: 64 word) \<longrightarrow> o19 = True) \<and> (o19 = True \<longrightarrow> o5 = (0 :: 64 word)) \<longrightarrow> (if \<not>o19 = True then uint'64_in_bounds ((2 :: int) * uint o5) \<and> (\<forall>(o20 :: 64 word). uint o20 = (2 :: int) * uint o5 \<longrightarrow> (((0 :: int) < uint o20 \<and> uint o20 < (64 :: int)) \<and> valid tpa (sint n) \<and> valid np (sint n) \<and> writable tpa = True \<and> (0 :: int) < sint n) \<and> (\<forall>(tpa1 :: 64 word ptr) (np1 :: 64 word ptr). offset tpa1 = offset tpa \<and> writable tpa1 = writable tpa \<and> zone1 tpa1 = zone1 tpa \<longrightarrow> offset np1 = offset np \<and> writable np1 = writable np \<and> zone1 np1 = zone1 np \<longrightarrow> (\<forall>(h :: 64 word). value tpa1 (sint n) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint n * uint h = value np (sint n) * (2 :: int) ^\<^sub>i uint o20 \<and> (\<forall>(j :: int). j < offset tpa1 \<or> offset tpa1 + sint n \<le> j \<longrightarrow> pelts tpa1 j = pelts tpa j) \<and> (\<forall>(j :: int). pelts np1 j = pelts np j) \<and> (c_C.min tpa1 = c_C.min tpa \<and> c_C.max tpa1 = c_C.max tpa \<and> plength tpa1 = plength tpa) \<and> c_C.min np1 = c_C.min np \<and> c_C.max np1 = c_C.max np \<and> plength np1 = plength np \<longrightarrow> (zone1 tp1 = zone1 tpa1 \<and> c_C.max tp1 = c_C.min tpa1 \<and> writable tp1 = True \<and> writable tpa1 = True) \<and> (\<forall>(tp2 :: 64 word ptr). length (data tp2) = length (data tp1) \<and> offset tp2 = offset tp1 \<and> c_C.min tp2 = c_C.min tp1 \<and> writable tp2 = writable tp1 \<and> zone1 tp2 = zone1 tp1 \<longrightarrow> length (data tp2) = length (data tp1) \<and> offset tp2 = offset tp1 \<and> c_C.min tp2 = c_C.min tp1 \<and> writable tp2 = writable tp1 \<and> zone1 tp2 = zone1 tp1 \<longrightarrow> c_C.max tp2 = c_C.max tpa1 \<and> plength tp2 = plength tp1 \<and> (\<forall>(i :: int). c_C.min tp1 \<le> i \<and> i < c_C.max tp1 \<longrightarrow> pelts tp2 i = pelts tp1 i) \<and> (\<forall>(i :: int). c_C.min tpa1 \<le> i \<and> i < c_C.max tpa1 \<longrightarrow> pelts tp2 i = pelts tpa1 i) \<longrightarrow> value tp2 (sint n + sint adj) = (2 :: int) ^\<^sub>i ((2 :: int) * uint o5) * ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint adj * value np1 (sint n) \<and> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint n + sint adj) \<le> (4 :: int) * value tp2 (sint n + sint adj) \<and> c_C.max tp2 = c_C.max tp \<and> plength tp2 = plength tp \<and> (c_C.min np1 = c_C.min np \<and> c_C.max np1 = c_C.max np \<and> plength np1 = plength np) \<and> (\<forall>(j :: int). pelts np1 j = pelts np j))))) else (valid np (sint n) \<and> valid tpa (sint n) \<and> writable tpa = True) \<and> (\<forall>(tpa1 :: 64 word ptr). length (data tpa1) = length (data tpa) \<and> offset tpa1 = offset tpa \<and> c_C.min tpa1 = c_C.min tpa \<and> c_C.max tpa1 = c_C.max tpa \<and> writable tpa1 = writable tpa \<and> zone1 tpa1 = zone1 tpa \<longrightarrow> map_eq_sub_shift (pelts tpa1) (pelts np) (offset tpa1) (offset np) (sint n) \<and> (\<forall>(j :: int). j < offset tpa1 \<or> offset tpa1 + sint n \<le> j \<longrightarrow> pelts tpa1 j = pelts tpa j) \<longrightarrow> (zone1 tp1 = zone1 tpa1 \<and> c_C.max tp1 = c_C.min tpa1 \<and> writable tp1 = True \<and> writable tpa1 = True) \<and> (\<forall>(tp2 :: 64 word ptr). length (data tp2) = length (data tp1) \<and> offset tp2 = offset tp1 \<and> c_C.min tp2 = c_C.min tp1 \<and> writable tp2 = writable tp1 \<and> zone1 tp2 = zone1 tp1 \<longrightarrow> length (data tp2) = length (data tp1) \<and> offset tp2 = offset tp1 \<and> c_C.min tp2 = c_C.min tp1 \<and> writable tp2 = writable tp1 \<and> zone1 tp2 = zone1 tp1 \<longrightarrow> c_C.max tp2 = c_C.max tpa1 \<and> plength tp2 = plength tp1 \<and> (\<forall>(i :: int). c_C.min tp1 \<le> i \<and> i < c_C.max tp1 \<longrightarrow> pelts tp2 i = pelts tp1 i) \<and> (\<forall>(i :: int). c_C.min tpa1 \<le> i \<and> i < c_C.max tpa1 \<longrightarrow> pelts tp2 i = pelts tpa1 i) \<longrightarrow> value tp2 (sint n + sint adj) = (2 :: int) ^\<^sub>i ((2 :: int) * uint o5) * ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint adj * value np (sint n) \<and> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint n + sint adj) \<le> (4 :: int) * value tp2 (sint n + sint adj) \<and> c_C.max tp2 = c_C.max tp \<and> plength tp2 = plength tp))))))) \<and> (\<forall>(tp1 :: 64 word ptr) (np1 :: 64 word ptr). offset tp1 = offset tp \<and> c_C.min tp1 = c_C.min tp \<and> writable tp1 = writable tp \<and> zone1 tp1 = zone1 tp \<longrightarrow> offset np1 = offset np \<and> writable np1 = writable np \<and> zone1 np1 = zone1 np \<longrightarrow> value tp1 (sint n + sint adj) = (2 :: int) ^\<^sub>i ((2 :: int) * uint o5) * ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint adj * value np1 (sint n) \<and> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint n + sint adj) \<le> (4 :: int) * value tp1 (sint n + sint adj) \<and> c_C.max tp1 = c_C.max tp \<and> plength tp1 = plength tp \<and> (c_C.min np1 = c_C.min np \<and> c_C.max np1 = c_C.max np \<and> plength np1 = plength np) \<and> (\<forall>(j :: int). pelts np1 j = pelts np j) \<longrightarrow> (\<forall>(o19 :: bool). (sint adj = sint (0 :: 32 word) \<longrightarrow> o19 = True) \<and> (o19 = True \<longrightarrow> adj = (0 :: 32 word)) \<longrightarrow> (\<forall>(o20 :: 64 word). (if \<not>o19 = True then o20 = (32 :: 64 word) else o20 = (0 :: 64 word)) \<longrightarrow> uint'64_in_bounds (uint o5 + uint o20) \<and> (\<forall>(o21 :: 64 word). uint o21 = uint o5 + uint o20 \<longrightarrow> (let vn :: int = value np1 (sint n) in (valid tp1 (sint o8 + sint o8) \<and> valid sp (sint o8) \<and> (1 :: int) \<le> sint o8 \<and> valid scratch ((1 :: int) + sint o8 ediv (2 :: int)) \<and> (2 :: int) ^\<^sub>i ((64 :: int) - (2 :: int)) \<le> uint (pelts tp1 (offset tp1 + sint o8 + sint o8 - (1 :: int))) \<and> (writable sp = True \<and> writable scratch = True \<and> writable tp1 = True) \<and> (4 :: int) * sint o8 < (2147483647 :: int)) \<and> (\<forall>(tp2 :: 64 word ptr) (scratch1 :: 64 word ptr) (sp1 :: 64 word ptr). offset tp2 = offset tp1 \<and> c_C.min tp2 = c_C.min tp1 \<and> writable tp2 = writable tp1 \<and> zone1 tp2 = zone1 tp1 \<longrightarrow> offset tp2 = offset tp1 \<and> c_C.min tp2 = c_C.min tp1 \<and> writable tp2 = writable tp1 \<and> zone1 tp2 = zone1 tp1 \<longrightarrow> offset scratch1 = offset scratch \<and> writable scratch1 = writable scratch \<and> zone1 scratch1 = zone1 scratch \<longrightarrow> offset sp1 = offset sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> (\<forall>(o22 :: 64 word). value sp1 (sint o8) * value sp1 (sint o8) + value tp2 (sint o8) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o8 * uint o22 = value tp1 (sint o8 + sint o8) \<and> value tp2 (sint o8) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o8 * uint o22 \<le> (2 :: int) * value sp1 (sint o8) \<and> (2 :: int) ^\<^sub>i ((64 :: int) - (1 :: int)) \<le> uint (pelts sp1 (offset sp1 + sint o8 - (1 :: int))) \<and> ((0 :: int) \<le> uint o22 \<and> uint o22 \<le> (1 :: int)) \<and> c_C.max tp2 = c_C.max tp1 \<and> c_C.min tp2 = c_C.min tp1 \<and> plength tp2 = plength tp1 \<and> c_C.max scratch1 = c_C.max scratch \<and> c_C.min scratch1 = c_C.min scratch \<and> plength scratch1 = plength scratch \<and> c_C.max sp1 = c_C.max sp \<and> c_C.min sp1 = c_C.min sp \<and> plength sp1 = plength sp \<longrightarrow> (let vs :: int = value sp1 (sint o8); vr :: int = value tp2 (sint o8) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o8 * uint o22; vs0 :: int = vs emod (2 :: int) ^\<^sub>i uint o21 in (0 :: int) \<le> (1 :: int) \<and> (\<forall>(s0 :: 64 word ptr). plength s0 = (1 :: int) \<and> offset s0 = (0 :: int) \<and> c_C.min s0 = (0 :: int) \<and> c_C.max s0 = (1 :: int) \<and> writable s0 = True \<longrightarrow> (((0 :: int) \<le> uint o21 \<and> uint o21 < (64 :: int)) \<and> (2 :: int) ^\<^sub>i uint o21 * uint (1 :: 64 word) \<le> (18446744073709551615 :: int)) \<and> (\<forall>(o23 :: 64 word). uint o23 = (2 :: int) ^\<^sub>i uint o21 * uint (1 :: 64 word) \<longrightarrow> (c_C.min sp1 \<le> offset sp1 \<and> offset sp1 < c_C.max sp1) \<and> (let o24 :: 64 word = pelts sp1 (offset sp1) in (\<not>uint o23 = (0 :: int) \<and> uint'64_in_bounds (uint o24 cmod uint o23)) \<and> (\<forall>(s00 :: 64 word). uint s00 = uint o24 cmod uint o23 \<longrightarrow> ((c_C.min s0 \<le> offset s0 \<and> offset s0 < c_C.max s0) \<and> writable s0 = True) \<and> (\<forall>(s01 :: 64 word ptr). length (data s01) = length (data s0) \<and> offset s01 = offset s0 \<and> c_C.min s01 = c_C.min s0 \<and> c_C.max s01 = c_C.max s0 \<and> writable s01 = writable s0 \<and> zone1 s01 = zone1 s0 \<longrightarrow> pelts s01 = (pelts s0)(offset s01 := s00) \<longrightarrow> uint'64_in_bounds ((2 :: int) * uint s00) \<and> (\<forall>(o25 :: 64 word). uint o25 = (2 :: int) * uint s00 \<longrightarrow> (valid sp1 (sint o8) \<and> valid tp2 (sint o8) \<and> writable tp2 = True) \<and> (\<forall>(tp3 :: 64 word ptr). length (data tp3) = length (data tp2) \<and> offset tp3 = offset tp2 \<and> c_C.min tp3 = c_C.min tp2 \<and> c_C.max tp3 = c_C.max tp2 \<and> writable tp3 = writable tp2 \<and> zone1 tp3 = zone1 tp2 \<longrightarrow> length (data tp3) = length (data tp2) \<and> offset tp3 = offset tp2 \<and> c_C.min tp3 = c_C.min tp2 \<and> c_C.max tp3 = c_C.max tp2 \<and> writable tp3 = writable tp2 \<and> zone1 tp3 = zone1 tp2 \<longrightarrow> (\<forall>(rc :: 64 word). value tp3 (sint o8) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o8 * uint rc = value tp2 (sint o8) + value sp1 (sint o8) * uint o25 \<and> (\<forall>(j :: int). j < offset tp3 \<or> offset tp3 + sint o8 \<le> j \<longrightarrow> pelts tp3 j = pelts tp2 j) \<longrightarrow> uint'64_in_bounds (uint o22 + uint rc) \<and> (\<forall>(o26 :: 64 word). uint o26 = uint o22 + uint rc \<longrightarrow> (valid s01 (1 :: int) \<and> valid tp3 (1 :: int) \<and> writable tp3 = True) \<and> (\<forall>(tp4 :: 64 word ptr). length (data tp4) = length (data tp3) \<and> offset tp4 = offset tp3 \<and> c_C.min tp4 = c_C.min tp3 \<and> c_C.max tp4 = c_C.max tp3 \<and> writable tp4 = writable tp3 \<and> zone1 tp4 = zone1 tp3 \<longrightarrow> length (data tp4) = length (data tp3) \<and> offset tp4 = offset tp3 \<and> c_C.min tp4 = c_C.min tp3 \<and> c_C.max tp4 = c_C.max tp3 \<and> writable tp4 = writable tp3 \<and> zone1 tp4 = zone1 tp3 \<longrightarrow> (\<forall>(o27 :: 64 word). value tp4 (1 :: int) - ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (1 :: int) * uint o27 = value tp3 (1 :: int) - value s01 (1 :: int) * uint s00 \<and> (\<forall>(j :: int). j < offset tp4 \<or> offset tp4 + (1 :: int) \<le> j \<longrightarrow> pelts tp4 j = pelts tp3 j) \<longrightarrow> (if (1 :: int) < sint o8 then (c_C.min tp4 \<le> offset tp4 + (1 :: int) \<and> offset tp4 + (1 :: int) \<le> c_C.max tp4) \<and> (\<forall>(tp11 :: 64 word ptr). offset tp11 = offset tp4 + (1 :: int) \<and> plength tp11 = plength tp4 \<and> pelts tp11 = pelts tp4 \<and> data tp11 = data tp4 \<and> c_C.min tp11 = c_C.min tp4 \<and> c_C.max tp11 = c_C.max tp4 \<and> zone1 tp11 = zone1 tp4 \<and> writable tp11 = writable tp4 \<longrightarrow> int'32_in_bounds (sint o8 - (1 :: int)) \<and> (\<forall>(o28 :: 32 word). sint o28 = sint o8 - (1 :: int) \<longrightarrow> (valid tp11 (sint o28) \<and> (0 :: int) < sint o28 \<and> writable tp11 = True) \<and> (\<forall>(tp12 :: 64 word ptr) (tp5 :: 64 word ptr). length (data tp12) = length (data tp11) \<and> offset tp12 = offset tp11 \<and> c_C.min tp12 = c_C.min tp11 \<and> c_C.max tp12 = c_C.max tp11 \<and> writable tp12 = writable tp11 \<and> zone1 tp12 = zone1 tp11 \<longrightarrow> data tp5 = data tp12 \<and> length (data tp12) = length (data tp4) \<and> offset tp5 = offset tp4 \<and> c_C.min tp5 = c_C.min tp4 \<and> c_C.max tp5 = c_C.max tp4 \<and> writable tp5 = writable tp4 \<and> zone1 tp5 = zone1 tp4 \<longrightarrow> (\<forall>(o29 :: 64 word). value tp12 (sint o28) - ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o28 * uint o29 = value tp11 (sint o28) - uint o27 \<and> ((0 :: int) \<le> uint o29 \<and> uint o29 \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset tp12 \<or> offset tp12 + sint o28 \<le> j \<longrightarrow> pelts tp12 j = pelts tp11 j) \<longrightarrow> uint'64_in_bounds (uint o26 - uint o29) \<and> (\<forall>(o30 :: 64 word). uint o30 = uint o26 - uint o29 \<longrightarrow> value tp5 (sint o8) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o8 * uint o30 = vr + (2 :: int) * vs0 * vs - vs0 * vs0))))) else uint'64_in_bounds (uint o26 - uint o27) \<and> (\<forall>(o28 :: 64 word). uint o28 = uint o26 - uint o27 \<longrightarrow> value tp4 (sint o8) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o8 * uint o28 = vr + (2 :: int) * vs0 * vs - vs0 * vs0)) \<and> (\<forall>(rl :: 64 word) (tp5 :: 64 word ptr). length (data tp5) = length (data tp4) \<and> offset tp5 = offset tp4 \<and> c_C.min tp5 = c_C.min tp4 \<and> c_C.max tp5 = c_C.max tp4 \<and> writable tp5 = writable tp4 \<and> zone1 tp5 = zone1 tp4 \<longrightarrow> value tp5 (sint o8) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o8 * uint rl = vr + (2 :: int) * vs0 * vs - vs0 * vs0 \<longrightarrow> (((0 :: int) < uint o21 \<and> uint o21 < (64 :: int)) \<and> valid sp1 (sint o8) \<and> valid sp1 (sint o8) \<and> (0 :: int) < sint o8 \<and> writable sp1 = True \<and> (offset sp1 \<le> offset sp1 \<or> offset sp1 + sint o8 \<le> offset sp1)) \<and> (\<forall>(sp2 :: 64 word ptr). length (data sp2) = length (data sp1) \<and> offset sp2 = offset sp1 \<and> c_C.min sp2 = c_C.min sp1 \<and> c_C.max sp2 = c_C.max sp1 \<and> writable sp2 = writable sp1 \<and> zone1 sp2 = zone1 sp1 \<longrightarrow> (\<forall>(r :: 64 word). uint r + ((18446744073709551615 :: int) + (1 :: int)) * value sp2 (sint o8) = value sp1 (sint o8) * (2 :: int) ^\<^sub>i ((64 :: int) - uint o21) \<and> (\<forall>(j :: int). j < offset sp2 \<or> offset sp2 + sint o8 \<le> j \<longrightarrow> pelts sp2 j = pelts sp1 j) \<and> c_C.min sp2 = c_C.min sp1 \<and> c_C.max sp2 = c_C.max sp1 \<and> plength sp2 = plength sp1 \<longrightarrow> (let vsp :: int = value sp2 (sint o8) in (0 :: int) < vn \<and> ((0 :: int) < vn \<longrightarrow> (((0 :: int) \<le> uint (1 :: 64 word) \<and> uint (1 :: 64 word) < (64 :: int)) \<and> (2 :: int) ^\<^sub>i uint (1 :: 64 word) * uint o21 \<le> (18446744073709551615 :: int)) \<and> (\<forall>(o28 :: 64 word). uint o28 = (2 :: int) ^\<^sub>i uint (1 :: 64 word) * uint o21 \<longrightarrow> (if uint o28 < (64 :: int) then int'32_in_bounds (sint o8 + (1 :: int)) \<and> (\<forall>(o29 :: 32 word). sint o29 = sint o8 + (1 :: int) \<longrightarrow> (2 :: int) ^\<^sub>i uint o28 * (vn - vsp * vsp) = value tp5 (sint o29) \<and> ((0 :: int) \<le> uint o28 \<and> uint o28 < (64 :: int)) \<and> valid tp5 (sint o29) \<and> (0 :: int) < sint o29 \<and> sint o29 \<le> k + (1 :: int)) else (c_C.min tp5 \<le> offset tp5 + (1 :: int) \<and> offset tp5 + (1 :: int) \<le> c_C.max tp5) \<and> (\<forall>(tp11 :: 64 word ptr). offset tp11 = offset tp5 + (1 :: int) \<and> plength tp11 = plength tp5 \<and> pelts tp11 = pelts tp5 \<and> data tp11 = data tp5 \<and> c_C.min tp11 = c_C.min tp5 \<and> c_C.max tp11 = c_C.max tp5 \<and> zone1 tp11 = zone1 tp5 \<and> writable tp11 = writable tp5 \<longrightarrow> uint'64_in_bounds (uint o28 - (64 :: int)) \<and> (\<forall>(o29 :: 64 word). uint o29 = uint o28 - (64 :: int) \<longrightarrow> (2 :: int) ^\<^sub>i uint o29 * (vn - vsp * vsp) = value tp11 (sint o8) \<and> ((0 :: int) \<le> uint o29 \<and> uint o29 < (64 :: int)) \<and> valid tp11 (sint o8) \<and> (0 :: int) < sint o8 \<and> sint o8 \<le> k + (1 :: int)))) \<and> (\<forall>(c2 :: 64 word) (tp6 :: 64 word ptr) (tn :: 32 word). (2 :: int) ^\<^sub>i uint c2 * (vn - vsp * vsp) = value tp6 (sint tn) \<and> ((0 :: int) \<le> uint c2 \<and> uint c2 < (64 :: int)) \<and> valid tp6 (sint tn) \<and> (0 :: int) < sint tn \<and> sint tn \<le> k + (1 :: int) \<longrightarrow> (\<forall>(o29 :: bool). (uint c2 = uint (0 :: 64 word) \<longrightarrow> o29 = True) \<and> (o29 = True \<longrightarrow> c2 = (0 :: 64 word)) \<longrightarrow> (if \<not>o29 = True then (valid tp6 (sint tn) \<and> valid rp (sint tn) \<and> ((0 :: int) < uint c2 \<and> uint c2 < (64 :: int)) \<and> (0 :: int) < sint tn \<and> writable rp = True) \<and> (\<forall>(o30 :: 64 word ptr) (rp1 :: 64 word ptr). offset o30 = offset tp6 \<and> writable o30 = writable tp6 \<and> zone1 o30 = zone1 tp6 \<longrightarrow> offset rp1 = offset rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(b :: 64 word). uint b + ((18446744073709551615 :: int) + (1 :: int)) * value rp1 (sint tn) = value o30 (sint tn) * (2 :: int) ^\<^sub>i ((64 :: int) - uint c2) \<and> (\<forall>(j :: int). j < offset rp1 \<or> offset rp1 + sint tn \<le> j \<longrightarrow> pelts rp1 j = pelts rp j) \<and> pelts o30 = pelts tp6 \<and> (c_C.min o30 = c_C.min tp6 \<and> c_C.max o30 = c_C.max tp6 \<and> plength o30 = plength tp6) \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> plength rp1 = plength rp \<longrightarrow> value rp1 (sint tn) = vn - vsp * vsp \<and> ((0 :: int) < sint tn \<and> sint tn \<le> k + (1 :: int)) \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> plength rp1 = plength rp)) else (valid tp6 (sint tn) \<and> valid rp (sint tn) \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> map_eq_sub_shift (pelts rp1) (pelts tp6) (offset rp1) (offset tp6) (sint tn) \<and> (\<forall>(j :: int). j < offset rp1 \<or> offset rp1 + sint tn \<le> j \<longrightarrow> pelts rp1 j = pelts rp j) \<longrightarrow> value rp1 (sint tn) = vn - vsp * vsp \<and> ((0 :: int) < sint tn \<and> sint tn \<le> k + (1 :: int)) \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> plength rp1 = plength rp))) \<and> (\<forall>(rn :: 32 word) (rp1 :: 64 word ptr). offset rp1 = offset rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> value rp1 (sint rn) = vn - vsp * vsp \<and> ((0 :: int) < sint rn \<and> sint rn \<le> k + (1 :: int)) \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> plength rp1 = plength rp \<longrightarrow> ((1 :: int) \<le> sint rn \<and> sint rn \<le> sint rn) \<and> (\<forall>(rn1 :: 32 word). value rp1 (sint rn1) = value rp1 (sint rn) \<and> (1 :: int) \<le> sint rn1 \<and> sint rn1 \<le> sint rn \<longrightarrow> int'32_in_bounds (sint rn1 - (1 :: int)) \<and> (\<forall>(o29 :: 32 word). sint o29 = sint rn1 - (1 :: int) \<longrightarrow> (c_C.min rp1 \<le> offset rp1 + sint o29 \<and> offset rp1 + sint o29 < c_C.max rp1) \<and> (let o30 :: 64 word = pelts rp1 (offset rp1 + sint o29) in \<forall>(o31 :: bool). (uint o30 = uint (0 :: 64 word) \<longrightarrow> o31 = True) \<and> (o31 = True \<longrightarrow> o30 = (0 :: 64 word)) \<longrightarrow> (if o31 = True then int'32_in_bounds (sint rn1 - (1 :: int)) \<and> (\<forall>(o32 :: 32 word). sint o32 = sint rn1 - (1 :: int) \<longrightarrow> (\<forall>(o33 :: bool). (sint o32 = sint (0 :: 32 word) \<longrightarrow> o33 = True) \<and> (o33 = True \<longrightarrow> o32 = (0 :: 32 word)) \<longrightarrow> (if o33 = True then value np1 (sint n) = value sp2 (ceilhalf (sint n)) * value sp2 (ceilhalf (sint n)) + value rp1 (sint o32) \<and> ((0 :: int) \<le> sint o32 \<and> sint o32 \<le> sint n) \<and> value rp1 (sint o32) \<le> (2 :: int) * value sp2 (ceilhalf (sint n)) \<and> ((0 :: int) < sint o32 \<longrightarrow> (0 :: int) < uint (pelts rp1 (offset rp1 + sint o32 - (1 :: int)))) \<and> (\<forall>(j :: int). pelts np1 j = pelts np j) \<and> c_C.max np1 = c_C.max np \<and> c_C.min np1 = c_C.min np \<and> plength np1 = plength np \<and> c_C.max rp1 = c_C.max rp \<and> c_C.min rp1 = c_C.min rp \<and> plength rp1 = plength rp \<and> c_C.max sp2 = c_C.max sp \<and> c_C.min sp2 = c_C.min sp \<and> plength sp2 = plength sp else sint o32 < sint rn1 \<and> value rp1 (sint o32) = value rp1 (sint rn) \<and> (1 :: int) \<le> sint o32 \<and> sint o32 \<le> sint rn))) else value np1 (sint n) = value sp2 (ceilhalf (sint n)) * value sp2 (ceilhalf (sint n)) + value rp1 (sint rn1) \<and> ((0 :: int) \<le> sint rn1 \<and> sint rn1 \<le> sint n) \<and> value rp1 (sint rn1) \<le> (2 :: int) * value sp2 (ceilhalf (sint n)) \<and> ((0 :: int) < sint rn1 \<longrightarrow> (0 :: int) < uint (pelts rp1 (offset rp1 + sint rn1 - (1 :: int)))) \<and> (\<forall>(j :: int). pelts np1 j = pelts np j) \<and> c_C.max np1 = c_C.max np \<and> c_C.min np1 = c_C.min np \<and> plength np1 = plength np \<and> c_C.max rp1 = c_C.max rp \<and> c_C.min rp1 = c_C.min rp \<and> plength rp1 = plength rp \<and> c_C.max sp2 = c_C.max sp \<and> c_C.min sp2 = c_C.min sp \<and> plength sp2 = plength sp))))))))))))))))))))))))))))))))))) else (valid np (sint n) \<and> valid rp (sint n) \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> map_eq_sub_shift (pelts rp1) (pelts np) (offset rp1) (offset np) (sint n) \<and> (\<forall>(j :: int). j < offset rp1 \<or> offset rp1 + sint n \<le> j \<longrightarrow> pelts rp1 j = pelts rp j) \<longrightarrow> (valid rp1 (sint o8 + sint o8) \<and> valid sp (sint o8) \<and> (1 :: int) \<le> sint o8 \<and> valid scratch ((1 :: int) + sint o8 ediv (2 :: int)) \<and> (2 :: int) ^\<^sub>i ((64 :: int) - (2 :: int)) \<le> uint (pelts rp1 (offset rp1 + sint o8 + sint o8 - (1 :: int))) \<and> (writable sp = True \<and> writable scratch = True \<and> writable rp1 = True) \<and> (4 :: int) * sint o8 < (2147483647 :: int)) \<and> (\<forall>(scratch1 :: 64 word ptr) (rp2 :: 64 word ptr) (sp1 :: 64 word ptr). offset scratch1 = offset scratch \<and> writable scratch1 = writable scratch \<and> zone1 scratch1 = zone1 scratch \<longrightarrow> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> offset sp1 = offset sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> (\<forall>(h :: 64 word). value sp1 (sint o8) * value sp1 (sint o8) + value rp2 (sint o8) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o8 * uint h = value rp1 (sint o8 + sint o8) \<and> value rp2 (sint o8) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o8 * uint h \<le> (2 :: int) * value sp1 (sint o8) \<and> (2 :: int) ^\<^sub>i ((64 :: int) - (1 :: int)) \<le> uint (pelts sp1 (offset sp1 + sint o8 - (1 :: int))) \<and> ((0 :: int) \<le> uint h \<and> uint h \<le> (1 :: int)) \<and> c_C.max rp2 = c_C.max rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> plength rp2 = plength rp1 \<and> c_C.max scratch1 = c_C.max scratch \<and> c_C.min scratch1 = c_C.min scratch \<and> plength scratch1 = plength scratch \<and> c_C.max sp1 = c_C.max sp \<and> c_C.min sp1 = c_C.min sp \<and> plength sp1 = plength sp \<longrightarrow> ((c_C.min rp2 \<le> offset rp2 + sint o8 \<and> offset rp2 + sint o8 < c_C.max rp2) \<and> writable rp2 = True) \<and> (\<forall>(rp3 :: 64 word ptr). length (data rp3) = length (data rp2) \<and> offset rp3 = offset rp2 \<and> c_C.min rp3 = c_C.min rp2 \<and> c_C.max rp3 = c_C.max rp2 \<and> writable rp3 = writable rp2 \<and> zone1 rp3 = zone1 rp2 \<longrightarrow> pelts rp3 = (pelts rp2)(offset rp3 + sint o8 := h) \<and> pelts rp3 (offset rp3 + sint o8) = h \<longrightarrow> uint h \<le> (2147483647 :: int) \<and> (\<forall>(o16 :: 32 word). sint o16 = uint h \<longrightarrow> int'32_in_bounds (sint o8 + sint o16) \<and> (\<forall>(o17 :: 32 word). sint o17 = sint o8 + sint o16 \<longrightarrow> ((1 :: int) \<le> sint o17 \<and> sint o17 \<le> sint o17) \<and> (\<forall>(rn :: 32 word). value rp3 (sint rn) = value rp3 (sint o17) \<and> (1 :: int) \<le> sint rn \<and> sint rn \<le> sint o17 \<longrightarrow> int'32_in_bounds (sint rn - (1 :: int)) \<and> (\<forall>(o18 :: 32 word). sint o18 = sint rn - (1 :: int) \<longrightarrow> (c_C.min rp3 \<le> offset rp3 + sint o18 \<and> offset rp3 + sint o18 < c_C.max rp3) \<and> (let o19 :: 64 word = pelts rp3 (offset rp3 + sint o18) in \<forall>(o20 :: bool). (uint o19 = uint (0 :: 64 word) \<longrightarrow> o20 = True) \<and> (o20 = True \<longrightarrow> o19 = (0 :: 64 word)) \<longrightarrow> (if o20 = True then int'32_in_bounds (sint rn - (1 :: int)) \<and> (\<forall>(o21 :: 32 word). sint o21 = sint rn - (1 :: int) \<longrightarrow> (\<forall>(o22 :: bool). (sint o21 = sint (0 :: 32 word) \<longrightarrow> o22 = True) \<and> (o22 = True \<longrightarrow> o21 = (0 :: 32 word)) \<longrightarrow> (if o22 = True then value np (sint n) = value sp1 (ceilhalf (sint n)) * value sp1 (ceilhalf (sint n)) + value rp3 (sint o21) \<and> ((0 :: int) \<le> sint o21 \<and> sint o21 \<le> sint n) \<and> value rp3 (sint o21) \<le> (2 :: int) * value sp1 (ceilhalf (sint n)) \<and> ((0 :: int) < sint o21 \<longrightarrow> (0 :: int) < uint (pelts rp3 (offset rp3 + sint o21 - (1 :: int)))) \<and> c_C.max rp3 = c_C.max rp \<and> c_C.min rp3 = c_C.min rp \<and> plength rp3 = plength rp \<and> c_C.max sp1 = c_C.max sp \<and> c_C.min sp1 = c_C.min sp \<and> plength sp1 = plength sp else sint o21 < sint rn \<and> value rp3 (sint o21) = value rp3 (sint o17) \<and> (1 :: int) \<le> sint o21 \<and> sint o21 \<le> sint o17))) else value np (sint n) = value sp1 (ceilhalf (sint n)) * value sp1 (ceilhalf (sint n)) + value rp3 (sint rn) \<and> ((0 :: int) \<le> sint rn \<and> sint rn \<le> sint n) \<and> value rp3 (sint rn) \<le> (2 :: int) * value sp1 (ceilhalf (sint n)) \<and> ((0 :: int) < sint rn \<longrightarrow> (0 :: int) < uint (pelts rp3 (offset rp3 + sint rn - (1 :: int)))) \<and> c_C.max rp3 = c_C.max rp \<and> c_C.min rp3 = c_C.min rp \<and> plength rp3 = plength rp \<and> c_C.max sp1 = c_C.max sp \<and> c_C.min sp1 = c_C.min sp \<and> plength sp1 = plength sp)))))))))))))))))))))))))))))"
  sorry
end
