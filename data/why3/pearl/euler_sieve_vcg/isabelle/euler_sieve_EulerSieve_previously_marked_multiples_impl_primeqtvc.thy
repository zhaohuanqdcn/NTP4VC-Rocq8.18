theory euler_sieve_EulerSieve_previously_marked_multiples_impl_primeqtvc
  imports "NTP4Verif.NTP4Verif" "./euler_sieve_ArithmeticResults" "./euler_sieve_DivisibilityResults" "./euler_sieve_EulerSieveSpec"
begin
typedecl  t
consts nexts :: "t \<Rightarrow> int list"
consts marked :: "t \<Rightarrow> bool list"
consts max :: "t \<Rightarrow> 63 word"
axiomatization where t'invariant'0:   "sint (max self) < sint int'63_max"
  for self :: "t"
axiomatization where t'invariant'1:   "(3 :: int) \<le> sint (max self)"
  for self :: "t"
axiomatization where t'invariant'2:   "length (nexts self) = length (marked self)"
  for self :: "t"
axiomatization where t'invariant'3:   "int (length (marked self)) = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'4:   "inv_nexts (nexts self) (int (length (nexts self)))"
  for self :: "t"
axiomatization where t'invariant'5:   "all_eliminated_marked (marked self) (nexts self)"
  for self :: "t"
axiomatization where t'invariant'6:   "\<forall>(i :: int). (3 :: int) \<le> i \<and> i \<le> sint (max self) \<longrightarrow> i emod (2 :: int) = (0 :: int) \<longrightarrow> marked self ! nat i = True"
  for self :: "t"
axiomatization where t'invariant'7:   "\<forall>(i :: int). (3 :: int) \<le> i \<and> i < sint (max self) - (1 :: int) \<longrightarrow> i emod (2 :: int) = (1 :: int) \<longrightarrow> nexts self ! nat i emod (2 :: int) = (1 :: int) \<or> nexts self ! nat i = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'8:   "nexts self ! nat (sint (max self)) = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'9:   "(sint (max self) - (1 :: int)) emod (2 :: int) = (0 :: int) \<longrightarrow> nexts self ! nat (sint (max self) - (1 :: int)) = sint (max self)"
  for self :: "t"
axiomatization where t'invariant'10:   "(sint (max self) - (1 :: int)) emod (2 :: int) = (1 :: int) \<longrightarrow> nexts self ! nat (sint (max self) - (1 :: int)) = sint (max self) + (1 :: int)"
  for self :: "t"
theorem previously_marked_multiples_impl_prime'vc:
  fixes n :: "int"
  fixes marked1 :: "bool list"
  assumes fact0: "(2 :: int) \<le> n"
  assumes fact1: "n < int (length marked1)"
  assumes fact2: "\<not>marked1 ! nat n = True"
  assumes fact3: "previously_marked_multiples marked1 n"
  shows "prime n"
  sorry
end
