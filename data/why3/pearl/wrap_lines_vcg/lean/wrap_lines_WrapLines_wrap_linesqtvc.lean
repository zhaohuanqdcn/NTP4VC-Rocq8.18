import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace wrap_lines_WrapLines_wrap_linesqtvc
axiom char : Type
axiom inhabited_axiom_char : Inhabited char
attribute [instance] inhabited_axiom_char
axiom space : char
axiom newline : char
noncomputable def at_least_line_length (s : List char) (line_length : ℤ) := ∀(i : ℤ) (j : ℤ), -(1 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length s) → i = -(1 : ℤ) ∨ i ≤ (0 : ℤ) ∧ s[Int.toNat i]! = newline → s[Int.toNat j]! = newline → line_length ≤ j - i
theorem wrap_lines'vc (s : List char) (line_length : ℤ) (fact0 : ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s) → ¬s[Int.toNat i]! = newline) : let o1 : char := space; ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length s)) ∧ (∀(o2 : ℤ), o2 = -(1 : ℤ) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s) → ¬s[Int.toNat i]! = o1) ∨ ((0 : ℤ) ≤ o2 ∧ o2 < Int.ofNat (List.length s)) ∧ s[Int.toNat o2]! = o1 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o2 → ¬s[Int.toNat i]! = o1) → ((-(1 : ℤ) ≤ -(1 : ℤ) ∧ -(1 : ℤ) < Int.ofNat (List.length s)) ∧ (o2 = -(1 : ℤ) ∨ (-(1 : ℤ) < o2 ∧ o2 < Int.ofNat (List.length s)) ∧ s[Int.toNat o2]! = space) ∧ (∀(i : ℤ), -(1 : ℤ) < i ∧ i < o2 → ¬s[Int.toNat i]! = newline) ∧ at_least_line_length s line_length) ∧ (∀(last_sp : ℤ) (last_nl : ℤ) (s1 : List char), List.length s1 = List.length s → (-(1 : ℤ) ≤ last_nl ∧ last_nl < Int.ofNat (List.length s1)) ∧ (last_sp = -(1 : ℤ) ∨ (last_nl < last_sp ∧ last_sp < Int.ofNat (List.length s1)) ∧ s1[Int.toNat last_sp]! = space) ∧ (∀(i : ℤ), last_nl < i ∧ i < Int.ofNat (List.length s1) → s1[Int.toNat i]! = s[Int.toNat i]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s1) → ¬s1[Int.toNat i]! = s[Int.toNat i]! → s[Int.toNat i]! = space ∧ s1[Int.toNat i]! = newline) ∧ (∀(i : ℤ), last_nl < i ∧ i < last_sp → ¬s1[Int.toNat i]! = newline) ∧ at_least_line_length s1 line_length → (if ¬last_sp = -(1 : ℤ) then if line_length < last_sp - last_nl then let o3 : char := newline; ((0 : ℤ) ≤ last_sp ∧ last_sp < Int.ofNat (List.length s1)) ∧ (List.length (List.set s1 (Int.toNat last_sp) o3) = List.length s1 → getElem! (List.set s1 (Int.toNat last_sp) o3) ∘ Int.toNat = Function.update (getElem! s1 ∘ Int.toNat) last_sp o3 → (let o4 : ℤ := last_sp + (1 : ℤ); let o5 : char := space; ((0 : ℤ) ≤ o4 ∧ o4 ≤ Int.ofNat (List.length (List.set s1 (Int.toNat last_sp) o3))) ∧ (∀(o6 : ℤ), o6 = -(1 : ℤ) ∧ (∀(i : ℤ), o4 ≤ i ∧ i < Int.ofNat (List.length (List.set s1 (Int.toNat last_sp) o3)) → ¬(List.set s1 (Int.toNat last_sp) o3)[Int.toNat i]! = o5) ∨ (o4 ≤ o6 ∧ o6 < Int.ofNat (List.length (List.set s1 (Int.toNat last_sp) o3))) ∧ (List.set s1 (Int.toNat last_sp) o3)[Int.toNat o6]! = o5 ∧ (∀(i : ℤ), o4 ≤ i ∧ i < o6 → ¬(List.set s1 (Int.toNat last_sp) o3)[Int.toNat i]! = o5) → ((0 : ℤ) ≤ (if last_sp = -(1 : ℤ) then (0 : ℤ) else Int.ofNat (List.length s1) - last_sp) ∧ (if o6 = -(1 : ℤ) then (0 : ℤ) else Int.ofNat (List.length (List.set s1 (Int.toNat last_sp) o3)) - o6) < (if last_sp = -(1 : ℤ) then (0 : ℤ) else Int.ofNat (List.length s1) - last_sp)) ∧ (-(1 : ℤ) ≤ last_sp ∧ last_sp < Int.ofNat (List.length (List.set s1 (Int.toNat last_sp) o3))) ∧ (o6 = -(1 : ℤ) ∨ (last_sp < o6 ∧ o6 < Int.ofNat (List.length (List.set s1 (Int.toNat last_sp) o3))) ∧ (List.set s1 (Int.toNat last_sp) o3)[Int.toNat o6]! = space) ∧ (∀(i : ℤ), last_sp < i ∧ i < Int.ofNat (List.length (List.set s1 (Int.toNat last_sp) o3)) → (List.set s1 (Int.toNat last_sp) o3)[Int.toNat i]! = s[Int.toNat i]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length (List.set s1 (Int.toNat last_sp) o3)) → ¬(List.set s1 (Int.toNat last_sp) o3)[Int.toNat i]! = s[Int.toNat i]! → s[Int.toNat i]! = space ∧ (List.set s1 (Int.toNat last_sp) o3)[Int.toNat i]! = newline) ∧ (∀(i : ℤ), last_sp < i ∧ i < o6 → ¬(List.set s1 (Int.toNat last_sp) o3)[Int.toNat i]! = newline) ∧ at_least_line_length (List.set s1 (Int.toNat last_sp) o3) line_length))) else let o3 : ℤ := last_sp + (1 : ℤ); let o4 : char := space; ((0 : ℤ) ≤ o3 ∧ o3 ≤ Int.ofNat (List.length s1)) ∧ (∀(o5 : ℤ), o5 = -(1 : ℤ) ∧ (∀(i : ℤ), o3 ≤ i ∧ i < Int.ofNat (List.length s1) → ¬s1[Int.toNat i]! = o4) ∨ (o3 ≤ o5 ∧ o5 < Int.ofNat (List.length s1)) ∧ s1[Int.toNat o5]! = o4 ∧ (∀(i : ℤ), o3 ≤ i ∧ i < o5 → ¬s1[Int.toNat i]! = o4) → ((0 : ℤ) ≤ (if last_sp = -(1 : ℤ) then (0 : ℤ) else Int.ofNat (List.length s1) - last_sp) ∧ (if o5 = -(1 : ℤ) then (0 : ℤ) else Int.ofNat (List.length s1) - o5) < (if last_sp = -(1 : ℤ) then (0 : ℤ) else Int.ofNat (List.length s1) - last_sp)) ∧ (-(1 : ℤ) ≤ last_nl ∧ last_nl < Int.ofNat (List.length s1)) ∧ (o5 = -(1 : ℤ) ∨ (last_nl < o5 ∧ o5 < Int.ofNat (List.length s1)) ∧ s1[Int.toNat o5]! = space) ∧ (∀(i : ℤ), last_nl < i ∧ i < Int.ofNat (List.length s1) → s1[Int.toNat i]! = s[Int.toNat i]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s1) → ¬s1[Int.toNat i]! = s[Int.toNat i]! → s[Int.toNat i]! = space ∧ s1[Int.toNat i]! = newline) ∧ (∀(i : ℤ), last_nl < i ∧ i < o5 → ¬s1[Int.toNat i]! = newline) ∧ at_least_line_length s1 line_length) else (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s1) → ¬s1[Int.toNat i]! = s[Int.toNat i]! → s[Int.toNat i]! = space ∧ s1[Int.toNat i]! = newline) ∧ at_least_line_length s1 line_length)))
  := sorry
end wrap_lines_WrapLines_wrap_linesqtvc
