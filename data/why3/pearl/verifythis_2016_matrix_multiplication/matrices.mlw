theory MatrixGen

  use int.Int

  type mat 'a

  function rows (mat 'a) : int

  function cols (mat 'a) : int

  axiom rows_and_cols_nonnegative:
    forall m: mat 'a. 0 <= rows m /\ 0 <= cols m

  function get (mat 'a) int int : 'a

  function set (mat 'a) int int 'a : mat 'a

  axiom set_def1:
    forall m: mat 'a, i j: int, v: 'a. 0 <= i < rows m -> 0 <= j < cols m ->
    rows (set m i j v) = rows m

  axiom set_def2:
    forall m: mat 'a, i j: int, v: 'a. 0 <= i < rows m -> 0 <= j < cols m ->
    cols (set m i j v) = cols m

  axiom set_def3:
    forall m: mat 'a, i j: int, v: 'a. 0 <= i < rows m -> 0 <= j < cols m ->
    get (set m i j v) i j = v

  axiom set_def4:
    forall m: mat 'a, i j: int, v: 'a. 0 <= i < rows m -> 0 <= j < cols m ->
    forall i' j': int. 0 <= i' < rows m /\ 0 <= j' < cols m /\
      (i <> i' \/ j <> j') ->
      get (set m i j v) i' j' = get m i' j'

  predicate (==) (m1 m2: mat 'a) =
    rows m1 = rows m2 && cols m1 = cols m2 &&
    forall i j: int. 0 <= i < rows m1 -> 0 <= j < cols m1 ->
    get m1 i j = get m2 i j

  axiom extensionality:
    forall m1 m2: mat 'a. m1 == m2 -> m1 = m2

  predicate (===) (a b: mat 'a) =
    rows a = rows b /\ cols a = cols b

end


theory MyMatrix

  use int.Int

  type mat 'a

  function rows (mat 'a) : int

  function cols (mat 'a) : int

  function get (mat 'a) int int : 'a

  function create (r c: int) (f: int -> int -> 'a) : mat 'a

  axiom create_rows:
    forall r c: int, f: int -> int -> 'a.
    0 <= r -> rows (create r c f) = r

  axiom create_cols:
  forall r c: int, f: int -> int -> 'a.
    0 <= c -> cols (create r c f) = c

  axiom create_get:
    forall r c: int, f: int -> int -> 'a, i j: int.
    0 <= i < r -> 0 <= j < c -> get (create r c f) i j = f i j

  function set (m:mat 'a) (x y:int) (z:'a) : mat 'a =
    create m.rows m.cols (fun x1 y1 -> if x1 = x && y1 = y then z else get m x1 y1)

  clone export MatrixGen with type mat 'a = mat 'a,
    function rows = rows,
    function cols = cols,
    function get = get,
    function set = set,
    lemma set_def1,
    lemma set_def2,
    lemma set_def3,
    lemma set_def4,
    axiom rows_and_cols_nonnegative,
    axiom extensionality

  use int.Int

end

module MatrixArithmetic

  use int.Int
  use int.Sum
  use sum_extended.Sum_extended
  use MyMatrix

  (* Zero matrix *)
  constant zerof : int -> int -> int = fun _ _ -> 0

  function zero (r c: int) : mat int = create r c zerof

  (* Matrix addition *)
  function add2f (a b: mat int) : int -> int -> int =
    fun x y -> get a x y + get b x y

  function add (a b: mat int) : mat int =
    create (rows a) (cols a) (add2f a b)

  (* Matrix additive inverse *)
  function opp2f (a: mat int) : int -> int -> int =
    fun x y -> - get a x y

  function opp (a: mat int) : mat int =
    create (rows a) (cols a) (opp2f a)

  function sub (a b: mat int) : mat int =
    add a (opp b)

  (* Matrix multiplication *)
  function mul_atom (a b: mat int) (i j:int) : int -> int =
    fun k -> get a i k  * get b k j

  function mul_cell (a b: mat int): int -> int -> int =
    fun i j -> sum (mul_atom a b i j) 0 (cols a)

  function mul (a b: mat int) : mat int =
    create (rows a) (cols b) (mul_cell a b)

  let ghost zero_neutral () : unit
    ensures { forall a. add a (zero a.rows a.cols) =  a }
  = ()

  let ghost add_commutative () : unit
    ensures { forall a b. a === b ->
              add a b =  add b a }
  = ()

  let ghost add_associative () : unit
    ensures { forall a b c. a === b === c ->
              add a (add b c) =  add (add a b) c }
  = ()

  let ghost add_opposite () : unit
    ensures { forall a. add a (opp a) =  zero a.rows a.cols }
  = ()

  let ghost opp_involutive () : unit
    ensures { forall m. opp (opp m) = m }
  = ()

  let ghost opposite_add () : unit
    ensures { forall m1 m2. m1 === m2 -> opp (add m1 m2) = add (opp m1) (opp m2) }
  = ()

  function ft1 (a b c: mat int) (i j: int)  : int -> int -> int =
                fun k -> smulf (mul_atom a b i k) (get c k j)

  function ft2 (a b c: mat int) (i j: int) : int -> int -> int =
                fun k -> smulf (mul_atom b c k j) (get a i k)

  let ghost mul_assoc_get (a b c: mat int) (i j: int) : unit
    requires { cols a = rows b }
    requires { cols b = rows c }
    requires { 0 <= i < (rows a) /\ 0 <= j < (cols c) }
    ensures  { get (mul (mul a b) c) i j = get (mul a (mul b c)) i j }
  = ()

  let ghost mul_assoc () : unit
    ensures { forall a b c. cols a = rows b -> cols b = rows c ->
              let ab = mul a b in
              let bc = mul b c in
              let a_bc = mul a bc in
              let ab_c = mul ab c in
              a_bc =  ab_c }
  = ()

  let ghost mul_distr_right_get (a b c: mat int) (i j: int) : unit
    requires { 0 <= i < rows a /\ 0 <= j < cols c }
    requires { cols b = rows c}
    requires { a === b }
    ensures  { get (mul (add a b) c) i j = get (add (mul a c) (mul b c)) i j }
  = ()

  let ghost mul_distr_right () : unit
    ensures { forall a b c.  a === b -> cols b = rows c ->
              mul (add a b) c = add (mul a c) (mul b c) }
  = ()

  let ghost mul_distr_left_get (a b c: mat int) (i j : int) : unit
    requires { 0 <= i < rows a /\ 0 <= j < cols c }
    requires { cols a = rows b }
    requires { b === c }
    ensures  { get (mul a (add b c)) i j = get (add (mul a b) (mul a c)) i j }
  = ()

  let ghost mul_distr_left () : unit
    ensures { forall a b c.  b === c -> cols a = rows b ->
              mul a (add b c) =  add (mul a b) (mul a c) }
  = ()

  let ghost mul_zero_right () : unit
    ensures { forall a c. 0 <= c -> mul a (zero a.cols c) = zero a.rows c }
  = ()

  let ghost mul_zero_left () : unit
    ensures { forall a r. 0 <= r -> mul (zero r a.rows) a = zero r a.cols }
  = ()

  let ghost mul_opp () : unit
    ensures { forall a b. a.cols = b.rows ->
              let oa = opp a in
              let ob = opp b in
              let ab = mul a b in
              let oab = opp ab in
              mul oa b = oab = mul a ob }
  = ()

end

module BlockMul

  use int.Int
  use int.Sum
  use sum_extended.Sum_extended
  use MyMatrix
  use MatrixArithmetic

  function ofs2 (a: mat int) (ai aj: int) : int -> int -> int
    = fun i j -> get a (ai + i) (aj + j)

  function block (a: mat int) (r dr c dc: int) : mat int =
    create dr dc (ofs2 a r c)

  predicate c_blocks (a a1 a2: mat int) =
    0 <= a1.cols <= a.cols /\ a1 = block a 0 a.rows 0 a1.cols /\
    a2 = block a 0 a.rows a1.cols (a.cols - a1.cols)

  predicate r_blocks (a a1 a2: mat int) =
    0 <= a1.rows <= a.rows /\ a1 = block a 0 a1.rows 0 a.cols /\
    a2 = block a a1.rows (a.rows - a1.rows) 0 a.cols

  let ghost block_mul_ij (a a1 a2 b b1 b2: mat int) (k: int) : unit
    requires { a.cols = b.rows /\ a1.cols = b1.rows}
    requires { 0 <= k <= a.cols }
    requires { c_blocks a a1 a2 /\ r_blocks b b1 b2 }
    ensures  { forall i j. 0 <= i < a.rows -> 0 <= j < b.cols ->
                 0 <= k <= a1.cols ->
                   sum (mul_atom a b i j) 0 k = sum (mul_atom a1 b1 i j) 0 k }
    ensures  { forall i j. 0 <= i < a.rows -> 0 <= j < b.cols ->
                a1.cols <= k <= a.cols ->
                  sum (mul_atom a b i j) 0 k  =
	            sum (mul_atom a1 b1 i j) 0 a1.cols +
		    sum (mul_atom a2 b2 i j) 0 (k - a1.cols) }
  = ()

  let ghost mul_split (a a1 a2 b b1 b2: mat int) : unit
    requires { a.cols = b.rows /\ a1.cols = b1.rows}
    requires { c_blocks a a1 a2 /\ r_blocks b b1 b2 }
    ensures  {add (mul a1 b1) (mul a2 b2) = mul a b }
  = ()

  let ghost mul_block_cell (a b: mat int) (r dr c dc i j: int) : unit
    requires { a.cols = b.rows }
    requires { 0 <= r /\ r + dr <= a.rows }
    requires { 0 <= c /\ c + dc <= b.cols }
    requires { 0 <= i < dr /\ 0 <= j < dc }
    ensures  { ofs2 (mul a b) r c i j =
               get (mul (block a r dr 0 a.cols) (block b 0 b.rows c dc)) i j }
  = ()

  let ghost mul_block () : unit
    ensures { forall a b: mat int, r dr c dc: int.
              a.cols = b.rows -> 0 <= r <= r + dr <= a.rows ->
              0 <= c <= c + dc <= b.cols ->
              let a' = block a r dr 0 a.cols in
              let b' = block b 0 b.rows c dc in
              let m' = block (mul a b) r dr c dc in
              m' =  mul a' b' }
  = ()

end
