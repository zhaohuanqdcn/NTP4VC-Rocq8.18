import Why3.Base
import pearl.string_search_vcg.lean.string_search.Spec
import pearl.string_search_vcg.lean.string_search.Occurs
import Why3.ocaml.Exceptions
open Classical
open Lean4Why3
namespace string_search_BadShiftTable_make_tableqtvc
axiom t : Type -> Type
axiom inhabited_axiom_t {χ : Type} [Inhabited χ] : Inhabited (t χ)
attribute [instance] inhabited_axiom_t
axiom to_fmap :  {χ : Type} -> [Inhabited χ] -> t χ -> Finmap (fun (_ : (BitVec 8)) => χ)
axiom bad_shift_table : Type
axiom inhabited_axiom_bad_shift_table : Inhabited bad_shift_table
attribute [instance] inhabited_axiom_bad_shift_table
axiom pat : bad_shift_table -> List (BitVec 8)
axiom sht : bad_shift_table -> t (BitVec 63)
axiom bad_shift_table'invariant (self : bad_shift_table) : (∀(j : ℤ) (c : BitVec 8), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length (pat self)) → c = (pat self)[Int.toNat j]! → c ∈ to_fmap (sht self)) ∧ (∀(c : BitVec 8), c ∈ to_fmap (sht self) → (1 : ℤ) ≤ BitVec.toInt (Finmap.lookup! (to_fmap (sht self)) c) ∧ BitVec.toInt (Finmap.lookup! (to_fmap (sht self)) c) ≤ Int.ofNat (List.length (pat self)) + (1 : ℤ)) ∧ (∀(c : BitVec 8), c ∈ to_fmap (sht self) → (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j < BitVec.toInt (Finmap.lookup! (to_fmap (sht self)) c) → ¬(pat self)[Int.toNat (Int.ofNat (List.length (pat self)) - j)]! = c))
noncomputable def bad_shift_table'eq (a : bad_shift_table) (b : bad_shift_table) := pat a = pat b ∧ sht a = sht b
axiom bad_shift_table'inj (a : bad_shift_table) (b : bad_shift_table) (fact0 : bad_shift_table'eq a b) : a = b
theorem make_table'vc (m : BitVec 63) (pat1 : List (BitVec 8)) (sht1 : t (BitVec 63)) (fact0 : BitVec.toInt m = Int.ofNat (List.length pat1)) (fact1 : (0 : ℤ) ≤ Int.ofNat (List.length pat1)) (fact2 : to_fmap sht1 = (∅ : Finmap (fun (_ : (BitVec 8)) => BitVec 63))) : int'63_in_bounds (BitVec.toInt m - (1 : ℤ)) ∧ (∀(o1 : BitVec 63), BitVec.toInt o1 = BitVec.toInt m - (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o1 + (1 : ℤ) → ((∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → pat1[Int.toNat j]! ∈ to_fmap sht1) ∧ (∀(c : BitVec 8), c ∈ to_fmap sht1 → (1 : ℤ) ≤ BitVec.toInt (Finmap.lookup! (to_fmap sht1) c) ∧ BitVec.toInt (Finmap.lookup! (to_fmap sht1) c) ≤ BitVec.toInt m + (1 : ℤ)) ∧ (∀(c : BitVec 8), c ∈ to_fmap sht1 → (∀(j : ℤ), BitVec.toInt m - BitVec.toInt (Finmap.lookup! (to_fmap sht1) c) < j ∧ j < (0 : ℤ) → ¬pat1[Int.toNat j]! = c))) ∧ (∀(sht2 : t (BitVec 63)), (∀(i : BitVec 63), let i1 : ℤ := BitVec.toInt i; ((0 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt o1) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i1 → pat1[Int.toNat j]! ∈ to_fmap sht2) ∧ (∀(c : BitVec 8), c ∈ to_fmap sht2 → (1 : ℤ) ≤ BitVec.toInt (Finmap.lookup! (to_fmap sht2) c) ∧ BitVec.toInt (Finmap.lookup! (to_fmap sht2) c) ≤ BitVec.toInt m + (1 : ℤ)) ∧ (∀(c : BitVec 8), c ∈ to_fmap sht2 → (∀(j : ℤ), BitVec.toInt m - BitVec.toInt (Finmap.lookup! (to_fmap sht2) c) < j ∧ j < i1 → ¬pat1[Int.toNat j]! = c)) → int'63_in_bounds (BitVec.toInt m - BitVec.toInt i) ∧ (∀(o2 : BitVec 63), BitVec.toInt o2 = BitVec.toInt m - BitVec.toInt i → ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i < Int.ofNat (List.length pat1)) ∧ (∀(sht3 : t (BitVec 63)), to_fmap sht3 = Finmap.insert (pat1[Int.toNat (BitVec.toInt i)]!) o2 (to_fmap sht2) → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i1 + (1 : ℤ) → pat1[Int.toNat j]! ∈ to_fmap sht3) ∧ (∀(c : BitVec 8), c ∈ to_fmap sht3 → (1 : ℤ) ≤ BitVec.toInt (Finmap.lookup! (to_fmap sht3) c) ∧ BitVec.toInt (Finmap.lookup! (to_fmap sht3) c) ≤ BitVec.toInt m + (1 : ℤ)) ∧ (∀(c : BitVec 8), c ∈ to_fmap sht3 → (∀(j : ℤ), BitVec.toInt m - BitVec.toInt (Finmap.lookup! (to_fmap sht3) c) < j ∧ j < i1 + (1 : ℤ) → ¬pat1[Int.toNat j]! = c))))) ∧ ((∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toInt o1 + (1 : ℤ) → pat1[Int.toNat j]! ∈ to_fmap sht2) ∧ (∀(c : BitVec 8), c ∈ to_fmap sht2 → (1 : ℤ) ≤ BitVec.toInt (Finmap.lookup! (to_fmap sht2) c) ∧ BitVec.toInt (Finmap.lookup! (to_fmap sht2) c) ≤ BitVec.toInt m + (1 : ℤ)) ∧ (∀(c : BitVec 8), c ∈ to_fmap sht2 → (∀(j : ℤ), BitVec.toInt m - BitVec.toInt (Finmap.lookup! (to_fmap sht2) c) < j ∧ j < BitVec.toInt o1 + (1 : ℤ) → ¬pat1[Int.toNat j]! = c)) → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length pat1) → pat1[Int.toNat j]! ∈ to_fmap sht2) ∧ (∀(c : BitVec 8), c ∈ to_fmap sht2 → (1 : ℤ) ≤ BitVec.toInt (Finmap.lookup! (to_fmap sht2) c) ∧ BitVec.toInt (Finmap.lookup! (to_fmap sht2) c) ≤ Int.ofNat (List.length pat1) + (1 : ℤ)) ∧ (∀(c : BitVec 8), c ∈ to_fmap sht2 → (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j < BitVec.toInt (Finmap.lookup! (to_fmap sht2) c) → ¬pat1[Int.toNat (Int.ofNat (List.length pat1) - j)]! = c))))) ∧ (BitVec.toInt o1 + (1 : ℤ) < (0 : ℤ) → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length pat1) → pat1[Int.toNat j]! ∈ to_fmap sht1) ∧ (∀(c : BitVec 8), c ∈ to_fmap sht1 → (1 : ℤ) ≤ BitVec.toInt (Finmap.lookup! (to_fmap sht1) c) ∧ BitVec.toInt (Finmap.lookup! (to_fmap sht1) c) ≤ Int.ofNat (List.length pat1) + (1 : ℤ)) ∧ (∀(c : BitVec 8), c ∈ to_fmap sht1 → (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j < BitVec.toInt (Finmap.lookup! (to_fmap sht1) c) → ¬pat1[Int.toNat (Int.ofNat (List.length pat1) - j)]! = c))))
  := sorry
end string_search_BadShiftTable_make_tableqtvc
