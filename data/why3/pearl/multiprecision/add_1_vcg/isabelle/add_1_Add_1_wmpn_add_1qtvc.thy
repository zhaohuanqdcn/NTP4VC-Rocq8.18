theory add_1_Add_1_wmpn_add_1qtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas"
begin
theorem wmpn_add_1'vc:
  fixes x :: "64 word ptr"
  fixes sz :: "32 word"
  fixes r :: "64 word ptr"
  fixes y :: "64 word"
  assumes fact0: "valid x (sint sz)"
  assumes fact1: "valid r (sint sz)"
  assumes fact2: "(0 :: int) < sint sz"
  assumes fact3: "writable r = True"
  shows "c_C.min x \<le> offset x"
  and "offset x < c_C.max x"
  and "let o1 :: 64 word = pelts x (offset x) in \<forall>(res :: 64 word). uint res = (uint o1 + uint y) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> ((c_C.min r \<le> offset r \<and> offset r < c_C.max r) \<and> writable r = True) \<and> (\<forall>(r1 :: 64 word ptr). length (data r1) = length (data r) \<and> offset r1 = offset r \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> writable r1 = writable r \<and> zone1 r1 = zone1 r \<longrightarrow> pelts r1 = (pelts r)(offset r1 := res) \<longrightarrow> (if uint res < uint o1 then (((1 :: int) \<le> (1 :: int) \<and> (1 :: int) \<le> sint sz) \<and> ((0 :: int) \<le> uint (1 :: 64 word) \<and> uint (1 :: 64 word) \<le> (1 :: int)) \<and> ((1 :: 32 word) = sz \<or> uint (1 :: 64 word) = (1 :: int)) \<and> value r1 (1 :: int) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (1 :: int) * uint (1 :: 64 word) = value x (1 :: int) + uint y \<and> (\<forall>(j :: int). j < offset r1 \<or> offset r1 + sint sz \<le> j \<longrightarrow> pelts r1 j = pelts r j)) \<and> (\<forall>(c :: 64 word) (i :: 32 word) (r2 :: 64 word ptr). length (data r2) = length (data r1) \<and> offset r2 = offset r1 \<and> c_C.min r2 = c_C.min r1 \<and> c_C.max r2 = c_C.max r1 \<and> writable r2 = writable r1 \<and> zone1 r2 = zone1 r1 \<longrightarrow> ((1 :: int) \<le> sint i \<and> sint i \<le> sint sz) \<and> ((0 :: int) \<le> uint c \<and> uint c \<le> (1 :: int)) \<and> (i = sz \<or> uint c = (1 :: int)) \<and> value r2 (sint i) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint i * uint c = value x (sint i) + uint y \<and> (\<forall>(j :: int). j < offset r2 \<or> offset r2 + sint sz \<le> j \<longrightarrow> pelts r2 j = pelts r j) \<longrightarrow> (if sint i < sint sz then (c_C.min x \<le> offset x + sint i \<and> offset x + sint i < c_C.max x) \<and> (\<forall>(res1 :: 64 word). uint res1 = (uint (pelts x (offset x + sint i)) + (1 :: int)) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> ((c_C.min r2 \<le> offset r2 + sint i \<and> offset r2 + sint i < c_C.max r2) \<and> writable r2 = True) \<and> (\<forall>(r3 :: 64 word ptr). length (data r3) = length (data r2) \<and> offset r3 = offset r2 \<and> c_C.min r3 = c_C.min r2 \<and> c_C.max r3 = c_C.max r2 \<and> writable r3 = writable r2 \<and> zone1 r3 = zone1 r2 \<longrightarrow> pelts r3 = (pelts r2)(offset r3 + sint i := res1) \<and> pelts r3 (offset r3 + sint i) = res1 \<longrightarrow> int'32_in_bounds (sint i + (1 :: int)) \<and> (\<forall>(o2 :: 32 word). sint o2 = sint i + (1 :: int) \<longrightarrow> (\<forall>(o3 :: bool). (uint res1 = uint (0 :: 64 word) \<longrightarrow> o3 = True) \<and> (o3 = True \<longrightarrow> res1 = (0 :: 64 word)) \<longrightarrow> (if \<not>o3 = True then ((o2 = sz \<or> uint (0 :: 64 word) = (0 :: int)) \<and> ((0 :: int) \<le> sint o2 \<and> sint o2 \<le> sint sz) \<and> value r3 (sint o2) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o2 * uint (0 :: 64 word) = value x (sint o2) + uint y \<and> (\<forall>(j :: int). j < offset r3 \<or> offset r3 + sint sz \<le> j \<longrightarrow> pelts r3 j = pelts r j)) \<and> (\<forall>(i1 :: 32 word) (r4 :: 64 word ptr). length (data r4) = length (data r3) \<and> offset r4 = offset r3 \<and> c_C.min r4 = c_C.min r3 \<and> c_C.max r4 = c_C.max r3 \<and> writable r4 = writable r3 \<and> zone1 r4 = zone1 r3 \<longrightarrow> (i1 = sz \<or> uint (0 :: 64 word) = (0 :: int)) \<and> ((0 :: int) \<le> sint i1 \<and> sint i1 \<le> sint sz) \<and> value r4 (sint i1) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint i1 * uint (0 :: 64 word) = value x (sint i1) + uint y \<and> (\<forall>(j :: int). j < offset r4 \<or> offset r4 + sint sz \<le> j \<longrightarrow> pelts r4 j = pelts r j) \<longrightarrow> (if sint i1 < sint sz then (c_C.min x \<le> offset x + sint i1 \<and> offset x + sint i1 < c_C.max x) \<and> ((c_C.min r4 \<le> offset r4 + sint i1 \<and> offset r4 + sint i1 < c_C.max r4) \<and> writable r4 = True) \<and> (\<forall>(r5 :: 64 word ptr). length (data r5) = length (data r4) \<and> offset r5 = offset r4 \<and> c_C.min r5 = c_C.min r4 \<and> c_C.max r5 = c_C.max r4 \<and> writable r5 = writable r4 \<and> zone1 r5 = zone1 r4 \<longrightarrow> pelts r5 = (pelts r4)(offset r5 + sint i1 := pelts x (offset x + sint i1)) \<and> pelts r5 (offset r5 + sint i1) = pelts x (offset x + sint i1) \<longrightarrow> int'32_in_bounds (sint i1 + (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint i1 + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint sz - sint i1 \<and> sint sz - sint o4 < sint sz - sint i1) \<and> (o4 = sz \<or> uint (0 :: 64 word) = (0 :: int)) \<and> ((0 :: int) \<le> sint o4 \<and> sint o4 \<le> sint sz) \<and> value r5 (sint o4) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o4 * uint (0 :: 64 word) = value x (sint o4) + uint y \<and> (\<forall>(j :: int). j < offset r5 \<or> offset r5 + sint sz \<le> j \<longrightarrow> pelts r5 j = pelts r j))) else value r4 (sint sz) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sz * uint (0 :: 64 word) = value x (sint sz) + uint y \<and> ((0 :: int) \<le> uint (0 :: 64 word) \<and> uint (0 :: 64 word) \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset r4 \<or> offset r4 + sint sz \<le> j \<longrightarrow> pelts r4 j = pelts r j))) else ((0 :: int) \<le> sint sz - sint i \<and> sint sz - sint o2 < sint sz - sint i) \<and> ((1 :: int) \<le> sint o2 \<and> sint o2 \<le> sint sz) \<and> ((0 :: int) \<le> uint c \<and> uint c \<le> (1 :: int)) \<and> (o2 = sz \<or> uint c = (1 :: int)) \<and> value r3 (sint o2) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o2 * uint c = value x (sint o2) + uint y \<and> (\<forall>(j :: int). j < offset r3 \<or> offset r3 + sint sz \<le> j \<longrightarrow> pelts r3 j = pelts r j)))))) else ((i = sz \<or> uint c = (0 :: int)) \<and> ((0 :: int) \<le> sint i \<and> sint i \<le> sint sz) \<and> value r2 (sint i) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint i * uint c = value x (sint i) + uint y \<and> (\<forall>(j :: int). j < offset r2 \<or> offset r2 + sint sz \<le> j \<longrightarrow> pelts r2 j = pelts r j)) \<and> (\<forall>(i1 :: 32 word) (r3 :: 64 word ptr). length (data r3) = length (data r2) \<and> offset r3 = offset r2 \<and> c_C.min r3 = c_C.min r2 \<and> c_C.max r3 = c_C.max r2 \<and> writable r3 = writable r2 \<and> zone1 r3 = zone1 r2 \<longrightarrow> (i1 = sz \<or> uint c = (0 :: int)) \<and> ((0 :: int) \<le> sint i1 \<and> sint i1 \<le> sint sz) \<and> value r3 (sint i1) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint i1 * uint c = value x (sint i1) + uint y \<and> (\<forall>(j :: int). j < offset r3 \<or> offset r3 + sint sz \<le> j \<longrightarrow> pelts r3 j = pelts r j) \<longrightarrow> (if sint i1 < sint sz then (c_C.min x \<le> offset x + sint i1 \<and> offset x + sint i1 < c_C.max x) \<and> ((c_C.min r3 \<le> offset r3 + sint i1 \<and> offset r3 + sint i1 < c_C.max r3) \<and> writable r3 = True) \<and> (\<forall>(r4 :: 64 word ptr). length (data r4) = length (data r3) \<and> offset r4 = offset r3 \<and> c_C.min r4 = c_C.min r3 \<and> c_C.max r4 = c_C.max r3 \<and> writable r4 = writable r3 \<and> zone1 r4 = zone1 r3 \<longrightarrow> pelts r4 = (pelts r3)(offset r4 + sint i1 := pelts x (offset x + sint i1)) \<and> pelts r4 (offset r4 + sint i1) = pelts x (offset x + sint i1) \<longrightarrow> int'32_in_bounds (sint i1 + (1 :: int)) \<and> (\<forall>(o2 :: 32 word). sint o2 = sint i1 + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint sz - sint i1 \<and> sint sz - sint o2 < sint sz - sint i1) \<and> (o2 = sz \<or> uint c = (0 :: int)) \<and> ((0 :: int) \<le> sint o2 \<and> sint o2 \<le> sint sz) \<and> value r4 (sint o2) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o2 * uint c = value x (sint o2) + uint y \<and> (\<forall>(j :: int). j < offset r4 \<or> offset r4 + sint sz \<le> j \<longrightarrow> pelts r4 j = pelts r j))) else value r3 (sint sz) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sz * uint c = value x (sint sz) + uint y \<and> ((0 :: int) \<le> uint c \<and> uint c \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset r3 \<or> offset r3 + sint sz \<le> j \<longrightarrow> pelts r3 j = pelts r j))))) else (((0 :: int) \<le> (1 :: int) \<and> (1 :: int) \<le> sint sz) \<and> value r1 (1 :: int) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (1 :: int) * (0 :: int) = value x (1 :: int) + uint y \<and> (\<forall>(j :: int). j < offset r1 \<or> offset r1 + sint sz \<le> j \<longrightarrow> pelts r1 j = pelts r j)) \<and> (\<forall>(i :: 32 word) (r2 :: 64 word ptr). length (data r2) = length (data r1) \<and> offset r2 = offset r1 \<and> c_C.min r2 = c_C.min r1 \<and> c_C.max r2 = c_C.max r1 \<and> writable r2 = writable r1 \<and> zone1 r2 = zone1 r1 \<longrightarrow> ((0 :: int) \<le> sint i \<and> sint i \<le> sint sz) \<and> value r2 (sint i) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint i * (0 :: int) = value x (sint i) + uint y \<and> (\<forall>(j :: int). j < offset r2 \<or> offset r2 + sint sz \<le> j \<longrightarrow> pelts r2 j = pelts r j) \<longrightarrow> (if sint i < sint sz then (c_C.min x \<le> offset x + sint i \<and> offset x + sint i < c_C.max x) \<and> ((c_C.min r2 \<le> offset r2 + sint i \<and> offset r2 + sint i < c_C.max r2) \<and> writable r2 = True) \<and> (\<forall>(r3 :: 64 word ptr). length (data r3) = length (data r2) \<and> offset r3 = offset r2 \<and> c_C.min r3 = c_C.min r2 \<and> c_C.max r3 = c_C.max r2 \<and> writable r3 = writable r2 \<and> zone1 r3 = zone1 r2 \<longrightarrow> pelts r3 = (pelts r2)(offset r3 + sint i := pelts x (offset x + sint i)) \<and> pelts r3 (offset r3 + sint i) = pelts x (offset x + sint i) \<longrightarrow> int'32_in_bounds (sint i + (1 :: int)) \<and> (\<forall>(o2 :: 32 word). sint o2 = sint i + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint sz - sint i \<and> sint sz - sint o2 < sint sz - sint i) \<and> ((0 :: int) \<le> sint o2 \<and> sint o2 \<le> sint sz) \<and> value r3 (sint o2) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o2 * (0 :: int) = value x (sint o2) + uint y \<and> (\<forall>(j :: int). j < offset r3 \<or> offset r3 + sint sz \<le> j \<longrightarrow> pelts r3 j = pelts r j))) else value r2 (sint sz) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sz * (0 :: int) = value x (sint sz) + uint y \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset r2 \<or> offset r2 + sint sz \<le> j \<longrightarrow> pelts r2 j = pelts r j)))))"
  sorry
end
