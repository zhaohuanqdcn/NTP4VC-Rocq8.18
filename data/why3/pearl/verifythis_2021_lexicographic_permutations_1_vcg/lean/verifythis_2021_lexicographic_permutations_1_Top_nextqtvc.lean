import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
open Classical
open Lean4Why3
namespace verifythis_2021_lexicographic_permutations_1_Top_nextqtvc
axiom elt : Type
axiom inhabited_axiom_elt : Inhabited elt
attribute [instance] inhabited_axiom_elt
axiom permutation : Type
axiom inhabited_axiom_permutation : Inhabited permutation
attribute [instance] inhabited_axiom_permutation
noncomputable def lt (p : List ℤ) (q : List ℤ) := (List.length p = List.length q ∧ (0 : ℤ) < Int.ofNat (List.length q)) ∧ (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length p)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → p[Int.toNat j]! = q[Int.toNat j]!) ∧ p[Int.toNat i]! < q[Int.toNat i]!)
axiom iseq :  {α : Type} -> [Inhabited α] -> α -> List α -> ℤ -> Bool
axiom iseq'def {α : Type} [Inhabited α] (x : α) (s : List α) (i : ℤ) : (iseq x s i = true) = (s[Int.toNat i]! = x)
noncomputable def occ {α : Type} [Inhabited α] (x : α) (s : List α) (l : ℤ) (u : ℤ) := NumOf.numof (iseq x s) l u
noncomputable def occ_all {α : Type} [Inhabited α] (x : α) (s : List α) := occ x s (0 : ℤ) (Int.ofNat (List.length s))
noncomputable def is_permutation_of (p : List ℤ) (a : List ℤ) := List.length p = List.length a ∧ (∀(x : ℤ), occ_all x p = occ_all x a)
noncomputable def descending (s : List ℤ) (lo : ℤ) (hi : ℤ) := ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ Int.ofNat (List.length s)) ∧ (∀(i : ℤ) (j : ℤ), lo ≤ i ∧ i ≤ j ∧ j < hi → s[Int.toNat j]! ≤ s[Int.toNat i]!)
noncomputable def ascending (s : List ℤ) (lo : ℤ) (hi : ℤ) := ((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ Int.ofNat (List.length s)) ∧ (∀(i : ℤ) (j : ℤ), lo ≤ i ∧ i ≤ j ∧ j < hi → s[Int.toNat i]! ≤ s[Int.toNat j]!)
axiom to_seq : List ℤ -> List ℤ
axiom to_seq'spec'0 (a : List ℤ) : List.length (to_seq a) = List.length a
axiom to_seq'spec (i : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ i) (fact1 : i < Int.ofNat (List.length (to_seq a))) : (to_seq a)[Int.toNat i]! = a[Int.toNat i]!
theorem next'vc (a : List ℤ) (a0 : List ℤ) (fact0 : List.length a = List.length a0) (fact1 : is_permutation_of (to_seq a) a0) : let n : ℤ := Int.ofNat (List.length a); let o1 : ℤ := n - (1 : ℤ); ((-(1 : ℤ) ≤ o1 ∧ o1 < n) ∧ (o1 = -(1 : ℤ) ∧ n = (0 : ℤ) ∨ (0 : ℤ) ≤ o1 ∧ descending (to_seq a) o1 n)) ∧ (∀(i : ℤ), (-(1 : ℤ) ≤ i ∧ i < n) ∧ (i = -(1 : ℤ) ∧ n = (0 : ℤ) ∨ (0 : ℤ) ≤ i ∧ descending (to_seq a) i n) → ((0 : ℤ) < i → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let o2 : ℤ := i - (1 : ℤ); (0 : ℤ) ≤ o2 ∧ o2 < Int.ofNat (List.length a))) ∧ (∀(o2 : Bool), (if (0 : ℤ) < i then o2 = (if a[Int.toNat i]! ≤ a[Int.toNat (i - (1 : ℤ))]! then true else false) else o2 = false) → (if o2 = true then ((0 : ℤ) ≤ i ∧ i - (1 : ℤ) < i) ∧ (-(1 : ℤ) ≤ i - (1 : ℤ) ∧ i - (1 : ℤ) < n) ∧ (i - (1 : ℤ) = -(1 : ℤ) ∧ n = (0 : ℤ) ∨ (0 : ℤ) ≤ i - (1 : ℤ) ∧ descending (to_seq a) (i - (1 : ℤ)) n) else if i ≤ (0 : ℤ) then is_permutation_of (to_seq a) a0 ∧ (∀(p : List ℤ), is_permutation_of p a0 → ¬lt (to_seq a) p) else let i0 : ℤ := i - (1 : ℤ); ((0 : ℤ) ≤ i0 ∧ i0 < Int.ofNat (List.length a)) ∧ (let x : ℤ := a[Int.toNat i0]!; let o3 : ℤ := n - (1 : ℤ); ((i ≤ o3 ∧ o3 < n) ∧ (∀(k : ℤ), o3 < k ∧ k < n → a[Int.toNat k]! ≤ x)) ∧ (∀(j : ℤ), (i ≤ j ∧ j < n) ∧ (∀(k : ℤ), j < k ∧ k < n → a[Int.toNat k]! ≤ x) → (let o4 : ℤ := i - (1 : ℤ); ((0 : ℤ) ≤ o4 ∧ o4 < Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a)) ∧ (if a[Int.toNat j]! ≤ a[Int.toNat o4]! then ((0 : ℤ) ≤ j ∧ j - (1 : ℤ) < j) ∧ (i ≤ j - (1 : ℤ) ∧ j - (1 : ℤ) < n) ∧ (∀(k : ℤ), j - (1 : ℤ) < k ∧ k < n → a[Int.toNat k]! ≤ x) else ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a)) ∧ (let z : ℤ := a[Int.toNat j]!; let o5 : ℤ := i - (1 : ℤ); (((0 : ℤ) ≤ o5 ∧ o5 < Int.ofNat (List.length a)) ∧ (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a)) ∧ (∀(a1 : List ℤ), List.length a1 = List.length a → a1[Int.toNat o5]! = a[Int.toNat j]! ∧ a1[Int.toNat j]! = a[Int.toNat o5]! ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length a1) → ¬k = o5 → ¬k = j → a1[Int.toNat k]! = a[Int.toNat k]!) ∧ is_permutation_of (to_seq a1) (to_seq a) → ((i0 < i ∧ i0 < n - (1 : ℤ) ∧ n - (1 : ℤ) < n) ∧ is_permutation_of (to_seq a1) a0 ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i0 → a1[Int.toNat k]! = a[Int.toNat k]!) ∧ a1[Int.toNat i0]! = z ∧ i - i0 = n - (n - (1 : ℤ)) ∧ (∀(k : ℤ), (0 : ℤ) < k ∧ k < i - i0 → a1[Int.toNat (i0 + k)]! = a1[Int.toNat (n - k)]! ∧ a1[Int.toNat (n - k)]! = a1[Int.toNat (i0 + k)]!)) ∧ (∀(j1 : ℤ) (i1 : ℤ) (a2 : List ℤ), List.length a2 = List.length a1 → (i0 < i1 ∧ i0 < j1 ∧ j1 < n) ∧ is_permutation_of (to_seq a2) a0 ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i0 → a2[Int.toNat k]! = a[Int.toNat k]!) ∧ a2[Int.toNat i0]! = z ∧ i1 - i0 = n - j1 ∧ (∀(k : ℤ), i1 ≤ k ∧ k ≤ j1 → a2[Int.toNat k]! = a1[Int.toNat k]!) ∧ (∀(k : ℤ), (0 : ℤ) < k ∧ k < i1 - i0 → a2[Int.toNat (i0 + k)]! = a1[Int.toNat (n - k)]! ∧ a2[Int.toNat (n - k)]! = a1[Int.toNat (i0 + k)]!) → (if i1 < j1 then (((0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a2)) ∧ (0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a2)) ∧ (∀(a3 : List ℤ), List.length a3 = List.length a2 → a3[Int.toNat i1]! = a2[Int.toNat j1]! ∧ a3[Int.toNat j1]! = a2[Int.toNat i1]! ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length a3) → ¬k = i1 → ¬k = j1 → a3[Int.toNat k]! = a2[Int.toNat k]!) ∧ is_permutation_of (to_seq a3) (to_seq a2) → ((0 : ℤ) ≤ j1 - i1 ∧ j1 - (1 : ℤ) - (i1 + (1 : ℤ)) < j1 - i1) ∧ (i0 < i1 + (1 : ℤ) ∧ i0 < j1 - (1 : ℤ) ∧ j1 - (1 : ℤ) < n) ∧ is_permutation_of (to_seq a3) a0 ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i0 → a3[Int.toNat k]! = a[Int.toNat k]!) ∧ a3[Int.toNat i0]! = z ∧ i1 + (1 : ℤ) - i0 = n - (j1 - (1 : ℤ)) ∧ (∀(k : ℤ), i1 + (1 : ℤ) ≤ k ∧ k ≤ j1 - (1 : ℤ) → a3[Int.toNat k]! = a1[Int.toNat k]!) ∧ (∀(k : ℤ), (0 : ℤ) < k ∧ k < i1 + (1 : ℤ) - i0 → a3[Int.toNat (i0 + k)]! = a1[Int.toNat (n - k)]! ∧ a3[Int.toNat (n - k)]! = a1[Int.toNat (i0 + k)]!)) else (∀(p : List ℤ), is_permutation_of p a0 ∧ lt (to_seq a) p ∧ lt p (to_seq a2) → (let a11 : List ℤ := to_seq a; let v : ℤ := p[Int.toNat i0]!; if v = x then let o6 : ℤ := n - (1 : ℤ); let o7 : ℤ := i0 + (1 : ℤ); (o7 ≤ o6 + (1 : ℤ) → (∀(k : ℤ), i0 + (1 : ℤ) ≤ k ∧ k < o7 → p[Int.toNat k]! = a11[Int.toNat k]!) ∧ (∀(l : ℤ), (o7 ≤ l ∧ l ≤ o6) ∧ (∀(k : ℤ), i0 + (1 : ℤ) ≤ k ∧ k < l → p[Int.toNat k]! = a11[Int.toNat k]!) → p[Int.toNat l]! = a11[Int.toNat l]! ∧ (∀(k : ℤ), i0 + (1 : ℤ) ≤ k ∧ k < l + (1 : ℤ) → p[Int.toNat k]! = a11[Int.toNat k]!)) ∧ ¬(∀(k : ℤ), i0 + (1 : ℤ) ≤ k ∧ k < o6 + (1 : ℤ) → p[Int.toNat k]! = a11[Int.toNat k]!)) ∧ ¬o6 + (1 : ℤ) < o7 else v = z ∧ (let a21 : List ℤ := to_seq a2; List.length a21 = List.length a2 ∧ (∀(i2 : ℤ), (0 : ℤ) ≤ i2 ∧ i2 < Int.ofNat (List.length a21) → a21[Int.toNat i2]! = a2[Int.toNat i2]!) → (let o6 : ℤ := n - (1 : ℤ); let o7 : ℤ := i0 + (1 : ℤ); (o7 ≤ o6 + (1 : ℤ) → (∀(k : ℤ), i0 + (1 : ℤ) ≤ k ∧ k < o7 → p[Int.toNat k]! = a21[Int.toNat k]!) ∧ (∀(l : ℤ), (o7 ≤ l ∧ l ≤ o6) ∧ (∀(k : ℤ), i0 + (1 : ℤ) ≤ k ∧ k < l → p[Int.toNat k]! = a21[Int.toNat k]!) → p[Int.toNat l]! = a21[Int.toNat l]! ∧ (∀(k : ℤ), i0 + (1 : ℤ) ≤ k ∧ k < l + (1 : ℤ) → p[Int.toNat k]! = a21[Int.toNat k]!)) ∧ ¬(∀(k : ℤ), i0 + (1 : ℤ) ≤ k ∧ k < o6 + (1 : ℤ) → p[Int.toNat k]! = a21[Int.toNat k]!)) ∧ ¬o6 + (1 : ℤ) < o7)))) ∧ ((∀(p : List ℤ), ¬(is_permutation_of p a0 ∧ lt (to_seq a) p ∧ lt p (to_seq a2))) → is_permutation_of (to_seq a2) a0 ∧ lt (to_seq a) (to_seq a2) ∧ (∀(p : List ℤ), is_permutation_of p a0 → ¬(lt (to_seq a) p ∧ lt p (to_seq a2)))))))))))))))
  := sorry
end verifythis_2021_lexicographic_permutations_1_Top_nextqtvc
