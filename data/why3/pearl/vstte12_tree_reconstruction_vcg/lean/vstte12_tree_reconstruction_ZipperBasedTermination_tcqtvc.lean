import Why3.Base
import pearl.vstte12_tree_reconstruction_vcg.lean.vstte12_tree_reconstruction.Tree
open Classical
open Lean4Why3
namespace vstte12_tree_reconstruction_ZipperBasedTermination_tcqtvc
theorem tc'vc (right1 : List (ℤ × Tree.tree)) (left1 : List (ℤ × Tree.tree)) : match right1 with | ([] : List (ℤ × Tree.tree)) => True | List.cons x x1 => (match x1 with | ([] : List (ℤ × Tree.tree)) => (match x with | (x2, x3) => (match left1 with | ([] : List (ℤ × Tree.tree)) => True | List.cons x4 x5 => (match x4 with | (x6, x7) => (if x6 = x2 then let o1 : List (ℤ × Tree.tree) := List.cons (x6 - (1 : ℤ), Tree.tree.Node x7 x3) x1; (0 : ℤ) ≤ Int.ofNat (List.length left1) + Int.ofNat (List.length right1) ∧ Int.ofNat (List.length x5) + Int.ofNat (List.length o1) < Int.ofNat (List.length left1) + Int.ofNat (List.length right1) ∨ Int.ofNat (List.length left1) + Int.ofNat (List.length right1) = Int.ofNat (List.length x5) + Int.ofNat (List.length o1) ∧ (0 : ℤ) ≤ Int.ofNat (List.length right1) ∧ List.length o1 < List.length right1 else let o1 : List (ℤ × Tree.tree) := List.cons (x2, x3) left1; (0 : ℤ) ≤ Int.ofNat (List.length left1) + Int.ofNat (List.length right1) ∧ Int.ofNat (List.length o1) + Int.ofNat (List.length x1) < Int.ofNat (List.length left1) + Int.ofNat (List.length right1) ∨ Int.ofNat (List.length left1) + Int.ofNat (List.length right1) = Int.ofNat (List.length o1) + Int.ofNat (List.length x1) ∧ (0 : ℤ) ≤ Int.ofNat (List.length right1) ∧ List.length x1 < List.length right1)))) | _ => (match x with | (x2, x3) => (match left1 with | ([] : List (ℤ × Tree.tree)) => (let o1 : List (ℤ × Tree.tree) := List.cons (x2, x3) ([] : List (ℤ × Tree.tree)); (0 : ℤ) ≤ Int.ofNat (List.length left1) + Int.ofNat (List.length right1) ∧ Int.ofNat (List.length o1) + Int.ofNat (List.length x1) < Int.ofNat (List.length left1) + Int.ofNat (List.length right1) ∨ Int.ofNat (List.length left1) + Int.ofNat (List.length right1) = Int.ofNat (List.length o1) + Int.ofNat (List.length x1) ∧ (0 : ℤ) ≤ Int.ofNat (List.length right1) ∧ List.length x1 < List.length right1) | List.cons x4 x5 => (match x4 with | (x6, x7) => (if x6 = x2 then let o1 : List (ℤ × Tree.tree) := List.cons (x6 - (1 : ℤ), Tree.tree.Node x7 x3) x1; (0 : ℤ) ≤ Int.ofNat (List.length left1) + Int.ofNat (List.length right1) ∧ Int.ofNat (List.length x5) + Int.ofNat (List.length o1) < Int.ofNat (List.length left1) + Int.ofNat (List.length right1) ∨ Int.ofNat (List.length left1) + Int.ofNat (List.length right1) = Int.ofNat (List.length x5) + Int.ofNat (List.length o1) ∧ (0 : ℤ) ≤ Int.ofNat (List.length right1) ∧ List.length o1 < List.length right1 else let o1 : List (ℤ × Tree.tree) := List.cons (x2, x3) left1; (0 : ℤ) ≤ Int.ofNat (List.length left1) + Int.ofNat (List.length right1) ∧ Int.ofNat (List.length o1) + Int.ofNat (List.length x1) < Int.ofNat (List.length left1) + Int.ofNat (List.length right1) ∨ Int.ofNat (List.length left1) + Int.ofNat (List.length right1) = Int.ofNat (List.length o1) + Int.ofNat (List.length x1) ∧ (0 : ℤ) ≤ Int.ofNat (List.length right1) ∧ List.length x1 < List.length right1)))))
  := sorry
end vstte12_tree_reconstruction_ZipperBasedTermination_tcqtvc
