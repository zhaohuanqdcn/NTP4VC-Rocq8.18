import Why3.Base
import Why3.why3.Ref.Ref
import pearl.vstte12_bfs_vcg.lean.vstte12_bfs.Graph
open Classical
open Lean4Why3
namespace vstte12_bfs_BFS_bfsqtvc
axiom set : Type
axiom inhabited_axiom_set : Inhabited set
attribute [instance] inhabited_axiom_set
axiom to_fset : set -> Finset Graph.vertex
axiom choose1 : set -> Graph.vertex
axiom choose'spec (s : set) (fact0 : ¬to_fset s = ∅) : choose1 s ∈ to_fset s
noncomputable def inv (s : Graph.vertex) (t : Graph.vertex) (visited : Finset Graph.vertex) (current : Finset Graph.vertex) (next : Finset Graph.vertex) (d : ℤ) := current ⊆ visited ∧ (∀(x : Graph.vertex), x ∈ current → Graph.shortest_path s x d) ∧ next ⊆ visited ∧ (∀(x : Graph.vertex), x ∈ next → Graph.shortest_path s x (d + (1 : ℤ))) ∧ (∀(x : Graph.vertex) (m : ℤ), Graph.path s x m → m ≤ d → x ∈ visited) ∧ (∀(x : Graph.vertex), x ∈ visited → (∃(m : ℤ), Graph.path s x m ∧ m ≤ d + (1 : ℤ))) ∧ (∀(x : Graph.vertex), Graph.shortest_path s x (d + (1 : ℤ)) → x ∈ next ∨ ¬x ∈ visited) ∧ (t ∈ visited → t ∈ current ∨ t ∈ next)
noncomputable def closure (visited : Finset Graph.vertex) (current : Finset Graph.vertex) (next : Finset Graph.vertex) (x : Graph.vertex) := x ∈ visited → ¬x ∈ current → ¬x ∈ next → (∀(y : Graph.vertex), y ∈ Graph.succ x → y ∈ visited)
theorem bfs'vc (visited : set) (o1 : set) (o2 : set) (visited1 : set) (s : Graph.vertex) (current : set) (t : Graph.vertex) (fact0 : to_fset visited = (∅ : Finset Graph.vertex)) (fact1 : Int.ofNat (Finset.card (to_fset visited)) = (0 : ℤ)) (fact2 : to_fset o1 = (∅ : Finset Graph.vertex)) (fact3 : Int.ofNat (Finset.card (to_fset o1)) = (0 : ℤ)) (fact4 : to_fset o2 = (∅ : Finset Graph.vertex)) (fact5 : Int.ofNat (Finset.card (to_fset o2)) = (0 : ℤ)) (fact6 : to_fset visited1 = insert s (to_fset visited)) (fact7 : if s ∈ to_fset visited then Finset.card (to_fset visited1) = Finset.card (to_fset visited) else Int.ofNat (Finset.card (to_fset visited1)) = Int.ofNat (Finset.card (to_fset visited)) + (1 : ℤ)) (fact8 : to_fset current = insert s (to_fset o1)) (fact9 : if s ∈ to_fset o1 then Finset.card (to_fset current) = Finset.card (to_fset o1) else Int.ofNat (Finset.card (to_fset current)) = Int.ofNat (Finset.card (to_fset o1)) + (1 : ℤ)) : inv s t (to_fset visited1) (to_fset current) (to_fset o2) (0 : ℤ) ∧ (to_fset current = ∅ → to_fset o2 = ∅) ∧ (∀(x : Graph.vertex), closure (to_fset visited1) (to_fset current) (to_fset o2) x) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (∀(d : ℤ) (next : set) (current1 : set) (visited2 : set), inv s t (to_fset visited2) (to_fset current1) (to_fset next) d ∧ (to_fset current1 = ∅ → to_fset next = ∅) ∧ (∀(x : Graph.vertex), closure (to_fset visited2) (to_fset current1) (to_fset next) x) ∧ (0 : ℤ) ≤ d → (if ¬to_fset current1 = ∅ then ¬to_fset current1 = ∅ ∧ (∀(current2 : set), let v : Graph.vertex := choose1 current1; v ∈ to_fset current1 ∧ to_fset current2 = Finset.erase (to_fset current1) v → Graph.eq v t = (v = t) → (if Graph.eq v t then Graph.shortest_path s t d else (inv s t (to_fset visited2) (to_fset current2) (to_fset next) d ∧ Graph.shortest_path s v d ∧ (∀(x : Graph.vertex), ¬x = v → closure (to_fset visited2) (to_fset current2) (to_fset next) x)) ∧ (∀(next1 : set) (visited3 : set), inv s t (to_fset visited3) (to_fset current2) (to_fset next1) d ∧ Graph.succ v ⊆ to_fset visited3 ∧ (∀(x : Graph.vertex), closure (to_fset visited3) (to_fset current2) (to_fset next1) x) → (if to_fset current2 = ∅ then ∀(o3 : set), to_fset o3 = (∅ : Finset Graph.vertex) ∧ Int.ofNat (Finset.card (to_fset o3)) = (0 : ℤ) → inv s t (to_fset visited3) (to_fset next1) (to_fset o3) (d + (1 : ℤ)) ∧ (to_fset next1 = ∅ → to_fset o3 = ∅) ∧ (∀(x : Graph.vertex), closure (to_fset visited3) (to_fset next1) (to_fset o3) x) ∧ (0 : ℤ) ≤ d + (1 : ℤ) else inv s t (to_fset visited3) (to_fset current2) (to_fset next1) d ∧ (to_fset current2 = ∅ → to_fset next1 = ∅) ∧ (∀(x : Graph.vertex), closure (to_fset visited3) (to_fset current2) (to_fset next1) x) ∧ (0 : ℤ) ≤ d)))) else ∀(d1 : ℤ), ¬Graph.path s t d1))
  := sorry
end vstte12_bfs_BFS_bfsqtvc
