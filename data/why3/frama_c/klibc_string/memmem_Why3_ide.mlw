(* ---------------------------------------------------------- *)
(* --- Complete behaviors 'occr', 'not_occur', 'err'      --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_complete_occr_not_occur_err
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Complete behaviors 'occr', 'not_occur', 'err'":
*)
goal goal0:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_5 a_4 a_3 a_2 a_1 a : addr.
  let a_6 = (shift_sint8 a_4 0) in
  let a_7 = (shift_sint8 a_5 0) in
  (0 <= i) ->
  (0 <= i_1) ->
  (((region (a_4.base))) <= 0) ->
  (((region (a_5.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_6 i_1)) ->
  ((valid_rw t a_7 i)) ->
  ((separated a_7 i a_6 i_1)) ->
  ((i = 0) \/ (i_1 = 0) \/ (i < i_1) \/
   ((i <> 0) /\ (i_1 <> 0) /\ (i_1 <= i) /\
    (forall i_2 : int. (0 <= i_2) -> ((i_2 + i_1) <= i) ->
     (exists i_3 : int.
      (t_1[(shift_uint8 a_3 (i_3 + i_2))] <> t_1[(shift_uint8 a_2 i_3)]) /\
      (0 <= i_3) /\ (i_3 < i_1)))) \/
   ((i <> 0) /\ (i_1 <> 0) /\ (i_1 <= i) /\
    (exists i_2 : int. (0 <= i_2) /\ ((i_2 + i_1) <= i) /\
     (forall i_3 : int. (0 <= i_3) -> (i_3 < i_1) ->
      (t_1[(shift_uint8 a_1 (i_3 + i_2))] = t_1[(shift_uint8 a i_3)])))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'occr', 'not_occur', 'err' (1/3) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_disjoint_occr_not_occur_err_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Disjoint behaviors 'occr', 'not_occur', 'err' (1/3)":
*)
goal goal1:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_3 a_2 a_1 a : addr.
  let a_4 = (shift_sint8 a_2 0) in
  let a_5 = (shift_sint8 a_3 0) in
  (0 <= i) ->
  (0 <= i_1) ->
  (((region (a_2.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_4 i_1)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i_1)) ->
  ((i = 0) \/ (i_1 = 0) \/ (i < i_1) \/
   ((i <> 0) /\ (i_1 <> 0) /\ (i_1 <= i)) \/
   (exists i_2 : int. (0 <= i_2) /\ ((i_2 + i_1) <= i) /\
    (forall i_3 : int.
     (t_1[(shift_uint8 a_1 (i_3 + i_2))] = t_1[(shift_uint8 a i_3)]) \/
     (i_3 < 0) \/ (i_1 <= i_3))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'occr', 'not_occur', 'err' (2/3) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_disjoint_occr_not_occur_err_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Disjoint behaviors 'occr', 'not_occur', 'err' (2/3)":
*)
goal goal2:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_3 a_2 a_1 a : addr.
  let a_4 = (shift_sint8 a_2 0) in
  let a_5 = (shift_sint8 a_3 0) in
  (0 <= i) ->
  (0 <= i_1) ->
  (((region (a_2.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_4 i_1)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i_1)) ->
  ((i = 0) \/ (i_1 = 0) \/ (i < i_1) \/
   ((i <> 0) /\ (i_1 <> 0) /\ (i_1 <= i)) \/
   (forall i_2 : int. (i_2 < 0) \/ (i < (i_2 + i_1)) \/
    (exists i_3 : int.
     (t_1[(shift_uint8 a_1 (i_3 + i_2))] <> t_1[(shift_uint8 a i_3)]) /\
     (0 <= i_3) /\ (i_3 < i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'occr', 'not_occur', 'err' (3/3) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_disjoint_occr_not_occur_err_part3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Disjoint behaviors 'occr', 'not_occur', 'err' (3/3)":
*)
goal goal3:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_5 a_4 a_3 a_2 a_1 a : addr.
  let a_6 = (shift_sint8 a_4 0) in
  let a_7 = (shift_sint8 a_5 0) in
  (0 <= i) ->
  (0 <= i_1) ->
  (((region (a_4.base))) <= 0) ->
  (((region (a_5.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_6 i_1)) ->
  ((valid_rw t a_7 i)) ->
  ((separated a_7 i a_6 i_1)) ->
  ((i = 0) \/ (i_1 = 0) \/ (i < i_1) \/
   (forall i_2 : int. (i_2 < 0) \/ (i < (i_2 + i_1)) \/
    (exists i_3 : int.
     (t_1[(shift_uint8 a_1 (i_3 + i_2))] <> t_1[(shift_uint8 a i_3)]) /\
     (0 <= i_3) /\ (i_3 < i_1))) \/
   (exists i_2 : int. (0 <= i_2) /\ ((i_2 + i_1) <= i) /\
    (forall i_3 : int.
     (t_1[(shift_uint8 a_3 (i_3 + i_2))] = t_1[(shift_uint8 a_2 i_3)]) \/
     (i_3 < 0) \/ (i_1 <= i_3))))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file memmem.c, line 62) (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_3_established_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Establishment of Invariant (file memmem.c, line 62) (1/2)":
*)
goal goal4:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_2 a_1 a : addr.
  let x = t_1[(shift_uint8 a 1)] in
  let x_1 = t_1[(shift_uint8 a 0)] in
  let x_2 = a_1.base in
  let a_3 = (shift_sint8 a_1 0) in
  let a_4 = (shift_sint8 a_2 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = x_1) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (((region x_2)) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_1)) ->
  ((is_uint8 x)) ->
  ((valid_rw t a_3 i_1)) ->
  ((valid_rw t a_4 i)) ->
  ((separated a_4 i a_3 i_1)) ->
  (x_2 = (a.base))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file memmem.c, line 62) (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_3_established_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Establishment of Invariant (file memmem.c, line 62) (2/2)":
*)
goal goal5:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_2 a_1 a : addr.
  let x = t_1[(shift_uint8 a 1)] in
  let x_1 = t_1[(shift_uint8 a 0)] in
  let x_2 = a_1.base in
  let a_3 = (shift_sint8 a_1 0) in
  let a_4 = (shift_sint8 a_2 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x <> x_1) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (((region x_2)) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_1)) ->
  ((is_uint8 x)) ->
  ((valid_rw t a_3 i_1)) ->
  ((valid_rw t a_4 i)) ->
  ((separated a_4 i a_3 i_1)) ->
  (x_2 = (a.base))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file memmem.c, line 63) (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_4_established_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Establishment of Invariant (file memmem.c, line 63) (1/2)":
*)
goal goal6:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_3 a_2 a_1 a : addr.
  let x = t_1[(shift_uint8 a_1 1)] in
  let x_1 = t_1[(shift_uint8 a_1 0)] in
  let x_2 = a_3.base in
  let a_4 = (shift_sint8 a_2 0) in
  let a_5 = (shift_sint8 a_3 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = x_1) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (((region (a_2.base))) <= 0) ->
  (((region x_2)) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_1)) ->
  ((is_uint8 x)) ->
  ((valid_rw t a_4 i_1)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i_1)) ->
  (x_2 = (a.base))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file memmem.c, line 63) (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_4_established_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Establishment of Invariant (file memmem.c, line 63) (2/2)":
*)
goal goal7:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_3 a_2 a_1 a : addr.
  let x = t_1[(shift_uint8 a_1 1)] in
  let x_1 = t_1[(shift_uint8 a_1 0)] in
  let x_2 = a_3.base in
  let a_4 = (shift_sint8 a_2 0) in
  let a_5 = (shift_sint8 a_3 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x <> x_1) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (((region (a_2.base))) <= 0) ->
  (((region x_2)) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_1)) ->
  ((is_uint8 x)) ->
  ((valid_rw t a_4 i_1)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i_1)) ->
  (x_2 = (a.base))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 64) (2/12) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_5_preserved_part02
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 64) (2/12)":
*)
goal goal8:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_4.base in
  let x_1 = a_5.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let x_5 = 2 + i in
  let a_6 = (shift_sint8 a_4 0) in
  let a_7 = (shift_sint8 a_5 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (x_4 <> x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= x_5) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_6 i_1)) ->
  ((valid_rw t a_7 i)) ->
  ((separated a_7 i a_6 i_1)) ->
  ((is_uint8 x_4)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  ((i_1 + ((to_uint32 (2 + i_2)))) <= x_5)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 64) (4/12) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_5_preserved_part04
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 64) (4/12)":
*)
goal goal9:
  forall i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = (to_uint32 (1 + i_3)) in
  let x_5 = t_1[(shift_uint8 a x_4)] in
  let x_6 = (to_uint32 (i_2 - 2)) in
  let x_7 = 2 + i in
  let a_10 = (shift_sint8 a_8 0) in
  let a_11 = (shift_sint8 a_9 0) in
  let a_12 = (shift_sint8 a_6 0) in
  let a_13 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_2 <> 0) ->
  (i_2 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (t_1[(shift_uint8 a_5 i_4)] <> t_1[(shift_uint8 a_4 i_4)]) ->
  (x_5 = x_2) ->
  (0 <= i) ->
  (i_2 <= i) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  (0 <= i_4) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_4 < x_6) ->
  (i_3 <= ((to_uint32 (i - i_2)))) ->
  ((i_2 + i_3) <= x_7) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((is_sint32 i_1)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_10 i_2)) ->
  ((valid_rw t a_11 i)) ->
  ((separated a_11 i a_10 i_2)) ->
  ((valid_rw t a_12 x_6)) ->
  ((valid_rw t a_13 x_6)) ->
  ((separated a_13 x_6 a_12 x_6)) ->
  ((is_uint8 x_5)) ->
  (forall i_5 : int. (0 <= i_5) -> (i_5 < i_3) ->
   (exists i_6 : int. (0 <= i_6) -> ((3 + i_6) <= i_2) ->
    (t_1[(shift_uint8 a_3 (2 + i_6 + i_5))]
       <> t_1[(shift_uint8 a_2 (2 + i_6))]))) ->
  ((i_2 + x_4) <= x_7)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 64) (6/12) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_5_preserved_part06
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 64) (6/12)":
*)
goal goal10:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let x_2 = t_1[(shift_uint8 a_1 0)] in
  let x_3 = t_1[(shift_uint8 a i_2)] in
  let x_4 = t_1[(shift_uint8 a_1 1)] in
  let x_5 = (to_uint32 (1 + i_2)) in
  let x_6 = t_1[(shift_uint8 a x_5)] in
  let x_7 = 2 + i in
  let a_10 = (shift_sint8 a_8 0) in
  let a_11 = (shift_sint8 a_9 0) in
  let a_12 = (shift_sint8 a_6 0) in
  let x_8 = (to_uint32 (i_1 - 2)) in
  let a_13 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_4 = x_2) ->
  (x_6 = x_4) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= x_7) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_10 i_1)) ->
  ((valid_rw t a_11 i)) ->
  ((separated a_11 i a_10 i_1)) ->
  ((valid_rw t a_12 x_8)) ->
  ((valid_rw t a_13 x_8)) ->
  ((separated a_13 x_8 a_12 x_8)) ->
  ((is_uint8 x_6)) ->
  ((0 < x_8) ->
   (exists i_3 : int.
    (t_1[(shift_uint8 a_5 i_3)] <> t_1[(shift_uint8 a_4 i_3)]) /\
    (0 <= i_3) /\ (i_3 < x_8)) -> false) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  ((i_1 + x_5) <= x_7)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 64) (8/12) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_5_preserved_part08
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 64) (8/12)":
*)
goal goal11:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_4.base in
  let x_1 = a_5.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = (to_uint32 (1 + i_2)) in
  let x_5 = t_1[(shift_uint8 a x_4)] in
  let x_6 = 2 + i in
  let a_6 = (shift_sint8 a_4 0) in
  let a_7 = (shift_sint8 a_5 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_5 <> x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= x_6) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_6 i_1)) ->
  ((valid_rw t a_7 i)) ->
  ((separated a_7 i a_6 i_1)) ->
  ((is_uint8 x_5)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  ((i_1 + x_4) <= x_6)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 64) (10/12) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_5_preserved_part10
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 64) (10/12)":
*)
goal goal12:
  forall i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_3))))] in
  let x_5 = (to_uint32 (i_2 - 2)) in
  let x_6 = 2 + i in
  let a_10 = (shift_sint8 a_8 0) in
  let a_11 = (shift_sint8 a_9 0) in
  let a_12 = (shift_sint8 a_6 0) in
  let a_13 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_2 <> 0) ->
  (i_2 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (t_1[(shift_uint8 a_5 i_4)] <> t_1[(shift_uint8 a_4 i_4)]) ->
  (x_4 = x_2) ->
  (0 <= i) ->
  (i_2 <= i) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  (0 <= i_4) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_4 < x_5) ->
  (i_3 <= ((to_uint32 (i - i_2)))) ->
  ((i_2 + i_3) <= x_6) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((is_sint32 i_1)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_10 i_2)) ->
  ((valid_rw t a_11 i)) ->
  ((separated a_11 i a_10 i_2)) ->
  ((valid_rw t a_12 x_5)) ->
  ((valid_rw t a_13 x_5)) ->
  ((separated a_13 x_5 a_12 x_5)) ->
  ((is_uint8 x_4)) ->
  (forall i_5 : int. (0 <= i_5) -> (i_5 < i_3) ->
   (exists i_6 : int. (0 <= i_6) -> ((3 + i_6) <= i_2) ->
    (t_1[(shift_uint8 a_3 (2 + i_6 + i_5))]
       <> t_1[(shift_uint8 a_2 (2 + i_6))]))) ->
  ((i_2 + ((to_uint32 (2 + i_3)))) <= x_6)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 64) (12/12) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_5_preserved_part12
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 64) (12/12)":
*)
goal goal13:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let x_2 = t_1[(shift_uint8 a_1 0)] in
  let x_3 = t_1[(shift_uint8 a i_2)] in
  let x_4 = t_1[(shift_uint8 a_1 1)] in
  let x_5 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let x_6 = 2 + i in
  let a_10 = (shift_sint8 a_8 0) in
  let a_11 = (shift_sint8 a_9 0) in
  let a_12 = (shift_sint8 a_6 0) in
  let x_7 = (to_uint32 (i_1 - 2)) in
  let a_13 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_4 <> x_2) ->
  (x_5 = x_4) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= x_6) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_10 i_1)) ->
  ((valid_rw t a_11 i)) ->
  ((separated a_11 i a_10 i_1)) ->
  ((valid_rw t a_12 x_7)) ->
  ((valid_rw t a_13 x_7)) ->
  ((separated a_13 x_7 a_12 x_7)) ->
  ((is_uint8 x_5)) ->
  ((0 < x_7) ->
   (exists i_3 : int.
    (t_1[(shift_uint8 a_5 i_3)] <> t_1[(shift_uint8 a_4 i_3)]) /\
    (0 <= i_3) /\ (i_3 < x_7)) -> false) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  ((i_1 + ((to_uint32 (2 + i_2)))) <= x_6)

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file memmem.c, line 64) (2/4) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_5_established_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Establishment of Invariant (file memmem.c, line 64) (2/4)":
*)
goal goal14:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_2 a_1 a : addr.
  let x = t_1[(shift_uint8 a 1)] in
  let x_1 = t_1[(shift_uint8 a 0)] in
  let a_3 = (shift_sint8 a_1 0) in
  let a_4 = (shift_sint8 a_2 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = x_1) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_1)) ->
  ((is_uint8 x)) ->
  ((valid_rw t a_3 i_1)) ->
  ((valid_rw t a_4 i)) ->
  ((separated a_4 i a_3 i_1)) ->
  (i_1 <= (2 + i))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file memmem.c, line 64) (4/4) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_5_established_part4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Establishment of Invariant (file memmem.c, line 64) (4/4)":
*)
goal goal15:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_2 a_1 a : addr.
  let x = t_1[(shift_uint8 a 1)] in
  let x_1 = t_1[(shift_uint8 a 0)] in
  let a_3 = (shift_sint8 a_1 0) in
  let a_4 = (shift_sint8 a_2 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x <> x_1) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_1)) ->
  ((is_uint8 x)) ->
  ((valid_rw t a_3 i_1)) ->
  ((valid_rw t a_4 i)) ->
  ((separated a_4 i a_3 i_1)) ->
  (i_1 <= (2 + i))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 65) (1/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_6_preserved_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 65) (1/6)":
*)
goal goal16:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_6.base in
  let x_1 = a_7.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_8 = (shift_sint8 a_6 0) in
  let a_9 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (x_4 <> x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_3 < ((to_uint32 (2 + i_2)))) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_8 i_1)) ->
  ((valid_rw t a_9 i)) ->
  ((separated a_9 i a_8 i_1)) ->
  ((is_uint8 x_4)) ->
  (forall i_4 : int. (0 <= i_4) -> (i_4 < i_2) ->
   (exists i_5 : int. (0 <= i_5) -> ((3 + i_5) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_5 + i_4))]
       <> t_1[(shift_uint8 a_2 (2 + i_5))]))) ->
  (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
   (t_1[(shift_uint8 a_5 (2 + i_4 + i_3))]
      <> t_1[(shift_uint8 a_4 (2 + i_4))]))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 65) (2/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_6_preserved_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 65) (2/6)":
*)
goal goal17:
  forall i_5 i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_11 a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_10.base in
  let x_1 = a_11.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = (to_uint32 (1 + i_3)) in
  let x_5 = t_1[(shift_uint8 a x_4)] in
  let x_6 = (to_uint32 (i_2 - 2)) in
  let a_12 = (shift_sint8 a_10 0) in
  let a_13 = (shift_sint8 a_11 0) in
  let a_14 = (shift_sint8 a_6 0) in
  let a_15 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_2 <> 0) ->
  (i_2 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (t_1[(shift_uint8 a_5 i_4)] <> t_1[(shift_uint8 a_4 i_4)]) ->
  (x_5 = x_2) ->
  (0 <= i) ->
  (i_2 <= i) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  (0 <= i_4) ->
  (0 <= i_5) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_4 < x_6) ->
  (i_5 < x_4) ->
  (i_3 <= ((to_uint32 (i - i_2)))) ->
  ((i_2 + i_3) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((is_sint32 i_1)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_12 i_2)) ->
  ((valid_rw t a_13 i)) ->
  ((separated a_13 i a_12 i_2)) ->
  ((valid_rw t a_14 x_6)) ->
  ((valid_rw t a_15 x_6)) ->
  ((separated a_15 x_6 a_14 x_6)) ->
  ((is_uint8 x_5)) ->
  (forall i_6 : int. (0 <= i_6) -> (i_6 < i_3) ->
   (exists i_7 : int. (0 <= i_7) -> ((3 + i_7) <= i_2) ->
    (t_1[(shift_uint8 a_3 (2 + i_7 + i_6))]
       <> t_1[(shift_uint8 a_2 (2 + i_7))]))) ->
  (exists i_6 : int. (0 <= i_6) -> ((3 + i_6) <= i_2) ->
   (t_1[(shift_uint8 a_9 (2 + i_6 + i_5))]
      <> t_1[(shift_uint8 a_8 (2 + i_6))]))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 65) (3/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_6_preserved_part3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 65) (3/6)":
*)
goal goal18:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_11 a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_10.base in
  let x_1 = a_11.base in
  let x_2 = t_1[(shift_uint8 a_1 0)] in
  let x_3 = t_1[(shift_uint8 a i_2)] in
  let x_4 = t_1[(shift_uint8 a_1 1)] in
  let x_5 = (to_uint32 (1 + i_2)) in
  let x_6 = t_1[(shift_uint8 a x_5)] in
  let a_12 = (shift_sint8 a_10 0) in
  let a_13 = (shift_sint8 a_11 0) in
  let a_14 = (shift_sint8 a_6 0) in
  let x_7 = (to_uint32 (i_1 - 2)) in
  let a_15 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_4 = x_2) ->
  (x_6 = x_4) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_3 < x_5) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_12 i_1)) ->
  ((valid_rw t a_13 i)) ->
  ((separated a_13 i a_12 i_1)) ->
  ((valid_rw t a_14 x_7)) ->
  ((valid_rw t a_15 x_7)) ->
  ((separated a_15 x_7 a_14 x_7)) ->
  ((is_uint8 x_6)) ->
  ((0 < x_7) ->
   (exists i_4 : int.
    (t_1[(shift_uint8 a_5 i_4)] <> t_1[(shift_uint8 a_4 i_4)]) /\
    (0 <= i_4) /\ (i_4 < x_7)) -> false) ->
  (forall i_4 : int. (0 <= i_4) -> (i_4 < i_2) ->
   (exists i_5 : int. (0 <= i_5) -> ((3 + i_5) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_5 + i_4))]
       <> t_1[(shift_uint8 a_2 (2 + i_5))]))) ->
  (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
   (t_1[(shift_uint8 a_9 (2 + i_4 + i_3))]
      <> t_1[(shift_uint8 a_8 (2 + i_4))]))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 65) (4/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_6_preserved_part4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 65) (4/6)":
*)
goal goal19:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_6.base in
  let x_1 = a_7.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = (to_uint32 (1 + i_2)) in
  let x_5 = t_1[(shift_uint8 a x_4)] in
  let a_8 = (shift_sint8 a_6 0) in
  let a_9 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_5 <> x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_3 < x_4) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_8 i_1)) ->
  ((valid_rw t a_9 i)) ->
  ((separated a_9 i a_8 i_1)) ->
  ((is_uint8 x_5)) ->
  (forall i_4 : int. (0 <= i_4) -> (i_4 < i_2) ->
   (exists i_5 : int. (0 <= i_5) -> ((3 + i_5) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_5 + i_4))]
       <> t_1[(shift_uint8 a_2 (2 + i_5))]))) ->
  (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
   (t_1[(shift_uint8 a_5 (2 + i_4 + i_3))]
      <> t_1[(shift_uint8 a_4 (2 + i_4))]))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 65) (5/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_6_preserved_part5
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 65) (5/6)":
*)
goal goal20:
  forall i_5 i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_11 a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_10.base in
  let x_1 = a_11.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_3))))] in
  let x_5 = (to_uint32 (i_2 - 2)) in
  let a_12 = (shift_sint8 a_10 0) in
  let a_13 = (shift_sint8 a_11 0) in
  let a_14 = (shift_sint8 a_6 0) in
  let a_15 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_2 <> 0) ->
  (i_2 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (t_1[(shift_uint8 a_5 i_4)] <> t_1[(shift_uint8 a_4 i_4)]) ->
  (x_4 = x_2) ->
  (0 <= i) ->
  (i_2 <= i) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  (0 <= i_4) ->
  (0 <= i_5) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_4 < x_5) ->
  (i_5 < ((to_uint32 (2 + i_3)))) ->
  (i_3 <= ((to_uint32 (i - i_2)))) ->
  ((i_2 + i_3) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((is_sint32 i_1)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_12 i_2)) ->
  ((valid_rw t a_13 i)) ->
  ((separated a_13 i a_12 i_2)) ->
  ((valid_rw t a_14 x_5)) ->
  ((valid_rw t a_15 x_5)) ->
  ((separated a_15 x_5 a_14 x_5)) ->
  ((is_uint8 x_4)) ->
  (forall i_6 : int. (0 <= i_6) -> (i_6 < i_3) ->
   (exists i_7 : int. (0 <= i_7) -> ((3 + i_7) <= i_2) ->
    (t_1[(shift_uint8 a_3 (2 + i_7 + i_6))]
       <> t_1[(shift_uint8 a_2 (2 + i_7))]))) ->
  (exists i_6 : int. (0 <= i_6) -> ((3 + i_6) <= i_2) ->
   (t_1[(shift_uint8 a_9 (2 + i_6 + i_5))]
      <> t_1[(shift_uint8 a_8 (2 + i_6))]))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 65) (6/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_6_preserved_part6
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 65) (6/6)":
*)
goal goal21:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_11 a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_10.base in
  let x_1 = a_11.base in
  let x_2 = t_1[(shift_uint8 a_1 0)] in
  let x_3 = t_1[(shift_uint8 a i_2)] in
  let x_4 = t_1[(shift_uint8 a_1 1)] in
  let x_5 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_12 = (shift_sint8 a_10 0) in
  let a_13 = (shift_sint8 a_11 0) in
  let a_14 = (shift_sint8 a_6 0) in
  let x_6 = (to_uint32 (i_1 - 2)) in
  let a_15 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_4 <> x_2) ->
  (x_5 = x_4) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_3 < ((to_uint32 (2 + i_2)))) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_12 i_1)) ->
  ((valid_rw t a_13 i)) ->
  ((separated a_13 i a_12 i_1)) ->
  ((valid_rw t a_14 x_6)) ->
  ((valid_rw t a_15 x_6)) ->
  ((separated a_15 x_6 a_14 x_6)) ->
  ((is_uint8 x_5)) ->
  ((0 < x_6) ->
   (exists i_4 : int.
    (t_1[(shift_uint8 a_5 i_4)] <> t_1[(shift_uint8 a_4 i_4)]) /\
    (0 <= i_4) /\ (i_4 < x_6)) -> false) ->
  (forall i_4 : int. (0 <= i_4) -> (i_4 < i_2) ->
   (exists i_5 : int. (0 <= i_5) -> ((3 + i_5) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_5 + i_4))]
       <> t_1[(shift_uint8 a_2 (2 + i_5))]))) ->
  (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
   (t_1[(shift_uint8 a_9 (2 + i_4 + i_3))]
      <> t_1[(shift_uint8 a_8 (2 + i_4))]))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file memmem.c, line 81) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_7_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Establishment of Invariant (file memmem.c, line 81)":
*)
goal goal22:
  forall i : int.
  forall t : map int int.
  forall a_2 a_1 a : addr.
  let x = a_1.base in
  let a_3 = (shift_sint8 a_1 0) in
  let a_4 = (shift_sint8 a_2 0) in
  (0 < i) ->
  (0 <= i) ->
  (((region x)) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_3 1)) ->
  ((valid_rw t a_4 i)) ->
  ((separated a_4 i a_3 1)) ->
  (x = (a.base))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file memmem.c, line 82) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_8_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Establishment of Invariant (file memmem.c, line 82)":
*)
goal goal23:
  forall i : int.
  forall t : map int int.
  forall a_2 a_1 a : addr.
  let x = a_2.base in
  let a_3 = (shift_sint8 a_1 0) in
  let a_4 = (shift_sint8 a_2 0) in
  (0 < i) ->
  (0 <= i) ->
  (((region (a_1.base))) <= 0) ->
  (((region x)) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_3 1)) ->
  ((valid_rw t a_4 i)) ->
  ((separated a_4 i a_3 1)) ->
  (x = (a.base))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 83) (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_9_preserved_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 83) (1/2)":
*)
goal goal24:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_7.base in
  let x_1 = a_8.base in
  let x_2 = - i in
  let a_9 = (shift_uint8 a_3 (i_1 - i)) in
  let x_3 = t_1[a_9] in
  let x_4 = t_1[a] in
  let a_10 = (shift_sint8 a_7 0) in
  let a_11 = (shift_sint8 a_8 0) in
  (x = (a.base)) ->
  (x_1 = (a_3.base)) ->
  (((to_uint32 (i - 1))) <> 0) ->
  (x_3 <> x_4) ->
  (0 < i) ->
  (0 < i_1) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_10 1)) ->
  ((valid_rw t a_11 i_1)) ->
  ((separated a_11 i_1 a_10 1)) ->
  ((addr_le a_4 a_9)) ->
  ((addr_le a_9 ((shift_uint8 a_5 i_1)))) ->
  ((is_uint8 x_3)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_uint8 a_2 0)] <> t_1[(shift_uint8 a_1 i_2)])) ->
  ((addr_le a_6 ((shift_uint8 a_3 (1 + i_1 - i)))))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 83) (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_9_preserved_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 83) (2/2)":
*)
goal goal25:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_7.base in
  let x_1 = a_8.base in
  let x_2 = - i in
  let a_9 = (shift_uint8 a_3 (i_1 - i)) in
  let x_3 = t_1[a_9] in
  let x_4 = t_1[a] in
  let a_10 = (shift_sint8 a_7 0) in
  let a_11 = (shift_sint8 a_8 0) in
  (x = (a.base)) ->
  (x_1 = (a_3.base)) ->
  (((to_uint32 (i - 1))) <> 0) ->
  (x_3 <> x_4) ->
  (0 < i) ->
  (0 < i_1) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_10 1)) ->
  ((valid_rw t a_11 i_1)) ->
  ((separated a_11 i_1 a_10 1)) ->
  ((addr_le a_4 a_9)) ->
  ((addr_le a_9 ((shift_uint8 a_5 i_1)))) ->
  ((is_uint8 x_3)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_uint8 a_2 0)] <> t_1[(shift_uint8 a_1 i_2)])) ->
  ((addr_le ((shift_uint8 a_3 (1 + i_1 - i))) ((shift_uint8 a_6 i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file memmem.c, line 83) (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_9_established_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Establishment of Invariant (file memmem.c, line 83) (1/2)":
*)
goal goal26:
  forall i : int.
  forall t : map int int.
  forall a_3 a_2 a_1 a : addr.
  let a_4 = (shift_sint8 a_2 0) in
  let a_5 = (shift_sint8 a_3 0) in
  (0 < i) ->
  (0 <= i) ->
  (((region (a_2.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_4 1)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 1)) ->
  ((addr_le a_1 a))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file memmem.c, line 83) (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_9_established_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Establishment of Invariant (file memmem.c, line 83) (2/2)":
*)
goal goal27:
  forall i : int.
  forall t : map int int.
  forall a_3 a_2 a_1 a : addr.
  let a_4 = (shift_sint8 a_2 0) in
  let a_5 = (shift_sint8 a_3 0) in
  (0 < i) ->
  (0 <= i) ->
  (((region (a_2.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_4 1)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 1)) ->
  ((addr_le a ((shift_uint8 a_1 i))))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 84) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_10_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 84)":
*)
goal goal28:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_7.base in
  let x_1 = a_8.base in
  let x_2 = (to_uint32 (i - 1)) in
  let x_3 = - i in
  let a_9 = (shift_uint8 a_3 (i_1 - i)) in
  let x_4 = t_1[a_9] in
  let x_5 = t_1[a] in
  let a_10 = (shift_sint8 a_7 0) in
  let a_11 = (shift_sint8 a_8 0) in
  (x = (a.base)) ->
  (x_1 = (a_3.base)) ->
  (x_2 <> 0) ->
  (x_4 <> x_5) ->
  (0 < i) ->
  (0 < i_1) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_5)) ->
  ((valid_rw t a_10 1)) ->
  ((valid_rw t a_11 i_1)) ->
  ((separated a_11 i_1 a_10 1)) ->
  ((addr_le a_4 a_9)) ->
  ((addr_le a_9 ((shift_uint8 a_5 i_1)))) ->
  ((is_uint8 x_4)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_uint8 a_2 0)] <> t_1[(shift_uint8 a_1 i_2)])) ->
  (((shift_uint8 a_6 (i_1 - x_2))) = ((shift_uint8 a_3 (1 + i_1 - i))))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file memmem.c, line 84) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_10_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Establishment of Invariant (file memmem.c, line 84)":
*)
goal goal29:
  forall i : int.
  forall t : map int int.
  forall a_3 a_2 a_1 a : addr.
  let a_4 = (shift_sint8 a_2 0) in
  let a_5 = (shift_sint8 a_3 0) in
  (0 < i) ->
  (0 <= i) ->
  (((region (a_2.base))) <= 0) ->
  (((region (a_3.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_4 1)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 1)) ->
  (((shift_uint8 a_1 0)) = a)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 85) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_11_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 85)":
*)
goal goal30:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let x_2 = (to_uint32 (i - 1)) in
  let a_10 = (shift_uint8 a_3 (i_1 - i)) in
  let x_3 = t_1[a_10] in
  let x_4 = t_1[a] in
  let a_11 = (shift_sint8 a_8 0) in
  let a_12 = (shift_sint8 a_9 0) in
  (x = (a.base)) ->
  (x_1 = (a_3.base)) ->
  (x_2 <> 0) ->
  (x_3 <> x_4) ->
  (0 < i) ->
  (0 < i_1) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  ((i_2 + x_2) < i_1) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_11 1)) ->
  ((valid_rw t a_12 i_1)) ->
  ((separated a_12 i_1 a_11 1)) ->
  ((addr_le a_4 a_10)) ->
  ((addr_le a_10 ((shift_uint8 a_5 i_1)))) ->
  ((is_uint8 x_3)) ->
  (forall i_3 : int. (0 <= i_3) -> ((i_3 + i) < i_1) ->
   (t_1[(shift_uint8 a_2 0)] <> t_1[(shift_uint8 a_1 i_3)])) ->
  (t_1[(shift_uint8 a_7 0)] <> t_1[(shift_uint8 a_6 i_2)])

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 86) (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_12_preserved_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 86) (1/2)":
*)
goal goal31:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_6.base in
  let x_1 = a_7.base in
  let x_2 = (to_uint32 (i - 1)) in
  let a_8 = (shift_uint8 a_3 (i_1 - i)) in
  let x_3 = t_1[a_8] in
  let x_4 = t_1[a] in
  let a_9 = (shift_sint8 a_6 0) in
  let a_10 = (shift_sint8 a_7 0) in
  (x = (a.base)) ->
  (x_1 = (a_3.base)) ->
  (x_2 <> 0) ->
  (x_3 <> x_4) ->
  (0 < i) ->
  (0 < i_1) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_9 1)) ->
  ((valid_rw t a_10 i_1)) ->
  ((separated a_10 i_1 a_9 1)) ->
  ((addr_le a_4 a_8)) ->
  ((addr_le a_8 ((shift_uint8 a_5 i_1)))) ->
  ((is_uint8 x_3)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_uint8 a_2 0)] <> t_1[(shift_uint8 a_1 i_2)])) ->
  (0 < x_2)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file memmem.c, line 86) (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_inv_12_preserved_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Preservation of Invariant (file memmem.c, line 86) (2/2)":
*)
goal goal32:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_6.base in
  let x_1 = a_7.base in
  let x_2 = (to_uint32 (i - 1)) in
  let a_8 = (shift_uint8 a_3 (i_1 - i)) in
  let x_3 = t_1[a_8] in
  let x_4 = t_1[a] in
  let a_9 = (shift_sint8 a_6 0) in
  let a_10 = (shift_sint8 a_7 0) in
  (x = (a.base)) ->
  (x_1 = (a_3.base)) ->
  (x_2 <> 0) ->
  (x_3 <> x_4) ->
  (0 < i) ->
  (0 < i_1) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_9 1)) ->
  ((valid_rw t a_10 i_1)) ->
  ((separated a_10 i_1 a_9 1)) ->
  ((addr_le a_4 a_8)) ->
  ((addr_le a_8 ((shift_uint8 a_5 i_1)))) ->
  ((is_uint8 x_3)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_uint8 a_2 0)] <> t_1[(shift_uint8 a_1 i_2)])) ->
  (x_2 <= i_1)

end

(* ---------------------------------------------------------- *)
(* --- Decreasing of Loop variant at loop (file memmem.c, line 69) (1/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_term_decrease_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Decreasing of Loop variant at loop (file memmem.c, line 69) (1/6)":
*)
goal goal33:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_4.base in
  let x_1 = a_5.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_6 = (shift_sint8 a_4 0) in
  let a_7 = (shift_sint8 a_5 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (x_4 <> x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_6 i_1)) ->
  ((valid_rw t a_7 i)) ->
  ((separated a_7 i a_6 i_1)) ->
  ((is_uint8 x_4)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  (i_2 < ((to_uint32 (2 + i_2))))

end

(* ---------------------------------------------------------- *)
(* --- Decreasing of Loop variant at loop (file memmem.c, line 69) (2/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_term_decrease_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Decreasing of Loop variant at loop (file memmem.c, line 69) (2/6)":
*)
goal goal34:
  forall i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = (to_uint32 (1 + i_3)) in
  let x_5 = t_1[(shift_uint8 a x_4)] in
  let x_6 = (to_uint32 (i_2 - 2)) in
  let a_10 = (shift_sint8 a_8 0) in
  let a_11 = (shift_sint8 a_9 0) in
  let a_12 = (shift_sint8 a_6 0) in
  let a_13 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_2 <> 0) ->
  (i_2 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (t_1[(shift_uint8 a_5 i_4)] <> t_1[(shift_uint8 a_4 i_4)]) ->
  (x_5 = x_2) ->
  (0 <= i) ->
  (i_2 <= i) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  (0 <= i_4) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_4 < x_6) ->
  (i_3 <= ((to_uint32 (i - i_2)))) ->
  ((i_2 + i_3) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((is_sint32 i_1)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_10 i_2)) ->
  ((valid_rw t a_11 i)) ->
  ((separated a_11 i a_10 i_2)) ->
  ((valid_rw t a_12 x_6)) ->
  ((valid_rw t a_13 x_6)) ->
  ((separated a_13 x_6 a_12 x_6)) ->
  ((is_uint8 x_5)) ->
  (forall i_5 : int. (0 <= i_5) -> (i_5 < i_3) ->
   (exists i_6 : int. (0 <= i_6) -> ((3 + i_6) <= i_2) ->
    (t_1[(shift_uint8 a_3 (2 + i_6 + i_5))]
       <> t_1[(shift_uint8 a_2 (2 + i_6))]))) ->
  (i_3 < x_4)

end

(* ---------------------------------------------------------- *)
(* --- Decreasing of Loop variant at loop (file memmem.c, line 69) (3/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_term_decrease_part3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Decreasing of Loop variant at loop (file memmem.c, line 69) (3/6)":
*)
goal goal35:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let x_2 = t_1[(shift_uint8 a_1 0)] in
  let x_3 = t_1[(shift_uint8 a i_2)] in
  let x_4 = t_1[(shift_uint8 a_1 1)] in
  let x_5 = (to_uint32 (1 + i_2)) in
  let x_6 = t_1[(shift_uint8 a x_5)] in
  let a_10 = (shift_sint8 a_8 0) in
  let a_11 = (shift_sint8 a_9 0) in
  let a_12 = (shift_sint8 a_6 0) in
  let x_7 = (to_uint32 (i_1 - 2)) in
  let a_13 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_4 = x_2) ->
  (x_6 = x_4) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_10 i_1)) ->
  ((valid_rw t a_11 i)) ->
  ((separated a_11 i a_10 i_1)) ->
  ((valid_rw t a_12 x_7)) ->
  ((valid_rw t a_13 x_7)) ->
  ((separated a_13 x_7 a_12 x_7)) ->
  ((is_uint8 x_6)) ->
  ((0 < x_7) ->
   (exists i_3 : int.
    (t_1[(shift_uint8 a_5 i_3)] <> t_1[(shift_uint8 a_4 i_3)]) /\
    (0 <= i_3) /\ (i_3 < x_7)) -> false) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  (i_2 < x_5)

end

(* ---------------------------------------------------------- *)
(* --- Decreasing of Loop variant at loop (file memmem.c, line 69) (4/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_term_decrease_part4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Decreasing of Loop variant at loop (file memmem.c, line 69) (4/6)":
*)
goal goal36:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_4.base in
  let x_1 = a_5.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = (to_uint32 (1 + i_2)) in
  let x_5 = t_1[(shift_uint8 a x_4)] in
  let a_6 = (shift_sint8 a_4 0) in
  let a_7 = (shift_sint8 a_5 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_5 <> x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_6 i_1)) ->
  ((valid_rw t a_7 i)) ->
  ((separated a_7 i a_6 i_1)) ->
  ((is_uint8 x_5)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  (i_2 < x_4)

end

(* ---------------------------------------------------------- *)
(* --- Decreasing of Loop variant at loop (file memmem.c, line 69) (5/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_term_decrease_part5
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Decreasing of Loop variant at loop (file memmem.c, line 69) (5/6)":
*)
goal goal37:
  forall i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_3))))] in
  let x_5 = (to_uint32 (i_2 - 2)) in
  let a_10 = (shift_sint8 a_8 0) in
  let a_11 = (shift_sint8 a_9 0) in
  let a_12 = (shift_sint8 a_6 0) in
  let a_13 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_2 <> 0) ->
  (i_2 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (t_1[(shift_uint8 a_5 i_4)] <> t_1[(shift_uint8 a_4 i_4)]) ->
  (x_4 = x_2) ->
  (0 <= i) ->
  (i_2 <= i) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  (0 <= i_4) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_4 < x_5) ->
  (i_3 <= ((to_uint32 (i - i_2)))) ->
  ((i_2 + i_3) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((is_sint32 i_1)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_10 i_2)) ->
  ((valid_rw t a_11 i)) ->
  ((separated a_11 i a_10 i_2)) ->
  ((valid_rw t a_12 x_5)) ->
  ((valid_rw t a_13 x_5)) ->
  ((separated a_13 x_5 a_12 x_5)) ->
  ((is_uint8 x_4)) ->
  (forall i_5 : int. (0 <= i_5) -> (i_5 < i_3) ->
   (exists i_6 : int. (0 <= i_6) -> ((3 + i_6) <= i_2) ->
    (t_1[(shift_uint8 a_3 (2 + i_6 + i_5))]
       <> t_1[(shift_uint8 a_2 (2 + i_6))]))) ->
  (i_3 < ((to_uint32 (2 + i_3))))

end

(* ---------------------------------------------------------- *)
(* --- Decreasing of Loop variant at loop (file memmem.c, line 69) (6/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_term_decrease_part6
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Decreasing of Loop variant at loop (file memmem.c, line 69) (6/6)":
*)
goal goal38:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let x_2 = t_1[(shift_uint8 a_1 0)] in
  let x_3 = t_1[(shift_uint8 a i_2)] in
  let x_4 = t_1[(shift_uint8 a_1 1)] in
  let x_5 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_10 = (shift_sint8 a_8 0) in
  let a_11 = (shift_sint8 a_9 0) in
  let a_12 = (shift_sint8 a_6 0) in
  let x_6 = (to_uint32 (i_1 - 2)) in
  let a_13 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_4 <> x_2) ->
  (x_5 = x_4) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_10 i_1)) ->
  ((valid_rw t a_11 i)) ->
  ((separated a_11 i a_10 i_1)) ->
  ((valid_rw t a_12 x_6)) ->
  ((valid_rw t a_13 x_6)) ->
  ((separated a_13 x_6 a_12 x_6)) ->
  ((is_uint8 x_5)) ->
  ((0 < x_6) ->
   (exists i_3 : int.
    (t_1[(shift_uint8 a_5 i_3)] <> t_1[(shift_uint8 a_4 i_3)]) /\
    (0 <= i_3) /\ (i_3 < x_6)) -> false) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  (i_2 < ((to_uint32 (2 + i_2))))

end

(* ---------------------------------------------------------- *)
(* --- Positivity of Loop variant at loop (file memmem.c, line 69) (1/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_term_positive_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Positivity of Loop variant at loop (file memmem.c, line 69) (1/6)":
*)
goal goal39:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_4.base in
  let x_1 = a_5.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let x_5 = i_1 + i_2 in
  let a_6 = (shift_sint8 a_4 0) in
  let a_7 = (shift_sint8 a_5 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (x_4 <> x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  (x_5 <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_6 i_1)) ->
  ((valid_rw t a_7 i)) ->
  ((separated a_7 i a_6 i_1)) ->
  ((is_uint8 x_4)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  (x_5 <= i)

end

(* ---------------------------------------------------------- *)
(* --- Positivity of Loop variant at loop (file memmem.c, line 69) (2/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_term_positive_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Positivity of Loop variant at loop (file memmem.c, line 69) (2/6)":
*)
goal goal40:
  forall i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_3))))] in
  let x_5 = (to_uint32 (i_2 - 2)) in
  let x_6 = i_2 + i_3 in
  let a_10 = (shift_sint8 a_8 0) in
  let a_11 = (shift_sint8 a_9 0) in
  let a_12 = (shift_sint8 a_6 0) in
  let a_13 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_2 <> 0) ->
  (i_2 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (t_1[(shift_uint8 a_5 i_4)] <> t_1[(shift_uint8 a_4 i_4)]) ->
  (x_4 = x_2) ->
  (0 <= i) ->
  (i_2 <= i) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  (0 <= i_4) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_4 < x_5) ->
  (i_3 <= ((to_uint32 (i - i_2)))) ->
  (x_6 <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((is_sint32 i_1)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_10 i_2)) ->
  ((valid_rw t a_11 i)) ->
  ((separated a_11 i a_10 i_2)) ->
  ((valid_rw t a_12 x_5)) ->
  ((valid_rw t a_13 x_5)) ->
  ((separated a_13 x_5 a_12 x_5)) ->
  ((is_uint8 x_4)) ->
  (forall i_5 : int. (0 <= i_5) -> (i_5 < i_3) ->
   (exists i_6 : int. (0 <= i_6) -> ((3 + i_6) <= i_2) ->
    (t_1[(shift_uint8 a_3 (2 + i_6 + i_5))]
       <> t_1[(shift_uint8 a_2 (2 + i_6))]))) ->
  (x_6 <= i)

end

(* ---------------------------------------------------------- *)
(* --- Positivity of Loop variant at loop (file memmem.c, line 69) (3/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_term_positive_part3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Positivity of Loop variant at loop (file memmem.c, line 69) (3/6)":
*)
goal goal41:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let x_2 = t_1[(shift_uint8 a_1 0)] in
  let x_3 = t_1[(shift_uint8 a i_2)] in
  let x_4 = t_1[(shift_uint8 a_1 1)] in
  let x_5 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let x_6 = i_1 + i_2 in
  let a_10 = (shift_sint8 a_8 0) in
  let a_11 = (shift_sint8 a_9 0) in
  let a_12 = (shift_sint8 a_6 0) in
  let x_7 = (to_uint32 (i_1 - 2)) in
  let a_13 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_4 = x_2) ->
  (x_5 = x_4) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  (x_6 <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_10 i_1)) ->
  ((valid_rw t a_11 i)) ->
  ((separated a_11 i a_10 i_1)) ->
  ((valid_rw t a_12 x_7)) ->
  ((valid_rw t a_13 x_7)) ->
  ((separated a_13 x_7 a_12 x_7)) ->
  ((is_uint8 x_5)) ->
  ((0 < x_7) ->
   (exists i_3 : int.
    (t_1[(shift_uint8 a_5 i_3)] <> t_1[(shift_uint8 a_4 i_3)]) /\
    (0 <= i_3) /\ (i_3 < x_7)) -> false) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  (x_6 <= i)

end

(* ---------------------------------------------------------- *)
(* --- Positivity of Loop variant at loop (file memmem.c, line 69) (4/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_term_positive_part4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Positivity of Loop variant at loop (file memmem.c, line 69) (4/6)":
*)
goal goal42:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_4.base in
  let x_1 = a_5.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let x_5 = i_1 + i_2 in
  let a_6 = (shift_sint8 a_4 0) in
  let a_7 = (shift_sint8 a_5 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_4 <> x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  (x_5 <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_6 i_1)) ->
  ((valid_rw t a_7 i)) ->
  ((separated a_7 i a_6 i_1)) ->
  ((is_uint8 x_4)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  (x_5 <= i)

end

(* ---------------------------------------------------------- *)
(* --- Positivity of Loop variant at loop (file memmem.c, line 69) (5/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_term_positive_part5
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Positivity of Loop variant at loop (file memmem.c, line 69) (5/6)":
*)
goal goal43:
  forall i_4 i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_3))))] in
  let x_5 = (to_uint32 (i_2 - 2)) in
  let x_6 = i_2 + i_3 in
  let a_10 = (shift_sint8 a_8 0) in
  let a_11 = (shift_sint8 a_9 0) in
  let a_12 = (shift_sint8 a_6 0) in
  let a_13 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_2 <> 0) ->
  (i_2 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (t_1[(shift_uint8 a_5 i_4)] <> t_1[(shift_uint8 a_4 i_4)]) ->
  (x_4 = x_2) ->
  (0 <= i) ->
  (i_2 <= i) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  (0 <= i_4) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_4 < x_5) ->
  (i_3 <= ((to_uint32 (i - i_2)))) ->
  (x_6 <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_2)) ->
  ((is_uint32 i_3)) ->
  ((is_sint32 i_1)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_10 i_2)) ->
  ((valid_rw t a_11 i)) ->
  ((separated a_11 i a_10 i_2)) ->
  ((valid_rw t a_12 x_5)) ->
  ((valid_rw t a_13 x_5)) ->
  ((separated a_13 x_5 a_12 x_5)) ->
  ((is_uint8 x_4)) ->
  (forall i_5 : int. (0 <= i_5) -> (i_5 < i_3) ->
   (exists i_6 : int. (0 <= i_6) -> ((3 + i_6) <= i_2) ->
    (t_1[(shift_uint8 a_3 (2 + i_6 + i_5))]
       <> t_1[(shift_uint8 a_2 (2 + i_6))]))) ->
  (x_6 <= i)

end

(* ---------------------------------------------------------- *)
(* --- Positivity of Loop variant at loop (file memmem.c, line 69) (6/6) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_term_positive_part6
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Positivity of Loop variant at loop (file memmem.c, line 69) (6/6)":
*)
goal goal44:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let x_2 = t_1[(shift_uint8 a_1 0)] in
  let x_3 = t_1[(shift_uint8 a i_2)] in
  let x_4 = t_1[(shift_uint8 a_1 1)] in
  let x_5 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let x_6 = i_1 + i_2 in
  let a_10 = (shift_sint8 a_8 0) in
  let a_11 = (shift_sint8 a_9 0) in
  let a_12 = (shift_sint8 a_6 0) in
  let x_7 = (to_uint32 (i_1 - 2)) in
  let a_13 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_4 <> x_2) ->
  (x_5 = x_4) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  (x_6 <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_10 i_1)) ->
  ((valid_rw t a_11 i)) ->
  ((separated a_11 i a_10 i_1)) ->
  ((valid_rw t a_12 x_7)) ->
  ((valid_rw t a_13 x_7)) ->
  ((separated a_13 x_7 a_12 x_7)) ->
  ((is_uint8 x_5)) ->
  ((0 < x_7) ->
   (exists i_3 : int.
    (t_1[(shift_uint8 a_5 i_3)] <> t_1[(shift_uint8 a_4 i_3)]) /\
    (0 <= i_3) /\ (i_3 < x_7)) -> false) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  (x_6 <= i)

end

(* ---------------------------------------------------------- *)
(* --- Decreasing of Loop variant at loop (file memmem.c, line 99) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_loop_term_2_decrease
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Decreasing of Loop variant at loop (file memmem.c, line 99)":
*)
goal goal45:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_6.base in
  let x_1 = a_7.base in
  let x_2 = (to_uint32 (i - 1)) in
  let a_8 = (shift_uint8 a_3 (i_1 - i)) in
  let x_3 = t_1[a_8] in
  let x_4 = t_1[a] in
  let a_9 = (shift_sint8 a_6 0) in
  let a_10 = (shift_sint8 a_7 0) in
  (x = (a.base)) ->
  (x_1 = (a_3.base)) ->
  (x_2 <> 0) ->
  (x_3 <> x_4) ->
  (0 < i) ->
  (0 < i_1) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_9 1)) ->
  ((valid_rw t a_10 i_1)) ->
  ((separated a_10 i_1 a_9 1)) ->
  ((addr_le a_4 a_8)) ->
  ((addr_le a_8 ((shift_uint8 a_5 i_1)))) ->
  ((is_uint8 x_3)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_uint8 a_2 0)] <> t_1[(shift_uint8 a_1 i_2)])) ->
  (x_2 < i)

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition (file memcmp.c, line 9) in 'memcmp'' in 'memmem' at call 'memcmp' (file memmem.c, line 73)
 (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_call_memcmp_pre_2_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Instance of 'Pre-condition (file memcmp.c, line 9) in 'memcmp'' in 'memmem' at call 'memcmp' (file memmem.c, line 73)
 (1/2)":
*)
goal goal46:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_5.base in
  let x_1 = a_6.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_7 = (shift_sint8 a_5 0) in
  let a_8 = (shift_sint8 a_6 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (x_4 = x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_7 i_1)) ->
  ((valid_rw t a_8 i)) ->
  ((separated a_8 i a_7 i_1)) ->
  ((is_uint8 x_4)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  ((valid_rw t ((shift_sint8 a_4 0)) ((to_uint32 (i_1 - 2)))))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition (file memcmp.c, line 9) in 'memcmp'' in 'memmem' at call 'memcmp' (file memmem.c, line 73)
 (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_call_memcmp_pre_2_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Instance of 'Pre-condition (file memcmp.c, line 9) in 'memcmp'' in 'memmem' at call 'memcmp' (file memmem.c, line 73)
 (2/2)":
*)
goal goal47:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_5.base in
  let x_1 = a_6.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_7 = (shift_sint8 a_5 0) in
  let a_8 = (shift_sint8 a_6 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_4 = x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_7 i_1)) ->
  ((valid_rw t a_8 i)) ->
  ((separated a_8 i a_7 i_1)) ->
  ((is_uint8 x_4)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  ((valid_rw t ((shift_sint8 a_4 0)) ((to_uint32 (i_1 - 2)))))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition (file memcmp.c, line 10) in 'memcmp'' in 'memmem' at call 'memcmp' (file memmem.c, line 73)
 (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_call_memcmp_pre_3_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Instance of 'Pre-condition (file memcmp.c, line 10) in 'memcmp'' in 'memmem' at call 'memcmp' (file memmem.c, line 73)
 (1/2)":
*)
goal goal48:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_5.base in
  let x_1 = a_6.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_7 = (shift_sint8 a_5 0) in
  let a_8 = (shift_sint8 a_6 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (x_4 = x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_7 i_1)) ->
  ((valid_rw t a_8 i)) ->
  ((separated a_8 i a_7 i_1)) ->
  ((is_uint8 x_4)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  ((valid_rw t ((shift_sint8 a_4 0)) ((to_uint32 (i_1 - 2)))))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition (file memcmp.c, line 10) in 'memcmp'' in 'memmem' at call 'memcmp' (file memmem.c, line 73)
 (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_call_memcmp_pre_3_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Instance of 'Pre-condition (file memcmp.c, line 10) in 'memcmp'' in 'memmem' at call 'memcmp' (file memmem.c, line 73)
 (2/2)":
*)
goal goal49:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_5.base in
  let x_1 = a_6.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_7 = (shift_sint8 a_5 0) in
  let a_8 = (shift_sint8 a_6 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_4 = x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_7 i_1)) ->
  ((valid_rw t a_8 i)) ->
  ((separated a_8 i a_7 i_1)) ->
  ((is_uint8 x_4)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  ((valid_rw t ((shift_sint8 a_4 0)) ((to_uint32 (i_1 - 2)))))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition (file memcmp.c, line 11) in 'memcmp'' in 'memmem' at call 'memcmp' (file memmem.c, line 73)
 (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_call_memcmp_pre_4_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Instance of 'Pre-condition (file memcmp.c, line 11) in 'memcmp'' in 'memmem' at call 'memcmp' (file memmem.c, line 73)
 (1/2)":
*)
goal goal50:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_6.base in
  let x_1 = a_7.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_8 = (shift_sint8 a_6 0) in
  let a_9 = (shift_sint8 a_7 0) in
  let x_5 = (to_uint32 (i_1 - 2)) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (x_4 = x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_8 i_1)) ->
  ((valid_rw t a_9 i)) ->
  ((separated a_9 i a_8 i_1)) ->
  ((is_uint8 x_4)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  ((separated ((shift_sint8 a_5 0)) x_5 ((shift_sint8 a_4 0)) x_5))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition (file memcmp.c, line 11) in 'memcmp'' in 'memmem' at call 'memcmp' (file memmem.c, line 73)
 (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_call_memcmp_pre_4_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Instance of 'Pre-condition (file memcmp.c, line 11) in 'memcmp'' in 'memmem' at call 'memcmp' (file memmem.c, line 73)
 (2/2)":
*)
goal goal51:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_6.base in
  let x_1 = a_7.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let x_4 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_8 = (shift_sint8 a_6 0) in
  let a_9 = (shift_sint8 a_7 0) in
  let x_5 = (to_uint32 (i_1 - 2)) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (x_4 = x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_8 i_1)) ->
  ((valid_rw t a_9 i)) ->
  ((separated a_9 i a_8 i_1)) ->
  ((is_uint8 x_4)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_3 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_2 (2 + i_4))]))) ->
  ((separated ((shift_sint8 a_5 0)) x_5 ((shift_sint8 a_4 0)) x_5))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'not_occur' (file memmem.c, line 29) in 'memmem' (4/9) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_not_occur_post_part4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Post-condition for 'not_occur' (file memmem.c, line 29) in 'memmem' (4/9)":
*)
goal goal52:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_12 a_11 a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_10.base in
  let x_1 = a_12.base in
  let x_2 = t_1[(shift_uint8 a_1 0)] in
  let x_3 = t_1[(shift_uint8 a i_2)] in
  let x_4 = t_1[(shift_uint8 a_1 1)] in
  let x_5 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_13 = (shift_sint8 a_10 0) in
  let a_14 = (shift_sint8 a_12 0) in
  let a_15 = (shift_sint8 a_8 0) in
  let x_6 = (to_uint32 (i_1 - 2)) in
  let a_16 = (shift_sint8 a_9 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (x_4 = x_2) ->
  (x_5 = x_4) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_13 i_1)) ->
  ((valid_rw t a_14 i)) ->
  ((separated a_14 i a_13 i_1)) ->
  ((valid_rw t a_15 x_6)) ->
  ((valid_rw t a_16 x_6)) ->
  ((separated a_16 x_6 a_15 x_6)) ->
  ((is_uint8 x_5)) ->
  ((0 < x_6) ->
   (exists i_3 : int.
    (t_1[(shift_uint8 a_7 i_3)] <> t_1[(shift_uint8 a_6 i_3)]) /\
    (0 <= i_3) /\ (i_3 < x_6)) -> false) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_5 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_4 (2 + i_4))]))) ->
  (forall i_3 : int. (0 <= i_3) -> ((i_3 + i_1) <= i) ->
   (exists i_4 : int.
    (t_1[(shift_uint8 a_3 (i_4 + i_3))] <> t_1[(shift_uint8 a_2 i_4)]) /\
    (0 <= i_4) /\ (i_4 < i_1))) ->
  (null = a_11)

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'not_occur' (file memmem.c, line 29) in 'memmem' (6/9) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_not_occur_post_part6
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Post-condition for 'not_occur' (file memmem.c, line 29) in 'memmem' (6/9)":
*)
goal goal53:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_12 a_11 a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_10.base in
  let x_1 = a_12.base in
  let x_2 = t_1[(shift_uint8 a_1 0)] in
  let x_3 = t_1[(shift_uint8 a i_2)] in
  let x_4 = t_1[(shift_uint8 a_1 1)] in
  let x_5 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_13 = (shift_sint8 a_10 0) in
  let a_14 = (shift_sint8 a_12 0) in
  let a_15 = (shift_sint8 a_8 0) in
  let x_6 = (to_uint32 (i_1 - 2)) in
  let a_16 = (shift_sint8 a_9 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (x_4 <> x_2) ->
  (x_5 = x_4) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_13 i_1)) ->
  ((valid_rw t a_14 i)) ->
  ((separated a_14 i a_13 i_1)) ->
  ((valid_rw t a_15 x_6)) ->
  ((valid_rw t a_16 x_6)) ->
  ((separated a_16 x_6 a_15 x_6)) ->
  ((is_uint8 x_5)) ->
  ((0 < x_6) ->
   (exists i_3 : int.
    (t_1[(shift_uint8 a_7 i_3)] <> t_1[(shift_uint8 a_6 i_3)]) /\
    (0 <= i_3) /\ (i_3 < x_6)) -> false) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (exists i_4 : int. (0 <= i_4) -> ((3 + i_4) <= i_1) ->
    (t_1[(shift_uint8 a_5 (2 + i_4 + i_3))]
       <> t_1[(shift_uint8 a_4 (2 + i_4))]))) ->
  (forall i_3 : int. (0 <= i_3) -> ((i_3 + i_1) <= i) ->
   (exists i_4 : int.
    (t_1[(shift_uint8 a_3 (i_4 + i_3))] <> t_1[(shift_uint8 a_2 i_4)]) /\
    (0 <= i_4) /\ (i_4 < i_1))) ->
  (null = a_11)

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'not_occur' (file memmem.c, line 29) in 'memmem' (8/9) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_not_occur_post_part8
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Post-condition for 'not_occur' (file memmem.c, line 29) in 'memmem' (8/9)":
*)
goal goal54:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_10.base in
  let a_11 = (shift_uint8 a_5 (i_1 - i)) in
  let x_2 = t_1[a_11] in
  let x_3 = t_1[a] in
  let a_12 = (shift_sint8 a_8 0) in
  let a_13 = (shift_sint8 a_10 0) in
  (i_1 <> 0) ->
  (x = (a.base)) ->
  (x_1 = (a_5.base)) ->
  (x_2 = x_3) ->
  (0 < i) ->
  (0 < i_1) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_3)) ->
  ((valid_rw t a_12 1)) ->
  ((valid_rw t a_13 i_1)) ->
  ((separated a_13 i_1 a_12 1)) ->
  ((addr_le a_6 a_11)) ->
  ((addr_le a_11 ((shift_uint8 a_7 i_1)))) ->
  ((is_uint8 x_2)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_uint8 a_4 0)] <> t_1[(shift_uint8 a_3 i_2)])) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i_1) ->
   (exists i_3 : int.
    (t_1[(shift_uint8 a_2 (i_3 + i_2))] <> t_1[(shift_uint8 a_1 i_3)]) /\
    (i_3 <= 0) /\ (0 <= i_3))) ->
  (null = a_9)

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'occr' (file memmem.c, line 34) in 'memmem' (4/9) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_occr_post_part4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Post-condition for 'occr' (file memmem.c, line 34) in 'memmem' (4/9)":
*)
goal goal55:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_11 a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_10.base in
  let x_1 = a_11.base in
  let x_2 = t_1[(shift_uint8 a_1 0)] in
  let x_3 = t_1[(shift_uint8 a i_2)] in
  let x_4 = t_1[(shift_uint8 a_1 1)] in
  let x_5 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_12 = (shift_sint8 a_10 0) in
  let a_13 = (shift_sint8 a_11 0) in
  let a_14 = (shift_sint8 a_8 0) in
  let x_6 = (to_uint32 (i_1 - 2)) in
  let a_15 = (shift_sint8 a_9 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (x_4 = x_2) ->
  (x_5 = x_4) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  ((i_1 + i_3) <= i) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_12 i_1)) ->
  ((valid_rw t a_13 i)) ->
  ((separated a_13 i a_12 i_1)) ->
  ((valid_rw t a_14 x_6)) ->
  ((valid_rw t a_15 x_6)) ->
  ((separated a_15 x_6 a_14 x_6)) ->
  ((is_uint8 x_5)) ->
  ((0 < x_6) ->
   (exists i_4 : int.
    (t_1[(shift_uint8 a_7 i_4)] <> t_1[(shift_uint8 a_6 i_4)]) /\
    (0 <= i_4) /\ (i_4 < x_6)) -> false) ->
  (forall i_4 : int. (0 <= i_4) -> (i_4 < i_1) ->
   (t_1[(shift_uint8 a_3 (i_4 + i_3))] = t_1[(shift_uint8 a_2 i_4)])) ->
  (forall i_4 : int. (0 <= i_4) -> (i_4 < i_2) ->
   (exists i_5 : int. (0 <= i_5) -> ((3 + i_5) <= i_1) ->
    (t_1[(shift_uint8 a_5 (2 + i_5 + i_4))]
       <> t_1[(shift_uint8 a_4 (2 + i_5))]))) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'occr' (file memmem.c, line 34) in 'memmem' (5/9) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_occr_post_part5
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Post-condition for 'occr' (file memmem.c, line 34) in 'memmem' (5/9)":
*)
goal goal56:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_6.base in
  let x_1 = a_7.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let a_8 = (shift_sint8 a_6 0) in
  let a_9 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  ((i_1 + i_3) <= i) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (((to_uint32 (i - i_1))) < i_2) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_8 i_1)) ->
  ((valid_rw t a_9 i)) ->
  ((separated a_9 i a_8 i_1)) ->
  ((is_uint8 t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))])) ->
  (forall i_4 : int. (0 <= i_4) -> (i_4 < i_1) ->
   (t_1[(shift_uint8 a_3 (i_4 + i_3))] = t_1[(shift_uint8 a_2 i_4)])) ->
  (forall i_4 : int. (0 <= i_4) -> (i_4 < i_2) ->
   (exists i_5 : int. (0 <= i_5) -> ((3 + i_5) <= i_1) ->
    (t_1[(shift_uint8 a_5 (2 + i_5 + i_4))]
       <> t_1[(shift_uint8 a_4 (2 + i_5))]))) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'occr' (file memmem.c, line 34) in 'memmem' (6/9) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_occr_post_part6
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Post-condition for 'occr' (file memmem.c, line 34) in 'memmem' (6/9)":
*)
goal goal57:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_11 a_10 a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_10.base in
  let x_1 = a_11.base in
  let x_2 = t_1[(shift_uint8 a_1 0)] in
  let x_3 = t_1[(shift_uint8 a i_2)] in
  let x_4 = t_1[(shift_uint8 a_1 1)] in
  let x_5 = t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))] in
  let a_12 = (shift_sint8 a_10 0) in
  let a_13 = (shift_sint8 a_11 0) in
  let a_14 = (shift_sint8 a_8 0) in
  let x_6 = (to_uint32 (i_1 - 2)) in
  let a_15 = (shift_sint8 a_9 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 = x_3) ->
  (x_4 <> x_2) ->
  (x_5 = x_4) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  ((i_1 + i_3) <= i) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (i_2 <= ((to_uint32 (i - i_1)))) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((is_uint8 x_4)) ->
  ((valid_rw t a_12 i_1)) ->
  ((valid_rw t a_13 i)) ->
  ((separated a_13 i a_12 i_1)) ->
  ((valid_rw t a_14 x_6)) ->
  ((valid_rw t a_15 x_6)) ->
  ((separated a_15 x_6 a_14 x_6)) ->
  ((is_uint8 x_5)) ->
  ((0 < x_6) ->
   (exists i_4 : int.
    (t_1[(shift_uint8 a_7 i_4)] <> t_1[(shift_uint8 a_6 i_4)]) /\
    (0 <= i_4) /\ (i_4 < x_6)) -> false) ->
  (forall i_4 : int. (0 <= i_4) -> (i_4 < i_1) ->
   (t_1[(shift_uint8 a_3 (i_4 + i_3))] = t_1[(shift_uint8 a_2 i_4)])) ->
  (forall i_4 : int. (0 <= i_4) -> (i_4 < i_2) ->
   (exists i_5 : int. (0 <= i_5) -> ((3 + i_5) <= i_1) ->
    (t_1[(shift_uint8 a_5 (2 + i_5 + i_4))]
       <> t_1[(shift_uint8 a_4 (2 + i_5))]))) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'occr' (file memmem.c, line 34) in 'memmem' (7/9) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_occr_post_part7
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Post-condition for 'occr' (file memmem.c, line 34) in 'memmem' (7/9)":
*)
goal goal58:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_6.base in
  let x_1 = a_7.base in
  let x_2 = t_1[(shift_uint8 a_1 1)] in
  let x_3 = t_1[(shift_uint8 a_1 0)] in
  let a_8 = (shift_sint8 a_6 0) in
  let a_9 = (shift_sint8 a_7 0) in
  (i <> 0) ->
  (i_1 <> 0) ->
  (i_1 <> 1) ->
  (x = (a_1.base)) ->
  (x_1 = (a.base)) ->
  (x_2 <> x_3) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  ((i_1 + i_3) <= i) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  (((to_uint32 (i - i_1))) < i_2) ->
  ((i_1 + i_2) <= (2 + i)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_uint8 x_3)) ->
  ((is_uint8 x_2)) ->
  ((valid_rw t a_8 i_1)) ->
  ((valid_rw t a_9 i)) ->
  ((separated a_9 i a_8 i_1)) ->
  ((is_uint8 t_1[(shift_uint8 a ((to_uint32 (1 + i_2))))])) ->
  (forall i_4 : int. (0 <= i_4) -> (i_4 < i_1) ->
   (t_1[(shift_uint8 a_3 (i_4 + i_3))] = t_1[(shift_uint8 a_2 i_4)])) ->
  (forall i_4 : int. (0 <= i_4) -> (i_4 < i_2) ->
   (exists i_5 : int. (0 <= i_5) -> ((3 + i_5) <= i_1) ->
    (t_1[(shift_uint8 a_5 (2 + i_5 + i_4))]
       <> t_1[(shift_uint8 a_4 (2 + i_5))]))) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'occr' (file memmem.c, line 34) in 'memmem' (8/9) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_occr_post_part8
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Post-condition for 'occr' (file memmem.c, line 34) in 'memmem' (8/9)":
*)
goal goal59:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let a_10 = (shift_uint8 a_5 (i_1 - i)) in
  let x_2 = t_1[a_10] in
  let x_3 = t_1[a] in
  let a_11 = (shift_sint8 a_8 0) in
  let a_12 = (shift_sint8 a_9 0) in
  (i_1 <> 0) ->
  (x = (a.base)) ->
  (x_1 = (a_5.base)) ->
  (x_2 = x_3) ->
  (0 < i) ->
  (0 < i_1) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (0 <= i_2) ->
  (i_2 < i_1) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_3)) ->
  ((valid_rw t a_11 1)) ->
  ((valid_rw t a_12 i_1)) ->
  ((separated a_12 i_1 a_11 1)) ->
  ((addr_le a_6 a_10)) ->
  ((addr_le a_10 ((shift_uint8 a_7 i_1)))) ->
  ((is_uint8 x_2)) ->
  (forall i_3 : int. (0 <= i_3) -> ((i_3 + i) < i_1) ->
   (t_1[(shift_uint8 a_4 0)] <> t_1[(shift_uint8 a_3 i_3)])) ->
  (forall i_3 : int. (i_3 <= 0) -> (0 <= i_3) ->
   (t_1[(shift_uint8 a_2 (i_3 + i_2))] = t_1[(shift_uint8 a_1 i_3)])) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'occr' (file memmem.c, line 34) in 'memmem' (9/9) --- *)
(* ---------------------------------------------------------- *)
theory VCmemmem_occr_post_part9
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Post-condition for 'occr' (file memmem.c, line 34) in 'memmem' (9/9)":
*)
goal goal60:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_9 a_8 a_7 a_6 a_5 a_4 a_3 a_2 a_1 a : addr.
  let x = a_8.base in
  let x_1 = a_9.base in
  let a_10 = (shift_uint8 a_5 (i_1 - i)) in
  let x_2 = t_1[a_10] in
  let x_3 = t_1[a] in
  let a_11 = (shift_sint8 a_8 0) in
  let a_12 = (shift_sint8 a_9 0) in
  (i_1 <> 0) ->
  (x = (a.base)) ->
  (x_1 = (a_5.base)) ->
  (((to_uint32 (i - 1))) = 0) ->
  (x_2 <> x_3) ->
  (0 < i) ->
  (0 < i_1) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (0 <= i_2) ->
  (i_2 < i_1) ->
  (((region x)) <= 0) ->
  (((region x_1)) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint8 x_3)) ->
  ((valid_rw t a_11 1)) ->
  ((valid_rw t a_12 i_1)) ->
  ((separated a_12 i_1 a_11 1)) ->
  ((addr_le a_6 a_10)) ->
  ((addr_le a_10 ((shift_uint8 a_7 i_1)))) ->
  ((is_uint8 x_2)) ->
  (forall i_3 : int. (0 <= i_3) -> ((i_3 + i) < i_1) ->
   (t_1[(shift_uint8 a_4 0)] <> t_1[(shift_uint8 a_3 i_3)])) ->
  (forall i_3 : int. (i_3 <= 0) -> (0 <= i_3) ->
   (t_1[(shift_uint8 a_2 (i_3 + i_2))] = t_1[(shift_uint8 a_1 i_3)])) ->
  false

end

