import Why3.Base
import Why3.why3.Ref.Ref
import pearl.vstte12_bfs_vcg.lean.vstte12_bfs.Graph
open Classical
open Lean4Why3
namespace vstte12_bfs_BFS_fill_nextqtvc
axiom set : Type
axiom inhabited_axiom_set : Inhabited set
attribute [instance] inhabited_axiom_set
axiom to_fset : set -> Finset Graph.vertex
axiom choose1 : set -> Graph.vertex
axiom choose'spec (s : set) (fact0 : ¬to_fset s = ∅) : choose1 s ∈ to_fset s
noncomputable def inv (s : Graph.vertex) (t : Graph.vertex) (visited : Finset Graph.vertex) (current : Finset Graph.vertex) (next : Finset Graph.vertex) (d : ℤ) := current ⊆ visited ∧ (∀(x : Graph.vertex), x ∈ current → Graph.shortest_path s x d) ∧ next ⊆ visited ∧ (∀(x : Graph.vertex), x ∈ next → Graph.shortest_path s x (d + (1 : ℤ))) ∧ (∀(x : Graph.vertex) (m : ℤ), Graph.path s x m → m ≤ d → x ∈ visited) ∧ (∀(x : Graph.vertex), x ∈ visited → (∃(m : ℤ), Graph.path s x m ∧ m ≤ d + (1 : ℤ))) ∧ (∀(x : Graph.vertex), Graph.shortest_path s x (d + (1 : ℤ)) → x ∈ next ∨ ¬x ∈ visited) ∧ (t ∈ visited → t ∈ current ∨ t ∈ next)
noncomputable def closure (visited : Finset Graph.vertex) (current : Finset Graph.vertex) (next : Finset Graph.vertex) (x : Graph.vertex) := x ∈ visited → ¬x ∈ current → ¬x ∈ next → (∀(y : Graph.vertex), y ∈ Graph.succ x → y ∈ visited)
theorem fill_next'vc (s : Graph.vertex) (t : Graph.vertex) (visited : set) (current : set) (next : set) (d : ℤ) (v : Graph.vertex) (acc : set) (fact0 : inv s t (to_fset visited) (to_fset current) (to_fset next) d) (fact1 : Graph.shortest_path s v d) (fact2 : ∀(x : Graph.vertex), ¬x = v → closure (to_fset visited) (to_fset current) (to_fset next) x) (fact3 : to_fset acc = Graph.succ v) : inv s t (to_fset visited) (to_fset current) (to_fset next) d ∧ to_fset acc ⊆ Graph.succ v ∧ Graph.succ v \ to_fset acc ⊆ to_fset visited ∧ (∀(x : Graph.vertex), ¬x = v → closure (to_fset visited) (to_fset current) (to_fset next) x) ∧ (∀(acc1 : set) (next1 : set) (visited1 : set), inv s t (to_fset visited1) (to_fset current) (to_fset next1) d ∧ to_fset acc1 ⊆ Graph.succ v ∧ Graph.succ v \ to_fset acc1 ⊆ to_fset visited1 ∧ (∀(x : Graph.vertex), ¬x = v → closure (to_fset visited1) (to_fset current) (to_fset next1) x) → (if ¬to_fset acc1 = ∅ then ¬to_fset acc1 = ∅ ∧ (∀(acc2 : set), let w : Graph.vertex := choose1 acc1; w ∈ to_fset acc1 ∧ to_fset acc2 = Finset.erase (to_fset acc1) w → (if ¬w ∈ to_fset visited1 then ∀(visited2 : set), to_fset visited2 = insert w (to_fset visited1) ∧ (if w ∈ to_fset visited1 then Finset.card (to_fset visited2) = Finset.card (to_fset visited1) else Int.ofNat (Finset.card (to_fset visited2)) = Int.ofNat (Finset.card (to_fset visited1)) + (1 : ℤ)) → (∀(next2 : set), to_fset next2 = insert w (to_fset next1) ∧ (if w ∈ to_fset next1 then Finset.card (to_fset next2) = Finset.card (to_fset next1) else Int.ofNat (Finset.card (to_fset next2)) = Int.ofNat (Finset.card (to_fset next1)) + (1 : ℤ)) → ((0 : ℤ) ≤ Int.ofNat (Finset.card (to_fset acc1)) ∧ Finset.card (to_fset acc2) < Finset.card (to_fset acc1)) ∧ inv s t (to_fset visited2) (to_fset current) (to_fset next2) d ∧ to_fset acc2 ⊆ Graph.succ v ∧ Graph.succ v \ to_fset acc2 ⊆ to_fset visited2 ∧ (∀(x : Graph.vertex), ¬x = v → closure (to_fset visited2) (to_fset current) (to_fset next2) x)) else ((0 : ℤ) ≤ Int.ofNat (Finset.card (to_fset acc1)) ∧ Finset.card (to_fset acc2) < Finset.card (to_fset acc1)) ∧ inv s t (to_fset visited1) (to_fset current) (to_fset next1) d ∧ to_fset acc2 ⊆ Graph.succ v ∧ Graph.succ v \ to_fset acc2 ⊆ to_fset visited1 ∧ (∀(x : Graph.vertex), ¬x = v → closure (to_fset visited1) (to_fset current) (to_fset next1) x))) else inv s t (to_fset visited1) (to_fset current) (to_fset next1) d ∧ Graph.succ v ⊆ to_fset visited1 ∧ (∀(x : Graph.vertex), closure (to_fset visited1) (to_fset current) (to_fset next1) x)))
  := sorry
end vstte12_bfs_BFS_fill_nextqtvc
