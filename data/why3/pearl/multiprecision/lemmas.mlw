module Lemmas

  use array.Array
  use map.Map
  use map.MapEq
  use map.Const
  use int.Int

  (** {3 Complements to map standard library} *)

  predicate map_eq_sub_shift (x y:map int 'a) (xi yi sz:int) =
    forall i. 0 <= i < sz -> x[xi+i] = y[yi+i]

  let ghost map_eq_shift (x y:map int 'a) (xi yi sz k:int) : unit
    requires { map_eq_sub_shift x y xi yi sz }
    requires { 0 <= k < sz }
    ensures { x[xi+k] = y[yi+k] }
  = ()

  let ghost map_eq_shift_zero (x y: map int 'a) (n m: int) : unit
    requires { map_eq_sub_shift x y n n (m-n) }
    ensures { MapEq.map_eq_sub x y n m }
  = ()

  use mach.int.Int32
  use ref.Ref
  use import mach.int.UInt64GMP as Limb
  use int.Int
  use int.Power
  use mach.c.C
  use types.Types
  use types.Int32Eq
  use types.UInt64Eq

  meta compute_max_steps 0x100000

  (** {3 Long integers as arrays of libs} *)

  let ghost limb_max_bound () : unit
    ensures { 1 <= max_uint64 }
  = ()

  function l2i (x:limb) : int = Limb.to_int x

  function p2i (i:int32) : int = int32'int i

  let ghost prod_compat_strict_r (a b c:int) : unit
    requires { 0 <= a < b }
    requires { 0 < c }
    ensures { c * a < c * b }
  = ()

  let ghost prod_compat_r (a b c:int) : unit
    requires { 0 <= a <= b }
    requires { 0 <= c }
    ensures { c * a <= c * b }
  = ()

  let ghost prod_compat_strict_lr (a b c d:int) : unit
    requires { 0 <= a < b }
    requires { 0 <= c < d }
    ensures  { a * c < b * d }
  = ()

  let ghost prod_compat_lr (a b c d:int) : unit
    requires { 0 <= a <= b }
    requires { 0 <= c <= d }
    ensures  { a * c <= b * d }
  = ()

  let ghost simp_compat_strict_l (a b c:int) : unit
    requires { 0 <= a * b < a * c }
    requires { 0 < a }
    ensures  { b < c }
  = ()

  (** {3 Integer value of a natural number} *)

  (** `value_sub x n m` denotes the integer represented by
     the digits `x[n..m-1]` with lsb at index n *)
  let rec ghost function value_sub (x:map int limb) (n:int) (m:int) : int
     variant {m - n}
   =
     if n < m then
       l2i x[n] + radix * value_sub x (n+1) m
       else 0

  let ghost value_sub_frame (x y:map int limb) (n m:int) : unit
    requires { MapEq.map_eq_sub x y n m }
    ensures  { value_sub x n m = value_sub y n m }
  = ()

  let ghost value_sub_frame_shift (x y:map int limb) (xi yi sz:int) : unit
    requires { map_eq_sub_shift x y xi yi sz }
    ensures { value_sub x xi (xi+sz) = value_sub y yi (yi+sz) }
  = ()

  let ghost value_sub_tail (x:map int limb) (n m:int) : unit
    requires { n <= m }
    ensures  {
      value_sub x n (m+1) =
        value_sub x n m + (Map.get x m) * power radix (m-n) }
  = ()

  let ghost value_sub_concat (x:map int limb) (n m l:int) : unit
    requires { n <= m <= l}
    ensures  {
      value_sub x n l =
        value_sub x n m + value_sub x m l * power radix (m-n) }
  = ()

  let ghost value_sub_head (x:map int limb) (n m:int) : unit
    requires { n < m }
    ensures { value_sub x n m = x[n] + radix * value_sub x (n+1) m }
  = ()

  let ghost value_sub_update (x:map int limb) (i n m:int) (v:limb) : unit
    requires { n <= i < m }
    ensures {
      value_sub (Map.set x i v) n m =
      value_sub x n m + power radix (i - n) * (v -(Map.get x i))
    }
  = ()

  let ghost value_zero (x:map int limb) (n m:int) : unit
    requires { MapEq.map_eq_sub x (Const.const Limb.zero_unsigned) n m }
    ensures  { value_sub x n m = 0 }
  = ()

  let ghost value_sub_update_no_change (x: map int limb) (i n m: int) (v:limb) : unit
     requires { n <= m }
     requires { i < n \/ m <= i }
     ensures { value_sub x n m = value_sub (Map.set x i v) n m }
  = ()

  let ghost value_sub_shift_no_change (x:map int limb) (ofs i sz:int) (v:limb) : unit
     requires { i < 0 \/ sz <= i }
     requires { 0 <= sz }
     ensures { value_sub x ofs (ofs + sz) =
               value_sub (Map.set x (ofs+i) v) ofs (ofs+sz) }
  = ()

  (** {3 Comparisons} *)

  let ghost value_sub_lower_bound (x:map int limb) (x1 x2:int) : unit
    ensures  { 0 <= value_sub x x1 x2 }
  = ()

  let ghost value_sub_upper_bound (x:map int limb) (x1 x2:int) : unit
    requires { x1 <= x2 }
    ensures  { value_sub x x1 x2 < power radix (x2 - x1) }
  = ()

  let ghost value_sub_lower_bound_tight (x:map int limb) (x1 x2:int) : unit
    requires { x1 < x2 }
    ensures  { power radix (x2-x1-1) *  l2i (Map.get x (x2-1)) <= value_sub x x1 x2 }
  = ()

  let ghost value_sub_upper_bound_tight (x:map int limb) (x1 x2:int) : unit
    requires { x1 < x2 }
    ensures  { value_sub x x1 x2 < power radix (x2-x1-1) *  (l2i (Map.get x (x2-1)) + 1) }
  = ()

  function value (x:t) (sz:int) : int =
     value_sub (pelts x) x.offset (x.offset + sz)

  let ghost value_tail (x:t) (sz:int32) : unit
    requires { 0 <= sz }
    ensures  { value x (sz+1) = value x sz + (pelts x)[x.offset + sz] * power radix sz }
  = ()

  let ghost value_concat (x:t) (n m:int32) : unit
    requires { 0 <= n <= m }
    ensures  { value x m
             = value x n + power radix n
                            * value_sub (pelts x) (x.offset + n) (x.offset + m) }
  = ()

  let ghost value_sub_eq (x1 x2: map int limb) (n1 n2 m1 m2: int) : unit
    requires { x1 = x2 }
    requires { n1 = n2 }
    requires { m1 = m2 }
    ensures  { value_sub x1 n1 m1 = value_sub x2 n2 m2 }
  = ()

end
