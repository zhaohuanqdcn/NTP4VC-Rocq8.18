import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.c.C
import Why3.mach.int.Unsigned
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.ptralias.Alias
open Classical
open Lean4Why3
namespace sub_Sub_sub_ryqtvc
theorem sub_ry'vc (sy : BitVec 32) (sx : BitVec 32) (x : C.ptr (BitVec 64)) (y : C.ptr (BitVec 64)) (fact0 : (0 : ℤ) ≤ BitVec.toInt sy) (fact1 : BitVec.toInt sy ≤ BitVec.toInt sx) (fact2 : C.valid x (BitVec.toInt sx)) (fact3 : C.valid y (BitVec.toInt sx)) (fact4 : C.writable y = true) : C.valid y (BitVec.toInt sx) ∧ C.valid x (BitVec.toInt sx) ∧ (0 : ℤ) ≤ BitVec.toInt sx ∧ BitVec.toInt sx ≤ BitVec.toInt sx ∧ C.writable y = true ∧ (∀(y1 : C.ptr (BitVec 64)) (x1 : C.ptr (BitVec 64)), C.offset y1 = C.offset y ∧ C.writable y1 = C.writable y ∧ C.zone1 y1 = C.zone1 y → C.offset x1 = C.offset x ∧ C.writable x1 = C.writable x ∧ C.zone1 x1 = C.zone1 x → (∀(nr : C.ptr (BitVec 64)) (ny : C.ptr (BitVec 64)) (nx : C.ptr (BitVec 64)) (m : Alias.mem), C.writable nr = true ∧ (Lemmas.value ny (BitVec.toInt sx) = Lemmas.value y (BitVec.toInt sx) ∧ Lemmas.value nx (BitVec.toInt sx) = Lemmas.value x (BitVec.toInt sx)) ∧ (C.valid ny (BitVec.toInt sx) ∧ C.valid nx (BitVec.toInt sx)) ∧ Alias.identical nr ny ∧ ((0 : ℤ) ≤ C.offset ny ∧ C.offset ny + BitVec.toInt sx ≤ C.offset nx ∨ (0 : ℤ) ≤ C.offset nx ∧ C.offset nx + BitVec.toInt sx ≤ C.offset ny) ∧ (Alias.zx m = C.zone1 y1 ∧ Alias.zy m = C.zone1 x1) ∧ (BitVec.toInt (Alias.mx m) = C.max y ∧ BitVec.toInt (Alias.my m) = C.max x) ∧ (Alias.lx m = sx ∧ Alias.ly m = sx) ∧ Alias.ok m = true ∧ Lemmas.map_eq_sub_shift (C.pelts ny) (C.pelts y1) (C.offset ny) (C.offset y1) (BitVec.toInt sx) ∧ Lemmas.map_eq_sub_shift (C.pelts nx) (C.pelts x1) (C.offset nx) (C.offset x1) (BitVec.toInt sx) ∧ (C.pelts y1 = C.pelts y ∧ C.pelts x1 = C.pelts x) ∧ (C.plength y1 = C.plength y ∧ C.plength x1 = C.plength x) ∧ (C.min y1 = C.min y ∧ C.min x1 = C.min x) ∧ C.data nr = C.data ny ∧ C.data ny = C.data nx → (((0 : ℤ) ≤ BitVec.toInt sy ∧ BitVec.toInt sy ≤ BitVec.toInt sx) ∧ (C.valid nr (BitVec.toInt sx) ∧ C.valid nx (BitVec.toInt sx) ∧ C.valid ny (BitVec.toInt sy)) ∧ (C.offset nr = C.offset nx ∨ C.offset nr + BitVec.toInt sx ≤ C.offset nx ∨ C.offset nx + BitVec.toInt sx ≤ C.offset nr) ∧ (C.offset nr = C.offset ny ∨ C.offset nr + BitVec.toInt sx ≤ C.offset ny ∨ C.offset ny + BitVec.toInt sy ≤ C.offset nr) ∧ (C.data nr = C.data nx ∧ C.data nx = C.data ny) ∧ C.writable nr = true) ∧ (∀(nx1 : C.ptr (BitVec 64)) (ny1 : C.ptr (BitVec 64)) (nr1 : C.ptr (BitVec 64)), C.data nx1 = C.data nr1 ∧ List.length (C.data nr1) = List.length (C.data nx) ∧ C.offset nx1 = C.offset nx ∧ C.min nx1 = C.min nx ∧ C.max nx1 = C.max nx ∧ C.writable nx1 = C.writable nx ∧ C.zone1 nx1 = C.zone1 nx → C.data ny1 = C.data nr1 ∧ List.length (C.data nr1) = List.length (C.data ny) ∧ C.offset ny1 = C.offset ny ∧ C.min ny1 = C.min ny ∧ C.max ny1 = C.max ny ∧ C.writable ny1 = C.writable ny ∧ C.zone1 ny1 = C.zone1 ny → List.length (C.data nr1) = List.length (C.data nr) ∧ C.offset nr1 = C.offset nr ∧ C.min nr1 = C.min nr ∧ C.max nr1 = C.max nr ∧ C.writable nr1 = C.writable nr ∧ C.zone1 nr1 = C.zone1 nr → (∀(res : BitVec 64), Lemmas.value nr1 (BitVec.toInt sx) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt res = Lemmas.value nx (BitVec.toInt sx) - Lemmas.value ny (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt res ∧ BitVec.toUInt res ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset nr1 ∨ C.offset nr1 + BitVec.toInt sx ≤ j → C.pelts nr1 j = C.pelts nr j) ∧ (C.offset nr1 = C.offset nx1 ∨ MapEq.map_eq_sub (C.pelts nx1) (C.pelts nx) (C.offset nx1) (C.offset nx1 + BitVec.toInt sx)) ∧ (C.offset nr1 = C.offset ny1 ∨ MapEq.map_eq_sub (C.pelts ny1) (C.pelts ny) (C.offset ny1) (C.offset ny1 + BitVec.toInt sy)) → ((C.writable y1 = true ∧ C.writable nr1 = true) ∧ Alias.ok m = true ∧ ((0 : ℤ) ≤ BitVec.toInt sx ∧ BitVec.toInt sx ≤ BitVec.toInt sx) ∧ Alias.identical nr1 ny1 ∧ ((0 : ℤ) ≤ C.offset ny1 ∧ C.offset ny1 + BitVec.toInt sx ≤ C.offset nx1 ∨ (0 : ℤ) ≤ C.offset nx1 ∧ C.offset nx1 + BitVec.toInt sx ≤ C.offset ny1) ∧ (Alias.zx m = C.zone1 y1 ∧ Alias.zy m = C.zone1 x1) ∧ Alias.lx m = sx ∧ Alias.ly m = sx) ∧ (∀(m1 : Alias.mem) (nx2 : C.ptr (BitVec 64)) (ny2 : C.ptr (BitVec 64)) (y2 : C.ptr (BitVec 64)) (x2 : C.ptr (BitVec 64)), Alias.zr m1 = Alias.zr m ∧ Alias.zx m1 = Alias.zx m ∧ Alias.zy m1 = Alias.zy m ∧ Alias.mr m1 = Alias.mr m ∧ Alias.mx m1 = Alias.mx m ∧ Alias.my m1 = Alias.my m ∧ Alias.lr m1 = Alias.lr m ∧ Alias.lx m1 = Alias.lx m ∧ Alias.ly m1 = Alias.ly m → C.offset nx2 = C.offset nx1 ∧ C.writable nx2 = C.writable nx1 ∧ C.zone1 nx2 = C.zone1 nx1 → C.offset ny2 = C.offset ny1 ∧ C.writable ny2 = C.writable ny1 ∧ C.zone1 ny2 = C.zone1 ny1 → C.offset y2 = C.offset y1 ∧ C.min y2 = C.min y1 ∧ C.writable y2 = C.writable y1 ∧ C.zone1 y2 = C.zone1 y1 → C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → (C.max y2 = BitVec.toInt (Alias.mx m1) ∧ C.max x2 = BitVec.toInt (Alias.my m1)) ∧ Lemmas.map_eq_sub_shift (C.pelts ny1) (C.pelts y2) (C.offset ny2) (C.offset y2) (BitVec.toInt sx) ∧ Lemmas.map_eq_sub_shift (C.pelts nx1) (C.pelts x2) (C.offset nx2) (C.offset x2) (BitVec.toInt sx) ∧ (∀(j : ℤ), j < C.offset y2 ∨ C.offset y2 + BitVec.toInt sx ≤ j → C.pelts y2 j = C.pelts y1 j) ∧ (∀(j : ℤ), j < C.offset x2 ∨ C.offset x2 + BitVec.toInt sx ≤ j → C.pelts x2 j = C.pelts x1 j) ∧ (C.plength y2 = C.plength y1 ∧ C.plength x2 = C.plength x1) ∧ C.min y2 = C.min y1 ∧ C.min x2 = C.min x1 → Lemmas.value y2 (BitVec.toInt sx) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt res = Lemmas.value x (BitVec.toInt sx) - Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt res ∧ BitVec.toUInt res ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset y2 ∨ C.offset y2 + BitVec.toInt sx ≤ j → C.pelts y2 j = C.pelts y j) ∧ (∀(j : ℤ), C.pelts x2 j = C.pelts x j) ∧ Lemmas.value x2 (BitVec.toInt sx) = Lemmas.value x (BitVec.toInt sx) ∧ (C.min x2 = C.min x ∧ C.max x2 = C.max x ∧ C.plength x2 = C.plength x) ∧ C.min y2 = C.min y ∧ C.max y2 = C.max y ∧ C.plength y2 = C.plength y)))))
  := sorry
end sub_Sub_sub_ryqtvc
