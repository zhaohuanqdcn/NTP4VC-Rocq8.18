import Why3.Base
import Why3.why3.Ref.Ref
import Why3.queue.Queue
open Classical
open Lean4Why3
namespace split_string_SplitStringOCaml_split_stringqtvc
axiom char : Type
axiom inhabited_axiom_char : Inhabited char
attribute [instance] inhabited_axiom_char
axiom string' : Type
axiom inhabited_axiom_string' : Inhabited string'
attribute [instance] inhabited_axiom_string'
axiom contents' : string' -> List char
axiom concat : List string' -> char -> List char
axiom concat'def (ss : List string') (sep : char) (fact0 : (1 : ℤ) ≤ Int.ofNat (List.length ss)) : if Int.ofNat (List.length ss) = (1 : ℤ) then concat ss sep = contents' (ss[(0 : ℕ)]!) else concat ss sep = concat (List.drop (0 : ℕ) (List.take (Int.toNat (Int.ofNat (List.length ss) - (1 : ℤ)) - (0 : ℕ)) ss)) sep ++ List.cons sep (contents' (ss[Int.toNat (Int.ofNat (List.length ss) - (1 : ℤ))]!))
noncomputable def notin (sep : char) (s : string') := ¬sep ∈ contents' s
theorem split_string'vc (limit : BitVec 63) (o1 : Queue.t string') (s : string') (sep : char) (fact0 : BitVec.toInt limit = -(1 : ℤ) ∨ (1 : ℤ) ≤ BitVec.toInt limit) (fact1 : Queue.seq o1 = ([] : List string')) (fact2 : BitVec.toInt limit = (1 : ℤ) → limit = (1 : BitVec 63)) : if limit = (1 : BitVec 63) then ∀(ss : Queue.t string'), Queue.seq ss = Queue.seq o1 ++ [s] → (1 : ℤ) ≤ Int.ofNat (List.length (Queue.seq ss)) ∧ (BitVec.toInt limit = -(1 : ℤ) ∨ Int.ofNat (List.length (Queue.seq ss)) ≤ BitVec.toInt limit) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length (Queue.seq ss)) - (1 : ℤ) → notin sep ((Queue.seq ss)[Int.toNat j]!)) ∧ (Int.ofNat (List.length (Queue.seq ss)) = BitVec.toInt limit ∨ notin sep ((Queue.seq ss)[Int.toNat (Int.ofNat (List.length (Queue.seq ss)) - (1 : ℤ))]!)) ∧ concat (Queue.seq ss) sep = contents' s else (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length (contents' s))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length (Queue.seq o1)) → notin sep ((Queue.seq o1)[Int.toNat j]!)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → ¬(contents' s)[Int.toNat j]! = sep) ∧ (BitVec.toInt limit = -(1 : ℤ) ∨ Int.ofNat (List.length (Queue.seq o1)) < BitVec.toInt limit - (1 : ℤ)) ∧ contents' s = List.drop (0 : ℕ) (contents' s) ∧ concat (Queue.seq o1 ++ [s]) sep = contents' s) ∧ (∀(suffix : string') (b : BitVec 63) (i : BitVec 63) (ss : Queue.t string'), ((0 : ℤ) ≤ BitVec.toInt b ∧ BitVec.toInt b ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ Int.ofNat (List.length (contents' s))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length (Queue.seq ss)) → notin sep ((Queue.seq ss)[Int.toNat j]!)) ∧ (∀(j : ℤ), BitVec.toInt b ≤ j ∧ j < BitVec.toInt i → ¬(contents' s)[Int.toNat j]! = sep) ∧ (BitVec.toInt limit = -(1 : ℤ) ∨ Int.ofNat (List.length (Queue.seq ss)) < BitVec.toInt limit - (1 : ℤ)) ∧ contents' suffix = List.drop (Int.toNat (BitVec.toInt b)) (contents' s) ∧ concat (Queue.seq ss ++ [suffix]) sep = contents' s → (∀(o2 : BitVec 63), BitVec.toInt o2 = Int.ofNat (List.length (contents' s)) → (if BitVec.toInt i < BitVec.toInt o2 then ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i < Int.ofNat (List.length (contents' s))) ∧ (if (contents' s)[Int.toNat (BitVec.toInt i)]! = sep then ((0 : ℤ) ≤ BitVec.toInt b ∧ BitVec.toInt b ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ Int.ofNat (List.length (contents' s))) ∧ (∀(o3 : string'), contents' o3 = List.drop (Int.toNat (BitVec.toInt b)) (List.take (Int.toNat (BitVec.toInt i) - Int.toNat (BitVec.toInt b)) (contents' s)) → (∀(ss1 : Queue.t string'), Queue.seq ss1 = Queue.seq ss ++ [o3] → int'63_in_bounds (BitVec.toInt limit - (1 : ℤ)) ∧ (∀(o4 : BitVec 63), BitVec.toInt o4 = BitVec.toInt limit - (1 : ℤ) → (∀(o5 : ℕ), o5 = List.length (Queue.seq ss1) → (∀(o6 : BitVec 63), BitVec.toInt o6 = Int.ofNat o5 → (BitVec.toInt o6 = BitVec.toInt o4 → o6 = o4) → (if o6 = o4 then ∀(o7 : BitVec 63), BitVec.toInt o7 = Int.ofNat (List.length (contents' s)) → int'63_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o8 : BitVec 63), BitVec.toInt o8 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o8 ∧ BitVec.toInt o8 ≤ BitVec.toInt o7 ∧ BitVec.toInt o7 ≤ Int.ofNat (List.length (contents' s))) ∧ (∀(o9 : string'), contents' o9 = List.drop (Int.toNat (BitVec.toInt o8)) (List.take (Int.toNat (BitVec.toInt o7) - Int.toNat (BitVec.toInt o8)) (contents' s)) → (∀(ss2 : Queue.t string'), Queue.seq ss2 = Queue.seq ss1 ++ [o9] → (1 : ℤ) ≤ Int.ofNat (List.length (Queue.seq ss2)) ∧ (BitVec.toInt limit = -(1 : ℤ) ∨ Int.ofNat (List.length (Queue.seq ss2)) ≤ BitVec.toInt limit) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length (Queue.seq ss2)) - (1 : ℤ) → notin sep ((Queue.seq ss2)[Int.toNat j]!)) ∧ (Int.ofNat (List.length (Queue.seq ss2)) = BitVec.toInt limit ∨ notin sep ((Queue.seq ss2)[Int.toNat (Int.ofNat (List.length (Queue.seq ss2)) - (1 : ℤ))]!)) ∧ concat (Queue.seq ss2) sep = contents' s))) else int'63_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o7 : BitVec 63), BitVec.toInt o7 = BitVec.toInt i + (1 : ℤ) → (∀(o8 : BitVec 63), BitVec.toInt o8 = Int.ofNat (List.length (contents' s)) → ((0 : ℤ) ≤ BitVec.toInt o7 ∧ BitVec.toInt o7 ≤ BitVec.toInt o8 ∧ BitVec.toInt o8 ≤ Int.ofNat (List.length (contents' s))) ∧ (∀(o9 : string'), contents' o9 = List.drop (Int.toNat (BitVec.toInt o7)) (List.take (Int.toNat (BitVec.toInt o8) - Int.toNat (BitVec.toInt o7)) (contents' s)) → int'63_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o10 : BitVec 63), BitVec.toInt o10 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ Int.ofNat (List.length (contents' s)) - BitVec.toInt i ∧ Int.ofNat (List.length (contents' s)) - BitVec.toInt o10 < Int.ofNat (List.length (contents' s)) - BitVec.toInt i) ∧ ((0 : ℤ) ≤ BitVec.toInt o7 ∧ BitVec.toInt o7 ≤ BitVec.toInt o10 ∧ BitVec.toInt o10 ≤ Int.ofNat (List.length (contents' s))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length (Queue.seq ss1)) → notin sep ((Queue.seq ss1)[Int.toNat j]!)) ∧ (∀(j : ℤ), BitVec.toInt o7 ≤ j ∧ j < BitVec.toInt o10 → ¬(contents' s)[Int.toNat j]! = sep) ∧ (BitVec.toInt limit = -(1 : ℤ) ∨ Int.ofNat (List.length (Queue.seq ss1)) < BitVec.toInt limit - (1 : ℤ)) ∧ contents' o9 = List.drop (Int.toNat (BitVec.toInt o7)) (contents' s) ∧ concat (Queue.seq ss1 ++ [o9]) sep = contents' s)))))))))) else int'63_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o3 : BitVec 63), BitVec.toInt o3 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ Int.ofNat (List.length (contents' s)) - BitVec.toInt i ∧ Int.ofNat (List.length (contents' s)) - BitVec.toInt o3 < Int.ofNat (List.length (contents' s)) - BitVec.toInt i) ∧ ((0 : ℤ) ≤ BitVec.toInt b ∧ BitVec.toInt b ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ Int.ofNat (List.length (contents' s))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length (Queue.seq ss)) → notin sep ((Queue.seq ss)[Int.toNat j]!)) ∧ (∀(j : ℤ), BitVec.toInt b ≤ j ∧ j < BitVec.toInt o3 → ¬(contents' s)[Int.toNat j]! = sep) ∧ (BitVec.toInt limit = -(1 : ℤ) ∨ Int.ofNat (List.length (Queue.seq ss)) < BitVec.toInt limit - (1 : ℤ)) ∧ contents' suffix = List.drop (Int.toNat (BitVec.toInt b)) (contents' s) ∧ concat (Queue.seq ss ++ [suffix]) sep = contents' s)) else ∀(o3 : BitVec 63), BitVec.toInt o3 = Int.ofNat (List.length (contents' s)) → ((0 : ℤ) ≤ BitVec.toInt b ∧ BitVec.toInt b ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ Int.ofNat (List.length (contents' s))) ∧ (∀(o4 : string'), contents' o4 = List.drop (Int.toNat (BitVec.toInt b)) (List.take (Int.toNat (BitVec.toInt o3) - Int.toNat (BitVec.toInt b)) (contents' s)) → (∀(ss1 : Queue.t string'), Queue.seq ss1 = Queue.seq ss ++ [o4] → (1 : ℤ) ≤ Int.ofNat (List.length (Queue.seq ss1)) ∧ (BitVec.toInt limit = -(1 : ℤ) ∨ Int.ofNat (List.length (Queue.seq ss1)) ≤ BitVec.toInt limit) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length (Queue.seq ss1)) - (1 : ℤ) → notin sep ((Queue.seq ss1)[Int.toNat j]!)) ∧ (Int.ofNat (List.length (Queue.seq ss1)) = BitVec.toInt limit ∨ notin sep ((Queue.seq ss1)[Int.toNat (Int.ofNat (List.length (Queue.seq ss1)) - (1 : ℤ))]!)) ∧ concat (Queue.seq ss1) sep = contents' s)))))
  := sorry
end split_string_SplitStringOCaml_split_stringqtvc
