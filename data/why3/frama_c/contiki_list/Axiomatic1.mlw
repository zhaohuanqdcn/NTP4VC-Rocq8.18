(* ---------------------------------------------------------- *)
(* --- Global Definitions (continued #1)                  --- *)
(* ---------------------------------------------------------- *)
theory Axiomatic1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import S1_list.S1_list

predicate p_unchanged (malloc_0 : map int int) (mptr_0 : map addr addr)
    (mflt_0 : map addr real) (malloc_1 : map int int)
    (mptr_1 : map addr addr) (mflt_1 : map addr real) (array_0 : addr)
    (down_0 : int) (up_0 : int) =
    forall i : int. let a = (shift_ptr array_0 i) in let a_1 = mptr_0[a] in
    let a_2 = mptr_1[a] in (down_0 <= i) -> (i < up_0) ->
    ((a_1 = a_2) /\
     ((eqs1_list ((load_s1_list a_2 mflt_1 mptr_1))
        ((load_s1_list a_1 mflt_0 mptr_0)))) /\
     (((valid_rw malloc_1 a_2 4)) -> ((valid_rw malloc_0 a_1 4))))

predicate p_array_swipe_left (mptr_0 : map addr addr)
    (mptr_1 : map addr addr) (array_0 : addr) (down_0 : int) (up_0 : int) =
    forall i : int. (down_0 <= i) -> (i < up_0) ->
    (mptr_1[(shift_ptr array_0 (1 + i))] = mptr_0[(shift_ptr array_0 i)])

predicate p_array_swipe_right (mptr_0 : map addr addr)
    (mptr_1 : map addr addr) (array_0 : addr) (down_0 : int) (up_0 : int) =
    forall i : int. (down_0 <= i) -> (i < up_0) ->
    (mptr_1[(shift_ptr array_0 (i - 1))] = mptr_0[(shift_ptr array_0 i)])

end

