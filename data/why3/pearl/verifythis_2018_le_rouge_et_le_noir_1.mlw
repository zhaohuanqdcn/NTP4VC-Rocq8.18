(**

{1 VerifyThis @ ETAPS 2018 competition
   Challenge 2: Le rouge et le noir}

Author: Raphaël Rieu-Helft (LRI, Université Paris Sud)
*)

module ColoredTiles

use int.Int
use set.Fset
use seq.Seq

type color = Red | Black

type coloring = seq color

predicate tworedneighbors (c: coloring) (i:int)
  = ((c[i-2] = Red /\ c[i-1] = Red /\ 2 <= i)
     \/ (c[i-1] = Red /\ c[i+1] = Red /\ 1 <= i <= length c - 2)
     \/ (c[i+1] = Red /\ c[i+2] = Red /\ i <= length c - 3))

predicate valid (c:coloring) =
  forall i. 0 <= i < length c -> c[i] = Red -> tworedneighbors c i

function black (_n:int) : color = Black
function red (_n:int) : color = Red

function colorings0 : fset coloring = add (create 0 black) Fset.empty
function colorings1 : fset coloring = add (create 1 black) Fset.empty
function colorings2 : fset coloring = add (create 2 black) Fset.empty
function colorings3: fset coloring =
         add (create 3 red) (add (create 3 black) Fset.empty)

let ghost valid_contr (c : coloring) (i : int) : unit
  requires { valid c }
  requires { 0 <= i < length c }
  requires { not (tworedneighbors c i) }
  ensures  { c[i] = Black }
= ()

let ghost colo_0 (c: coloring) : unit
  requires { length c = 0 }
  ensures  { valid c <-> mem c colorings0 }
= ()

let ghost colo_1 (c: coloring) : unit
  requires { length c = 1 }
  ensures  { valid c <-> mem c colorings1 }
= ()

let ghost colo_2 (c: coloring) : unit
  requires { length c = 2 }
  ensures  { valid c <-> mem c colorings2 }
= ()

let ghost colo_3 (c: coloring) : unit
  requires { length c = 3 }
  ensures  { valid c <-> mem c colorings3 }
= ()

let ghost valid_split_fb (c:coloring) (k: int) : unit
  requires { 3 <= k < length c }
  requires { forall i. 0 <= i < k -> c[i] = Red }
  requires { valid c[k+1 ..] }
  ensures  { valid c }
= ()

let ghost valid_restrict (c: coloring) (k: int) : unit
  requires { valid c }
  requires { 0 <= k < length c }
  requires { c[k] = Black }
  ensures  { valid c[k+1 ..] }
= ()

(*1st black tile starting at i *)
let rec function first_black_tile (c:coloring) : int
  ensures { 0 <= result <= length c }
  ensures { forall j. 0 <= j < result <= length c
            -> c[j] = Red }
  ensures { result < length c -> c[result] = Black }
  ensures { valid c -> result = 0 \/ 3 <= result }
  variant { length c }
= if Seq.length c = 0 then 0
  else match c[0] with
       | Black -> 0
       | Red ->
           let r = first_black_tile c[1 ..] in
           1+r end

let rec function addleft (nr:int) (c:coloring) : coloring
  variant { nr }
  ensures { nr >= 0 -> Seq.length result = Seq.length c + nr + 1 }
= if nr <= 0 then cons Black c
  else cons Red (addleft (nr-1) c)

(* add nr red tiles and a black tile to the left of each coloring *)
function mapaddleft (s:fset coloring) (nr:int) : fset coloring
=  map (addleft nr) s

let ghost addleft_fb (c : coloring) (nr : int) : unit
  requires { 0 <= nr }
  ensures  { first_black_tile (addleft nr c) = nr }
= ()

let ghost mapaddleft_fb (s : fset coloring) (c : coloring) (nr : int) : unit
  requires { 0 <= nr }
  requires { mem c (mapaddleft s nr) }
  ensures  { first_black_tile c = nr }
= ()

predicate reciprocal (f: 'a -> 'b) (g: 'b -> 'a)
  = forall y. g (f y) = y

let ghost bij_image (u: fset 'a) (f: 'a -> 'b) (g: 'b -> 'a) : unit
  requires { reciprocal f g }
  ensures  { subset u (map g (map f u)) }
= ()

let ghost bij_cardinal (u: fset 'a) (f: 'a -> 'b) (g: 'b -> 'a) : unit
  requires { reciprocal f g }
  ensures  { cardinal (map f u) = cardinal u }
= ()

function rmleft (nr:int) (c:coloring) : coloring = c[nr+1 ..]

use seq.FreeMonoid

let ghost ext (c1 c2 : coloring) : unit
  requires { Seq.(==) c1 c2 }
  ensures  { c1 = c2 }
= ()

let ghost app_eq (c1 c2 c3 c4 : coloring) : unit
  requires { c1 = c2 }
  requires { c3 = c4 }
  ensures  { c1 ++ c3 = c2 ++ c4 }
= ()

let ghost addleft_result (c:coloring) (nr:int) : unit
  requires { 0 <= nr }
  ensures  { addleft nr c = (Seq.create nr red) ++ (cons Black c) }
= ()

let ghost addleft_bijective (nr:int) : unit
  requires { 0 <= nr }
  ensures  { reciprocal (addleft nr) (rmleft nr) }
= ()

let ghost mapaddleft_card (s: fset coloring) (nr: int) : unit
  requires { 0 <= nr }
  ensures  { cardinal (mapaddleft s nr) = cardinal s }
= ()

let ghost addleft_valid (c:coloring) (nr:int) : unit
  requires { nr = 0 \/ 3 <= nr }
  requires { valid c }
  ensures  { valid (addleft nr c) }
= ()

let ghost mapaddleft_valid (s: fset coloring) (nr: int) : unit
  requires { forall c. mem c s -> valid c }
  requires { nr = 0 \/ 3 <= nr }
  ensures  { forall c. mem c (mapaddleft s nr) -> valid c }
= ()

let ghost mapaddleft_length (s: fset coloring) (nr: int) (l1 l2: int) : unit
  requires { forall c. mem c s -> Seq.length c = l1 }
  requires { 0 <= nr }
  requires { l2 = l1 + nr + 1 }
  ensures  { forall c. mem c (mapaddleft s nr) -> Seq.length c = l2 }
= ()

let rec ghost disjoint_union (s1 s2: fset coloring) : fset coloring
  requires { forall x. mem x s1 -> not mem x s2 }
  ensures  { result = union s1 s2 }
  ensures  { cardinal result = cardinal s1 + cardinal s2 }
  variant  { cardinal s1 }
= if is_empty s1
  then begin
    s2
  end
  else
    let x = pick s1 in
    let s1' = remove x s1 in
    let s2' = add x s2 in
    let u = disjoint_union s1' s2' in
    u

use array.Array

let enum () : (count: array int, ghost sets: array (fset coloring))
  ensures { Array.length count = 51 = Array.length sets
            /\ (forall i. 0 <= i <= 50 ->
               (forall c: coloring. Seq.length c = i ->
                          (valid c <-> mem c (sets[i]))))
            /\ (forall i. 0 <= i < 50 ->
                          count[i] = cardinal (sets[i])) }
= let count = Array.make 51 0 in
  let ghost sets : array (fset coloring) = Array.make 51 Fset.empty in
  count[0] <- 1;
  sets[0] <- colorings0;
  count[1] <- 1;
  sets[1] <- colorings1;
  count[2] <- 1;
  sets[2] <- colorings2;
  count[3] <- 2;
  sets[3] <- colorings3;
  for n = 4 to 50 do
    invariant { forall c i. 0 <= i < n -> Seq.length c = i ->
                         valid c -> mem c (sets[i]) }
    invariant { forall c i. 0 <= i < n -> mem c (sets[i]) ->
                         (Seq.length c = i /\ valid c) }
    invariant { forall i. 0 <= i < n ->
                         count[i] = cardinal (sets[i]) }
    label StartLoop in
    (* colorings with first_black_tile = 0 *)
    count[n] <- count[n-1];
    sets[n] <- mapaddleft (sets[n-1]) 0;
    for k = 3 to n-1 do
      invariant { forall c i. 0 <= i < n -> Seq.length c = i ->
                           valid c -> mem c (sets[i]) }
      invariant { forall c i. 0 <= i < n -> mem c (sets[i]) ->
                             (Seq.length c = i /\ valid c) }
      invariant { forall i. 0 <= i < n ->
                            count[i] = cardinal (sets[i]) }
      invariant { forall c. (mem c (sets[n]) <->
                            (Seq.length c = n /\ valid c
                            /\ first_black_tile c < k)) }
      invariant { count[n] = cardinal (sets[n]) }
      label InnerLoop in
      (* colorings with first_black_tile = k *)
      count[n] <- count [n] + count [n-k-1];
      let ghost ns = mapaddleft sets[n-k-1] k in
      sets[n] <- disjoint_union (sets[n]) ns;
    done;
    (* coloring with first_black_tile = n *)
    label LastAdd in
    let ghost r = Seq.create n red in
    let ghost sr = Fset.singleton r in
    count[n] <- count[n]+1;
    sets[n] <- disjoint_union (sets[n]) sr;
  done;
  count, sets

end
