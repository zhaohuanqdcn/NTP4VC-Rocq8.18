theory min_max_Top_a_better_min_maxqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref"
begin
definition is_min :: "int \<Rightarrow> int list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "is_min m a lo hi \<longleftrightarrow> (\<exists>(i :: int). (lo \<le> i \<and> i < hi \<and> hi \<le> int (length a)) \<and> a ! nat i = m) \<and> (\<forall>(i :: int). lo \<le> i \<and> i < hi \<longrightarrow> m \<le> a ! nat i)" for m a lo hi
definition is_max :: "int \<Rightarrow> int list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "is_max m a lo hi \<longleftrightarrow> (\<exists>(i :: int). (lo \<le> i \<and> i < hi \<and> hi \<le> int (length a)) \<and> a ! nat i = m) \<and> (\<forall>(i :: int). lo \<le> i \<and> i < hi \<longrightarrow> a ! nat i \<le> m)" for m a lo hi
theorem a_better_min_max'vc:
  fixes a :: "int list"
  assumes fact0: "(1 :: int) \<le> int (length a)"
  shows "let n :: int = int (length a) in ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length a)) \<and> (let o1 :: int = a ! (0 :: nat) in ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length a)) \<and> (let o2 :: int = a ! (0 :: nat) in \<not>(2 :: int) = (0 :: int) \<and> (\<forall>(o3 :: int). (if n cmod (2 :: int) = (0 :: int) then o3 = (2 :: int) else o3 = (1 :: int)) \<longrightarrow> (o3 = (2 :: int) \<longrightarrow> ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) < int (length a)) \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length a)) \<and> (0 :: int) \<le> (1 :: int) \<and> (1 :: int) < int (length a)) \<and> (\<forall>(min :: int) (max :: int). (if o3 = (2 :: int) then if a ! (0 :: nat) < a ! (1 :: nat) then max = a ! (1 :: nat) \<and> min = o1 else min = a ! (1 :: nat) \<and> max = o2 else min = o1 \<and> max = o2) \<longrightarrow> (o3 cmod (2 :: int) = n cmod (2 :: int) \<and> is_min min a (0 :: int) o3 \<and> is_max max a (0 :: int) o3) \<and> (\<forall>(min1 :: int) (max1 :: int) (i :: int). i cmod (2 :: int) = n cmod (2 :: int) \<and> is_min min1 a (0 :: int) i \<and> is_max max1 a (0 :: int) i \<longrightarrow> (if i < n then (let o4 :: int = i + (1 :: int) in ((0 :: int) \<le> o4 \<and> o4 < int (length a)) \<and> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if a ! nat i < a ! nat o4 then let o5 :: int = i + (1 :: int) in ((0 :: int) \<le> o5 \<and> o5 < int (length a)) \<and> (0 :: int) \<le> i \<and> i < int (length a) else ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (let o5 :: int = i + (1 :: int) in (0 :: int) \<le> o5 \<and> o5 < int (length a)))) \<and> (\<forall>(x :: int) (y :: int). (if a ! nat i < a ! nat (i + (1 :: int)) then x = a ! nat i \<and> y = a ! nat (i + (1 :: int)) else x = a ! nat (i + (1 :: int)) \<and> y = a ! nat i) \<longrightarrow> (\<forall>(min2 :: int). (if x < min1 then min2 = x else min2 = min1) \<longrightarrow> (\<forall>(max2 :: int). (if max1 < y then max2 = y else max2 = max1) \<longrightarrow> ((0 :: int) \<le> n - i \<and> n - (i + (2 :: int)) < n - i) \<and> (i + (2 :: int)) cmod (2 :: int) = n cmod (2 :: int) \<and> is_min min2 a (0 :: int) (i + (2 :: int)) \<and> is_max max2 a (0 :: int) (i + (2 :: int))))) else is_min min1 a (0 :: int) (int (length a)) \<and> is_max max1 a (0 :: int) (int (length a))))))))"
  sorry
end
