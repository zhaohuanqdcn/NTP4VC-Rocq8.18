import Why3.Base
import pearl.imp.lib.lean.imp.Syntax
import pearl.imp.lib.lean.imp.ConcreteSemantics
import pearl.imp.lib.lean.imp.Svar
import pearl.imp.lib.lean.imp.Constraint
import pearl.imp.lib.lean.imp.SymState
import pearl.imp.lib.lean.imp.FreshSvar
import pearl.imp.lib.lean.imp.SymStateSet
open Classical
open Lean4Why3
namespace imp_SymbolicInterpreter_symbolic_interp_whileqtvc
axiom compose : (Svar.svar -> ℤ) -> Constraint.t -> Syntax.program_var -> Option ℤ
axiom compose'def (rho : Svar.svar -> ℤ) (sigma : Constraint.t) (x : Syntax.program_var) : compose rho sigma x = (match Constraint.get sigma x with | Option.some v => Option.some (rho v) | Option.none => Option.none)
noncomputable def state_extends (s : SymState.sym_state) (s' : SymState.sym_state) := Svar.to_fset (SymState.vars s) ⊆ Svar.to_fset (SymState.vars s') ∧ (∀(v : Svar.svar), v ∈ Svar.to_fset (SymState.vars s) → SymState.rho s v = SymState.rho s' v)
axiom svar_set_add : Svar.svar -> Svar.set -> Svar.set
axiom svar_set_add'def (v : Svar.svar) (vs : Svar.set) : Svar.to_fset (svar_set_add v vs) = insert v (Svar.to_fset vs) ∧ (if v ∈ Svar.to_fset vs then Finset.card (Svar.to_fset (svar_set_add v vs)) = Finset.card (Svar.to_fset vs) else Int.ofNat (Finset.card (Svar.to_fset (svar_set_add v vs))) = Int.ofNat (Finset.card (Svar.to_fset vs)) + (1 : ℤ))
noncomputable def results_extend (s : SymState.sym_state) (normals : Finset SymState.sym_state) (unbounds : Finset SymState.sym_state) (limits : Finset SymState.sym_state) := ∀(s' : SymState.sym_state), s' ∈ normals ∨ s' ∈ unbounds ∨ s' ∈ limits → state_extends s s'
theorem symbolic_interp_while'vc (ctr : ℤ) (n : ℤ) (s : SymState.sym_state) (e : Syntax.expr) (c : Syntax.cmd) (fact0 : (0 : ℤ) ≤ ctr) (fact1 : ctr ≤ n) : (¬ctr = n → (∀(sym_cond : Constraint.symbolic_expr), ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e (ConcreteSemantics.expr_behaviour.Enormal (Constraint.interp_symbolic_expr (SymState.rho s) sym_cond)) ∧ (∀(v : Svar.svar), v ∈ Constraint.vars_in_symbolic_expr sym_cond → (∃(x : Syntax.program_var), Constraint.get (SymState.sigma s) x = Option.some v)) → (let o1 : Svar.set := SymState.vars s; let o2 : Constraint.constr := Constraint.constr.Cconj (SymState.constr s) (Constraint.constr.Cneq sym_cond (Constraint.symbolic_expr.Slit (0 : ℤ))); let o3 : Constraint.t := SymState.sigma s; (Constraint.vars_in_constraint o2 ⊆ Svar.to_fset o1 ∧ (∀(x : Syntax.program_var) (v : Svar.svar), Constraint.get o3 x = Option.some v → v ∈ Svar.to_fset o1)) ∧ (∀(s1 : SymState.sym_state), SymState.sigma s1 = o3 ∧ SymState.constr s1 = o2 ∧ SymState.rho s1 = SymState.rho s ∧ SymState.vars s1 = o1 → (let o4 : Svar.set := SymState.vars s; let o5 : Constraint.constr := Constraint.constr.Cconj (SymState.constr s) (Constraint.constr.Ceq sym_cond (Constraint.symbolic_expr.Slit (0 : ℤ))); let o6 : Constraint.t := SymState.sigma s; (Constraint.vars_in_constraint o5 ⊆ Svar.to_fset o4 ∧ (∀(x : Syntax.program_var) (v : Svar.svar), Constraint.get o6 x = Option.some v → v ∈ Svar.to_fset o4)) ∧ (∀(s2 : SymState.sym_state), SymState.sigma s2 = o6 ∧ SymState.constr s2 = o5 ∧ SymState.rho s2 = SymState.rho s ∧ SymState.vars s2 = o4 → (true = false → (∀(rho : Svar.svar -> ℤ), ¬Constraint.is_solution rho (SymState.constr s1))) → (0 : ℤ) ≤ n ∧ (∀(normals1 : SymStateSet.set) (unbounds1 : SymStateSet.set) (limits1 : SymStateSet.set), results_extend s1 (SymStateSet.to_fset normals1) (SymStateSet.to_fset unbounds1) (SymStateSet.to_fset limits1) ∧ (Constraint.is_solution (SymState.rho s1) (SymState.constr s1) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s1) (SymState.sigma s1)) c gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → Constraint.is_solution (SymState.rho s1) (SymState.constr s1) ∧ ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s1) (SymState.sigma s1)) c (compose (SymState.rho s') (SymState.sigma s')) bhv) → (let o7 : List SymState.sym_state := SymStateSet.to_list normals1; (∀(e1 : SymState.sym_state), (e1 ∈ SymStateSet.to_fset normals1) = (e1 ∈ o7)) → (let o8 : ℤ := ctr + (1 : ℤ); ((0 : ℤ) ≤ n - ctr ∧ n - o8 < n - ctr ∨ n - ctr = n - o8 ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ Int.ofNat (List.length o7) < (0 : ℤ)) ∧ (0 : ℤ) ≤ o8 ∧ o8 ≤ n))))))))) ∧ (∀(normals : SymStateSet.set) (unbounds : SymStateSet.set) (limits : SymStateSet.set), (if ctr = n then (SymStateSet.to_fset limits = insert s (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset limits)) = (1 : ℤ)) ∧ (SymStateSet.to_fset unbounds = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset unbounds)) = (0 : ℤ)) ∧ SymStateSet.to_fset normals = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset normals)) = (0 : ℤ) else (∃(sym_cond : Constraint.symbolic_expr), (ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e (ConcreteSemantics.expr_behaviour.Enormal (Constraint.interp_symbolic_expr (SymState.rho s) sym_cond)) ∧ (∀(v : Svar.svar), v ∈ Constraint.vars_in_symbolic_expr sym_cond → (∃(x : Syntax.program_var), Constraint.get (SymState.sigma s) x = Option.some v))) ∧ (∃(s1 : SymState.sym_state), (SymState.sigma s1 = SymState.sigma s ∧ SymState.constr s1 = Constraint.constr.Cconj (SymState.constr s) (Constraint.constr.Cneq sym_cond (Constraint.symbolic_expr.Slit (0 : ℤ))) ∧ SymState.rho s1 = SymState.rho s ∧ SymState.vars s1 = SymState.vars s) ∧ (∃(s2 : SymState.sym_state), (SymState.sigma s2 = SymState.sigma s ∧ SymState.constr s2 = Constraint.constr.Cconj (SymState.constr s) (Constraint.constr.Ceq sym_cond (Constraint.symbolic_expr.Slit (0 : ℤ))) ∧ SymState.rho s2 = SymState.rho s ∧ SymState.vars s2 = SymState.vars s) ∧ (∃(normals1 : SymStateSet.set) (unbounds1 : SymStateSet.set) (limits1 : SymStateSet.set), (∃(o1 : Bool), (o1 = false → (∀(rho : Svar.svar -> ℤ), ¬Constraint.is_solution rho (SymState.constr s1))) ∧ (if o1 = true then ∃(normals2 : SymStateSet.set) (unbounds2 : SymStateSet.set) (limits2 : SymStateSet.set), (results_extend s1 (SymStateSet.to_fset normals2) (SymStateSet.to_fset unbounds2) (SymStateSet.to_fset limits2) ∧ (Constraint.is_solution (SymState.rho s1) (SymState.constr s1) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s1) (SymState.sigma s1)) c gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals2 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds2 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits2) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals2 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds2 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits2) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → Constraint.is_solution (SymState.rho s1) (SymState.constr s1) ∧ ConcreteSemantics.exec_cmd (ConcreteSemantics.mk_loop_cnf n) (compose (SymState.rho s1) (SymState.sigma s1)) c (compose (SymState.rho s') (SymState.sigma s')) bhv)) ∧ (let o2 : List SymState.sym_state := SymStateSet.to_list normals2; (∀(e1 : SymState.sym_state), (e1 ∈ SymStateSet.to_fset normals2) = (e1 ∈ o2)) ∧ (let o3 : ℤ := ctr + (1 : ℤ); ∃(unbounds3 : SymStateSet.set) (limits3 : SymStateSet.set), ((∀(s' : SymState.sym_state), s' ∈ SymStateSet.to_fset normals1 ∨ s' ∈ SymStateSet.to_fset unbounds3 ∨ s' ∈ SymStateSet.to_fset limits3 → (∃(s3 : SymState.sym_state), s3 ∈ SymStateSet.to_fset (SymStateSet.of_list o2) ∧ state_extends s3 s')) ∧ (∀(s3 : SymState.sym_state), s3 ∈ SymStateSet.to_fset (SymStateSet.of_list o2) → Constraint.is_solution (SymState.rho s3) (SymState.constr s3) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) o3 (compose (SymState.rho s3) (SymState.sigma s3)) e c gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds3 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits3) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds3 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits3) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → (∃(s3 : SymState.sym_state), s3 ∈ SymStateSet.to_fset (SymStateSet.of_list o2) ∧ Constraint.is_solution (SymState.rho s3) (SymState.constr s3) ∧ ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) o3 (compose (SymState.rho s3) (SymState.sigma s3)) e c (compose (SymState.rho s') (SymState.sigma s')) bhv))) ∧ SymStateSet.to_fset limits1 = SymStateSet.to_fset limits2 ∪ SymStateSet.to_fset limits3 ∧ SymStateSet.to_fset unbounds1 = SymStateSet.to_fset unbounds2 ∪ SymStateSet.to_fset unbounds3)) else (SymStateSet.to_fset limits1 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset limits1)) = (0 : ℤ)) ∧ (SymStateSet.to_fset unbounds1 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset unbounds1)) = (0 : ℤ)) ∧ SymStateSet.to_fset normals1 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset normals1)) = (0 : ℤ))) ∧ (∃(normals2 : SymStateSet.set) (unbounds2 : SymStateSet.set) (limits2 : SymStateSet.set), (∃(o1 : Bool), (o1 = false → (∀(rho : Svar.svar -> ℤ), ¬Constraint.is_solution rho (SymState.constr s2))) ∧ (if o1 = true then (SymStateSet.to_fset limits2 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset limits2)) = (0 : ℤ)) ∧ (SymStateSet.to_fset unbounds2 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset unbounds2)) = (0 : ℤ)) ∧ SymStateSet.to_fset normals2 = insert s2 (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset normals2)) = (1 : ℤ) else (SymStateSet.to_fset limits2 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset limits2)) = (0 : ℤ)) ∧ (SymStateSet.to_fset unbounds2 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset unbounds2)) = (0 : ℤ)) ∧ SymStateSet.to_fset normals2 = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset normals2)) = (0 : ℤ))) ∧ SymStateSet.to_fset limits = SymStateSet.to_fset limits1 ∪ SymStateSet.to_fset limits2 ∧ SymStateSet.to_fset unbounds = SymStateSet.to_fset unbounds1 ∪ SymStateSet.to_fset unbounds2 ∧ SymStateSet.to_fset normals = SymStateSet.to_fset normals1 ∪ SymStateSet.to_fset normals2))))) ∨ ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e ConcreteSemantics.expr_behaviour.Eunbound_var ∧ (SymStateSet.to_fset limits = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset limits)) = (0 : ℤ)) ∧ (SymStateSet.to_fset unbounds = insert s (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset unbounds)) = (1 : ℤ)) ∧ SymStateSet.to_fset normals = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset normals)) = (0 : ℤ)) → results_extend s (SymStateSet.to_fset normals) (SymStateSet.to_fset unbounds) (SymStateSet.to_fset limits) ∧ (Constraint.is_solution (SymState.rho s) (SymState.constr s) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) ctr (compose (SymState.rho s) (SymState.sigma s)) e c gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → Constraint.is_solution (SymState.rho s) (SymState.constr s) ∧ ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) ctr (compose (SymState.rho s) (SymState.sigma s)) e c (compose (SymState.rho s') (SymState.sigma s')) bhv))
  := sorry
end imp_SymbolicInterpreter_symbolic_interp_whileqtvc
