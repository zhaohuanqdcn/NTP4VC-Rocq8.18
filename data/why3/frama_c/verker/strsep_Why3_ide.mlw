(* ---------------------------------------------------------- *)
(* --- Complete behaviors 'input_strpbrk_not_null', 'input_strpbrk_null',
                   'input_null' --- *)
(* ---------------------------------------------------------- *)
theory VCstrsep_complete_input_strpbrk_not_null_input_strpbrk_null___
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import A_Strlen.A_Strlen
use import A_StrPBrk.A_StrPBrk

(*
goal WP "expl:Complete behaviors 'input_strpbrk_not_null', 'input_strpbrk_null',
                   'input_null'":
*)
goal goal0:
  forall t : map int int.
  forall t_1 : map addr int.
  forall t_2 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_2[a] in
  let a_3 = (l_strpbrk a_2 a_1) in
  (not ((p_valid_str t t_1 a_2)) <-> (a_2 = null)) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_2)) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((valid_rw t a 1)) ->
  ((p_valid_str t t_1 a_1)) ->
  ((a_2 = null) \/ ((a_3 = null) /\ ((p_valid_str t t_1 a_2))) \/
   ((a_3 <> null) /\ ((p_valid_str t t_1 a_2))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'input_strpbrk_not_null', 'input_strpbrk_null',
                   'input_null' --- *)
(* ---------------------------------------------------------- *)
theory VCstrsep_disjoint_input_strpbrk_not_null_input_strpbrk_null___
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import A_Strlen.A_Strlen
use import A_StrPBrk.A_StrPBrk

(*
goal WP "expl:Disjoint behaviors 'input_strpbrk_not_null', 'input_strpbrk_null',
                   'input_null'":
*)
goal goal1:
  forall t : map int int.
  forall t_1 : map addr int.
  forall t_2 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_2[a] in
  let a_3 = (l_strpbrk a_2 a_1) in
  (not ((p_valid_str t t_1 a_2)) <-> (a_2 = null)) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_2)) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((valid_rw t a 1)) ->
  ((p_valid_str t t_1 a_1)) ->
  (((a_2 <> null) \/ (a_3 <> null) \/ (not (p_valid_str t t_1 a_2))) /\
   ((a_2 <> null) \/ (a_3 = null) \/ (not (p_valid_str t t_1 a_2))))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'input_strpbrk_not_null' (file src/strsep.h, line 40) in 'strsep' --- *)
(* ---------------------------------------------------------- *)
theory VCstrsep_input_strpbrk_not_null_post_4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import A_StrPBrk.A_StrPBrk
use import A_Strlen.A_Strlen
use import Compound.Compound

(*
goal WP "expl:Post-condition for 'input_strpbrk_not_null' (file src/strsep.h, line 40) in 'strsep'":
*)
goal goal2:
  forall t : map int int.
  forall t_1 : map addr int.
  forall t_2 : map addr addr.
  forall a_4 a_3 a_2 a_1 a : addr.
  let a_5 = t_2[a] in
  let a_6 = (l_strpbrk a_5 a_1) in
  let a_7 = (shift_sint8 a_1 ((l_strlen t_1 a_1))) in
  let a_8 = (shift_sint8 a_5 ((l_strlen t_1 a_5))) in
  (a_5 <> null) ->
  (t_1[a_3] = t_1[a_2]) ->
  (a_6 <> null) ->
  (t_1[a_6] = t_1[a_4]) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_2)) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((addr_le a_1 a_2)) ->
  ((addr_le a_1 a_4)) ->
  ((valid_rw t a 1)) ->
  ((addr_le a_5 a_3)) ->
  ((p_valid_str t t_1 a_1)) ->
  ((p_valid_str t t_1 a_5)) ->
  ((addr_le a_5 a_6)) ->
  ((addr_lt a_2 a_7)) ->
  ((addr_le a_4 a_7)) ->
  ((addr_lt a_3 a_8)) ->
  ((addr_lt a_6 a_8)) ->
  (forall a_10 a_9 : addr. ((addr_le a_1 a_9)) -> ((addr_le a_5 a_10)) ->
   ((addr_lt a_10 a_6)) -> ((addr_lt a_9 a_7)) -> (t_1[a_10] <> t_1[a_9])) ->
  ((p_valid_str t t_1[a_6 <- 0] a_5))

end

