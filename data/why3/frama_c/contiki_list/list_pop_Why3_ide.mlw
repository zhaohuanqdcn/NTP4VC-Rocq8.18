(* ---------------------------------------------------------- *)
(* --- Complete behaviors 'more', 'empty'                 --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_complete_more_empty
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Complete behaviors 'more', 'empty'":
*)
goal goal0:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = (shift_ptr a_1 0) in
  let a_3 = t_1[a] in
  let x = i + i_1 in
  (0 <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_2 2147483646)) ->
  ((separated a 1 a_2 2147483646)) ->
  ((separated a_3 4 a_2 2147483646)) ->
  ((p_linked_n t t_1 a_3 a_1 i_1 i null)) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_2)] 4))) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated t_1[(shift_ptr a_1 i_2)] 4 a_2 2147483646))) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   (t_1[(shift_ptr a_1 i_3)] <> t_1[(shift_ptr a_1 i_2)])) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 t_1[(shift_ptr a_1 i_2)] 4))) ->
  ((i = 0) \/ (0 < i))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'more', 'empty'                 --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_disjoint_more_empty
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'more', 'empty'":
*)
goal goal1:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = (shift_ptr a_1 0) in
  let a_3 = t_1[a] in
  let x = i + i_1 in
  (0 <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_2 2147483646)) ->
  ((separated a 1 a_2 2147483646)) ->
  ((separated a_3 4 a_2 2147483646)) ->
  ((p_linked_n t t_1 a_3 a_1 i_1 i null)) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_2)] 4))) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated t_1[(shift_ptr a_1 i_2)] 4 a_2 2147483646))) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   (t_1[(shift_ptr a_1 i_3)] <> t_1[(shift_ptr a_1 i_2)])) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 t_1[(shift_ptr a_1 i_2)] 4))) ->
  ((i <> 0) \/ (i <= 0))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition (file list_pop.c, line 36) in 'list_pop' (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_post_2_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition (file list_pop.c, line 36) in 'list_pop' (1/2)":
*)
goal goal2:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let x = i + i_1 in
  let a_3 = (shift_ptr a_1 0) in
  (a_2 <> null) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i null)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 a_3 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_1[(shift_ptr a_1 i_4)] <> t_1[(shift_ptr a_1 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_1 i_4)] 4 t_1[(shift_ptr a_1 i_3)] 4))) ->
  ((separated a 1
     t_1[a <- t_1[(shiftfield_f1_list_next a_2)]][(shift_ptr a_1 i_2)] 4))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition (file list_pop.c, line 36) in 'list_pop' (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_post_2_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition (file list_pop.c, line 36) in 'list_pop' (2/2)":
*)
goal goal3:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let x = i + i_1 in
  let a_3 = (shift_ptr a_1 0) in
  (a_2 = null) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_2 < x) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i a_2)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 a_3 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_1[(shift_ptr a_1 i_4)] <> t_1[(shift_ptr a_1 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_1 i_4)] 4 t_1[(shift_ptr a_1 i_3)] 4))) ->
  ((separated a 1 t_1[(shift_ptr a_1 i_2)] 4))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition (file list_pop.c, line 38) in 'list_pop' (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_post_3_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition (file list_pop.c, line 38) in 'list_pop' (1/2)":
*)
goal goal4:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let a_3 = (shift_ptr a_1 0) in
  let x = i + i_1 in
  (a_2 <> null) ->
  (0 <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i null)) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_2)] 4))) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated t_1[(shift_ptr a_1 i_2)] 4 a_3 2147483646))) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   (t_1[(shift_ptr a_1 i_3)] <> t_1[(shift_ptr a_1 i_2)])) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 t_1[(shift_ptr a_1 i_2)] 4))) ->
  ((separated t_1[(shiftfield_f1_list_next a_2)] 4 a_3 2147483646))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file list_pop.c, line 105) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_assert_rte_mem_access
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Assertion 'rte,mem_access' (file list_pop.c, line 105)":
*)
goal goal5:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = (shift_ptr a_1 0) in
  let a_3 = t_1[a] in
  let x = i + i_1 in
  (0 <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_2 2147483646)) ->
  ((separated a 1 a_2 2147483646)) ->
  ((separated a_3 4 a_2 2147483646)) ->
  ((p_linked_n t t_1 a_3 a_1 i_1 i null)) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_2)] 4))) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated t_1[(shift_ptr a_1 i_2)] 4 a_2 2147483646))) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   (t_1[(shift_ptr a_1 i_3)] <> t_1[(shift_ptr a_1 i_2)])) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 t_1[(shift_ptr a_1 i_2)] 4))) ->
  ((valid_rd t a 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file list_pop.c, line 107) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_assert_rte_mem_access_4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Assertion 'rte,mem_access' (file list_pop.c, line 107)":
*)
goal goal6:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let a_3 = (shift_ptr a_1 0) in
  let x = i + i_1 in
  (a_2 <> null) ->
  (0 <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rd t a 1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i null)) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_2)] 4))) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated t_1[(shift_ptr a_1 i_2)] 4 a_3 2147483646))) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   (t_1[(shift_ptr a_1 i_3)] <> t_1[(shift_ptr a_1 i_2)])) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 t_1[(shift_ptr a_1 i_2)] 4))) ->
  ((valid_rd t ((shiftfield_f1_list_next a_2)) 1))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'empty' (file list_pop.c, line 43) in 'list_pop' (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_empty_post_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'empty' (file list_pop.c, line 43) in 'list_pop' (1/2)":
*)
goal goal7:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let a_3 = (shift_ptr a_1 0) in
  (a_2 <> null) ->
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i 0 null)) ->
  (t_1[(shiftfield_f1_list_next a_2)] = a_2)

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'empty' (file list_pop.c, line 44) in 'list_pop' (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_empty_post_2_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'empty' (file list_pop.c, line 44) in 'list_pop' (1/2)":
*)
goal goal8:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let a_3 = (shift_ptr a_1 0) in
  let a_4 = t_1[(shiftfield_f1_list_next a_2)] in
  (a_2 <> null) ->
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i 0 null)) ->
  ((p_linked_n t t_1[a <- a_4] a_4 a_1 i 0 null))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'empty' (file list_pop.c, line 45) in 'list_pop' (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_empty_post_3_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition for 'empty' (file list_pop.c, line 45) in 'list_pop' (1/2)":
*)
goal goal9:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_2 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_2[a] in
  let a_3 = (shift_ptr a_1 0) in
  (a_2 <> null) ->
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_2)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_2 a_2 a_1 i 0 null)) ->
  ((p_unchanged t t_2[a <- t_2[(shiftfield_f1_list_next a_2)]] t_1 t t_2 t_1
     a_1 i i))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'empty' (file list_pop.c, line 45) in 'list_pop' (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_empty_post_3_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition for 'empty' (file list_pop.c, line 45) in 'list_pop' (2/2)":
*)
goal goal10:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr real.
  forall t_2 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_2[a] in
  let a_3 = (shift_ptr a_1 0) in
  (a_2 = null) ->
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_2)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_2 a_2 a_1 i 0 a_2)) ->
  ((p_unchanged t t_2 t_1 t t_2 t_1 a_1 i i))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'empty' (file list_pop.c, line 46) in 'list_pop' (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_empty_post_4_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'empty' (file list_pop.c, line 46) in 'list_pop' (1/2)":
*)
goal goal11:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let a_3 = (shift_ptr a_1 0) in
  (a_2 <> null) ->
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i 0 null)) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Assigns for 'empty' nothing in 'list_pop' (2/2)    --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_empty_assign_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Assigns for 'empty' nothing in 'list_pop' (2/2)":
*)
goal goal12:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let a_3 = (shift_ptr a_1 0) in
  (a_2 <> null) ->
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i 0 null)) ->
  ((invalid t a 1))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' (file list_pop.c, line 69) in 'list_pop' (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'more' (file list_pop.c, line 69) in 'list_pop' (2/2)":
*)
goal goal13:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let a_3 = (shift_ptr a_1 0) in
  let x = i + i_1 in
  (a_2 = null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i a_2)) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_2)] 4))) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated t_1[(shift_ptr a_1 i_2)] 4 a_3 2147483646))) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   (t_1[(shift_ptr a_1 i_3)] <> t_1[(shift_ptr a_1 i_2)])) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 t_1[(shift_ptr a_1 i_2)] 4))) ->
  (t_1[(shiftfield_f1_list_next a_2)] = a_2)

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' (file list_pop.c, line 70) in 'list_pop' (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_2_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition for 'more' (file list_pop.c, line 70) in 'list_pop' (1/2)":
*)
goal goal14:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let a_3 = (shift_ptr a_1 0) in
  let x = i + i_1 in
  (a_2 <> null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i null)) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_2)] 4))) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated t_1[(shift_ptr a_1 i_2)] 4 a_3 2147483646))) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   (t_1[(shift_ptr a_1 i_3)] <> t_1[(shift_ptr a_1 i_2)])) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 t_1[(shift_ptr a_1 i_2)] 4))) ->
  ((p_array_swipe_left t_1[a <- t_1[(shiftfield_f1_list_next a_2)]] t_1 a_1
     i_1 (i + i_1 - 1)))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' (file list_pop.c, line 70) in 'list_pop' (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_2_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic
use import Axiomatic1.Axiomatic1

(*
goal WP "expl:Post-condition for 'more' (file list_pop.c, line 70) in 'list_pop' (2/2)":
*)
goal goal15:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let a_3 = (shift_ptr a_1 0) in
  let x = i + i_1 in
  (a_2 = null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i a_2)) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_2)] 4))) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated t_1[(shift_ptr a_1 i_2)] 4 a_3 2147483646))) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   (t_1[(shift_ptr a_1 i_3)] <> t_1[(shift_ptr a_1 i_2)])) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 t_1[(shift_ptr a_1 i_2)] 4))) ->
  ((p_array_swipe_left t_1 t_1 a_1 i_1 (i + i_1 - 1)))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' (file list_pop.c, line 71) in 'list_pop' (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_3_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'more' (file list_pop.c, line 71) in 'list_pop' (1/2)":
*)
goal goal16:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let a_3 = (shift_ptr a_1 0) in
  let x = i + i_1 in
  let a_4 = t_1[(shiftfield_f1_list_next a_2)] in
  (a_2 <> null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i null)) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_2)] 4))) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated t_1[(shift_ptr a_1 i_2)] 4 a_3 2147483646))) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   (t_1[(shift_ptr a_1 i_3)] <> t_1[(shift_ptr a_1 i_2)])) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 t_1[(shift_ptr a_1 i_2)] 4))) ->
  ((p_linked_n t t_1[a <- a_4] a_4 a_1 i_1 (i - 1) null))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' (file list_pop.c, line 71) in 'list_pop' (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_3_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'more' (file list_pop.c, line 71) in 'list_pop' (2/2)":
*)
goal goal17:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let a_3 = (shift_ptr a_1 0) in
  let x = i + i_1 in
  (a_2 = null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i a_2)) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_2)] 4))) ->
  (forall i_2 : int. (i_1 <= i_2) -> (i_2 < x) ->
   ((separated t_1[(shift_ptr a_1 i_2)] 4 a_3 2147483646))) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   (t_1[(shift_ptr a_1 i_3)] <> t_1[(shift_ptr a_1 i_2)])) ->
  (forall i_3 i_2 : int. (i_3 <> i_2) -> (i_1 <= i_2) -> (i_1 <= i_3) ->
   (i_2 < x) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 t_1[(shift_ptr a_1 i_2)] 4))) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 (i - 1) a_2))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' 'Unique' in 'list_pop' (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_Unique_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'more' 'Unique' in 'list_pop' (1/2)":
*)
goal goal18:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let x = i + i_1 in
  let a_3 = (shift_ptr a_1 0) in
  let m = t_1[a <- t_1[(shiftfield_f1_list_next a_2)]] in
  (i_3 <> i_2) ->
  (a_2 <> null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_1 <= i_3) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((2 + i_2) <= x) ->
  ((2 + i_3) <= x) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i null)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_1 i_4)] 4 a_3 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_1[(shift_ptr a_1 i_5)] <> t_1[(shift_ptr a_1 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_1[(shift_ptr a_1 i_5)] 4 t_1[(shift_ptr a_1 i_4)] 4))) ->
  (m[(shift_ptr a_1 i_3)] <> m[(shift_ptr a_1 i_2)])

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' 'Unique' in 'list_pop' (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_Unique_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'more' 'Unique' in 'list_pop' (2/2)":
*)
goal goal19:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let x = i + i_1 in
  let a_3 = (shift_ptr a_1 0) in
  (i_3 <> i_2) ->
  (a_2 = null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_1 <= i_3) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((2 + i_2) <= x) ->
  ((2 + i_3) <= x) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i a_2)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_1 i_4)] 4 a_3 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_1[(shift_ptr a_1 i_5)] <> t_1[(shift_ptr a_1 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_1[(shift_ptr a_1 i_5)] 4 t_1[(shift_ptr a_1 i_4)] 4))) ->
  (t_1[(shift_ptr a_1 i_3)] <> t_1[(shift_ptr a_1 i_2)])

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' 'Separation' in 'list_pop' (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_Separation_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'more' 'Separation' in 'list_pop' (1/2)":
*)
goal goal20:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let x = i + i_1 in
  let a_3 = (shift_ptr a_1 0) in
  (a_2 <> null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((2 + i_2) <= x) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i null)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 a_3 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_1[(shift_ptr a_1 i_4)] <> t_1[(shift_ptr a_1 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_1 i_4)] 4 t_1[(shift_ptr a_1 i_3)] 4))) ->
  ((separated
     t_1[a <- t_1[(shiftfield_f1_list_next a_2)]][(shift_ptr a_1 i_2)] 4 a_3
     2147483646))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' 'Separation' in 'list_pop' (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_Separation_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'more' 'Separation' in 'list_pop' (2/2)":
*)
goal goal21:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let x = i + i_1 in
  let a_3 = (shift_ptr a_1 0) in
  (a_2 = null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((2 + i_2) <= x) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i a_2)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 a_3 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_1[(shift_ptr a_1 i_4)] <> t_1[(shift_ptr a_1 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_1 i_4)] 4 t_1[(shift_ptr a_1 i_3)] 4))) ->
  ((separated t_1[(shift_ptr a_1 i_2)] 4 a_3 2147483646))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' 'Separation' in 'list_pop' (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_Separation_2_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'more' 'Separation' in 'list_pop' (1/2)":
*)
goal goal22:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let x = i + i_1 in
  let a_3 = (shift_ptr a_1 0) in
  let m = t_1[a <- t_1[(shiftfield_f1_list_next a_2)]] in
  (i_3 <> i_2) ->
  (a_2 <> null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_1 <= i_3) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((2 + i_2) <= x) ->
  ((2 + i_3) <= x) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i null)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_1 i_4)] 4 a_3 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_1[(shift_ptr a_1 i_5)] <> t_1[(shift_ptr a_1 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_1[(shift_ptr a_1 i_5)] 4 t_1[(shift_ptr a_1 i_4)] 4))) ->
  ((separated m[(shift_ptr a_1 i_3)] 4 m[(shift_ptr a_1 i_2)] 4))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' 'Separation' in 'list_pop' (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_Separation_2_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'more' 'Separation' in 'list_pop' (2/2)":
*)
goal goal23:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let x = i + i_1 in
  let a_3 = (shift_ptr a_1 0) in
  (i_3 <> i_2) ->
  (a_2 = null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (i_1 <= i_3) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((2 + i_2) <= x) ->
  ((2 + i_3) <= x) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i a_2)) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_4)] 4))) ->
  (forall i_4 : int. (i_1 <= i_4) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_1 i_4)] 4 a_3 2147483646))) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   (t_1[(shift_ptr a_1 i_5)] <> t_1[(shift_ptr a_1 i_4)])) ->
  (forall i_5 i_4 : int. (i_5 <> i_4) -> (i_1 <= i_4) -> (i_1 <= i_5) ->
   (i_4 < x) -> (i_5 < x) ->
   ((separated t_1[(shift_ptr a_1 i_5)] 4 t_1[(shift_ptr a_1 i_4)] 4))) ->
  ((separated t_1[(shift_ptr a_1 i_3)] 4 t_1[(shift_ptr a_1 i_2)] 4))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' 'NoMoreHere' in 'list_pop' (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_NoMoreHere_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'more' 'NoMoreHere' in 'list_pop' (1/2)":
*)
goal goal24:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let x = i + i_1 in
  let a_3 = (shift_ptr a_1 0) in
  (a_2 <> null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((2 + i_2) <= x) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i null)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 a_3 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_1[(shift_ptr a_1 i_4)] <> t_1[(shift_ptr a_1 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_1 i_4)] 4 t_1[(shift_ptr a_1 i_3)] 4))) ->
  (t_1[a <- t_1[(shiftfield_f1_list_next a_2)]][(shift_ptr a_1 i_2)] <> a_2)

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' 'NoMoreHere' in 'list_pop' (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_NoMoreHere_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'more' 'NoMoreHere' in 'list_pop' (2/2)":
*)
goal goal25:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let x = i + i_1 in
  let a_3 = (shift_ptr a_1 0) in
  (a_2 = null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((2 + i_2) <= x) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i a_2)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 a_3 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_1[(shift_ptr a_1 i_4)] <> t_1[(shift_ptr a_1 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_1 i_4)] 4 t_1[(shift_ptr a_1 i_3)] 4))) ->
  (t_1[(shift_ptr a_1 i_2)] <> a_2)

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' 'NoMoreHere' in 'list_pop' (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_NoMoreHere_2_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'more' 'NoMoreHere' in 'list_pop' (1/2)":
*)
goal goal26:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let x = i + i_1 in
  let a_3 = (shift_ptr a_1 0) in
  (a_2 <> null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((2 + i_2) <= x) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i null)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 a_3 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_1[(shift_ptr a_1 i_4)] <> t_1[(shift_ptr a_1 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_1 i_4)] 4 t_1[(shift_ptr a_1 i_3)] 4))) ->
  ((separated
     t_1[a <- t_1[(shiftfield_f1_list_next a_2)]][(shift_ptr a_1 i_2)] 4 a_2
     4))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'more' 'NoMoreHere' in 'list_pop' (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VClist_pop_more_post_NoMoreHere_2_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'more' 'NoMoreHere' in 'list_pop' (2/2)":
*)
goal goal27:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_1 a : addr.
  let a_2 = t_1[a] in
  let x = i + i_1 in
  let a_3 = (shift_ptr a_1 0) in
  (a_2 = null) ->
  (0 < i) ->
  (0 <= i_1) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((2 + i_2) <= x) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rw t a 1)) ->
  ((valid_rw t a_3 2147483646)) ->
  ((separated a 1 a_3 2147483646)) ->
  ((separated a_2 4 a_3 2147483646)) ->
  ((p_linked_n t t_1 a_2 a_1 i_1 i a_2)) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated a 1 t_1[(shift_ptr a_1 i_3)] 4))) ->
  (forall i_3 : int. (i_1 <= i_3) -> (i_3 < x) ->
   ((separated t_1[(shift_ptr a_1 i_3)] 4 a_3 2147483646))) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   (t_1[(shift_ptr a_1 i_4)] <> t_1[(shift_ptr a_1 i_3)])) ->
  (forall i_4 i_3 : int. (i_4 <> i_3) -> (i_1 <= i_3) -> (i_1 <= i_4) ->
   (i_3 < x) -> (i_4 < x) ->
   ((separated t_1[(shift_ptr a_1 i_4)] 4 t_1[(shift_ptr a_1 i_3)] 4))) ->
  ((separated t_1[(shift_ptr a_1 i_2)] 4 a_2 4))

end

