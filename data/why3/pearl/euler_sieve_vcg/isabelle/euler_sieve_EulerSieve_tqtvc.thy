theory euler_sieve_EulerSieve_tqtvc
  imports "NTP4Verif.NTP4Verif" "./euler_sieve_ArithmeticResults" "./euler_sieve_DivisibilityResults" "./euler_sieve_EulerSieveSpec"
begin
consts o1 :: "int \<Rightarrow> bool"
consts o2 :: "int \<Rightarrow> int"
axiomatization where o'def:   "o1 i = True \<longleftrightarrow> i < (2 :: int)"
  for i :: "int"
axiomatization where o'def1:   "o2 i = i + (1 :: int)"
  for i :: "int"
theorem t'vc:
  shows "let o3 :: int \<Rightarrow> bool = o1 in (0 :: int) \<le> (4 :: int) \<and> (let o4 :: bool list = create_list (4 :: int) o3 in int (length o4) = (4 :: int) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (4 :: int) \<longrightarrow> o4 ! nat i = o3 i) \<longrightarrow> (let o5 :: int \<Rightarrow> int = o2 in (0 :: int) \<le> (4 :: int) \<and> (let o6 :: int list = create_list (4 :: int) o5 in int (length o6) = (4 :: int) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (4 :: int) \<longrightarrow> o6 ! nat i = o5 i) \<longrightarrow> ((3 :: int) < sint int'63_max \<and> (3 :: int) \<le> (3 :: int)) \<and> ((3 :: int) < sint int'63_max \<and> (3 :: int) \<le> (3 :: int) \<longrightarrow> (length o6 = length o4 \<and> int (length o4) = (3 :: int) + (1 :: int)) \<and> (length o6 = length o4 \<and> int (length o4) = (3 :: int) + (1 :: int) \<longrightarrow> inv_nexts o6 (int (length o6)) \<and> (inv_nexts o6 (int (length o6)) \<longrightarrow> all_eliminated_marked o4 o6 \<and> (all_eliminated_marked o4 o6 \<longrightarrow> (\<forall>(i :: int). (3 :: int) \<le> i \<and> i \<le> (3 :: int) \<longrightarrow> i emod (2 :: int) = (0 :: int) \<longrightarrow> o4 ! nat i = True) \<and> ((\<forall>(i :: int). (3 :: int) \<le> i \<and> i \<le> (3 :: int) \<longrightarrow> i emod (2 :: int) = (0 :: int) \<longrightarrow> o4 ! nat i = True) \<longrightarrow> (\<forall>(i :: int). (3 :: int) \<le> i \<and> i < (3 :: int) - (1 :: int) \<longrightarrow> i emod (2 :: int) = (1 :: int) \<longrightarrow> o6 ! nat i emod (2 :: int) = (1 :: int) \<or> o6 ! nat i = (3 :: int) + (1 :: int)) \<and> ((\<forall>(i :: int). (3 :: int) \<le> i \<and> i < (3 :: int) - (1 :: int) \<longrightarrow> i emod (2 :: int) = (1 :: int) \<longrightarrow> o6 ! nat i emod (2 :: int) = (1 :: int) \<or> o6 ! nat i = (3 :: int) + (1 :: int)) \<longrightarrow> o6 ! (3 :: nat) = (3 :: int) + (1 :: int) \<and> (((3 :: int) - (1 :: int)) emod (2 :: int) = (0 :: int) \<longrightarrow> o6 ! nat ((3 :: int) - (1 :: int)) = (3 :: int)) \<and> (((3 :: int) - (1 :: int)) emod (2 :: int) = (1 :: int) \<longrightarrow> o6 ! nat ((3 :: int) - (1 :: int)) = (3 :: int) + (1 :: int)))))))))))"
  sorry
end
