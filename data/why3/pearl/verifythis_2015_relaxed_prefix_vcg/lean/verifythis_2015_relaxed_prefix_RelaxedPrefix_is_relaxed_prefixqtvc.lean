import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace verifythis_2015_relaxed_prefix_RelaxedPrefix_is_relaxed_prefixqtvc
axiom char : Type
axiom inhabited_axiom_char : Inhabited char
attribute [instance] inhabited_axiom_char
noncomputable def eq_array (a1 : List char) (ofs1 : ℤ) (a2 : List char) (ofs2 : ℤ) (len : ℤ) := (0 : ℤ) ≤ len ∧ (0 : ℤ) ≤ ofs1 ∧ (0 : ℤ) ≤ ofs2 ∧ ofs1 + len ≤ Int.ofNat (List.length a1) ∧ ofs2 + len ≤ Int.ofNat (List.length a2) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < len → a1[Int.toNat (ofs1 + i)]! = a2[Int.toNat (ofs2 + i)]!)
noncomputable def is_relaxed_prefix (pat : List char) (a : List char) := let n : ℤ := Int.ofNat (List.length pat); eq_array pat (0 : ℤ) a (0 : ℤ) n ∨ (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < n) ∧ eq_array pat (0 : ℤ) a (0 : ℤ) i ∧ eq_array pat (i + (1 : ℤ)) a i (n - i - (1 : ℤ)))
theorem is_relaxed_prefix'vc (a : List char) (pat : List char) : let m : ℤ := Int.ofNat (List.length a); let o1 : ℤ := Int.ofNat (List.length pat) - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (1 : ℤ)) ∧ ((0 : ℤ) = (1 : ℤ) → (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < (0 : ℤ)) ∧ (0 : ℤ) ≤ m + (0 : ℤ) ∧ eq_array pat (0 : ℤ) a (0 : ℤ) (0 : ℤ)) ∧ (∀(ignored : ℤ) (shift : ℤ), (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ ((0 : ℤ) ≤ shift ∧ shift ≤ (1 : ℤ)) ∧ (shift = (1 : ℤ) → (0 : ℤ) ≤ ignored ∧ ignored < i) ∧ i ≤ m + shift ∧ (if shift = (0 : ℤ) then eq_array pat (0 : ℤ) a (0 : ℤ) i else eq_array pat (0 : ℤ) a (0 : ℤ) ignored ∧ eq_array pat (ignored + (1 : ℤ)) a ignored (i - ignored - (1 : ℤ)) ∧ ¬eq_array pat (0 : ℤ) a (0 : ℤ) i ∧ (ignored < m → ¬pat[Int.toNat ignored]! = a[Int.toNat ignored]!)) → (let o2 : ℤ := i - shift; (¬m ≤ o2 → (let o3 : ℤ := i - shift; ((0 : ℤ) ≤ o3 ∧ o3 < Int.ofNat (List.length a)) ∧ (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length pat))) ∧ (∀(o3 : Bool), (if m ≤ o2 then o3 = true else o3 = (if pat[Int.toNat i]! = a[Int.toNat (i - shift)]! then false else true)) → (if o3 = true then if shift = (1 : ℤ) then ¬is_relaxed_prefix pat a else ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ (1 : ℤ)) ∧ ((0 : ℤ) ≤ i ∧ i < i + (1 : ℤ)) ∧ i + (1 : ℤ) ≤ m + (1 : ℤ) ∧ (if (1 : ℤ) = (0 : ℤ) then eq_array pat (0 : ℤ) a (0 : ℤ) (i + (1 : ℤ)) else eq_array pat (0 : ℤ) a (0 : ℤ) i ∧ eq_array pat (i + (1 : ℤ)) a i (i + (1 : ℤ) - i - (1 : ℤ)) ∧ ¬eq_array pat (0 : ℤ) a (0 : ℤ) (i + (1 : ℤ)) ∧ (i < m → ¬pat[Int.toNat i]! = a[Int.toNat i]!)) else ((0 : ℤ) ≤ shift ∧ shift ≤ (1 : ℤ)) ∧ (shift = (1 : ℤ) → (0 : ℤ) ≤ ignored ∧ ignored < i + (1 : ℤ)) ∧ i + (1 : ℤ) ≤ m + shift ∧ (if shift = (0 : ℤ) then eq_array pat (0 : ℤ) a (0 : ℤ) (i + (1 : ℤ)) else eq_array pat (0 : ℤ) a (0 : ℤ) ignored ∧ eq_array pat (ignored + (1 : ℤ)) a ignored (i + (1 : ℤ) - ignored - (1 : ℤ)) ∧ ¬eq_array pat (0 : ℤ) a (0 : ℤ) (i + (1 : ℤ)) ∧ (ignored < m → ¬pat[Int.toNat ignored]! = a[Int.toNat ignored]!)))))) ∧ (((0 : ℤ) ≤ shift ∧ shift ≤ (1 : ℤ)) ∧ (shift = (1 : ℤ) → (0 : ℤ) ≤ ignored ∧ ignored < o1 + (1 : ℤ)) ∧ o1 + (1 : ℤ) ≤ m + shift ∧ (if shift = (0 : ℤ) then eq_array pat (0 : ℤ) a (0 : ℤ) (o1 + (1 : ℤ)) else eq_array pat (0 : ℤ) a (0 : ℤ) ignored ∧ eq_array pat (ignored + (1 : ℤ)) a ignored (o1 + (1 : ℤ) - ignored - (1 : ℤ)) ∧ ¬eq_array pat (0 : ℤ) a (0 : ℤ) (o1 + (1 : ℤ)) ∧ (ignored < m → ¬pat[Int.toNat ignored]! = a[Int.toNat ignored]!)) → is_relaxed_prefix pat a))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → is_relaxed_prefix pat a)
  := sorry
end verifythis_2015_relaxed_prefix_RelaxedPrefix_is_relaxed_prefixqtvc
