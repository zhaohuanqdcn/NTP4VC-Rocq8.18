import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.ptralias.Alias
open Classical
open Lean4Why3
namespace util_Util_wmpn_copyd_sepqtvc
theorem wmpn_copyd_sep'vc (up : C.ptr (BitVec 64)) (n : BitVec 32) (rp : C.ptr (BitVec 64)) (fact0 : C.valid up (BitVec.toInt n)) (fact1 : C.valid rp (BitVec.toInt n)) (fact2 : C.writable rp = true) : C.valid rp (BitVec.toInt n) ∧ C.valid up (BitVec.toInt n) ∧ (0 : ℤ) ≤ BitVec.toInt n ∧ C.writable rp = true ∧ (∀(up1 : C.ptr (BitVec 64)) (rp1 : C.ptr (BitVec 64)), C.offset up1 = C.offset up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → C.offset rp1 = C.offset rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(nr : C.ptr (BitVec 64)) (nx : C.ptr (BitVec 64)) (m : Alias.mem), C.writable nr = true ∧ Lemmas.value nx (BitVec.toInt n) = Lemmas.value up (BitVec.toInt n) ∧ (C.valid nr (BitVec.toInt n) ∧ C.valid nx (BitVec.toInt n)) ∧ ((0 : ℤ) ≤ C.offset nx ∧ C.offset nx + BitVec.toInt n ≤ C.offset nr) ∧ (Alias.zr m = C.zone1 rp1 ∧ Alias.zx m = C.zone1 up1) ∧ (BitVec.toInt (Alias.mr m) = C.max rp ∧ BitVec.toInt (Alias.mx m) = C.max up) ∧ (Alias.lr m = Alias.lx m ∧ Alias.lx m = n) ∧ Alias.ok m = true ∧ Lemmas.map_eq_sub_shift (C.pelts nx) (C.pelts up1) (C.offset nx) (C.offset up1) (BitVec.toInt n) ∧ Lemmas.map_eq_sub_shift (C.pelts nr) (C.pelts rp1) (C.offset nr) (C.offset rp1) (BitVec.toInt n) ∧ (C.pelts rp1 = C.pelts rp ∧ C.pelts up1 = C.pelts up) ∧ (C.plength rp1 = C.plength rp ∧ C.plength up1 = C.plength up) ∧ (C.min rp1 = C.min rp ∧ C.min up1 = C.min up) ∧ C.data nr = C.data nx → (C.valid nx (BitVec.toInt n) ∧ C.valid nr (BitVec.toInt n) ∧ C.writable nr = true ∧ (C.offset nx ≤ C.offset nr ∨ C.offset nr + BitVec.toInt n ≤ C.offset nx)) ∧ (∀(nx1 : C.ptr (BitVec 64)) (nr1 : C.ptr (BitVec 64)), C.data nx1 = C.data nr1 ∧ List.length (C.data nr1) = List.length (C.data nx) ∧ C.offset nx1 = C.offset nx ∧ C.min nx1 = C.min nx ∧ C.max nx1 = C.max nx ∧ C.writable nx1 = C.writable nx ∧ C.zone1 nx1 = C.zone1 nx → List.length (C.data nr1) = List.length (C.data nr) ∧ C.offset nr1 = C.offset nr ∧ C.min nr1 = C.min nr ∧ C.max nr1 = C.max nr ∧ C.writable nr1 = C.writable nr ∧ C.zone1 nr1 = C.zone1 nr → Lemmas.map_eq_sub_shift (C.pelts nr1) (C.pelts nx) (C.offset nr1) (C.offset nx1) (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset nr1 ∨ C.offset nr1 + BitVec.toInt n ≤ j → C.pelts nr1 j = C.pelts nr j) → ((C.writable rp1 = true ∧ C.writable nr1 = true) ∧ Alias.ok m = true ∧ (0 : ℤ) ≤ BitVec.toInt n ∧ ((0 : ℤ) ≤ C.offset nx1 ∧ C.offset nx1 + BitVec.toInt n ≤ C.offset nr1) ∧ (Alias.zx m = C.zone1 up1 ∧ Alias.zr m = C.zone1 rp1) ∧ Alias.lx m = Alias.lr m ∧ Alias.lr m = n) ∧ (∀(m1 : Alias.mem) (nx2 : C.ptr (BitVec 64)) (nr2 : C.ptr (BitVec 64)) (up2 : C.ptr (BitVec 64)) (rp2 : C.ptr (BitVec 64)), Alias.zr m1 = Alias.zr m ∧ Alias.zx m1 = Alias.zx m ∧ Alias.zy m1 = Alias.zy m ∧ Alias.mr m1 = Alias.mr m ∧ Alias.mx m1 = Alias.mx m ∧ Alias.my m1 = Alias.my m ∧ Alias.lr m1 = Alias.lr m ∧ Alias.lx m1 = Alias.lx m ∧ Alias.ly m1 = Alias.ly m → C.offset nx2 = C.offset nx1 ∧ C.writable nx2 = C.writable nx1 ∧ C.zone1 nx2 = C.zone1 nx1 → C.offset nr2 = C.offset nr1 ∧ C.writable nr2 = C.writable nr1 ∧ C.zone1 nr2 = C.zone1 nr1 → C.offset up2 = C.offset up1 ∧ C.min up2 = C.min up1 ∧ C.writable up2 = C.writable up1 ∧ C.zone1 up2 = C.zone1 up1 → C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → (C.max up2 = BitVec.toInt (Alias.mx m1) ∧ C.max rp2 = BitVec.toInt (Alias.mr m1)) ∧ Lemmas.map_eq_sub_shift (C.pelts nx1) (C.pelts up2) (C.offset nx2) (C.offset up2) (BitVec.toInt n) ∧ Lemmas.map_eq_sub_shift (C.pelts nr1) (C.pelts rp2) (C.offset nr2) (C.offset rp2) (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset up2 ∨ C.offset up2 + BitVec.toInt n ≤ j → C.pelts up2 j = C.pelts up1 j) ∧ (∀(j : ℤ), j < C.offset rp2 ∨ C.offset rp2 + BitVec.toInt n ≤ j → C.pelts rp2 j = C.pelts rp1 j) ∧ (C.plength up2 = C.plength up1 ∧ C.plength rp2 = C.plength rp1) ∧ C.min rp2 = C.min rp1 ∧ C.min up2 = C.min up1 → Lemmas.map_eq_sub_shift (C.pelts rp2) (C.pelts up) (C.offset rp2) (C.offset up) (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset rp2 ∨ C.offset rp2 + BitVec.toInt n ≤ j → C.pelts rp2 j = C.pelts rp j) ∧ (∀(j : ℤ), C.pelts up2 j = C.pelts up j) ∧ (C.min up2 = C.min up ∧ C.max up2 = C.max up ∧ C.plength up2 = C.plength up) ∧ C.min rp2 = C.min rp ∧ C.max rp2 = C.max rp ∧ C.plength rp2 = C.plength rp))))
  := sorry
end util_Util_wmpn_copyd_sepqtvc
