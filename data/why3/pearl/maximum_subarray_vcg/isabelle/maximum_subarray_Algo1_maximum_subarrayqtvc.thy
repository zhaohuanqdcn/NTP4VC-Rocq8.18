theory maximum_subarray_Algo1_maximum_subarrayqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_Sum" "./maximum_subarray_Spec"
begin
theorem maximum_subarray'vc:
  fixes a :: "int list"
  shows "let n :: int = int (length a); o1 :: int = n - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (0 :: int)) \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> n) \<and> (0 :: int) = sum_list (drop (0 :: nat) (take ((0 :: nat) - (0 :: nat)) a))) \<and> maxsublo a (0 :: int) (0 :: int)) \<and> (\<forall>(ms :: int) (hi :: int) (lo :: int). (\<forall>(l :: int). ((0 :: int) \<le> l \<and> l \<le> o1) \<and> (((0 :: int) \<le> lo \<and> lo \<le> l) \<and> (lo \<le> hi \<and> hi \<le> n) \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> maxsublo a l ms \<longrightarrow> (l \<le> n + (1 :: int) \<longrightarrow> ((((0 :: int) \<le> lo \<and> lo \<le> l) \<and> (lo \<le> hi \<and> hi \<le> n) \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> maxsublo a l ms \<and> (\<forall>(h' :: int). l \<le> h' \<and> h' < l \<longrightarrow> sum_list (drop (nat l) (take (nat h' - nat l) a)) \<le> ms)) \<and> (\<forall>(ms1 :: int) (hi1 :: int) (lo1 :: int). (\<forall>(h :: int). (l \<le> h \<and> h \<le> n) \<and> (((0 :: int) \<le> lo1 \<and> lo1 \<le> l) \<and> (lo1 \<le> hi1 \<and> hi1 \<le> n) \<and> ms1 = sum_list (drop (nat lo1) (take (nat hi1 - nat lo1) a))) \<and> maxsublo a l ms1 \<and> (\<forall>(h' :: int). l \<le> h' \<and> h' < h \<longrightarrow> sum_list (drop (nat l) (take (nat h' - nat l) a)) \<le> ms1) \<longrightarrow> (let o2 :: int = h - (1 :: int) in (l \<le> o2 + (1 :: int) \<longrightarrow> ((0 :: int) = sum_list (drop (nat l) (take (nat l - nat l) a)) \<and> ((0 :: int) \<le> lo1 \<and> lo1 \<le> l) \<and> (lo1 \<le> hi1 \<and> hi1 \<le> n) \<and> ms1 = sum_list (drop (nat lo1) (take (nat hi1 - nat lo1) a))) \<and> (\<forall>(s :: int). (\<forall>(i :: int). (l \<le> i \<and> i \<le> o2) \<and> s = sum_list (drop (nat l) (take (nat i - nat l) a)) \<and> ((0 :: int) \<le> lo1 \<and> lo1 \<le> l) \<and> (lo1 \<le> hi1 \<and> hi1 \<le> n) \<and> ms1 = sum_list (drop (nat lo1) (take (nat hi1 - nat lo1) a)) \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> s + a ! nat i = sum_list (drop (nat l) (take (nat (i + (1 :: int)) - nat l) a)) \<and> ((0 :: int) \<le> lo1 \<and> lo1 \<le> l) \<and> (lo1 \<le> hi1 \<and> hi1 \<le> n) \<and> ms1 = sum_list (drop (nat lo1) (take (nat hi1 - nat lo1) a))) \<and> (s = sum_list (drop (nat l) (take (nat (o2 + (1 :: int)) - nat l) a)) \<and> ((0 :: int) \<le> lo1 \<and> lo1 \<le> l) \<and> (lo1 \<le> hi1 \<and> hi1 \<le> n) \<and> ms1 = sum_list (drop (nat lo1) (take (nat hi1 - nat lo1) a)) \<longrightarrow> (if ms1 < s then (((0 :: int) \<le> l \<and> l \<le> l) \<and> (l \<le> h \<and> h \<le> n) \<and> s = sum_list (drop (nat l) (take (nat h - nat l) a))) \<and> maxsublo a l s \<and> (\<forall>(h' :: int). l \<le> h' \<and> h' < h + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h' - nat l) a)) \<le> s) else (((0 :: int) \<le> lo1 \<and> lo1 \<le> l) \<and> (lo1 \<le> hi1 \<and> hi1 \<le> n) \<and> ms1 = sum_list (drop (nat lo1) (take (nat hi1 - nat lo1) a))) \<and> maxsublo a l ms1 \<and> (\<forall>(h' :: int). l \<le> h' \<and> h' < h + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h' - nat l) a)) \<le> ms1))))) \<and> (o2 + (1 :: int) < l \<longrightarrow> (if ms1 < (0 :: int) then (((0 :: int) \<le> l \<and> l \<le> l) \<and> (l \<le> h \<and> h \<le> n) \<and> (0 :: int) = sum_list (drop (nat l) (take (nat h - nat l) a))) \<and> maxsublo a l (0 :: int) \<and> (\<forall>(h' :: int). l \<le> h' \<and> h' < h + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h' - nat l) a)) \<le> (0 :: int)) else (((0 :: int) \<le> lo1 \<and> lo1 \<le> l) \<and> (lo1 \<le> hi1 \<and> hi1 \<le> n) \<and> ms1 = sum_list (drop (nat lo1) (take (nat hi1 - nat lo1) a))) \<and> maxsublo a l ms1 \<and> (\<forall>(h' :: int). l \<le> h' \<and> h' < h + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h' - nat l) a)) \<le> ms1))))) \<and> ((((0 :: int) \<le> lo1 \<and> lo1 \<le> l) \<and> (lo1 \<le> hi1 \<and> hi1 \<le> n) \<and> ms1 = sum_list (drop (nat lo1) (take (nat hi1 - nat lo1) a))) \<and> maxsublo a l ms1 \<and> (\<forall>(h' :: int). l \<le> h' \<and> h' < n + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h' - nat l) a)) \<le> ms1) \<longrightarrow> (((0 :: int) \<le> lo1 \<and> lo1 \<le> l + (1 :: int)) \<and> (lo1 \<le> hi1 \<and> hi1 \<le> n) \<and> ms1 = sum_list (drop (nat lo1) (take (nat hi1 - nat lo1) a))) \<and> maxsublo a (l + (1 :: int)) ms1))) \<and> (n + (1 :: int) < l \<longrightarrow> (((0 :: int) \<le> lo \<and> lo \<le> l + (1 :: int)) \<and> (lo \<le> hi \<and> hi \<le> n) \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> maxsublo a (l + (1 :: int)) ms)) \<and> ((((0 :: int) \<le> lo \<and> lo \<le> o1 + (1 :: int)) \<and> (lo \<le> hi \<and> hi \<le> n) \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> maxsublo a (o1 + (1 :: int)) ms \<longrightarrow> (((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> int (length a)) \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> maxsub a ms))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> int (length a)) \<and> (0 :: int) = sum_list (drop (0 :: nat) (take ((0 :: nat) - (0 :: nat)) a))) \<and> maxsub a (0 :: int))"
  sorry
end
