import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
open Classical
open Lean4Why3
namespace ccursor_PtrCursor_nextqtvc
axiom cursor : Type
axiom inhabited_axiom_cursor : Inhabited cursor
attribute [instance] inhabited_axiom_cursor
axiom current : cursor -> C.ptr (BitVec 32)
axiom new : cursor -> Bool
axiom len : cursor -> BitVec 32
axiom freed : cursor -> Bool
axiom bound : cursor -> BitVec 32
axiom cursor'invariant (self : cursor) : (0 : ℤ) < BitVec.toInt (len self) ∧ (¬freed self = true → C.plength (current self) = BitVec.toInt (len self) ∧ C.offset (current self) = (0 : ℤ) ∧ C.valid (current self) (BitVec.toInt (len self)) ∧ C.min (current self) = (0 : ℤ) ∧ C.max (current self) = BitVec.toInt (len self) ∧ C.is_not_null (current self) ∧ C.writable (current self) = true ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt (len self) → BitVec.toInt ((C.data (current self))[Int.toNat i]!) < BitVec.toInt (bound self)))
noncomputable def cursor'eq (a : cursor) (b : cursor) := current a = current b ∧ new a = new b ∧ len a = len b ∧ freed a = freed b ∧ bound a = bound b
axiom cursor'inj (a : cursor) (b : cursor) (fact0 : cursor'eq a b) : a = b
theorem next'vc (c : cursor) (fact0 : ¬freed c = true) (fact1 : (0 : ℤ) < BitVec.toInt (bound c)) (fact2 : BitVec.toInt (bound c) < (2147483647 : ℤ)) : ¬freed c = true ∧ (∀(a : List (BitVec 32)), Int.ofNat (List.length a) = C.plength (current c) ∧ MapEq.map_eq_sub (getElem! a ∘ Int.toNat) (C.pelts (current c)) (0 : ℤ) (BitVec.toInt (len c)) → (let n : BitVec 32 := len c; let b : BitVec 32 := bound c; int'32_in_bounds (BitVec.toInt n - (1 : ℤ)) ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = BitVec.toInt n - (1 : ℤ) → ((-(1 : ℤ) ≤ BitVec.toInt o1 ∧ BitVec.toInt o1 < BitVec.toInt n) ∧ (∀(s : ℤ), BitVec.toInt o1 < s ∧ s < BitVec.toInt (len c) → BitVec.toInt (a[Int.toNat s]!) = BitVec.toInt b - (1 : ℤ))) ∧ (∀(r : BitVec 32), (-(1 : ℤ) ≤ BitVec.toInt r ∧ BitVec.toInt r < BitVec.toInt n) ∧ (∀(s : ℤ), BitVec.toInt r < s ∧ s < BitVec.toInt (len c) → BitVec.toInt (a[Int.toNat s]!) = BitVec.toInt b - (1 : ℤ)) → ((0 : ℤ) ≤ BitVec.toInt r → int'32_in_bounds (BitVec.toInt b - (1 : ℤ)) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toInt b - (1 : ℤ) → (0 : ℤ) ≤ BitVec.toInt r ∧ BitVec.toInt r < Int.ofNat (List.length a))) ∧ (∀(o2 : Bool), (if (0 : ℤ) ≤ BitVec.toInt r then ∃(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt b - (1 : ℤ) ∧ (let o4 : BitVec 32 := a[Int.toNat (BitVec.toInt r)]!; o2 = (if o4 = o3 then true else false) ∧ (BitVec.toInt o4 = BitVec.toInt o3 → o2 = true)) else o2 = false) → (if o2 = true then int'32_in_bounds (BitVec.toInt r - (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt r - (1 : ℤ) → BitVec.toInt o3 < BitVec.toInt r ∧ (-(1 : ℤ) ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 < BitVec.toInt n) ∧ (∀(s : ℤ), BitVec.toInt o3 < s ∧ s < BitVec.toInt (len c) → BitVec.toInt (a[Int.toNat s]!) = BitVec.toInt b - (1 : ℤ))) else if BitVec.toInt r < (0 : ℤ) then (0 : ℤ) < BitVec.toInt (len c) ∧ (¬freed c = true → C.plength (current c) = BitVec.toInt (len c) ∧ C.offset (current c) = (0 : ℤ) ∧ C.valid (current c) (BitVec.toInt (len c)) ∧ C.min (current c) = (0 : ℤ) ∧ C.max (current c) = BitVec.toInt (len c) ∧ C.is_not_null (current c) ∧ C.writable (current c) = true ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt (len c) → BitVec.toInt ((C.data (current c))[Int.toNat i]!) < BitVec.toInt (bound c))) else ((0 : ℤ) ≤ BitVec.toInt r ∧ BitVec.toInt r < Int.ofNat (List.length a)) ∧ (let o3 : BitVec 32 := a[Int.toNat (BitVec.toInt r)]!; int'32_in_bounds (BitVec.toInt o3 + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt o3 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt r ∧ BitVec.toInt r < Int.ofNat (List.length a)) ∧ (∀(c_current : C.ptr (BitVec 32)), List.length (C.data c_current) = List.length a → List.length (C.data c_current) = List.length (C.data (current c)) ∧ C.offset c_current = C.offset (current c) ∧ C.min c_current = C.min (current c) ∧ C.max c_current = C.max (current c) ∧ C.writable c_current = C.writable (current c) ∧ C.zone1 c_current = C.zone1 (current c) → getElem! (C.data c_current) ∘ Int.toNat = Function.update (getElem! a ∘ Int.toNat) (BitVec.toInt r) o4 ∧ C.data c_current = List.set a (Int.toNat (BitVec.toInt r)) o4 → int'32_in_bounds (BitVec.toInt n - (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt n - (1 : ℤ) → int'32_in_bounds (BitVec.toInt r + (1 : ℤ)) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt r + (1 : ℤ) → (BitVec.toInt o6 ≤ BitVec.toInt o5 + (1 : ℤ) → ((∀(j : ℤ), BitVec.toInt r + (1 : ℤ) ≤ j ∧ j < BitVec.toInt o6 → BitVec.toInt ((C.data c_current)[Int.toNat j]!) = (0 : ℤ)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toInt r → (C.data c_current)[Int.toNat j]! = a[Int.toNat j]!) ∧ BitVec.toInt ((C.data c_current)[Int.toNat (BitVec.toInt r)]!) = BitVec.toInt (a[Int.toNat (BitVec.toInt r)]!) + (1 : ℤ)) ∧ (∀(c_current1 : C.ptr (BitVec 32)), List.length (C.data c_current1) = List.length (C.data c_current) → List.length (C.data c_current1) = List.length (C.data c_current) ∧ C.offset c_current1 = C.offset c_current ∧ C.min c_current1 = C.min c_current ∧ C.max c_current1 = C.max c_current ∧ C.writable c_current1 = C.writable c_current ∧ C.zone1 c_current1 = C.zone1 c_current → (∀(i : BitVec 32), let i1 : ℤ := BitVec.toInt i; (BitVec.toInt o6 ≤ i1 ∧ i1 ≤ BitVec.toInt o5) ∧ (∀(j : ℤ), BitVec.toInt r + (1 : ℤ) ≤ j ∧ j < i1 → BitVec.toInt ((C.data c_current1)[Int.toNat j]!) = (0 : ℤ)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toInt r → (C.data c_current1)[Int.toNat j]! = a[Int.toNat j]!) ∧ BitVec.toInt ((C.data c_current1)[Int.toNat (BitVec.toInt r)]!) = BitVec.toInt (a[Int.toNat (BitVec.toInt r)]!) + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i < Int.ofNat (List.length (C.data c_current1))) ∧ (List.length (List.set (C.data c_current1) (Int.toNat (BitVec.toInt i)) (0 : BitVec 32)) = List.length (C.data c_current1) → getElem! (List.set (C.data c_current1) (Int.toNat (BitVec.toInt i)) (0 : BitVec 32)) ∘ Int.toNat = Function.update (getElem! (C.data c_current1) ∘ Int.toNat) (BitVec.toInt i) (0 : BitVec 32) → (∀(j : ℤ), BitVec.toInt r + (1 : ℤ) ≤ j ∧ j < i1 + (1 : ℤ) → BitVec.toInt ((List.set (C.data c_current1) (Int.toNat (BitVec.toInt i)) (0 : BitVec 32))[Int.toNat j]!) = (0 : ℤ)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toInt r → (List.set (C.data c_current1) (Int.toNat (BitVec.toInt i)) (0 : BitVec 32))[Int.toNat j]! = a[Int.toNat j]!) ∧ BitVec.toInt ((List.set (C.data c_current1) (Int.toNat (BitVec.toInt i)) (0 : BitVec 32))[Int.toNat (BitVec.toInt r)]!) = BitVec.toInt (a[Int.toNat (BitVec.toInt r)]!) + (1 : ℤ))) ∧ ((∀(j : ℤ), BitVec.toInt r + (1 : ℤ) ≤ j ∧ j < BitVec.toInt o5 + (1 : ℤ) → BitVec.toInt ((C.data c_current1)[Int.toNat j]!) = (0 : ℤ)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toInt r → (C.data c_current1)[Int.toNat j]! = a[Int.toNat j]!) ∧ BitVec.toInt ((C.data c_current1)[Int.toNat (BitVec.toInt r)]!) = BitVec.toInt (a[Int.toNat (BitVec.toInt r)]!) + (1 : ℤ) → (0 : ℤ) < BitVec.toInt (len c) ∧ (¬freed c = true → C.plength c_current1 = BitVec.toInt (len c) ∧ C.offset c_current1 = (0 : ℤ) ∧ C.valid c_current1 (BitVec.toInt (len c)) ∧ C.min c_current1 = (0 : ℤ) ∧ C.max c_current1 = BitVec.toInt (len c) ∧ C.is_not_null c_current1 ∧ C.writable c_current1 = true ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt (len c) → BitVec.toInt ((C.data c_current1)[Int.toNat i]!) < BitVec.toInt (bound c)))))) ∧ (BitVec.toInt o5 + (1 : ℤ) < BitVec.toInt o6 → (0 : ℤ) < BitVec.toInt (len c) ∧ (¬freed c = true → C.plength c_current = BitVec.toInt (len c) ∧ C.offset c_current = (0 : ℤ) ∧ C.valid c_current (BitVec.toInt (len c)) ∧ C.min c_current = (0 : ℤ) ∧ C.max c_current = BitVec.toInt (len c) ∧ C.is_not_null c_current ∧ C.writable c_current = true ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt (len c) → BitVec.toInt ((C.data c_current)[Int.toNat i]!) < BitVec.toInt (bound c)))))))))))))))
  := sorry
end ccursor_PtrCursor_nextqtvc
