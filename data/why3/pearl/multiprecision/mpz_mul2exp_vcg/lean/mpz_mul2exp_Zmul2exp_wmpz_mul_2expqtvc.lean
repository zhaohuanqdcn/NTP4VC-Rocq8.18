import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.mpz.Z
import pearl.multiprecision.lib.lean.mpz.Zutil
open Classical
open Lean4Why3
namespace mpz_mul2exp_Zmul2exp_wmpz_mul_2expqtvc
theorem wmpz_mul_2exp'vc (mpz : Z.mpz_memo) (r : Z.mpz_ptr) (u : Z.mpz_ptr) (cnt : BitVec 64) (fact0 : (1 : ℤ) ≤ Z.alloc mpz r) (fact1 : (1 : ℤ) ≤ Z.alloc mpz u) (fact2 : Z.readers mpz r = (0 : ℤ)) (fact3 : Z.readers mpz u = (0 : ℤ)) (fact4 : Z.abs_size mpz u + BitVec.toUInt cnt / (64 : ℤ) + (1 : ℤ) ≤ (2147483647 : ℤ)) : -(2 : ℤ) < Z.readers mpz u ∧ (∀(un : BitVec 32), BitVec.toInt un = Z.abs_size mpz u → (¬(64 : ℤ) = (0 : ℤ) ∧ uint'64_in_bounds (Int.tdiv (BitVec.toUInt cnt) (64 : ℤ))) ∧ (∀(o1 : BitVec 64), BitVec.toUInt o1 = Int.tdiv (BitVec.toUInt cnt) (64 : ℤ) → BitVec.toUInt o1 ≤ (2147483647 : ℤ) ∧ (∀(limb_cnt : BitVec 32), BitVec.toInt limb_cnt = BitVec.toUInt o1 → int'32_in_bounds (BitVec.toInt un + BitVec.toInt limb_cnt) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toInt un + BitVec.toInt limb_cnt → (∀(o3 : Bool), (BitVec.toInt un = BitVec.toInt (0 : BitVec 32) → o3 = true) ∧ (o3 = true → un = (0 : BitVec 32)) → (if o3 = true then (-(1 : ℤ) ≤ Z.readers mpz r ∧ Z.readers mpz r ≤ (0 : ℤ)) ∧ (∀(mpz1 : Z.mpz_memo), Z.alloc mpz1 = Z.alloc mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.readers mpz1 = Z.readers mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz1 mpz) ∧ Z.abs_size mpz1 r = (0 : ℤ) ∧ Z.abs_value_of mpz1 r = (0 : ℤ) → Z.value_of r mpz1 = Z.value_of u mpz * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) ∧ (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz1 mpz) ∧ Z.readers mpz1 r = (0 : ℤ) ∧ Z.readers mpz1 u = (0 : ℤ)) else int'32_in_bounds (BitVec.toInt o2 + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt o2 + (1 : ℤ) → (Z.readers mpz r = (0 : ℤ) ∧ (1 : ℤ) ≤ Z.alloc mpz r) ∧ (∀(mpz1 : Z.mpz_memo), Z.sgn mpz1 = Z.sgn mpz → (∀(rp : C.ptr (BitVec 64)), (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz1 mpz) ∧ Z.readers mpz1 r = -(1 : ℤ) ∧ Z.abs_value_of mpz1 r = Lemmas.value rp (Z.abs_size mpz1 r) ∧ Z.zones mpz1 r = C.zone1 rp ∧ C.offset rp = (0 : ℤ) ∧ C.plength rp = Z.alloc mpz1 r ∧ C.min rp = (0 : ℤ) ∧ C.max rp = C.plength rp ∧ C.writable rp = true ∧ Z.abs_size mpz1 r = Z.abs_size mpz r ∧ Lemmas.value rp (Z.abs_size mpz r) = Z.abs_value_of mpz r ∧ (if Z.alloc mpz r < BitVec.toInt o4 then Z.alloc mpz1 r = BitVec.toInt o4 else Z.alloc mpz1 r = Z.alloc mpz r) → (¬(64 : ℤ) = (0 : ℤ) ∧ uint'64_in_bounds (Int.tmod (BitVec.toUInt cnt) (64 : ℤ))) ∧ (∀(c : BitVec 64), BitVec.toUInt c = Int.tmod (BitVec.toUInt cnt) (64 : ℤ) → Z.mpz_eq u r = (u = r) → (if Z.mpz_eq u r then ∀(o5 : Bool), (BitVec.toUInt c = BitVec.toUInt (0 : BitVec 64) → o5 = true) ∧ (o5 = true → c = (0 : BitVec 64)) → (if ¬o5 = true then (C.min rp ≤ C.offset rp + BitVec.toInt limb_cnt ∧ C.offset rp + BitVec.toInt limb_cnt ≤ C.max rp) ∧ (∀(rl : C.ptr (BitVec 64)), C.offset rl = C.offset rp + BitVec.toInt limb_cnt ∧ C.plength rl = C.plength rp ∧ C.pelts rl = C.pelts rp ∧ C.data rl = C.data rp ∧ C.min rl = C.min rp ∧ C.max rl = C.max rp ∧ C.zone1 rl = C.zone1 rp ∧ C.writable rl = C.writable rp → (((0 : ℤ) < BitVec.toUInt c ∧ BitVec.toUInt c < (64 : ℤ)) ∧ C.valid rl (BitVec.toInt un) ∧ C.valid rp (BitVec.toInt un) ∧ C.writable rl = true ∧ (0 : ℤ) < BitVec.toInt un ∧ (C.offset rp ≤ C.offset rl ∨ C.offset rl + BitVec.toInt un ≤ C.offset rp)) ∧ (∀(rl1 : C.ptr (BitVec 64)) (rp1 : C.ptr (BitVec 64)), C.data rl1 = C.data rp1 ∧ List.length (C.data rp1) = List.length (C.data rl) ∧ C.offset rl1 = C.offset rl ∧ C.min rl1 = C.min rl ∧ C.max rl1 = C.max rl ∧ C.writable rl1 = C.writable rl ∧ C.zone1 rl1 = C.zone1 rl → List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(rlimb : BitVec 64), Lemmas.value rl1 (BitVec.toInt un) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt un)) * BitVec.toUInt rlimb = Lemmas.value rp (BitVec.toInt un) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt c)) ∧ (∀(j : ℤ), j < C.offset rl1 ∨ C.offset rl1 + BitVec.toInt un ≤ j → C.pelts rl1 j = C.pelts rl j) ∧ (C.min rl1 = C.min rl ∧ C.max rl1 = C.max rl ∧ C.plength rl1 = C.plength rl) ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.plength rp1 = C.plength rp → ((C.min rp1 ≤ C.offset rp1 + BitVec.toInt o2 ∧ C.offset rp1 + BitVec.toInt o2 < C.max rp1) ∧ C.writable rp1 = true) ∧ (∀(rp2 : C.ptr (BitVec 64)), List.length (C.data rp2) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → C.pelts rp2 = Function.update (C.pelts rp1) (C.offset rp2 + BitVec.toInt o2) rlimb ∧ C.pelts rp2 (C.offset rp2 + BitVec.toInt o2) = rlimb → (∀(o6 : Bool), (BitVec.toUInt rlimb = BitVec.toUInt (0 : BitVec 64) → o6 = true) ∧ (o6 = true → rlimb = (0 : BitVec 64)) → (∀(o7 : BitVec 32), (if ¬o6 = true then o7 = (1 : BitVec 32) else o7 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt o2 + BitVec.toInt o7) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt o2 + BitVec.toInt o7 → (C.valid rp2 (BitVec.toInt limb_cnt) ∧ C.writable rp2 = true) ∧ (∀(rp3 : C.ptr (BitVec 64)), List.length (C.data rp3) = List.length (C.data rp2) ∧ C.offset rp3 = C.offset rp2 ∧ C.min rp3 = C.min rp2 ∧ C.max rp3 = C.max rp2 ∧ C.writable rp3 = C.writable rp2 ∧ C.zone1 rp3 = C.zone1 rp2 → Lemmas.value rp3 (BitVec.toInt limb_cnt) = (0 : ℤ) ∧ (∀(j : ℤ), j < C.offset rp3 ∨ C.offset rp3 + BitVec.toInt limb_cnt ≤ j → C.pelts rp3 j = C.pelts rp2 j) → -(2 : ℤ) < Z.readers mpz1 u ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = Z.sgn mpz1 u * Z.abs_size mpz1 u → (¬(0 : ℤ) ≤ BitVec.toInt o9 → int'32_in_bounds (-BitVec.toInt o8)) ∧ ((¬(0 : ℤ) ≤ BitVec.toInt o9 → (∃(nrn : BitVec 32), BitVec.toInt nrn = -BitVec.toInt o8)) → -(2 : ℤ) < Z.readers mpz1 u ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = Z.sgn mpz1 u * Z.abs_size mpz1 u → (¬(0 : ℤ) ≤ BitVec.toInt o10 → int'32_in_bounds (-BitVec.toInt o8)) ∧ (∀(o11 : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt o10 then o11 = o8 else BitVec.toInt o11 = -BitVec.toInt o8) → (Z.zones mpz1 r = C.zone1 rp3 ∧ Z.readers mpz1 r = -(1 : ℤ) ∧ C.offset rp3 = (0 : ℤ) ∧ C.min rp3 = (0 : ℤ) ∧ C.max rp3 = C.plength rp3 ∧ abs (BitVec.toInt o11) ≤ C.plength rp3 ∧ C.plength rp3 = Z.alloc mpz1 r ∧ (¬BitVec.toInt o11 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o11) - (1 : ℤ))) ≤ Lemmas.value rp3 (abs (BitVec.toInt o11)))) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz2 mpz1) ∧ (Z.sgn mpz2 r = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o11) ∧ (Z.sgn mpz2 r = -(1 : ℤ)) = (BitVec.toInt o11 < (0 : ℤ)) ∧ Z.abs_size mpz2 r = abs (BitVec.toInt o11) ∧ Z.abs_value_of mpz2 r = Lemmas.value rp3 (abs (BitVec.toInt o11)) → (Z.zones mpz2 r = C.zone1 rp3 ∧ Z.readers mpz2 r = -(1 : ℤ) ∧ C.min rp3 = (0 : ℤ) ∧ C.max rp3 = C.plength rp3 ∧ Z.abs_value_of mpz2 r = Lemmas.value rp3 (Z.abs_size mpz2 r)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 r = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = r → Z.readers mpz3 y = Z.readers mpz2 y) → Z.value_of r mpz3 = Z.value_of u mpz * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) ∧ (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz3 mpz) ∧ Z.readers mpz3 r = (0 : ℤ) ∧ Z.readers mpz3 u = (0 : ℤ))))))))))))))) else (C.valid rp (BitVec.toInt limb_cnt) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → Lemmas.value rp1 (BitVec.toInt limb_cnt) = (0 : ℤ) ∧ (∀(j : ℤ), j < C.offset rp1 ∨ C.offset rp1 + BitVec.toInt limb_cnt ≤ j → C.pelts rp1 j = C.pelts rp j) → -(2 : ℤ) < Z.readers mpz1 u ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = Z.sgn mpz1 u * Z.abs_size mpz1 u → (¬(0 : ℤ) ≤ BitVec.toInt o6 → int'32_in_bounds (-BitVec.toInt o2)) ∧ ((¬(0 : ℤ) ≤ BitVec.toInt o6 → (∃(nrn : BitVec 32), BitVec.toInt nrn = -BitVec.toInt o2)) → -(2 : ℤ) < Z.readers mpz1 u ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = Z.sgn mpz1 u * Z.abs_size mpz1 u → (¬(0 : ℤ) ≤ BitVec.toInt o7 → int'32_in_bounds (-BitVec.toInt o2)) ∧ (∀(o8 : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt o7 then o8 = o2 else BitVec.toInt o8 = -BitVec.toInt o2) → (Z.zones mpz1 r = C.zone1 rp1 ∧ Z.readers mpz1 r = -(1 : ℤ) ∧ C.offset rp1 = (0 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ abs (BitVec.toInt o8) ≤ C.plength rp1 ∧ C.plength rp1 = Z.alloc mpz1 r ∧ (¬BitVec.toInt o8 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o8) - (1 : ℤ))) ≤ Lemmas.value rp1 (abs (BitVec.toInt o8)))) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz2 mpz1) ∧ (Z.sgn mpz2 r = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o8) ∧ (Z.sgn mpz2 r = -(1 : ℤ)) = (BitVec.toInt o8 < (0 : ℤ)) ∧ Z.abs_size mpz2 r = abs (BitVec.toInt o8) ∧ Z.abs_value_of mpz2 r = Lemmas.value rp1 (abs (BitVec.toInt o8)) → (Z.zones mpz2 r = C.zone1 rp1 ∧ Z.readers mpz2 r = -(1 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ Z.abs_value_of mpz2 r = Lemmas.value rp1 (Z.abs_size mpz2 r)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 r = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = r → Z.readers mpz3 y = Z.readers mpz2 y) → Z.value_of r mpz3 = Z.value_of u mpz * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) ∧ (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz3 mpz) ∧ Z.readers mpz3 r = (0 : ℤ) ∧ Z.readers mpz3 u = (0 : ℤ))))))))) else Z.mpz_unchanged u mpz1 mpz ∧ (Z.readers mpz1 u = Z.readers mpz u ∧ (-(2 : ℤ) < Z.readers mpz1 u → Z.abs_value_of mpz1 u = Z.abs_value_of mpz u ∧ Z.alloc mpz1 u = Z.alloc mpz u ∧ Z.abs_size mpz1 u = Z.abs_size mpz u ∧ Z.sgn mpz1 u = Z.sgn mpz u ∧ Z.readers mpz1 u = Z.readers mpz u ∧ Z.zones mpz1 u = Z.zones mpz u) → (0 : ℤ) ≤ Z.readers mpz1 u ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(up : C.ptr (BitVec 64)), Z.readers mpz2 u = Z.readers mpz1 u + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬u = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value up (Z.abs_size mpz2 u) = Z.abs_value_of mpz2 u ∧ C.plength up = Z.alloc mpz2 u ∧ C.offset up = (0 : ℤ) ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up ∧ C.zone1 up = Z.zones mpz2 u → (∀(o5 : Bool), (BitVec.toUInt c = BitVec.toUInt (0 : BitVec 64) → o5 = true) ∧ (o5 = true → c = (0 : BitVec 64)) → (if ¬o5 = true then (C.min rp ≤ C.offset rp + BitVec.toInt limb_cnt ∧ C.offset rp + BitVec.toInt limb_cnt ≤ C.max rp) ∧ (∀(rl : C.ptr (BitVec 64)), C.offset rl = C.offset rp + BitVec.toInt limb_cnt ∧ C.plength rl = C.plength rp ∧ C.pelts rl = C.pelts rp ∧ C.data rl = C.data rp ∧ C.min rl = C.min rp ∧ C.max rl = C.max rp ∧ C.zone1 rl = C.zone1 rp ∧ C.writable rl = C.writable rp → (((0 : ℤ) < BitVec.toUInt c ∧ BitVec.toUInt c < (64 : ℤ)) ∧ C.valid rl (BitVec.toInt un) ∧ C.valid up (BitVec.toInt un) ∧ C.writable rl = true ∧ (0 : ℤ) < BitVec.toInt un) ∧ (∀(rl1 : C.ptr (BitVec 64)) (rp1 : C.ptr (BitVec 64)), C.data rl1 = C.data rp1 ∧ List.length (C.data rp1) = List.length (C.data rl) ∧ C.offset rl1 = C.offset rl ∧ C.min rl1 = C.min rl ∧ C.max rl1 = C.max rl ∧ C.writable rl1 = C.writable rl ∧ C.zone1 rl1 = C.zone1 rl → List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(rlimb : BitVec 64), Lemmas.value rl1 (BitVec.toInt un) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt un)) * BitVec.toUInt rlimb = Lemmas.value up (BitVec.toInt un) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt c)) → ((C.min rp1 ≤ C.offset rp1 + BitVec.toInt o2 ∧ C.offset rp1 + BitVec.toInt o2 < C.max rp1) ∧ C.writable rp1 = true) ∧ (∀(rp2 : C.ptr (BitVec 64)), List.length (C.data rp2) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → C.pelts rp2 = Function.update (C.pelts rp1) (C.offset rp2 + BitVec.toInt o2) rlimb ∧ C.pelts rp2 (C.offset rp2 + BitVec.toInt o2) = rlimb → (∀(o6 : Bool), (BitVec.toUInt rlimb = BitVec.toUInt (0 : BitVec 64) → o6 = true) ∧ (o6 = true → rlimb = (0 : BitVec 64)) → (∀(o7 : BitVec 32), (if ¬o6 = true then o7 = (1 : BitVec 32) else o7 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt o2 + BitVec.toInt o7) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt o2 + BitVec.toInt o7 → (Z.zones mpz2 u = C.zone1 up ∧ (1 : ℤ) ≤ Z.readers mpz2 u ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 u = Z.readers mpz2 u - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u → Z.readers mpz3 y = Z.readers mpz2 y) → (C.valid rp2 (BitVec.toInt limb_cnt) ∧ C.writable rp2 = true) ∧ (∀(rp3 : C.ptr (BitVec 64)), List.length (C.data rp3) = List.length (C.data rp2) ∧ C.offset rp3 = C.offset rp2 ∧ C.min rp3 = C.min rp2 ∧ C.max rp3 = C.max rp2 ∧ C.writable rp3 = C.writable rp2 ∧ C.zone1 rp3 = C.zone1 rp2 → Lemmas.value rp3 (BitVec.toInt limb_cnt) = (0 : ℤ) ∧ (∀(j : ℤ), j < C.offset rp3 ∨ C.offset rp3 + BitVec.toInt limb_cnt ≤ j → C.pelts rp3 j = C.pelts rp2 j) → -(2 : ℤ) < Z.readers mpz3 u ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = Z.sgn mpz3 u * Z.abs_size mpz3 u → (¬(0 : ℤ) ≤ BitVec.toInt o9 → int'32_in_bounds (-BitVec.toInt o8)) ∧ ((¬(0 : ℤ) ≤ BitVec.toInt o9 → (∃(nrn : BitVec 32), BitVec.toInt nrn = -BitVec.toInt o8)) → -(2 : ℤ) < Z.readers mpz3 u ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = Z.sgn mpz3 u * Z.abs_size mpz3 u → (¬(0 : ℤ) ≤ BitVec.toInt o10 → int'32_in_bounds (-BitVec.toInt o8)) ∧ (∀(o11 : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt o10 then o11 = o8 else BitVec.toInt o11 = -BitVec.toInt o8) → (Z.zones mpz3 r = C.zone1 rp3 ∧ Z.readers mpz3 r = -(1 : ℤ) ∧ C.offset rp3 = (0 : ℤ) ∧ C.min rp3 = (0 : ℤ) ∧ C.max rp3 = C.plength rp3 ∧ abs (BitVec.toInt o11) ≤ C.plength rp3 ∧ C.plength rp3 = Z.alloc mpz3 r ∧ (¬BitVec.toInt o11 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o11) - (1 : ℤ))) ≤ Lemmas.value rp3 (abs (BitVec.toInt o11)))) ∧ (∀(mpz4 : Z.mpz_memo), Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.readers mpz4 = Z.readers mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz4 mpz3) ∧ (Z.sgn mpz4 r = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o11) ∧ (Z.sgn mpz4 r = -(1 : ℤ)) = (BitVec.toInt o11 < (0 : ℤ)) ∧ Z.abs_size mpz4 r = abs (BitVec.toInt o11) ∧ Z.abs_value_of mpz4 r = Lemmas.value rp3 (abs (BitVec.toInt o11)) → (Z.zones mpz4 r = C.zone1 rp3 ∧ Z.readers mpz4 r = -(1 : ℤ) ∧ C.min rp3 = (0 : ℤ) ∧ C.max rp3 = C.plength rp3 ∧ Z.abs_value_of mpz4 r = Lemmas.value rp3 (Z.abs_size mpz4 r)) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 r = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = r → Z.readers mpz5 y = Z.readers mpz4 y) → Z.value_of r mpz5 = Z.value_of u mpz * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) ∧ (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz5 mpz) ∧ Z.readers mpz5 r = (0 : ℤ) ∧ Z.readers mpz5 u = (0 : ℤ)))))))))))))))) else (C.min rp ≤ C.offset rp + BitVec.toInt limb_cnt ∧ C.offset rp + BitVec.toInt limb_cnt ≤ C.max rp) ∧ (∀(rl : C.ptr (BitVec 64)), C.offset rl = C.offset rp + BitVec.toInt limb_cnt ∧ C.plength rl = C.plength rp ∧ C.pelts rl = C.pelts rp ∧ C.data rl = C.data rp ∧ C.min rl = C.min rp ∧ C.max rl = C.max rp ∧ C.zone1 rl = C.zone1 rp ∧ C.writable rl = C.writable rp → (C.valid up (BitVec.toInt un) ∧ C.valid rl (BitVec.toInt un) ∧ C.writable rl = true) ∧ (∀(rl1 : C.ptr (BitVec 64)) (rp1 : C.ptr (BitVec 64)), C.data rl1 = C.data rp1 ∧ List.length (C.data rp1) = List.length (C.data rl) ∧ C.offset rl1 = C.offset rl ∧ C.min rl1 = C.min rl ∧ C.max rl1 = C.max rl ∧ C.writable rl1 = C.writable rl ∧ C.zone1 rl1 = C.zone1 rl → List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → Lemmas.map_eq_sub_shift (C.pelts rl1) (C.pelts up) (C.offset rl1) (C.offset up) (BitVec.toInt un) ∧ (∀(j : ℤ), j < C.offset rl1 ∨ C.offset rl1 + BitVec.toInt un ≤ j → C.pelts rl1 j = C.pelts rl j) → (Z.zones mpz2 u = C.zone1 up ∧ (1 : ℤ) ≤ Z.readers mpz2 u ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 u = Z.readers mpz2 u - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u → Z.readers mpz3 y = Z.readers mpz2 y) → (C.valid rp1 (BitVec.toInt limb_cnt) ∧ C.writable rp1 = true) ∧ (∀(rp2 : C.ptr (BitVec 64)), List.length (C.data rp2) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → Lemmas.value rp2 (BitVec.toInt limb_cnt) = (0 : ℤ) ∧ (∀(j : ℤ), j < C.offset rp2 ∨ C.offset rp2 + BitVec.toInt limb_cnt ≤ j → C.pelts rp2 j = C.pelts rp1 j) → -(2 : ℤ) < Z.readers mpz3 u ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = Z.sgn mpz3 u * Z.abs_size mpz3 u → (¬(0 : ℤ) ≤ BitVec.toInt o6 → int'32_in_bounds (-BitVec.toInt o2)) ∧ ((¬(0 : ℤ) ≤ BitVec.toInt o6 → (∃(nrn : BitVec 32), BitVec.toInt nrn = -BitVec.toInt o2)) → -(2 : ℤ) < Z.readers mpz3 u ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = Z.sgn mpz3 u * Z.abs_size mpz3 u → (¬(0 : ℤ) ≤ BitVec.toInt o7 → int'32_in_bounds (-BitVec.toInt o2)) ∧ (∀(o8 : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt o7 then o8 = o2 else BitVec.toInt o8 = -BitVec.toInt o2) → (Z.zones mpz3 r = C.zone1 rp2 ∧ Z.readers mpz3 r = -(1 : ℤ) ∧ C.offset rp2 = (0 : ℤ) ∧ C.min rp2 = (0 : ℤ) ∧ C.max rp2 = C.plength rp2 ∧ abs (BitVec.toInt o8) ≤ C.plength rp2 ∧ C.plength rp2 = Z.alloc mpz3 r ∧ (¬BitVec.toInt o8 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o8) - (1 : ℤ))) ≤ Lemmas.value rp2 (abs (BitVec.toInt o8)))) ∧ (∀(mpz4 : Z.mpz_memo), Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.readers mpz4 = Z.readers mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz4 mpz3) ∧ (Z.sgn mpz4 r = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o8) ∧ (Z.sgn mpz4 r = -(1 : ℤ)) = (BitVec.toInt o8 < (0 : ℤ)) ∧ Z.abs_size mpz4 r = abs (BitVec.toInt o8) ∧ Z.abs_value_of mpz4 r = Lemmas.value rp2 (abs (BitVec.toInt o8)) → (Z.zones mpz4 r = C.zone1 rp2 ∧ Z.readers mpz4 r = -(1 : ℤ) ∧ C.min rp2 = (0 : ℤ) ∧ C.max rp2 = C.plength rp2 ∧ Z.abs_value_of mpz4 r = Lemmas.value rp2 (Z.abs_size mpz4 r)) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 r = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = r → Z.readers mpz5 y = Z.readers mpz4 y) → Z.value_of r mpz5 = Z.value_of u mpz * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) ∧ (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz5 mpz) ∧ Z.readers mpz5 r = (0 : ℤ) ∧ Z.readers mpz5 u = (0 : ℤ)))))))))))))))))))))))))))
  := sorry
end mpz_mul2exp_Zmul2exp_wmpz_mul_2expqtvc
