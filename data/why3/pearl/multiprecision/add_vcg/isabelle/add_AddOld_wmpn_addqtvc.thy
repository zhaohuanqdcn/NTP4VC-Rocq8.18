theory add_AddOld_wmpn_addqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.c_C" "mach.int_Unsigned" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/ptralias_Alias"
begin
theorem wmpn_add'vc:
  fixes sy :: "32 word"
  fixes sx :: "32 word"
  fixes x :: "64 word ptr"
  fixes y :: "64 word ptr"
  fixes r :: "64 word ptr"
  assumes fact0: "(0 :: int) \<le> sint sy"
  assumes fact1: "sint sy \<le> sint sx"
  assumes fact2: "valid x (sint sx)"
  assumes fact3: "valid y (sint sy)"
  assumes fact4: "valid r (sint sx)"
  assumes fact5: "writable r = True"
  shows "valid x (sint sy)"
  and "valid y (sint sy)"
  and "valid r (sint sy)"
  and "writable r = True"
  and "\<forall>(r1 :: 64 word ptr). length (data r1) = length (data r) \<and> offset r1 = offset r \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> writable r1 = writable r \<and> zone1 r1 = zone1 r \<longrightarrow> (\<forall>(o1 :: 64 word). ((0 :: int) \<le> uint o1 \<and> uint o1 \<le> (1 :: int)) \<and> value r1 (sint sy) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sy * uint o1 = value x (sint sy) + value y (sint sy) \<and> (\<forall>(j :: int). j < offset r1 \<or> offset r1 + sint sy \<le> j \<longrightarrow> pelts r1 j = pelts r j) \<longrightarrow> (\<forall>(o2 :: bool). (uint o1 = uint (0 :: 64 word) \<longrightarrow> o2 = True) \<and> (o2 = True \<longrightarrow> o1 = (0 :: 64 word)) \<longrightarrow> (if \<not>o2 = True then ((sint sy \<le> sint sy \<and> sint sy \<le> sint sx) \<and> value r1 (sint sy) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sy * uint o1 = value x (sint sy) + value y (sint sy) \<and> ((0 :: int) \<le> uint o1 \<and> uint o1 \<le> (1 :: int)) \<and> (sy = sx \<or> uint o1 = (1 :: int)) \<and> (\<forall>(j :: int). j < offset r1 \<or> offset r1 + sint sx \<le> j \<longrightarrow> pelts r1 j = pelts r j)) \<and> (\<forall>(i :: 32 word) (c :: 64 word) (r2 :: 64 word ptr). length (data r2) = length (data r1) \<and> offset r2 = offset r1 \<and> c_C.min r2 = c_C.min r1 \<and> c_C.max r2 = c_C.max r1 \<and> writable r2 = writable r1 \<and> zone1 r2 = zone1 r1 \<longrightarrow> (sint sy \<le> sint i \<and> sint i \<le> sint sx) \<and> value r2 (sint i) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint i * uint c = value x (sint i) + value y (sint sy) \<and> ((0 :: int) \<le> uint c \<and> uint c \<le> (1 :: int)) \<and> (i = sx \<or> uint c = (1 :: int)) \<and> (\<forall>(j :: int). j < offset r2 \<or> offset r2 + sint sx \<le> j \<longrightarrow> pelts r2 j = pelts r j) \<longrightarrow> (if sint i < sint sx then (c_C.min x \<le> offset x + sint i \<and> offset x + sint i < c_C.max x) \<and> (\<forall>(res :: 64 word). uint res = (uint (pelts x (offset x + sint i)) + (1 :: int)) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> ((c_C.min r2 \<le> offset r2 + sint i \<and> offset r2 + sint i < c_C.max r2) \<and> writable r2 = True) \<and> (\<forall>(r3 :: 64 word ptr). length (data r3) = length (data r2) \<and> offset r3 = offset r2 \<and> c_C.min r3 = c_C.min r2 \<and> c_C.max r3 = c_C.max r2 \<and> writable r3 = writable r2 \<and> zone1 r3 = zone1 r2 \<longrightarrow> pelts r3 = (pelts r2)(offset r3 + sint i := res) \<and> pelts r3 (offset r3 + sint i) = res \<longrightarrow> int'32_in_bounds (sint i + (1 :: int)) \<and> (\<forall>(o3 :: 32 word). sint o3 = sint i + (1 :: int) \<longrightarrow> (\<forall>(o4 :: bool). (uint res = uint (0 :: 64 word) \<longrightarrow> o4 = True) \<and> (o4 = True \<longrightarrow> res = (0 :: 64 word)) \<longrightarrow> (if \<not>o4 = True then ((sint sy \<le> sint o3 \<and> sint o3 \<le> sint sx) \<and> (o3 = sx \<or> uint (0 :: 64 word) = (0 :: int)) \<and> value r3 (sint o3) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o3 * uint (0 :: 64 word) = value x (sint o3) + value y (sint sy) \<and> (\<forall>(j :: int). j < offset r3 \<or> offset r3 + sint sx \<le> j \<longrightarrow> pelts r3 j = pelts r j)) \<and> (\<forall>(i1 :: 32 word) (r4 :: 64 word ptr). length (data r4) = length (data r3) \<and> offset r4 = offset r3 \<and> c_C.min r4 = c_C.min r3 \<and> c_C.max r4 = c_C.max r3 \<and> writable r4 = writable r3 \<and> zone1 r4 = zone1 r3 \<longrightarrow> (sint sy \<le> sint i1 \<and> sint i1 \<le> sint sx) \<and> (i1 = sx \<or> uint (0 :: 64 word) = (0 :: int)) \<and> value r4 (sint i1) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint i1 * uint (0 :: 64 word) = value x (sint i1) + value y (sint sy) \<and> (\<forall>(j :: int). j < offset r4 \<or> offset r4 + sint sx \<le> j \<longrightarrow> pelts r4 j = pelts r j) \<longrightarrow> (if sint i1 < sint sx then (c_C.min x \<le> offset x + sint i1 \<and> offset x + sint i1 < c_C.max x) \<and> ((c_C.min r4 \<le> offset r4 + sint i1 \<and> offset r4 + sint i1 < c_C.max r4) \<and> writable r4 = True) \<and> (\<forall>(r5 :: 64 word ptr). length (data r5) = length (data r4) \<and> offset r5 = offset r4 \<and> c_C.min r5 = c_C.min r4 \<and> c_C.max r5 = c_C.max r4 \<and> writable r5 = writable r4 \<and> zone1 r5 = zone1 r4 \<longrightarrow> pelts r5 = (pelts r4)(offset r5 + sint i1 := pelts x (offset x + sint i1)) \<and> pelts r5 (offset r5 + sint i1) = pelts x (offset x + sint i1) \<longrightarrow> int'32_in_bounds (sint i1 + (1 :: int)) \<and> (\<forall>(o5 :: 32 word). sint o5 = sint i1 + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint sx - sint i1 \<and> sint sx - sint o5 < sint sx - sint i1) \<and> (sint sy \<le> sint o5 \<and> sint o5 \<le> sint sx) \<and> (o5 = sx \<or> uint (0 :: 64 word) = (0 :: int)) \<and> value r5 (sint o5) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o5 * uint (0 :: 64 word) = value x (sint o5) + value y (sint sy) \<and> (\<forall>(j :: int). j < offset r5 \<or> offset r5 + sint sx \<le> j \<longrightarrow> pelts r5 j = pelts r j))) else value r4 (sint sx) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sx * uint (0 :: 64 word) = value x (sint sx) + value y (sint sy) \<and> (\<forall>(j :: int). j < offset r4 \<or> offset r4 + sint sx \<le> j \<longrightarrow> pelts r4 j = pelts r j) \<and> (0 :: int) \<le> uint (0 :: 64 word) \<and> uint (0 :: 64 word) \<le> (1 :: int))) else ((0 :: int) \<le> sint sx - sint i \<and> sint sx - sint o3 < sint sx - sint i) \<and> (sint sy \<le> sint o3 \<and> sint o3 \<le> sint sx) \<and> value r3 (sint o3) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o3 * uint c = value x (sint o3) + value y (sint sy) \<and> ((0 :: int) \<le> uint c \<and> uint c \<le> (1 :: int)) \<and> (o3 = sx \<or> uint c = (1 :: int)) \<and> (\<forall>(j :: int). j < offset r3 \<or> offset r3 + sint sx \<le> j \<longrightarrow> pelts r3 j = pelts r j)))))) else ((sint sy \<le> sint i \<and> sint i \<le> sint sx) \<and> (i = sx \<or> uint c = (0 :: int)) \<and> value r2 (sint i) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint i * uint c = value x (sint i) + value y (sint sy) \<and> (\<forall>(j :: int). j < offset r2 \<or> offset r2 + sint sx \<le> j \<longrightarrow> pelts r2 j = pelts r j)) \<and> (\<forall>(i1 :: 32 word) (r3 :: 64 word ptr). length (data r3) = length (data r2) \<and> offset r3 = offset r2 \<and> c_C.min r3 = c_C.min r2 \<and> c_C.max r3 = c_C.max r2 \<and> writable r3 = writable r2 \<and> zone1 r3 = zone1 r2 \<longrightarrow> (sint sy \<le> sint i1 \<and> sint i1 \<le> sint sx) \<and> (i1 = sx \<or> uint c = (0 :: int)) \<and> value r3 (sint i1) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint i1 * uint c = value x (sint i1) + value y (sint sy) \<and> (\<forall>(j :: int). j < offset r3 \<or> offset r3 + sint sx \<le> j \<longrightarrow> pelts r3 j = pelts r j) \<longrightarrow> (if sint i1 < sint sx then (c_C.min x \<le> offset x + sint i1 \<and> offset x + sint i1 < c_C.max x) \<and> ((c_C.min r3 \<le> offset r3 + sint i1 \<and> offset r3 + sint i1 < c_C.max r3) \<and> writable r3 = True) \<and> (\<forall>(r4 :: 64 word ptr). length (data r4) = length (data r3) \<and> offset r4 = offset r3 \<and> c_C.min r4 = c_C.min r3 \<and> c_C.max r4 = c_C.max r3 \<and> writable r4 = writable r3 \<and> zone1 r4 = zone1 r3 \<longrightarrow> pelts r4 = (pelts r3)(offset r4 + sint i1 := pelts x (offset x + sint i1)) \<and> pelts r4 (offset r4 + sint i1) = pelts x (offset x + sint i1) \<longrightarrow> int'32_in_bounds (sint i1 + (1 :: int)) \<and> (\<forall>(o3 :: 32 word). sint o3 = sint i1 + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint sx - sint i1 \<and> sint sx - sint o3 < sint sx - sint i1) \<and> (sint sy \<le> sint o3 \<and> sint o3 \<le> sint sx) \<and> (o3 = sx \<or> uint c = (0 :: int)) \<and> value r4 (sint o3) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o3 * uint c = value x (sint o3) + value y (sint sy) \<and> (\<forall>(j :: int). j < offset r4 \<or> offset r4 + sint sx \<le> j \<longrightarrow> pelts r4 j = pelts r j))) else value r3 (sint sx) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sx * uint c = value x (sint sx) + value y (sint sy) \<and> (\<forall>(j :: int). j < offset r3 \<or> offset r3 + sint sx \<le> j \<longrightarrow> pelts r3 j = pelts r j) \<and> (0 :: int) \<le> uint c \<and> uint c \<le> (1 :: int))))) else ((sint sy \<le> sint sy \<and> sint sy \<le> sint sx) \<and> (sy = sx \<or> uint o1 = (0 :: int)) \<and> value r1 (sint sy) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sy * uint o1 = value x (sint sy) + value y (sint sy) \<and> (\<forall>(j :: int). j < offset r1 \<or> offset r1 + sint sx \<le> j \<longrightarrow> pelts r1 j = pelts r j)) \<and> (\<forall>(i :: 32 word) (r2 :: 64 word ptr). length (data r2) = length (data r1) \<and> offset r2 = offset r1 \<and> c_C.min r2 = c_C.min r1 \<and> c_C.max r2 = c_C.max r1 \<and> writable r2 = writable r1 \<and> zone1 r2 = zone1 r1 \<longrightarrow> (sint sy \<le> sint i \<and> sint i \<le> sint sx) \<and> (i = sx \<or> uint o1 = (0 :: int)) \<and> value r2 (sint i) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint i * uint o1 = value x (sint i) + value y (sint sy) \<and> (\<forall>(j :: int). j < offset r2 \<or> offset r2 + sint sx \<le> j \<longrightarrow> pelts r2 j = pelts r j) \<longrightarrow> (if sint i < sint sx then (c_C.min x \<le> offset x + sint i \<and> offset x + sint i < c_C.max x) \<and> ((c_C.min r2 \<le> offset r2 + sint i \<and> offset r2 + sint i < c_C.max r2) \<and> writable r2 = True) \<and> (\<forall>(r3 :: 64 word ptr). length (data r3) = length (data r2) \<and> offset r3 = offset r2 \<and> c_C.min r3 = c_C.min r2 \<and> c_C.max r3 = c_C.max r2 \<and> writable r3 = writable r2 \<and> zone1 r3 = zone1 r2 \<longrightarrow> pelts r3 = (pelts r2)(offset r3 + sint i := pelts x (offset x + sint i)) \<and> pelts r3 (offset r3 + sint i) = pelts x (offset x + sint i) \<longrightarrow> int'32_in_bounds (sint i + (1 :: int)) \<and> (\<forall>(o3 :: 32 word). sint o3 = sint i + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint sx - sint i \<and> sint sx - sint o3 < sint sx - sint i) \<and> (sint sy \<le> sint o3 \<and> sint o3 \<le> sint sx) \<and> (o3 = sx \<or> uint o1 = (0 :: int)) \<and> value r3 (sint o3) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o3 * uint o1 = value x (sint o3) + value y (sint sy) \<and> (\<forall>(j :: int). j < offset r3 \<or> offset r3 + sint sx \<le> j \<longrightarrow> pelts r3 j = pelts r j))) else value r2 (sint sx) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sx * uint o1 = value x (sint sx) + value y (sint sy) \<and> (\<forall>(j :: int). j < offset r2 \<or> offset r2 + sint sx \<le> j \<longrightarrow> pelts r2 j = pelts r j) \<and> (0 :: int) \<le> uint o1 \<and> uint o1 \<le> (1 :: int))))))"
  sorry
end
