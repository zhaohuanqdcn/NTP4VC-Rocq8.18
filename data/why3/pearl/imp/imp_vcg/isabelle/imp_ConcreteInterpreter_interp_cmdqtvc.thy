theory imp_ConcreteInterpreter_interp_cmdqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "../../lib/isabelle/imp_Syntax" "../../lib/isabelle/imp_ConcreteSemantics" "../../lib/isabelle/dict_Imperative"
begin
typedecl  env
theorem interp_cmd'vc:
  fixes c :: "cmd"
  fixes env1 :: "(program_var, int) t"
  shows "case c of Cskip \<Rightarrow> exec_cmd no_limit_cnf (model1 env1) c (model1 env1) Cnormal | Cassign x e \<Rightarrow> (\<forall>(o1 :: int). eval_expr (model1 env1) e (Enormal o1) \<longrightarrow> (\<forall>(env2 :: (program_var, int) t). model1 env2 = (model1 env1)(x := Some o1) \<longrightarrow> exec_cmd no_limit_cnf (model1 env1) c (model1 env2) Cnormal)) \<and> (eval_expr (model1 env1) e Eunbound_var \<longrightarrow> exec_cmd no_limit_cnf (model1 env1) c (model1 env1) Cunbound_var) | Cseq c1 c2 \<Rightarrow> (\<forall>(env2 :: (program_var, int) t). (exec_cmd no_limit_cnf (model1 env1) c1 (model1 env2) Cnormal \<longrightarrow> (\<forall>(env3 :: (program_var, int) t). (exec_cmd no_limit_cnf (model1 env2) c2 (model1 env3) Cnormal \<longrightarrow> exec_cmd no_limit_cnf (model1 env1) c (model1 env3) Cnormal) \<and> (exec_cmd no_limit_cnf (model1 env2) c2 (model1 env3) Cunbound_var \<longrightarrow> exec_cmd no_limit_cnf (model1 env1) c (model1 env3) Cunbound_var))) \<and> (exec_cmd no_limit_cnf (model1 env1) c1 (model1 env2) Cunbound_var \<longrightarrow> exec_cmd no_limit_cnf (model1 env1) c (model1 env2) Cunbound_var)) | Cif e c1 c2 \<Rightarrow> (\<forall>(o1 :: int). eval_expr (model1 env1) e (Enormal o1) \<longrightarrow> (if \<not>o1 = (0 :: int) then \<forall>(env2 :: (program_var, int) t). (exec_cmd no_limit_cnf (model1 env1) c1 (model1 env2) Cnormal \<longrightarrow> exec_cmd no_limit_cnf (model1 env1) c (model1 env2) Cnormal) \<and> (exec_cmd no_limit_cnf (model1 env1) c1 (model1 env2) Cunbound_var \<longrightarrow> exec_cmd no_limit_cnf (model1 env1) c (model1 env2) Cunbound_var) else \<forall>(env2 :: (program_var, int) t). (exec_cmd no_limit_cnf (model1 env1) c2 (model1 env2) Cnormal \<longrightarrow> exec_cmd no_limit_cnf (model1 env1) c (model1 env2) Cnormal) \<and> (exec_cmd no_limit_cnf (model1 env1) c2 (model1 env2) Cunbound_var \<longrightarrow> exec_cmd no_limit_cnf (model1 env1) c (model1 env2) Cunbound_var))) \<and> (eval_expr (model1 env1) e Eunbound_var \<longrightarrow> exec_cmd no_limit_cnf (model1 env1) c (model1 env1) Cunbound_var) | Cwhile e c1 \<Rightarrow> (let env0 :: program_var \<Rightarrow> int option = model1 env1 in (\<forall>(env11 :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_while no_limit_cnf (0 :: int) (model1 env1) e c1 env11 bhv \<longrightarrow> exec_while no_limit_cnf (0 :: int) env0 e c1 env11 bhv) \<and> (\<forall>(ctr :: int) (env2 :: (program_var, int) t). (\<forall>(env11 :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_while no_limit_cnf ctr (model1 env2) e c1 env11 bhv \<longrightarrow> exec_while no_limit_cnf (0 :: int) env0 e c1 env11 bhv) \<longrightarrow> (\<forall>(o1 :: int). eval_expr (model1 env2) e (Enormal o1) \<longrightarrow> (if \<not>o1 = (0 :: int) then \<forall>(env3 :: (program_var, int) t). (exec_cmd no_limit_cnf (model1 env2) c1 (model1 env3) Cnormal \<longrightarrow> (\<forall>(env11 :: program_var \<Rightarrow> int option) (bhv :: behavior). exec_while no_limit_cnf (ctr + (1 :: int)) (model1 env3) e c1 env11 bhv \<longrightarrow> exec_while no_limit_cnf (0 :: int) env0 e c1 env11 bhv)) \<and> (exec_cmd no_limit_cnf (model1 env2) c1 (model1 env3) Cunbound_var \<longrightarrow> exec_cmd no_limit_cnf (model1 env1) c (model1 env3) Cunbound_var) else exec_cmd no_limit_cnf (model1 env1) c (model1 env2) Cnormal)) \<and> (eval_expr (model1 env2) e Eunbound_var \<longrightarrow> exec_cmd no_limit_cnf (model1 env1) c (model1 env2) Cunbound_var)))"
  sorry
end
