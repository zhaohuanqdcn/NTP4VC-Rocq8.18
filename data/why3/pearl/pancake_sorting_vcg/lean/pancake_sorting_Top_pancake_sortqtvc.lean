import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
open Classical
open Lean4Why3
namespace pancake_sorting_Top_pancake_sortqtvc
noncomputable def sorted (a : List ℤ) (hi : ℤ) := ∀(j1 : ℤ) (j2 : ℤ), (0 : ℤ) ≤ j1 ∧ j1 ≤ j2 ∧ j2 < hi → a[Int.toNat j2]! ≤ a[Int.toNat j1]!
theorem pancake_sort'vc (a : List ℤ) : let o1 : ℤ := Int.ofNat (List.length a) - (2 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → (sorted a (0 : ℤ) ∧ (∀(j1 : ℤ) (j2 : ℤ), (0 : ℤ) ≤ j1 ∧ j1 < (0 : ℤ) ∧ (0 : ℤ) ≤ j2 ∧ j2 < Int.ofNat (List.length a) → a[Int.toNat j2]! ≤ a[Int.toNat j1]!) ∧ List.Perm a a) ∧ (∀(a1 : List ℤ), List.length a1 = List.length a → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ sorted a1 i ∧ (∀(j1 : ℤ) (j2 : ℤ), (0 : ℤ) ≤ j1 ∧ j1 < i ∧ i ≤ j2 ∧ j2 < Int.ofNat (List.length a1) → a1[Int.toNat j2]! ≤ a1[Int.toNat j1]!) ∧ List.Perm a a1 → (let o2 : ℤ := Int.ofNat (List.length a1) - (1 : ℤ); let o3 : ℤ := i + (1 : ℤ); (o3 ≤ o2 + (1 : ℤ) → ((i ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (∀(j : ℤ), i ≤ j ∧ j < o3 → a1[Int.toNat j]! ≤ a1[Int.toNat i]!)) ∧ (∀(m : ℤ), (∀(k : ℤ), (o3 ≤ k ∧ k ≤ o2) ∧ (i ≤ m ∧ m < Int.ofNat (List.length a1)) ∧ (∀(j : ℤ), i ≤ j ∧ j < k → a1[Int.toNat j]! ≤ a1[Int.toNat m]!) → ((0 : ℤ) ≤ m ∧ m < Int.ofNat (List.length a1)) ∧ ((0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length a1)) ∧ (if a1[Int.toNat m]! < a1[Int.toNat k]! then (i ≤ k ∧ k < Int.ofNat (List.length a1)) ∧ (∀(j : ℤ), i ≤ j ∧ j < k + (1 : ℤ) → a1[Int.toNat j]! ≤ a1[Int.toNat k]!) else (i ≤ m ∧ m < Int.ofNat (List.length a1)) ∧ (∀(j : ℤ), i ≤ j ∧ j < k + (1 : ℤ) → a1[Int.toNat j]! ≤ a1[Int.toNat m]!))) ∧ ((i ≤ m ∧ m < Int.ofNat (List.length a1)) ∧ (∀(j : ℤ), i ≤ j ∧ j < o2 + (1 : ℤ) → a1[Int.toNat j]! ≤ a1[Int.toNat m]!) → (if m = i then sorted a1 (i + (1 : ℤ)) ∧ (∀(j1 : ℤ) (j2 : ℤ), (0 : ℤ) ≤ j1 ∧ j1 < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ j2 ∧ j2 < Int.ofNat (List.length a1) → a1[Int.toNat j2]! ≤ a1[Int.toNat j1]!) ∧ List.Perm a a1 else if m < Int.ofNat (List.length a1) - (1 : ℤ) then ((0 : ℤ) ≤ m ∧ m < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < m → a2[Int.toNat j]! = a1[Int.toNat j]!) ∧ (∀(j : ℤ), m ≤ j ∧ j < Int.ofNat (List.length a2) → a2[Int.toNat j]! = a1[Int.toNat (Int.ofNat (List.length a2) - (1 : ℤ) - (j - m))]!) ∧ List.Perm a1 a2 → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a2)) ∧ (∀(a3 : List ℤ), List.length a3 = List.length a2 → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → a3[Int.toNat j]! = a2[Int.toNat j]!) ∧ (∀(j : ℤ), i ≤ j ∧ j < Int.ofNat (List.length a3) → a3[Int.toNat j]! = a2[Int.toNat (Int.ofNat (List.length a3) - (1 : ℤ) - (j - i))]!) ∧ List.Perm a2 a3 → sorted a3 (i + (1 : ℤ)) ∧ (∀(j1 : ℤ) (j2 : ℤ), (0 : ℤ) ≤ j1 ∧ j1 < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ j2 ∧ j2 < Int.ofNat (List.length a3) → a3[Int.toNat j2]! ≤ a3[Int.toNat j1]!) ∧ List.Perm a a3)) else ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → a2[Int.toNat j]! = a1[Int.toNat j]!) ∧ (∀(j : ℤ), i ≤ j ∧ j < Int.ofNat (List.length a2) → a2[Int.toNat j]! = a1[Int.toNat (Int.ofNat (List.length a2) - (1 : ℤ) - (j - i))]!) ∧ List.Perm a1 a2 → sorted a2 (i + (1 : ℤ)) ∧ (∀(j1 : ℤ) (j2 : ℤ), (0 : ℤ) ≤ j1 ∧ j1 < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ j2 ∧ j2 < Int.ofNat (List.length a2) → a2[Int.toNat j2]! ≤ a2[Int.toNat j1]!) ∧ List.Perm a a2))))) ∧ (o2 + (1 : ℤ) < o3 → sorted a1 (i + (1 : ℤ)) ∧ (∀(j1 : ℤ) (j2 : ℤ), (0 : ℤ) ≤ j1 ∧ j1 < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ j2 ∧ j2 < Int.ofNat (List.length a1) → a1[Int.toNat j2]! ≤ a1[Int.toNat j1]!) ∧ List.Perm a a1))) ∧ (sorted a1 (o1 + (1 : ℤ)) ∧ (∀(j1 : ℤ) (j2 : ℤ), (0 : ℤ) ≤ j1 ∧ j1 < o1 + (1 : ℤ) ∧ o1 + (1 : ℤ) ≤ j2 ∧ j2 < Int.ofNat (List.length a1) → a1[Int.toNat j2]! ≤ a1[Int.toNat j1]!) ∧ List.Perm a a1 → sorted a1 (Int.ofNat (List.length a1)) ∧ List.Perm a a1))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → sorted a (Int.ofNat (List.length a)) ∧ List.Perm a a)
  := sorry
end pancake_sorting_Top_pancake_sortqtvc
