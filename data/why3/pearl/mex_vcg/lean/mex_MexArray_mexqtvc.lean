import Why3.Base
import Why3.why3.Ref.Ref
import Why3.pigeon.Pigeonhole
open Classical
open Lean4Why3
namespace mex_MexArray_mexqtvc
noncomputable def mem (x : ℤ) (a : List ℤ) := ∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ a[Int.toNat i]! = x
axiom identity : ℤ -> ℤ
axiom identity_def (y : ℤ) : identity y = y
theorem mex'vc (a : List ℤ) : let n : ℤ := Int.ofNat (List.length a); (0 : ℤ) ≤ n ∧ (∀(used : List Bool), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → used[Int.toNat i]! = false) ∧ Int.ofNat (List.length used) = n → (let o1 : ℤ -> ℤ := identity; let o2 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → ((∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < n → used[Int.toNat x]! = true → mem x a ∧ ((0 : ℤ) ≤ o1 x ∧ o1 x < n) ∧ a[Int.toNat (o1 x)]! = x) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → (0 : ℤ) ≤ a[Int.toNat j]! ∧ a[Int.toNat j]! < n → used[Int.toNat (a[Int.toNat j]!)]! = true ∧ ((0 : ℤ) ≤ o1 (a[Int.toNat j]!) ∧ o1 (a[Int.toNat j]!) < n) ∧ a[Int.toNat (o1 (a[Int.toNat j]!))]! = a[Int.toNat j]!)) ∧ (∀(idx : ℤ -> ℤ) (used1 : List Bool), List.length used1 = List.length used → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o2) ∧ (∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < n → used1[Int.toNat x]! = true → mem x a ∧ ((0 : ℤ) ≤ idx x ∧ idx x < n) ∧ a[Int.toNat (idx x)]! = x) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → (0 : ℤ) ≤ a[Int.toNat j]! ∧ a[Int.toNat j]! < n → used1[Int.toNat (a[Int.toNat j]!)]! = true ∧ ((0 : ℤ) ≤ idx (a[Int.toNat j]!) ∧ idx (a[Int.toNat j]!) < n) ∧ a[Int.toNat (idx (a[Int.toNat j]!))]! = a[Int.toNat j]!) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let x : ℤ := a[Int.toNat i]!; ∀(o3 : Bool), (if (0 : ℤ) ≤ x then o3 = (if x < n then true else false) else o3 = false) → (if o3 = true then let o4 : Bool := true; ((0 : ℤ) ≤ x ∧ x < Int.ofNat (List.length used1)) ∧ (List.length (List.set used1 (Int.toNat x) o4) = List.length used1 → getElem! (List.set used1 (Int.toNat x) o4) ∘ Int.toNat = Function.update (getElem! used1 ∘ Int.toNat) x o4 → (∀(x1 : ℤ), (0 : ℤ) ≤ x1 ∧ x1 < n → (List.set used1 (Int.toNat x) o4)[Int.toNat x1]! = true → mem x1 a ∧ ((0 : ℤ) ≤ Function.update idx x i x1 ∧ Function.update idx x i x1 < n) ∧ a[Int.toNat (Function.update idx x i x1)]! = x1) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → (0 : ℤ) ≤ a[Int.toNat j]! ∧ a[Int.toNat j]! < n → (List.set used1 (Int.toNat x) o4)[Int.toNat (a[Int.toNat j]!)]! = true ∧ ((0 : ℤ) ≤ Function.update idx x i (a[Int.toNat j]!) ∧ Function.update idx x i (a[Int.toNat j]!) < n) ∧ a[Int.toNat (Function.update idx x i (a[Int.toNat j]!))]! = a[Int.toNat j]!)) else (∀(x1 : ℤ), (0 : ℤ) ≤ x1 ∧ x1 < n → used1[Int.toNat x1]! = true → mem x1 a ∧ ((0 : ℤ) ≤ idx x1 ∧ idx x1 < n) ∧ a[Int.toNat (idx x1)]! = x1) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → (0 : ℤ) ≤ a[Int.toNat j]! ∧ a[Int.toNat j]! < n → used1[Int.toNat (a[Int.toNat j]!)]! = true ∧ ((0 : ℤ) ≤ idx (a[Int.toNat j]!) ∧ idx (a[Int.toNat j]!) < n) ∧ a[Int.toNat (idx (a[Int.toNat j]!))]! = a[Int.toNat j]!)))) ∧ ((∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < n → used1[Int.toNat x]! = true → mem x a ∧ ((0 : ℤ) ≤ idx x ∧ idx x < n) ∧ a[Int.toNat (idx x)]! = x) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < o2 + (1 : ℤ) → (0 : ℤ) ≤ a[Int.toNat j]! ∧ a[Int.toNat j]! < n → used1[Int.toNat (a[Int.toNat j]!)]! = true ∧ ((0 : ℤ) ≤ idx (a[Int.toNat j]!) ∧ idx (a[Int.toNat j]!) < n) ∧ a[Int.toNat (idx (a[Int.toNat j]!))]! = a[Int.toNat j]!) → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → used1[Int.toNat j]! = true ∧ (0 : ℤ) ≤ idx j ∧ idx j < n) ∧ (if (0 : ℤ) ≤ -(1 : ℤ) then ((0 : ℤ) ≤ -(1 : ℤ) ∧ -(1 : ℤ) < n) ∧ a[Int.toNat (-(1 : ℤ))]! = n else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → ¬a[Int.toNat j]! = n)) ∧ (∀(posn : ℤ) (r : ℤ), ((0 : ℤ) ≤ r ∧ r ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r → used1[Int.toNat j]! = true ∧ (0 : ℤ) ≤ idx j ∧ idx j < n) ∧ (if (0 : ℤ) ≤ posn then ((0 : ℤ) ≤ posn ∧ posn < n) ∧ a[Int.toNat posn]! = n else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r → ¬a[Int.toNat j]! = n) → (r < n → (0 : ℤ) ≤ r ∧ r < Int.ofNat (List.length used1)) ∧ (∀(o3 : Bool), (if r < n then o3 = used1[Int.toNat r]! else o3 = false) → (if o3 = true then ((0 : ℤ) ≤ r ∧ r < Int.ofNat (List.length a)) ∧ (if a[Int.toNat r]! = n then ((0 : ℤ) ≤ n - r ∧ n - (r + (1 : ℤ)) < n - r) ∧ ((0 : ℤ) ≤ r + (1 : ℤ) ∧ r + (1 : ℤ) ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r + (1 : ℤ) → used1[Int.toNat j]! = true ∧ (0 : ℤ) ≤ idx j ∧ idx j < n) ∧ (if (0 : ℤ) ≤ r then ((0 : ℤ) ≤ r ∧ r < n) ∧ a[Int.toNat r]! = n else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r + (1 : ℤ) → ¬a[Int.toNat j]! = n) else ((0 : ℤ) ≤ n - r ∧ n - (r + (1 : ℤ)) < n - r) ∧ ((0 : ℤ) ≤ r + (1 : ℤ) ∧ r + (1 : ℤ) ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r + (1 : ℤ) → used1[Int.toNat j]! = true ∧ (0 : ℤ) ≤ idx j ∧ idx j < n) ∧ (if (0 : ℤ) ≤ posn then ((0 : ℤ) ≤ posn ∧ posn < n) ∧ a[Int.toNat posn]! = n else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r + (1 : ℤ) → ¬a[Int.toNat j]! = n)) else ∀(o4 : Bool), (if r = n then o4 = (if (0 : ℤ) ≤ posn then true else false) else o4 = false) → (o4 = true → (let o5 : ℤ -> ℤ := Function.update idx n posn; let o6 : ℤ := n + (1 : ℤ); ((0 : ℤ) ≤ n ∧ n < o6) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o6 → (0 : ℤ) ≤ o5 i ∧ o5 i < n))) ∧ ((o4 = true → (let o5 : ℤ -> ℤ := Function.update idx n posn; ∃(i1 : ℤ) (i2 : ℤ), ((0 : ℤ) ≤ i1 ∧ i1 < i2 ∧ i2 < n + (1 : ℤ)) ∧ o5 i1 = o5 i2)) → ((0 : ℤ) ≤ r ∧ r ≤ Int.ofNat (List.length a)) ∧ ¬mem r a ∧ (∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < r → mem x a)))))))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → used[Int.toNat j]! = true ∧ (0 : ℤ) ≤ o1 j ∧ o1 j < n) ∧ (if (0 : ℤ) ≤ -(1 : ℤ) then ((0 : ℤ) ≤ -(1 : ℤ) ∧ -(1 : ℤ) < n) ∧ a[Int.toNat (-(1 : ℤ))]! = n else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → ¬a[Int.toNat j]! = n)) ∧ (∀(posn : ℤ) (r : ℤ), ((0 : ℤ) ≤ r ∧ r ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r → used[Int.toNat j]! = true ∧ (0 : ℤ) ≤ o1 j ∧ o1 j < n) ∧ (if (0 : ℤ) ≤ posn then ((0 : ℤ) ≤ posn ∧ posn < n) ∧ a[Int.toNat posn]! = n else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r → ¬a[Int.toNat j]! = n) → (r < n → (0 : ℤ) ≤ r ∧ r < Int.ofNat (List.length used)) ∧ (∀(o3 : Bool), (if r < n then o3 = used[Int.toNat r]! else o3 = false) → (if o3 = true then ((0 : ℤ) ≤ r ∧ r < Int.ofNat (List.length a)) ∧ (if a[Int.toNat r]! = n then ((0 : ℤ) ≤ n - r ∧ n - (r + (1 : ℤ)) < n - r) ∧ ((0 : ℤ) ≤ r + (1 : ℤ) ∧ r + (1 : ℤ) ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r + (1 : ℤ) → used[Int.toNat j]! = true ∧ (0 : ℤ) ≤ o1 j ∧ o1 j < n) ∧ (if (0 : ℤ) ≤ r then ((0 : ℤ) ≤ r ∧ r < n) ∧ a[Int.toNat r]! = n else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r + (1 : ℤ) → ¬a[Int.toNat j]! = n) else ((0 : ℤ) ≤ n - r ∧ n - (r + (1 : ℤ)) < n - r) ∧ ((0 : ℤ) ≤ r + (1 : ℤ) ∧ r + (1 : ℤ) ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r + (1 : ℤ) → used[Int.toNat j]! = true ∧ (0 : ℤ) ≤ o1 j ∧ o1 j < n) ∧ (if (0 : ℤ) ≤ posn then ((0 : ℤ) ≤ posn ∧ posn < n) ∧ a[Int.toNat posn]! = n else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < r + (1 : ℤ) → ¬a[Int.toNat j]! = n)) else ∀(o4 : Bool), (if r = n then o4 = (if (0 : ℤ) ≤ posn then true else false) else o4 = false) → (o4 = true → (let o5 : ℤ -> ℤ := Function.update o1 n posn; let o6 : ℤ := n + (1 : ℤ); ((0 : ℤ) ≤ n ∧ n < o6) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o6 → (0 : ℤ) ≤ o5 i ∧ o5 i < n))) ∧ ((o4 = true → (let o5 : ℤ -> ℤ := Function.update o1 n posn; ∃(i1 : ℤ) (i2 : ℤ), ((0 : ℤ) ≤ i1 ∧ i1 < i2 ∧ i2 < n + (1 : ℤ)) ∧ o5 i1 = o5 i2)) → ((0 : ℤ) ≤ r ∧ r ≤ Int.ofNat (List.length a)) ∧ ¬mem r a ∧ (∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < r → mem x a))))))))
  := sorry
end mex_MexArray_mexqtvc
