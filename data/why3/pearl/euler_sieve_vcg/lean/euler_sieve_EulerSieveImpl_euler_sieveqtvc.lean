import Why3.Base
import Why3.why3.Ref.Ref
import pearl.euler_sieve_vcg.lean.euler_sieve.ArithmeticResults
import pearl.euler_sieve_vcg.lean.euler_sieve.DivisibilityResults
import pearl.euler_sieve_vcg.lean.euler_sieve.EulerSieveSpec
import Why3.mach.array.ArrayInt63
open Classical
open Lean4Why3
namespace euler_sieve_EulerSieveImpl_euler_sieveqtvc
axiom t : Type
axiom inhabited_axiom_t : Inhabited t
attribute [instance] inhabited_axiom_t
axiom nexts : t -> List ℤ
axiom marked : t -> List Bool
axiom arr : t -> ArrayInt63.array63
axiom max : t -> BitVec 63
axiom max_arr : t -> BitVec 63
axiom t'invariant (self : t) : BitVec.toInt (max self) < BitVec.toInt int'63_max ∧ (3 : ℤ) ≤ BitVec.toInt (max self) ∧ List.length (nexts self) = List.length (marked self) ∧ Int.ofNat (List.length (marked self)) = BitVec.toInt (max self) + (1 : ℤ) ∧ (BitVec.toInt (max self) - (1 : ℤ)) / (2 : ℤ) = BitVec.toInt (max_arr self) ∧ Int.ofNat (List.length (ArrayInt63.elts (arr self))) = BitVec.toInt (max_arr self) + (1 : ℤ) ∧ EulerSieveSpec.inv_nexts (nexts self) (Int.ofNat (List.length (nexts self))) ∧ EulerSieveSpec.all_eliminated_marked (marked self) (nexts self) ∧ (∀(i : ℤ), (3 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max self) → i % (2 : ℤ) = (0 : ℤ) → (marked self)[Int.toNat i]! = true) ∧ (∀(i : ℤ), (3 : ℤ) ≤ i ∧ i < BitVec.toInt (max self) - (1 : ℤ) → i % (2 : ℤ) = (1 : ℤ) → (nexts self)[Int.toNat i]! % (2 : ℤ) = (1 : ℤ) ∨ (nexts self)[Int.toNat i]! = BitVec.toInt (max self) + (1 : ℤ)) ∧ (nexts self)[Int.toNat (BitVec.toInt (max self))]! = BitVec.toInt (max self) + (1 : ℤ) ∧ ((BitVec.toInt (max self) - (1 : ℤ)) % (2 : ℤ) = (0 : ℤ) → (nexts self)[Int.toNat (BitVec.toInt (max self) - (1 : ℤ))]! = BitVec.toInt (max self)) ∧ ((BitVec.toInt (max self) - (1 : ℤ)) % (2 : ℤ) = (1 : ℤ) → (nexts self)[Int.toNat (BitVec.toInt (max self) - (1 : ℤ))]! = BitVec.toInt (max self) + (1 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → -(BitVec.toInt (max self) + (1 : ℤ)) ≤ (ArrayInt63.elts (arr self))[Int.toNat i]! ∧ (ArrayInt63.elts (arr self))[Int.toNat i]! ≤ BitVec.toInt (max self) + (1 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → ((marked self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true) = ((ArrayInt63.elts (arr self))[Int.toNat i]! < (0 : ℤ))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → ¬(marked self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true → (ArrayInt63.elts (arr self))[Int.toNat i]! = (nexts self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → (marked self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true → (ArrayInt63.elts (arr self))[Int.toNat i]! = -(nexts self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → (i < abs ((ArrayInt63.elts (arr self))[Int.toNat i]!) / (2 : ℤ) ∧ abs ((ArrayInt63.elts (arr self))[Int.toNat i]!) / (2 : ℤ) ≤ BitVec.toInt (max_arr self) + (1 : ℤ)) ∧ abs ((ArrayInt63.elts (arr self))[Int.toNat i]!) ≤ BitVec.toInt (max self) + (1 : ℤ)) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → i < j ∧ j < abs ((ArrayInt63.elts (arr self))[Int.toNat i]!) / (2 : ℤ) → (ArrayInt63.elts (arr self))[Int.toNat j]! < (0 : ℤ))
noncomputable def t'eq (a : t) (b : t) := nexts a = nexts b ∧ marked a = marked b ∧ arr a = arr b ∧ max a = max b ∧ max_arr a = max_arr b
axiom t'inj (a : t) (b : t) (fact0 : t'eq a b) : a = b
noncomputable def inv_count (arr1 : List ℤ) (min : ℤ) := ∀(i : ℤ), min ≤ i ∧ i < Int.ofNat (List.length arr1) → (i < abs (arr1[Int.toNat i]!) / (2 : ℤ) ∧ abs (arr1[Int.toNat i]!) / (2 : ℤ) ≤ Int.ofNat (List.length arr1)) ∧ (-BitVec.toInt int'63_max ≤ arr1[Int.toNat i]! ∧ arr1[Int.toNat i]! ≤ BitVec.toInt int'63_max) ∧ (∀(j : ℤ), i < j ∧ j < abs (arr1[Int.toNat i]!) / (2 : ℤ) → arr1[Int.toNat j]! < (0 : ℤ)) ∧ (∀(j : ℤ), (2 : ℤ) * i + (1 : ℤ) < j ∧ j < abs (arr1[Int.toNat i]!) → ¬Nat.Prime (Int.toNat j))
theorem euler_sieve'vc (max1 : BitVec 63) (fact0 : BitVec.toInt max1 < BitVec.toInt int'63_max) (fact1 : (3 : ℤ) ≤ BitVec.toInt max1) : BitVec.toInt max1 < BitVec.toInt int'63_max ∧ (3 : ℤ) ≤ BitVec.toInt max1 ∧ (∀(t1 : t), max t1 = max1 ∧ (((marked t1)[(0 : ℕ)]! = (marked t1)[(1 : ℕ)]! ∧ (marked t1)[(1 : ℕ)]! = true) ∧ ¬(marked t1)[(2 : ℕ)]! = true) ∧ (∀(i : ℤ), (1 : ℤ) ≤ i ∧ i ≤ (BitVec.toInt max1 - (1 : ℤ)) / (2 : ℤ) → ¬(marked t1)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i ≤ (BitVec.toInt max1 + (1 : ℤ)) / (2 : ℤ) → (2 : ℤ) * i ≤ BitVec.toInt max1 → (marked t1)[Int.toNat ((2 : ℤ) * i)]! = true) ∧ (∀(i : ℤ), (1 : ℤ) ≤ i ∧ i ≤ (BitVec.toInt max1 - (1 : ℤ)) / (2 : ℤ) → (2 : ℤ) * i + (1 : ℤ) < BitVec.toInt max1 - (1 : ℤ) → (nexts t1)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = (2 : ℤ) * i + (3 : ℤ)) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i ≤ (BitVec.toInt max1 - (1 : ℤ)) / (2 : ℤ) → (2 : ℤ) * i < BitVec.toInt max1 - (1 : ℤ) → (nexts t1)[Int.toNat ((2 : ℤ) * i)]! = (2 : ℤ) * i + (1 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt max1 → (marked t1)[Int.toNat i]! = true → i < (2 : ℤ) ∨ (2 : ℤ) ∣  i) → (∀(t2 : t), ArrayInt63.size (arr t2) = ArrayInt63.size (arr t1) → (∀(n : BitVec 63), (max_arr t1 = max_arr t2 ∧ max t1 = max t2) ∧ ((3 : ℤ) ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ BitVec.toInt max1) ∧ BitVec.toInt n * BitVec.toInt n ≤ BitVec.toInt max1 ∧ EulerSieveSpec.previously_marked_multiples (marked t2) (BitVec.toInt n) ∧ EulerSieveSpec.only_multiples_marked (marked t2) (BitVec.toInt n) ∧ EulerSieveSpec.not_marked_impl_next_not_marked (marked t2) (nexts t2) (BitVec.toInt n) ∧ EulerSieveSpec.inv_remove_products (nexts t2) (marked t2) (BitVec.toInt n) → ((((3 : ℤ) ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ BitVec.toInt (max t2)) ∧ BitVec.toInt n * BitVec.toInt n ≤ BitVec.toInt (max t2)) ∧ EulerSieveSpec.inv_remove_products (nexts t2) (marked t2) (BitVec.toInt n) ∧ EulerSieveSpec.previously_marked_multiples (marked t2) (BitVec.toInt n) ∧ EulerSieveSpec.only_multiples_marked (marked t2) (BitVec.toInt n) ∧ EulerSieveSpec.not_marked_impl_next_not_marked (marked t2) (nexts t2) (BitVec.toInt n)) ∧ (∀(t3 : t), ArrayInt63.size (arr t3) = ArrayInt63.size (arr t2) → max_arr t2 = max_arr t3 ∧ max t2 = max t3 → EulerSieveSpec.inv_remove_products (nexts t3) (marked t3) (BitVec.toInt n) ∧ EulerSieveSpec.not_marked_impl_next_not_marked (marked t3) (nexts t3) ((nexts t3)[Int.toNat (BitVec.toInt n)]!) ∧ EulerSieveSpec.previously_marked_multiples (marked t3) ((nexts t3)[Int.toNat (BitVec.toInt n)]!) ∧ EulerSieveSpec.only_multiples_marked (marked t3) ((nexts t3)[Int.toNat (BitVec.toInt n)]!) → (((3 : ℤ) ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ BitVec.toInt (max t3)) ∧ BitVec.toInt n % (2 : ℤ) = (1 : ℤ)) ∧ (∀(nn : BitVec 63), ((3 : ℤ) ≤ BitVec.toInt nn ∧ BitVec.toInt nn ≤ BitVec.toInt (max t3) + (1 : ℤ)) ∧ BitVec.toInt nn = (nexts t3)[Int.toNat (BitVec.toInt n)]! ∧ (BitVec.toInt nn % (2 : ℤ) = (1 : ℤ) ∨ BitVec.toInt nn = BitVec.toInt (max t3) + (1 : ℤ)) → (¬BitVec.toInt nn = (0 : ℤ) ∧ int'63_in_bounds (Int.tdiv (BitVec.toInt max1) (BitVec.toInt nn))) ∧ (∀(o1 : BitVec 63), BitVec.toInt o1 = Int.tdiv (BitVec.toInt max1) (BitVec.toInt nn) → (if BitVec.toInt nn ≤ BitVec.toInt o1 then ((0 : ℤ) ≤ BitVec.toInt max1 + (1 : ℤ) - BitVec.toInt n ∧ BitVec.toInt max1 + (1 : ℤ) - BitVec.toInt nn < BitVec.toInt max1 + (1 : ℤ) - BitVec.toInt n) ∧ ((3 : ℤ) ≤ BitVec.toInt nn ∧ BitVec.toInt nn ≤ BitVec.toInt max1) ∧ BitVec.toInt nn * BitVec.toInt nn ≤ BitVec.toInt max1 ∧ EulerSieveSpec.previously_marked_multiples (marked t3) (BitVec.toInt nn) ∧ EulerSieveSpec.only_multiples_marked (marked t3) (BitVec.toInt nn) ∧ EulerSieveSpec.not_marked_impl_next_not_marked (marked t3) (nexts t3) (BitVec.toInt nn) ∧ EulerSieveSpec.inv_remove_products (nexts t3) (marked t3) (BitVec.toInt nn) else ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length (marked t3)) → (¬(marked t3)[Int.toNat i]! = true) = Nat.Prime (Int.toNat i))))))) ∧ (if (9 : ℤ) ≤ BitVec.toInt max1 then (((3 : ℤ) ≤ (3 : ℤ) ∧ (3 : ℤ) ≤ BitVec.toInt max1) ∧ (3 : ℤ) * (3 : ℤ) ≤ BitVec.toInt max1 ∧ EulerSieveSpec.previously_marked_multiples (marked t1) (3 : ℤ) ∧ EulerSieveSpec.only_multiples_marked (marked t1) (3 : ℤ) ∧ EulerSieveSpec.not_marked_impl_next_not_marked (marked t1) (nexts t1) (3 : ℤ) ∧ EulerSieveSpec.inv_remove_products (nexts t1) (marked t1) (3 : ℤ)) ∧ (∀(t2 : t), ArrayInt63.size (arr t2) = ArrayInt63.size (arr t1) → max_arr t1 = max_arr t2 ∧ max t1 = max t2 → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length (marked t2)) → (¬(marked t2)[Int.toNat i]! = true) = Nat.Prime (Int.toNat i)) → (let o1 : ArrayInt63.array63 := arr t2; ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length (ArrayInt63.elts o1))) ∧ (∀(t_arr : ArrayInt63.array63), ArrayInt63.size t_arr = ArrayInt63.size o1 → ArrayInt63.size t_arr = ArrayInt63.size (arr t2) → ArrayInt63.elts t_arr = List.set (ArrayInt63.elts o1) (0 : ℕ) (BitVec.toInt (2 : BitVec 63)) → (((1 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ BitVec.toInt (max_arr t2) + (1 : ℤ)) ∧ (1 : ℤ) ≤ (1 : ℤ) ∧ ((2 : ℤ) * (1 : ℤ) + (1 : ℤ) ≤ BitVec.toInt max1 → (0 : ℤ) ≤ (ArrayInt63.elts t_arr)[(1 : ℕ)]!) ∧ ((2 : ℤ) * (1 : ℤ) + (1 : ℤ) ≤ BitVec.toInt max1 → Nat.Prime (Int.toNat ((2 : ℤ) * (1 : ℤ) + (1 : ℤ)))) ∧ inv_count (ArrayInt63.elts t_arr) (1 : ℤ) ∧ EulerSieveSpec.ordered (ArrayInt63.elts t_arr) (1 : ℤ) ∧ EulerSieveSpec.all_inf_or_eq (ArrayInt63.elts t_arr) (1 : ℤ) ((2 : ℤ) * (1 : ℤ)) ∧ (∀(i : ℤ), (1 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr t2) → ((0 : ℤ) ≤ (ArrayInt63.elts t_arr)[Int.toNat i]!) = Nat.Prime (Int.toNat ((2 : ℤ) * i + (1 : ℤ)))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (1 : ℤ) → Nat.Prime (Int.toNat ((ArrayInt63.elts t_arr)[Int.toNat i]!))) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i < (2 : ℤ) * (1 : ℤ) + (1 : ℤ) → Nat.Prime (Int.toNat i) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < (1 : ℤ)) ∧ (ArrayInt63.elts t_arr)[Int.toNat j]! = i))) ∧ (∀(p : BitVec 63) (cnt : BitVec 63) (t_arr1 : ArrayInt63.array63), ArrayInt63.size t_arr1 = ArrayInt63.size t_arr → ((1 : ℤ) ≤ BitVec.toInt p ∧ BitVec.toInt p ≤ BitVec.toInt (max_arr t2) + (1 : ℤ)) ∧ ((1 : ℤ) ≤ BitVec.toInt cnt ∧ BitVec.toInt cnt ≤ BitVec.toInt p) ∧ ((2 : ℤ) * BitVec.toInt p + (1 : ℤ) ≤ BitVec.toInt max1 → (0 : ℤ) ≤ (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]!) ∧ ((2 : ℤ) * BitVec.toInt p + (1 : ℤ) ≤ BitVec.toInt max1 → Nat.Prime (Int.toNat ((2 : ℤ) * BitVec.toInt p + (1 : ℤ)))) ∧ inv_count (ArrayInt63.elts t_arr1) (BitVec.toInt cnt) ∧ EulerSieveSpec.ordered (ArrayInt63.elts t_arr1) (BitVec.toInt cnt) ∧ EulerSieveSpec.all_inf_or_eq (ArrayInt63.elts t_arr1) (BitVec.toInt cnt) ((2 : ℤ) * BitVec.toInt p) ∧ (∀(i : ℤ), BitVec.toInt cnt ≤ i ∧ i ≤ BitVec.toInt (max_arr t2) → ((0 : ℤ) ≤ (ArrayInt63.elts t_arr1)[Int.toNat i]!) = Nat.Prime (Int.toNat ((2 : ℤ) * i + (1 : ℤ)))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt cnt → Nat.Prime (Int.toNat ((ArrayInt63.elts t_arr1)[Int.toNat i]!))) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i < (2 : ℤ) * BitVec.toInt p + (1 : ℤ) → Nat.Prime (Int.toNat i) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < BitVec.toInt cnt) ∧ (ArrayInt63.elts t_arr1)[Int.toNat j]! = i)) → int'63_in_bounds ((2 : ℤ) * BitVec.toInt p) ∧ (∀(o2 : BitVec 63), BitVec.toInt o2 = (2 : ℤ) * BitVec.toInt p → int'63_in_bounds (BitVec.toInt o2 + (1 : ℤ)) ∧ (∀(o3 : BitVec 63), BitVec.toInt o3 = BitVec.toInt o2 + (1 : ℤ) → (if BitVec.toInt o3 ≤ BitVec.toInt max1 then ((0 : ℤ) ≤ BitVec.toInt p ∧ BitVec.toInt p < Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(o4 : BitVec 63), BitVec.toInt o4 = (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]! → (¬(2 : ℤ) = (0 : ℤ) ∧ int'63_in_bounds (Int.tdiv (BitVec.toInt o4) (2 : ℤ))) ∧ (∀(next : BitVec 63), BitVec.toInt next = Int.tdiv (BitVec.toInt o4) (2 : ℤ) → (if BitVec.toInt next ≤ BitVec.toInt (max_arr t2) then ((0 : ℤ) ≤ BitVec.toInt next ∧ BitVec.toInt next < Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(o5 : BitVec 63), BitVec.toInt o5 = (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt next)]! → (if BitVec.toInt o5 < (0 : ℤ) then ((0 : ℤ) ≤ BitVec.toInt next ∧ BitVec.toInt next < Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(o6 : BitVec 63), BitVec.toInt o6 = (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt next)]! → int'63_in_bounds (-BitVec.toInt o6) ∧ (∀(o7 : BitVec 63), BitVec.toInt o7 = -BitVec.toInt o6 → ((0 : ℤ) ≤ BitVec.toInt p ∧ BitVec.toInt p < Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(t_arr2 : ArrayInt63.array63), ArrayInt63.size t_arr2 = ArrayInt63.size t_arr1 → ArrayInt63.size t_arr2 = ArrayInt63.size t_arr1 → ArrayInt63.elts t_arr2 = List.set (ArrayInt63.elts t_arr1) (Int.toNat (BitVec.toInt p)) (BitVec.toInt o7) → ((0 : ℤ) ≤ BitVec.toInt (max_arr t2) + (1 : ℤ) - BitVec.toInt p ∧ BitVec.toInt (max_arr t2) + (1 : ℤ) - BitVec.toInt p < BitVec.toInt (max_arr t2) + (1 : ℤ) - BitVec.toInt p ∨ (0 : ℤ) ≤ BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]! ∧ BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr2)[Int.toNat (BitVec.toInt p)]! < BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]!) ∧ ((1 : ℤ) ≤ BitVec.toInt p ∧ BitVec.toInt p ≤ BitVec.toInt (max_arr t2) + (1 : ℤ)) ∧ ((1 : ℤ) ≤ BitVec.toInt cnt ∧ BitVec.toInt cnt ≤ BitVec.toInt p) ∧ ((2 : ℤ) * BitVec.toInt p + (1 : ℤ) ≤ BitVec.toInt max1 → (0 : ℤ) ≤ (ArrayInt63.elts t_arr2)[Int.toNat (BitVec.toInt p)]!) ∧ ((2 : ℤ) * BitVec.toInt p + (1 : ℤ) ≤ BitVec.toInt max1 → Nat.Prime (Int.toNat ((2 : ℤ) * BitVec.toInt p + (1 : ℤ)))) ∧ inv_count (ArrayInt63.elts t_arr2) (BitVec.toInt cnt) ∧ EulerSieveSpec.ordered (ArrayInt63.elts t_arr2) (BitVec.toInt cnt) ∧ EulerSieveSpec.all_inf_or_eq (ArrayInt63.elts t_arr2) (BitVec.toInt cnt) ((2 : ℤ) * BitVec.toInt p) ∧ (∀(i : ℤ), BitVec.toInt cnt ≤ i ∧ i ≤ BitVec.toInt (max_arr t2) → ((0 : ℤ) ≤ (ArrayInt63.elts t_arr2)[Int.toNat i]!) = Nat.Prime (Int.toNat ((2 : ℤ) * i + (1 : ℤ)))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt cnt → Nat.Prime (Int.toNat ((ArrayInt63.elts t_arr2)[Int.toNat i]!))) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i < (2 : ℤ) * BitVec.toInt p + (1 : ℤ) → Nat.Prime (Int.toNat i) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < BitVec.toInt cnt) ∧ (ArrayInt63.elts t_arr2)[Int.toNat j]! = i))))) else int'63_in_bounds ((2 : ℤ) * BitVec.toInt p) ∧ (∀(o6 : BitVec 63), BitVec.toInt o6 = (2 : ℤ) * BitVec.toInt p → int'63_in_bounds (BitVec.toInt o6 + (1 : ℤ)) ∧ (∀(o7 : BitVec 63), BitVec.toInt o7 = BitVec.toInt o6 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt cnt ∧ BitVec.toInt cnt < Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(t_arr2 : ArrayInt63.array63), ArrayInt63.size t_arr2 = ArrayInt63.size t_arr1 → ArrayInt63.size t_arr2 = ArrayInt63.size t_arr1 → ArrayInt63.elts t_arr2 = List.set (ArrayInt63.elts t_arr1) (Int.toNat (BitVec.toInt cnt)) (BitVec.toInt o7) → int'63_in_bounds (BitVec.toInt cnt + (1 : ℤ)) ∧ (∀(o8 : BitVec 63), BitVec.toInt o8 = BitVec.toInt cnt + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt (max_arr t2) + (1 : ℤ) - BitVec.toInt p ∧ BitVec.toInt (max_arr t2) + (1 : ℤ) - BitVec.toInt next < BitVec.toInt (max_arr t2) + (1 : ℤ) - BitVec.toInt p ∨ BitVec.toInt (max_arr t2) + (1 : ℤ) - BitVec.toInt p = BitVec.toInt (max_arr t2) + (1 : ℤ) - BitVec.toInt next ∧ (0 : ℤ) ≤ BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]! ∧ BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr2)[Int.toNat (BitVec.toInt next)]! < BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]!) ∧ ((1 : ℤ) ≤ BitVec.toInt next ∧ BitVec.toInt next ≤ BitVec.toInt (max_arr t2) + (1 : ℤ)) ∧ ((1 : ℤ) ≤ BitVec.toInt o8 ∧ BitVec.toInt o8 ≤ BitVec.toInt next) ∧ ((2 : ℤ) * BitVec.toInt next + (1 : ℤ) ≤ BitVec.toInt max1 → (0 : ℤ) ≤ (ArrayInt63.elts t_arr2)[Int.toNat (BitVec.toInt next)]!) ∧ ((2 : ℤ) * BitVec.toInt next + (1 : ℤ) ≤ BitVec.toInt max1 → Nat.Prime (Int.toNat ((2 : ℤ) * BitVec.toInt next + (1 : ℤ)))) ∧ inv_count (ArrayInt63.elts t_arr2) (BitVec.toInt o8) ∧ EulerSieveSpec.ordered (ArrayInt63.elts t_arr2) (BitVec.toInt o8) ∧ EulerSieveSpec.all_inf_or_eq (ArrayInt63.elts t_arr2) (BitVec.toInt o8) ((2 : ℤ) * BitVec.toInt next) ∧ (∀(i : ℤ), BitVec.toInt o8 ≤ i ∧ i ≤ BitVec.toInt (max_arr t2) → ((0 : ℤ) ≤ (ArrayInt63.elts t_arr2)[Int.toNat i]!) = Nat.Prime (Int.toNat ((2 : ℤ) * i + (1 : ℤ)))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt o8 → Nat.Prime (Int.toNat ((ArrayInt63.elts t_arr2)[Int.toNat i]!))) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i < (2 : ℤ) * BitVec.toInt next + (1 : ℤ) → Nat.Prime (Int.toNat i) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < BitVec.toInt o8) ∧ (ArrayInt63.elts t_arr2)[Int.toNat j]! = i)))))))) else int'63_in_bounds ((2 : ℤ) * BitVec.toInt p) ∧ (∀(o5 : BitVec 63), BitVec.toInt o5 = (2 : ℤ) * BitVec.toInt p → int'63_in_bounds (BitVec.toInt o5 + (1 : ℤ)) ∧ (∀(o6 : BitVec 63), BitVec.toInt o6 = BitVec.toInt o5 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt cnt ∧ BitVec.toInt cnt < Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(t_arr2 : ArrayInt63.array63), ArrayInt63.size t_arr2 = ArrayInt63.size t_arr1 → ArrayInt63.size t_arr2 = ArrayInt63.size t_arr1 → ArrayInt63.elts t_arr2 = List.set (ArrayInt63.elts t_arr1) (Int.toNat (BitVec.toInt cnt)) (BitVec.toInt o6) → int'63_in_bounds (BitVec.toInt cnt + (1 : ℤ)) ∧ (∀(o7 : BitVec 63), BitVec.toInt o7 = BitVec.toInt cnt + (1 : ℤ) → int'63_in_bounds (BitVec.toInt (max_arr t2) + (1 : ℤ)) ∧ (∀(o8 : BitVec 63), BitVec.toInt o8 = BitVec.toInt (max_arr t2) + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt (max_arr t2) + (1 : ℤ) - BitVec.toInt p ∧ BitVec.toInt (max_arr t2) + (1 : ℤ) - BitVec.toInt o8 < BitVec.toInt (max_arr t2) + (1 : ℤ) - BitVec.toInt p ∨ BitVec.toInt (max_arr t2) + (1 : ℤ) - BitVec.toInt p = BitVec.toInt (max_arr t2) + (1 : ℤ) - BitVec.toInt o8 ∧ (0 : ℤ) ≤ BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]! ∧ BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr2)[Int.toNat (BitVec.toInt o8)]! < BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]!) ∧ ((1 : ℤ) ≤ BitVec.toInt o8 ∧ BitVec.toInt o8 ≤ BitVec.toInt (max_arr t2) + (1 : ℤ)) ∧ ((1 : ℤ) ≤ BitVec.toInt o7 ∧ BitVec.toInt o7 ≤ BitVec.toInt o8) ∧ ((2 : ℤ) * BitVec.toInt o8 + (1 : ℤ) ≤ BitVec.toInt max1 → (0 : ℤ) ≤ (ArrayInt63.elts t_arr2)[Int.toNat (BitVec.toInt o8)]!) ∧ ((2 : ℤ) * BitVec.toInt o8 + (1 : ℤ) ≤ BitVec.toInt max1 → Nat.Prime (Int.toNat ((2 : ℤ) * BitVec.toInt o8 + (1 : ℤ)))) ∧ inv_count (ArrayInt63.elts t_arr2) (BitVec.toInt o7) ∧ EulerSieveSpec.ordered (ArrayInt63.elts t_arr2) (BitVec.toInt o7) ∧ EulerSieveSpec.all_inf_or_eq (ArrayInt63.elts t_arr2) (BitVec.toInt o7) ((2 : ℤ) * BitVec.toInt o8) ∧ (∀(i : ℤ), BitVec.toInt o7 ≤ i ∧ i ≤ BitVec.toInt (max_arr t2) → ((0 : ℤ) ≤ (ArrayInt63.elts t_arr2)[Int.toNat i]!) = Nat.Prime (Int.toNat ((2 : ℤ) * i + (1 : ℤ)))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt o7 → Nat.Prime (Int.toNat ((ArrayInt63.elts t_arr2)[Int.toNat i]!))) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i < (2 : ℤ) * BitVec.toInt o8 + (1 : ℤ) → Nat.Prime (Int.toNat i) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < BitVec.toInt o7) ∧ (ArrayInt63.elts t_arr2)[Int.toNat j]! = i)))))))))) else ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt cnt ∧ (0 : ℤ) + BitVec.toInt cnt ≤ Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(result : ArrayInt63.array63), Int.ofNat (List.length (ArrayInt63.elts result)) = BitVec.toInt cnt ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt cnt → (ArrayInt63.elts result)[Int.toNat i]! = (ArrayInt63.elts t_arr1)[Int.toNat ((0 : ℤ) + i)]!) → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length (ArrayInt63.elts result)) → (ArrayInt63.elts result)[Int.toNat i]! < (ArrayInt63.elts result)[Int.toNat j]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length (ArrayInt63.elts result)) → (2 : ℤ) ≤ (ArrayInt63.elts result)[Int.toNat i]! ∧ (ArrayInt63.elts result)[Int.toNat i]! ≤ BitVec.toInt max1) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length (ArrayInt63.elts result)) → Nat.Prime (Int.toNat ((ArrayInt63.elts result)[Int.toNat i]!))) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i ≤ BitVec.toInt max1 → Nat.Prime (Int.toNat i) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length (ArrayInt63.elts result))) ∧ (ArrayInt63.elts result)[Int.toNat j]! = i)))))))))) else let o1 : ArrayInt63.array63 := arr t1; ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length (ArrayInt63.elts o1))) ∧ (∀(t_arr : ArrayInt63.array63), ArrayInt63.size t_arr = ArrayInt63.size o1 → ArrayInt63.size t_arr = ArrayInt63.size (arr t1) → ArrayInt63.elts t_arr = List.set (ArrayInt63.elts o1) (0 : ℕ) (BitVec.toInt (2 : BitVec 63)) → (((1 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ BitVec.toInt (max_arr t1) + (1 : ℤ)) ∧ (1 : ℤ) ≤ (1 : ℤ) ∧ ((2 : ℤ) * (1 : ℤ) + (1 : ℤ) ≤ BitVec.toInt max1 → (0 : ℤ) ≤ (ArrayInt63.elts t_arr)[(1 : ℕ)]!) ∧ ((2 : ℤ) * (1 : ℤ) + (1 : ℤ) ≤ BitVec.toInt max1 → Nat.Prime (Int.toNat ((2 : ℤ) * (1 : ℤ) + (1 : ℤ)))) ∧ inv_count (ArrayInt63.elts t_arr) (1 : ℤ) ∧ EulerSieveSpec.ordered (ArrayInt63.elts t_arr) (1 : ℤ) ∧ EulerSieveSpec.all_inf_or_eq (ArrayInt63.elts t_arr) (1 : ℤ) ((2 : ℤ) * (1 : ℤ)) ∧ (∀(i : ℤ), (1 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr t1) → ((0 : ℤ) ≤ (ArrayInt63.elts t_arr)[Int.toNat i]!) = Nat.Prime (Int.toNat ((2 : ℤ) * i + (1 : ℤ)))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (1 : ℤ) → Nat.Prime (Int.toNat ((ArrayInt63.elts t_arr)[Int.toNat i]!))) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i < (2 : ℤ) * (1 : ℤ) + (1 : ℤ) → Nat.Prime (Int.toNat i) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < (1 : ℤ)) ∧ (ArrayInt63.elts t_arr)[Int.toNat j]! = i))) ∧ (∀(p : BitVec 63) (cnt : BitVec 63) (t_arr1 : ArrayInt63.array63), ArrayInt63.size t_arr1 = ArrayInt63.size t_arr → ((1 : ℤ) ≤ BitVec.toInt p ∧ BitVec.toInt p ≤ BitVec.toInt (max_arr t1) + (1 : ℤ)) ∧ ((1 : ℤ) ≤ BitVec.toInt cnt ∧ BitVec.toInt cnt ≤ BitVec.toInt p) ∧ ((2 : ℤ) * BitVec.toInt p + (1 : ℤ) ≤ BitVec.toInt max1 → (0 : ℤ) ≤ (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]!) ∧ ((2 : ℤ) * BitVec.toInt p + (1 : ℤ) ≤ BitVec.toInt max1 → Nat.Prime (Int.toNat ((2 : ℤ) * BitVec.toInt p + (1 : ℤ)))) ∧ inv_count (ArrayInt63.elts t_arr1) (BitVec.toInt cnt) ∧ EulerSieveSpec.ordered (ArrayInt63.elts t_arr1) (BitVec.toInt cnt) ∧ EulerSieveSpec.all_inf_or_eq (ArrayInt63.elts t_arr1) (BitVec.toInt cnt) ((2 : ℤ) * BitVec.toInt p) ∧ (∀(i : ℤ), BitVec.toInt cnt ≤ i ∧ i ≤ BitVec.toInt (max_arr t1) → ((0 : ℤ) ≤ (ArrayInt63.elts t_arr1)[Int.toNat i]!) = Nat.Prime (Int.toNat ((2 : ℤ) * i + (1 : ℤ)))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt cnt → Nat.Prime (Int.toNat ((ArrayInt63.elts t_arr1)[Int.toNat i]!))) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i < (2 : ℤ) * BitVec.toInt p + (1 : ℤ) → Nat.Prime (Int.toNat i) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < BitVec.toInt cnt) ∧ (ArrayInt63.elts t_arr1)[Int.toNat j]! = i)) → int'63_in_bounds ((2 : ℤ) * BitVec.toInt p) ∧ (∀(o2 : BitVec 63), BitVec.toInt o2 = (2 : ℤ) * BitVec.toInt p → int'63_in_bounds (BitVec.toInt o2 + (1 : ℤ)) ∧ (∀(o3 : BitVec 63), BitVec.toInt o3 = BitVec.toInt o2 + (1 : ℤ) → (if BitVec.toInt o3 ≤ BitVec.toInt max1 then ((0 : ℤ) ≤ BitVec.toInt p ∧ BitVec.toInt p < Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(o4 : BitVec 63), BitVec.toInt o4 = (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]! → (¬(2 : ℤ) = (0 : ℤ) ∧ int'63_in_bounds (Int.tdiv (BitVec.toInt o4) (2 : ℤ))) ∧ (∀(next : BitVec 63), BitVec.toInt next = Int.tdiv (BitVec.toInt o4) (2 : ℤ) → (if BitVec.toInt next ≤ BitVec.toInt (max_arr t1) then ((0 : ℤ) ≤ BitVec.toInt next ∧ BitVec.toInt next < Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(o5 : BitVec 63), BitVec.toInt o5 = (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt next)]! → (if BitVec.toInt o5 < (0 : ℤ) then ((0 : ℤ) ≤ BitVec.toInt next ∧ BitVec.toInt next < Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(o6 : BitVec 63), BitVec.toInt o6 = (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt next)]! → int'63_in_bounds (-BitVec.toInt o6) ∧ (∀(o7 : BitVec 63), BitVec.toInt o7 = -BitVec.toInt o6 → ((0 : ℤ) ≤ BitVec.toInt p ∧ BitVec.toInt p < Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(t_arr2 : ArrayInt63.array63), ArrayInt63.size t_arr2 = ArrayInt63.size t_arr1 → ArrayInt63.size t_arr2 = ArrayInt63.size t_arr1 → ArrayInt63.elts t_arr2 = List.set (ArrayInt63.elts t_arr1) (Int.toNat (BitVec.toInt p)) (BitVec.toInt o7) → ((0 : ℤ) ≤ BitVec.toInt (max_arr t1) + (1 : ℤ) - BitVec.toInt p ∧ BitVec.toInt (max_arr t1) + (1 : ℤ) - BitVec.toInt p < BitVec.toInt (max_arr t1) + (1 : ℤ) - BitVec.toInt p ∨ (0 : ℤ) ≤ BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]! ∧ BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr2)[Int.toNat (BitVec.toInt p)]! < BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]!) ∧ ((1 : ℤ) ≤ BitVec.toInt p ∧ BitVec.toInt p ≤ BitVec.toInt (max_arr t1) + (1 : ℤ)) ∧ ((1 : ℤ) ≤ BitVec.toInt cnt ∧ BitVec.toInt cnt ≤ BitVec.toInt p) ∧ ((2 : ℤ) * BitVec.toInt p + (1 : ℤ) ≤ BitVec.toInt max1 → (0 : ℤ) ≤ (ArrayInt63.elts t_arr2)[Int.toNat (BitVec.toInt p)]!) ∧ ((2 : ℤ) * BitVec.toInt p + (1 : ℤ) ≤ BitVec.toInt max1 → Nat.Prime (Int.toNat ((2 : ℤ) * BitVec.toInt p + (1 : ℤ)))) ∧ inv_count (ArrayInt63.elts t_arr2) (BitVec.toInt cnt) ∧ EulerSieveSpec.ordered (ArrayInt63.elts t_arr2) (BitVec.toInt cnt) ∧ EulerSieveSpec.all_inf_or_eq (ArrayInt63.elts t_arr2) (BitVec.toInt cnt) ((2 : ℤ) * BitVec.toInt p) ∧ (∀(i : ℤ), BitVec.toInt cnt ≤ i ∧ i ≤ BitVec.toInt (max_arr t1) → ((0 : ℤ) ≤ (ArrayInt63.elts t_arr2)[Int.toNat i]!) = Nat.Prime (Int.toNat ((2 : ℤ) * i + (1 : ℤ)))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt cnt → Nat.Prime (Int.toNat ((ArrayInt63.elts t_arr2)[Int.toNat i]!))) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i < (2 : ℤ) * BitVec.toInt p + (1 : ℤ) → Nat.Prime (Int.toNat i) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < BitVec.toInt cnt) ∧ (ArrayInt63.elts t_arr2)[Int.toNat j]! = i))))) else int'63_in_bounds ((2 : ℤ) * BitVec.toInt p) ∧ (∀(o6 : BitVec 63), BitVec.toInt o6 = (2 : ℤ) * BitVec.toInt p → int'63_in_bounds (BitVec.toInt o6 + (1 : ℤ)) ∧ (∀(o7 : BitVec 63), BitVec.toInt o7 = BitVec.toInt o6 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt cnt ∧ BitVec.toInt cnt < Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(t_arr2 : ArrayInt63.array63), ArrayInt63.size t_arr2 = ArrayInt63.size t_arr1 → ArrayInt63.size t_arr2 = ArrayInt63.size t_arr1 → ArrayInt63.elts t_arr2 = List.set (ArrayInt63.elts t_arr1) (Int.toNat (BitVec.toInt cnt)) (BitVec.toInt o7) → int'63_in_bounds (BitVec.toInt cnt + (1 : ℤ)) ∧ (∀(o8 : BitVec 63), BitVec.toInt o8 = BitVec.toInt cnt + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt (max_arr t1) + (1 : ℤ) - BitVec.toInt p ∧ BitVec.toInt (max_arr t1) + (1 : ℤ) - BitVec.toInt next < BitVec.toInt (max_arr t1) + (1 : ℤ) - BitVec.toInt p ∨ BitVec.toInt (max_arr t1) + (1 : ℤ) - BitVec.toInt p = BitVec.toInt (max_arr t1) + (1 : ℤ) - BitVec.toInt next ∧ (0 : ℤ) ≤ BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]! ∧ BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr2)[Int.toNat (BitVec.toInt next)]! < BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]!) ∧ ((1 : ℤ) ≤ BitVec.toInt next ∧ BitVec.toInt next ≤ BitVec.toInt (max_arr t1) + (1 : ℤ)) ∧ ((1 : ℤ) ≤ BitVec.toInt o8 ∧ BitVec.toInt o8 ≤ BitVec.toInt next) ∧ ((2 : ℤ) * BitVec.toInt next + (1 : ℤ) ≤ BitVec.toInt max1 → (0 : ℤ) ≤ (ArrayInt63.elts t_arr2)[Int.toNat (BitVec.toInt next)]!) ∧ ((2 : ℤ) * BitVec.toInt next + (1 : ℤ) ≤ BitVec.toInt max1 → Nat.Prime (Int.toNat ((2 : ℤ) * BitVec.toInt next + (1 : ℤ)))) ∧ inv_count (ArrayInt63.elts t_arr2) (BitVec.toInt o8) ∧ EulerSieveSpec.ordered (ArrayInt63.elts t_arr2) (BitVec.toInt o8) ∧ EulerSieveSpec.all_inf_or_eq (ArrayInt63.elts t_arr2) (BitVec.toInt o8) ((2 : ℤ) * BitVec.toInt next) ∧ (∀(i : ℤ), BitVec.toInt o8 ≤ i ∧ i ≤ BitVec.toInt (max_arr t1) → ((0 : ℤ) ≤ (ArrayInt63.elts t_arr2)[Int.toNat i]!) = Nat.Prime (Int.toNat ((2 : ℤ) * i + (1 : ℤ)))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt o8 → Nat.Prime (Int.toNat ((ArrayInt63.elts t_arr2)[Int.toNat i]!))) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i < (2 : ℤ) * BitVec.toInt next + (1 : ℤ) → Nat.Prime (Int.toNat i) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < BitVec.toInt o8) ∧ (ArrayInt63.elts t_arr2)[Int.toNat j]! = i)))))))) else int'63_in_bounds ((2 : ℤ) * BitVec.toInt p) ∧ (∀(o5 : BitVec 63), BitVec.toInt o5 = (2 : ℤ) * BitVec.toInt p → int'63_in_bounds (BitVec.toInt o5 + (1 : ℤ)) ∧ (∀(o6 : BitVec 63), BitVec.toInt o6 = BitVec.toInt o5 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt cnt ∧ BitVec.toInt cnt < Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(t_arr2 : ArrayInt63.array63), ArrayInt63.size t_arr2 = ArrayInt63.size t_arr1 → ArrayInt63.size t_arr2 = ArrayInt63.size t_arr1 → ArrayInt63.elts t_arr2 = List.set (ArrayInt63.elts t_arr1) (Int.toNat (BitVec.toInt cnt)) (BitVec.toInt o6) → int'63_in_bounds (BitVec.toInt cnt + (1 : ℤ)) ∧ (∀(o7 : BitVec 63), BitVec.toInt o7 = BitVec.toInt cnt + (1 : ℤ) → int'63_in_bounds (BitVec.toInt (max_arr t1) + (1 : ℤ)) ∧ (∀(o8 : BitVec 63), BitVec.toInt o8 = BitVec.toInt (max_arr t1) + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt (max_arr t1) + (1 : ℤ) - BitVec.toInt p ∧ BitVec.toInt (max_arr t1) + (1 : ℤ) - BitVec.toInt o8 < BitVec.toInt (max_arr t1) + (1 : ℤ) - BitVec.toInt p ∨ BitVec.toInt (max_arr t1) + (1 : ℤ) - BitVec.toInt p = BitVec.toInt (max_arr t1) + (1 : ℤ) - BitVec.toInt o8 ∧ (0 : ℤ) ≤ BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]! ∧ BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr2)[Int.toNat (BitVec.toInt o8)]! < BitVec.toInt max1 + (1 : ℤ) - (ArrayInt63.elts t_arr1)[Int.toNat (BitVec.toInt p)]!) ∧ ((1 : ℤ) ≤ BitVec.toInt o8 ∧ BitVec.toInt o8 ≤ BitVec.toInt (max_arr t1) + (1 : ℤ)) ∧ ((1 : ℤ) ≤ BitVec.toInt o7 ∧ BitVec.toInt o7 ≤ BitVec.toInt o8) ∧ ((2 : ℤ) * BitVec.toInt o8 + (1 : ℤ) ≤ BitVec.toInt max1 → (0 : ℤ) ≤ (ArrayInt63.elts t_arr2)[Int.toNat (BitVec.toInt o8)]!) ∧ ((2 : ℤ) * BitVec.toInt o8 + (1 : ℤ) ≤ BitVec.toInt max1 → Nat.Prime (Int.toNat ((2 : ℤ) * BitVec.toInt o8 + (1 : ℤ)))) ∧ inv_count (ArrayInt63.elts t_arr2) (BitVec.toInt o7) ∧ EulerSieveSpec.ordered (ArrayInt63.elts t_arr2) (BitVec.toInt o7) ∧ EulerSieveSpec.all_inf_or_eq (ArrayInt63.elts t_arr2) (BitVec.toInt o7) ((2 : ℤ) * BitVec.toInt o8) ∧ (∀(i : ℤ), BitVec.toInt o7 ≤ i ∧ i ≤ BitVec.toInt (max_arr t1) → ((0 : ℤ) ≤ (ArrayInt63.elts t_arr2)[Int.toNat i]!) = Nat.Prime (Int.toNat ((2 : ℤ) * i + (1 : ℤ)))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt o7 → Nat.Prime (Int.toNat ((ArrayInt63.elts t_arr2)[Int.toNat i]!))) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i < (2 : ℤ) * BitVec.toInt o8 + (1 : ℤ) → Nat.Prime (Int.toNat i) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < BitVec.toInt o7) ∧ (ArrayInt63.elts t_arr2)[Int.toNat j]! = i)))))))))) else ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt cnt ∧ (0 : ℤ) + BitVec.toInt cnt ≤ Int.ofNat (List.length (ArrayInt63.elts t_arr1))) ∧ (∀(result : ArrayInt63.array63), Int.ofNat (List.length (ArrayInt63.elts result)) = BitVec.toInt cnt ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt cnt → (ArrayInt63.elts result)[Int.toNat i]! = (ArrayInt63.elts t_arr1)[Int.toNat ((0 : ℤ) + i)]!) → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length (ArrayInt63.elts result)) → (ArrayInt63.elts result)[Int.toNat i]! < (ArrayInt63.elts result)[Int.toNat j]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length (ArrayInt63.elts result)) → (2 : ℤ) ≤ (ArrayInt63.elts result)[Int.toNat i]! ∧ (ArrayInt63.elts result)[Int.toNat i]! ≤ BitVec.toInt max1) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length (ArrayInt63.elts result)) → Nat.Prime (Int.toNat ((ArrayInt63.elts result)[Int.toNat i]!))) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i ≤ BitVec.toInt max1 → Nat.Prime (Int.toNat i) → (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length (ArrayInt63.elts result))) ∧ (ArrayInt63.elts result)[Int.toNat j]! = i))))))))))
  := sorry
end euler_sieve_EulerSieveImpl_euler_sieveqtvc
