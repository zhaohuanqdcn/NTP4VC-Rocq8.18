import Why3.Base
import Why3.why3.Ref.Ref
import pearl.vacid_0_build_maze_vcg.lean.vacid_0_build_maze.UnionFind_pure
import pearl.vacid_0_build_maze_vcg.lean.vacid_0_build_maze.UnionFind_sig
import pearl.vacid_0_build_maze_vcg.lean.vacid_0_build_maze.Graph_sig
open Classical
open Lean4Why3
namespace vacid_0_build_maze_BuildMaze_build_mazeqtvc
theorem build_maze'vc (n : ℤ) (graph : Graph_sig.graph) (fact0 : (1 : ℤ) ≤ n) (fact1 : ∀(x : ℤ) (y : ℤ), (x = y) = Graph_sig.path graph x y) : let o1 : ℤ := n * n; (0 : ℤ) ≤ o1 ∧ (∀(u : UnionFind_sig.uf), UnionFind_pure.num (UnionFind_sig.state u) = o1 ∧ UnionFind_pure.size (UnionFind_sig.state u) = o1 ∧ (∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < o1 → UnionFind_pure.repr (UnionFind_sig.state u) x x) → ((1 : ℤ) ≤ UnionFind_pure.num (UnionFind_sig.state u) ∧ (UnionFind_pure.num (UnionFind_sig.state u) + (0 : ℤ) = UnionFind_pure.size (UnionFind_sig.state u) ∧ UnionFind_pure.size (UnionFind_sig.state u) = n * n) ∧ (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n * n → (0 : ℤ) ≤ y ∧ y < n * n → UnionFind_pure.same (UnionFind_sig.state u) x y = Graph_sig.path graph x y)) ∧ (∀(u1 : UnionFind_sig.uf) (num_edges : ℤ) (graph1 : Graph_sig.graph), (1 : ℤ) ≤ UnionFind_pure.num (UnionFind_sig.state u1) ∧ (UnionFind_pure.num (UnionFind_sig.state u1) + num_edges = UnionFind_pure.size (UnionFind_sig.state u1) ∧ UnionFind_pure.size (UnionFind_sig.state u1) = n * n) ∧ (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n * n → (0 : ℤ) ≤ y ∧ y < n * n → UnionFind_pure.same (UnionFind_sig.state u1) x y = Graph_sig.path graph1 x y) → (if (1 : ℤ) < UnionFind_pure.num (UnionFind_sig.state u1) then (0 : ℤ) < n ∧ (∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) < n ∧ (∀(y : ℤ), (0 : ℤ) ≤ y ∧ y < n → (0 : ℤ) < (2 : ℤ) ∧ (∀(d : ℤ), (0 : ℤ) ≤ d ∧ d < (2 : ℤ) → (∀(w : ℤ), (if d = (0 : ℤ) then w = x + (1 : ℤ) else w = x) → (∀(z : ℤ), (if d = (0 : ℤ) then z = y else z = y + (1 : ℤ)) → (∀(o2 : Bool), (if w < n then o2 = (if z < n then true else false) else o2 = false) → (if o2 = true then let a : ℤ := y * n + x; let b : ℤ := w * n + z; ((0 : ℤ) ≤ b ∧ b < UnionFind_pure.size (UnionFind_sig.state u1)) ∧ (∀(u2 : UnionFind_sig.uf) (o3 : ℤ), UnionFind_pure.repr (UnionFind_sig.state u2) b o3 ∧ UnionFind_pure.size (UnionFind_sig.state u2) = UnionFind_pure.size (UnionFind_sig.state u1) ∧ UnionFind_pure.num (UnionFind_sig.state u2) = UnionFind_pure.num (UnionFind_sig.state u1) ∧ UnionFind_pure.same_reprs (UnionFind_sig.state u2) (UnionFind_sig.state u1) → ((0 : ℤ) ≤ a ∧ a < UnionFind_pure.size (UnionFind_sig.state u2)) ∧ (∀(u3 : UnionFind_sig.uf) (o4 : ℤ), UnionFind_pure.repr (UnionFind_sig.state u3) a o4 ∧ UnionFind_pure.size (UnionFind_sig.state u3) = UnionFind_pure.size (UnionFind_sig.state u2) ∧ UnionFind_pure.num (UnionFind_sig.state u3) = UnionFind_pure.num (UnionFind_sig.state u2) ∧ UnionFind_pure.same_reprs (UnionFind_sig.state u3) (UnionFind_sig.state u2) → (if ¬o4 = o3 then (((0 : ℤ) ≤ a ∧ a < UnionFind_pure.size (UnionFind_sig.state u3)) ∧ ((0 : ℤ) ≤ b ∧ b < UnionFind_pure.size (UnionFind_sig.state u3)) ∧ ¬UnionFind_pure.same (UnionFind_sig.state u3) a b ∧ ¬Graph_sig.path graph1 a b ∧ (∀(x1 : ℤ) (y1 : ℤ), (0 : ℤ) ≤ x1 ∧ x1 < UnionFind_pure.size (UnionFind_sig.state u3) → (0 : ℤ) ≤ y1 ∧ y1 < UnionFind_pure.size (UnionFind_sig.state u3) → UnionFind_pure.same (UnionFind_sig.state u3) x1 y1 = Graph_sig.path graph1 x1 y1)) ∧ (∀(u4 : UnionFind_sig.uf) (graph2 : Graph_sig.graph), UnionFind_pure.same (UnionFind_sig.state u4) a b ∧ UnionFind_pure.size (UnionFind_sig.state u4) = UnionFind_pure.size (UnionFind_sig.state u3) ∧ UnionFind_pure.num (UnionFind_sig.state u4) = UnionFind_pure.num (UnionFind_sig.state u3) - (1 : ℤ) ∧ (∀(x1 : ℤ) (y1 : ℤ), (0 : ℤ) ≤ x1 ∧ x1 < UnionFind_pure.size (UnionFind_sig.state u4) → (0 : ℤ) ≤ y1 ∧ y1 < UnionFind_pure.size (UnionFind_sig.state u4) → UnionFind_pure.same (UnionFind_sig.state u4) x1 y1 = Graph_sig.path graph2 x1 y1) → (1 : ℤ) ≤ UnionFind_pure.num (UnionFind_sig.state u4) ∧ (UnionFind_pure.num (UnionFind_sig.state u4) + (num_edges + (1 : ℤ)) = UnionFind_pure.size (UnionFind_sig.state u4) ∧ UnionFind_pure.size (UnionFind_sig.state u4) = n * n) ∧ (∀(x1 : ℤ) (y1 : ℤ), (0 : ℤ) ≤ x1 ∧ x1 < n * n → (0 : ℤ) ≤ y1 ∧ y1 < n * n → UnionFind_pure.same (UnionFind_sig.state u4) x1 y1 = Graph_sig.path graph2 x1 y1)) else (1 : ℤ) ≤ UnionFind_pure.num (UnionFind_sig.state u3) ∧ (UnionFind_pure.num (UnionFind_sig.state u3) + num_edges = UnionFind_pure.size (UnionFind_sig.state u3) ∧ UnionFind_pure.size (UnionFind_sig.state u3) = n * n) ∧ (∀(x1 : ℤ) (y1 : ℤ), (0 : ℤ) ≤ x1 ∧ x1 < n * n → (0 : ℤ) ≤ y1 ∧ y1 < n * n → UnionFind_pure.same (UnionFind_sig.state u3) x1 y1 = Graph_sig.path graph1 x1 y1)))) else (1 : ℤ) ≤ UnionFind_pure.num (UnionFind_sig.state u1) ∧ (UnionFind_pure.num (UnionFind_sig.state u1) + num_edges = UnionFind_pure.size (UnionFind_sig.state u1) ∧ UnionFind_pure.size (UnionFind_sig.state u1) = n * n) ∧ (∀(x1 : ℤ) (y1 : ℤ), (0 : ℤ) ≤ x1 ∧ x1 < n * n → (0 : ℤ) ≤ y1 ∧ y1 < n * n → UnionFind_pure.same (UnionFind_sig.state u1) x1 y1 = Graph_sig.path graph1 x1 y1)))))))) else num_edges = n * n - (1 : ℤ) ∧ (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n * n → (0 : ℤ) ≤ y ∧ y < n * n → Graph_sig.path graph1 x y))))
  := sorry
end vacid_0_build_maze_BuildMaze_build_mazeqtvc
