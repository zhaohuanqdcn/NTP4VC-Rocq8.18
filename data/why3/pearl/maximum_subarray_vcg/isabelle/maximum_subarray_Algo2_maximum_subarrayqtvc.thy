theory maximum_subarray_Algo2_maximum_subarrayqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_Sum" "./maximum_subarray_Spec"
begin
theorem maximum_subarray'vc:
  fixes a :: "int list"
  shows "let n :: int = int (length a); o1 :: int = n - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (0 :: int)) \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> n) \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) = sum_list (drop (0 :: nat) (take ((0 :: nat) - (0 :: nat)) a))) \<and> maxsublo a (0 :: int) (0 :: int)) \<and> (\<forall>(ms :: int) (hi :: int) (lo :: int). (\<forall>(l :: int). ((0 :: int) \<le> l \<and> l \<le> o1) \<and> (((0 :: int) \<le> lo \<and> lo \<le> l) \<and> (lo \<le> hi \<and> hi \<le> n) \<and> (0 :: int) \<le> ms \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> maxsublo a l ms \<longrightarrow> (let o2 :: int = l + (1 :: int) in (o2 \<le> n + (1 :: int) \<longrightarrow> ((((0 :: int) \<le> lo \<and> lo \<le> l) \<and> (lo \<le> hi \<and> hi \<le> n) \<and> (0 :: int) \<le> ms \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> maxsublo a l ms \<and> (\<forall>(h' :: int). l \<le> h' \<and> h' < o2 \<longrightarrow> sum_list (drop (nat l) (take (nat h' - nat l) a)) \<le> ms) \<and> (0 :: int) = sum_list (drop (nat l) (take (nat (o2 - (1 :: int)) - nat l) a))) \<and> (\<forall>(s :: int) (ms1 :: int) (hi1 :: int) (lo1 :: int). (\<forall>(h :: int). (o2 \<le> h \<and> h \<le> n) \<and> (((0 :: int) \<le> lo1 \<and> lo1 \<le> l) \<and> (lo1 \<le> hi1 \<and> hi1 \<le> n) \<and> (0 :: int) \<le> ms1 \<and> ms1 = sum_list (drop (nat lo1) (take (nat hi1 - nat lo1) a))) \<and> maxsublo a l ms1 \<and> (\<forall>(h' :: int). l \<le> h' \<and> h' < h \<longrightarrow> sum_list (drop (nat l) (take (nat h' - nat l) a)) \<le> ms1) \<and> s = sum_list (drop (nat l) (take (nat (h - (1 :: int)) - nat l) a)) \<longrightarrow> (let o3 :: int = h - (1 :: int) in ((0 :: int) \<le> o3 \<and> o3 < int (length a)) \<and> (if ms1 < s + a ! nat o3 then (((0 :: int) \<le> l \<and> l \<le> l) \<and> (l \<le> h \<and> h \<le> n) \<and> (0 :: int) \<le> s + a ! nat o3 \<and> s + a ! nat o3 = sum_list (drop (nat l) (take (nat h - nat l) a))) \<and> maxsublo a l (s + a ! nat o3) \<and> (\<forall>(h' :: int). l \<le> h' \<and> h' < h + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h' - nat l) a)) \<le> s + a ! nat o3) \<and> s + a ! nat o3 = sum_list (drop (nat l) (take (nat (h + (1 :: int) - (1 :: int)) - nat l) a)) else (((0 :: int) \<le> lo1 \<and> lo1 \<le> l) \<and> (lo1 \<le> hi1 \<and> hi1 \<le> n) \<and> (0 :: int) \<le> ms1 \<and> ms1 = sum_list (drop (nat lo1) (take (nat hi1 - nat lo1) a))) \<and> maxsublo a l ms1 \<and> (\<forall>(h' :: int). l \<le> h' \<and> h' < h + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h' - nat l) a)) \<le> ms1) \<and> s + a ! nat o3 = sum_list (drop (nat l) (take (nat (h + (1 :: int) - (1 :: int)) - nat l) a))))) \<and> ((((0 :: int) \<le> lo1 \<and> lo1 \<le> l) \<and> (lo1 \<le> hi1 \<and> hi1 \<le> n) \<and> (0 :: int) \<le> ms1 \<and> ms1 = sum_list (drop (nat lo1) (take (nat hi1 - nat lo1) a))) \<and> maxsublo a l ms1 \<and> (\<forall>(h' :: int). l \<le> h' \<and> h' < n + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h' - nat l) a)) \<le> ms1) \<and> s = sum_list (drop (nat l) (take (nat (n + (1 :: int) - (1 :: int)) - nat l) a)) \<longrightarrow> (((0 :: int) \<le> lo1 \<and> lo1 \<le> l + (1 :: int)) \<and> (lo1 \<le> hi1 \<and> hi1 \<le> n) \<and> (0 :: int) \<le> ms1 \<and> ms1 = sum_list (drop (nat lo1) (take (nat hi1 - nat lo1) a))) \<and> maxsublo a (l + (1 :: int)) ms1))) \<and> (n + (1 :: int) < o2 \<longrightarrow> (((0 :: int) \<le> lo \<and> lo \<le> l + (1 :: int)) \<and> (lo \<le> hi \<and> hi \<le> n) \<and> (0 :: int) \<le> ms \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> maxsublo a (l + (1 :: int)) ms))) \<and> ((((0 :: int) \<le> lo \<and> lo \<le> o1 + (1 :: int)) \<and> (lo \<le> hi \<and> hi \<le> n) \<and> (0 :: int) \<le> ms \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> maxsublo a (o1 + (1 :: int)) ms \<longrightarrow> (((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> int (length a)) \<and> ms = sum_list (drop (nat lo) (take (nat hi - nat lo) a))) \<and> maxsub a ms))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> int (length a)) \<and> (0 :: int) = sum_list (drop (0 :: nat) (take ((0 :: nat) - (0 :: nat)) a))) \<and> maxsub a (0 :: int))"
  sorry
end
