import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace split_string_SplitString_split_stringqtvc
axiom char : Type
axiom inhabited_axiom_char : Inhabited char
attribute [instance] inhabited_axiom_char
axiom string' : Type
axiom inhabited_axiom_string' : Inhabited string'
attribute [instance] inhabited_axiom_string'
axiom concat : List (List char) -> char -> List char
axiom concat'def (ss : List (List char)) (sep : char) (fact0 : (1 : ℤ) ≤ Int.ofNat (List.length ss)) : if Int.ofNat (List.length ss) = (1 : ℤ) then concat ss sep = ss[(0 : ℕ)]! else concat ss sep = concat (List.drop (0 : ℕ) (List.take (Int.toNat (Int.ofNat (List.length ss) - (1 : ℤ)) - (0 : ℕ)) ss)) sep ++ List.cons sep (ss[Int.toNat (Int.ofNat (List.length ss) - (1 : ℤ))]!)
noncomputable def notin (sep : char) (s : List char) := ¬sep ∈ s
theorem split_string'vc (limit : ℤ) (s : List char) (sep : char) (fact0 : limit = -(1 : ℤ) ∨ (1 : ℤ) ≤ limit) : if limit = (1 : ℤ) then let r : List (List char) := [s]; Int.ofNat (List.length r) = (1 : ℤ) ∧ r[(0 : ℕ)]! = s → (1 : ℤ) ≤ Int.ofNat (List.length r) ∧ (limit = -(1 : ℤ) ∨ Int.ofNat (List.length r) ≤ limit) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length r) - (1 : ℤ) → notin sep (r[Int.toNat j]!)) ∧ (Int.ofNat (List.length r) = limit ∨ notin sep (r[Int.toNat (Int.ofNat (List.length r) - (1 : ℤ))]!)) ∧ concat r sep = s else (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length s)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length ([] : List (List char))) → notin sep (([] : List (List char))[Int.toNat j]!)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → ¬s[Int.toNat j]! = sep) ∧ (limit = -(1 : ℤ) ∨ Int.ofNat (List.length ([] : List (List char))) < limit - (1 : ℤ)) ∧ concat (([] : List (List char)) ++ [List.drop (0 : ℕ) s]) sep = s) ∧ (∀(b : ℤ) (i : ℤ) (ss : List (List char)), ((0 : ℤ) ≤ b ∧ b ≤ i ∧ i ≤ Int.ofNat (List.length s)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length ss) → notin sep (ss[Int.toNat j]!)) ∧ (∀(j : ℤ), b ≤ j ∧ j < i → ¬s[Int.toNat j]! = sep) ∧ (limit = -(1 : ℤ) ∨ Int.ofNat (List.length ss) < limit - (1 : ℤ)) ∧ concat (ss ++ [List.drop (Int.toNat b) s]) sep = s → (if i < Int.ofNat (List.length s) then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s)) ∧ (if s[Int.toNat i]! = sep then ((0 : ℤ) ≤ b ∧ b ≤ i ∧ i ≤ Int.ofNat (List.length s)) ∧ (let o1 : List char := List.drop (Int.toNat b) (List.take (Int.toNat i - Int.toNat b) s); Int.ofNat (List.length o1) = i - b ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i - b → o1[Int.toNat k]! = s[Int.toNat (b + k)]!) → (let o2 : List (List char) := ss ++ [o1]; Int.ofNat (List.length o2) = (1 : ℤ) + Int.ofNat (List.length ss) ∧ o2[List.length ss]! = o1 ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length ss) → o2[Int.toNat i1]! = ss[Int.toNat i1]!) → (if Int.ofNat (List.length o2) = limit - (1 : ℤ) then let o3 : ℤ := i + (1 : ℤ); ((0 : ℤ) ≤ o3 ∧ o3 ≤ Int.ofNat (List.length s)) ∧ (let o4 : List char := List.drop (Int.toNat o3) s; let r : List (List char) := o2 ++ [o4]; Int.ofNat (List.length r) = (1 : ℤ) + Int.ofNat (List.length o2) ∧ r[List.length o2]! = o4 ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length o2) → r[Int.toNat i1]! = o2[Int.toNat i1]!) → (1 : ℤ) ≤ Int.ofNat (List.length r) ∧ (limit = -(1 : ℤ) ∨ Int.ofNat (List.length r) ≤ limit) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length r) - (1 : ℤ) → notin sep (r[Int.toNat j]!)) ∧ (Int.ofNat (List.length r) = limit ∨ notin sep (r[Int.toNat (Int.ofNat (List.length r) - (1 : ℤ))]!)) ∧ concat r sep = s) else ((0 : ℤ) ≤ Int.ofNat (List.length s) - i ∧ Int.ofNat (List.length s) - (i + (1 : ℤ)) < Int.ofNat (List.length s) - i) ∧ ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ Int.ofNat (List.length s)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length o2) → notin sep (o2[Int.toNat j]!)) ∧ (∀(j : ℤ), i + (1 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → ¬s[Int.toNat j]! = sep) ∧ (limit = -(1 : ℤ) ∨ Int.ofNat (List.length o2) < limit - (1 : ℤ)) ∧ concat (o2 ++ [List.drop (Int.toNat (i + (1 : ℤ))) s]) sep = s))) else ((0 : ℤ) ≤ Int.ofNat (List.length s) - i ∧ Int.ofNat (List.length s) - (i + (1 : ℤ)) < Int.ofNat (List.length s) - i) ∧ ((0 : ℤ) ≤ b ∧ b ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ Int.ofNat (List.length s)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length ss) → notin sep (ss[Int.toNat j]!)) ∧ (∀(j : ℤ), b ≤ j ∧ j < i + (1 : ℤ) → ¬s[Int.toNat j]! = sep) ∧ (limit = -(1 : ℤ) ∨ Int.ofNat (List.length ss) < limit - (1 : ℤ)) ∧ concat (ss ++ [List.drop (Int.toNat b) s]) sep = s) else ((0 : ℤ) ≤ b ∧ b ≤ Int.ofNat (List.length s)) ∧ (let o1 : List char := List.drop (Int.toNat b) s; let r : List (List char) := ss ++ [o1]; Int.ofNat (List.length r) = (1 : ℤ) + Int.ofNat (List.length ss) ∧ r[List.length ss]! = o1 ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length ss) → r[Int.toNat i1]! = ss[Int.toNat i1]!) → (1 : ℤ) ≤ Int.ofNat (List.length r) ∧ (limit = -(1 : ℤ) ∨ Int.ofNat (List.length r) ≤ limit) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length r) - (1 : ℤ) → notin sep (r[Int.toNat j]!)) ∧ (Int.ofNat (List.length r) = limit ∨ notin sep (r[Int.toNat (Int.ofNat (List.length r) - (1 : ℤ))]!)) ∧ concat r sep = s)))
  := sorry
end split_string_SplitString_split_stringqtvc
