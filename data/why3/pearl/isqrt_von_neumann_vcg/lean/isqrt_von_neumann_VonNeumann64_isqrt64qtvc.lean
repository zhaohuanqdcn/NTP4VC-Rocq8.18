import Why3.Base
import Why3.why3.WellFounded.WellFounded
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace isqrt_von_neumann_VonNeumann64_isqrt64qtvc
noncomputable def sqr (x : BitVec 64) := x * x
noncomputable def is_pow2 (x : BitVec 64) (n : BitVec 64) := x &&& ((1 : BitVec 64) <<< BitVec.toNat n) - (1 : BitVec 64) = (0 : BitVec 64)
theorem isqrt64'vc (x : BitVec 64) : (32 : BitVec 64) ≤ (32 : BitVec 64) ∧ (2147483648 : BitVec 64) = (if (32 : BitVec 64) = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat ((32 : BitVec 64) - (1 : BitVec 64))) ∧ (4611686018427387904 : BitVec 64) = sqr (2147483648 : BitVec 64) ∧ is_pow2 (0 : BitVec 64) (32 : BitVec 64) ∧ (0 : BitVec 64) < (4294967296 : BitVec 64) ∧ (0 : BitVec 64) = (0 : BitVec 64) * ((1 : BitVec 64) <<< BitVec.toNat (32 : BitVec 64)) ∧ x ≤ x ∧ x - x = sqr (0 : BitVec 64) ∧ (0 : BitVec 64) + ((1 : BitVec 64) <<< BitVec.toNat (32 : BitVec 64)) ≤ (4294967296 : BitVec 64) ∧ x ≤ sqr ((0 : BitVec 64) + ((1 : BitVec 64) <<< BitVec.toNat (32 : BitVec 64))) - (1 : BitVec 64) ∧ (∀(res_g : BitVec 64) (m : BitVec 64) (num : BitVec 64), m ≤ (32 : BitVec 64) ∧ is_pow2 res_g m ∧ res_g < (4294967296 : BitVec 64) ∧ num ≤ x ∧ x - num = sqr res_g ∧ res_g + ((1 : BitVec 64) <<< BitVec.toNat m) ≤ (4294967296 : BitVec 64) ∧ x ≤ sqr (res_g + ((1 : BitVec 64) <<< BitVec.toNat m)) - (1 : BitVec 64) → (if ¬sqr (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) = (0 : BitVec 64) then let b : BitVec 64 := res_g * ((1 : BitVec 64) <<< BitVec.toNat m) ||| sqr (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))); if num ≥ b then BitVec.toUInt (sqr (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) >>> BitVec.toNat (2 : BitVec 64)) < BitVec.toUInt (sqr (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64)))) ∧ m - (1 : BitVec 64) ≤ (32 : BitVec 64) ∧ (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) >>> BitVec.toNat (1 : BitVec 64) = (if m - (1 : BitVec 64) = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64) - (1 : BitVec 64))) ∧ sqr (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) >>> BitVec.toNat (2 : BitVec 64) = sqr ((if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) >>> BitVec.toNat (1 : BitVec 64)) ∧ is_pow2 (res_g + (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64)))) (m - (1 : BitVec 64)) ∧ res_g + (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) < (4294967296 : BitVec 64) ∧ res_g * ((1 : BitVec 64) <<< BitVec.toNat m) >>> BitVec.toNat (1 : BitVec 64) ||| sqr (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) = (res_g + (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64)))) * ((1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) ∧ num - b ≤ x ∧ x - (num - b) = sqr (res_g + (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64)))) ∧ res_g + (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) + ((1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) ≤ (4294967296 : BitVec 64) ∧ x ≤ sqr (res_g + (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) + ((1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64)))) - (1 : BitVec 64) else BitVec.toUInt (sqr (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) >>> BitVec.toNat (2 : BitVec 64)) < BitVec.toUInt (sqr (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64)))) ∧ m - (1 : BitVec 64) ≤ (32 : BitVec 64) ∧ (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) >>> BitVec.toNat (1 : BitVec 64) = (if m - (1 : BitVec 64) = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64) - (1 : BitVec 64))) ∧ sqr (if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) >>> BitVec.toNat (2 : BitVec 64) = sqr ((if m = (0 : BitVec 64) then (0 : BitVec 64) else (1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) >>> BitVec.toNat (1 : BitVec 64)) ∧ is_pow2 res_g (m - (1 : BitVec 64)) ∧ res_g < (4294967296 : BitVec 64) ∧ res_g * ((1 : BitVec 64) <<< BitVec.toNat m) >>> BitVec.toNat (1 : BitVec 64) = res_g * ((1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) ∧ num ≤ x ∧ x - num = sqr res_g ∧ res_g + ((1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64))) ≤ (4294967296 : BitVec 64) ∧ x ≤ sqr (res_g + ((1 : BitVec 64) <<< BitVec.toNat (m - (1 : BitVec 64)))) - (1 : BitVec 64) else sqr (res_g * ((1 : BitVec 64) <<< BitVec.toNat m)) ≤ x ∧ x ≤ sqr (res_g * ((1 : BitVec 64) <<< BitVec.toNat m) + (1 : BitVec 64)) - (1 : BitVec 64)))
  := sorry
end isqrt_von_neumann_VonNeumann64_isqrt64qtvc
