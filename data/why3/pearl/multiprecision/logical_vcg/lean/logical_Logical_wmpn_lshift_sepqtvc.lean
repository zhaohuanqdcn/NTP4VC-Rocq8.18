import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.ptralias.Alias
open Classical
open Lean4Why3
namespace logical_Logical_wmpn_lshift_sepqtvc
theorem wmpn_lshift_sep'vc (cnt : BitVec 64) (r : C.ptr (BitVec 64)) (sz : BitVec 32) (x : C.ptr (BitVec 64)) (fact0 : (0 : ℤ) < BitVec.toUInt cnt) (fact1 : BitVec.toUInt cnt < (64 : ℤ)) (fact2 : C.valid r (BitVec.toInt sz)) (fact3 : C.valid x (BitVec.toInt sz)) (fact4 : C.writable r = true) (fact5 : (0 : ℤ) < BitVec.toInt sz) : C.valid r (BitVec.toInt sz) ∧ C.valid x (BitVec.toInt sz) ∧ (0 : ℤ) ≤ BitVec.toInt sz ∧ C.writable r = true ∧ (∀(x1 : C.ptr (BitVec 64)) (r1 : C.ptr (BitVec 64)), C.offset x1 = C.offset x ∧ C.writable x1 = C.writable x ∧ C.zone1 x1 = C.zone1 x → C.offset r1 = C.offset r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → (∀(nr : C.ptr (BitVec 64)) (nx : C.ptr (BitVec 64)) (m : Alias.mem), C.writable nr = true ∧ Lemmas.value nx (BitVec.toInt sz) = Lemmas.value x (BitVec.toInt sz) ∧ (C.valid nr (BitVec.toInt sz) ∧ C.valid nx (BitVec.toInt sz)) ∧ ((0 : ℤ) ≤ C.offset nx ∧ C.offset nx + BitVec.toInt sz ≤ C.offset nr) ∧ (Alias.zr m = C.zone1 r1 ∧ Alias.zx m = C.zone1 x1) ∧ (BitVec.toInt (Alias.mr m) = C.max r ∧ BitVec.toInt (Alias.mx m) = C.max x) ∧ (Alias.lr m = Alias.lx m ∧ Alias.lx m = sz) ∧ Alias.ok m = true ∧ Lemmas.map_eq_sub_shift (C.pelts nx) (C.pelts x1) (C.offset nx) (C.offset x1) (BitVec.toInt sz) ∧ Lemmas.map_eq_sub_shift (C.pelts nr) (C.pelts r1) (C.offset nr) (C.offset r1) (BitVec.toInt sz) ∧ (C.pelts r1 = C.pelts r ∧ C.pelts x1 = C.pelts x) ∧ (C.plength r1 = C.plength r ∧ C.plength x1 = C.plength x) ∧ (C.min r1 = C.min r ∧ C.min x1 = C.min x) ∧ C.data nr = C.data nx → (((0 : ℤ) < BitVec.toUInt cnt ∧ BitVec.toUInt cnt < (64 : ℤ)) ∧ C.valid nr (BitVec.toInt sz) ∧ C.valid nx (BitVec.toInt sz) ∧ C.writable nr = true ∧ (0 : ℤ) < BitVec.toInt sz ∧ (C.offset nx ≤ C.offset nr ∨ C.offset nr + BitVec.toInt sz ≤ C.offset nx)) ∧ (∀(nx1 : C.ptr (BitVec 64)) (nr1 : C.ptr (BitVec 64)), C.data nx1 = C.data nr1 ∧ List.length (C.data nr1) = List.length (C.data nx) ∧ C.offset nx1 = C.offset nx ∧ C.min nx1 = C.min nx ∧ C.max nx1 = C.max nx ∧ C.writable nx1 = C.writable nx ∧ C.zone1 nx1 = C.zone1 nx → List.length (C.data nr1) = List.length (C.data nr) ∧ C.offset nr1 = C.offset nr ∧ C.min nr1 = C.min nr ∧ C.max nr1 = C.max nr ∧ C.writable nr1 = C.writable nr ∧ C.zone1 nr1 = C.zone1 nr → (∀(res : BitVec 64), Lemmas.value nr1 (BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz)) * BitVec.toUInt res = Lemmas.value nx (BitVec.toInt sz) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) ∧ (∀(j : ℤ), j < C.offset nr1 ∨ C.offset nr1 + BitVec.toInt sz ≤ j → C.pelts nr1 j = C.pelts nr j) ∧ (C.min nr1 = C.min nr ∧ C.max nr1 = C.max nr ∧ C.plength nr1 = C.plength nr) ∧ C.min nx1 = C.min nx ∧ C.max nx1 = C.max nx ∧ C.plength nx1 = C.plength nx → ((C.writable r1 = true ∧ C.writable nr1 = true) ∧ Alias.ok m = true ∧ (0 : ℤ) ≤ BitVec.toInt sz ∧ ((0 : ℤ) ≤ C.offset nx1 ∧ C.offset nx1 + BitVec.toInt sz ≤ C.offset nr1) ∧ (Alias.zx m = C.zone1 x1 ∧ Alias.zr m = C.zone1 r1) ∧ Alias.lx m = Alias.lr m ∧ Alias.lr m = sz) ∧ (∀(m1 : Alias.mem) (nx2 : C.ptr (BitVec 64)) (nr2 : C.ptr (BitVec 64)) (x2 : C.ptr (BitVec 64)) (r2 : C.ptr (BitVec 64)), Alias.zr m1 = Alias.zr m ∧ Alias.zx m1 = Alias.zx m ∧ Alias.zy m1 = Alias.zy m ∧ Alias.mr m1 = Alias.mr m ∧ Alias.mx m1 = Alias.mx m ∧ Alias.my m1 = Alias.my m ∧ Alias.lr m1 = Alias.lr m ∧ Alias.lx m1 = Alias.lx m ∧ Alias.ly m1 = Alias.ly m → C.offset nx2 = C.offset nx1 ∧ C.writable nx2 = C.writable nx1 ∧ C.zone1 nx2 = C.zone1 nx1 → C.offset nr2 = C.offset nr1 ∧ C.writable nr2 = C.writable nr1 ∧ C.zone1 nr2 = C.zone1 nr1 → C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → (C.max x2 = BitVec.toInt (Alias.mx m1) ∧ C.max r2 = BitVec.toInt (Alias.mr m1)) ∧ Lemmas.map_eq_sub_shift (C.pelts nx1) (C.pelts x2) (C.offset nx2) (C.offset x2) (BitVec.toInt sz) ∧ Lemmas.map_eq_sub_shift (C.pelts nr1) (C.pelts r2) (C.offset nr2) (C.offset r2) (BitVec.toInt sz) ∧ (∀(j : ℤ), j < C.offset x2 ∨ C.offset x2 + BitVec.toInt sz ≤ j → C.pelts x2 j = C.pelts x1 j) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sz ≤ j → C.pelts r2 j = C.pelts r1 j) ∧ (C.plength x2 = C.plength x1 ∧ C.plength r2 = C.plength r1) ∧ C.min r2 = C.min r1 ∧ C.min x2 = C.min x1 → Lemmas.value r2 (BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz)) * BitVec.toUInt res = Lemmas.value x (BitVec.toInt sz) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sz ≤ j → C.pelts r2 j = C.pelts r j) ∧ (∀(j : ℤ), C.pelts x2 j = C.pelts x j) ∧ (C.min r2 = C.min r ∧ C.max r2 = C.max r ∧ C.plength r2 = C.plength r) ∧ C.min x2 = C.min x ∧ C.max x2 = C.max x ∧ C.plength x2 = C.plength x)))))
  := sorry
end logical_Logical_wmpn_lshift_sepqtvc
