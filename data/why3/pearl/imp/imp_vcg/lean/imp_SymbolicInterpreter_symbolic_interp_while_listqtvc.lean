import Why3.Base
import pearl.imp.lib.lean.imp.Syntax
import pearl.imp.lib.lean.imp.ConcreteSemantics
import pearl.imp.lib.lean.imp.Svar
import pearl.imp.lib.lean.imp.Constraint
import pearl.imp.lib.lean.imp.SymState
import pearl.imp.lib.lean.imp.FreshSvar
import pearl.imp.lib.lean.imp.SymStateSet
open Classical
open Lean4Why3
namespace imp_SymbolicInterpreter_symbolic_interp_while_listqtvc
axiom compose : (Svar.svar -> ℤ) -> Constraint.t -> Syntax.program_var -> Option ℤ
axiom compose'def (rho : Svar.svar -> ℤ) (sigma : Constraint.t) (x : Syntax.program_var) : compose rho sigma x = (match Constraint.get sigma x with | Option.some v => Option.some (rho v) | Option.none => Option.none)
noncomputable def state_extends (s : SymState.sym_state) (s' : SymState.sym_state) := Svar.to_fset (SymState.vars s) ⊆ Svar.to_fset (SymState.vars s') ∧ (∀(v : Svar.svar), v ∈ Svar.to_fset (SymState.vars s) → SymState.rho s v = SymState.rho s' v)
axiom svar_set_add : Svar.svar -> Svar.set -> Svar.set
axiom svar_set_add'def (v : Svar.svar) (vs : Svar.set) : Svar.to_fset (svar_set_add v vs) = insert v (Svar.to_fset vs) ∧ (if v ∈ Svar.to_fset vs then Finset.card (Svar.to_fset (svar_set_add v vs)) = Finset.card (Svar.to_fset vs) else Int.ofNat (Finset.card (Svar.to_fset (svar_set_add v vs))) = Int.ofNat (Finset.card (Svar.to_fset vs)) + (1 : ℤ))
noncomputable def results_extend (s : SymState.sym_state) (normals : Finset SymState.sym_state) (unbounds : Finset SymState.sym_state) (limits : Finset SymState.sym_state) := ∀(s' : SymState.sym_state), s' ∈ normals ∨ s' ∈ unbounds ∨ s' ∈ limits → state_extends s s'
theorem symbolic_interp_while_list'vc (ctr : ℤ) (n : ℤ) (ss : List SymState.sym_state) (e : Syntax.expr) (c : Syntax.cmd) (fact0 : (0 : ℤ) ≤ ctr) (fact1 : ctr ≤ n) : (match ss with | ([] : List SymState.sym_state) => True | List.cons s ss' => (((0 : ℤ) ≤ Int.ofNat (List.length ss) ∧ (0 : ℤ) < Int.ofNat (List.length ss)) ∧ (0 : ℤ) ≤ ctr ∧ ctr ≤ n) ∧ (∀(normals1 : SymStateSet.set) (unbounds1 : SymStateSet.set) (limits1 : SymStateSet.set), results_extend s (SymStateSet.to_fset normals1) (SymStateSet.to_fset unbounds1) (SymStateSet.to_fset limits1) ∧ (Constraint.is_solution (SymState.rho s) (SymState.constr s) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) ctr (compose (SymState.rho s) (SymState.sigma s)) e c gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → Constraint.is_solution (SymState.rho s) (SymState.constr s) ∧ ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) ctr (compose (SymState.rho s) (SymState.sigma s)) e c (compose (SymState.rho s') (SymState.sigma s')) bhv) → ((0 : ℤ) ≤ Int.ofNat (List.length ss) ∧ List.length ss' < List.length ss) ∧ (0 : ℤ) ≤ ctr ∧ ctr ≤ n)) ∧ (∀(normals : SymStateSet.set) (unbounds : SymStateSet.set) (limits : SymStateSet.set), (match ss with | ([] : List SymState.sym_state) => (SymStateSet.to_fset limits = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset limits)) = (0 : ℤ)) ∧ (SymStateSet.to_fset unbounds = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset unbounds)) = (0 : ℤ)) ∧ SymStateSet.to_fset normals = (∅ : Finset SymState.sym_state) ∧ Int.ofNat (Finset.card (SymStateSet.to_fset normals)) = (0 : ℤ) | List.cons s ss' => (∃(normals1 : SymStateSet.set) (unbounds1 : SymStateSet.set) (limits1 : SymStateSet.set), (results_extend s (SymStateSet.to_fset normals1) (SymStateSet.to_fset unbounds1) (SymStateSet.to_fset limits1) ∧ (Constraint.is_solution (SymState.rho s) (SymState.constr s) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) ctr (compose (SymState.rho s) (SymState.sigma s)) e c gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals1 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds1 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits1) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → Constraint.is_solution (SymState.rho s) (SymState.constr s) ∧ ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) ctr (compose (SymState.rho s) (SymState.sigma s)) e c (compose (SymState.rho s') (SymState.sigma s')) bhv)) ∧ (∃(normals2 : SymStateSet.set) (unbounds2 : SymStateSet.set) (limits2 : SymStateSet.set), ((∀(s' : SymState.sym_state), s' ∈ SymStateSet.to_fset normals2 ∨ s' ∈ SymStateSet.to_fset unbounds2 ∨ s' ∈ SymStateSet.to_fset limits2 → (∃(s1 : SymState.sym_state), s1 ∈ SymStateSet.to_fset (SymStateSet.of_list ss') ∧ state_extends s1 s')) ∧ (∀(s1 : SymState.sym_state), s1 ∈ SymStateSet.to_fset (SymStateSet.of_list ss') → Constraint.is_solution (SymState.rho s1) (SymState.constr s1) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) ctr (compose (SymState.rho s1) (SymState.sigma s1)) e c gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals2 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds2 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits2) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals2 | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds2 | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits2) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → (∃(s1 : SymState.sym_state), s1 ∈ SymStateSet.to_fset (SymStateSet.of_list ss') ∧ Constraint.is_solution (SymState.rho s1) (SymState.constr s1) ∧ ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) ctr (compose (SymState.rho s1) (SymState.sigma s1)) e c (compose (SymState.rho s') (SymState.sigma s')) bhv))) ∧ SymStateSet.to_fset limits = SymStateSet.to_fset limits1 ∪ SymStateSet.to_fset limits2 ∧ SymStateSet.to_fset unbounds = SymStateSet.to_fset unbounds1 ∪ SymStateSet.to_fset unbounds2 ∧ SymStateSet.to_fset normals = SymStateSet.to_fset normals1 ∪ SymStateSet.to_fset normals2))) → (∀(s' : SymState.sym_state), s' ∈ SymStateSet.to_fset normals ∨ s' ∈ SymStateSet.to_fset unbounds ∨ s' ∈ SymStateSet.to_fset limits → (∃(s : SymState.sym_state), s ∈ SymStateSet.to_fset (SymStateSet.of_list ss) ∧ state_extends s s')) ∧ (∀(s : SymState.sym_state), s ∈ SymStateSet.to_fset (SymStateSet.of_list ss) → Constraint.is_solution (SymState.rho s) (SymState.constr s) → (∀(gamma' : Syntax.program_var -> Option ℤ) (bhv : ConcreteSemantics.behavior), ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) ctr (compose (SymState.rho s) (SymState.sigma s)) e c gamma' bhv → (∃(s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits) ∧ Constraint.is_solution (SymState.rho s') (SymState.constr s') ∧ gamma' = compose (SymState.rho s') (SymState.sigma s')))) ∧ (∀(bhv : ConcreteSemantics.behavior) (s' : SymState.sym_state), (match bhv with | ConcreteSemantics.behavior.Cnormal => s' ∈ SymStateSet.to_fset normals | ConcreteSemantics.behavior.Cunbound_var => s' ∈ SymStateSet.to_fset unbounds | ConcreteSemantics.behavior.Cloop_limit => s' ∈ SymStateSet.to_fset limits) → Constraint.is_solution (SymState.rho s') (SymState.constr s') → (∃(s : SymState.sym_state), s ∈ SymStateSet.to_fset (SymStateSet.of_list ss) ∧ Constraint.is_solution (SymState.rho s) (SymState.constr s) ∧ ConcreteSemantics.exec_while (ConcreteSemantics.mk_loop_cnf n) ctr (compose (SymState.rho s) (SymState.sigma s)) e c (compose (SymState.rho s') (SymState.sigma s')) bhv)))
  := sorry
end imp_SymbolicInterpreter_symbolic_interp_while_listqtvc
