import Why3.Base
import Why3.why3.Ref.Ref
import pearl.prover.lib.lean.Unification.Types
import pearl.prover.lib.lean.Functions.Config
import pearl.prover.lib.lean.Functions.Func
import pearl.prover.lib.lean.BacktrackArray.Types
import pearl.prover.lib.lean.Predicates.Pred
import pearl.prover.lib.lean.BacktrackArray.Logic
import pearl.prover.lib.lean.Choice.Choice
import pearl.prover.lib.lean.BacktrackArray.Impl
import pearl.prover.lib.lean.Firstorder_symbol_spec.Spec
import pearl.prover.lib.lean.Nat.Nat
import pearl.prover.lib.lean.OptionFuncs.Funcs
import pearl.prover.lib.lean.Sum.Sum
import pearl.prover.lib.lean.Firstorder_symbol_impl.Types
import pearl.prover.lib.lean.Firstorder_symbol_impl.Logic
import pearl.prover.lib.lean.Firstorder_symbol_impl.Impl
import pearl.prover.lib.lean.Firstorder_term_spec.Spec
import pearl.prover.lib.lean.Firstorder_term_impl.Types
import pearl.prover.lib.lean.Firstorder_term_impl.Logic
import pearl.prover.lib.lean.Firstorder_term_impl.Impl
import pearl.prover.lib.lean.Unification.Logic
open Classical
open Lean4Why3
namespace Unification_Impl_unification_termqtvc
theorem unification_term'vc (t1 : Types.nlimpl_fo_term) (t2 : Types.nlimpl_fo_term) (rhob : Types.t Types.sdata) (rho : Types.unifier_subst) (lv : List ℤ) (lp : ℤ -> Bool) (fact0 : Logic.nlimpl_fo_term_ok t1) (fact1 : Logic.nlimpl_fo_term_ok t2) (fact2 : Logic.unifier_subst_ok rhob rho) (fact3 : ∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field t1) → (0 : ℤ) ≤ y) (fact4 : ∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field t2) → (0 : ℤ) ≤ y) (fact5 : ∀(x : ℤ), x ∈ lv → lp x = true ∧ (0 : ℤ) ≤ x) (fact6 : ∀(x : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x → lp x = true) : Logic.nlimpl_fo_term_ok t2 ∧ (∀(o1 : Types.cons_fo_term), Logic.cons_ok_fo_term o1 ∧ Logic.cons_rel_fo_term o1 t2 ∧ Logic.cons_open_rel_fo_term o1 t2 → Logic.nlimpl_fo_term_ok t1 ∧ (∀(o2 : Types.cons_fo_term), Logic.cons_ok_fo_term o2 ∧ Logic.cons_rel_fo_term o2 t1 ∧ Logic.cons_open_rel_fo_term o2 t1 → (match o1 with | Types.cons_fo_term.NLCVar_fo_term x => (match o2 with | Types.cons_fo_term.NLCVar_fo_term x1 => (if x1 = x then Logic.unifier_subst_ok rhob rho ∧ Logic.precede rhob rhob ∧ (∀(x2 : ℤ), x2 ∈ lv → lp x2 = true ∧ (0 : ℤ) ≤ x2) ∧ (∀(x2 : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x2 → lp x2 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol Spec.subst_id_fo_term = Types.unifier_subst.unifier rho ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) else (Logic.correct rhob ∧ (0 : ℤ) ≤ x1) ∧ (let bx : List Types.sdata := Types.timestamp.table (Logic.current_timestamp rhob) x1; Logic.list_forall (Types.t.inv rhob) bx → (match bx with | List.cons (Types.sdata.Assign bx1) _ => (Logic.nlimpl_fo_term_ok bx1 ∧ Logic.nlimpl_fo_term_ok t2 ∧ Logic.unifier_subst_ok rhob rho ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field bx1) → (0 : ℤ) ≤ y) ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field t2) → (0 : ℤ) ≤ y) ∧ (∀(x2 : ℤ), x2 ∈ lv → lp x2 = true ∧ (0 : ℤ) ≤ x2) ∧ (∀(x2 : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x2 → lp x2 = true)) ∧ (∀(rhob1 : Types.t Types.sdata) (lv1 : List ℤ), Types.t.inv rhob1 = Types.t.inv rhob → (∀(res : Types.unification_return), Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier res) ∧ Logic.precede rhob rhob1 ∧ (∀(x2 : ℤ), x2 ∈ lv1 → lp x2 = true ∧ (0 : ℤ) ≤ x2) ∧ (∀(x2 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x2 → lp x2 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor res) = Types.unifier_subst.unifier (Types.unification_return.final_unifier res) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field bx1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier res)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field bx1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) → Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier res) ∧ Logic.precede rhob rhob1 ∧ (∀(x2 : ℤ), x2 ∈ lv1 → lp x2 = true ∧ (0 : ℤ) ≤ x2) ∧ (∀(x2 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x2 → lp x2 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor res) = Types.unifier_subst.unifier (Types.unification_return.final_unifier res) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier res)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0))) | _ => (Logic.correct rhob ∧ (0 : ℤ) ≤ x) ∧ (let by' : List Types.sdata := Types.timestamp.table (Logic.current_timestamp rhob) x; Logic.list_forall (Types.t.inv rhob) by' → (match by' with | List.cons (Types.sdata.Assign by'1) _ => (Logic.nlimpl_fo_term_ok t1 ∧ Logic.nlimpl_fo_term_ok by'1 ∧ Logic.unifier_subst_ok rhob rho ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field t1) → (0 : ℤ) ≤ y) ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field by'1) → (0 : ℤ) ≤ y) ∧ (∀(x2 : ℤ), x2 ∈ lv → lp x2 = true ∧ (0 : ℤ) ≤ x2) ∧ (∀(x2 : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x2 → lp x2 = true)) ∧ (∀(rhob1 : Types.t Types.sdata) (lv1 : List ℤ), Types.t.inv rhob1 = Types.t.inv rhob → (∀(res : Types.unification_return), Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier res) ∧ Logic.precede rhob rhob1 ∧ (∀(x2 : ℤ), x2 ∈ lv1 → lp x2 = true ∧ (0 : ℤ) ≤ x2) ∧ (∀(x2 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x2 → lp x2 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor res) = Types.unifier_subst.unifier (Types.unification_return.final_unifier res) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field by'1) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier res)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field by'1) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) → Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier res) ∧ Logic.precede rhob rhob1 ∧ (∀(x2 : ℤ), x2 ∈ lv1 → lp x2 = true ∧ (0 : ℤ) ≤ x2) ∧ (∀(x2 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x2 → lp x2 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor res) = Types.unifier_subst.unifier (Types.unification_return.final_unifier res) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier res)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0))) | _ => (Logic.unifier_subst_ok rhob rho ∧ Logic.unassigned (Logic.current_timestamp rhob) x) ∧ ((let tm : Spec.fo_term ℤ ℤ := Spec.fo_term.Var_fo_term x; tm = Spec.subst_fo_term tm Spec.subst_id_symbol (Types.unifier_subst.unifier_base_model rho) ∧ tm = Spec.subst_fo_term tm Spec.subst_id_symbol (Types.unifier_subst.unifier rho)) → (Logic.unifier_subst_ok rhob rho ∧ Logic.unassigned (Logic.current_timestamp rhob) x1) ∧ ((let tm : Spec.fo_term ℤ ℤ := Spec.fo_term.Var_fo_term x1; tm = Spec.subst_fo_term tm Spec.subst_id_symbol (Types.unifier_subst.unifier_base_model rho) ∧ tm = Spec.subst_fo_term tm Spec.subst_id_symbol (Types.unifier_subst.unifier rho)) → (if x1 < x then ((0 : ℤ) ≤ x1 ∧ Logic.nlimpl_fo_term_ok t2 ∧ Logic.unifier_subst_ok rhob rho ∧ Logic.unassigned (Logic.current_timestamp rhob) x1 ∧ ¬Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol (Types.unifier_subst.unifier rho) = Spec.fo_term.Var_fo_term x1 ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field t2) → (0 : ℤ) ≤ y) ∧ (∀(x2 : ℤ), x2 ∈ lv → lp x2 = true ∧ (0 : ℤ) ≤ x2) ∧ (∀(x2 : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x2 → lp x2 = true)) ∧ (∀(rhob1 : Types.t Types.sdata) (lv1 : List ℤ), Types.t.inv rhob1 = Types.t.inv rhob → (∀(result : Types.unification_return), (∀(x2 : ℤ), x2 ∈ lv1 → lp x2 = true ∧ (0 : ℤ) ≤ x2) ∧ (∀(x2 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x2 → lp x2 = true) ∧ Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier result) ∧ Logic.precede rhob rhob1 ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor result) = Types.unifier_subst.unifier (Types.unification_return.final_unifier result) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; s' x1 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier result)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); s0 x1 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) → Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier result) ∧ Logic.precede rhob rhob1 ∧ (∀(x2 : ℤ), x2 ∈ lv1 → lp x2 = true ∧ (0 : ℤ) ≤ x2) ∧ (∀(x2 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x2 → lp x2 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor result) = Types.unifier_subst.unifier (Types.unification_return.final_unifier result) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier result)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0))) else ((0 : ℤ) ≤ x ∧ Logic.nlimpl_fo_term_ok t1 ∧ Logic.unifier_subst_ok rhob rho ∧ Logic.unassigned (Logic.current_timestamp rhob) x ∧ ¬Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol (Types.unifier_subst.unifier rho) = Spec.fo_term.Var_fo_term x ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field t1) → (0 : ℤ) ≤ y) ∧ (∀(x2 : ℤ), x2 ∈ lv → lp x2 = true ∧ (0 : ℤ) ≤ x2) ∧ (∀(x2 : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x2 → lp x2 = true)) ∧ (∀(rhob1 : Types.t Types.sdata) (lv1 : List ℤ), Types.t.inv rhob1 = Types.t.inv rhob → (∀(result : Types.unification_return), (∀(x2 : ℤ), x2 ∈ lv1 → lp x2 = true ∧ (0 : ℤ) ≤ x2) ∧ (∀(x2 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x2 → lp x2 = true) ∧ Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier result) ∧ Logic.precede rhob rhob1 ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor result) = Types.unifier_subst.unifier (Types.unification_return.final_unifier result) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; s' x = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier result)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); s0 x = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) → Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier result) ∧ Logic.precede rhob rhob1 ∧ (∀(x2 : ℤ), x2 ∈ lv1 → lp x2 = true ∧ (0 : ℤ) ≤ x2) ∧ (∀(x2 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x2 → lp x2 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor result) = Types.unifier_subst.unifier (Types.unification_return.final_unifier result) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier result)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0))))))))))) | Types.cons_fo_term.NLC_App x1 x2 => (Logic.correct rhob ∧ (0 : ℤ) ≤ x) ∧ (let bx : List Types.sdata := Types.timestamp.table (Logic.current_timestamp rhob) x; Logic.list_forall (Types.t.inv rhob) bx → (match bx with | List.cons (Types.sdata.Assign bx1) _ => (Logic.nlimpl_fo_term_ok t1 ∧ Logic.nlimpl_fo_term_ok bx1 ∧ Logic.unifier_subst_ok rhob rho ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field t1) → (0 : ℤ) ≤ y) ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field bx1) → (0 : ℤ) ≤ y) ∧ (∀(x3 : ℤ), x3 ∈ lv → lp x3 = true ∧ (0 : ℤ) ≤ x3) ∧ (∀(x3 : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x3 → lp x3 = true)) ∧ (∀(rhob1 : Types.t Types.sdata) (lv1 : List ℤ), Types.t.inv rhob1 = Types.t.inv rhob → (∀(res : Types.unification_return), Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier res) ∧ Logic.precede rhob rhob1 ∧ (∀(x3 : ℤ), x3 ∈ lv1 → lp x3 = true ∧ (0 : ℤ) ≤ x3) ∧ (∀(x3 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x3 → lp x3 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor res) = Types.unifier_subst.unifier (Types.unification_return.final_unifier res) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field bx1) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier res)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field bx1) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) → Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier res) ∧ Logic.precede rhob rhob1 ∧ (∀(x3 : ℤ), x3 ∈ lv1 → lp x3 = true ∧ (0 : ℤ) ≤ x3) ∧ (∀(x3 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x3 → lp x3 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor res) = Types.unifier_subst.unifier (Types.unification_return.final_unifier res) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier res)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0))) | _ => ((0 : ℤ) ≤ x ∧ Logic.nlimpl_fo_term_ok t1 ∧ Logic.unifier_subst_ok rhob rho ∧ Logic.unassigned (Logic.current_timestamp rhob) x ∧ ¬Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol (Types.unifier_subst.unifier rho) = Spec.fo_term.Var_fo_term x ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field t1) → (0 : ℤ) ≤ y) ∧ (∀(x3 : ℤ), x3 ∈ lv → lp x3 = true ∧ (0 : ℤ) ≤ x3) ∧ (∀(x3 : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x3 → lp x3 = true)) ∧ (∀(rhob1 : Types.t Types.sdata) (lv1 : List ℤ), Types.t.inv rhob1 = Types.t.inv rhob → (∀(result : Types.unification_return), (∀(x3 : ℤ), x3 ∈ lv1 → lp x3 = true ∧ (0 : ℤ) ≤ x3) ∧ (∀(x3 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x3 → lp x3 = true) ∧ Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier result) ∧ Logic.precede rhob rhob1 ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor result) = Types.unifier_subst.unifier (Types.unification_return.final_unifier result) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; s' x = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier result)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); s0 x = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) → Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier result) ∧ Logic.precede rhob rhob1 ∧ (∀(x3 : ℤ), x3 ∈ lv1 → lp x3 = true ∧ (0 : ℤ) ≤ x3) ∧ (∀(x3 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x3 → lp x3 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor result) = Types.unifier_subst.unifier (Types.unification_return.final_unifier result) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier result)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0)))))) | Types.cons_fo_term.NLC_App x x1 => (match o2 with | Types.cons_fo_term.NLC_App x2 x3 => Logic.nlimpl_symbol_ok x ∧ (∀(o3 : ℤ), let o4 : Types.cons_symbol := Types.cons_symbol.NLCVar_symbol o3; Logic.cons_ok_symbol o4 ∧ Logic.cons_rel_symbol o4 x ∧ Logic.cons_open_rel_symbol o4 x → Logic.nlimpl_symbol_ok x2 ∧ (∀(o5 : ℤ), let o6 : Types.cons_symbol := Types.cons_symbol.NLCVar_symbol o5; Logic.cons_ok_symbol o6 ∧ Logic.cons_rel_symbol o6 x2 ∧ Logic.cons_open_rel_symbol o6 x2 → (if o5 = o3 then (Logic.nlimpl_fo_term_list_ok x3 ∧ Logic.nlimpl_fo_term_list_ok x1 ∧ Logic.unifier_subst_ok rhob rho ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term_list y (Types.nlimpl_fo_term_list.model_fo_term_list_field x3) → (0 : ℤ) ≤ y) ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term_list y (Types.nlimpl_fo_term_list.model_fo_term_list_field x1) → (0 : ℤ) ≤ y) ∧ (∀(x4 : ℤ), x4 ∈ lv → lp x4 = true ∧ (0 : ℤ) ≤ x4) ∧ (∀(x4 : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x4 → lp x4 = true)) ∧ (∀(rhob1 : Types.t Types.sdata) (lv1 : List ℤ), Types.t.inv rhob1 = Types.t.inv rhob → (∀(result : Types.unification_return), Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier result) ∧ Logic.precede rhob rhob1 ∧ (∀(x4 : ℤ), x4 ∈ lv1 → lp x4 = true ∧ (0 : ℤ) ≤ x4) ∧ (∀(x4 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x4 → lp x4 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor result) = Types.unifier_subst.unifier (Types.unification_return.final_unifier result) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field x3) Spec.subst_id_symbol s' = Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field x1) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier result)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field x3) Spec.subst_id_symbol s0 = Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field x1) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) → Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier result) ∧ Logic.precede rhob rhob1 ∧ (∀(x4 : ℤ), x4 ∈ lv1 → lp x4 = true ∧ (0 : ℤ) ≤ x4) ∧ (∀(x4 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x4 → lp x4 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor result) = Types.unifier_subst.unifier (Types.unification_return.final_unifier result) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier result)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0))) else Logic.precede rhob rhob ∧ Logic.correct rhob))) | Types.cons_fo_term.NLCVar_fo_term x2 => (Logic.correct rhob ∧ (0 : ℤ) ≤ x2) ∧ (let bx : List Types.sdata := Types.timestamp.table (Logic.current_timestamp rhob) x2; Logic.list_forall (Types.t.inv rhob) bx → (match bx with | List.cons (Types.sdata.Assign bx1) _ => (Logic.nlimpl_fo_term_ok bx1 ∧ Logic.nlimpl_fo_term_ok t2 ∧ Logic.unifier_subst_ok rhob rho ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field bx1) → (0 : ℤ) ≤ y) ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field t2) → (0 : ℤ) ≤ y) ∧ (∀(x3 : ℤ), x3 ∈ lv → lp x3 = true ∧ (0 : ℤ) ≤ x3) ∧ (∀(x3 : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x3 → lp x3 = true)) ∧ (∀(rhob1 : Types.t Types.sdata) (lv1 : List ℤ), Types.t.inv rhob1 = Types.t.inv rhob → (∀(res : Types.unification_return), Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier res) ∧ Logic.precede rhob rhob1 ∧ (∀(x3 : ℤ), x3 ∈ lv1 → lp x3 = true ∧ (0 : ℤ) ≤ x3) ∧ (∀(x3 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x3 → lp x3 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor res) = Types.unifier_subst.unifier (Types.unification_return.final_unifier res) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field bx1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier res)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field bx1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) → Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier res) ∧ Logic.precede rhob rhob1 ∧ (∀(x3 : ℤ), x3 ∈ lv1 → lp x3 = true ∧ (0 : ℤ) ≤ x3) ∧ (∀(x3 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x3 → lp x3 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor res) = Types.unifier_subst.unifier (Types.unification_return.final_unifier res) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier res)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier res); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0))) | _ => ((0 : ℤ) ≤ x2 ∧ Logic.nlimpl_fo_term_ok t2 ∧ Logic.unifier_subst_ok rhob rho ∧ Logic.unassigned (Logic.current_timestamp rhob) x2 ∧ ¬Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol (Types.unifier_subst.unifier rho) = Spec.fo_term.Var_fo_term x2 ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field t2) → (0 : ℤ) ≤ y) ∧ (∀(x3 : ℤ), x3 ∈ lv → lp x3 = true ∧ (0 : ℤ) ≤ x3) ∧ (∀(x3 : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x3 → lp x3 = true)) ∧ (∀(rhob1 : Types.t Types.sdata) (lv1 : List ℤ), Types.t.inv rhob1 = Types.t.inv rhob → (∀(result : Types.unification_return), (∀(x3 : ℤ), x3 ∈ lv1 → lp x3 = true ∧ (0 : ℤ) ≤ x3) ∧ (∀(x3 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x3 → lp x3 = true) ∧ Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier result) ∧ Logic.precede rhob rhob1 ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor result) = Types.unifier_subst.unifier (Types.unification_return.final_unifier result) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; s' x2 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier result)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); s0 x2 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) → Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier result) ∧ Logic.precede rhob rhob1 ∧ (∀(x3 : ℤ), x3 ∈ lv1 → lp x3 = true ∧ (0 : ℤ) ≤ x3) ∧ (∀(x3 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x3 → lp x3 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor result) = Types.unifier_subst.unifier (Types.unification_return.final_unifier result) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier result)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier result); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0)))))))))
  := sorry
end Unification_Impl_unification_termqtvc
