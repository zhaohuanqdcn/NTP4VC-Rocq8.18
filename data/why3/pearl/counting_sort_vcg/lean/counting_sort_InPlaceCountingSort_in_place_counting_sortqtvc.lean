import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
import pearl.counting_sort_vcg.lean.counting_sort.Spec
import Why3.array.IntArraySorted
open Classical
open Lean4Why3
namespace counting_sort_InPlaceCountingSort_in_place_counting_sortqtvc
theorem in_place_counting_sort'vc (a : List ℤ) (fact0 : Spec.k_values a) : let o1 : ℤ := Spec.k; (0 : ℤ) ≤ o1 ∧ (∀(c : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o1 → getElem! c (Int.toNat i) = (0 : ℤ)) ∧ Int.ofNat (List.length c) = o1 → (let o2 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → (∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < Spec.k → getElem! c (Int.toNat v) = Spec.numeq a v (0 : ℤ) (0 : ℤ)) ∧ (∀(c1 : List ℤ), List.length c1 = List.length c → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o2) ∧ (∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < Spec.k → c1[Int.toNat v]! = Spec.numeq a v (0 : ℤ) i) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let v : ℤ := a[Int.toNat i]!; ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length c1)) ∧ (let o3 : ℤ := c1[Int.toNat v]! + (1 : ℤ); ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length c1)) ∧ (List.length (List.set c1 (Int.toNat v) o3) = List.length c1 → getElem! (List.set c1 (Int.toNat v) o3) ∘ Int.toNat = Function.update (getElem! c1 ∘ Int.toNat) v o3 → (∀(v1 : ℤ), (0 : ℤ) ≤ v1 ∧ v1 < Spec.k → (List.set c1 (Int.toNat v) o3)[Int.toNat v1]! = Spec.numeq a v1 (0 : ℤ) (i + (1 : ℤ))))))) ∧ ((∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < Spec.k → c1[Int.toNat v]! = Spec.numeq a v (0 : ℤ) (o2 + (1 : ℤ))) → (let o3 : ℤ := Spec.k - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → ((0 : ℤ) = Spec.numlt a (0 : ℤ) (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 a (0 : ℤ) (0 : ℤ) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < (0 : ℤ) → (0 : ℤ) ≤ a[Int.toNat e]! ∧ a[Int.toNat e]! < (0 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < (0 : ℤ) → Spec.numeq a f (0 : ℤ) (0 : ℤ) = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a)))) ∧ (∀(j : ℤ) (a1 : List ℤ), List.length a1 = List.length a → (∀(v : ℤ), ((0 : ℤ) ≤ v ∧ v ≤ o3) ∧ j = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a1)) ∧ IntArraySorted.sorted_sub1 a1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ a1[Int.toNat e]! ∧ a1[Int.toNat e]! < v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq a1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a1))) → ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length c1)) ∧ (let o4 : ℤ := c1[Int.toNat v]!; ((1 : ℤ) ≤ o4 + (1 : ℤ) → (j - (1 : ℤ) + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a1)) ∧ IntArraySorted.sorted_sub1 a1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ a1[Int.toNat e]! ∧ a1[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq a1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a1))) ∧ Spec.numeq a1 v (0 : ℤ) j = (1 : ℤ) - (1 : ℤ)) ∧ (∀(j1 : ℤ) (a2 : List ℤ), List.length a2 = List.length a1 → (∀(i : ℤ), ((1 : ℤ) ≤ i ∧ i ≤ o4) ∧ j1 - i + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a2)) ∧ IntArraySorted.sorted_sub1 a2 (0 : ℤ) j1 ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 → (0 : ℤ) ≤ a2[Int.toNat e]! ∧ a2[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq a2 f (0 : ℤ) j1 = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a2))) ∧ Spec.numeq a2 v (0 : ℤ) j1 = i - (1 : ℤ) → ((0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat j1) v) = List.length a2 → getElem! (List.set a2 (Int.toNat j1) v) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) j1 v → j1 + (1 : ℤ) - (i + (1 : ℤ)) + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length (List.set a2 (Int.toNat j1) v))) ∧ IntArraySorted.sorted_sub1 (List.set a2 (Int.toNat j1) v) (0 : ℤ) (j1 + (1 : ℤ)) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 + (1 : ℤ) → (0 : ℤ) ≤ (List.set a2 (Int.toNat j1) v)[Int.toNat e]! ∧ (List.set a2 (Int.toNat j1) v)[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq (List.set a2 (Int.toNat j1) v) f (0 : ℤ) (j1 + (1 : ℤ)) = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length (List.set a2 (Int.toNat j1) v)))) ∧ Spec.numeq (List.set a2 (Int.toNat j1) v) v (0 : ℤ) (j1 + (1 : ℤ)) = i + (1 : ℤ) - (1 : ℤ))) ∧ (j1 - (o4 + (1 : ℤ)) + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a2)) ∧ IntArraySorted.sorted_sub1 a2 (0 : ℤ) j1 ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 → (0 : ℤ) ≤ a2[Int.toNat e]! ∧ a2[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq a2 f (0 : ℤ) j1 = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a2))) ∧ Spec.numeq a2 v (0 : ℤ) j1 = o4 + (1 : ℤ) - (1 : ℤ) → j1 = Spec.numlt a (v + (1 : ℤ)) (0 : ℤ) (Int.ofNat (List.length a2)) ∧ IntArraySorted.sorted_sub1 a2 (0 : ℤ) j1 ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 → (0 : ℤ) ≤ a2[Int.toNat e]! ∧ a2[Int.toNat e]! < v + (1 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v + (1 : ℤ) → Spec.numeq a2 f (0 : ℤ) j1 = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a2)))))) ∧ (o4 + (1 : ℤ) < (1 : ℤ) → j = Spec.numlt a (v + (1 : ℤ)) (0 : ℤ) (Int.ofNat (List.length a1)) ∧ IntArraySorted.sorted_sub1 a1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ a1[Int.toNat e]! ∧ a1[Int.toNat e]! < v + (1 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v + (1 : ℤ) → Spec.numeq a1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a1)))))) ∧ (j = Spec.numlt a (o3 + (1 : ℤ)) (0 : ℤ) (Int.ofNat (List.length a1)) ∧ IntArraySorted.sorted_sub1 a1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ a1[Int.toNat e]! ∧ a1[Int.toNat e]! < o3 + (1 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < o3 + (1 : ℤ) → Spec.numeq a1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a1))) → IntArraySorted.sorted a1 ∧ Spec.permut a a1))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → IntArraySorted.sorted a ∧ Spec.permut a a))))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → (let o3 : ℤ := Spec.k - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → ((0 : ℤ) = Spec.numlt a (0 : ℤ) (0 : ℤ) (Int.ofNat (List.length a)) ∧ IntArraySorted.sorted_sub1 a (0 : ℤ) (0 : ℤ) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < (0 : ℤ) → (0 : ℤ) ≤ a[Int.toNat e]! ∧ a[Int.toNat e]! < (0 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < (0 : ℤ) → Spec.numeq a f (0 : ℤ) (0 : ℤ) = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a)))) ∧ (∀(j : ℤ) (a1 : List ℤ), List.length a1 = List.length a → (∀(v : ℤ), ((0 : ℤ) ≤ v ∧ v ≤ o3) ∧ j = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a1)) ∧ IntArraySorted.sorted_sub1 a1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ a1[Int.toNat e]! ∧ a1[Int.toNat e]! < v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq a1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a1))) → ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length c)) ∧ (let o4 : ℤ := getElem! c (Int.toNat v); ((1 : ℤ) ≤ o4 + (1 : ℤ) → (j - (1 : ℤ) + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a1)) ∧ IntArraySorted.sorted_sub1 a1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ a1[Int.toNat e]! ∧ a1[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq a1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a1))) ∧ Spec.numeq a1 v (0 : ℤ) j = (1 : ℤ) - (1 : ℤ)) ∧ (∀(j1 : ℤ) (a2 : List ℤ), List.length a2 = List.length a1 → (∀(i : ℤ), ((1 : ℤ) ≤ i ∧ i ≤ o4) ∧ j1 - i + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a2)) ∧ IntArraySorted.sorted_sub1 a2 (0 : ℤ) j1 ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 → (0 : ℤ) ≤ a2[Int.toNat e]! ∧ a2[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq a2 f (0 : ℤ) j1 = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a2))) ∧ Spec.numeq a2 v (0 : ℤ) j1 = i - (1 : ℤ) → ((0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat j1) v) = List.length a2 → getElem! (List.set a2 (Int.toNat j1) v) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) j1 v → j1 + (1 : ℤ) - (i + (1 : ℤ)) + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length (List.set a2 (Int.toNat j1) v))) ∧ IntArraySorted.sorted_sub1 (List.set a2 (Int.toNat j1) v) (0 : ℤ) (j1 + (1 : ℤ)) ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 + (1 : ℤ) → (0 : ℤ) ≤ (List.set a2 (Int.toNat j1) v)[Int.toNat e]! ∧ (List.set a2 (Int.toNat j1) v)[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq (List.set a2 (Int.toNat j1) v) f (0 : ℤ) (j1 + (1 : ℤ)) = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length (List.set a2 (Int.toNat j1) v)))) ∧ Spec.numeq (List.set a2 (Int.toNat j1) v) v (0 : ℤ) (j1 + (1 : ℤ)) = i + (1 : ℤ) - (1 : ℤ))) ∧ (j1 - (o4 + (1 : ℤ)) + (1 : ℤ) = Spec.numlt a v (0 : ℤ) (Int.ofNat (List.length a2)) ∧ IntArraySorted.sorted_sub1 a2 (0 : ℤ) j1 ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 → (0 : ℤ) ≤ a2[Int.toNat e]! ∧ a2[Int.toNat e]! ≤ v) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v → Spec.numeq a2 f (0 : ℤ) j1 = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a2))) ∧ Spec.numeq a2 v (0 : ℤ) j1 = o4 + (1 : ℤ) - (1 : ℤ) → j1 = Spec.numlt a (v + (1 : ℤ)) (0 : ℤ) (Int.ofNat (List.length a2)) ∧ IntArraySorted.sorted_sub1 a2 (0 : ℤ) j1 ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j1 → (0 : ℤ) ≤ a2[Int.toNat e]! ∧ a2[Int.toNat e]! < v + (1 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v + (1 : ℤ) → Spec.numeq a2 f (0 : ℤ) j1 = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a2)))))) ∧ (o4 + (1 : ℤ) < (1 : ℤ) → j = Spec.numlt a (v + (1 : ℤ)) (0 : ℤ) (Int.ofNat (List.length a1)) ∧ IntArraySorted.sorted_sub1 a1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ a1[Int.toNat e]! ∧ a1[Int.toNat e]! < v + (1 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < v + (1 : ℤ) → Spec.numeq a1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a1)))))) ∧ (j = Spec.numlt a (o3 + (1 : ℤ)) (0 : ℤ) (Int.ofNat (List.length a1)) ∧ IntArraySorted.sorted_sub1 a1 (0 : ℤ) j ∧ (∀(e : ℤ), (0 : ℤ) ≤ e ∧ e < j → (0 : ℤ) ≤ a1[Int.toNat e]! ∧ a1[Int.toNat e]! < o3 + (1 : ℤ)) ∧ (∀(f : ℤ), (0 : ℤ) ≤ f ∧ f < o3 + (1 : ℤ) → Spec.numeq a1 f (0 : ℤ) j = Spec.numeq a f (0 : ℤ) (Int.ofNat (List.length a1))) → IntArraySorted.sorted a1 ∧ Spec.permut a a1))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → IntArraySorted.sorted a ∧ Spec.permut a a)))))
  := sorry
end counting_sort_InPlaceCountingSort_in_place_counting_sortqtvc
