theory div_Div_div_qrqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/mul_Mul"
begin
definition reciprocal :: "64 word \<Rightarrow> 64 word \<Rightarrow> _"
  where "reciprocal v d \<longleftrightarrow> uint v = (((18446744073709551615 :: int) + (1 :: int)) * ((18446744073709551615 :: int) + (1 :: int)) - (1 :: int)) ediv uint d - ((18446744073709551615 :: int) + (1 :: int))" for v d
definition reciprocal_3by2 :: "64 word \<Rightarrow> 64 word \<Rightarrow> 64 word \<Rightarrow> _"
  where "reciprocal_3by2 v dh dl \<longleftrightarrow> uint v = (((18446744073709551615 :: int) + (1 :: int)) * ((18446744073709551615 :: int) + (1 :: int)) * ((18446744073709551615 :: int) + (1 :: int)) - (1 :: int)) ediv (uint dl + ((18446744073709551615 :: int) + (1 :: int)) * uint dh) - ((18446744073709551615 :: int) + (1 :: int))" for v dh dl
definition normalized :: "64 word ptr \<Rightarrow> 32 word \<Rightarrow> _"
  where "normalized x sz \<longleftrightarrow> valid x (sint sz) \<and> ((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint (pelts x (offset x + sint sz - (1 :: int)))" for x sz
theorem div_qr'vc:
  fixes sy :: "32 word"
  fixes sx :: "32 word"
  fixes x :: "64 word ptr"
  fixes y :: "64 word ptr"
  fixes q :: "64 word ptr"
  fixes r :: "64 word ptr"
  fixes nx :: "64 word ptr"
  fixes ny :: "64 word ptr"
  fixes o1 :: "bool"
  assumes fact0: "(1 :: int) \<le> sint sy"
  assumes fact1: "sint sy \<le> sint sx"
  assumes fact2: "sint sx \<le> (2147483647 :: int) - (1 :: int)"
  assumes fact3: "valid x (sint sx)"
  assumes fact4: "valid y (sint sy)"
  assumes fact5: "valid q (sint sx - sint sy + (1 :: int))"
  assumes fact6: "valid r (sint sy)"
  assumes fact7: "valid nx (sint sx + (1 :: int))"
  assumes fact8: "valid ny (sint sy)"
  assumes fact9: "writable nx = True"
  assumes fact10: "writable ny = True"
  assumes fact11: "(0 :: int) < uint (pelts y (offset y + sint sy - (1 :: int)))"
  assumes fact12: "writable q = True"
  assumes fact13: "writable r = True"
  assumes fact14: "sint sy = sint (1 :: 32 word) \<longrightarrow> o1 = True"
  assumes fact15: "o1 = True \<longrightarrow> sy = (1 :: 32 word)"
  shows "if o1 = True then (c_C.min y \<le> offset y \<and> offset y < c_C.max y) \<and> (let o2 :: 64 word = pelts y (offset y) in (valid x (sint sx) \<and> valid q (sint sx) \<and> writable q = True \<and> (0 :: int) < sint sx \<and> (0 :: int) < uint o2) \<and> (\<forall>(q1 :: 64 word ptr). length (data q1) = length (data q) \<and> offset q1 = offset q \<and> c_C.min q1 = c_C.min q \<and> c_C.max q1 = c_C.max q \<and> writable q1 = writable q \<and> zone1 q1 = zone1 q \<longrightarrow> (\<forall>(lr :: 64 word). value x (sint sx) = value q1 (sint sx) * uint o2 + uint lr \<and> uint lr < uint o2 \<longrightarrow> ((c_C.min r \<le> offset r \<and> offset r < c_C.max r) \<and> writable r = True) \<and> (\<forall>(r1 :: 64 word ptr). length (data r1) = length (data r) \<and> offset r1 = offset r \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> writable r1 = writable r \<and> zone1 r1 = zone1 r \<longrightarrow> pelts r1 = (pelts r)(offset r1 := lr) \<longrightarrow> value x (sint sx) = value q1 (sint sx - sint sy + (1 :: int)) * value y (sint sy) + value r1 (sint sy) \<and> value r1 (sint sy) < value y (sint sy))))) else \<forall>(o2 :: bool). (sint sy = sint (2 :: 32 word) \<longrightarrow> o2 = True) \<and> (o2 = True \<longrightarrow> sy = (2 :: 32 word)) \<longrightarrow> (if o2 = True then int'32_in_bounds (sint sy - (1 :: int)) \<and> (\<forall>(o3 :: 32 word). sint o3 = sint sy - (1 :: int) \<longrightarrow> (c_C.min y \<le> offset y + sint o3 \<and> offset y + sint o3 < c_C.max y) \<and> (let o4 :: 64 word = pelts y (offset y + sint o3) in (0 :: int) < uint o4 \<and> (\<forall>(clz :: 32 word). (2 :: int) ^\<^sub>i sint clz * uint o4 < (18446744073709551615 :: int) + (1 :: int) \<and> (18446744073709551615 :: int) + (1 :: int) \<le> (2 :: int) * (2 :: int) ^\<^sub>i sint clz * uint o4 \<and> ((0 :: int) \<le> sint clz \<and> sint clz < (64 :: int)) \<and> (2 :: int) ^\<^sub>i sint clz * uint o4 \<le> (18446744073709551615 :: int) + (1 :: int) - (2 :: int) ^\<^sub>i sint clz \<longrightarrow> (\<forall>(o5 :: bool). (sint clz = sint (0 :: 32 word) \<longrightarrow> o5 = True) \<and> (o5 = True \<longrightarrow> clz = (0 :: 32 word)) \<longrightarrow> (if o5 = True then (valid x (sint sx) \<and> valid nx (sint sx) \<and> writable nx = True) \<and> (\<forall>(nx1 :: 64 word ptr). length (data nx1) = length (data nx) \<and> offset nx1 = offset nx \<and> c_C.min nx1 = c_C.min nx \<and> c_C.max nx1 = c_C.max nx \<and> writable nx1 = writable nx \<and> zone1 nx1 = zone1 nx \<longrightarrow> map_eq_sub_shift (pelts nx1) (pelts x) (offset nx1) (offset x) (sint sx) \<and> (\<forall>(j :: int). j < offset nx1 \<or> offset nx1 + sint sx \<le> j \<longrightarrow> pelts nx1 j = pelts nx j) \<longrightarrow> ((c_C.min nx1 \<le> offset nx1 + sint sx \<and> offset nx1 + sint sx < c_C.max nx1) \<and> writable nx1 = True) \<and> (\<forall>(nx2 :: 64 word ptr). length (data nx2) = length (data nx1) \<and> offset nx2 = offset nx1 \<and> c_C.min nx2 = c_C.min nx1 \<and> c_C.max nx2 = c_C.max nx1 \<and> writable nx2 = writable nx1 \<and> zone1 nx2 = zone1 nx1 \<longrightarrow> pelts nx2 = (pelts nx1)(offset nx2 + sint sx := 0 :: 64 word) \<and> pelts nx2 (offset nx2 + sint sx) = (0 :: 64 word) \<longrightarrow> int'32_in_bounds (sint sx + (1 :: int)) \<and> (\<forall>(o6 :: 32 word). sint o6 = sint sx + (1 :: int) \<longrightarrow> ((2 :: int) \<le> sint o6 \<and> valid nx2 (sint o6) \<and> valid y (2 :: int) \<and> valid q (sint o6 - (2 :: int)) \<and> ((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint (pelts y (offset y + (1 :: int))) \<and> writable q = True \<and> writable nx2 = True) \<and> (\<forall>(nx3 :: 64 word ptr) (q1 :: 64 word ptr). length (data nx3) = length (data nx2) \<and> offset nx3 = offset nx2 \<and> c_C.min nx3 = c_C.min nx2 \<and> c_C.max nx3 = c_C.max nx2 \<and> writable nx3 = writable nx2 \<and> zone1 nx3 = zone1 nx2 \<longrightarrow> length (data q1) = length (data q) \<and> offset q1 = offset q \<and> c_C.min q1 = c_C.min q \<and> c_C.max q1 = c_C.max q \<and> writable q1 = writable q \<and> zone1 q1 = zone1 q \<longrightarrow> (\<forall>(x_qh :: 64 word). value nx2 (sint o6) = (value q1 (sint o6 - (2 :: int)) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint o6 - (2 :: int)) * uint x_qh) * value y (2 :: int) + value nx3 (2 :: int) \<and> value nx3 (2 :: int) < value y (2 :: int) \<and> (0 :: int) \<le> uint x_qh \<and> uint x_qh \<le> (1 :: int) \<longrightarrow> (valid nx3 (sint sy) \<and> valid r (sint sy) \<and> writable r = True) \<and> (\<forall>(r1 :: 64 word ptr). length (data r1) = length (data r) \<and> offset r1 = offset r \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> writable r1 = writable r \<and> zone1 r1 = zone1 r \<longrightarrow> map_eq_sub_shift (pelts r1) (pelts nx3) (offset r1) (offset nx3) (sint sy) \<and> (\<forall>(j :: int). j < offset r1 \<or> offset r1 + sint sy \<le> j \<longrightarrow> pelts r1 j = pelts r j) \<longrightarrow> value x (sint sx) = value q1 (sint sx - sint sy + (1 :: int)) * value y (sint sy) + value r1 (sint sy) \<and> value r1 (sint sy) < value y (sint sy))))))) else (0 :: int) \<le> sint clz \<and> (\<forall>(o6 :: 64 word). uint o6 = sint clz \<longrightarrow> (((0 :: int) < uint o6 \<and> uint o6 < (64 :: int)) \<and> valid ny (sint sy) \<and> valid y (sint sy) \<and> writable ny = True \<and> (0 :: int) < sint sy) \<and> (\<forall>(ny1 :: 64 word ptr). length (data ny1) = length (data ny) \<and> offset ny1 = offset ny \<and> c_C.min ny1 = c_C.min ny \<and> c_C.max ny1 = c_C.max ny \<and> writable ny1 = writable ny \<and> zone1 ny1 = zone1 ny \<longrightarrow> (\<forall>(x_c :: 64 word). value ny1 (sint sy) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sy * uint x_c = value y (sint sy) * (2 :: int) ^\<^sub>i uint o6 \<longrightarrow> (0 :: int) \<le> sint clz \<and> (\<forall>(o7 :: 64 word). uint o7 = sint clz \<longrightarrow> (((0 :: int) < uint o7 \<and> uint o7 < (64 :: int)) \<and> valid nx (sint sx) \<and> valid x (sint sx) \<and> writable nx = True \<and> (0 :: int) < sint sx) \<and> (\<forall>(nx1 :: 64 word ptr). length (data nx1) = length (data nx) \<and> offset nx1 = offset nx \<and> c_C.min nx1 = c_C.min nx \<and> c_C.max nx1 = c_C.max nx \<and> writable nx1 = writable nx \<and> zone1 nx1 = zone1 nx \<longrightarrow> (\<forall>(h :: 64 word). value nx1 (sint sx) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sx * uint h = value x (sint sx) * (2 :: int) ^\<^sub>i uint o7 \<longrightarrow> ((c_C.min nx1 \<le> offset nx1 + sint sx \<and> offset nx1 + sint sx < c_C.max nx1) \<and> writable nx1 = True) \<and> (\<forall>(nx2 :: 64 word ptr). length (data nx2) = length (data nx1) \<and> offset nx2 = offset nx1 \<and> c_C.min nx2 = c_C.min nx1 \<and> c_C.max nx2 = c_C.max nx1 \<and> writable nx2 = writable nx1 \<and> zone1 nx2 = zone1 nx1 \<longrightarrow> pelts nx2 = (pelts nx1)(offset nx2 + sint sx := h) \<and> pelts nx2 (offset nx2 + sint sx) = h \<longrightarrow> int'32_in_bounds (sint sx + (1 :: int)) \<and> (\<forall>(o8 :: 32 word). sint o8 = sint sx + (1 :: int) \<longrightarrow> ((2 :: int) \<le> sint o8 \<and> valid nx2 (sint o8) \<and> valid ny1 (2 :: int) \<and> valid q (sint o8 - (2 :: int)) \<and> ((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint (pelts ny1 (offset ny1 + (1 :: int))) \<and> writable q = True \<and> writable nx2 = True) \<and> (\<forall>(nx3 :: 64 word ptr) (q1 :: 64 word ptr). length (data nx3) = length (data nx2) \<and> offset nx3 = offset nx2 \<and> c_C.min nx3 = c_C.min nx2 \<and> c_C.max nx3 = c_C.max nx2 \<and> writable nx3 = writable nx2 \<and> zone1 nx3 = zone1 nx2 \<longrightarrow> length (data q1) = length (data q) \<and> offset q1 = offset q \<and> c_C.min q1 = c_C.min q \<and> c_C.max q1 = c_C.max q \<and> writable q1 = writable q \<and> zone1 q1 = zone1 q \<longrightarrow> (\<forall>(x_qh :: 64 word). value nx2 (sint o8) = (value q1 (sint o8 - (2 :: int)) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint o8 - (2 :: int)) * uint x_qh) * value ny1 (2 :: int) + value nx3 (2 :: int) \<and> value nx3 (2 :: int) < value ny1 (2 :: int) \<and> (0 :: int) \<le> uint x_qh \<and> uint x_qh \<le> (1 :: int) \<longrightarrow> (0 :: int) \<le> sint clz \<and> (\<forall>(o9 :: 64 word). uint o9 = sint clz \<longrightarrow> (valid nx3 (sint sy) \<and> valid r (sint sy) \<and> ((0 :: int) < uint o9 \<and> uint o9 < (64 :: int)) \<and> (0 :: int) < sint sy \<and> writable r = True) \<and> (\<forall>(r1 :: 64 word ptr). length (data r1) = length (data r) \<and> offset r1 = offset r \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> writable r1 = writable r \<and> zone1 r1 = zone1 r \<longrightarrow> (\<forall>(x_l :: 64 word). uint x_l + ((18446744073709551615 :: int) + (1 :: int)) * value r1 (sint sy) = value nx3 (sint sy) * (2 :: int) ^\<^sub>i ((64 :: int) - uint o9) \<longrightarrow> value x (sint sx) = value q1 (sint sx - sint sy + (1 :: int)) * value y (sint sy) + value r1 (sint sy) \<and> value r1 (sint sy) < value y (sint sy))))))))))))))))))) else int'32_in_bounds (sint sy - (1 :: int)) \<and> (\<forall>(o3 :: 32 word). sint o3 = sint sy - (1 :: int) \<longrightarrow> (c_C.min y \<le> offset y + sint o3 \<and> offset y + sint o3 < c_C.max y) \<and> int'32_in_bounds (sint sx - (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint sx - (1 :: int) \<longrightarrow> (c_C.min x \<le> offset x + sint o4 \<and> offset x + sint o4 < c_C.max x) \<and> (\<forall>(adjust :: 32 word). (if uint (pelts y (offset y + sint o3)) \<le> uint (pelts x (offset x + sint o4)) then adjust = (1 :: 32 word) else adjust = (0 :: 32 word)) \<longrightarrow> int'32_in_bounds (sint sy - (1 :: int)) \<and> (\<forall>(o5 :: 32 word). sint o5 = sint sy - (1 :: int) \<longrightarrow> (c_C.min y \<le> offset y + sint o5 \<and> offset y + sint o5 < c_C.max y) \<and> (let o6 :: 64 word = pelts y (offset y + sint o5) in (0 :: int) < uint o6 \<and> (\<forall>(clz :: 32 word). (2 :: int) ^\<^sub>i sint clz * uint o6 < (18446744073709551615 :: int) + (1 :: int) \<and> (18446744073709551615 :: int) + (1 :: int) \<le> (2 :: int) * (2 :: int) ^\<^sub>i sint clz * uint o6 \<and> ((0 :: int) \<le> sint clz \<and> sint clz < (64 :: int)) \<and> (2 :: int) ^\<^sub>i sint clz * uint o6 \<le> (18446744073709551615 :: int) + (1 :: int) - (2 :: int) ^\<^sub>i sint clz \<longrightarrow> (let p :: int = (2 :: int) ^\<^sub>i sint clz in \<forall>(o7 :: bool). (sint clz = sint (0 :: 32 word) \<longrightarrow> o7 = True) \<and> (o7 = True \<longrightarrow> clz = (0 :: 32 word)) \<longrightarrow> (if o7 = True then (valid x (sint sx) \<and> valid nx (sint sx) \<and> writable nx = True) \<and> (\<forall>(nx1 :: 64 word ptr). length (data nx1) = length (data nx) \<and> offset nx1 = offset nx \<and> c_C.min nx1 = c_C.min nx \<and> c_C.max nx1 = c_C.max nx \<and> writable nx1 = writable nx \<and> zone1 nx1 = zone1 nx \<longrightarrow> map_eq_sub_shift (pelts nx1) (pelts x) (offset nx1) (offset x) (sint sx) \<and> (\<forall>(j :: int). j < offset nx1 \<or> offset nx1 + sint sx \<le> j \<longrightarrow> pelts nx1 j = pelts nx j) \<longrightarrow> ((c_C.min nx1 \<le> offset nx1 + sint sx \<and> offset nx1 + sint sx < c_C.max nx1) \<and> writable nx1 = True) \<and> (\<forall>(nx2 :: 64 word ptr). length (data nx2) = length (data nx1) \<and> offset nx2 = offset nx1 \<and> c_C.min nx2 = c_C.min nx1 \<and> c_C.max nx2 = c_C.max nx1 \<and> writable nx2 = writable nx1 \<and> zone1 nx2 = zone1 nx1 \<longrightarrow> pelts nx2 = (pelts nx1)(offset nx2 + sint sx := 0 :: 64 word) \<and> pelts nx2 (offset nx2 + sint sx) = (0 :: 64 word) \<longrightarrow> int'32_in_bounds (sint sx + sint adjust) \<and> (\<forall>(o8 :: 32 word). sint o8 = sint sx + sint adjust \<longrightarrow> (((3 :: int) \<le> sint sy \<and> sint sy \<le> sint o8) \<and> valid nx2 (sint o8) \<and> valid y (sint sy) \<and> valid q (sint o8 - sint sy) \<and> writable q = True \<and> writable nx2 = True \<and> normalized y sy) \<and> (\<forall>(nx3 :: 64 word ptr) (q1 :: 64 word ptr). length (data nx3) = length (data nx2) \<and> offset nx3 = offset nx2 \<and> c_C.min nx3 = c_C.min nx2 \<and> c_C.max nx3 = c_C.max nx2 \<and> writable nx3 = writable nx2 \<and> zone1 nx3 = zone1 nx2 \<longrightarrow> length (data q1) = length (data q) \<and> offset q1 = offset q \<and> c_C.min q1 = c_C.min q \<and> c_C.max q1 = c_C.max q \<and> writable q1 = writable q \<and> zone1 q1 = zone1 q \<longrightarrow> (\<forall>(x_qh :: 64 word). value nx2 (sint o8) = (value q1 (sint o8 - sint sy) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint o8 - sint sy) * uint x_qh) * value y (sint sy) + value nx3 (sint sy) \<and> value nx3 (sint sy) < value y (sint sy) \<and> (0 :: int) \<le> uint x_qh \<and> uint x_qh \<le> (1 :: int) \<longrightarrow> (valid nx3 (sint sy) \<and> valid r (sint sy) \<and> writable r = True) \<and> (\<forall>(r1 :: 64 word ptr). length (data r1) = length (data r) \<and> offset r1 = offset r \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> writable r1 = writable r \<and> zone1 r1 = zone1 r \<longrightarrow> map_eq_sub_shift (pelts r1) (pelts nx3) (offset r1) (offset nx3) (sint sy) \<and> (\<forall>(j :: int). j < offset r1 \<or> offset r1 + sint sy \<le> j \<longrightarrow> pelts r1 j = pelts r j) \<longrightarrow> (\<forall>(o9 :: bool). (sint adjust = sint (0 :: 32 word) \<longrightarrow> o9 = True) \<and> (o9 = True \<longrightarrow> adjust = (0 :: 32 word)) \<longrightarrow> (if o9 = True then int'32_in_bounds (sint sx - sint sy) \<and> (\<forall>(o10 :: 32 word). sint o10 = sint sx - sint sy \<longrightarrow> ((c_C.min q1 \<le> offset q1 + sint o10 \<and> offset q1 + sint o10 < c_C.max q1) \<and> writable q1 = True) \<and> (\<forall>(q2 :: 64 word ptr). length (data q2) = length (data q1) \<and> offset q2 = offset q1 \<and> c_C.min q2 = c_C.min q1 \<and> c_C.max q2 = c_C.max q1 \<and> writable q2 = writable q1 \<and> zone1 q2 = zone1 q1 \<longrightarrow> pelts q2 = (pelts q1)(offset q2 + sint o10 := 0 :: 64 word) \<and> pelts q2 (offset q2 + sint o10) = (0 :: 64 word) \<longrightarrow> value q2 (sint sx - sint sy + (1 :: int)) = value q1 (sint sx - sint sy + sint adjust))) else value q1 (sint sx - sint sy + (1 :: int)) = value q1 (sint sx - sint sy + sint adjust))) \<and> (\<forall>(q2 :: 64 word ptr). length (data q2) = length (data q1) \<and> offset q2 = offset q1 \<and> c_C.min q2 = c_C.min q1 \<and> c_C.max q2 = c_C.max q1 \<and> writable q2 = writable q1 \<and> zone1 q2 = zone1 q1 \<longrightarrow> value q2 (sint sx - sint sy + (1 :: int)) = value q1 (sint sx - sint sy + sint adjust) \<longrightarrow> value x (sint sx) = value q2 (sint sx - sint sy + (1 :: int)) * value y (sint sy) + value r1 (sint sy) \<and> value r1 (sint sy) < value y (sint sy)))))))) else (0 :: int) \<le> sint clz \<and> (\<forall>(o8 :: 64 word). uint o8 = sint clz \<longrightarrow> (((0 :: int) < uint o8 \<and> uint o8 < (64 :: int)) \<and> valid ny (sint sy) \<and> valid y (sint sy) \<and> writable ny = True \<and> (0 :: int) < sint sy) \<and> (\<forall>(ny1 :: 64 word ptr). length (data ny1) = length (data ny) \<and> offset ny1 = offset ny \<and> c_C.min ny1 = c_C.min ny \<and> c_C.max ny1 = c_C.max ny \<and> writable ny1 = writable ny \<and> zone1 ny1 = zone1 ny \<longrightarrow> (\<forall>(x_c :: 64 word). value ny1 (sint sy) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sy * uint x_c = value y (sint sy) * (2 :: int) ^\<^sub>i uint o8 \<longrightarrow> (normalized ny1 sy \<and> value ny1 (sint sy) = (2 :: int) ^\<^sub>i sint clz * value y (sint sy)) \<and> (normalized ny1 sy \<and> value ny1 (sint sy) = (2 :: int) ^\<^sub>i sint clz * value y (sint sy) \<longrightarrow> (0 :: int) \<le> sint clz \<and> (\<forall>(o9 :: 64 word). uint o9 = sint clz \<longrightarrow> (((0 :: int) < uint o9 \<and> uint o9 < (64 :: int)) \<and> valid nx (sint sx) \<and> valid x (sint sx) \<and> writable nx = True \<and> (0 :: int) < sint sx) \<and> (\<forall>(nx1 :: 64 word ptr). length (data nx1) = length (data nx) \<and> offset nx1 = offset nx \<and> c_C.min nx1 = c_C.min nx \<and> c_C.max nx1 = c_C.max nx \<and> writable nx1 = writable nx \<and> zone1 nx1 = zone1 nx \<longrightarrow> (\<forall>(h :: 64 word). value nx1 (sint sx) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sx * uint h = value x (sint sx) * (2 :: int) ^\<^sub>i uint o9 \<longrightarrow> ((c_C.min nx1 \<le> offset nx1 + sint sx \<and> offset nx1 + sint sx < c_C.max nx1) \<and> writable nx1 = True) \<and> (\<forall>(nx2 :: 64 word ptr). length (data nx2) = length (data nx1) \<and> offset nx2 = offset nx1 \<and> c_C.min nx2 = c_C.min nx1 \<and> c_C.max nx2 = c_C.max nx1 \<and> writable nx2 = writable nx1 \<and> zone1 nx2 = zone1 nx1 \<longrightarrow> pelts nx2 = (pelts nx1)(offset nx2 + sint sx := h) \<and> pelts nx2 (offset nx2 + sint sx) = h \<longrightarrow> (\<forall>(o10 :: bool). (sint adjust = sint (1 :: 32 word) \<longrightarrow> o10 = True) \<and> (o10 = True \<longrightarrow> adjust = (1 :: 32 word)) \<longrightarrow> value nx2 (sint sx + sint adjust) = p * value x (sint sx)) \<and> (value nx2 (sint sx + sint adjust) = p * value x (sint sx) \<longrightarrow> int'32_in_bounds (sint sx + sint adjust) \<and> (\<forall>(o10 :: 32 word). sint o10 = sint sx + sint adjust \<longrightarrow> (((3 :: int) \<le> sint sy \<and> sint sy \<le> sint o10) \<and> valid nx2 (sint o10) \<and> valid ny1 (sint sy) \<and> valid q (sint o10 - sint sy) \<and> writable q = True \<and> writable nx2 = True \<and> normalized ny1 sy) \<and> (\<forall>(nx3 :: 64 word ptr) (q1 :: 64 word ptr). length (data nx3) = length (data nx2) \<and> offset nx3 = offset nx2 \<and> c_C.min nx3 = c_C.min nx2 \<and> c_C.max nx3 = c_C.max nx2 \<and> writable nx3 = writable nx2 \<and> zone1 nx3 = zone1 nx2 \<longrightarrow> length (data q1) = length (data q) \<and> offset q1 = offset q \<and> c_C.min q1 = c_C.min q \<and> c_C.max q1 = c_C.max q \<and> writable q1 = writable q \<and> zone1 q1 = zone1 q \<longrightarrow> (\<forall>(x_qh :: 64 word). value nx2 (sint o10) = (value q1 (sint o10 - sint sy) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint o10 - sint sy) * uint x_qh) * value ny1 (sint sy) + value nx3 (sint sy) \<and> value nx3 (sint sy) < value ny1 (sint sy) \<and> (0 :: int) \<le> uint x_qh \<and> uint x_qh \<le> (1 :: int) \<longrightarrow> (0 :: int) \<le> sint clz \<and> (\<forall>(o11 :: 64 word). uint o11 = sint clz \<longrightarrow> (valid nx3 (sint sy) \<and> valid r (sint sy) \<and> ((0 :: int) < uint o11 \<and> uint o11 < (64 :: int)) \<and> (0 :: int) < sint sy \<and> writable r = True) \<and> (\<forall>(r1 :: 64 word ptr). length (data r1) = length (data r) \<and> offset r1 = offset r \<and> c_C.min r1 = c_C.min r \<and> c_C.max r1 = c_C.max r \<and> writable r1 = writable r \<and> zone1 r1 = zone1 r \<longrightarrow> (\<forall>(x_l :: 64 word). uint x_l + ((18446744073709551615 :: int) + (1 :: int)) * value r1 (sint sy) = value nx3 (sint sy) * (2 :: int) ^\<^sub>i ((64 :: int) - uint o11) \<longrightarrow> value nx3 (sint sy) = p * value r1 (sint sy) \<and> (value nx3 (sint sy) = p * value r1 (sint sy) \<longrightarrow> (\<forall>(o12 :: bool). (sint adjust = sint (0 :: 32 word) \<longrightarrow> o12 = True) \<and> (o12 = True \<longrightarrow> adjust = (0 :: 32 word)) \<longrightarrow> (if o12 = True then int'32_in_bounds (sint sx - sint sy) \<and> (\<forall>(o13 :: 32 word). sint o13 = sint sx - sint sy \<longrightarrow> ((c_C.min q1 \<le> offset q1 + sint o13 \<and> offset q1 + sint o13 < c_C.max q1) \<and> writable q1 = True) \<and> (\<forall>(q2 :: 64 word ptr). length (data q2) = length (data q1) \<and> offset q2 = offset q1 \<and> c_C.min q2 = c_C.min q1 \<and> c_C.max q2 = c_C.max q1 \<and> writable q2 = writable q1 \<and> zone1 q2 = zone1 q1 \<longrightarrow> pelts q2 = (pelts q1)(offset q2 + sint o13 := 0 :: 64 word) \<and> pelts q2 (offset q2 + sint o13) = (0 :: 64 word) \<longrightarrow> value q2 (sint sx - sint sy + (1 :: int)) = value q1 (sint sx - sint sy + sint adjust))) else value q1 (sint sx - sint sy + (1 :: int)) = value q1 (sint sx - sint sy + sint adjust))) \<and> (\<forall>(q2 :: 64 word ptr). length (data q2) = length (data q1) \<and> offset q2 = offset q1 \<and> c_C.min q2 = c_C.min q1 \<and> c_C.max q2 = c_C.max q1 \<and> writable q2 = writable q1 \<and> zone1 q2 = zone1 q1 \<longrightarrow> value q2 (sint sx - sint sy + (1 :: int)) = value q1 (sint sx - sint sy + sint adjust) \<longrightarrow> value x (sint sx) = value q2 (sint sx - sint sy + (1 :: int)) * value y (sint sy) + value r1 (sint sy) \<and> value r1 (sint sy) < value y (sint sy)))))))))))))))))))))))))))"
  sorry
end
