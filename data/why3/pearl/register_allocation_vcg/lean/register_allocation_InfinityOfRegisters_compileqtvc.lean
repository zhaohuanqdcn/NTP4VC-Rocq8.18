import Why3.Base
import pearl.register_allocation_vcg.lean.register_allocation.Spec
import pearl.register_allocation_vcg.lean.register_allocation.DWP
open Classical
open Lean4Why3
namespace register_allocation_InfinityOfRegisters_compileqtvc
axiom identity : (Spec.state -> Bool) -> Spec.state -> Bool
axiom exec_closure : Spec.instr -> Spec.state -> Spec.state
axiom identity_def (y : Spec.state -> Bool) : identity y = y
axiom exec_closure_def (y : Spec.instr) (y1 : Spec.state) : exec_closure y y1 = Spec.exec y y1
theorem compile'vc (e : Spec.expr) (r : ℤ) : let o1 : Spec.state -> Spec.state -> Bool := Spec.expr_post e r; (match e with | Spec.expr.Evar x => (∀(o2 : DWP.wcode), DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = identity → DWP.wcode_ok o2) | Spec.expr.Eneg e1 => (∀(o2 : DWP.wcode), DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = identity → DWP.wcode_ok o2 ∧ (∀(o3 : DWP.wcode), DWP.wcode_ok o3 ∧ DWP.wcode.trans1 o3 = DWP.rcompose (DWP.wcode.trans1 o2) (DWP.rcompose (exec_closure (Spec.instr.Ineg r))) → (match e with | Spec.expr.Evar _ => False | Spec.expr.Eneg f => f = e1 | Spec.expr.Eadd f f1 => f = e1 ∨ f1 = e1) ∧ (∀(o4 : DWP.hcode), DWP.hcode_ok o4 ∧ DWP.hcode.post1 o4 = Spec.expr_post e1 r → DWP.hcode_ok o4 ∧ (∀(o5 : DWP.wcode), DWP.wcode_ok o5 ∧ DWP.wcode.trans1 o5 = DWP.to_wp (DWP.hcode.post1 o4) → DWP.wcode_ok o5 ∧ DWP.wcode_ok o3)))) | Spec.expr.Eadd e1 e2 => (∀(o2 : DWP.wcode), DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = identity → DWP.wcode_ok o2 ∧ (∀(o3 : DWP.wcode), DWP.wcode_ok o3 ∧ DWP.wcode.trans1 o3 = DWP.rcompose (DWP.wcode.trans1 o2) (DWP.rcompose (exec_closure (Spec.instr.Iadd (r + (1 : ℤ)) r))) → (match e with | Spec.expr.Evar _ => False | Spec.expr.Eneg f => f = e2 | Spec.expr.Eadd f f1 => f = e2 ∨ f1 = e2) ∧ (∀(o4 : DWP.hcode), DWP.hcode_ok o4 ∧ DWP.hcode.post1 o4 = Spec.expr_post e2 (r + (1 : ℤ)) → DWP.hcode_ok o4 ∧ (∀(o5 : DWP.wcode), DWP.wcode_ok o5 ∧ DWP.wcode.trans1 o5 = DWP.to_wp (DWP.hcode.post1 o4) → (match e with | Spec.expr.Evar _ => False | Spec.expr.Eneg f => f = e1 | Spec.expr.Eadd f f1 => f = e1 ∨ f1 = e1) ∧ (∀(o6 : DWP.hcode), DWP.hcode_ok o6 ∧ DWP.hcode.post1 o6 = Spec.expr_post e1 r → DWP.hcode_ok o6 ∧ (∀(o7 : DWP.wcode), DWP.wcode_ok o7 ∧ DWP.wcode.trans1 o7 = DWP.to_wp (DWP.hcode.post1 o6) → (DWP.wcode_ok o7 ∧ DWP.wcode_ok o5) ∧ (∀(o8 : DWP.wcode), DWP.wcode_ok o8 ∧ DWP.wcode.trans1 o8 = DWP.rcompose (DWP.wcode.trans1 o5) (DWP.wcode.trans1 o7) → DWP.wcode_ok o8 ∧ DWP.wcode_ok o3)))))))) ∧ (∀(o2 : DWP.wcode), (match e with | Spec.expr.Evar x => (∃(o3 : DWP.wcode), (DWP.wcode_ok o3 ∧ DWP.wcode.trans1 o3 = identity) ∧ DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = DWP.rcompose (DWP.wcode.trans1 o3) (DWP.rcompose (exec_closure (Spec.instr.Iload x r)))) | Spec.expr.Eneg e1 => (∃(o3 : DWP.wcode), (DWP.wcode_ok o3 ∧ DWP.wcode.trans1 o3 = identity) ∧ (∃(o4 : DWP.wcode), (DWP.wcode_ok o4 ∧ DWP.wcode.trans1 o4 = DWP.rcompose (DWP.wcode.trans1 o3) (DWP.rcompose (exec_closure (Spec.instr.Ineg r)))) ∧ (∃(o5 : DWP.hcode), (DWP.hcode_ok o5 ∧ DWP.hcode.post1 o5 = Spec.expr_post e1 r) ∧ (∃(o6 : DWP.wcode), (DWP.wcode_ok o6 ∧ DWP.wcode.trans1 o6 = DWP.to_wp (DWP.hcode.post1 o5)) ∧ DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = DWP.rcompose (DWP.wcode.trans1 o4) (DWP.wcode.trans1 o6))))) | Spec.expr.Eadd e1 e2 => (∃(o3 : DWP.wcode), (DWP.wcode_ok o3 ∧ DWP.wcode.trans1 o3 = identity) ∧ (∃(o4 : DWP.wcode), (DWP.wcode_ok o4 ∧ DWP.wcode.trans1 o4 = DWP.rcompose (DWP.wcode.trans1 o3) (DWP.rcompose (exec_closure (Spec.instr.Iadd (r + (1 : ℤ)) r)))) ∧ (∃(o5 : DWP.hcode), (DWP.hcode_ok o5 ∧ DWP.hcode.post1 o5 = Spec.expr_post e2 (r + (1 : ℤ))) ∧ (∃(o6 : DWP.wcode), (DWP.wcode_ok o6 ∧ DWP.wcode.trans1 o6 = DWP.to_wp (DWP.hcode.post1 o5)) ∧ (∃(o7 : DWP.hcode), (DWP.hcode_ok o7 ∧ DWP.hcode.post1 o7 = Spec.expr_post e1 r) ∧ (∃(o8 : DWP.wcode), (DWP.wcode_ok o8 ∧ DWP.wcode.trans1 o8 = DWP.to_wp (DWP.hcode.post1 o7)) ∧ (∃(o9 : DWP.wcode), (DWP.wcode_ok o9 ∧ DWP.wcode.trans1 o9 = DWP.rcompose (DWP.wcode.trans1 o6) (DWP.wcode.trans1 o8)) ∧ DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = DWP.rcompose (DWP.wcode.trans1 o4) (DWP.wcode.trans1 o9))))))))) → (DWP.wcode_ok o2 ∧ (∀(x : Spec.state), DWP.wcode.trans1 o2 (o1 x) x = true)) ∧ (∀(result : DWP.hcode), DWP.hcode_ok result ∧ DWP.hcode.post1 result = o1 → DWP.hcode_ok result ∧ DWP.hcode.post1 result = Spec.expr_post e r))
  := sorry
end register_allocation_InfinityOfRegisters_compileqtvc
