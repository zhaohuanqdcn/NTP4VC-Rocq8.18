theory mergesort_queue_MergesortQueue_mergeqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.int_NumOf" "Why3STD.queue_Queue"
begin
typedecl  elt
consts le :: "elt \<Rightarrow> elt \<Rightarrow> bool"
axiomatization where Refl:   "le x x"
  for x :: "elt"
axiomatization where Trans:   "le x z"
 if "le x y"
 and "le y z"
  for x :: "elt"
  and y :: "elt"
  and z :: "elt"
axiomatization where Total:   "le x y \<or> le y x"
  for x :: "elt"
  and y :: "elt"
definition sorted_sub :: "elt list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "sorted_sub s l u \<longleftrightarrow> (\<forall>(i1 :: int) (i2 :: int). l \<le> i1 \<and> i1 \<le> i2 \<and> i2 < u \<longrightarrow> le (s ! nat i1) (s ! nat i2))" for s l u
definition sorted :: "elt list \<Rightarrow> _"
  where "sorted s \<longleftrightarrow> sorted_sub s (0 :: int) (int (length s))" for s
axiomatization where sorted_cons:   "(\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length s) \<longrightarrow> le x (s ! nat i)) \<and> sorted s \<longleftrightarrow> sorted (Cons x s)"
  for s :: "elt list"
  and x :: "elt"
axiomatization where sorted_append:   "sorted s1 \<and> sorted s2 \<and> (\<forall>(i :: int) (j :: int). ((0 :: int) \<le> i \<and> i < int (length s1)) \<and> (0 :: int) \<le> j \<and> j < int (length s2) \<longrightarrow> le (s1 ! nat i) (s2 ! nat j)) \<longleftrightarrow> sorted (s1 @ s2)"
  for s1 :: "elt list"
  and s2 :: "elt list"
axiomatization where sorted_snoc:   "(\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length s) \<longrightarrow> le (s ! nat i) x) \<and> sorted s \<longleftrightarrow> sorted (s @ [x])"
  for s :: "elt list"
  and x :: "elt"
theorem merge'vc:
  fixes q :: "elt t"
  fixes q1 :: "elt t"
  fixes q2 :: "elt t"
  assumes fact0: "seq q = []"
  assumes fact1: "sorted (seq q1)"
  assumes fact2: "sorted (seq q2)"
  shows "sorted (seq q1)"
  and "sorted (seq q2)"
  and "sorted (seq q)"
  and "\<forall>(x :: elt) (y :: elt). x \<in> set (seq q) \<longrightarrow> y \<in> set (seq q1) \<longrightarrow> le x y"
  and "\<forall>(x :: elt) (y :: elt). x \<in> set (seq q) \<longrightarrow> y \<in> set (seq q2) \<longrightarrow> le x y"
  and "int (length (seq q)) + int (length (seq q1)) + int (length (seq q2)) = int (length (seq q1)) + int (length (seq q2))"
  and "\<forall>(x :: elt). int (count_list (seq q) x) + int (count_list (seq q1) x) + int (count_list (seq q2) x) = int (count_list (seq q1) x) + int (count_list (seq q2) x)"
  and "\<forall>(q3 :: elt t) (q21 :: elt t) (q11 :: elt t). (sorted (seq q11) \<and> sorted (seq q21) \<and> sorted (seq q3)) \<and> (\<forall>(x :: elt) (y :: elt). x \<in> set (seq q3) \<longrightarrow> y \<in> set (seq q11) \<longrightarrow> le x y) \<and> (\<forall>(x :: elt) (y :: elt). x \<in> set (seq q3) \<longrightarrow> y \<in> set (seq q21) \<longrightarrow> le x y) \<and> int (length (seq q3)) + int (length (seq q11)) + int (length (seq q21)) = int (length (seq q1)) + int (length (seq q2)) \<and> (\<forall>(x :: elt). int (count_list (seq q3) x) + int (count_list (seq q11) x) + int (count_list (seq q21) x) = int (count_list (seq q1) x) + int (count_list (seq q2) x)) \<longrightarrow> (\<forall>(o1 :: bool). (if seq q11 = [] then o1 = (if seq q21 = [] then True else False) else o1 = False) \<longrightarrow> (if \<not>o1 = True then if seq q11 = [] then \<not>seq q21 = [] \<and> (\<forall>(q22 :: elt t). seq q22 = drop (1 :: nat) (seq q21) \<longrightarrow> (\<forall>(q4 :: elt t). seq q4 = seq q3 @ [seq q21 ! (0 :: nat)] \<longrightarrow> ((0 :: int) \<le> int (length (seq q11)) + int (length (seq q21)) \<and> int (length (seq q11)) + int (length (seq q22)) < int (length (seq q11)) + int (length (seq q21))) \<and> (sorted (seq q11) \<and> sorted (seq q22) \<and> sorted (seq q4)) \<and> (\<forall>(x :: elt) (y :: elt). x \<in> set (seq q4) \<longrightarrow> y \<in> set (seq q11) \<longrightarrow> le x y) \<and> (\<forall>(x :: elt) (y :: elt). x \<in> set (seq q4) \<longrightarrow> y \<in> set (seq q22) \<longrightarrow> le x y) \<and> int (length (seq q4)) + int (length (seq q11)) + int (length (seq q22)) = int (length (seq q1)) + int (length (seq q2)) \<and> (\<forall>(x :: elt). int (count_list (seq q4) x) + int (count_list (seq q11) x) + int (count_list (seq q22) x) = int (count_list (seq q1) x) + int (count_list (seq q2) x)))) else if seq q21 = [] then \<not>seq q11 = [] \<and> (\<forall>(q12 :: elt t). seq q12 = drop (1 :: nat) (seq q11) \<longrightarrow> (\<forall>(q4 :: elt t). seq q4 = seq q3 @ [seq q11 ! (0 :: nat)] \<longrightarrow> ((0 :: int) \<le> int (length (seq q11)) + int (length (seq q21)) \<and> int (length (seq q12)) + int (length (seq q21)) < int (length (seq q11)) + int (length (seq q21))) \<and> (sorted (seq q12) \<and> sorted (seq q21) \<and> sorted (seq q4)) \<and> (\<forall>(x :: elt) (y :: elt). x \<in> set (seq q4) \<longrightarrow> y \<in> set (seq q12) \<longrightarrow> le x y) \<and> (\<forall>(x :: elt) (y :: elt). x \<in> set (seq q4) \<longrightarrow> y \<in> set (seq q21) \<longrightarrow> le x y) \<and> int (length (seq q4)) + int (length (seq q12)) + int (length (seq q21)) = int (length (seq q1)) + int (length (seq q2)) \<and> (\<forall>(x :: elt). int (count_list (seq q4) x) + int (count_list (seq q12) x) + int (count_list (seq q21) x) = int (count_list (seq q1) x) + int (count_list (seq q2) x)))) else \<not>seq q11 = [] \<and> \<not>seq q21 = [] \<and> (if le (seq q11 ! (0 :: nat)) (seq q21 ! (0 :: nat)) then \<not>seq q11 = [] \<and> (\<forall>(q12 :: elt t). seq q12 = drop (1 :: nat) (seq q11) \<longrightarrow> (\<forall>(q4 :: elt t). seq q4 = seq q3 @ [seq q11 ! (0 :: nat)] \<longrightarrow> ((0 :: int) \<le> int (length (seq q11)) + int (length (seq q21)) \<and> int (length (seq q12)) + int (length (seq q21)) < int (length (seq q11)) + int (length (seq q21))) \<and> (sorted (seq q12) \<and> sorted (seq q21) \<and> sorted (seq q4)) \<and> (\<forall>(x :: elt) (y :: elt). x \<in> set (seq q4) \<longrightarrow> y \<in> set (seq q12) \<longrightarrow> le x y) \<and> (\<forall>(x :: elt) (y :: elt). x \<in> set (seq q4) \<longrightarrow> y \<in> set (seq q21) \<longrightarrow> le x y) \<and> int (length (seq q4)) + int (length (seq q12)) + int (length (seq q21)) = int (length (seq q1)) + int (length (seq q2)) \<and> (\<forall>(x :: elt). int (count_list (seq q4) x) + int (count_list (seq q12) x) + int (count_list (seq q21) x) = int (count_list (seq q1) x) + int (count_list (seq q2) x)))) else \<not>seq q21 = [] \<and> (\<forall>(q22 :: elt t). seq q22 = drop (1 :: nat) (seq q21) \<longrightarrow> (\<forall>(q4 :: elt t). seq q4 = seq q3 @ [seq q21 ! (0 :: nat)] \<longrightarrow> ((0 :: int) \<le> int (length (seq q11)) + int (length (seq q21)) \<and> int (length (seq q11)) + int (length (seq q22)) < int (length (seq q11)) + int (length (seq q21))) \<and> (sorted (seq q11) \<and> sorted (seq q22) \<and> sorted (seq q4)) \<and> (\<forall>(x :: elt) (y :: elt). x \<in> set (seq q4) \<longrightarrow> y \<in> set (seq q11) \<longrightarrow> le x y) \<and> (\<forall>(x :: elt) (y :: elt). x \<in> set (seq q4) \<longrightarrow> y \<in> set (seq q22) \<longrightarrow> le x y) \<and> int (length (seq q4)) + int (length (seq q11)) + int (length (seq q22)) = int (length (seq q1)) + int (length (seq q2)) \<and> (\<forall>(x :: elt). int (count_list (seq q4) x) + int (count_list (seq q11) x) + int (count_list (seq q22) x) = int (count_list (seq q1) x) + int (count_list (seq q2) x))))) else sorted (seq q3) \<and> int (length (seq q3)) = int (length (seq q1)) + int (length (seq q2)) \<and> (\<forall>(x :: elt). int (count_list (seq q3) x) = int (count_list (seq q1) x) + int (count_list (seq q2) x))))"
  sorry
end
