theory A_OccArray_A_OccArray
  imports "NTP4Verif.NTP4Verif" "Why3STD.Qed_Qed" "Why3STD.Memory_Memory" "../../lib/isabelle/Compound_Compound"
begin
consts l_occ_a :: "(addr \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> addr \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int"
axiomatization where Q_end_occ_a:   "l_occ_a mchar_0 e t from_0 to_0 = (0 :: int)"
 if "to_0 \<le> from_0"
  for to_0 :: "int"
  and from_0 :: "int"
  and mchar_0 :: "addr \<Rightarrow> int"
  and e :: "int"
  and t :: "addr"
axiomatization where Q_iter_occ_a_true:   "mchar_0 (shift t (to_0 - (1 :: int))) = e \<longrightarrow> from_0 < to_0 \<longrightarrow> (1 :: int) + l_occ_a mchar_0 e t from_0 (to_0 - (1 :: int)) = l_occ_a mchar_0 e t from_0 to_0"
  for to_0 :: "int"
  and mchar_0 :: "addr \<Rightarrow> int"
  and t :: "addr"
  and e :: "int"
  and from_0 :: "int"
axiomatization where Q_iter_occ_a_false:   "\<not>mchar_0 (shift t (to_0 - (1 :: int))) = e \<longrightarrow> from_0 < to_0 \<longrightarrow> l_occ_a mchar_0 e t from_0 (to_0 - (1 :: int)) = l_occ_a mchar_0 e t from_0 to_0"
  for to_0 :: "int"
  and mchar_0 :: "addr \<Rightarrow> int"
  and t :: "addr"
  and e :: "int"
  and from_0 :: "int"
end
