From Stdlib Require Import Strings.String.
From Stdlib Require Import String Ascii.
From Stdlib Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Stdlib Require Classical.
From Stdlib Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Stdlib Require Import Sorting.Sorted.
From Stdlib Require Import Reals.Rbasic_fun.
From Stdlib Require Import Reals.Abstract.ConstructiveAbs.
From Stdlib Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Stdlib Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Stdlib Require Import ZArith.Zeuclid.
From Stdlib Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Stdlib Require Import Reals.
Require Import Why3.Base.
Require Import prover.BacktrackArray.Types.
Require Import prover.Functions.Config.
Require Import prover.Functions.Func.
Require Import prover.Predicates.Pred.
Require Import prover.BacktrackArray.Logic.
Require Import prover.Choice.Choice.
Open Scope Z_scope.
Theorem backtrack'vc {α : Type} `{Inhabited α} (t : timestamp α) (tb : Types.t α) (fact0 : past_time t tb) (fact1 : correct tb) : let final_size : Z := Types.size t in let o1 : list (list α) := buffer tb in ∀(o2 : list (list α)), length o2 = length o1 ∧ (∀(i : Z), 0%Z ≤ i ∧ i < Z.of_nat (length o2) -> nth (Z.to_nat i) o2 inhabitant = nth (Z.to_nat i) o1 inhabitant) -> (let tbc : Types.t α := t'mk (history tb) (current_time tb) o2 (inv tb) in (∀(tbc1 : Types.t α) (tb1 : Types.t α), inv tbc1 = inv tb -> inv tb1 = inv tb -> (∀(delta : Z), correct tbc1 ∧ past_time t tbc1 ∧ 0%Z ≤ delta ∧ current_time tbc1 = time t + delta ∧ (history tbc1 = history tb1 ∧ (∀(x : Z), (0%Z ≤ x ∧ x < final_size) ∧ x < Z.of_nat (length (buffer tbc1)) -> func_of_array (buffer tbc1) ([] : list α) x = func_of_array (buffer tb1) ([] : list α) x)) ∧ Z.of_nat (length (buffer tb1)) ≤ final_size -> (if decide (¬ delta = 0%Z) then match history tb1 with | [] => False | cons x q => (∀(tb2 : Types.t α), history tb2 = q ∧ current_time tb2 = current_time tb1 ∧ buffer tb2 = buffer tb1 ∧ inv tb2 = inv tb1 -> (∀(tbc2 : Types.t α), history tbc2 = q ∧ current_time tbc2 = current_time tbc1 ∧ buffer tbc2 = buffer tbc1 ∧ inv tbc2 = inv tbc1 -> (∀(tbc3 : Types.t α), history tbc3 = history tbc2 ∧ current_time tbc3 = current_time tbc2 - 1%Z ∧ buffer tbc3 = buffer tbc2 ∧ inv tbc3 = inv tbc2 -> (if decide (x = - 1%Z) then let buf1 : list (list α) := buffer tbc3 in ¬ 2%Z = 0%Z ∧ (let len2 : Z := Z.rem (Z.of_nat (length buf1)) 2%Z in 0%Z ≤ len2 ∧ (∀(buf2 : list (list α)), (∀(i : Z), 0%Z ≤ i ∧ i < len2 -> nth (Z.to_nat i) buf2 inhabitant = ([] : list α)) ∧ Z.of_nat (length buf2) = len2 -> ((0%Z ≤ 0%Z ∧ 0%Z ≤ len2 ∧ 0%Z + len2 ≤ Z.of_nat (length buf1)) ∧ 0%Z ≤ 0%Z ∧ 0%Z + len2 ≤ Z.of_nat (length buf2)) ∧ (∀(buf21 : list (list α)), length buf21 = length buf2 -> (∀(i : Z), 0%Z ≤ i ∧ i < 0%Z ∨ 0%Z + len2 ≤ i ∧ i < Z.of_nat (length buf21) -> nth (Z.to_nat i) buf21 inhabitant = nth (Z.to_nat i) buf2 inhabitant) ∧ (∀(i : Z), 0%Z ≤ i ∧ i < 0%Z + len2 -> nth (Z.to_nat i) buf21 inhabitant = nth (Z.to_nat (0%Z + i - 0%Z)) buf1 inhabitant) -> (∀(tbc4 : Types.t α), history tbc4 = history tbc3 ∧ current_time tbc4 = current_time tbc3 ∧ buffer tbc4 = buf21 ∧ inv tbc4 = inv tbc3 -> (let o3 : Z := delta - 1%Z in ((0%Z ≤ delta ∧ o3 < delta) ∧ correct tbc4 ∧ past_time t tbc4 ∧ 0%Z ≤ o3 ∧ current_time tbc4 = time t + o3 ∧ (history tbc4 = history tb2 ∧ (∀(x1 : Z), (0%Z ≤ x1 ∧ x1 < final_size) ∧ x1 < Z.of_nat (length (buffer tbc4)) -> func_of_array (buffer tbc4) ([] : list α) x1 = func_of_array (buffer tb2) ([] : list α) x1)) ∧ Z.of_nat (length (buffer tb2)) ≤ final_size) ∧ (∀(tbc5 : Types.t α) (tb3 : Types.t α), inv tbc5 = inv tbc4 -> current_time tb3 = current_time tb2 ∧ length (buffer tb3) = length (buffer tb2) ∧ inv tb3 = inv tb2 -> correct tbc5 ∧ (history tbc5 = history tb3 ∧ (∀(x1 : Z), 0%Z ≤ x1 ∧ x1 < final_size -> func_of_array (buffer tbc5) ([] : list α) x1 = func_of_array (buffer tb3) ([] : list α) x1)) ∧ current_timestamp tbc5 = t ∧ Z.of_nat (length (buffer tbc5)) ≤ Z.of_nat (length (buffer tbc4)) ∧ precede tbc5 tbc4 ∧ (∀(t2 : timestamp α), before t2 t ∧ past_time t2 tbc4 -> past_time t2 tbc5) -> correct tbc5 ∧ (history tbc5 = history tb3 ∧ (∀(x1 : Z), 0%Z ≤ x1 ∧ x1 < final_size -> func_of_array (buffer tbc5) ([] : list α) x1 = func_of_array (buffer tb3) ([] : list α) x1)) ∧ current_timestamp tbc5 = t ∧ Z.of_nat (length (buffer tbc5)) ≤ Z.of_nat (length (buffer tbc1)) ∧ precede tbc5 tbc1 ∧ (∀(t2 : timestamp α), before t2 t ∧ past_time t2 tbc1 -> past_time t2 tbc5))))))) else if decide (x < final_size) then let o3 : list (list α) := buffer tb2 in (0%Z ≤ x ∧ x < Z.of_nat (length o3)) ∧ (match nth (Z.to_nat x) o3 inhabitant with | [] => False | cons _ q1 => (let o4 : list (list α) := buffer tb2 in (0%Z ≤ x ∧ x < Z.of_nat (length o4)) ∧ (∀(tb3 : Types.t α), let o5 : list (list α) := buffer tb3 in length (buffer tb3) = length o4 -> tb3 = t'mk (history tb2) (current_time tb2) (buffer tb3) (inv tb2) ∧ length (buffer tb3) = length (buffer tb2) -> nth_i o5 = fun_updt (nth_i o4) x q1 ∧ o5 = set_list o4 (Z.to_nat x) q1 -> (let o6 : list (list α) := buffer tbc3 in (0%Z ≤ x ∧ x < Z.of_nat (length o6)) ∧ (∀(tbc4 : Types.t α), let o7 : list (list α) := buffer tbc4 in length (buffer tbc4) = length o6 -> tbc4 = t'mk (history tbc3) (current_time tbc3) (buffer tbc4) (inv tbc3) ∧ length (buffer tbc4) = length (buffer tbc3) -> nth_i o7 = fun_updt (nth_i o6) x q1 ∧ o7 = set_list o6 (Z.to_nat x) q1 -> (let o8 : Z := delta - 1%Z in ((0%Z ≤ delta ∧ o8 < delta) ∧ correct tbc4 ∧ past_time t tbc4 ∧ 0%Z ≤ o8 ∧ current_time tbc4 = time t + o8 ∧ (history tbc4 = history tb3 ∧ (∀(x1 : Z), (0%Z ≤ x1 ∧ x1 < final_size) ∧ x1 < Z.of_nat (length (buffer tbc4)) -> func_of_array (buffer tbc4) ([] : list α) x1 = func_of_array (buffer tb3) ([] : list α) x1)) ∧ Z.of_nat (length (buffer tb3)) ≤ final_size) ∧ (∀(tbc5 : Types.t α) (tb4 : Types.t α), inv tbc5 = inv tbc4 -> current_time tb4 = current_time tb3 ∧ length (buffer tb4) = length (buffer tb3) ∧ inv tb4 = inv tb3 -> correct tbc5 ∧ (history tbc5 = history tb4 ∧ (∀(x1 : Z), 0%Z ≤ x1 ∧ x1 < final_size -> func_of_array (buffer tbc5) ([] : list α) x1 = func_of_array (buffer tb4) ([] : list α) x1)) ∧ current_timestamp tbc5 = t ∧ Z.of_nat (length (buffer tbc5)) ≤ Z.of_nat (length (buffer tbc4)) ∧ precede tbc5 tbc4 ∧ (∀(t2 : timestamp α), before t2 t ∧ past_time t2 tbc4 -> past_time t2 tbc5) -> correct tbc5 ∧ (history tbc5 = history tb4 ∧ (∀(x1 : Z), 0%Z ≤ x1 ∧ x1 < final_size -> func_of_array (buffer tbc5) ([] : list α) x1 = func_of_array (buffer tb4) ([] : list α) x1)) ∧ current_timestamp tbc5 = t ∧ Z.of_nat (length (buffer tbc5)) ≤ Z.of_nat (length (buffer tbc1)) ∧ precede tbc5 tbc1 ∧ (∀(t2 : timestamp α), before t2 t ∧ past_time t2 tbc1 -> past_time t2 tbc5))))))) end) else let o3 : list (list α) := buffer tbc3 in (0%Z ≤ x ∧ x < Z.of_nat (length o3)) ∧ (match nth (Z.to_nat x) o3 inhabitant with | [] => False | cons _ q1 => (let o4 : list (list α) := buffer tbc3 in (0%Z ≤ x ∧ x < Z.of_nat (length o4)) ∧ (∀(tbc4 : Types.t α), let o5 : list (list α) := buffer tbc4 in length (buffer tbc4) = length o4 -> tbc4 = t'mk (history tbc3) (current_time tbc3) (buffer tbc4) (inv tbc3) ∧ length (buffer tbc4) = length (buffer tbc3) -> nth_i o5 = fun_updt (nth_i o4) x q1 ∧ o5 = set_list o4 (Z.to_nat x) q1 -> (let o6 : Z := delta - 1%Z in ((0%Z ≤ delta ∧ o6 < delta) ∧ correct tbc4 ∧ past_time t tbc4 ∧ 0%Z ≤ o6 ∧ current_time tbc4 = time t + o6 ∧ (history tbc4 = history tb2 ∧ (∀(x1 : Z), (0%Z ≤ x1 ∧ x1 < final_size) ∧ x1 < Z.of_nat (length (buffer tbc4)) -> func_of_array (buffer tbc4) ([] : list α) x1 = func_of_array (buffer tb2) ([] : list α) x1)) ∧ Z.of_nat (length (buffer tb2)) ≤ final_size) ∧ (∀(tbc5 : Types.t α) (tb3 : Types.t α), inv tbc5 = inv tbc4 -> current_time tb3 = current_time tb2 ∧ length (buffer tb3) = length (buffer tb2) ∧ inv tb3 = inv tb2 -> correct tbc5 ∧ (history tbc5 = history tb3 ∧ (∀(x1 : Z), 0%Z ≤ x1 ∧ x1 < final_size -> func_of_array (buffer tbc5) ([] : list α) x1 = func_of_array (buffer tb3) ([] : list α) x1)) ∧ current_timestamp tbc5 = t ∧ Z.of_nat (length (buffer tbc5)) ≤ Z.of_nat (length (buffer tbc4)) ∧ precede tbc5 tbc4 ∧ (∀(t2 : timestamp α), before t2 t ∧ past_time t2 tbc4 -> past_time t2 tbc5) -> correct tbc5 ∧ (history tbc5 = history tb3 ∧ (∀(x1 : Z), 0%Z ≤ x1 ∧ x1 < final_size -> func_of_array (buffer tbc5) ([] : list α) x1 = func_of_array (buffer tb3) ([] : list α) x1)) ∧ current_timestamp tbc5 = t ∧ Z.of_nat (length (buffer tbc5)) ≤ Z.of_nat (length (buffer tbc1)) ∧ precede tbc5 tbc1 ∧ (∀(t2 : timestamp α), before t2 t ∧ past_time t2 tbc1 -> past_time t2 tbc5))))) end))))) end else correct tbc1 ∧ (history tbc1 = history tb1 ∧ (∀(x : Z), 0%Z ≤ x ∧ x < final_size -> func_of_array (buffer tbc1) ([] : list α) x = func_of_array (buffer tb1) ([] : list α) x)) ∧ current_timestamp tbc1 = t ∧ Z.of_nat (length (buffer tbc1)) ≤ Z.of_nat (length (buffer tbc1)) ∧ precede tbc1 tbc1 ∧ (∀(t2 : timestamp α), before t2 t ∧ past_time t2 tbc1 -> past_time t2 tbc1)))) ∧ (if decide (final_size < Z.of_nat (length (buffer tb))) then 0%Z ≤ final_size ∧ (∀(buf2 : list (list α)), (∀(i : Z), 0%Z ≤ i ∧ i < final_size -> nth (Z.to_nat i) buf2 inhabitant = ([] : list α)) ∧ Z.of_nat (length buf2) = final_size -> (let buf1 : list (list α) := buffer tb in ((0%Z ≤ 0%Z ∧ 0%Z ≤ final_size ∧ 0%Z + final_size ≤ Z.of_nat (length buf1)) ∧ 0%Z ≤ 0%Z ∧ 0%Z + final_size ≤ Z.of_nat (length buf2)) ∧ (∀(buf21 : list (list α)), length buf21 = length buf2 -> (∀(i : Z), 0%Z ≤ i ∧ i < 0%Z ∨ 0%Z + final_size ≤ i ∧ i < Z.of_nat (length buf21) -> nth (Z.to_nat i) buf21 inhabitant = nth (Z.to_nat i) buf2 inhabitant) ∧ (∀(i : Z), 0%Z ≤ i ∧ i < 0%Z + final_size -> nth (Z.to_nat i) buf21 inhabitant = nth (Z.to_nat (0%Z + i - 0%Z)) buf1 inhabitant) -> (∀(tb1 : Types.t α), history tb1 = history tb ∧ current_time tb1 = current_time tb ∧ buffer tb1 = buf21 ∧ inv tb1 = inv tb -> (∀(tb2 : Types.t α), history tb2 = history tb1 ∧ current_time tb2 = time t ∧ buffer tb2 = buffer tb1 ∧ inv tb2 = inv tb1 -> (let o3 : Z := current_time tb1 - time t in (correct tbc ∧ past_time t tbc ∧ 0%Z ≤ o3 ∧ current_time tb = time t + o3 ∧ (history tb = history tb2 ∧ (∀(x : Z), (0%Z ≤ x ∧ x < final_size) ∧ x < Z.of_nat (length o2) -> func_of_array o2 ([] : list α) x = func_of_array (buffer tb2) ([] : list α) x)) ∧ Z.of_nat (length (buffer tb2)) ≤ final_size) ∧ (∀(tbc1 : Types.t α) (tb3 : Types.t α), inv tbc1 = inv tb -> current_time tb3 = current_time tb2 ∧ length (buffer tb3) = length (buffer tb2) ∧ inv tb3 = inv tb2 -> correct tbc1 ∧ (history tbc1 = history tb3 ∧ (∀(x : Z), 0%Z ≤ x ∧ x < final_size -> func_of_array (buffer tbc1) ([] : list α) x = func_of_array (buffer tb3) ([] : list α) x)) ∧ current_timestamp tbc1 = t ∧ Z.of_nat (length (buffer tbc1)) ≤ Z.of_nat (length o2) ∧ precede tbc1 tbc ∧ (∀(t2 : timestamp α), before t2 t ∧ past_time t2 tbc -> past_time t2 tbc1) -> correct tb3 ∧ current_timestamp tb3 = t ∧ past_time (current_timestamp tb3) tb3 ∧ (∀(t2 : timestamp α), before t2 t ∧ past_time t2 tb -> past_time t2 tb3) ∧ precede tb3 tb))))))) else ∀(tb1 : Types.t α), history tb1 = history tb ∧ current_time tb1 = time t ∧ buffer tb1 = buffer tb ∧ inv tb1 = inv tb -> (let o3 : Z := current_time tb - time t in (correct tbc ∧ past_time t tbc ∧ 0%Z ≤ o3 ∧ current_time tb = time t + o3 ∧ (history tb = history tb1 ∧ (∀(x : Z), (0%Z ≤ x ∧ x < final_size) ∧ x < Z.of_nat (length o2) -> func_of_array o2 ([] : list α) x = func_of_array (buffer tb1) ([] : list α) x)) ∧ Z.of_nat (length (buffer tb1)) ≤ final_size) ∧ (∀(tbc1 : Types.t α) (tb2 : Types.t α), inv tbc1 = inv tb -> current_time tb2 = current_time tb1 ∧ length (buffer tb2) = length (buffer tb1) ∧ inv tb2 = inv tb1 -> correct tbc1 ∧ (history tbc1 = history tb2 ∧ (∀(x : Z), 0%Z ≤ x ∧ x < final_size -> func_of_array (buffer tbc1) ([] : list α) x = func_of_array (buffer tb2) ([] : list α) x)) ∧ current_timestamp tbc1 = t ∧ Z.of_nat (length (buffer tbc1)) ≤ Z.of_nat (length o2) ∧ precede tbc1 tbc ∧ (∀(t2 : timestamp α), before t2 t ∧ past_time t2 tbc -> past_time t2 tbc1) -> correct tb2 ∧ current_timestamp tb2 = t ∧ past_time (current_timestamp tb2) tb2 ∧ (∀(t2 : timestamp α), before t2 t ∧ past_time t2 tb -> past_time t2 tb2) ∧ precede tb2 tb)))).
Admitted.
