theory queens_NQueensSets_t3qtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "./queens_S" "./queens_Solution"
begin
theorem t3'vc:
  fixes k :: "int"
  fixes a :: "int FSet.fset"
  fixes s :: "int"
  fixes col :: "int \<Rightarrow> int"
  fixes b :: "int FSet.fset"
  fixes c :: "int FSet.fset"
  fixes sol :: "int \<Rightarrow> int \<Rightarrow> int"
  assumes fact0: "(0 :: int) \<le> k"
  assumes fact1: "k + int (fcard a) = n"
  assumes fact2: "(0 :: int) \<le> s"
  assumes fact3: "\<forall>(i :: int). i |\<in>| a \<longleftrightarrow> ((0 :: int) \<le> i \<and> i < n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k \<longrightarrow> \<not>col j = i)"
  assumes fact4: "\<forall>(i :: int). (0 :: int) \<le> i \<longrightarrow> \<not>i |\<in>| b \<longleftrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k \<longrightarrow> \<not>col j = i + j - k)"
  assumes fact5: "\<forall>(i :: int). (0 :: int) \<le> i \<longrightarrow> \<not>i |\<in>| c \<longleftrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k \<longrightarrow> \<not>col j = i + k - j)"
  assumes fact6: "partial_solution k col"
  shows "if \<not>a = fempty then \<forall>(o1 :: int FSet.fset). o1 = a |-| b \<longrightarrow> (\<forall>(o2 :: int FSet.fset). o2 = o1 |-| c \<longrightarrow> ((((0 :: int) = s - s \<and> (0 :: int) \<le> s - s) \<and> o2 |\<subseteq>| a |-| b |-| c \<and> partial_solution k col \<and> queens_Solution.sorted sol s s \<and> (\<forall>(i :: int) (j :: int). i |\<in>| o2 |-| o2 \<longrightarrow> j |\<in>| o2 \<longrightarrow> i < j)) \<and> (\<forall>(i :: int). s \<le> i \<and> i < s \<longrightarrow> partial_solution n (sol i) \<and> eq_prefix col (sol i) k \<and> sol i k |\<in>| o2 |-| o2) \<and> (\<forall>(t :: int \<Rightarrow> int). partial_solution n t \<and> eq_prefix col t k \<and> t k |\<in>| o2 |-| o2 \<longrightarrow> t k |\<in>| o2 \<and> \<not>t k |\<in>| o2 \<and> (\<exists>(i :: int). (s \<le> i \<and> i < s) \<and> eq_prefix t (sol i) n)) \<and> eq_prefix col col k \<and> eq_prefix sol sol s) \<and> (\<forall>(e :: int FSet.fset) (s1 :: int) (sol1 :: int \<Rightarrow> int \<Rightarrow> int) (col1 :: int \<Rightarrow> int). ((0 :: int) \<le> s1 - s \<and> e |\<subseteq>| a |-| b |-| c \<and> partial_solution k col1 \<and> queens_Solution.sorted sol1 s s1 \<and> (\<forall>(i :: int) (j :: int). i |\<in>| o2 |-| e \<longrightarrow> j |\<in>| e \<longrightarrow> i < j)) \<and> (\<forall>(i :: int). s \<le> i \<and> i < s1 \<longrightarrow> partial_solution n (sol1 i) \<and> eq_prefix col1 (sol1 i) k \<and> sol1 i k |\<in>| o2 |-| e) \<and> (\<forall>(t :: int \<Rightarrow> int). partial_solution n t \<and> eq_prefix col1 t k \<and> t k |\<in>| o2 |-| e \<longrightarrow> t k |\<in>| o2 \<and> \<not>t k |\<in>| e \<and> (\<exists>(i :: int). (s \<le> i \<and> i < s1) \<and> eq_prefix t (sol1 i) n)) \<and> eq_prefix col col1 k \<and> eq_prefix sol sol1 s \<longrightarrow> (if \<not>e = fempty then \<not>e = fempty \<and> (let d :: int = Min (fset e) in \<forall>(o3 :: int FSet.fset). o3 = finsert d c \<and> (if d |\<in>| c then fcard o3 = fcard c else int (fcard o3) = int (fcard c) + (1 :: int)) \<longrightarrow> (\<forall>(o4 :: int FSet.fset). (\<forall>(i :: int). i |\<in>| o4 \<longleftrightarrow> (0 :: int) \<le> i \<and> i + (1 :: int) |\<in>| o3) \<longrightarrow> (\<forall>(o5 :: int FSet.fset). o5 = finsert d b \<and> (if d |\<in>| b then fcard o5 = fcard b else int (fcard o5) = int (fcard b) + (1 :: int)) \<longrightarrow> (\<forall>(o6 :: int FSet.fset). (\<forall>(i :: int). i |\<in>| o6 \<longleftrightarrow> (1 :: int) \<le> i \<and> i - (1 :: int) |\<in>| o5) \<longrightarrow> (\<forall>(o7 :: int FSet.fset). o7 = fset_remove d a \<and> (if d |\<in>| a then int (fcard o7) = int (fcard a) - (1 :: int) else fcard o7 = fcard a) \<longrightarrow> (((0 :: int) \<le> int (fcard a) \<and> fcard o7 < fcard a) \<and> (0 :: int) \<le> k + (1 :: int) \<and> k + (1 :: int) + int (fcard o7) = n \<and> (0 :: int) \<le> s1 \<and> (\<forall>(i :: int). i |\<in>| o7 \<longleftrightarrow> ((0 :: int) \<le> i \<and> i < n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k + (1 :: int) \<longrightarrow> \<not>(col1(k := d)) j = i)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<longrightarrow> \<not>i |\<in>| o6 \<longleftrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k + (1 :: int) \<longrightarrow> \<not>(col1(k := d)) j = i + j - (k + (1 :: int)))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<longrightarrow> \<not>i |\<in>| o4 \<longleftrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < k + (1 :: int) \<longrightarrow> \<not>(col1(k := d)) j = i + (k + (1 :: int)) - j)) \<and> partial_solution (k + (1 :: int)) (col1(k := d))) \<and> (\<forall>(s2 :: int) (sol2 :: int \<Rightarrow> int \<Rightarrow> int) (col2 :: int \<Rightarrow> int). (0 :: int) \<le> s2 - s1 \<and> queens_Solution.sorted sol2 s1 s2 \<and> (\<forall>(t :: int \<Rightarrow> int). partial_solution n t \<and> eq_prefix col2 t (k + (1 :: int)) \<longleftrightarrow> (\<exists>(i :: int). (s1 \<le> i \<and> i < s2) \<and> eq_prefix t (sol2 i) n)) \<and> eq_prefix (col1(k := d)) col2 (k + (1 :: int)) \<and> eq_prefix sol1 sol2 s1 \<longrightarrow> (\<forall>(o8 :: int FSet.fset). o8 = fset_remove d e \<and> (if d |\<in>| e then int (fcard o8) = int (fcard e) - (1 :: int) else fcard o8 = fcard e) \<longrightarrow> ((0 :: int) \<le> int (fcard e) \<and> fcard o8 < fcard e) \<and> ((s1 - s + (s2 - s1) = s2 - s \<and> (0 :: int) \<le> s2 - s) \<and> k + (1 :: int) - (1 :: int) = k \<and> o8 |\<subseteq>| a |-| b |-| c \<and> partial_solution (k + (1 :: int) - (1 :: int)) col2 \<and> queens_Solution.sorted sol2 s s2 \<and> (\<forall>(i :: int) (j :: int). i |\<in>| o2 |-| o8 \<longrightarrow> j |\<in>| o8 \<longrightarrow> i < j)) \<and> (\<forall>(i :: int). s \<le> i \<and> i < s2 \<longrightarrow> partial_solution n (sol2 i) \<and> eq_prefix col2 (sol2 i) (k + (1 :: int) - (1 :: int)) \<and> sol2 i (k + (1 :: int) - (1 :: int)) |\<in>| o2 |-| o8) \<and> (\<forall>(t :: int \<Rightarrow> int). partial_solution n t \<and> eq_prefix col2 t (k + (1 :: int) - (1 :: int)) \<and> t (k + (1 :: int) - (1 :: int)) |\<in>| o2 |-| o8 \<longrightarrow> t (k + (1 :: int) - (1 :: int)) |\<in>| o2 \<and> \<not>t (k + (1 :: int) - (1 :: int)) |\<in>| o8 \<and> (\<exists>(i :: int). (s \<le> i \<and> i < s2) \<and> eq_prefix t (sol2 i) n)) \<and> eq_prefix col col2 (k + (1 :: int) - (1 :: int)) \<and> eq_prefix sol sol2 s))))))) else (0 :: int) \<le> s1 - s \<and> queens_Solution.sorted sol1 s s1 \<and> (\<forall>(t :: int \<Rightarrow> int). partial_solution n t \<and> eq_prefix col1 t k \<longleftrightarrow> (\<exists>(i :: int). (s \<le> i \<and> i < s1) \<and> eq_prefix t (sol1 i) n)) \<and> eq_prefix col col1 k \<and> eq_prefix sol sol1 s))) else ((1 :: int) = s + (1 :: int) - s \<and> (0 :: int) \<le> s + (1 :: int) - s) \<and> queens_Solution.sorted (sol(s := col)) s (s + (1 :: int)) \<and> (\<forall>(t :: int \<Rightarrow> int). partial_solution n t \<and> eq_prefix col t k \<longleftrightarrow> (\<exists>(i :: int). (s \<le> i \<and> i < s + (1 :: int)) \<and> eq_prefix t ((sol(s := col)) i) n)) \<and> eq_prefix col col k \<and> eq_prefix sol (sol(s := col)) s"
  sorry
end
