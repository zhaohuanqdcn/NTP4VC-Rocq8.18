import Why3.Base
import pearl.vstte12_ring_buffer_vcg.lean.vstte12_ring_buffer.RingBuffer
open Classical
open Lean4Why3
namespace vstte12_ring_buffer_Harness_harnessqtvc
theorem harness'vc : (0 : ℤ) < (10 : ℤ) ∧ (∀(b : RingBuffer.buffer ℤ), RingBuffer.size b = (10 : ℤ) ∧ RingBuffer.sequence b = ([] : List ℤ) → RingBuffer.len b < RingBuffer.size b ∧ (∀(b1 : RingBuffer.buffer ℤ), List.length (RingBuffer.data b1) = List.length (RingBuffer.data b) → RingBuffer.first b = RingBuffer.first b1 → RingBuffer.len b1 = RingBuffer.len b + (1 : ℤ) ∧ RingBuffer.sequence b1 = RingBuffer.sequence b ++ List.cons (1 : ℤ) ([] : List ℤ) → RingBuffer.len b1 < RingBuffer.size b1 ∧ (∀(b2 : RingBuffer.buffer ℤ), List.length (RingBuffer.data b2) = List.length (RingBuffer.data b1) → RingBuffer.first b1 = RingBuffer.first b2 → RingBuffer.len b2 = RingBuffer.len b1 + (1 : ℤ) ∧ RingBuffer.sequence b2 = RingBuffer.sequence b1 ++ List.cons (2 : ℤ) ([] : List ℤ) → RingBuffer.len b2 < RingBuffer.size b2 ∧ (∀(b3 : RingBuffer.buffer ℤ), List.length (RingBuffer.data b3) = List.length (RingBuffer.data b2) → RingBuffer.first b2 = RingBuffer.first b3 → RingBuffer.len b3 = RingBuffer.len b2 + (1 : ℤ) ∧ RingBuffer.sequence b3 = RingBuffer.sequence b2 ++ List.cons (3 : ℤ) ([] : List ℤ) → (0 : ℤ) < RingBuffer.len b3 ∧ (∀(b4 : RingBuffer.buffer ℤ), RingBuffer.data b3 = RingBuffer.data b4 → (∀(x : ℤ), RingBuffer.len b4 = RingBuffer.len b3 - (1 : ℤ) ∧ (match RingBuffer.sequence b3 with | ([] : List ℤ) => False | List.cons x1 l => x = x1 ∧ RingBuffer.sequence b4 = l) → (0 : ℤ) < RingBuffer.len b4 ∧ (∀(b5 : RingBuffer.buffer ℤ), RingBuffer.data b4 = RingBuffer.data b5 → (∀(x1 : ℤ), RingBuffer.len b5 = RingBuffer.len b4 - (1 : ℤ) ∧ (match RingBuffer.sequence b4 with | ([] : List ℤ) => False | List.cons x2 l => x1 = x2 ∧ RingBuffer.sequence b5 = l) → (0 : ℤ) < RingBuffer.len b5))))))))
  := sorry
end vstte12_ring_buffer_Harness_harnessqtvc
