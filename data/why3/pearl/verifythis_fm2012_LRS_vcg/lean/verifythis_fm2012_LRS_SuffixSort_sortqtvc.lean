import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
import Why3.map.MapInjection
import pearl.verifythis_fm2012_LRS_vcg.lean.verifythis_fm2012_LRS.LCP
open Classical
open Lean4Why3
namespace verifythis_fm2012_LRS_SuffixSort_sortqtvc
noncomputable def lt (a : List ℤ) (x : ℤ) (y : ℤ) := let n : ℤ := Int.ofNat (List.length a); ((0 : ℤ) ≤ x ∧ x ≤ n) ∧ ((0 : ℤ) ≤ y ∧ y ≤ n) ∧ (∃(l : ℤ), LCP.is_common_prefix a x y l ∧ y + l < n ∧ (x + l = n ∨ a[Int.toNat (x + l)]! < a[Int.toNat (y + l)]!))
noncomputable def range (a : List ℤ) := MapInjection.range (getElem! a ∘ Int.toNat) (Int.ofNat (List.length a))
noncomputable def le (a : List ℤ) (x : ℤ) (y : ℤ) := x = y ∨ lt a x y
noncomputable def sorted_sub (a : List ℤ) (data : ℤ -> ℤ) (l : ℤ) (u : ℤ) := ∀(i1 : ℤ) (i2 : ℤ), l ≤ i1 ∧ i1 ≤ i2 ∧ i2 < u → le a (data i1) (data i2)
noncomputable def sorted (a : List ℤ) (data : List ℤ) := sorted_sub a (getElem! data ∘ Int.toNat) (0 : ℤ) (Int.ofNat (List.length data))
theorem sort'vc (data : List ℤ) (a : List ℤ) (fact0 : List.length data = List.length a) (fact1 : range data) : let o1 : ℤ := Int.ofNat (List.length data) - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → (List.Perm data data ∧ sorted_sub a (getElem! data ∘ Int.toNat) (0 : ℤ) (0 : ℤ) ∧ range data) ∧ (∀(data1 : List ℤ), List.length data1 = List.length data → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ List.Perm data data1 ∧ sorted_sub a (getElem! data1 ∘ Int.toNat) (0 : ℤ) i ∧ range data1 → (((0 : ℤ) ≤ i ∧ i ≤ i) ∧ range data1 ∧ List.Perm data data1 ∧ sorted_sub a (getElem! data1 ∘ Int.toNat) (0 : ℤ) i ∧ sorted_sub a (getElem! data1 ∘ Int.toNat) i (i + (1 : ℤ)) ∧ (∀(k1 : ℤ) (k2 : ℤ), ((0 : ℤ) ≤ k1 ∧ k1 < i) ∧ i + (1 : ℤ) ≤ k2 ∧ k2 ≤ i → le a (data1[Int.toNat k1]!) (data1[Int.toNat k2]!))) ∧ (∀(j : ℤ) (data2 : List ℤ), List.length data2 = List.length data1 → ((0 : ℤ) ≤ j ∧ j ≤ i) ∧ range data2 ∧ List.Perm data data2 ∧ sorted_sub a (getElem! data2 ∘ Int.toNat) (0 : ℤ) j ∧ sorted_sub a (getElem! data2 ∘ Int.toNat) j (i + (1 : ℤ)) ∧ (∀(k1 : ℤ) (k2 : ℤ), ((0 : ℤ) ≤ k1 ∧ k1 < j) ∧ j + (1 : ℤ) ≤ k2 ∧ k2 ≤ i → le a (data2[Int.toNat k1]!) (data2[Int.toNat k2]!)) → ((0 : ℤ) < j → ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length data2)) ∧ (let o2 : ℤ := data2[Int.toNat j]!; let o3 : ℤ := j - (1 : ℤ); ((0 : ℤ) ≤ o3 ∧ o3 < Int.ofNat (List.length data2)) ∧ (let o4 : ℤ := data2[Int.toNat o3]!; ((0 : ℤ) ≤ o4 ∧ o4 ≤ Int.ofNat (List.length a)) ∧ (0 : ℤ) ≤ o2 ∧ o2 ≤ Int.ofNat (List.length a)))) ∧ (∀(o2 : Bool), (if (0 : ℤ) < j then let o3 : ℤ := data2[Int.toNat j]!; let o4 : ℤ := data2[Int.toNat (j - (1 : ℤ))]!; ∃(o5 : ℤ), ((o5 = (0 : ℤ) → o4 = o3) ∧ (o5 < (0 : ℤ) → lt a o4 o3) ∧ ((0 : ℤ) < o5 → lt a o3 o4)) ∧ o2 = (if (0 : ℤ) < o5 then true else false) else o2 = false) → (if o2 = true then let b : ℤ := j - (1 : ℤ); ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length data2)) ∧ (let t : ℤ := data2[Int.toNat j]!; ((0 : ℤ) ≤ b ∧ b < Int.ofNat (List.length data2)) ∧ (let o3 : ℤ := data2[Int.toNat b]!; ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length data2)) ∧ (List.length (List.set data2 (Int.toNat j) o3) = List.length data2 → getElem! (List.set data2 (Int.toNat j) o3) ∘ Int.toNat = Function.update (getElem! data2 ∘ Int.toNat) j o3 → ((0 : ℤ) ≤ b ∧ b < Int.ofNat (List.length (List.set data2 (Int.toNat j) o3))) ∧ (List.length (List.set (List.set data2 (Int.toNat j) o3) (Int.toNat b) t) = List.length (List.set data2 (Int.toNat j) o3) → getElem! (List.set (List.set data2 (Int.toNat j) o3) (Int.toNat b) t) ∘ Int.toNat = Function.update (getElem! (List.set data2 (Int.toNat j) o3) ∘ Int.toNat) b t → ((0 : ℤ) ≤ j ∧ j - (1 : ℤ) < j) ∧ ((0 : ℤ) ≤ j - (1 : ℤ) ∧ j - (1 : ℤ) ≤ i) ∧ range (List.set (List.set data2 (Int.toNat j) o3) (Int.toNat b) t) ∧ List.Perm data (List.set (List.set data2 (Int.toNat j) o3) (Int.toNat b) t) ∧ sorted_sub a (getElem! (List.set (List.set data2 (Int.toNat j) o3) (Int.toNat b) t) ∘ Int.toNat) (0 : ℤ) (j - (1 : ℤ)) ∧ sorted_sub a (getElem! (List.set (List.set data2 (Int.toNat j) o3) (Int.toNat b) t) ∘ Int.toNat) (j - (1 : ℤ)) (i + (1 : ℤ)) ∧ (∀(k1 : ℤ) (k2 : ℤ), ((0 : ℤ) ≤ k1 ∧ k1 < j - (1 : ℤ)) ∧ j - (1 : ℤ) + (1 : ℤ) ≤ k2 ∧ k2 ≤ i → le a ((List.set (List.set data2 (Int.toNat j) o3) (Int.toNat b) t)[Int.toNat k1]!) ((List.set (List.set data2 (Int.toNat j) o3) (Int.toNat b) t)[Int.toNat k2]!)))))) else List.Perm data data2 ∧ sorted_sub a (getElem! data2 ∘ Int.toNat) (0 : ℤ) (i + (1 : ℤ)) ∧ range data2)))) ∧ (List.Perm data data1 ∧ sorted_sub a (getElem! data1 ∘ Int.toNat) (0 : ℤ) (o1 + (1 : ℤ)) ∧ range data1 → sorted a data1 ∧ List.Perm data data1))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → sorted a data ∧ List.Perm data data)
  := sorry
end verifythis_fm2012_LRS_SuffixSort_sortqtvc
