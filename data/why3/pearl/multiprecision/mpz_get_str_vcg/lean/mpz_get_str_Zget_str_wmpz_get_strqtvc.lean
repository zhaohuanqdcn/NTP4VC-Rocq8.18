import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import Why3.mach.c.String
import Why3.mach.c.UChar
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.mpz.Z
import pearl.multiprecision.lib.lean.mpz.Zutil
import pearl.multiprecision.lib.lean.base_info.BaseInfo
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.stringlemmas.String_lemmas
import pearl.multiprecision.lib.lean.stringlemmas.Conversions
import pearl.multiprecision.lib.lean.stringlemmas.String_value
import pearl.multiprecision.lib.lean.get_str.Get_str
import pearl.multiprecision.lib.lean.powm.Powm
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.valuation.Valuation
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.sub_1.Sub_1
open Classical
open Lean4Why3
namespace mpz_get_str_Zget_str_wmpz_get_strqtvc
noncomputable def effective (b : ℤ) := if abs b < (2 : ℤ) then (10 : ℤ) else abs b
theorem wmpz_get_str'vc (sp : C.ptr (BitVec 8)) (sz : BitVec 32) (mpz : Z.mpz_memo) (u : Z.mpz_ptr) (base : BitVec 32) (fact0 : C.valid sp (BitVec.toInt sz)) (fact1 : C.writable sp = true) (fact2 : (2 : ℤ) ≤ BitVec.toInt sz) (fact3 : Z.abs_value_of mpz u < HPow.hPow (effective (BitVec.toInt base)) (Int.toNat (BitVec.toInt sz - (2 : ℤ)))) (fact4 : Z.readers mpz u = (0 : ℤ)) (fact5 : (64 : ℤ) * Z.abs_size mpz u + (7 : ℤ) ≤ (2147483647 : ℤ)) (fact6 : -(36 : ℤ) ≤ BitVec.toInt base) (fact7 : BitVec.toInt base ≤ (62 : ℤ)) : (∀(result : List (BitVec 8)), (if (36 : ℤ) < BitVec.toInt base then result = ([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122] : List (BitVec 8)) else if (0 : ℤ) ≤ BitVec.toInt base then result = ([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122] : List (BitVec 8)) else result = ([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90] : List (BitVec 8))) → (BitVec.toInt base < (0 : ℤ) → result = ([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90] : List (BitVec 8))) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → result = ([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122] : List (BitVec 8))) ∧ ((36 : ℤ) < BitVec.toInt base → result = ([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122] : List (BitVec 8))) ∧ effective (BitVec.toInt base) ≤ Int.ofNat (List.length result)) ∧ (∀(digits : List (BitVec 8)), (BitVec.toInt base < (0 : ℤ) → digits = ([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90] : List (BitVec 8))) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → digits = ([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122] : List (BitVec 8))) ∧ ((36 : ℤ) < BitVec.toInt base → digits = ([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122] : List (BitVec 8))) ∧ effective (BitVec.toInt base) ≤ Int.ofNat (List.length digits) → (if BitVec.toInt base ≤ (0 : ℤ) then int'32_in_bounds (-BitVec.toInt base) ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = -BitVec.toInt base → (if BitVec.toInt o1 ≤ (1 : ℤ) then BitVec.toInt (10 : BitVec 32) = effective (BitVec.toInt base) else BitVec.toInt o1 = effective (BitVec.toInt base))) else if BitVec.toInt base ≤ (1 : ℤ) then BitVec.toInt (10 : BitVec 32) = effective (BitVec.toInt base) else BitVec.toInt base = effective (BitVec.toInt base)) ∧ (∀(base1 : BitVec 32), BitVec.toInt base1 = effective (BitVec.toInt base) → -(2 : ℤ) < Z.readers mpz u ∧ (∀(un : BitVec 32), BitVec.toInt un = Z.abs_size mpz u → (∀(o1 : Bool), (BitVec.toInt un = BitVec.toInt (0 : BitVec 32) → o1 = true) ∧ (o1 = true → un = (0 : BitVec 32)) → (if o1 = true then let o2 : BitVec 8 := ([48] : List (BitVec 8))[(0 : ℕ)]!; ((C.min sp ≤ C.offset sp + (0 : ℤ) ∧ C.offset sp + (0 : ℤ) < C.max sp) ∧ C.writable sp = true) ∧ (∀(sp1 : C.ptr (BitVec 8)), List.length (C.data sp1) = List.length (C.data sp) ∧ C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.max sp1 = C.max sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → C.pelts sp1 = Function.update (C.pelts sp) (C.offset sp1 + (0 : ℤ)) o2 ∧ C.pelts sp1 (C.offset sp1 + (0 : ℤ)) = o2 → (let o3 : BitVec 8 := String.zero_char; ((C.min sp1 ≤ C.offset sp1 + (1 : ℤ) ∧ C.offset sp1 + (1 : ℤ) < C.max sp1) ∧ C.writable sp1 = true) ∧ (∀(sp2 : C.ptr (BitVec 8)), List.length (C.data sp2) = List.length (C.data sp1) ∧ C.offset sp2 = C.offset sp1 ∧ C.min sp2 = C.min sp1 ∧ C.max sp2 = C.max sp1 ∧ C.writable sp2 = C.writable sp1 ∧ C.zone1 sp2 = C.zone1 sp1 → C.pelts sp2 = Function.update (C.pelts sp1) (C.offset sp2 + (1 : ℤ)) o3 ∧ C.pelts sp2 (C.offset sp2 + (1 : ℤ)) = o3 → String.valid_string sp2 ∧ String_value.string_in_base (effective (BitVec.toInt base)) (C.pelts sp2) (C.offset sp2) ∧ (∀(x : Z.mpz_ptr), Z.mpz_unchanged x mpz mpz) ∧ String_value.value_text (effective (BitVec.toInt base)) (C.pelts sp2) (C.offset sp2) = Z.value_of u mpz))) else -(2 : ℤ) < Z.readers mpz u ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = Z.sgn mpz u * Z.abs_size mpz u → (if BitVec.toInt o2 < (0 : ℤ) then let o3 : BitVec 8 := ([45] : List (BitVec 8))[(0 : ℕ)]!; ((C.min sp ≤ C.offset sp + (0 : ℤ) ∧ C.offset sp + (0 : ℤ) < C.max sp) ∧ C.writable sp = true) ∧ (∀(sp1 : C.ptr (BitVec 8)), List.length (C.data sp1) = List.length (C.data sp) ∧ C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.max sp1 = C.max sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → C.pelts sp1 = Function.update (C.pelts sp) (C.offset sp1 + (0 : ℤ)) o3 ∧ C.pelts sp1 (C.offset sp1 + (0 : ℤ)) = o3 → int'32_in_bounds ((0 : ℤ) + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = (0 : ℤ) + (1 : ℤ) → (0 : ℤ) ≤ BitVec.toInt base1 ∧ (∀(o5 : BitVec 64), BitVec.toUInt o5 = BitVec.toInt base1 → ((2 : ℤ) ≤ BitVec.toUInt o5 ∧ BitVec.toUInt o5 ≤ (256 : ℤ)) ∧ (∀(bits : BitVec 32), ((0 : ℤ) ≤ BitVec.toUInt bits ∧ BitVec.toUInt bits ≤ (8 : ℤ)) ∧ (¬BitVec.toUInt bits = (0 : ℤ) → HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits)) = BitVec.toUInt o5) ∧ (BitVec.toUInt bits = (0 : ℤ) → (∀(n : ℤ), (0 : ℤ) ≤ n → ¬HPow.hPow (2 : ℤ) (Int.toNat n) = BitVec.toUInt o5)) → (0 : ℤ) ≤ Z.readers mpz u ∧ (∀(mpz1 : Z.mpz_memo), Z.abs_value_of mpz1 = Z.abs_value_of mpz ∧ Z.alloc mpz1 = Z.alloc mpz ∧ Z.abs_size mpz1 = Z.abs_size mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(up : C.ptr (BitVec 64)), Z.readers mpz1 u = Z.readers mpz u + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬u = y → Z.readers mpz1 y = Z.readers mpz y) ∧ Lemmas.value up (Z.abs_size mpz1 u) = Z.abs_value_of mpz1 u ∧ C.plength up = Z.alloc mpz1 u ∧ C.offset up = (0 : ℤ) ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up ∧ C.zone1 up = Z.zones mpz1 u → C.writable sp1 = true ∧ (∀(sp2 : C.ptr (BitVec 8)), C.offset sp2 = C.offset sp1 ∧ C.writable sp2 = C.writable sp1 ∧ C.zone1 sp2 = C.zone1 sp1 → (∀(usp : C.ptr (BitVec 8)) (mem : UChar.cast_mem), (C.min usp = C.min sp1 ∧ C.min sp1 = UChar.mi mem) ∧ (C.max usp = C.max sp1 ∧ C.max sp1 = UChar.ma mem) ∧ C.zone1 sp1 = UChar.z mem ∧ (C.plength usp = C.plength sp1 ∧ C.plength sp1 = UChar.l mem) ∧ UChar.ok mem = true ∧ C.offset usp = C.offset sp1 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < C.plength sp1 → C.pelts usp i = C.pelts sp1 i) ∧ C.writable usp = true → (C.min usp ≤ C.offset usp + BitVec.toInt o4 ∧ C.offset usp + BitVec.toInt o4 ≤ C.max usp) ∧ (∀(uspi : C.ptr (BitVec 8)), C.offset uspi = C.offset usp + BitVec.toInt o4 ∧ C.plength uspi = C.plength usp ∧ C.pelts uspi = C.pelts usp ∧ C.data uspi = C.data usp ∧ C.min uspi = C.min usp ∧ C.max uspi = C.max usp ∧ C.zone1 uspi = C.zone1 usp ∧ C.writable uspi = C.writable usp → (BitVec.toUInt bits = (0 : ℤ) → bits = (0 : BitVec 32)) → (if ¬bits = (0 : BitVec 32) then int'32_in_bounds (BitVec.toInt un - (1 : ℤ)) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt un - (1 : ℤ) → (C.min up ≤ C.offset up + BitVec.toInt o6 ∧ C.offset up + BitVec.toInt o6 < C.max up) ∧ (let um : BitVec 64 := C.pelts up (C.offset up + BitVec.toInt o6); (0 : ℤ) < BitVec.toUInt um ∧ (∀(sb : BitVec 64), ((1 : ℤ) ≤ BitVec.toUInt sb ∧ BitVec.toUInt sb ≤ (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt sb - (1 : ℤ))) ≤ BitVec.toUInt um ∧ BitVec.toUInt um < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt sb)) → BitVec.toUInt sb ≤ (2147483647 : ℤ) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toUInt sb → int'32_in_bounds (BitVec.toInt un - (1 : ℤ)) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt un - (1 : ℤ) → int'32_in_bounds ((64 : ℤ) * BitVec.toInt o8) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = (64 : ℤ) * BitVec.toInt o8 → int'32_in_bounds (BitVec.toInt o9 + BitVec.toInt o7) ∧ (∀(ub : BitVec 32), BitVec.toInt ub = BitVec.toInt o9 + BitVec.toInt o7 → ((1 : ℤ) ≤ BitVec.toInt un ∧ C.valid up (BitVec.toInt un) ∧ ((1 : ℤ) ≤ BitVec.toUInt bits ∧ BitVec.toUInt bits ≤ (8 : ℤ)) ∧ C.valid uspi ((BitVec.toInt ub + BitVec.toUInt bits - (1 : ℤ)) / BitVec.toUInt bits) ∧ (0 : ℤ) ≤ BitVec.toInt ub ∧ Lemmas.value up (BitVec.toInt un) < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt ub)) ∧ (0 : ℤ) < BitVec.toUInt (C.pelts up (C.offset up + BitVec.toInt un - (1 : ℤ))) ∧ (64 : ℤ) * BitVec.toInt un + (7 : ℤ) ≤ (2147483647 : ℤ) ∧ C.writable uspi = true) ∧ (∀(uspi1 : C.ptr (BitVec 8)) (usp1 : C.ptr (BitVec 8)), C.data uspi1 = C.data usp1 ∧ List.length (C.data usp1) = List.length (C.data uspi) ∧ C.offset uspi1 = C.offset uspi ∧ C.min uspi1 = C.min uspi ∧ C.max uspi1 = C.max uspi ∧ C.writable uspi1 = C.writable uspi ∧ C.zone1 uspi1 = C.zone1 uspi → List.length (C.data usp1) = List.length (C.data usp) ∧ C.offset usp1 = C.offset usp ∧ C.min usp1 = C.min usp ∧ C.max usp1 = C.max usp ∧ C.writable usp1 = C.writable usp ∧ C.zone1 usp1 = C.zone1 usp → (∀(g : BitVec 32), String_lemmas.in_base (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) (C.pelts uspi1) (C.offset uspi1) (C.offset uspi1 + BitVec.toUInt g) ∧ String_lemmas.svalue (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) uspi1 (BitVec.toUInt g) = Lemmas.value up (BitVec.toInt un) ∧ ((0 : ℤ) < BitVec.toUInt g ∧ BitVec.toUInt g ≤ (BitVec.toInt ub + BitVec.toUInt bits - (1 : ℤ)) / BitVec.toUInt bits) ∧ (0 : ℤ) < BitVec.toInt (C.pelts uspi1 (C.offset uspi1)) ∧ (∀(j : ℤ), j < C.offset uspi1 ∨ C.offset uspi1 + (BitVec.toInt ub + BitVec.toUInt bits - (1 : ℤ)) / BitVec.toUInt bits ≤ j → C.pelts uspi1 j = C.pelts uspi j) → BitVec.toUInt g ≤ (2147483647 : ℤ) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toUInt g → int'32_in_bounds (BitVec.toInt o4 + BitVec.toInt o10) ∧ (∀(o11 : BitVec 32), BitVec.toInt o11 = BitVec.toInt o4 + BitVec.toInt o10 → (UChar.ok mem = true ∧ UChar.z mem = C.zone1 sp2 ∧ UChar.mi mem = C.min usp1 ∧ UChar.ma mem = C.max usp1 ∧ C.offset sp2 = C.offset usp1 ∧ C.plength usp1 = UChar.l mem) ∧ (∀(mem1 : UChar.cast_mem) (sp3 : C.ptr (BitVec 8)), UChar.mi mem1 = UChar.mi mem ∧ UChar.ma mem1 = UChar.ma mem ∧ UChar.z mem1 = UChar.z mem ∧ UChar.l mem1 = UChar.l mem → C.offset sp3 = C.offset sp2 ∧ C.writable sp3 = C.writable sp2 ∧ C.zone1 sp3 = C.zone1 sp2 → (C.min sp3 = UChar.mi mem1 ∧ C.max sp3 = UChar.ma mem1) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < C.plength sp3 → C.pelts sp3 i = C.pelts usp1 i) ∧ C.plength sp3 = C.plength usp1 → int'32_in_bounds (BitVec.toInt o11 - (1 : ℤ)) ∧ (∀(o12 : BitVec 32), BitVec.toInt o12 = BitVec.toInt o11 - (1 : ℤ) → (BitVec.toInt o4 ≤ BitVec.toInt o12 + (1 : ℤ) → ((BitVec.toInt o4 ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ BitVec.toInt o11) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + BitVec.toInt o4)) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + BitVec.toInt o4)) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + BitVec.toInt o4)) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp3) (C.offset sp3 + BitVec.toInt o4) (C.offset sp3 + BitVec.toInt o4) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + BitVec.toInt o4) (C.offset usp1 + BitVec.toInt o4) ∧ (∀(k : ℤ), C.offset sp3 ≤ k ∧ k < C.offset sp3 + BitVec.toInt o4 → ¬BitVec.toInt (C.pelts sp3 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp3) (C.offset sp3 + BitVec.toInt o4) (C.offset sp3 + BitVec.toInt o4) ∧ (BitVec.toInt o4 = (1 : ℤ) → C.pelts sp3 (C.offset sp3) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ (BitVec.toInt o4 = (0 : ℤ) → BitVec.toInt o4 < BitVec.toInt o4 → ¬C.pelts sp3 (C.offset sp3) = ([45] : List (BitVec 8))[(0 : ℕ)]!)) ∧ (∀(sp4 : C.ptr (BitVec 8)), List.length (C.data sp4) = List.length (C.data sp3) ∧ C.offset sp4 = C.offset sp3 ∧ C.min sp4 = C.min sp3 ∧ C.max sp4 = C.max sp3 ∧ C.writable sp4 = C.writable sp3 ∧ C.zone1 sp4 = C.zone1 sp3 → (∀(j : BitVec 32), let j1 : ℤ := BitVec.toInt j; (BitVec.toInt o4 ≤ j1 ∧ j1 ≤ BitVec.toInt o12) ∧ (BitVec.toInt o4 ≤ j1 ∧ j1 ≤ BitVec.toInt o11) ∧ (∀(k : ℤ), C.offset sp4 + j1 ≤ C.offset sp4 + k ∧ C.offset sp4 + k < C.offset sp4 + BitVec.toInt o11 → C.pelts sp4 (C.offset sp4 + k) = C.pelts sp3 (C.offset sp4 + k)) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + j1)) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + j1)) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + j1)) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp4) (C.offset sp4 + BitVec.toInt o4) (C.offset sp4 + j1) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + BitVec.toInt o4) (C.offset usp1 + j1) ∧ (∀(k : ℤ), C.offset sp4 ≤ k ∧ k < C.offset sp4 + j1 → ¬BitVec.toInt (C.pelts sp4 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp4) (C.offset sp4 + BitVec.toInt o4) (C.offset sp4 + j1) ∧ (BitVec.toInt o4 = (1 : ℤ) → C.pelts sp4 (C.offset sp4) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ (BitVec.toInt o4 = (0 : ℤ) → BitVec.toInt o4 < j1 → ¬C.pelts sp4 (C.offset sp4) = ([45] : List (BitVec 8))[(0 : ℕ)]!) → (C.min sp4 ≤ C.offset sp4 + BitVec.toInt j ∧ C.offset sp4 + BitVec.toInt j < C.max sp4) ∧ (let o13 : BitVec 8 := C.pelts sp4 (C.offset sp4 + BitVec.toInt j); let cj : BitVec 8 := o13; ((0 : ℤ) ≤ BitVec.toInt o13 ∧ BitVec.toInt o13 ≤ (127 : ℤ) → BitVec.toInt cj = BitVec.toInt o13) → (∀(o14 : BitVec 32), BitVec.toInt o14 = BitVec.toInt cj → ((0 : ℤ) ≤ BitVec.toInt o14 ∧ BitVec.toInt o14 ≤ Int.ofNat (List.length digits)) ∧ (∀(dc : BitVec 8), ((0 : ℤ) ≤ BitVec.toInt o14 ∧ BitVec.toInt o14 < Int.ofNat (List.length digits) → dc = digits[Int.toNat (BitVec.toInt o14)]!) ∧ (BitVec.toInt o14 = Int.ofNat (List.length digits) → dc = BitVec.ofNat 8 (0 : ℕ)) → ((C.min sp4 ≤ C.offset sp4 + BitVec.toInt j ∧ C.offset sp4 + BitVec.toInt j < C.max sp4) ∧ C.writable sp4 = true) ∧ (∀(sp5 : C.ptr (BitVec 8)), List.length (C.data sp5) = List.length (C.data sp4) ∧ C.offset sp5 = C.offset sp4 ∧ C.min sp5 = C.min sp4 ∧ C.max sp5 = C.max sp4 ∧ C.writable sp5 = C.writable sp4 ∧ C.zone1 sp5 = C.zone1 sp4 → C.pelts sp5 = Function.update (C.pelts sp4) (C.offset sp5 + BitVec.toInt j) dc ∧ C.pelts sp5 (C.offset sp5 + BitVec.toInt j) = dc → (BitVec.toInt o4 ≤ j1 + (1 : ℤ) ∧ j1 + (1 : ℤ) ≤ BitVec.toInt o11) ∧ (∀(k : ℤ), C.offset sp5 + (j1 + (1 : ℤ)) ≤ C.offset sp5 + k ∧ C.offset sp5 + k < C.offset sp5 + BitVec.toInt o11 → C.pelts sp5 (C.offset sp5 + k) = C.pelts sp3 (C.offset sp5 + k)) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp5) (C.offset sp5) (C.offset sp5 + (j1 + (1 : ℤ)))) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp5) (C.offset sp5) (C.offset sp5 + (j1 + (1 : ℤ)))) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp5) (C.offset sp5) (C.offset sp5 + (j1 + (1 : ℤ)))) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp5) (C.offset sp5 + BitVec.toInt o4) (C.offset sp5 + (j1 + (1 : ℤ))) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + BitVec.toInt o4) (C.offset usp1 + (j1 + (1 : ℤ))) ∧ (∀(k : ℤ), C.offset sp5 ≤ k ∧ k < C.offset sp5 + (j1 + (1 : ℤ)) → ¬BitVec.toInt (C.pelts sp5 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp5) (C.offset sp5 + BitVec.toInt o4) (C.offset sp5 + (j1 + (1 : ℤ))) ∧ (BitVec.toInt o4 = (1 : ℤ) → C.pelts sp5 (C.offset sp5) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ (BitVec.toInt o4 = (0 : ℤ) → BitVec.toInt o4 < j1 + (1 : ℤ) → ¬C.pelts sp5 (C.offset sp5) = ([45] : List (BitVec 8))[(0 : ℕ)]!)))))) ∧ ((BitVec.toInt o4 ≤ BitVec.toInt o12 + (1 : ℤ) ∧ BitVec.toInt o12 + (1 : ℤ) ≤ BitVec.toInt o11) ∧ (∀(k : ℤ), C.offset sp4 + (BitVec.toInt o12 + (1 : ℤ)) ≤ C.offset sp4 + k ∧ C.offset sp4 + k < C.offset sp4 + BitVec.toInt o11 → C.pelts sp4 (C.offset sp4 + k) = C.pelts sp3 (C.offset sp4 + k)) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + (BitVec.toInt o12 + (1 : ℤ)))) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + (BitVec.toInt o12 + (1 : ℤ)))) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + (BitVec.toInt o12 + (1 : ℤ)))) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp4) (C.offset sp4 + BitVec.toInt o4) (C.offset sp4 + (BitVec.toInt o12 + (1 : ℤ))) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + BitVec.toInt o4) (C.offset usp1 + (BitVec.toInt o12 + (1 : ℤ))) ∧ (∀(k : ℤ), C.offset sp4 ≤ k ∧ k < C.offset sp4 + (BitVec.toInt o12 + (1 : ℤ)) → ¬BitVec.toInt (C.pelts sp4 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp4) (C.offset sp4 + BitVec.toInt o4) (C.offset sp4 + (BitVec.toInt o12 + (1 : ℤ))) ∧ (BitVec.toInt o4 = (1 : ℤ) → C.pelts sp4 (C.offset sp4) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ (BitVec.toInt o4 = (0 : ℤ) → BitVec.toInt o4 < BitVec.toInt o12 + (1 : ℤ) → ¬C.pelts sp4 (C.offset sp4) = ([45] : List (BitVec 8))[(0 : ℕ)]!) → (let o13 : BitVec 8 := String.zero_char; ((C.min sp4 ≤ C.offset sp4 + BitVec.toInt o11 ∧ C.offset sp4 + BitVec.toInt o11 < C.max sp4) ∧ C.writable sp4 = true) ∧ (∀(sp5 : C.ptr (BitVec 8)), List.length (C.data sp5) = List.length (C.data sp4) ∧ C.offset sp5 = C.offset sp4 ∧ C.min sp5 = C.min sp4 ∧ C.max sp5 = C.max sp4 ∧ C.writable sp5 = C.writable sp4 ∧ C.zone1 sp5 = C.zone1 sp4 → C.pelts sp5 = Function.update (C.pelts sp4) (C.offset sp5 + BitVec.toInt o11) o13 ∧ C.pelts sp5 (C.offset sp5 + BitVec.toInt o11) = o13 → (Z.zones mpz1 u = C.zone1 up ∧ (1 : ℤ) ≤ Z.readers mpz1 u ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up) ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → Z.readers mpz2 u = Z.readers mpz1 u - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u → Z.readers mpz2 y = Z.readers mpz1 y) → String.valid_string sp5 ∧ String_value.string_in_base (effective (BitVec.toInt base)) (C.pelts sp5) (C.offset sp5) ∧ (∀(x : Z.mpz_ptr), Z.mpz_unchanged x mpz2 mpz) ∧ String_value.value_text (effective (BitVec.toInt base)) (C.pelts sp5) (C.offset sp5) = Z.value_of u mpz2)))))) ∧ (BitVec.toInt o12 + (1 : ℤ) < BitVec.toInt o4 → (let o13 : BitVec 8 := String.zero_char; ((C.min sp3 ≤ C.offset sp3 + BitVec.toInt o11 ∧ C.offset sp3 + BitVec.toInt o11 < C.max sp3) ∧ C.writable sp3 = true) ∧ (∀(sp4 : C.ptr (BitVec 8)), List.length (C.data sp4) = List.length (C.data sp3) ∧ C.offset sp4 = C.offset sp3 ∧ C.min sp4 = C.min sp3 ∧ C.max sp4 = C.max sp3 ∧ C.writable sp4 = C.writable sp3 ∧ C.zone1 sp4 = C.zone1 sp3 → C.pelts sp4 = Function.update (C.pelts sp3) (C.offset sp4 + BitVec.toInt o11) o13 ∧ C.pelts sp4 (C.offset sp4 + BitVec.toInt o11) = o13 → (Z.zones mpz1 u = C.zone1 up ∧ (1 : ℤ) ≤ Z.readers mpz1 u ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up) ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → Z.readers mpz2 u = Z.readers mpz1 u - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u → Z.readers mpz2 y = Z.readers mpz1 y) → String.valid_string sp4 ∧ String_value.string_in_base (effective (BitVec.toInt base)) (C.pelts sp4) (C.offset sp4) ∧ (∀(x : Z.mpz_ptr), Z.mpz_unchanged x mpz2 mpz) ∧ String_value.value_text (effective (BitVec.toInt base)) (C.pelts sp4) (C.offset sp4) = Z.value_of u mpz2))))))))))))))))) else (0 : ℤ) ≤ BitVec.toInt base1 ∧ (∀(o6 : BitVec 64), BitVec.toUInt o6 = BitVec.toInt base1 → ((2 : ℤ) ≤ BitVec.toUInt o6 ∧ BitVec.toUInt o6 ≤ (256 : ℤ)) ∧ (∀(info : BaseInfo.wmpn_base_info), BaseInfo.b info = BitVec.toUInt o6 → (0 : ℤ) ≤ BitVec.toInt un ∧ (∀(o7 : BitVec 32), BitVec.toUInt o7 = BitVec.toInt un → (0 : ℤ) ≤ BitVec.toUInt o7 ∧ (∀(tp : C.ptr (BitVec 64)), C.plength tp = BitVec.toUInt o7 ∧ C.offset tp = (0 : ℤ) ∧ C.min tp = (0 : ℤ) ∧ C.max tp = BitVec.toUInt o7 ∧ C.writable tp = true → (C.valid up (BitVec.toInt un) ∧ C.valid tp (BitVec.toInt un) ∧ C.writable tp = true) ∧ (∀(tp1 : C.ptr (BitVec 64)) (up1 : C.ptr (BitVec 64)), C.offset tp1 = C.offset tp ∧ C.writable tp1 = C.writable tp ∧ C.zone1 tp1 = C.zone1 tp → C.offset up1 = C.offset up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → Lemmas.map_eq_sub_shift (C.pelts tp1) (C.pelts up) (C.offset tp1) (C.offset up) (BitVec.toInt un) ∧ (∀(j : ℤ), j < C.offset tp1 ∨ C.offset tp1 + BitVec.toInt un ≤ j → C.pelts tp1 j = C.pelts tp j) ∧ (∀(j : ℤ), C.pelts up1 j = C.pelts up j) ∧ (C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.plength up1 = C.plength up) ∧ C.min tp1 = C.min tp ∧ C.max tp1 = C.max tp ∧ C.plength tp1 = C.plength tp → int'32_in_bounds (BitVec.toInt sz - BitVec.toInt o4) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt sz - BitVec.toInt o4 → (C.valid tp1 (BitVec.toInt un) ∧ (1 : ℤ) ≤ BitVec.toInt un ∧ BaseInfo.b info = BitVec.toInt base1 ∧ C.writable tp1 = true ∧ C.writable uspi = true ∧ (0 : ℤ) < BitVec.toUInt (C.pelts tp1 (C.offset tp1 + BitVec.toInt un - (1 : ℤ))) ∧ (0 : ℤ) < BitVec.toInt o8 ∧ C.valid uspi (BitVec.toInt o8) ∧ Lemmas.value tp1 (BitVec.toInt un) < HPow.hPow (BitVec.toInt base1) (Int.toNat (BitVec.toInt o8 - (1 : ℤ)))) ∧ (∀(uspi1 : C.ptr (BitVec 8)) (usp1 : C.ptr (BitVec 8)), C.data uspi1 = C.data usp1 ∧ List.length (C.data usp1) = List.length (C.data uspi) ∧ C.offset uspi1 = C.offset uspi ∧ C.min uspi1 = C.min uspi ∧ C.max uspi1 = C.max uspi ∧ C.writable uspi1 = C.writable uspi ∧ C.zone1 uspi1 = C.zone1 uspi → List.length (C.data usp1) = List.length (C.data usp) ∧ C.offset usp1 = C.offset usp ∧ C.min usp1 = C.min usp ∧ C.max usp1 = C.max usp ∧ C.writable usp1 = C.writable usp ∧ C.zone1 usp1 = C.zone1 usp → (∀(g : BitVec 32), ((0 : ℤ) ≤ BitVec.toUInt g ∧ BitVec.toUInt g < BitVec.toInt o8) ∧ String_lemmas.svalue (BitVec.toInt base1) uspi1 (BitVec.toUInt g) = Lemmas.value tp1 (BitVec.toInt un) ∧ String_lemmas.in_base (BitVec.toInt base1) (C.pelts uspi1) (C.offset uspi1) (C.offset uspi1 + BitVec.toUInt g) ∧ (0 : ℤ) < BitVec.toInt (C.pelts uspi1 (C.offset uspi1)) ∧ (∀(j : ℤ), j < C.offset uspi1 ∨ C.offset uspi1 + BitVec.toInt o8 ≤ j → C.pelts uspi1 j = C.pelts uspi j) → BitVec.toUInt g ≤ (2147483647 : ℤ) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toUInt g → int'32_in_bounds (BitVec.toInt o4 + BitVec.toInt o9) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt o4 + BitVec.toInt o9 → (UChar.ok mem = true ∧ UChar.z mem = C.zone1 sp2 ∧ UChar.mi mem = C.min usp1 ∧ UChar.ma mem = C.max usp1 ∧ C.offset sp2 = C.offset usp1 ∧ C.plength usp1 = UChar.l mem) ∧ (∀(mem1 : UChar.cast_mem) (sp3 : C.ptr (BitVec 8)), UChar.mi mem1 = UChar.mi mem ∧ UChar.ma mem1 = UChar.ma mem ∧ UChar.z mem1 = UChar.z mem ∧ UChar.l mem1 = UChar.l mem → C.offset sp3 = C.offset sp2 ∧ C.writable sp3 = C.writable sp2 ∧ C.zone1 sp3 = C.zone1 sp2 → (C.min sp3 = UChar.mi mem1 ∧ C.max sp3 = UChar.ma mem1) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < C.plength sp3 → C.pelts sp3 i = C.pelts usp1 i) ∧ C.plength sp3 = C.plength usp1 → int'32_in_bounds (BitVec.toInt o10 - (1 : ℤ)) ∧ (∀(o11 : BitVec 32), BitVec.toInt o11 = BitVec.toInt o10 - (1 : ℤ) → (BitVec.toInt o4 ≤ BitVec.toInt o11 + (1 : ℤ) → ((BitVec.toInt o4 ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ BitVec.toInt o10) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + BitVec.toInt o4)) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + BitVec.toInt o4)) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + BitVec.toInt o4)) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp3) (C.offset sp3 + BitVec.toInt o4) (C.offset sp3 + BitVec.toInt o4) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + BitVec.toInt o4) (C.offset usp1 + BitVec.toInt o4) ∧ (∀(k : ℤ), C.offset sp3 ≤ k ∧ k < C.offset sp3 + BitVec.toInt o4 → ¬BitVec.toInt (C.pelts sp3 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp3) (C.offset sp3 + BitVec.toInt o4) (C.offset sp3 + BitVec.toInt o4) ∧ (BitVec.toInt o4 = (1 : ℤ) → C.pelts sp3 (C.offset sp3) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ (BitVec.toInt o4 = (0 : ℤ) → BitVec.toInt o4 < BitVec.toInt o4 → ¬C.pelts sp3 (C.offset sp3) = ([45] : List (BitVec 8))[(0 : ℕ)]!)) ∧ (∀(sp4 : C.ptr (BitVec 8)), List.length (C.data sp4) = List.length (C.data sp3) ∧ C.offset sp4 = C.offset sp3 ∧ C.min sp4 = C.min sp3 ∧ C.max sp4 = C.max sp3 ∧ C.writable sp4 = C.writable sp3 ∧ C.zone1 sp4 = C.zone1 sp3 → (∀(j : BitVec 32), let j1 : ℤ := BitVec.toInt j; (BitVec.toInt o4 ≤ j1 ∧ j1 ≤ BitVec.toInt o11) ∧ (BitVec.toInt o4 ≤ j1 ∧ j1 ≤ BitVec.toInt o10) ∧ (∀(k : ℤ), C.offset sp4 + j1 ≤ C.offset sp4 + k ∧ C.offset sp4 + k < C.offset sp4 + BitVec.toInt o10 → C.pelts sp4 (C.offset sp4 + k) = C.pelts sp3 (C.offset sp4 + k)) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + j1)) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + j1)) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + j1)) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp4) (C.offset sp4 + BitVec.toInt o4) (C.offset sp4 + j1) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + BitVec.toInt o4) (C.offset usp1 + j1) ∧ (∀(k : ℤ), C.offset sp4 ≤ k ∧ k < C.offset sp4 + j1 → ¬BitVec.toInt (C.pelts sp4 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp4) (C.offset sp4 + BitVec.toInt o4) (C.offset sp4 + j1) ∧ (BitVec.toInt o4 = (1 : ℤ) → C.pelts sp4 (C.offset sp4) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ (BitVec.toInt o4 = (0 : ℤ) → BitVec.toInt o4 < j1 → ¬C.pelts sp4 (C.offset sp4) = ([45] : List (BitVec 8))[(0 : ℕ)]!) → (C.min sp4 ≤ C.offset sp4 + BitVec.toInt j ∧ C.offset sp4 + BitVec.toInt j < C.max sp4) ∧ (let o12 : BitVec 8 := C.pelts sp4 (C.offset sp4 + BitVec.toInt j); let cj : BitVec 8 := o12; ((0 : ℤ) ≤ BitVec.toInt o12 ∧ BitVec.toInt o12 ≤ (127 : ℤ) → BitVec.toInt cj = BitVec.toInt o12) → (∀(o13 : BitVec 32), BitVec.toInt o13 = BitVec.toInt cj → ((0 : ℤ) ≤ BitVec.toInt o13 ∧ BitVec.toInt o13 ≤ Int.ofNat (List.length digits)) ∧ (∀(dc : BitVec 8), ((0 : ℤ) ≤ BitVec.toInt o13 ∧ BitVec.toInt o13 < Int.ofNat (List.length digits) → dc = digits[Int.toNat (BitVec.toInt o13)]!) ∧ (BitVec.toInt o13 = Int.ofNat (List.length digits) → dc = BitVec.ofNat 8 (0 : ℕ)) → ((C.min sp4 ≤ C.offset sp4 + BitVec.toInt j ∧ C.offset sp4 + BitVec.toInt j < C.max sp4) ∧ C.writable sp4 = true) ∧ (∀(sp5 : C.ptr (BitVec 8)), List.length (C.data sp5) = List.length (C.data sp4) ∧ C.offset sp5 = C.offset sp4 ∧ C.min sp5 = C.min sp4 ∧ C.max sp5 = C.max sp4 ∧ C.writable sp5 = C.writable sp4 ∧ C.zone1 sp5 = C.zone1 sp4 → C.pelts sp5 = Function.update (C.pelts sp4) (C.offset sp5 + BitVec.toInt j) dc ∧ C.pelts sp5 (C.offset sp5 + BitVec.toInt j) = dc → (BitVec.toInt o4 ≤ j1 + (1 : ℤ) ∧ j1 + (1 : ℤ) ≤ BitVec.toInt o10) ∧ (∀(k : ℤ), C.offset sp5 + (j1 + (1 : ℤ)) ≤ C.offset sp5 + k ∧ C.offset sp5 + k < C.offset sp5 + BitVec.toInt o10 → C.pelts sp5 (C.offset sp5 + k) = C.pelts sp3 (C.offset sp5 + k)) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp5) (C.offset sp5) (C.offset sp5 + (j1 + (1 : ℤ)))) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp5) (C.offset sp5) (C.offset sp5 + (j1 + (1 : ℤ)))) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp5) (C.offset sp5) (C.offset sp5 + (j1 + (1 : ℤ)))) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp5) (C.offset sp5 + BitVec.toInt o4) (C.offset sp5 + (j1 + (1 : ℤ))) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + BitVec.toInt o4) (C.offset usp1 + (j1 + (1 : ℤ))) ∧ (∀(k : ℤ), C.offset sp5 ≤ k ∧ k < C.offset sp5 + (j1 + (1 : ℤ)) → ¬BitVec.toInt (C.pelts sp5 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp5) (C.offset sp5 + BitVec.toInt o4) (C.offset sp5 + (j1 + (1 : ℤ))) ∧ (BitVec.toInt o4 = (1 : ℤ) → C.pelts sp5 (C.offset sp5) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ (BitVec.toInt o4 = (0 : ℤ) → BitVec.toInt o4 < j1 + (1 : ℤ) → ¬C.pelts sp5 (C.offset sp5) = ([45] : List (BitVec 8))[(0 : ℕ)]!)))))) ∧ ((BitVec.toInt o4 ≤ BitVec.toInt o11 + (1 : ℤ) ∧ BitVec.toInt o11 + (1 : ℤ) ≤ BitVec.toInt o10) ∧ (∀(k : ℤ), C.offset sp4 + (BitVec.toInt o11 + (1 : ℤ)) ≤ C.offset sp4 + k ∧ C.offset sp4 + k < C.offset sp4 + BitVec.toInt o10 → C.pelts sp4 (C.offset sp4 + k) = C.pelts sp3 (C.offset sp4 + k)) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + (BitVec.toInt o11 + (1 : ℤ)))) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + (BitVec.toInt o11 + (1 : ℤ)))) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + (BitVec.toInt o11 + (1 : ℤ)))) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp4) (C.offset sp4 + BitVec.toInt o4) (C.offset sp4 + (BitVec.toInt o11 + (1 : ℤ))) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + BitVec.toInt o4) (C.offset usp1 + (BitVec.toInt o11 + (1 : ℤ))) ∧ (∀(k : ℤ), C.offset sp4 ≤ k ∧ k < C.offset sp4 + (BitVec.toInt o11 + (1 : ℤ)) → ¬BitVec.toInt (C.pelts sp4 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp4) (C.offset sp4 + BitVec.toInt o4) (C.offset sp4 + (BitVec.toInt o11 + (1 : ℤ))) ∧ (BitVec.toInt o4 = (1 : ℤ) → C.pelts sp4 (C.offset sp4) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ (BitVec.toInt o4 = (0 : ℤ) → BitVec.toInt o4 < BitVec.toInt o11 + (1 : ℤ) → ¬C.pelts sp4 (C.offset sp4) = ([45] : List (BitVec 8))[(0 : ℕ)]!) → (let o12 : BitVec 8 := String.zero_char; ((C.min sp4 ≤ C.offset sp4 + BitVec.toInt o10 ∧ C.offset sp4 + BitVec.toInt o10 < C.max sp4) ∧ C.writable sp4 = true) ∧ (∀(sp5 : C.ptr (BitVec 8)), List.length (C.data sp5) = List.length (C.data sp4) ∧ C.offset sp5 = C.offset sp4 ∧ C.min sp5 = C.min sp4 ∧ C.max sp5 = C.max sp4 ∧ C.writable sp5 = C.writable sp4 ∧ C.zone1 sp5 = C.zone1 sp4 → C.pelts sp5 = Function.update (C.pelts sp4) (C.offset sp5 + BitVec.toInt o10) o12 ∧ C.pelts sp5 (C.offset sp5 + BitVec.toInt o10) = o12 → (Z.zones mpz1 u = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz1 u ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → Z.readers mpz2 u = Z.readers mpz1 u - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u → Z.readers mpz2 y = Z.readers mpz1 y) → String.valid_string sp5 ∧ String_value.string_in_base (effective (BitVec.toInt base)) (C.pelts sp5) (C.offset sp5) ∧ (∀(x : Z.mpz_ptr), Z.mpz_unchanged x mpz2 mpz) ∧ String_value.value_text (effective (BitVec.toInt base)) (C.pelts sp5) (C.offset sp5) = Z.value_of u mpz2)))))) ∧ (BitVec.toInt o11 + (1 : ℤ) < BitVec.toInt o4 → (let o12 : BitVec 8 := String.zero_char; ((C.min sp3 ≤ C.offset sp3 + BitVec.toInt o10 ∧ C.offset sp3 + BitVec.toInt o10 < C.max sp3) ∧ C.writable sp3 = true) ∧ (∀(sp4 : C.ptr (BitVec 8)), List.length (C.data sp4) = List.length (C.data sp3) ∧ C.offset sp4 = C.offset sp3 ∧ C.min sp4 = C.min sp3 ∧ C.max sp4 = C.max sp3 ∧ C.writable sp4 = C.writable sp3 ∧ C.zone1 sp4 = C.zone1 sp3 → C.pelts sp4 = Function.update (C.pelts sp3) (C.offset sp4 + BitVec.toInt o10) o12 ∧ C.pelts sp4 (C.offset sp4 + BitVec.toInt o10) = o12 → (Z.zones mpz1 u = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz1 u ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → Z.readers mpz2 u = Z.readers mpz1 u - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u → Z.readers mpz2 y = Z.readers mpz1 y) → String.valid_string sp4 ∧ String_value.string_in_base (effective (BitVec.toInt base)) (C.pelts sp4) (C.offset sp4) ∧ (∀(x : Z.mpz_ptr), Z.mpz_unchanged x mpz2 mpz) ∧ String_value.value_text (effective (BitVec.toInt base)) (C.pelts sp4) (C.offset sp4) = Z.value_of u mpz2)))))))))))))))))))))))))) else (0 : ℤ) ≤ BitVec.toInt base1 ∧ (∀(o3 : BitVec 64), BitVec.toUInt o3 = BitVec.toInt base1 → ((2 : ℤ) ≤ BitVec.toUInt o3 ∧ BitVec.toUInt o3 ≤ (256 : ℤ)) ∧ (∀(bits : BitVec 32), ((0 : ℤ) ≤ BitVec.toUInt bits ∧ BitVec.toUInt bits ≤ (8 : ℤ)) ∧ (¬BitVec.toUInt bits = (0 : ℤ) → HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits)) = BitVec.toUInt o3) ∧ (BitVec.toUInt bits = (0 : ℤ) → (∀(n : ℤ), (0 : ℤ) ≤ n → ¬HPow.hPow (2 : ℤ) (Int.toNat n) = BitVec.toUInt o3)) → (0 : ℤ) ≤ Z.readers mpz u ∧ (∀(mpz1 : Z.mpz_memo), Z.abs_value_of mpz1 = Z.abs_value_of mpz ∧ Z.alloc mpz1 = Z.alloc mpz ∧ Z.abs_size mpz1 = Z.abs_size mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(up : C.ptr (BitVec 64)), Z.readers mpz1 u = Z.readers mpz u + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬u = y → Z.readers mpz1 y = Z.readers mpz y) ∧ Lemmas.value up (Z.abs_size mpz1 u) = Z.abs_value_of mpz1 u ∧ C.plength up = Z.alloc mpz1 u ∧ C.offset up = (0 : ℤ) ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up ∧ C.zone1 up = Z.zones mpz1 u → C.writable sp = true ∧ (∀(sp1 : C.ptr (BitVec 8)), C.offset sp1 = C.offset sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → (∀(usp : C.ptr (BitVec 8)) (mem : UChar.cast_mem), (C.min usp = C.min sp ∧ C.min sp = UChar.mi mem) ∧ (C.max usp = C.max sp ∧ C.max sp = UChar.ma mem) ∧ C.zone1 sp = UChar.z mem ∧ (C.plength usp = C.plength sp ∧ C.plength sp = UChar.l mem) ∧ UChar.ok mem = true ∧ C.offset usp = C.offset sp ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < C.plength sp → C.pelts usp i = C.pelts sp i) ∧ C.writable usp = true → (C.min usp ≤ C.offset usp + (0 : ℤ) ∧ C.offset usp + (0 : ℤ) ≤ C.max usp) ∧ (∀(uspi : C.ptr (BitVec 8)), C.offset uspi = C.offset usp + (0 : ℤ) ∧ C.plength uspi = C.plength usp ∧ C.pelts uspi = C.pelts usp ∧ C.data uspi = C.data usp ∧ C.min uspi = C.min usp ∧ C.max uspi = C.max usp ∧ C.zone1 uspi = C.zone1 usp ∧ C.writable uspi = C.writable usp → (BitVec.toUInt bits = (0 : ℤ) → bits = (0 : BitVec 32)) → (if ¬bits = (0 : BitVec 32) then int'32_in_bounds (BitVec.toInt un - (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt un - (1 : ℤ) → (C.min up ≤ C.offset up + BitVec.toInt o4 ∧ C.offset up + BitVec.toInt o4 < C.max up) ∧ (let um : BitVec 64 := C.pelts up (C.offset up + BitVec.toInt o4); (0 : ℤ) < BitVec.toUInt um ∧ (∀(sb : BitVec 64), ((1 : ℤ) ≤ BitVec.toUInt sb ∧ BitVec.toUInt sb ≤ (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt sb - (1 : ℤ))) ≤ BitVec.toUInt um ∧ BitVec.toUInt um < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt sb)) → BitVec.toUInt sb ≤ (2147483647 : ℤ) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toUInt sb → int'32_in_bounds (BitVec.toInt un - (1 : ℤ)) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt un - (1 : ℤ) → int'32_in_bounds ((64 : ℤ) * BitVec.toInt o6) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = (64 : ℤ) * BitVec.toInt o6 → int'32_in_bounds (BitVec.toInt o7 + BitVec.toInt o5) ∧ (∀(ub : BitVec 32), BitVec.toInt ub = BitVec.toInt o7 + BitVec.toInt o5 → ((1 : ℤ) ≤ BitVec.toInt un ∧ C.valid up (BitVec.toInt un) ∧ ((1 : ℤ) ≤ BitVec.toUInt bits ∧ BitVec.toUInt bits ≤ (8 : ℤ)) ∧ C.valid uspi ((BitVec.toInt ub + BitVec.toUInt bits - (1 : ℤ)) / BitVec.toUInt bits) ∧ (0 : ℤ) ≤ BitVec.toInt ub ∧ Lemmas.value up (BitVec.toInt un) < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt ub)) ∧ (0 : ℤ) < BitVec.toUInt (C.pelts up (C.offset up + BitVec.toInt un - (1 : ℤ))) ∧ (64 : ℤ) * BitVec.toInt un + (7 : ℤ) ≤ (2147483647 : ℤ) ∧ C.writable uspi = true) ∧ (∀(uspi1 : C.ptr (BitVec 8)) (usp1 : C.ptr (BitVec 8)), C.data uspi1 = C.data usp1 ∧ List.length (C.data usp1) = List.length (C.data uspi) ∧ C.offset uspi1 = C.offset uspi ∧ C.min uspi1 = C.min uspi ∧ C.max uspi1 = C.max uspi ∧ C.writable uspi1 = C.writable uspi ∧ C.zone1 uspi1 = C.zone1 uspi → List.length (C.data usp1) = List.length (C.data usp) ∧ C.offset usp1 = C.offset usp ∧ C.min usp1 = C.min usp ∧ C.max usp1 = C.max usp ∧ C.writable usp1 = C.writable usp ∧ C.zone1 usp1 = C.zone1 usp → (∀(g : BitVec 32), String_lemmas.in_base (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) (C.pelts uspi1) (C.offset uspi1) (C.offset uspi1 + BitVec.toUInt g) ∧ String_lemmas.svalue (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) uspi1 (BitVec.toUInt g) = Lemmas.value up (BitVec.toInt un) ∧ ((0 : ℤ) < BitVec.toUInt g ∧ BitVec.toUInt g ≤ (BitVec.toInt ub + BitVec.toUInt bits - (1 : ℤ)) / BitVec.toUInt bits) ∧ (0 : ℤ) < BitVec.toInt (C.pelts uspi1 (C.offset uspi1)) ∧ (∀(j : ℤ), j < C.offset uspi1 ∨ C.offset uspi1 + (BitVec.toInt ub + BitVec.toUInt bits - (1 : ℤ)) / BitVec.toUInt bits ≤ j → C.pelts uspi1 j = C.pelts uspi j) → BitVec.toUInt g ≤ (2147483647 : ℤ) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toUInt g → int'32_in_bounds ((0 : ℤ) + BitVec.toInt o8) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = (0 : ℤ) + BitVec.toInt o8 → (UChar.ok mem = true ∧ UChar.z mem = C.zone1 sp1 ∧ UChar.mi mem = C.min usp1 ∧ UChar.ma mem = C.max usp1 ∧ C.offset sp1 = C.offset usp1 ∧ C.plength usp1 = UChar.l mem) ∧ (∀(mem1 : UChar.cast_mem) (sp2 : C.ptr (BitVec 8)), UChar.mi mem1 = UChar.mi mem ∧ UChar.ma mem1 = UChar.ma mem ∧ UChar.z mem1 = UChar.z mem ∧ UChar.l mem1 = UChar.l mem → C.offset sp2 = C.offset sp1 ∧ C.writable sp2 = C.writable sp1 ∧ C.zone1 sp2 = C.zone1 sp1 → (C.min sp2 = UChar.mi mem1 ∧ C.max sp2 = UChar.ma mem1) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < C.plength sp2 → C.pelts sp2 i = C.pelts usp1 i) ∧ C.plength sp2 = C.plength usp1 → int'32_in_bounds (BitVec.toInt o9 - (1 : ℤ)) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt o9 - (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o10 + (1 : ℤ) → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt o9) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp2) (C.offset sp2) (C.offset sp2 + (0 : ℤ))) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp2) (C.offset sp2) (C.offset sp2 + (0 : ℤ))) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp2) (C.offset sp2) (C.offset sp2 + (0 : ℤ))) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp2) (C.offset sp2 + (0 : ℤ)) (C.offset sp2 + (0 : ℤ)) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + (0 : ℤ)) (C.offset usp1 + (0 : ℤ)) ∧ (∀(k : ℤ), C.offset sp2 ≤ k ∧ k < C.offset sp2 + (0 : ℤ) → ¬BitVec.toInt (C.pelts sp2 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp2) (C.offset sp2 + (0 : ℤ)) (C.offset sp2 + (0 : ℤ)) ∧ ((0 : ℤ) = (1 : ℤ) → C.pelts sp2 (C.offset sp2) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ ((0 : ℤ) < (0 : ℤ) → ¬C.pelts sp2 (C.offset sp2) = ([45] : List (BitVec 8))[(0 : ℕ)]!)) ∧ (∀(sp3 : C.ptr (BitVec 8)), List.length (C.data sp3) = List.length (C.data sp2) ∧ C.offset sp3 = C.offset sp2 ∧ C.min sp3 = C.min sp2 ∧ C.max sp3 = C.max sp2 ∧ C.writable sp3 = C.writable sp2 ∧ C.zone1 sp3 = C.zone1 sp2 → (∀(j : BitVec 32), let j1 : ℤ := BitVec.toInt j; ((0 : ℤ) ≤ j1 ∧ j1 ≤ BitVec.toInt o10) ∧ ((0 : ℤ) ≤ j1 ∧ j1 ≤ BitVec.toInt o9) ∧ (∀(k : ℤ), C.offset sp3 + j1 ≤ C.offset sp3 + k ∧ C.offset sp3 + k < C.offset sp3 + BitVec.toInt o9 → C.pelts sp3 (C.offset sp3 + k) = C.pelts sp2 (C.offset sp3 + k)) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + j1)) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + j1)) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + j1)) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp3) (C.offset sp3 + (0 : ℤ)) (C.offset sp3 + j1) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + (0 : ℤ)) (C.offset usp1 + j1) ∧ (∀(k : ℤ), C.offset sp3 ≤ k ∧ k < C.offset sp3 + j1 → ¬BitVec.toInt (C.pelts sp3 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp3) (C.offset sp3 + (0 : ℤ)) (C.offset sp3 + j1) ∧ ((0 : ℤ) = (1 : ℤ) → C.pelts sp3 (C.offset sp3) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ ((0 : ℤ) < j1 → ¬C.pelts sp3 (C.offset sp3) = ([45] : List (BitVec 8))[(0 : ℕ)]!) → (C.min sp3 ≤ C.offset sp3 + BitVec.toInt j ∧ C.offset sp3 + BitVec.toInt j < C.max sp3) ∧ (let o11 : BitVec 8 := C.pelts sp3 (C.offset sp3 + BitVec.toInt j); let cj : BitVec 8 := o11; ((0 : ℤ) ≤ BitVec.toInt o11 ∧ BitVec.toInt o11 ≤ (127 : ℤ) → BitVec.toInt cj = BitVec.toInt o11) → (∀(o12 : BitVec 32), BitVec.toInt o12 = BitVec.toInt cj → ((0 : ℤ) ≤ BitVec.toInt o12 ∧ BitVec.toInt o12 ≤ Int.ofNat (List.length digits)) ∧ (∀(dc : BitVec 8), ((0 : ℤ) ≤ BitVec.toInt o12 ∧ BitVec.toInt o12 < Int.ofNat (List.length digits) → dc = digits[Int.toNat (BitVec.toInt o12)]!) ∧ (BitVec.toInt o12 = Int.ofNat (List.length digits) → dc = BitVec.ofNat 8 (0 : ℕ)) → ((C.min sp3 ≤ C.offset sp3 + BitVec.toInt j ∧ C.offset sp3 + BitVec.toInt j < C.max sp3) ∧ C.writable sp3 = true) ∧ (∀(sp4 : C.ptr (BitVec 8)), List.length (C.data sp4) = List.length (C.data sp3) ∧ C.offset sp4 = C.offset sp3 ∧ C.min sp4 = C.min sp3 ∧ C.max sp4 = C.max sp3 ∧ C.writable sp4 = C.writable sp3 ∧ C.zone1 sp4 = C.zone1 sp3 → C.pelts sp4 = Function.update (C.pelts sp3) (C.offset sp4 + BitVec.toInt j) dc ∧ C.pelts sp4 (C.offset sp4 + BitVec.toInt j) = dc → ((0 : ℤ) ≤ j1 + (1 : ℤ) ∧ j1 + (1 : ℤ) ≤ BitVec.toInt o9) ∧ (∀(k : ℤ), C.offset sp4 + (j1 + (1 : ℤ)) ≤ C.offset sp4 + k ∧ C.offset sp4 + k < C.offset sp4 + BitVec.toInt o9 → C.pelts sp4 (C.offset sp4 + k) = C.pelts sp2 (C.offset sp4 + k)) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + (j1 + (1 : ℤ)))) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + (j1 + (1 : ℤ)))) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + (j1 + (1 : ℤ)))) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp4) (C.offset sp4 + (0 : ℤ)) (C.offset sp4 + (j1 + (1 : ℤ))) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + (0 : ℤ)) (C.offset usp1 + (j1 + (1 : ℤ))) ∧ (∀(k : ℤ), C.offset sp4 ≤ k ∧ k < C.offset sp4 + (j1 + (1 : ℤ)) → ¬BitVec.toInt (C.pelts sp4 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp4) (C.offset sp4 + (0 : ℤ)) (C.offset sp4 + (j1 + (1 : ℤ))) ∧ ((0 : ℤ) = (1 : ℤ) → C.pelts sp4 (C.offset sp4) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ ((0 : ℤ) < j1 + (1 : ℤ) → ¬C.pelts sp4 (C.offset sp4) = ([45] : List (BitVec 8))[(0 : ℕ)]!)))))) ∧ (((0 : ℤ) ≤ BitVec.toInt o10 + (1 : ℤ) ∧ BitVec.toInt o10 + (1 : ℤ) ≤ BitVec.toInt o9) ∧ (∀(k : ℤ), C.offset sp3 + (BitVec.toInt o10 + (1 : ℤ)) ≤ C.offset sp3 + k ∧ C.offset sp3 + k < C.offset sp3 + BitVec.toInt o9 → C.pelts sp3 (C.offset sp3 + k) = C.pelts sp2 (C.offset sp3 + k)) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + (BitVec.toInt o10 + (1 : ℤ)))) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + (BitVec.toInt o10 + (1 : ℤ)))) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + (BitVec.toInt o10 + (1 : ℤ)))) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp3) (C.offset sp3 + (0 : ℤ)) (C.offset sp3 + (BitVec.toInt o10 + (1 : ℤ))) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + (0 : ℤ)) (C.offset usp1 + (BitVec.toInt o10 + (1 : ℤ))) ∧ (∀(k : ℤ), C.offset sp3 ≤ k ∧ k < C.offset sp3 + (BitVec.toInt o10 + (1 : ℤ)) → ¬BitVec.toInt (C.pelts sp3 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp3) (C.offset sp3 + (0 : ℤ)) (C.offset sp3 + (BitVec.toInt o10 + (1 : ℤ))) ∧ ((0 : ℤ) = (1 : ℤ) → C.pelts sp3 (C.offset sp3) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ ((0 : ℤ) < BitVec.toInt o10 + (1 : ℤ) → ¬C.pelts sp3 (C.offset sp3) = ([45] : List (BitVec 8))[(0 : ℕ)]!) → (let o11 : BitVec 8 := String.zero_char; ((C.min sp3 ≤ C.offset sp3 + BitVec.toInt o9 ∧ C.offset sp3 + BitVec.toInt o9 < C.max sp3) ∧ C.writable sp3 = true) ∧ (∀(sp4 : C.ptr (BitVec 8)), List.length (C.data sp4) = List.length (C.data sp3) ∧ C.offset sp4 = C.offset sp3 ∧ C.min sp4 = C.min sp3 ∧ C.max sp4 = C.max sp3 ∧ C.writable sp4 = C.writable sp3 ∧ C.zone1 sp4 = C.zone1 sp3 → C.pelts sp4 = Function.update (C.pelts sp3) (C.offset sp4 + BitVec.toInt o9) o11 ∧ C.pelts sp4 (C.offset sp4 + BitVec.toInt o9) = o11 → (Z.zones mpz1 u = C.zone1 up ∧ (1 : ℤ) ≤ Z.readers mpz1 u ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up) ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → Z.readers mpz2 u = Z.readers mpz1 u - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u → Z.readers mpz2 y = Z.readers mpz1 y) → String.valid_string sp4 ∧ String_value.string_in_base (effective (BitVec.toInt base)) (C.pelts sp4) (C.offset sp4) ∧ (∀(x : Z.mpz_ptr), Z.mpz_unchanged x mpz2 mpz) ∧ String_value.value_text (effective (BitVec.toInt base)) (C.pelts sp4) (C.offset sp4) = Z.value_of u mpz2)))))) ∧ (BitVec.toInt o10 + (1 : ℤ) < (0 : ℤ) → (let o11 : BitVec 8 := String.zero_char; ((C.min sp2 ≤ C.offset sp2 + BitVec.toInt o9 ∧ C.offset sp2 + BitVec.toInt o9 < C.max sp2) ∧ C.writable sp2 = true) ∧ (∀(sp3 : C.ptr (BitVec 8)), List.length (C.data sp3) = List.length (C.data sp2) ∧ C.offset sp3 = C.offset sp2 ∧ C.min sp3 = C.min sp2 ∧ C.max sp3 = C.max sp2 ∧ C.writable sp3 = C.writable sp2 ∧ C.zone1 sp3 = C.zone1 sp2 → C.pelts sp3 = Function.update (C.pelts sp2) (C.offset sp3 + BitVec.toInt o9) o11 ∧ C.pelts sp3 (C.offset sp3 + BitVec.toInt o9) = o11 → (Z.zones mpz1 u = C.zone1 up ∧ (1 : ℤ) ≤ Z.readers mpz1 u ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up) ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → Z.readers mpz2 u = Z.readers mpz1 u - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u → Z.readers mpz2 y = Z.readers mpz1 y) → String.valid_string sp3 ∧ String_value.string_in_base (effective (BitVec.toInt base)) (C.pelts sp3) (C.offset sp3) ∧ (∀(x : Z.mpz_ptr), Z.mpz_unchanged x mpz2 mpz) ∧ String_value.value_text (effective (BitVec.toInt base)) (C.pelts sp3) (C.offset sp3) = Z.value_of u mpz2))))))))))))))))) else (0 : ℤ) ≤ BitVec.toInt base1 ∧ (∀(o4 : BitVec 64), BitVec.toUInt o4 = BitVec.toInt base1 → ((2 : ℤ) ≤ BitVec.toUInt o4 ∧ BitVec.toUInt o4 ≤ (256 : ℤ)) ∧ (∀(info : BaseInfo.wmpn_base_info), BaseInfo.b info = BitVec.toUInt o4 → (0 : ℤ) ≤ BitVec.toInt un ∧ (∀(o5 : BitVec 32), BitVec.toUInt o5 = BitVec.toInt un → (0 : ℤ) ≤ BitVec.toUInt o5 ∧ (∀(tp : C.ptr (BitVec 64)), C.plength tp = BitVec.toUInt o5 ∧ C.offset tp = (0 : ℤ) ∧ C.min tp = (0 : ℤ) ∧ C.max tp = BitVec.toUInt o5 ∧ C.writable tp = true → (C.valid up (BitVec.toInt un) ∧ C.valid tp (BitVec.toInt un) ∧ C.writable tp = true) ∧ (∀(tp1 : C.ptr (BitVec 64)) (up1 : C.ptr (BitVec 64)), C.offset tp1 = C.offset tp ∧ C.writable tp1 = C.writable tp ∧ C.zone1 tp1 = C.zone1 tp → C.offset up1 = C.offset up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → Lemmas.map_eq_sub_shift (C.pelts tp1) (C.pelts up) (C.offset tp1) (C.offset up) (BitVec.toInt un) ∧ (∀(j : ℤ), j < C.offset tp1 ∨ C.offset tp1 + BitVec.toInt un ≤ j → C.pelts tp1 j = C.pelts tp j) ∧ (∀(j : ℤ), C.pelts up1 j = C.pelts up j) ∧ (C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.plength up1 = C.plength up) ∧ C.min tp1 = C.min tp ∧ C.max tp1 = C.max tp ∧ C.plength tp1 = C.plength tp → int'32_in_bounds (BitVec.toInt sz - (0 : ℤ)) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt sz - (0 : ℤ) → (C.valid tp1 (BitVec.toInt un) ∧ (1 : ℤ) ≤ BitVec.toInt un ∧ BaseInfo.b info = BitVec.toInt base1 ∧ C.writable tp1 = true ∧ C.writable uspi = true ∧ (0 : ℤ) < BitVec.toUInt (C.pelts tp1 (C.offset tp1 + BitVec.toInt un - (1 : ℤ))) ∧ (0 : ℤ) < BitVec.toInt o6 ∧ C.valid uspi (BitVec.toInt o6) ∧ Lemmas.value tp1 (BitVec.toInt un) < HPow.hPow (BitVec.toInt base1) (Int.toNat (BitVec.toInt o6 - (1 : ℤ)))) ∧ (∀(uspi1 : C.ptr (BitVec 8)) (usp1 : C.ptr (BitVec 8)), C.data uspi1 = C.data usp1 ∧ List.length (C.data usp1) = List.length (C.data uspi) ∧ C.offset uspi1 = C.offset uspi ∧ C.min uspi1 = C.min uspi ∧ C.max uspi1 = C.max uspi ∧ C.writable uspi1 = C.writable uspi ∧ C.zone1 uspi1 = C.zone1 uspi → List.length (C.data usp1) = List.length (C.data usp) ∧ C.offset usp1 = C.offset usp ∧ C.min usp1 = C.min usp ∧ C.max usp1 = C.max usp ∧ C.writable usp1 = C.writable usp ∧ C.zone1 usp1 = C.zone1 usp → (∀(g : BitVec 32), ((0 : ℤ) ≤ BitVec.toUInt g ∧ BitVec.toUInt g < BitVec.toInt o6) ∧ String_lemmas.svalue (BitVec.toInt base1) uspi1 (BitVec.toUInt g) = Lemmas.value tp1 (BitVec.toInt un) ∧ String_lemmas.in_base (BitVec.toInt base1) (C.pelts uspi1) (C.offset uspi1) (C.offset uspi1 + BitVec.toUInt g) ∧ (0 : ℤ) < BitVec.toInt (C.pelts uspi1 (C.offset uspi1)) ∧ (∀(j : ℤ), j < C.offset uspi1 ∨ C.offset uspi1 + BitVec.toInt o6 ≤ j → C.pelts uspi1 j = C.pelts uspi j) → BitVec.toUInt g ≤ (2147483647 : ℤ) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toUInt g → int'32_in_bounds ((0 : ℤ) + BitVec.toInt o7) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = (0 : ℤ) + BitVec.toInt o7 → (UChar.ok mem = true ∧ UChar.z mem = C.zone1 sp1 ∧ UChar.mi mem = C.min usp1 ∧ UChar.ma mem = C.max usp1 ∧ C.offset sp1 = C.offset usp1 ∧ C.plength usp1 = UChar.l mem) ∧ (∀(mem1 : UChar.cast_mem) (sp2 : C.ptr (BitVec 8)), UChar.mi mem1 = UChar.mi mem ∧ UChar.ma mem1 = UChar.ma mem ∧ UChar.z mem1 = UChar.z mem ∧ UChar.l mem1 = UChar.l mem → C.offset sp2 = C.offset sp1 ∧ C.writable sp2 = C.writable sp1 ∧ C.zone1 sp2 = C.zone1 sp1 → (C.min sp2 = UChar.mi mem1 ∧ C.max sp2 = UChar.ma mem1) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < C.plength sp2 → C.pelts sp2 i = C.pelts usp1 i) ∧ C.plength sp2 = C.plength usp1 → int'32_in_bounds (BitVec.toInt o8 - (1 : ℤ)) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt o8 - (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o9 + (1 : ℤ) → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt o8) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp2) (C.offset sp2) (C.offset sp2 + (0 : ℤ))) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp2) (C.offset sp2) (C.offset sp2 + (0 : ℤ))) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp2) (C.offset sp2) (C.offset sp2 + (0 : ℤ))) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp2) (C.offset sp2 + (0 : ℤ)) (C.offset sp2 + (0 : ℤ)) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + (0 : ℤ)) (C.offset usp1 + (0 : ℤ)) ∧ (∀(k : ℤ), C.offset sp2 ≤ k ∧ k < C.offset sp2 + (0 : ℤ) → ¬BitVec.toInt (C.pelts sp2 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp2) (C.offset sp2 + (0 : ℤ)) (C.offset sp2 + (0 : ℤ)) ∧ ((0 : ℤ) = (1 : ℤ) → C.pelts sp2 (C.offset sp2) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ ((0 : ℤ) < (0 : ℤ) → ¬C.pelts sp2 (C.offset sp2) = ([45] : List (BitVec 8))[(0 : ℕ)]!)) ∧ (∀(sp3 : C.ptr (BitVec 8)), List.length (C.data sp3) = List.length (C.data sp2) ∧ C.offset sp3 = C.offset sp2 ∧ C.min sp3 = C.min sp2 ∧ C.max sp3 = C.max sp2 ∧ C.writable sp3 = C.writable sp2 ∧ C.zone1 sp3 = C.zone1 sp2 → (∀(j : BitVec 32), let j1 : ℤ := BitVec.toInt j; ((0 : ℤ) ≤ j1 ∧ j1 ≤ BitVec.toInt o9) ∧ ((0 : ℤ) ≤ j1 ∧ j1 ≤ BitVec.toInt o8) ∧ (∀(k : ℤ), C.offset sp3 + j1 ≤ C.offset sp3 + k ∧ C.offset sp3 + k < C.offset sp3 + BitVec.toInt o8 → C.pelts sp3 (C.offset sp3 + k) = C.pelts sp2 (C.offset sp3 + k)) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + j1)) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + j1)) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + j1)) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp3) (C.offset sp3 + (0 : ℤ)) (C.offset sp3 + j1) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + (0 : ℤ)) (C.offset usp1 + j1) ∧ (∀(k : ℤ), C.offset sp3 ≤ k ∧ k < C.offset sp3 + j1 → ¬BitVec.toInt (C.pelts sp3 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp3) (C.offset sp3 + (0 : ℤ)) (C.offset sp3 + j1) ∧ ((0 : ℤ) = (1 : ℤ) → C.pelts sp3 (C.offset sp3) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ ((0 : ℤ) < j1 → ¬C.pelts sp3 (C.offset sp3) = ([45] : List (BitVec 8))[(0 : ℕ)]!) → (C.min sp3 ≤ C.offset sp3 + BitVec.toInt j ∧ C.offset sp3 + BitVec.toInt j < C.max sp3) ∧ (let o10 : BitVec 8 := C.pelts sp3 (C.offset sp3 + BitVec.toInt j); let cj : BitVec 8 := o10; ((0 : ℤ) ≤ BitVec.toInt o10 ∧ BitVec.toInt o10 ≤ (127 : ℤ) → BitVec.toInt cj = BitVec.toInt o10) → (∀(o11 : BitVec 32), BitVec.toInt o11 = BitVec.toInt cj → ((0 : ℤ) ≤ BitVec.toInt o11 ∧ BitVec.toInt o11 ≤ Int.ofNat (List.length digits)) ∧ (∀(dc : BitVec 8), ((0 : ℤ) ≤ BitVec.toInt o11 ∧ BitVec.toInt o11 < Int.ofNat (List.length digits) → dc = digits[Int.toNat (BitVec.toInt o11)]!) ∧ (BitVec.toInt o11 = Int.ofNat (List.length digits) → dc = BitVec.ofNat 8 (0 : ℕ)) → ((C.min sp3 ≤ C.offset sp3 + BitVec.toInt j ∧ C.offset sp3 + BitVec.toInt j < C.max sp3) ∧ C.writable sp3 = true) ∧ (∀(sp4 : C.ptr (BitVec 8)), List.length (C.data sp4) = List.length (C.data sp3) ∧ C.offset sp4 = C.offset sp3 ∧ C.min sp4 = C.min sp3 ∧ C.max sp4 = C.max sp3 ∧ C.writable sp4 = C.writable sp3 ∧ C.zone1 sp4 = C.zone1 sp3 → C.pelts sp4 = Function.update (C.pelts sp3) (C.offset sp4 + BitVec.toInt j) dc ∧ C.pelts sp4 (C.offset sp4 + BitVec.toInt j) = dc → ((0 : ℤ) ≤ j1 + (1 : ℤ) ∧ j1 + (1 : ℤ) ≤ BitVec.toInt o8) ∧ (∀(k : ℤ), C.offset sp4 + (j1 + (1 : ℤ)) ≤ C.offset sp4 + k ∧ C.offset sp4 + k < C.offset sp4 + BitVec.toInt o8 → C.pelts sp4 (C.offset sp4 + k) = C.pelts sp2 (C.offset sp4 + k)) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + (j1 + (1 : ℤ)))) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + (j1 + (1 : ℤ)))) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp4) (C.offset sp4) (C.offset sp4 + (j1 + (1 : ℤ)))) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp4) (C.offset sp4 + (0 : ℤ)) (C.offset sp4 + (j1 + (1 : ℤ))) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + (0 : ℤ)) (C.offset usp1 + (j1 + (1 : ℤ))) ∧ (∀(k : ℤ), C.offset sp4 ≤ k ∧ k < C.offset sp4 + (j1 + (1 : ℤ)) → ¬BitVec.toInt (C.pelts sp4 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp4) (C.offset sp4 + (0 : ℤ)) (C.offset sp4 + (j1 + (1 : ℤ))) ∧ ((0 : ℤ) = (1 : ℤ) → C.pelts sp4 (C.offset sp4) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ ((0 : ℤ) < j1 + (1 : ℤ) → ¬C.pelts sp4 (C.offset sp4) = ([45] : List (BitVec 8))[(0 : ℕ)]!)))))) ∧ (((0 : ℤ) ≤ BitVec.toInt o9 + (1 : ℤ) ∧ BitVec.toInt o9 + (1 : ℤ) ≤ BitVec.toInt o8) ∧ (∀(k : ℤ), C.offset sp3 + (BitVec.toInt o9 + (1 : ℤ)) ≤ C.offset sp3 + k ∧ C.offset sp3 + k < C.offset sp3 + BitVec.toInt o8 → C.pelts sp3 (C.offset sp3 + k) = C.pelts sp2 (C.offset sp3 + k)) ∧ ((0 : ℤ) ≤ BitVec.toInt base ∧ BitVec.toInt base ≤ (36 : ℤ) → Conversions.to_lowercase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + (BitVec.toInt o9 + (1 : ℤ)))) ∧ ((36 : ℤ) < BitVec.toInt base → Conversions.to_bothcase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + (BitVec.toInt o9 + (1 : ℤ)))) ∧ (BitVec.toInt base < (0 : ℤ) → Conversions.to_uppercase_text (C.pelts usp1) (C.pelts sp3) (C.offset sp3) (C.offset sp3 + (BitVec.toInt o9 + (1 : ℤ)))) ∧ String_value.abs_value_sub_text (BitVec.toInt base1) (C.pelts sp3) (C.offset sp3 + (0 : ℤ)) (C.offset sp3 + (BitVec.toInt o9 + (1 : ℤ))) = String_lemmas.svalue_sub (BitVec.toInt base1) (C.pelts usp1) (C.offset usp1 + (0 : ℤ)) (C.offset usp1 + (BitVec.toInt o9 + (1 : ℤ))) ∧ (∀(k : ℤ), C.offset sp3 ≤ k ∧ k < C.offset sp3 + (BitVec.toInt o9 + (1 : ℤ)) → ¬BitVec.toInt (C.pelts sp3 k) = (0 : ℤ)) ∧ String_value.text_in_base (BitVec.toInt base1) (C.pelts sp3) (C.offset sp3 + (0 : ℤ)) (C.offset sp3 + (BitVec.toInt o9 + (1 : ℤ))) ∧ ((0 : ℤ) = (1 : ℤ) → C.pelts sp3 (C.offset sp3) = ([45] : List (BitVec 8))[(0 : ℕ)]!) ∧ ((0 : ℤ) < BitVec.toInt o9 + (1 : ℤ) → ¬C.pelts sp3 (C.offset sp3) = ([45] : List (BitVec 8))[(0 : ℕ)]!) → (let o10 : BitVec 8 := String.zero_char; ((C.min sp3 ≤ C.offset sp3 + BitVec.toInt o8 ∧ C.offset sp3 + BitVec.toInt o8 < C.max sp3) ∧ C.writable sp3 = true) ∧ (∀(sp4 : C.ptr (BitVec 8)), List.length (C.data sp4) = List.length (C.data sp3) ∧ C.offset sp4 = C.offset sp3 ∧ C.min sp4 = C.min sp3 ∧ C.max sp4 = C.max sp3 ∧ C.writable sp4 = C.writable sp3 ∧ C.zone1 sp4 = C.zone1 sp3 → C.pelts sp4 = Function.update (C.pelts sp3) (C.offset sp4 + BitVec.toInt o8) o10 ∧ C.pelts sp4 (C.offset sp4 + BitVec.toInt o8) = o10 → (Z.zones mpz1 u = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz1 u ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → Z.readers mpz2 u = Z.readers mpz1 u - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u → Z.readers mpz2 y = Z.readers mpz1 y) → String.valid_string sp4 ∧ String_value.string_in_base (effective (BitVec.toInt base)) (C.pelts sp4) (C.offset sp4) ∧ (∀(x : Z.mpz_ptr), Z.mpz_unchanged x mpz2 mpz) ∧ String_value.value_text (effective (BitVec.toInt base)) (C.pelts sp4) (C.offset sp4) = Z.value_of u mpz2)))))) ∧ (BitVec.toInt o9 + (1 : ℤ) < (0 : ℤ) → (let o10 : BitVec 8 := String.zero_char; ((C.min sp2 ≤ C.offset sp2 + BitVec.toInt o8 ∧ C.offset sp2 + BitVec.toInt o8 < C.max sp2) ∧ C.writable sp2 = true) ∧ (∀(sp3 : C.ptr (BitVec 8)), List.length (C.data sp3) = List.length (C.data sp2) ∧ C.offset sp3 = C.offset sp2 ∧ C.min sp3 = C.min sp2 ∧ C.max sp3 = C.max sp2 ∧ C.writable sp3 = C.writable sp2 ∧ C.zone1 sp3 = C.zone1 sp2 → C.pelts sp3 = Function.update (C.pelts sp2) (C.offset sp3 + BitVec.toInt o8) o10 ∧ C.pelts sp3 (C.offset sp3 + BitVec.toInt o8) = o10 → (Z.zones mpz1 u = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz1 u ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → Z.readers mpz2 u = Z.readers mpz1 u - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u → Z.readers mpz2 y = Z.readers mpz1 y) → String.valid_string sp3 ∧ String_value.string_in_base (effective (BitVec.toInt base)) (C.pelts sp3) (C.offset sp3) ∧ (∀(x : Z.mpz_ptr), Z.mpz_unchanged x mpz2 mpz) ∧ String_value.value_text (effective (BitVec.toInt base)) (C.pelts sp3) (C.offset sp3) = Z.value_of u mpz2)))))))))))))))))))))))))))))))
  := sorry
end mpz_get_str_Zget_str_wmpz_get_strqtvc
