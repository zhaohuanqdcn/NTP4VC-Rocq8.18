theory Unification_Impl_conflictqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "../../lib/isabelle/Unification_Types" "../../lib/isabelle/Functions_Config" "../../lib/isabelle/Functions_Func" "../../lib/isabelle/BacktrackArray_Types" "../../lib/isabelle/Predicates_Pred" "../../lib/isabelle/BacktrackArray_Logic" "../../lib/isabelle/Choice_Choice" "../../lib/isabelle/BacktrackArray_Impl" "../../lib/isabelle/Firstorder_symbol_spec_Spec" "../../lib/isabelle/Nat_Nat" "../../lib/isabelle/OptionFuncs_Funcs" "../../lib/isabelle/Sum_Sum" "../../lib/isabelle/Firstorder_symbol_impl_Types" "../../lib/isabelle/Firstorder_symbol_impl_Logic" "../../lib/isabelle/Firstorder_symbol_impl_Impl" "../../lib/isabelle/Firstorder_term_spec_Spec" "../../lib/isabelle/Firstorder_term_impl_Types" "../../lib/isabelle/Firstorder_term_impl_Logic" "../../lib/isabelle/Firstorder_term_impl_Impl" "../../lib/isabelle/Unification_Logic"
begin
consts unassigned_closure :: "sdata timestamp \<Rightarrow> int \<Rightarrow> bool"
axiomatization where unassigned_closure_def:   "unassigned_closure y y1 = True \<longleftrightarrow> unassigned y y1"
  for y :: "sdata timestamp"
  and y1 :: "int"
theorem conflict'vc:
  fixes t1 :: "nlimpl_fo_term_list"
  fixes t2 :: "nlimpl_fo_term_list"
  fixes rhob :: "sdata t"
  fixes rho :: "unifier_subst"
  assumes fact0: "sdata_inv (PConflict t1 t2) = True"
  assumes fact1: "unifier_subst_ok rhob rho"
  shows "correct rhob"
  and "let t :: sdata timestamp = current_timestamp rhob; lp :: int \<Rightarrow> bool = unassigned_closure (current_timestamp rhob) in (nlimpl_fo_term_list_ok t1 \<and> nlimpl_fo_term_list_ok t2 \<and> unifier_subst_ok rhob rho \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term_list y (model_fo_term_list_field t1) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(y :: int). is_fo_term_free_var_in_fo_term_list y (model_fo_term_list_field t2) \<longrightarrow> (0 :: int) \<le> y) \<and> (\<forall>(x :: int). x \<in> set (Nil :: int list) \<longrightarrow> lp x = True \<and> (0 :: int) \<le> x) \<and> (\<forall>(x :: int). unassigned (current_timestamp rhob) x \<longrightarrow> lp x = True)) \<and> (\<forall>(l :: int list) (rhob1 :: sdata t). inv rhob1 = inv rhob \<longrightarrow> (\<forall>(o1 :: unification_return). unifier_subst_ok rhob1 (final_unifier o1) \<and> precede rhob rhob1 \<and> (\<forall>(x :: int). x \<in> set l \<longrightarrow> lp x = True \<and> (0 :: int) \<le> x) \<and> (\<forall>(x :: int). unassigned (current_timestamp rhob1) x \<longrightarrow> lp x = True) \<and> subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor o1) = unifier (final_unifier o1) \<and> (\<forall>(s :: int \<Rightarrow> (int, int) fo_term). let s' :: int \<Rightarrow> (int, int) fo_term = subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term_list (model_fo_term_list_field t1) subst_id_symbol s' = subst_fo_term_list (model_fo_term_list_field t2) subst_id_symbol s' \<longrightarrow> s' = subst_compose_fo_term (unifier (final_unifier o1)) subst_id_symbol s) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier o1) in subst_fo_term_list (model_fo_term_list_field t1) subst_id_symbol s0 = subst_fo_term_list (model_fo_term_list_field t2) subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier o1); s1 :: int \<Rightarrow> (int, int) fo_term = unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<and> (let s0 :: int \<Rightarrow> (int, int) fo_term = unifier (final_unifier o1); s1 :: int \<Rightarrow> (int, int) fo_term = unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 \<and> s0 = subst_compose_fo_term s1 subst_id_symbol s0) \<longrightarrow> (case l of Nil \<Rightarrow> precede rhob rhob1 \<and> correct rhob1 | Cons v _ \<Rightarrow> (past_time t rhob1 \<and> correct rhob1) \<and> (\<forall>(rhob2 :: sdata t). inv rhob2 = inv rhob1 \<longrightarrow> correct rhob2 \<and> current_timestamp rhob2 = t \<and> past_time (current_timestamp rhob2) rhob2 \<and> (\<forall>(t21 :: sdata timestamp). before t21 t \<and> past_time t21 rhob1 \<longrightarrow> past_time t21 rhob2) \<and> precede rhob2 rhob1 \<longrightarrow> (let o2 :: sdata = PConflict t1 t2 in (correct rhob2 \<and> (0 :: int) \<le> v \<and> inv rhob2 o2 = True) \<and> (\<forall>(rhob3 :: sdata t). inv rhob3 = inv rhob2 \<longrightarrow> past_time (current_timestamp rhob3) rhob3 \<and> correct rhob3 \<and> precede rhob2 rhob3 \<and> (let tb0 :: int \<Rightarrow> sdata list = table (current_timestamp rhob2) in table (current_timestamp rhob3) = update tb0 v (Cons o2 (tb0 v))) \<longrightarrow> unifier_subst_ok rhob3 rho \<and> precede rhob rhob3))))) \<and> (precede rhob rhob1 \<and> correct rhob1 \<longrightarrow> (past_time t rhob1 \<and> correct rhob1) \<and> (\<forall>(rhob2 :: sdata t). inv rhob2 = inv rhob1 \<longrightarrow> correct rhob2 \<and> current_timestamp rhob2 = t \<and> past_time (current_timestamp rhob2) rhob2 \<and> (\<forall>(t21 :: sdata timestamp). before t21 t \<and> past_time t21 rhob1 \<longrightarrow> past_time t21 rhob2) \<and> precede rhob2 rhob1 \<longrightarrow> unifier_subst_ok rhob2 rho \<and> precede rhob rhob2)))"
  sorry
end
