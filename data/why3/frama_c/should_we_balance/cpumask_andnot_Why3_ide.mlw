(* ---------------------------------------------------------- *)
(* --- Post-condition (file masks.c, line 155) in 'cpumask_andnot' --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_post_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Post-condition (file masks.c, line 155) in 'cpumask_andnot'":
*)
goal goal0:
  forall i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = t_3[(shiftfield_f1_cpumask_bits a)] in
  let a_4 = (shift_uint8 a_3 0) in
  let a_5 = t_3[(shiftfield_f1_cpumask_bits a_1)] in
  let a_6 = (shift_uint8 a_5 0) in
  let a_7 = t_3[(shiftfield_f1_cpumask_bits a_2)] in
  let a_8 = (shift_uint8 a_7 0) in
  let a_9 = (havoc t_1 t_2 a_8 l_size) in
  (null <> a_2) ->
  (((to_uint32 i)) = l_size) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i_1 < l_size) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_4 l_size)) ->
  ((valid_rd t a_6 l_size)) ->
  ((valid_rw t a_8 l_size)) ->
  ((p_idle_core t_3 a_9 i_1)) ->
  ((a_2 <> a) -> ((separated a_8 l_size a_4 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_8 l_size a_6 l_size))) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < l_size) ->
   ((separated a_8 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_2)))]
         0)) l_size))) ->
  (forall i_2 : int. let a_10 = (shift_uint8 a_7 i_2) in (i <= i_2) ->
   (i_2 < l_size) -> ((a_9[a_10] <> 0) <-> (t_2[a_10] <> 0))) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (((t_2[(shift_uint8 a_3 i_2)] = 0) /\ (t_2[(shift_uint8 a_5 i_2)] <> 0)) <->
    (a_9[(shift_uint8 a_7 i_2)] <> 0))) ->
  ((p_idle_core t_3 t_2 i_1))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition (file masks.c, line 158) in 'cpumask_andnot' --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_post_4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import A_schedule_cpumask.A_schedule_cpumask
use import Compound.Compound

(*
goal WP "expl:Post-condition (file masks.c, line 158) in 'cpumask_andnot'":
*)
goal goal1:
  forall i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = t_3[(shiftfield_f1_cpumask_bits a)] in
  let a_4 = (shift_uint8 a_3 0) in
  let a_5 = t_3[(shiftfield_f1_cpumask_bits a_1)] in
  let a_6 = (shift_uint8 a_5 0) in
  let a_7 = t_3[(shiftfield_f1_cpumask_bits a_2)] in
  let a_8 = (shift_uint8 a_7 0) in
  let a_9 = (havoc t_1 t_2 a_8 l_size) in
  (null <> a_2) ->
  (((to_uint32 i)) = l_size) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i_1 < l_size) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((p_idle_core t_3 t_2 i_1)) ->
  ((valid_rd t a_4 l_size)) ->
  ((valid_rd t a_6 l_size)) ->
  ((valid_rw t a_8 l_size)) ->
  ((a_2 <> a) -> ((separated a_8 l_size a_4 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_8 l_size a_6 l_size))) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < l_size) ->
   ((separated a_8 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_2)))]
         0)) l_size))) ->
  (forall i_2 : int. let a_10 = (shift_uint8 a_7 i_2) in (i <= i_2) ->
   (i_2 < l_size) -> ((a_9[a_10] <> 0) <-> (t_2[a_10] <> 0))) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (((t_2[(shift_uint8 a_3 i_2)] = 0) /\ (t_2[(shift_uint8 a_5 i_2)] <> 0)) <->
    (a_9[(shift_uint8 a_7 i_2)] <> 0))) ->
  ((p_idle_core t_3 a_9 i_1))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file masks.c, line 178) --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_loop_inv_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Preservation of Invariant (file masks.c, line 178)":
*)
goal goal2:
  forall i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = (shiftfield_f1_cpumask_bits a_1) in
  let a_4 = (shiftfield_f1_cpumask_bits a_2) in
  let a_5 = (shiftfield_f1_cpumask_bits a) in
  let a_6 = t_3[a_5] in
  let a_7 = (shift_uint8 a_6 0) in
  let a_8 = t_3[a_3] in
  let a_9 = (shift_uint8 a_8 0) in
  let a_10 = (shift_uint8 a_8 i) in
  let a_11 = t_3[a_4] in
  let a_12 = (shift_uint8 a_11 0) in
  let a_13 = (havoc t_1 t_2 a_12 l_size) in
  let a_14 = (shift_uint8 a_6 i) in
  let a_15 = a_13[a_14] in
  let a_16 = a_13[a_10] in
  (null <> a_2) ->
  (((to_uint32 i)) <> l_size) ->
  (0 <= i) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  (i <= 2147483646) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((is_sint32 (1 + i))) ->
  ((valid_rd t a_3 1)) ->
  ((valid_rd t a_4 1)) ->
  ((valid_rd t a_7 l_size)) ->
  ((valid_rd t a_9 l_size)) ->
  ((valid_rd t a_10 1)) ->
  ((valid_rw t a_12 l_size)) ->
  ((valid_rw t ((shift_uint8 a_11 i)) 1)) ->
  ((is_uint8 a_15)) ->
  ((is_uint8 a_16)) ->
  ((a_2 <> a) -> ((separated a_12 l_size a_7 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_12 l_size a_9 l_size))) ->
  ((a_16 = 0) \/ (a_16 = 1)) ->
  ((a_16 = 0) \/
   (((valid_rd t a_5 1)) /\ ((valid_rd t a_14 1)) /\
    ((a_15 = 0) \/ (a_15 = 1)))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < l_size) ->
   ((separated a_12 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_1)))]
         0)) l_size))) ->
  (forall i_1 : int. let a_17 = (shift_uint8 a_11 i_1) in (i <= i_1) ->
   (i_1 < l_size) -> ((a_13[a_17] <> 0) <-> (t_2[a_17] <> 0))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
   (((t_2[(shift_uint8 a_6 i_1)] = 0) /\ (t_2[(shift_uint8 a_8 i_1)] <> 0)) <->
    (a_13[(shift_uint8 a_11 i_1)] <> 0))) ->
  ((i < l_size) /\ ((-1) <= i))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file masks.c, line 178) --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_loop_inv_established
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import A_thread_variables_properties.A_thread_variables_properties
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Establishment of Invariant (file masks.c, line 178)":
*)
goal goal3:
  forall t : map int int.
  forall t_1 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = (shift_uint8 t_1[(shiftfield_f1_cpumask_bits a)] 0) in
  let a_4 = (shift_uint8 t_1[(shiftfield_f1_cpumask_bits a_1)] 0) in
  let a_5 = (shift_uint8 t_1[(shiftfield_f1_cpumask_bits a_2)] 0) in
  (null <> a_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_1)) ->
  ((linked t)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_3 l_size)) ->
  ((valid_rd t a_4 l_size)) ->
  ((valid_rw t a_5 l_size)) ->
  ((a_2 <> a) -> ((separated a_5 l_size a_3 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_5 l_size a_4 l_size))) ->
  (forall i : int. (0 <= i) -> (i < l_size) ->
   ((separated a_5 l_size
      ((shift_uint8 t_1[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i)))] 0))
      l_size))) ->
  (0 <= l_size)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file masks.c, line 179) --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_loop_inv_2_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Preservation of Invariant (file masks.c, line 179)":
*)
goal goal4:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = (shiftfield_f1_cpumask_bits a_1) in
  let a_4 = (shiftfield_f1_cpumask_bits a_2) in
  let a_5 = (shiftfield_f1_cpumask_bits a) in
  let a_6 = t_3[a_5] in
  let a_7 = (shift_uint8 a_6 0) in
  let a_8 = t_3[a_3] in
  let a_9 = (shift_uint8 a_8 0) in
  let a_10 = (shift_uint8 a_8 i_1) in
  let a_11 = t_3[a_4] in
  let a_12 = (shift_uint8 a_11 0) in
  let a_13 = (shift_uint8 a_11 i_1) in
  let a_14 = (havoc t_1 t_2 a_12 l_size) in
  let a_15 = (shift_uint8 a_6 i_1) in
  let a_16 = a_14[a_15] in
  let a_17 = a_14[a_10] in
  (null <> a_2) ->
  (((to_uint32 i_1)) <> l_size) ->
  (0 <= i_1) ->
  (i_2 <= i_1) ->
  (0 <= i_2) ->
  (i_1 <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  (i_1 <= 2147483646) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((is_sint32 (1 + i_1))) ->
  ((valid_rd t a_3 1)) ->
  ((valid_rd t a_4 1)) ->
  ((valid_rd t a_7 l_size)) ->
  ((valid_rd t a_9 l_size)) ->
  ((valid_rd t a_10 1)) ->
  ((valid_rw t a_12 l_size)) ->
  ((valid_rw t a_13 1)) ->
  ((is_uint8 a_16)) ->
  ((is_uint8 a_17)) ->
  (if (a_17 = 0) then (i = 0)
   else (((valid_rd t a_5 1)) /\ ((valid_rd t a_15 1)) /\
         (if (a_16 = 0) then (i = 1) else (i = 0)) /\
         ((a_16 = 0) \/ (a_16 = 1)))) ->
  ((a_2 <> a) -> ((separated a_12 l_size a_7 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_12 l_size a_9 l_size))) ->
  ((a_17 = 0) \/ (a_17 = 1)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < l_size) ->
   ((separated a_12 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_3)))]
         0)) l_size))) ->
  (forall i_3 : int. let a_18 = (shift_uint8 a_11 i_3) in (i_1 <= i_3) ->
   (i_3 < l_size) -> ((a_14[a_18] <> 0) <-> (t_2[a_18] <> 0))) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_1) ->
   (((t_2[(shift_uint8 a_6 i_3)] = 0) /\ (t_2[(shift_uint8 a_8 i_3)] <> 0)) <->
    (a_14[(shift_uint8 a_11 i_3)] <> 0))) ->
  (((t_2[(shift_uint8 a_6 i_2)] = 0) /\ (t_2[(shift_uint8 a_8 i_2)] <> 0)) <->
   (a_14[a_13 <- if (i = 0) then 0 else 1][(shift_uint8 a_11 i_2)] <> 0))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file masks.c, line 180) --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_loop_inv_3_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Preservation of Invariant (file masks.c, line 180)":
*)
goal goal5:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = (shiftfield_f1_cpumask_bits a_1) in
  let a_4 = (shiftfield_f1_cpumask_bits a_2) in
  let a_5 = (shiftfield_f1_cpumask_bits a) in
  let a_6 = t_3[a_5] in
  let a_7 = (shift_uint8 a_6 0) in
  let a_8 = t_3[a_3] in
  let a_9 = (shift_uint8 a_8 0) in
  let a_10 = (shift_uint8 a_8 i_1) in
  let a_11 = t_3[a_4] in
  let a_12 = (shift_uint8 a_11 0) in
  let a_13 = (shift_uint8 a_11 i_1) in
  let a_14 = (havoc t_1 t_2 a_12 l_size) in
  let a_15 = (shift_uint8 a_6 i_1) in
  let a_16 = a_14[a_15] in
  let a_17 = a_14[a_10] in
  let a_18 = (shift_uint8 a_11 i_2) in
  (null <> a_2) ->
  (((to_uint32 i_1)) <> l_size) ->
  (0 <= i_1) ->
  (i_1 < i_2) ->
  (i_2 < l_size) ->
  (i_1 <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  (i_1 <= 2147483646) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((is_sint32 i_1)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((is_sint32 (1 + i_1))) ->
  ((valid_rd t a_3 1)) ->
  ((valid_rd t a_4 1)) ->
  ((valid_rd t a_7 l_size)) ->
  ((valid_rd t a_9 l_size)) ->
  ((valid_rd t a_10 1)) ->
  ((valid_rw t a_12 l_size)) ->
  ((valid_rw t a_13 1)) ->
  ((is_uint8 a_16)) ->
  ((is_uint8 a_17)) ->
  (if (a_17 = 0) then (i = 0)
   else (((valid_rd t a_5 1)) /\ ((valid_rd t a_15 1)) /\
         (if (a_16 = 0) then (i = 1) else (i = 0)) /\
         ((a_16 = 0) \/ (a_16 = 1)))) ->
  ((a_2 <> a) -> ((separated a_12 l_size a_7 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_12 l_size a_9 l_size))) ->
  ((a_17 = 0) \/ (a_17 = 1)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < l_size) ->
   ((separated a_12 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_3)))]
         0)) l_size))) ->
  (forall i_3 : int. let a_19 = (shift_uint8 a_11 i_3) in (i_1 <= i_3) ->
   (i_3 < l_size) -> ((a_14[a_19] <> 0) <-> (t_2[a_19] <> 0))) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_1) ->
   (((t_2[(shift_uint8 a_6 i_3)] = 0) /\ (t_2[(shift_uint8 a_8 i_3)] <> 0)) <->
    (a_14[(shift_uint8 a_11 i_3)] <> 0))) ->
  ((a_14[a_13 <- if (i = 0) then 0 else 1][a_18] <> 0) <-> (t_2[a_18] <> 0))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,bool_value' (file masks.c, line 186) --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_assert_rte_bool_value
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Assertion 'rte,bool_value' (file masks.c, line 186)":
*)
goal goal6:
  forall i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = t_3[(shiftfield_f1_cpumask_bits a)] in
  let a_4 = (shift_uint8 a_3 0) in
  let a_5 = t_3[(shiftfield_f1_cpumask_bits a_1)] in
  let a_6 = (shift_uint8 a_5 0) in
  let a_7 = t_3[(shiftfield_f1_cpumask_bits a_2)] in
  let a_8 = (shift_uint8 a_7 0) in
  let a_9 = (havoc t_1 t_2 a_8 l_size) in
  let a_10 = a_9[(shift_uint8 a_5 i)] in
  (null <> a_2) ->
  (((to_uint32 i)) <> l_size) ->
  (0 <= i) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_4 l_size)) ->
  ((valid_rd t a_6 l_size)) ->
  ((valid_rw t a_8 l_size)) ->
  ((is_uint8 a_9[(shift_uint8 a_3 i)])) ->
  ((is_uint8 a_10)) ->
  ((a_2 <> a) -> ((separated a_8 l_size a_4 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_8 l_size a_6 l_size))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < l_size) ->
   ((separated a_8 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_1)))]
         0)) l_size))) ->
  (forall i_1 : int. let a_11 = (shift_uint8 a_7 i_1) in (i <= i_1) ->
   (i_1 < l_size) -> ((a_9[a_11] <> 0) <-> (t_2[a_11] <> 0))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
   (((t_2[(shift_uint8 a_3 i_1)] = 0) /\ (t_2[(shift_uint8 a_5 i_1)] <> 0)) <->
    (a_9[(shift_uint8 a_7 i_1)] <> 0))) ->
  ((a_10 = 0) \/ (a_10 = 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file masks.c, line 186) --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_assert_rte_mem_access
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Assertion 'rte,mem_access' (file masks.c, line 186)":
*)
goal goal7:
  forall i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = t_3[(shiftfield_f1_cpumask_bits a)] in
  let a_4 = (shift_uint8 a_3 0) in
  let a_5 = (shiftfield_f1_cpumask_bits a_1) in
  let a_6 = t_3[a_5] in
  let a_7 = (shift_uint8 a_6 0) in
  let a_8 = t_3[(shiftfield_f1_cpumask_bits a_2)] in
  let a_9 = (shift_uint8 a_8 0) in
  let a_10 = (havoc t_1 t_2 a_9 l_size) in
  (null <> a_2) ->
  (((to_uint32 i)) <> l_size) ->
  (0 <= i) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_4 l_size)) ->
  ((valid_rd t a_7 l_size)) ->
  ((valid_rw t a_9 l_size)) ->
  ((a_2 <> a) -> ((separated a_9 l_size a_4 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_9 l_size a_7 l_size))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < l_size) ->
   ((separated a_9 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_1)))]
         0)) l_size))) ->
  (forall i_1 : int. let a_11 = (shift_uint8 a_8 i_1) in (i <= i_1) ->
   (i_1 < l_size) -> ((a_10[a_11] <> 0) <-> (t_2[a_11] <> 0))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
   (((t_2[(shift_uint8 a_3 i_1)] = 0) /\ (t_2[(shift_uint8 a_6 i_1)] <> 0)) <->
    (a_10[(shift_uint8 a_8 i_1)] <> 0))) ->
  ((valid_rd t a_5 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file masks.c, line 186) --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_assert_rte_mem_access_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Assertion 'rte,mem_access' (file masks.c, line 186)":
*)
goal goal8:
  forall i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = t_3[(shiftfield_f1_cpumask_bits a)] in
  let a_4 = (shift_uint8 a_3 0) in
  let a_5 = t_3[(shiftfield_f1_cpumask_bits a_1)] in
  let a_6 = (shift_uint8 a_5 0) in
  let a_7 = t_3[(shiftfield_f1_cpumask_bits a_2)] in
  let a_8 = (shift_uint8 a_7 0) in
  let a_9 = (havoc t_1 t_2 a_8 l_size) in
  (null <> a_2) ->
  (((to_uint32 i)) <> l_size) ->
  (0 <= i) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_4 l_size)) ->
  ((valid_rd t a_6 l_size)) ->
  ((valid_rw t a_8 l_size)) ->
  ((a_2 <> a) -> ((separated a_8 l_size a_4 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_8 l_size a_6 l_size))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < l_size) ->
   ((separated a_8 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_1)))]
         0)) l_size))) ->
  (forall i_1 : int. let a_10 = (shift_uint8 a_7 i_1) in (i <= i_1) ->
   (i_1 < l_size) -> ((a_9[a_10] <> 0) <-> (t_2[a_10] <> 0))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
   (((t_2[(shift_uint8 a_3 i_1)] = 0) /\ (t_2[(shift_uint8 a_5 i_1)] <> 0)) <->
    (a_9[(shift_uint8 a_7 i_1)] <> 0))) ->
  ((valid_rd t ((shift_uint8 a_5 i)) 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,bool_value' (file masks.c, line 186) --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_assert_rte_bool_value_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Assertion 'rte,bool_value' (file masks.c, line 186)":
*)
goal goal9:
  forall i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = t_3[(shiftfield_f1_cpumask_bits a_2)] in
  let a_4 = (shift_uint8 a_3 0) in
  let a_5 = (havoc t_1 t_2 a_4 l_size) in
  let a_6 = (shiftfield_f1_cpumask_bits a_1) in
  let a_7 = t_3[a_6] in
  let a_8 = (shift_uint8 a_7 i) in
  let a_9 = t_3[(shiftfield_f1_cpumask_bits a)] in
  let a_10 = (shift_uint8 a_9 0) in
  let a_11 = (shift_uint8 a_7 0) in
  let a_12 = a_5[(shift_uint8 a_9 i)] in
  (null <> a_2) ->
  (((to_uint32 i)) <> l_size) ->
  (a_5[a_8] = 1) ->
  (0 <= i) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_6 1)) ->
  ((valid_rd t a_10 l_size)) ->
  ((valid_rd t a_11 l_size)) ->
  ((valid_rd t a_8 1)) ->
  ((valid_rw t a_4 l_size)) ->
  ((is_uint8 a_12)) ->
  ((a_2 <> a) -> ((separated a_4 l_size a_10 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_4 l_size a_11 l_size))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < l_size) ->
   ((separated a_4 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_1)))]
         0)) l_size))) ->
  (forall i_1 : int. let a_13 = (shift_uint8 a_3 i_1) in (i <= i_1) ->
   (i_1 < l_size) -> ((a_5[a_13] <> 0) <-> (t_2[a_13] <> 0))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
   (((t_2[(shift_uint8 a_9 i_1)] = 0) /\ (t_2[(shift_uint8 a_7 i_1)] <> 0)) <->
    (a_5[(shift_uint8 a_3 i_1)] <> 0))) ->
  ((a_12 = 0) \/ (a_12 = 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file masks.c, line 186) --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_assert_rte_mem_access_3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Assertion 'rte,mem_access' (file masks.c, line 186)":
*)
goal goal10:
  forall i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = t_3[(shiftfield_f1_cpumask_bits a_2)] in
  let a_4 = (shift_uint8 a_3 0) in
  let a_5 = (havoc t_1 t_2 a_4 l_size) in
  let a_6 = (shiftfield_f1_cpumask_bits a_1) in
  let a_7 = t_3[a_6] in
  let a_8 = (shift_uint8 a_7 i) in
  let a_9 = (shiftfield_f1_cpumask_bits a) in
  let a_10 = t_3[a_9] in
  let a_11 = (shift_uint8 a_10 0) in
  let a_12 = (shift_uint8 a_7 0) in
  (null <> a_2) ->
  (((to_uint32 i)) <> l_size) ->
  (a_5[a_8] = 1) ->
  (0 <= i) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_6 1)) ->
  ((valid_rd t a_11 l_size)) ->
  ((valid_rd t a_12 l_size)) ->
  ((valid_rd t a_8 1)) ->
  ((valid_rw t a_4 l_size)) ->
  ((is_uint8 a_5[(shift_uint8 a_10 i)])) ->
  ((a_2 <> a) -> ((separated a_4 l_size a_11 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_4 l_size a_12 l_size))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < l_size) ->
   ((separated a_4 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_1)))]
         0)) l_size))) ->
  (forall i_1 : int. let a_13 = (shift_uint8 a_3 i_1) in (i <= i_1) ->
   (i_1 < l_size) -> ((a_5[a_13] <> 0) <-> (t_2[a_13] <> 0))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
   (((t_2[(shift_uint8 a_10 i_1)] = 0) /\ (t_2[(shift_uint8 a_7 i_1)] <> 0)) <->
    (a_5[(shift_uint8 a_3 i_1)] <> 0))) ->
  ((valid_rd t a_9 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file masks.c, line 186) --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_assert_rte_mem_access_4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Assertion 'rte,mem_access' (file masks.c, line 186)":
*)
goal goal11:
  forall i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = t_3[(shiftfield_f1_cpumask_bits a_2)] in
  let a_4 = (shift_uint8 a_3 0) in
  let a_5 = (havoc t_1 t_2 a_4 l_size) in
  let a_6 = (shiftfield_f1_cpumask_bits a_1) in
  let a_7 = t_3[a_6] in
  let a_8 = (shift_uint8 a_7 i) in
  let a_9 = t_3[(shiftfield_f1_cpumask_bits a)] in
  let a_10 = (shift_uint8 a_9 0) in
  let a_11 = (shift_uint8 a_7 0) in
  let a_12 = (shift_uint8 a_9 i) in
  (null <> a_2) ->
  (((to_uint32 i)) <> l_size) ->
  (a_5[a_8] = 1) ->
  (0 <= i) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_6 1)) ->
  ((valid_rd t a_10 l_size)) ->
  ((valid_rd t a_11 l_size)) ->
  ((valid_rd t a_8 1)) ->
  ((valid_rw t a_4 l_size)) ->
  ((is_uint8 a_5[a_12])) ->
  ((a_2 <> a) -> ((separated a_4 l_size a_10 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_4 l_size a_11 l_size))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < l_size) ->
   ((separated a_4 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_1)))]
         0)) l_size))) ->
  (forall i_1 : int. let a_13 = (shift_uint8 a_3 i_1) in (i <= i_1) ->
   (i_1 < l_size) -> ((a_5[a_13] <> 0) <-> (t_2[a_13] <> 0))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
   (((t_2[(shift_uint8 a_9 i_1)] = 0) /\ (t_2[(shift_uint8 a_7 i_1)] <> 0)) <->
    (a_5[(shift_uint8 a_3 i_1)] <> 0))) ->
  ((valid_rd t a_12 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file masks.c, line 186) --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_assert_rte_mem_access_5
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Assertion 'rte,mem_access' (file masks.c, line 186)":
*)
goal goal12:
  forall i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = (shiftfield_f1_cpumask_bits a_1) in
  let a_4 = (shiftfield_f1_cpumask_bits a) in
  let a_5 = t_3[a_4] in
  let a_6 = (shift_uint8 a_5 0) in
  let a_7 = t_3[a_3] in
  let a_8 = (shift_uint8 a_7 0) in
  let a_9 = (shift_uint8 a_7 i) in
  let a_10 = t_3[(shiftfield_f1_cpumask_bits a_2)] in
  let a_11 = (shift_uint8 a_10 0) in
  let a_12 = (havoc t_1 t_2 a_11 l_size) in
  let a_13 = (shift_uint8 a_5 i) in
  let a_14 = a_12[a_13] in
  let a_15 = a_12[a_9] in
  (null <> a_2) ->
  (((to_uint32 i)) <> l_size) ->
  (0 <= i) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_3 1)) ->
  ((valid_rd t a_6 l_size)) ->
  ((valid_rd t a_8 l_size)) ->
  ((valid_rd t a_9 1)) ->
  ((valid_rw t a_11 l_size)) ->
  ((is_uint8 a_14)) ->
  ((is_uint8 a_15)) ->
  ((a_2 <> a) -> ((separated a_11 l_size a_6 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_11 l_size a_8 l_size))) ->
  ((a_15 = 0) \/ (a_15 = 1)) ->
  ((a_15 = 0) \/
   (((valid_rd t a_4 1)) /\ ((valid_rd t a_13 1)) /\
    ((a_14 = 0) \/ (a_14 = 1)))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < l_size) ->
   ((separated a_11 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_1)))]
         0)) l_size))) ->
  (forall i_1 : int. let a_16 = (shift_uint8 a_10 i_1) in (i <= i_1) ->
   (i_1 < l_size) -> ((a_12[a_16] <> 0) <-> (t_2[a_16] <> 0))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
   (((t_2[(shift_uint8 a_5 i_1)] = 0) /\ (t_2[(shift_uint8 a_7 i_1)] <> 0)) <->
    (a_12[(shift_uint8 a_10 i_1)] <> 0))) ->
  ((valid_rw t ((shift_uint8 a_10 i)) 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,mem_access' (file masks.c, line 186) --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_assert_rte_mem_access_6
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Assertion 'rte,mem_access' (file masks.c, line 186)":
*)
goal goal13:
  forall i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = (shiftfield_f1_cpumask_bits a_1) in
  let a_4 = (shiftfield_f1_cpumask_bits a) in
  let a_5 = t_3[a_4] in
  let a_6 = (shift_uint8 a_5 0) in
  let a_7 = t_3[a_3] in
  let a_8 = (shift_uint8 a_7 0) in
  let a_9 = (shift_uint8 a_7 i) in
  let a_10 = (shiftfield_f1_cpumask_bits a_2) in
  let a_11 = t_3[a_10] in
  let a_12 = (shift_uint8 a_11 0) in
  let a_13 = (havoc t_1 t_2 a_12 l_size) in
  let a_14 = (shift_uint8 a_5 i) in
  let a_15 = a_13[a_14] in
  let a_16 = a_13[a_9] in
  (null <> a_2) ->
  (((to_uint32 i)) <> l_size) ->
  (0 <= i) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_3 1)) ->
  ((valid_rd t a_6 l_size)) ->
  ((valid_rd t a_8 l_size)) ->
  ((valid_rd t a_9 1)) ->
  ((valid_rw t a_12 l_size)) ->
  ((is_uint8 a_15)) ->
  ((is_uint8 a_16)) ->
  ((a_2 <> a) -> ((separated a_12 l_size a_6 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_12 l_size a_8 l_size))) ->
  ((a_16 = 0) \/ (a_16 = 1)) ->
  ((a_16 = 0) \/
   (((valid_rd t a_4 1)) /\ ((valid_rd t a_14 1)) /\
    ((a_15 = 0) \/ (a_15 = 1)))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < l_size) ->
   ((separated a_12 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_1)))]
         0)) l_size))) ->
  (forall i_1 : int. let a_17 = (shift_uint8 a_11 i_1) in (i <= i_1) ->
   (i_1 < l_size) -> ((a_13[a_17] <> 0) <-> (t_2[a_17] <> 0))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
   (((t_2[(shift_uint8 a_5 i_1)] = 0) /\ (t_2[(shift_uint8 a_7 i_1)] <> 0)) <->
    (a_13[(shift_uint8 a_11 i_1)] <> 0))) ->
  ((valid_rd t a_10 1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,signed_overflow' (file masks.c, line 185) --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_assert_rte_signed_overflow
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Assertion 'rte,signed_overflow' (file masks.c, line 185)":
*)
goal goal14:
  forall i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = (shiftfield_f1_cpumask_bits a_1) in
  let a_4 = (shiftfield_f1_cpumask_bits a_2) in
  let a_5 = (shiftfield_f1_cpumask_bits a) in
  let a_6 = t_3[a_5] in
  let a_7 = (shift_uint8 a_6 0) in
  let a_8 = t_3[a_3] in
  let a_9 = (shift_uint8 a_8 0) in
  let a_10 = (shift_uint8 a_8 i) in
  let a_11 = t_3[a_4] in
  let a_12 = (shift_uint8 a_11 0) in
  let a_13 = (havoc t_1 t_2 a_12 l_size) in
  let a_14 = (shift_uint8 a_6 i) in
  let a_15 = a_13[a_14] in
  let a_16 = a_13[a_10] in
  (null <> a_2) ->
  (((to_uint32 i)) <> l_size) ->
  (0 <= i) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_3 1)) ->
  ((valid_rd t a_4 1)) ->
  ((valid_rd t a_7 l_size)) ->
  ((valid_rd t a_9 l_size)) ->
  ((valid_rd t a_10 1)) ->
  ((valid_rw t a_12 l_size)) ->
  ((valid_rw t ((shift_uint8 a_11 i)) 1)) ->
  ((is_uint8 a_15)) ->
  ((is_uint8 a_16)) ->
  ((a_2 <> a) -> ((separated a_12 l_size a_7 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_12 l_size a_9 l_size))) ->
  ((a_16 = 0) \/ (a_16 = 1)) ->
  ((a_16 = 0) \/
   (((valid_rd t a_5 1)) /\ ((valid_rd t a_14 1)) /\
    ((a_15 = 0) \/ (a_15 = 1)))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < l_size) ->
   ((separated a_12 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_1)))]
         0)) l_size))) ->
  (forall i_1 : int. let a_17 = (shift_uint8 a_11 i_1) in (i <= i_1) ->
   (i_1 < l_size) -> ((a_13[a_17] <> 0) <-> (t_2[a_17] <> 0))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
   (((t_2[(shift_uint8 a_6 i_1)] = 0) /\ (t_2[(shift_uint8 a_8 i_1)] <> 0)) <->
    (a_13[(shift_uint8 a_11 i_1)] <> 0))) ->
  (i <= 2147483646)

end

(* ---------------------------------------------------------- *)
(* --- Loop assigns (file masks.c, line 181) (6/6)        --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_loop_assign_part6
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Loop assigns (file masks.c, line 181) (6/6)":
*)
goal goal15:
  forall i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = (shiftfield_f1_cpumask_bits a_1) in
  let a_4 = (shiftfield_f1_cpumask_bits a_2) in
  let a_5 = (shiftfield_f1_cpumask_bits a) in
  let a_6 = t_3[a_5] in
  let a_7 = (shift_uint8 a_6 0) in
  let a_8 = t_3[a_3] in
  let a_9 = (shift_uint8 a_8 0) in
  let a_10 = (shift_uint8 a_8 i) in
  let a_11 = t_3[a_4] in
  let a_12 = (shift_uint8 a_11 0) in
  let a_13 = (shift_uint8 a_11 i) in
  let a_14 = (havoc t_1 t_2 a_12 l_size) in
  let a_15 = (shift_uint8 a_6 i) in
  let a_16 = a_14[a_15] in
  let a_17 = a_14[a_10] in
  (null <> a_2) ->
  (((to_uint32 i)) <> l_size) ->
  (0 <= i) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  (i <= 2147483646) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_3 1)) ->
  ((valid_rd t a_4 1)) ->
  ((valid_rd t a_7 l_size)) ->
  ((valid_rd t a_9 l_size)) ->
  ((valid_rd t a_10 1)) ->
  ((valid_rw t a_12 l_size)) ->
  ((valid_rw t a_13 1)) ->
  (not (invalid t a_13 1)) ->
  ((is_uint8 a_16)) ->
  ((is_uint8 a_17)) ->
  ((a_2 <> a) -> ((separated a_12 l_size a_7 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_12 l_size a_9 l_size))) ->
  ((a_17 = 0) \/ (a_17 = 1)) ->
  ((a_17 = 0) \/
   (((valid_rd t a_5 1)) /\ ((valid_rd t a_15 1)) /\
    ((a_16 = 0) \/ (a_16 = 1)))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < l_size) ->
   ((separated a_12 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_1)))]
         0)) l_size))) ->
  (forall i_1 : int. let a_18 = (shift_uint8 a_11 i_1) in (i <= i_1) ->
   (i_1 < l_size) -> ((a_14[a_18] <> 0) <-> (t_2[a_18] <> 0))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
   (((t_2[(shift_uint8 a_6 i_1)] = 0) /\ (t_2[(shift_uint8 a_8 i_1)] <> 0)) <->
    (a_14[(shift_uint8 a_11 i_1)] <> 0))) ->
  ((included a_13 1 a_12 l_size))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'nonempty_dst1' (file masks.c, line 166) in 'cpumask_andnot' --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_nonempty_dst1_post
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Post-condition for 'nonempty_dst1' (file masks.c, line 166) in 'cpumask_andnot'":
*)
goal goal16:
  forall i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = t_3[(shiftfield_f1_cpumask_bits a)] in
  let a_4 = (shift_uint8 a_3 0) in
  let a_5 = t_3[(shiftfield_f1_cpumask_bits a_1)] in
  let a_6 = (shift_uint8 a_5 0) in
  let a_7 = t_3[(shiftfield_f1_cpumask_bits a_2)] in
  let a_8 = (shift_uint8 a_7 0) in
  let a_9 = (havoc t_1 t_2 a_8 l_size) in
  (null <> a_2) ->
  (((to_uint32 i)) = l_size) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i_1 < l_size) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_4 l_size)) ->
  ((valid_rd t a_6 l_size)) ->
  ((valid_rw t a_8 l_size)) ->
  ((a_2 <> a) -> ((separated a_8 l_size a_4 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_8 l_size a_6 l_size))) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < l_size) ->
   ((separated a_8 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_2)))]
         0)) l_size))) ->
  (forall i_2 : int. let a_10 = (shift_uint8 a_7 i_2) in (i <= i_2) ->
   (i_2 < l_size) -> ((a_9[a_10] <> 0) <-> (t_2[a_10] <> 0))) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (((t_2[(shift_uint8 a_3 i_2)] = 0) /\ (t_2[(shift_uint8 a_5 i_2)] <> 0)) <->
    (a_9[(shift_uint8 a_7 i_2)] <> 0))) ->
  (((t_2[(shift_uint8 a_3 i_1)] = 0) /\ (t_2[(shift_uint8 a_5 i_1)] <> 0)) <->
   (a_9[(shift_uint8 a_7 i_1)] <> 0))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'nonempty_dst1' (file masks.c, line 167) in 'cpumask_andnot' --- *)
(* ---------------------------------------------------------- *)
theory VCcpumask_andnot_nonempty_dst1_post_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import A_thread_variables_properties.A_thread_variables_properties
use import Compound.Compound
use import A_schedule_cpumask.A_schedule_cpumask

(*
goal WP "expl:Post-condition for 'nonempty_dst1' (file masks.c, line 167) in 'cpumask_andnot'":
*)
goal goal17:
  forall i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall t_3 : map addr addr.
  forall a_2 a_1 a : addr.
  let a_3 = t_3[(shiftfield_f1_cpumask_bits a_2)] in
  let a_4 = (shift_uint8 a_3 0) in
  let a_5 = (havoc t_1 t_2 a_4 l_size) in
  let a_6 = t_3[(shiftfield_f1_cpumask_bits a)] in
  let a_7 = (shift_uint8 a_6 0) in
  let a_8 = t_3[(shiftfield_f1_cpumask_bits a_1)] in
  let a_9 = (shift_uint8 a_8 0) in
  (null <> a_2) ->
  (((to_uint32 i)) = l_size) ->
  (a_5[(shift_uint8 a_3 i_1)] <> 0) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i_1 < l_size) ->
  (i <= l_size) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (((region (a_2.base))) <= 0) ->
  ((framed t_3)) ->
  ((linked t)) ->
  ((is_sint32 i)) ->
  ((valid_rd t a 1)) ->
  ((valid_rd t a_1 1)) ->
  ((valid_rd t a_2 1)) ->
  ((valid_rd t a_7 l_size)) ->
  ((valid_rd t a_9 l_size)) ->
  ((valid_rw t a_4 l_size)) ->
  ((a_2 <> a) -> ((separated a_4 l_size a_7 l_size))) ->
  ((a_2 <> a_1) -> ((separated a_4 l_size a_9 l_size))) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < l_size) ->
   ((separated a_4 l_size
      ((shift_uint8 t_3[(shiftfield_f1_cpumask_bits ((l_cpu_smt_mask i_2)))]
         0)) l_size))) ->
  (forall i_2 : int. let a_10 = (shift_uint8 a_3 i_2) in (i <= i_2) ->
   (i_2 < l_size) -> ((a_5[a_10] <> 0) <-> (t_2[a_10] <> 0))) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (((t_2[(shift_uint8 a_6 i_2)] = 0) /\ (t_2[(shift_uint8 a_8 i_2)] <> 0)) <->
    (a_5[(shift_uint8 a_3 i_2)] <> 0))) ->
  (t_2[(shift_uint8 a_8 i_1)] <> 0)

end

