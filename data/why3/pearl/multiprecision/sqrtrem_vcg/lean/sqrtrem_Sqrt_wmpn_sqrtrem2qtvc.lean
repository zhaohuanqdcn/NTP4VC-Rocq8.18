import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.real.Truncate
import Why3.mach.c.C
import Why3.mach.int.Unsigned
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub_1.Sub_1
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.sqrt.Sqrt1
import Why3.mach.fxp.Fxp
open Classical
open Lean4Why3
namespace sqrtrem_Sqrt_wmpn_sqrtrem2qtvc
theorem wmpn_sqrtrem2'vc (rp : C.ptr (BitVec 64)) (sp : C.ptr (BitVec 64)) (np : C.ptr (BitVec 64)) (fact0 : C.valid rp (1 : ℤ)) (fact1 : C.valid sp (1 : ℤ)) (fact2 : C.valid np (2 : ℤ)) (fact3 : HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (2 : ℤ))) ≤ BitVec.toUInt (C.pelts np (C.offset np + (1 : ℤ)))) (fact4 : C.writable sp = true) (fact5 : C.writable rp = true) : C.min np ≤ C.offset np ∧ C.offset np < C.max np ∧ (let np0 : BitVec 64 := C.pelts np (C.offset np); (C.min np ≤ C.offset np + (1 : ℤ) ∧ C.offset np + (1 : ℤ) < C.max np) ∧ (C.min np ≤ C.offset np + (1 : ℤ) ∧ C.offset np + (1 : ℤ) < C.max np) ∧ (let o1 : BitVec 64 := C.pelts np (C.offset np + (1 : ℤ)); (C.valid rp (1 : ℤ) ∧ (4611686018427387904 : ℤ) ≤ BitVec.toUInt o1 ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(o2 : BitVec 64), (BitVec.toUInt o2 * BitVec.toUInt o2 ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 < (BitVec.toUInt o2 + (1 : ℤ)) * (BitVec.toUInt o2 + (1 : ℤ))) ∧ BitVec.toUInt o2 * BitVec.toUInt o2 + BitVec.toUInt (C.pelts rp1 (C.offset rp1)) = BitVec.toUInt o1 ∧ BitVec.toUInt (C.pelts rp1 (C.offset rp1)) ≤ (2 : ℤ) * BitVec.toUInt o2 → (C.min rp1 ≤ C.offset rp1 ∧ C.offset rp1 < C.max rp1) ∧ (let o3 : BitVec 64 := C.pelts rp1 (C.offset rp1); uint'64_in_bounds (64 : ℤ) ∧ (∀(o4 : BitVec 64), BitVec.toUInt o4 = (64 : ℤ) → (¬(2 : ℤ) = (0 : ℤ) ∧ uint'64_in_bounds (Int.tdiv (BitVec.toUInt o4) (2 : ℤ))) ∧ (∀(prec : BitVec 64), BitVec.toUInt prec = Int.tdiv (BitVec.toUInt o4) (2 : ℤ) → uint'64_in_bounds (BitVec.toUInt prec + (1 : ℤ)) ∧ (∀(o5 : BitVec 64), BitVec.toUInt o5 = BitVec.toUInt prec + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt o5 ∧ BitVec.toUInt o5 < (64 : ℤ)) ∧ (∀(nph : BitVec 64), BitVec.toUInt nph = BitVec.toUInt np0 / HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o5)) → uint'64_in_bounds (BitVec.toUInt prec - (1 : ℤ)) ∧ (∀(o6 : BitVec 64), BitVec.toUInt o6 = BitVec.toUInt prec - (1 : ℤ) → (((0 : ℤ) ≤ BitVec.toUInt o6 ∧ BitVec.toUInt o6 < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o6)) * BitVec.toUInt o3 ≤ (18446744073709551615 : ℤ)) ∧ (∀(o7 : BitVec 64), BitVec.toUInt o7 = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o6)) * BitVec.toUInt o3 → uint'64_in_bounds (BitVec.toUInt o7 + BitVec.toUInt nph) ∧ (∀(o8 : BitVec 64), BitVec.toUInt o8 = BitVec.toUInt o7 + BitVec.toUInt nph → (¬BitVec.toUInt o2 = (0 : ℤ) ∧ uint'64_in_bounds (Int.tdiv (BitVec.toUInt o8) (BitVec.toUInt o2))) ∧ (∀(o9 : BitVec 64), BitVec.toUInt o9 = Int.tdiv (BitVec.toUInt o8) (BitVec.toUInt o2) → (((0 : ℤ) ≤ BitVec.toUInt prec ∧ BitVec.toUInt prec < (64 : ℤ)) ∧ (∀(rq : BitVec 64), BitVec.toUInt rq = BitVec.toUInt o9 / HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt prec)) → uint'64_in_bounds (BitVec.toUInt o9 - BitVec.toUInt rq) ∧ (∀(o10 : BitVec 64), BitVec.toUInt o10 = BitVec.toUInt o9 - BitVec.toUInt rq → (if BitVec.toUInt o9 = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt prec)) then BitVec.toUInt o10 = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt prec)) - (1 : ℤ) else o10 = o9) ∧ BitVec.toUInt o10 < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt prec))))) ∧ (∀(q : BitVec 64), (if BitVec.toUInt o9 = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt prec)) then BitVec.toUInt q = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt prec)) - (1 : ℤ) else q = o9) ∧ BitVec.toUInt q < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt prec)) → uint'64_in_bounds (BitVec.toUInt q * BitVec.toUInt o2) ∧ (∀(o10 : BitVec 64), BitVec.toUInt o10 = BitVec.toUInt q * BitVec.toUInt o2 → uint'64_in_bounds (BitVec.toUInt o8 - BitVec.toUInt o10) ∧ (∀(u : BitVec 64), BitVec.toUInt u = BitVec.toUInt o8 - BitVec.toUInt o10 → (((0 : ℤ) ≤ BitVec.toUInt prec ∧ BitVec.toUInt prec < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt prec)) * BitVec.toUInt o2 ≤ (18446744073709551615 : ℤ)) ∧ (∀(o11 : BitVec 64), BitVec.toUInt o11 = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt prec)) * BitVec.toUInt o2 → uint'64_in_bounds (BitVec.toUInt o11 + BitVec.toUInt q) ∧ (∀(o12 : BitVec 64), BitVec.toUInt o12 = BitVec.toUInt o11 + BitVec.toUInt q → uint'64_in_bounds (BitVec.toUInt prec - (1 : ℤ)) ∧ (∀(o13 : BitVec 64), BitVec.toUInt o13 = BitVec.toUInt prec - (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt o13 ∧ BitVec.toUInt o13 < (64 : ℤ)) ∧ (∀(uh : BitVec 64), BitVec.toUInt uh = BitVec.toUInt u / HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o13)) → BitVec.toUInt uh ≤ (9223372036854775807 : ℤ) ∧ (∀(o14 : BitVec 64), BitVec.toInt o14 = BitVec.toUInt uh → uint'64_in_bounds (BitVec.toUInt prec + (1 : ℤ)) ∧ (∀(o15 : BitVec 64), BitVec.toUInt o15 = BitVec.toUInt prec + (1 : ℤ) → (((0 : ℤ) ≤ BitVec.toUInt o15 ∧ BitVec.toUInt o15 < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o15)) * BitVec.toUInt (1 : BitVec 64) ≤ (18446744073709551615 : ℤ)) ∧ (∀(o16 : BitVec 64), BitVec.toUInt o16 = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o15)) * BitVec.toUInt (1 : BitVec 64) → (¬BitVec.toUInt o16 = (0 : ℤ) ∧ uint'64_in_bounds (Int.tmod (BitVec.toUInt np0) (BitVec.toUInt o16))) ∧ (∀(npl : BitVec 64), BitVec.toUInt npl = Int.tmod (BitVec.toUInt np0) (BitVec.toUInt o16) → uint'64_in_bounds (BitVec.toUInt prec + (1 : ℤ)) ∧ (∀(o17 : BitVec 64), BitVec.toUInt o17 = BitVec.toUInt prec + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt o17 ∧ BitVec.toUInt o17 < (64 : ℤ)) ∧ (∀(ul : BitVec 64), BitVec.toUInt ul = BitVec.toUInt u * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o17)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) ∧ BitVec.toUInt ul ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o17)) → uint'64_in_bounds (BitVec.toUInt ul + BitVec.toUInt npl) ∧ (∀(o18 : BitVec 64), BitVec.toUInt o18 = BitVec.toUInt ul + BitVec.toUInt npl → uint'64_in_bounds (BitVec.toUInt q * BitVec.toUInt q) ∧ (∀(q2 : BitVec 64), BitVec.toUInt q2 = BitVec.toUInt q * BitVec.toUInt q → (if BitVec.toUInt o18 < BitVec.toUInt q2 then int'64_in_bounds (BitVec.toInt o14 - (1 : ℤ)) ∧ (∀(o19 : BitVec 64), BitVec.toInt o19 = BitVec.toInt o14 - (1 : ℤ) → (∀(o20 : BitVec 64), BitVec.toUInt o20 = (BitVec.toUInt o18 - BitVec.toUInt q2) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → BitVec.toUInt o20 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt o19 = BitVec.toUInt o18 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt o14 - BitVec.toUInt q2)) else ∀(o19 : BitVec 64), BitVec.toUInt o19 = (BitVec.toUInt o18 - BitVec.toUInt q2) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → BitVec.toUInt o19 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt o14 = BitVec.toUInt o18 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt o14 - BitVec.toUInt q2) ∧ (∀(cc : BitVec 64) (rp0 : BitVec 64), BitVec.toUInt rp0 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt cc = BitVec.toUInt o18 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt o14 - BitVec.toUInt q2 → (if BitVec.toInt cc < (0 : ℤ) then (∀(o19 : BitVec 64), BitVec.toUInt o19 = (BitVec.toUInt rp0 + BitVec.toUInt o12) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (if BitVec.toUInt o19 < BitVec.toUInt o12 then int'64_in_bounds (BitVec.toInt cc + (1 : ℤ)) ∧ (∀(o20 : BitVec 64), BitVec.toInt o20 = BitVec.toInt cc + (1 : ℤ) → BitVec.toUInt o19 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt o20 = BitVec.toUInt rp0 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt cc + BitVec.toUInt o12 ∧ ((0 : ℤ) ≤ BitVec.toInt o20 ∨ BitVec.toUInt o19 = BitVec.toUInt rp0 + BitVec.toUInt o12)) else BitVec.toUInt o19 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt cc = BitVec.toUInt rp0 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt cc + BitVec.toUInt o12 ∧ ((0 : ℤ) ≤ BitVec.toInt cc ∨ BitVec.toUInt o19 = BitVec.toUInt rp0 + BitVec.toUInt o12))) ∧ (∀(cc1 : BitVec 64) (rp01 : BitVec 64), BitVec.toUInt rp01 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt cc1 = BitVec.toUInt rp0 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt cc + BitVec.toUInt o12 ∧ ((0 : ℤ) ≤ BitVec.toInt cc1 ∨ BitVec.toUInt rp01 = BitVec.toUInt rp0 + BitVec.toUInt o12) → uint'64_in_bounds (BitVec.toUInt o12 - (1 : ℤ)) ∧ (∀(o19 : BitVec 64), BitVec.toUInt o19 = BitVec.toUInt o12 - (1 : ℤ) → (∀(o20 : BitVec 64), BitVec.toUInt o20 = (BitVec.toUInt rp01 + BitVec.toUInt o19) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (if BitVec.toUInt o20 < BitVec.toUInt o19 then int'64_in_bounds (BitVec.toInt cc1 + (1 : ℤ)) ∧ (∀(o21 : BitVec 64), BitVec.toInt o21 = BitVec.toInt cc1 + (1 : ℤ) → BitVec.toUInt o20 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt o21 = BitVec.toUInt rp01 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt cc1 + BitVec.toUInt o19 ∧ (0 : ℤ) ≤ BitVec.toInt o21) else BitVec.toUInt o20 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt cc1 = BitVec.toUInt rp01 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt cc1 + BitVec.toUInt o19 ∧ (0 : ℤ) ≤ BitVec.toInt cc1)) ∧ (∀(cc2 : BitVec 64) (rp02 : BitVec 64), BitVec.toUInt rp02 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt cc2 = BitVec.toUInt rp01 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toInt cc1 + BitVec.toUInt o19 ∧ (0 : ℤ) ≤ BitVec.toInt cc2 → ((C.min rp1 ≤ C.offset rp1 ∧ C.offset rp1 < C.max rp1) ∧ C.writable rp1 = true) ∧ (∀(rp2 : C.ptr (BitVec 64)), List.length (C.data rp2) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → C.pelts rp2 = Function.update (C.pelts rp1) (C.offset rp2) rp02 → ((C.min sp ≤ C.offset sp ∧ C.offset sp < C.max sp) ∧ C.writable sp = true) ∧ (∀(sp1 : C.ptr (BitVec 64)), List.length (C.data sp1) = List.length (C.data sp) ∧ C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.max sp1 = C.max sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → C.pelts sp1 = Function.update (C.pelts sp) (C.offset sp1) o19 → (0 : ℤ) ≤ BitVec.toInt cc2 ∧ (∀(result : BitVec 64), BitVec.toUInt result = BitVec.toInt cc2 → Lemmas.value np (2 : ℤ) = BitVec.toUInt (C.pelts sp1 (C.offset sp1)) * BitVec.toUInt (C.pelts sp1 (C.offset sp1)) + BitVec.toUInt result * ((18446744073709551615 : ℤ) + (1 : ℤ)) + BitVec.toUInt (C.pelts rp2 (C.offset rp2)) ∧ BitVec.toUInt (C.pelts rp2 (C.offset rp2)) + BitVec.toUInt result * ((18446744073709551615 : ℤ) + (1 : ℤ)) ≤ (2 : ℤ) * BitVec.toUInt (C.pelts sp1 (C.offset sp1)) ∧ (0 : ℤ) ≤ BitVec.toUInt result ∧ BitVec.toUInt result ≤ (1 : ℤ))))))) else ((C.min rp1 ≤ C.offset rp1 ∧ C.offset rp1 < C.max rp1) ∧ C.writable rp1 = true) ∧ (∀(rp2 : C.ptr (BitVec 64)), List.length (C.data rp2) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → C.pelts rp2 = Function.update (C.pelts rp1) (C.offset rp2) rp0 → ((C.min sp ≤ C.offset sp ∧ C.offset sp < C.max sp) ∧ C.writable sp = true) ∧ (∀(sp1 : C.ptr (BitVec 64)), List.length (C.data sp1) = List.length (C.data sp) ∧ C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.max sp1 = C.max sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → C.pelts sp1 = Function.update (C.pelts sp) (C.offset sp1) o12 → (0 : ℤ) ≤ BitVec.toInt cc ∧ (∀(result : BitVec 64), BitVec.toUInt result = BitVec.toInt cc → Lemmas.value np (2 : ℤ) = BitVec.toUInt (C.pelts sp1 (C.offset sp1)) * BitVec.toUInt (C.pelts sp1 (C.offset sp1)) + BitVec.toUInt result * ((18446744073709551615 : ℤ) + (1 : ℤ)) + BitVec.toUInt (C.pelts rp2 (C.offset rp2)) ∧ BitVec.toUInt (C.pelts rp2 (C.offset rp2)) + BitVec.toUInt result * ((18446744073709551615 : ℤ) + (1 : ℤ)) ≤ (2 : ℤ) * BitVec.toUInt (C.pelts sp1 (C.offset sp1)) ∧ (0 : ℤ) ≤ BitVec.toUInt result ∧ BitVec.toUInt result ≤ (1 : ℤ))))))))))))))))))))))))))))))))))
  := sorry
end sqrtrem_Sqrt_wmpn_sqrtrem2qtvc
