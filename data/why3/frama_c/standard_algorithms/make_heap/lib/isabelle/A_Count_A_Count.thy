theory A_Count_A_Count
  imports "NTP4Verif.NTP4Verif" "Why3STD.Qed_Qed" "Why3STD.Memory_Memory" "Why3STD.Cint_Cint" "../../lib/isabelle/Compound_Compound" "../../lib/isabelle/Axiomatic_Axiomatic"
begin
consts l_count_1' :: "(addr \<Rightarrow> int) \<Rightarrow> addr \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int"
axiomatization where Q_CountSectionEmpty:   "l_count_1' mint_0 a m n v = (0 :: int)"
 if "n \<le> m"
 and "is_sint32 v"
  for n :: "int"
  and m :: "int"
  and v :: "int"
  and mint_0 :: "addr \<Rightarrow> int"
  and a :: "addr"
axiomatization where Q_CountSectionHit:   "mint_0 (shift a (n - (1 :: int))) = v \<longrightarrow> m < n \<longrightarrow> is_sint32 v \<longrightarrow> (1 :: int) + l_count_1' mint_0 a m (n - (1 :: int)) v = l_count_1' mint_0 a m n v"
  for n :: "int"
  and mint_0 :: "addr \<Rightarrow> int"
  and a :: "addr"
  and v :: "int"
  and m :: "int"
axiomatization where Q_CountSectionMiss:   "\<not>mint_0 (shift a (n - (1 :: int))) = v \<longrightarrow> m < n \<longrightarrow> is_sint32 v \<longrightarrow> l_count_1' mint_0 a m (n - (1 :: int)) v = l_count_1' mint_0 a m n v"
  for n :: "int"
  and mint_0 :: "addr \<Rightarrow> int"
  and a :: "addr"
  and v :: "int"
  and m :: "int"
axiomatization where Q_CountSectionRead:   "l_count_1' mint_1 a m n v = l_count_1' mint_0 a m n v"
 if "is_sint32 v"
 and "p_unchanged_1' mint_0 mint_1 a m n"
  for v :: "int"
  and mint_0 :: "addr \<Rightarrow> int"
  and mint_1 :: "addr \<Rightarrow> int"
  and a :: "addr"
  and m :: "int"
  and n :: "int"
end
