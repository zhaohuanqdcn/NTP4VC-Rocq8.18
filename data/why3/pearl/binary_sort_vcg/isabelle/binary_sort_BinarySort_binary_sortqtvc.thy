theory binary_sort_BinarySort_binary_sortqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut"
begin
theorem binary_sort'vc:
  fixes a :: "int list"
  shows "let o1 :: int = int (length a) - (1 :: int) in ((1 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> j \<and> j < (1 :: int) \<longrightarrow> a ! nat i \<le> a ! nat j) \<and> permut_sub' a a (0 :: nat) (length a)) \<and> (\<forall>(a1 :: int list). length a1 = length a \<longrightarrow> (\<forall>(k :: int). ((1 :: int) \<le> k \<and> k \<le> o1) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> j \<and> j < k \<longrightarrow> a1 ! nat i \<le> a1 ! nat j) \<and> permut_sub' a a1 (0 :: nat) (length a1) \<longrightarrow> ((0 :: int) \<le> k \<and> k < int (length a1)) \<and> (let v :: int = a1 ! nat k in (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> k \<and> k \<le> k) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (0 :: int) \<longrightarrow> a1 ! nat i \<le> v) \<and> (\<forall>(i :: int). k \<le> i \<and> i < k \<longrightarrow> v < a1 ! nat i)) \<and> (\<forall>(right1 :: int) (left1 :: int). ((0 :: int) \<le> left1 \<and> left1 \<le> right1 \<and> right1 \<le> k) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < left1 \<longrightarrow> a1 ! nat i \<le> v) \<and> (\<forall>(i :: int). right1 \<le> i \<and> i < k \<longrightarrow> v < a1 ! nat i) \<longrightarrow> (if left1 < right1 then \<not>(2 :: int) = (0 :: int) \<and> (let mid :: int = left1 + (right1 - left1) cdiv (2 :: int) in ((0 :: int) \<le> mid \<and> mid < int (length a1)) \<and> (if v < a1 ! nat mid then ((0 :: int) \<le> right1 - left1 \<and> mid - left1 < right1 - left1) \<and> ((0 :: int) \<le> left1 \<and> left1 \<le> mid \<and> mid \<le> k) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < left1 \<longrightarrow> a1 ! nat i \<le> v) \<and> (\<forall>(i :: int). mid \<le> i \<and> i < k \<longrightarrow> v < a1 ! nat i) else ((0 :: int) \<le> right1 - left1 \<and> right1 - (mid + (1 :: int)) < right1 - left1) \<and> ((0 :: int) \<le> mid + (1 :: int) \<and> mid + (1 :: int) \<le> right1 \<and> right1 \<le> k) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < mid + (1 :: int) \<longrightarrow> a1 ! nat i \<le> v) \<and> (\<forall>(i :: int). right1 \<le> i \<and> i < k \<longrightarrow> v < a1 ! nat i))) else let o2 :: int = k - left1; o3 :: int = left1 + (1 :: int) in (((0 :: int) \<le> left1 \<and> (0 :: int) \<le> o2 \<and> left1 + o2 \<le> int (length a1)) \<and> (0 :: int) \<le> o3 \<and> o3 + o2 \<le> int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < o3 \<or> o3 + o2 \<le> i \<and> i < int (length a2) \<longrightarrow> a2 ! nat i = a1 ! nat i) \<and> (\<forall>(i :: int). o3 \<le> i \<and> i < o3 + o2 \<longrightarrow> a2 ! nat i = a1 ! nat (left1 + i - o3)) \<longrightarrow> ((0 :: int) \<le> left1 \<and> left1 < int (length a2)) \<and> (length (a2[nat left1 := v]) = length a2 \<longrightarrow> nth (a2[nat left1 := v]) o nat = (nth a2 o nat)(left1 := v) \<longrightarrow> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> j \<and> j < k + (1 :: int) \<longrightarrow> a2[nat left1 := v] ! nat i \<le> a2[nat left1 := v] ! nat j) \<and> permut_sub' a (a2[nat left1 := v]) (0 :: nat) (length (a2[nat left1 := v])))))))) \<and> ((\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> j \<and> j < o1 + (1 :: int) \<longrightarrow> a1 ! nat i \<le> a1 ! nat j) \<and> permut_sub' a a1 (0 :: nat) (length a1) \<longrightarrow> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> j \<and> j < int (length a1) \<longrightarrow> a1 ! nat i \<le> a1 ! nat j) \<and> permut_sub' a a1 (0 :: nat) (length a1)))) \<and> (o1 + (1 :: int) < (1 :: int) \<longrightarrow> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> j \<and> j < int (length a) \<longrightarrow> a ! nat i \<le> a ! nat j) \<and> permut_sub' a a (0 :: nat) (length a))"
  sorry
end
