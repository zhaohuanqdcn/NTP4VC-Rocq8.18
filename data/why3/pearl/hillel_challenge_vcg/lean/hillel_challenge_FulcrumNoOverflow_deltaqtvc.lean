import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Sum
open Classical
open Lean4Why3
namespace hillel_challenge_FulcrumNoOverflow_deltaqtvc
axiom big : Type
axiom inhabited_axiom_big : Inhabited big
attribute [instance] inhabited_axiom_big
axiom q : big -> BitVec 32
axiom r : big -> BitVec 32
axiom v : big -> ℤ
axiom big'invariant (self : big) : -((2147483647 : ℤ) + (1 : ℤ)) ≤ BitVec.toInt (q self) ∧ BitVec.toInt (q self) ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt (r self) ∧ BitVec.toInt (r self) ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ) ∧ v self = BitVec.toInt (q self) * ((2147483647 : ℤ) + (1 : ℤ)) + BitVec.toInt (r self)
noncomputable def big'eq (a : big) (b : big) := q a = q b ∧ r a = r b ∧ v a = v b
axiom big'inj (a : big) (b : big) (fact0 : big'eq a b) : a = b
axiom big_zero : Unit -> big
axiom big_zero'def (x : Unit) : q (big_zero x) = (0 : BitVec 32) ∧ r (big_zero x) = (0 : BitVec 32) ∧ v (big_zero x) = (0 : ℤ)
theorem delta'vc (x : big) (y : big) (fact0 : -((2147483647 : ℤ) + (1 : ℤ)) * ((2147483647 : ℤ) + (1 : ℤ)) ≤ abs (v x - v y)) (fact1 : abs (v x - v y) ≤ ((2147483647 : ℤ) + (1 : ℤ)) * ((2147483647 : ℤ) + (1 : ℤ)) - (1 : ℤ)) : let o1 : BitVec 32 := r x; let o2 : BitVec 32 := r y; int'32_in_bounds (BitVec.toInt o2 - BitVec.toInt o1) ∧ (∀(r1 : BitVec 32), BitVec.toInt r1 = BitVec.toInt o2 - BitVec.toInt o1 → (let v1 : ℤ := abs (v x - v y); (if BitVec.toInt (q y) < BitVec.toInt (q x) then if (0 : ℤ) < BitVec.toInt r1 then int'32_in_bounds (-BitVec.toInt r1) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = -BitVec.toInt r1 → int'32_in_bounds (BitVec.toInt o3 + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt o3 + (1 : ℤ) → int'32_in_bounds (BitVec.toInt o4 + BitVec.toInt (2147483647 : BitVec 32)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt o4 + BitVec.toInt (2147483647 : BitVec 32) → (let o6 : BitVec 32 := q y; let o7 : BitVec 32 := q x; int'32_in_bounds (BitVec.toInt o7 - (1 : ℤ)) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt o7 - (1 : ℤ) → int'32_in_bounds (BitVec.toInt o8 - BitVec.toInt o6) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt o8 - BitVec.toInt o6 → (-((2147483647 : ℤ) + (1 : ℤ)) ≤ BitVec.toInt o9 ∧ BitVec.toInt o9 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ v1 = BitVec.toInt o9 * ((2147483647 : ℤ) + (1 : ℤ)) + BitVec.toInt o5)))))) else int'32_in_bounds (-BitVec.toInt r1) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = -BitVec.toInt r1 → (let o4 : BitVec 32 := q y; let o5 : BitVec 32 := q x; int'32_in_bounds (BitVec.toInt o5 - BitVec.toInt o4) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt o5 - BitVec.toInt o4 → (-((2147483647 : ℤ) + (1 : ℤ)) ≤ BitVec.toInt o6 ∧ BitVec.toInt o6 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ v1 = BitVec.toInt o6 * ((2147483647 : ℤ) + (1 : ℤ)) + BitVec.toInt o3))) else let o3 : BitVec 32 := q x; let o4 : BitVec 32 := q y; (BitVec.toInt o4 = BitVec.toInt o3 → o4 = o3) → (if o4 = o3 then if BitVec.toInt r1 < (0 : ℤ) then int'32_in_bounds (-BitVec.toInt r1) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = -BitVec.toInt r1 → (-((2147483647 : ℤ) + (1 : ℤ)) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ v1 = (0 : ℤ) * ((2147483647 : ℤ) + (1 : ℤ)) + BitVec.toInt o5) else (-((2147483647 : ℤ) + (1 : ℤ)) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt r1 ∧ BitVec.toInt r1 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ v1 = (0 : ℤ) * ((2147483647 : ℤ) + (1 : ℤ)) + BitVec.toInt r1 else if BitVec.toInt r1 < (0 : ℤ) then int'32_in_bounds (BitVec.toInt r1 + (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt r1 + (1 : ℤ) → int'32_in_bounds (BitVec.toInt o5 + BitVec.toInt (2147483647 : BitVec 32)) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt o5 + BitVec.toInt (2147483647 : BitVec 32) → (let o7 : BitVec 32 := q x; let o8 : BitVec 32 := q y; int'32_in_bounds (BitVec.toInt o8 - (1 : ℤ)) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt o8 - (1 : ℤ) → int'32_in_bounds (BitVec.toInt o9 - BitVec.toInt o7) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt o9 - BitVec.toInt o7 → (-((2147483647 : ℤ) + (1 : ℤ)) ≤ BitVec.toInt o10 ∧ BitVec.toInt o10 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt o6 ∧ BitVec.toInt o6 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ v1 = BitVec.toInt o10 * ((2147483647 : ℤ) + (1 : ℤ)) + BitVec.toInt o6))))) else let o5 : BitVec 32 := q x; let o6 : BitVec 32 := q y; int'32_in_bounds (BitVec.toInt o6 - BitVec.toInt o5) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt o6 - BitVec.toInt o5 → (-((2147483647 : ℤ) + (1 : ℤ)) ≤ BitVec.toInt o7 ∧ BitVec.toInt o7 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt r1 ∧ BitVec.toInt r1 ≤ (2147483647 : ℤ) + (1 : ℤ) - (1 : ℤ)) ∧ v1 = BitVec.toInt o7 * ((2147483647 : ℤ) + (1 : ℤ)) + BitVec.toInt r1))) ∧ (∀(result : big) (result_v : ℤ) (result_r : BitVec 32) (result_q : BitVec 32), (if BitVec.toInt (q y) < BitVec.toInt (q x) then if (0 : ℤ) < BitVec.toInt r1 then ∃(o3 : BitVec 32), BitVec.toInt o3 = -BitVec.toInt r1 ∧ (∃(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt o3 + (1 : ℤ) ∧ BitVec.toInt (r result) = BitVec.toInt o4 + BitVec.toInt (2147483647 : BitVec 32) ∧ (∃(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt (q x) - (1 : ℤ) ∧ BitVec.toInt (q result) = BitVec.toInt o5 - BitVec.toInt (q y) ∧ (result_v = v result ∧ result_r = r result ∧ result_q = q result) ∧ v result = v1)) else BitVec.toInt (r result) = -BitVec.toInt r1 ∧ BitVec.toInt (q result) = BitVec.toInt (q x) - BitVec.toInt (q y) ∧ (result_v = v result ∧ result_r = r result ∧ result_q = q result) ∧ v result = v1 else let o3 : BitVec 32 := q x; let o4 : BitVec 32 := q y; (BitVec.toInt o4 = BitVec.toInt o3 → o4 = o3) ∧ (if o4 = o3 then if BitVec.toInt r1 < (0 : ℤ) then BitVec.toInt (r result) = -BitVec.toInt r1 ∧ (result_v = v result ∧ result_r = r result ∧ result_q = q result) ∧ q result = (0 : BitVec 32) ∧ v result = v1 else (result_v = v result ∧ result_r = r result ∧ result_q = q result) ∧ q result = (0 : BitVec 32) ∧ r result = r1 ∧ v result = v1 else if BitVec.toInt r1 < (0 : ℤ) then ∃(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt r1 + (1 : ℤ) ∧ BitVec.toInt (r result) = BitVec.toInt o5 + BitVec.toInt (2147483647 : BitVec 32) ∧ (∃(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt (q y) - (1 : ℤ) ∧ BitVec.toInt (q result) = BitVec.toInt o6 - BitVec.toInt (q x) ∧ (result_v = v result ∧ result_r = r result ∧ result_q = q result) ∧ v result = v1) else BitVec.toInt (q result) = BitVec.toInt (q y) - BitVec.toInt (q x) ∧ (result_v = v result ∧ result_r = r result ∧ result_q = q result) ∧ r result = r1 ∧ v result = v1)) → v result = abs (v x - v y))))
  := sorry
end hillel_challenge_FulcrumNoOverflow_deltaqtvc
