theory powm_Powm_binvert_limbqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.c_C" "mach.int_Unsigned" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/sub_1_Sub_1"
begin
definition redc :: "int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "redc ur u n m \<longleftrightarrow> ur emod m = ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i n * u emod m" for ur u n m
theorem binvert_limb'vc:
  fixes n :: "64 word"
  assumes fact0: "odd (uint n)"
  shows "\<forall>(n1 :: int) (inv :: int) (prec :: int). ((0 :: int) \<le> n1 \<and> (0 :: int) \<le> inv) \<and> inv * n1 emod (2 :: int) ^\<^sub>i prec = (1 :: int) \<and> (0 :: int) \<le> (2 :: int) * prec \<and> (2 :: int) * prec \<le> (64 :: int) \<longrightarrow> ((2 :: int) * inv - inv * (inv * n1)) emod ((18446744073709551615 :: int) + (1 :: int)) * n1 emod (2 :: int) ^\<^sub>i ((2 :: int) * prec) = (1 :: int)"
  and "\<not>(2 :: int) = (0 :: int)"
  and "uint'64_in_bounds (uint n cdiv (2 :: int))"
  and "\<forall>(o1 :: 64 word). uint o1 = uint n cdiv (2 :: int) \<longrightarrow> (\<not>(128 :: int) = (0 :: int) \<and> uint'64_in_bounds (uint o1 cmod (128 :: int))) \<and> (\<forall>(h :: 64 word). uint h = uint o1 cmod (128 :: int) \<longrightarrow> ((0 :: int) \<le> uint h \<and> uint h < (128 :: int)) \<and> (\<forall>(o2 :: 64 word). ((0 :: int) \<le> uint o2 \<and> uint o2 < (256 :: int)) \<and> uint o2 * ((2 :: int) * uint h + (1 :: int)) emod (2 :: int) ^\<^sub>i (8 :: int) = (1 :: int) \<longrightarrow> (\<forall>(o3 :: 64 word). uint o3 = uint o2 * uint n emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(o4 :: 64 word). uint o4 = uint o2 * uint o3 emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(o5 :: 64 word). uint o5 = (2 :: int) * uint o2 emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(o6 :: 64 word). uint o6 = (uint o5 - uint o4) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(o7 :: 64 word). uint o7 = uint o6 * uint n emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(o8 :: 64 word). uint o8 = uint o6 * uint o7 emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(o9 :: 64 word). uint o9 = (2 :: int) * uint o6 emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(o10 :: 64 word). uint o10 = (uint o9 - uint o8) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(o11 :: 64 word). uint o11 = uint o10 * uint n emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(o12 :: 64 word). uint o12 = uint o10 * uint o11 emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(o13 :: 64 word). uint o13 = (2 :: int) * uint o10 emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(o14 :: 64 word). uint o14 = (uint o13 - uint o12) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> uint o14 * uint n emod ((18446744073709551615 :: int) + (1 :: int)) = (1 :: int)))))))))))))))"
  sorry
end
