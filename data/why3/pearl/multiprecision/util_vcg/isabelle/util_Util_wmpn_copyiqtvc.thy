theory util_Util_wmpn_copyiqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/ptralias_Alias"
begin
theorem wmpn_copyi'vc:
  fixes up :: "64 word ptr"
  fixes n :: "32 word"
  fixes rp :: "64 word ptr"
  assumes fact0: "valid up (sint n)"
  assumes fact1: "valid rp (sint n)"
  assumes fact2: "writable rp = True"
  assumes fact3: "offset rp \<le> offset up \<or> offset up + sint n \<le> offset rp"
  shows "int'32_in_bounds (sint n - (1 :: int))"
  and "\<forall>(o1 :: 32 word). sint o1 = sint n - (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint o1 + (1 :: int) \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> pelts rp (offset rp + j) = pelts up (offset up + j)) \<and> (\<forall>(up1 :: 64 word ptr) (rp1 :: 64 word ptr). data up1 = data rp1 \<and> length (data rp1) = length (data up) \<and> offset up1 = offset up \<and> c_C.min up1 = c_C.min up \<and> c_C.max up1 = c_C.max up \<and> writable up1 = writable up \<and> zone1 up1 = zone1 up \<longrightarrow> length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(i :: 32 word). let i1 :: int = sint i in ((0 :: int) \<le> i1 \<and> i1 \<le> sint o1) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i1 \<longrightarrow> pelts rp1 (offset rp1 + j) = pelts up (offset up1 + j)) \<and> (\<forall>(j :: int). j < offset rp1 \<or> offset rp1 + sint n \<le> j \<longrightarrow> pelts rp1 j = pelts rp j) \<and> (\<forall>(j :: int). i1 \<le> j \<and> j < sint n \<longrightarrow> pelts up1 (offset up1 + j) = pelts up (offset up1 + j)) \<longrightarrow> (c_C.min up1 \<le> offset up1 + sint i \<and> offset up1 + sint i < c_C.max up1) \<and> (let lu :: 64 word = pelts up1 (offset up1 + sint i) in (c_C.min up \<le> offset up + sint i \<and> offset up + sint i < c_C.max up) \<and> ((c_C.min rp1 \<le> offset rp1 + sint i \<and> offset rp1 + sint i < c_C.max rp1) \<and> writable rp1 = True) \<and> (\<forall>(up2 :: 64 word ptr) (rp2 :: 64 word ptr). data up2 = data rp2 \<and> length (data rp2) = length (data up1) \<and> offset up2 = offset up1 \<and> c_C.min up2 = c_C.min up1 \<and> c_C.max up2 = c_C.max up1 \<and> writable up2 = writable up1 \<and> zone1 up2 = zone1 up1 \<longrightarrow> length (data rp2) = length (data rp1) \<and> offset rp2 = offset rp1 \<and> c_C.min rp2 = c_C.min rp1 \<and> c_C.max rp2 = c_C.max rp1 \<and> writable rp2 = writable rp1 \<and> zone1 rp2 = zone1 rp1 \<longrightarrow> pelts rp2 = (pelts rp1)(offset rp2 + sint i := lu) \<and> pelts rp2 (offset rp2 + sint i) = lu \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i1 + (1 :: int) \<longrightarrow> pelts rp2 (offset rp2 + j) = pelts up (offset up2 + j)) \<and> (\<forall>(j :: int). j < offset rp2 \<or> offset rp2 + sint n \<le> j \<longrightarrow> pelts rp2 j = pelts rp j) \<and> (\<forall>(j :: int). i1 + (1 :: int) \<le> j \<and> j < sint n \<longrightarrow> pelts up2 (offset up2 + j) = pelts up (offset up2 + j))))) \<and> ((\<forall>(j :: int). (0 :: int) \<le> j \<and> j < sint o1 + (1 :: int) \<longrightarrow> pelts rp1 (offset rp1 + j) = pelts up (offset up1 + j)) \<and> (\<forall>(j :: int). j < offset rp1 \<or> offset rp1 + sint n \<le> j \<longrightarrow> pelts rp1 j = pelts rp j) \<and> (\<forall>(j :: int). sint o1 + (1 :: int) \<le> j \<and> j < sint n \<longrightarrow> pelts up1 (offset up1 + j) = pelts up (offset up1 + j)) \<longrightarrow> map_eq_sub_shift (pelts rp1) (pelts up) (offset rp1) (offset up1) (sint n) \<and> (\<forall>(j :: int). j < offset rp1 \<or> offset rp1 + sint n \<le> j \<longrightarrow> pelts rp1 j = pelts rp j)))) \<and> (sint o1 + (1 :: int) < (0 :: int) \<longrightarrow> map_eq_sub_shift (pelts rp) (pelts up) (offset rp) (offset up) (sint n))"
  sorry
end
