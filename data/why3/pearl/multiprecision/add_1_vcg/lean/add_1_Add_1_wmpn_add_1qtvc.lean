import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
open Classical
open Lean4Why3
namespace add_1_Add_1_wmpn_add_1qtvc
theorem wmpn_add_1'vc (x : C.ptr (BitVec 64)) (sz : BitVec 32) (r : C.ptr (BitVec 64)) (y : BitVec 64) (fact0 : C.valid x (BitVec.toInt sz)) (fact1 : C.valid r (BitVec.toInt sz)) (fact2 : (0 : ℤ) < BitVec.toInt sz) (fact3 : C.writable r = true) : C.min x ≤ C.offset x ∧ C.offset x < C.max x ∧ (let o1 : BitVec 64 := C.pelts x (C.offset x); ∀(res : BitVec 64), BitVec.toUInt res = (BitVec.toUInt o1 + BitVec.toUInt y) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → ((C.min r ≤ C.offset r ∧ C.offset r < C.max r) ∧ C.writable r = true) ∧ (∀(r1 : C.ptr (BitVec 64)), List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → C.pelts r1 = Function.update (C.pelts r) (C.offset r1) res → (if BitVec.toUInt res < BitVec.toUInt o1 then (((1 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ BitVec.toInt sz) ∧ ((0 : ℤ) ≤ BitVec.toUInt (1 : BitVec 64) ∧ BitVec.toUInt (1 : BitVec 64) ≤ (1 : ℤ)) ∧ ((1 : BitVec 32) = sz ∨ BitVec.toUInt (1 : BitVec 64) = (1 : ℤ)) ∧ Lemmas.value r1 (1 : ℤ) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (1 : ℕ) * BitVec.toUInt (1 : BitVec 64) = Lemmas.value x (1 : ℤ) + BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sz ≤ j → C.pelts r1 j = C.pelts r j)) ∧ (∀(c : BitVec 64) (i : BitVec 32) (r2 : C.ptr (BitVec 64)), List.length (C.data r2) = List.length (C.data r1) ∧ C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.max r2 = C.max r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → ((1 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sz) ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (i = sz ∨ BitVec.toUInt c = (1 : ℤ)) ∧ Lemmas.value r2 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt i) + BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sz ≤ j → C.pelts r2 j = C.pelts r j) → (if BitVec.toInt i < BitVec.toInt sz then (C.min x ≤ C.offset x + BitVec.toInt i ∧ C.offset x + BitVec.toInt i < C.max x) ∧ (∀(res1 : BitVec 64), BitVec.toUInt res1 = (BitVec.toUInt (C.pelts x (C.offset x + BitVec.toInt i)) + (1 : ℤ)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → ((C.min r2 ≤ C.offset r2 + BitVec.toInt i ∧ C.offset r2 + BitVec.toInt i < C.max r2) ∧ C.writable r2 = true) ∧ (∀(r3 : C.ptr (BitVec 64)), List.length (C.data r3) = List.length (C.data r2) ∧ C.offset r3 = C.offset r2 ∧ C.min r3 = C.min r2 ∧ C.max r3 = C.max r2 ∧ C.writable r3 = C.writable r2 ∧ C.zone1 r3 = C.zone1 r2 → C.pelts r3 = Function.update (C.pelts r2) (C.offset r3 + BitVec.toInt i) res1 ∧ C.pelts r3 (C.offset r3 + BitVec.toInt i) = res1 → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toInt i + (1 : ℤ) → (∀(o3 : Bool), (BitVec.toUInt res1 = BitVec.toUInt (0 : BitVec 64) → o3 = true) ∧ (o3 = true → res1 = (0 : BitVec 64)) → (if ¬o3 = true then ((o2 = sz ∨ BitVec.toUInt (0 : BitVec 64) = (0 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 ≤ BitVec.toInt sz) ∧ Lemmas.value r3 (BitVec.toInt o2) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o2)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt o2) + BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt sz ≤ j → C.pelts r3 j = C.pelts r j)) ∧ (∀(i1 : BitVec 32) (r4 : C.ptr (BitVec 64)), List.length (C.data r4) = List.length (C.data r3) ∧ C.offset r4 = C.offset r3 ∧ C.min r4 = C.min r3 ∧ C.max r4 = C.max r3 ∧ C.writable r4 = C.writable r3 ∧ C.zone1 r4 = C.zone1 r3 → (i1 = sz ∨ BitVec.toUInt (0 : BitVec 64) = (0 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt i1 ∧ BitVec.toInt i1 ≤ BitVec.toInt sz) ∧ Lemmas.value r4 (BitVec.toInt i1) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i1)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt i1) + BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r4 ∨ C.offset r4 + BitVec.toInt sz ≤ j → C.pelts r4 j = C.pelts r j) → (if BitVec.toInt i1 < BitVec.toInt sz then (C.min x ≤ C.offset x + BitVec.toInt i1 ∧ C.offset x + BitVec.toInt i1 < C.max x) ∧ ((C.min r4 ≤ C.offset r4 + BitVec.toInt i1 ∧ C.offset r4 + BitVec.toInt i1 < C.max r4) ∧ C.writable r4 = true) ∧ (∀(r5 : C.ptr (BitVec 64)), List.length (C.data r5) = List.length (C.data r4) ∧ C.offset r5 = C.offset r4 ∧ C.min r5 = C.min r4 ∧ C.max r5 = C.max r4 ∧ C.writable r5 = C.writable r4 ∧ C.zone1 r5 = C.zone1 r4 → C.pelts r5 = Function.update (C.pelts r4) (C.offset r5 + BitVec.toInt i1) (C.pelts x (C.offset x + BitVec.toInt i1)) ∧ C.pelts r5 (C.offset r5 + BitVec.toInt i1) = C.pelts x (C.offset x + BitVec.toInt i1) → int'32_in_bounds (BitVec.toInt i1 + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt i1 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt sz - BitVec.toInt i1 ∧ BitVec.toInt sz - BitVec.toInt o4 < BitVec.toInt sz - BitVec.toInt i1) ∧ (o4 = sz ∨ BitVec.toUInt (0 : BitVec 64) = (0 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ BitVec.toInt sz) ∧ Lemmas.value r5 (BitVec.toInt o4) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o4)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt o4) + BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r5 ∨ C.offset r5 + BitVec.toInt sz ≤ j → C.pelts r5 j = C.pelts r j))) else Lemmas.value r4 (BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt sz) + BitVec.toUInt y ∧ ((0 : ℤ) ≤ BitVec.toUInt (0 : BitVec 64) ∧ BitVec.toUInt (0 : BitVec 64) ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r4 ∨ C.offset r4 + BitVec.toInt sz ≤ j → C.pelts r4 j = C.pelts r j))) else ((0 : ℤ) ≤ BitVec.toInt sz - BitVec.toInt i ∧ BitVec.toInt sz - BitVec.toInt o2 < BitVec.toInt sz - BitVec.toInt i) ∧ ((1 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 ≤ BitVec.toInt sz) ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (o2 = sz ∨ BitVec.toUInt c = (1 : ℤ)) ∧ Lemmas.value r3 (BitVec.toInt o2) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o2)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt o2) + BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt sz ≤ j → C.pelts r3 j = C.pelts r j)))))) else ((i = sz ∨ BitVec.toUInt c = (0 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sz) ∧ Lemmas.value r2 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt i) + BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sz ≤ j → C.pelts r2 j = C.pelts r j)) ∧ (∀(i1 : BitVec 32) (r3 : C.ptr (BitVec 64)), List.length (C.data r3) = List.length (C.data r2) ∧ C.offset r3 = C.offset r2 ∧ C.min r3 = C.min r2 ∧ C.max r3 = C.max r2 ∧ C.writable r3 = C.writable r2 ∧ C.zone1 r3 = C.zone1 r2 → (i1 = sz ∨ BitVec.toUInt c = (0 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt i1 ∧ BitVec.toInt i1 ≤ BitVec.toInt sz) ∧ Lemmas.value r3 (BitVec.toInt i1) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i1)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt i1) + BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt sz ≤ j → C.pelts r3 j = C.pelts r j) → (if BitVec.toInt i1 < BitVec.toInt sz then (C.min x ≤ C.offset x + BitVec.toInt i1 ∧ C.offset x + BitVec.toInt i1 < C.max x) ∧ ((C.min r3 ≤ C.offset r3 + BitVec.toInt i1 ∧ C.offset r3 + BitVec.toInt i1 < C.max r3) ∧ C.writable r3 = true) ∧ (∀(r4 : C.ptr (BitVec 64)), List.length (C.data r4) = List.length (C.data r3) ∧ C.offset r4 = C.offset r3 ∧ C.min r4 = C.min r3 ∧ C.max r4 = C.max r3 ∧ C.writable r4 = C.writable r3 ∧ C.zone1 r4 = C.zone1 r3 → C.pelts r4 = Function.update (C.pelts r3) (C.offset r4 + BitVec.toInt i1) (C.pelts x (C.offset x + BitVec.toInt i1)) ∧ C.pelts r4 (C.offset r4 + BitVec.toInt i1) = C.pelts x (C.offset x + BitVec.toInt i1) → int'32_in_bounds (BitVec.toInt i1 + (1 : ℤ)) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toInt i1 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt sz - BitVec.toInt i1 ∧ BitVec.toInt sz - BitVec.toInt o2 < BitVec.toInt sz - BitVec.toInt i1) ∧ (o2 = sz ∨ BitVec.toUInt c = (0 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 ≤ BitVec.toInt sz) ∧ Lemmas.value r4 (BitVec.toInt o2) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o2)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt o2) + BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r4 ∨ C.offset r4 + BitVec.toInt sz ≤ j → C.pelts r4 j = C.pelts r j))) else Lemmas.value r3 (BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt sz) + BitVec.toUInt y ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt sz ≤ j → C.pelts r3 j = C.pelts r j))))) else (((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ BitVec.toInt sz) ∧ Lemmas.value r1 (1 : ℤ) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (1 : ℕ) * (0 : ℤ) = Lemmas.value x (1 : ℤ) + BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sz ≤ j → C.pelts r1 j = C.pelts r j)) ∧ (∀(i : BitVec 32) (r2 : C.ptr (BitVec 64)), List.length (C.data r2) = List.length (C.data r1) ∧ C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.max r2 = C.max r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sz) ∧ Lemmas.value r2 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * (0 : ℤ) = Lemmas.value x (BitVec.toInt i) + BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sz ≤ j → C.pelts r2 j = C.pelts r j) → (if BitVec.toInt i < BitVec.toInt sz then (C.min x ≤ C.offset x + BitVec.toInt i ∧ C.offset x + BitVec.toInt i < C.max x) ∧ ((C.min r2 ≤ C.offset r2 + BitVec.toInt i ∧ C.offset r2 + BitVec.toInt i < C.max r2) ∧ C.writable r2 = true) ∧ (∀(r3 : C.ptr (BitVec 64)), List.length (C.data r3) = List.length (C.data r2) ∧ C.offset r3 = C.offset r2 ∧ C.min r3 = C.min r2 ∧ C.max r3 = C.max r2 ∧ C.writable r3 = C.writable r2 ∧ C.zone1 r3 = C.zone1 r2 → C.pelts r3 = Function.update (C.pelts r2) (C.offset r3 + BitVec.toInt i) (C.pelts x (C.offset x + BitVec.toInt i)) ∧ C.pelts r3 (C.offset r3 + BitVec.toInt i) = C.pelts x (C.offset x + BitVec.toInt i) → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt sz - BitVec.toInt i ∧ BitVec.toInt sz - BitVec.toInt o2 < BitVec.toInt sz - BitVec.toInt i) ∧ ((0 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 ≤ BitVec.toInt sz) ∧ Lemmas.value r3 (BitVec.toInt o2) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o2)) * (0 : ℤ) = Lemmas.value x (BitVec.toInt o2) + BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt sz ≤ j → C.pelts r3 j = C.pelts r j))) else Lemmas.value r2 (BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz)) * (0 : ℤ) = Lemmas.value x (BitVec.toInt sz) + BitVec.toUInt y ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sz ≤ j → C.pelts r2 j = C.pelts r j))))))
  := sorry
end add_1_Add_1_wmpn_add_1qtvc
