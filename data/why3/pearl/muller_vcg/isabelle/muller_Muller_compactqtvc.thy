theory muller_Muller_compactqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_NumOf"
begin
consts fc :: "int list \<Rightarrow> int \<Rightarrow> bool"
axiomatization where fc'def:   "fc a i = True \<longleftrightarrow> \<not>a ! nat i = (0 :: int)"
  for a :: "int list"
  and i :: "int"
definition numof :: "int list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int"
  where "numof a l u = int_NumOf.numof (fc a) l u" for a l u
theorem compact'vc:
  fixes a :: "int list"
  shows "let o1 :: int = int (length a) - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> (0 :: int) = numof a (0 :: int) (0 :: int) \<and> (\<forall>(count :: int). (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o1) \<and> count = numof a (0 :: int) i \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if \<not>a ! nat i = (0 :: int) then count + (1 :: int) = numof a (0 :: int) (i + (1 :: int)) else count = numof a (0 :: int) (i + (1 :: int)))) \<and> (count = numof a (0 :: int) (o1 + (1 :: int)) \<longrightarrow> (0 :: int) \<le> count \<and> (\<forall>(u :: int list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < count \<longrightarrow> u ! nat i = (0 :: int)) \<and> int (length u) = count \<longrightarrow> (let o2 :: int = int (length a) - (1 :: int) in (0 :: int) \<le> o2 + (1 :: int) \<longrightarrow> (0 :: int) = numof a (0 :: int) (0 :: int) \<and> (\<forall>(u1 :: int list) (count1 :: int). length u1 = length u \<longrightarrow> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o2) \<and> count1 = numof a (0 :: int) i \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if \<not>a ! nat i = (0 :: int) then ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (let o3 :: int = a ! nat i in ((0 :: int) \<le> count1 \<and> count1 < int (length u1)) \<and> (length (u1[nat count1 := o3]) = length u1 \<longrightarrow> nth (u1[nat count1 := o3]) o nat = (nth u1 o nat)(count1 := o3) \<longrightarrow> count1 + (1 :: int) = numof a (0 :: int) (i + (1 :: int)))) else count1 = numof a (0 :: int) (i + (1 :: int)))))))))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> (0 :: int) \<le> (0 :: int) \<and> (\<forall>(u :: int list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (0 :: int) \<longrightarrow> u ! nat i = (0 :: int)) \<and> int (length u) = (0 :: int) \<longrightarrow> (let o2 :: int = int (length a) - (1 :: int) in (0 :: int) \<le> o2 + (1 :: int) \<longrightarrow> (0 :: int) = numof a (0 :: int) (0 :: int) \<and> (\<forall>(u1 :: int list) (count :: int). length u1 = length u \<longrightarrow> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o2) \<and> count = numof a (0 :: int) i \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if \<not>a ! nat i = (0 :: int) then ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (let o3 :: int = a ! nat i in ((0 :: int) \<le> count \<and> count < int (length u1)) \<and> (length (u1[nat count := o3]) = length u1 \<longrightarrow> nth (u1[nat count := o3]) o nat = (nth u1 o nat)(count := o3) \<longrightarrow> count + (1 :: int) = numof a (0 :: int) (i + (1 :: int)))) else count = numof a (0 :: int) (i + (1 :: int))))))))"
  sorry
end
