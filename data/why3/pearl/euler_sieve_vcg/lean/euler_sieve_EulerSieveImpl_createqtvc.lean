import Why3.Base
import pearl.euler_sieve_vcg.lean.euler_sieve.ArithmeticResults
import pearl.euler_sieve_vcg.lean.euler_sieve.DivisibilityResults
import pearl.euler_sieve_vcg.lean.euler_sieve.EulerSieveSpec
import Why3.mach.array.ArrayInt63
open Classical
open Lean4Why3
namespace euler_sieve_EulerSieveImpl_createqtvc
axiom t : Type
axiom inhabited_axiom_t : Inhabited t
attribute [instance] inhabited_axiom_t
axiom nexts : t -> List ℤ
axiom marked : t -> List Bool
axiom arr : t -> ArrayInt63.array63
axiom max : t -> BitVec 63
axiom max_arr : t -> BitVec 63
axiom t'invariant (self : t) : BitVec.toInt (max self) < BitVec.toInt int'63_max ∧ (3 : ℤ) ≤ BitVec.toInt (max self) ∧ List.length (nexts self) = List.length (marked self) ∧ Int.ofNat (List.length (marked self)) = BitVec.toInt (max self) + (1 : ℤ) ∧ (BitVec.toInt (max self) - (1 : ℤ)) / (2 : ℤ) = BitVec.toInt (max_arr self) ∧ Int.ofNat (List.length (ArrayInt63.elts (arr self))) = BitVec.toInt (max_arr self) + (1 : ℤ) ∧ EulerSieveSpec.inv_nexts (nexts self) (Int.ofNat (List.length (nexts self))) ∧ EulerSieveSpec.all_eliminated_marked (marked self) (nexts self) ∧ (∀(i : ℤ), (3 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max self) → i % (2 : ℤ) = (0 : ℤ) → (marked self)[Int.toNat i]! = true) ∧ (∀(i : ℤ), (3 : ℤ) ≤ i ∧ i < BitVec.toInt (max self) - (1 : ℤ) → i % (2 : ℤ) = (1 : ℤ) → (nexts self)[Int.toNat i]! % (2 : ℤ) = (1 : ℤ) ∨ (nexts self)[Int.toNat i]! = BitVec.toInt (max self) + (1 : ℤ)) ∧ (nexts self)[Int.toNat (BitVec.toInt (max self))]! = BitVec.toInt (max self) + (1 : ℤ) ∧ ((BitVec.toInt (max self) - (1 : ℤ)) % (2 : ℤ) = (0 : ℤ) → (nexts self)[Int.toNat (BitVec.toInt (max self) - (1 : ℤ))]! = BitVec.toInt (max self)) ∧ ((BitVec.toInt (max self) - (1 : ℤ)) % (2 : ℤ) = (1 : ℤ) → (nexts self)[Int.toNat (BitVec.toInt (max self) - (1 : ℤ))]! = BitVec.toInt (max self) + (1 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → -(BitVec.toInt (max self) + (1 : ℤ)) ≤ (ArrayInt63.elts (arr self))[Int.toNat i]! ∧ (ArrayInt63.elts (arr self))[Int.toNat i]! ≤ BitVec.toInt (max self) + (1 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → ((marked self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true) = ((ArrayInt63.elts (arr self))[Int.toNat i]! < (0 : ℤ))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → ¬(marked self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true → (ArrayInt63.elts (arr self))[Int.toNat i]! = (nexts self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → (marked self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true → (ArrayInt63.elts (arr self))[Int.toNat i]! = -(nexts self)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → (i < abs ((ArrayInt63.elts (arr self))[Int.toNat i]!) / (2 : ℤ) ∧ abs ((ArrayInt63.elts (arr self))[Int.toNat i]!) / (2 : ℤ) ≤ BitVec.toInt (max_arr self) + (1 : ℤ)) ∧ abs ((ArrayInt63.elts (arr self))[Int.toNat i]!) ≤ BitVec.toInt (max self) + (1 : ℤ)) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt (max_arr self) → i < j ∧ j < abs ((ArrayInt63.elts (arr self))[Int.toNat i]!) / (2 : ℤ) → (ArrayInt63.elts (arr self))[Int.toNat j]! < (0 : ℤ))
noncomputable def t'eq (a : t) (b : t) := nexts a = nexts b ∧ marked a = marked b ∧ arr a = arr b ∧ max a = max b ∧ max_arr a = max_arr b
axiom t'inj (a : t) (b : t) (fact0 : t'eq a b) : a = b
axiom fc : BitVec 63 -> ℤ -> ℤ
axiom o1 : ℤ -> Bool
axiom fc1 : BitVec 63 -> BitVec 63 -> ℤ -> ℤ
axiom fc'def (max1 : BitVec 63) (i : ℤ) : fc max1 i = (if i = BitVec.toInt max1 then BitVec.toInt max1 + (1 : ℤ) else if i = BitVec.toInt max1 - (1 : ℤ) then if i % (2 : ℤ) = (0 : ℤ) then BitVec.toInt max1 else BitVec.toInt max1 + (1 : ℤ) else if i < (3 : ℤ) ∨ i % (2 : ℤ) = (0 : ℤ) then i + (1 : ℤ) else i + (2 : ℤ))
axiom o'def (i : ℤ) : (o1 i = true) = (i = (0 : ℤ) ∨ i = (1 : ℤ) ∨ (2 : ℤ) < i ∧ i % (2 : ℤ) = (0 : ℤ))
axiom fc'def1 (max1 : BitVec 63) (len_arr : BitVec 63) (i : ℤ) : fc1 max1 len_arr i = (if i = BitVec.toInt len_arr - (1 : ℤ) then BitVec.toInt max1 + (1 : ℤ) else if i = (0 : ℤ) then -(2 : ℤ) else (2 : ℤ) * i + (3 : ℤ))
theorem create'vc (max1 : BitVec 63) (fact0 : BitVec.toInt max1 < BitVec.toInt int'63_max) (fact1 : (3 : ℤ) ≤ BitVec.toInt max1) : let len : ℤ := BitVec.toInt max1 + (1 : ℤ); int'63_in_bounds (BitVec.toInt max1 - (1 : ℤ)) ∧ (∀(o2 : BitVec 63), BitVec.toInt o2 = BitVec.toInt max1 - (1 : ℤ) → (¬(2 : ℤ) = (0 : ℤ) ∧ int'63_in_bounds (Int.tdiv (BitVec.toInt o2) (2 : ℤ))) ∧ (∀(o3 : BitVec 63), BitVec.toInt o3 = Int.tdiv (BitVec.toInt o2) (2 : ℤ) → int'63_in_bounds (BitVec.toInt o3 + (1 : ℤ)) ∧ (∀(len_arr : BitVec 63), BitVec.toInt len_arr = BitVec.toInt o3 + (1 : ℤ) → (let o4 : ℤ -> ℤ := fc max1; (0 : ℤ) ≤ len ∧ (let nexts1 : List ℤ := List.create (Int.toNat len) (o4 ∘ Int.ofNat); Int.ofNat (List.length nexts1) = len ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < len → nexts1[Int.toNat i]! = o4 i) → (∀(i : ℤ), ¬i = (0 : ℤ) → ¬i = (1 : ℤ) → (2 : ℤ) < i → ¬(2 : ℤ) = (0 : ℤ)) ∧ (let o5 : ℤ -> Bool := o1; (0 : ℤ) ≤ len ∧ (let marked1 : List Bool := List.create (Int.toNat len) (o5 ∘ Int.ofNat); Int.ofNat (List.length marked1) = len ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < len → marked1[Int.toNat i]! = o5 i) → (let f : ℤ -> ℤ := fc1 max1 len_arr; (0 : ℤ) ≤ BitVec.toInt len_arr ∧ (∀(arr1 : ArrayInt63.array63), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt len_arr → (ArrayInt63.elts arr1)[Int.toNat i]! = BitVec.toInt (-(2 : BitVec 63))) ∧ Int.ofNat (List.length (ArrayInt63.elts arr1)) = BitVec.toInt len_arr → int'63_in_bounds (BitVec.toInt len_arr - (1 : ℤ)) ∧ (∀(o6 : BitVec 63), BitVec.toInt o6 = BitVec.toInt len_arr - (1 : ℤ) → ((1 : ℤ) ≤ BitVec.toInt o6 + (1 : ℤ) → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (1 : ℤ) → (ArrayInt63.elts arr1)[Int.toNat j]! = f j) ∧ (∀(arr2 : ArrayInt63.array63), ArrayInt63.size arr2 = ArrayInt63.size arr1 → (∀(i : BitVec 63), let i1 : ℤ := BitVec.toInt i; ((1 : ℤ) ≤ i1 ∧ i1 ≤ BitVec.toInt o6) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i1 → (ArrayInt63.elts arr2)[Int.toNat j]! = f j) → int'63_in_bounds (BitVec.toInt len_arr - (1 : ℤ)) ∧ (∀(o7 : BitVec 63), BitVec.toInt o7 = BitVec.toInt len_arr - (1 : ℤ) → (BitVec.toInt i = BitVec.toInt o7 → i = o7) → (if i = o7 then int'63_in_bounds (BitVec.toInt max1 + (1 : ℤ)) else int'63_in_bounds ((2 : ℤ) * BitVec.toInt i) ∧ (∀(o8 : BitVec 63), BitVec.toInt o8 = (2 : ℤ) * BitVec.toInt i → int'63_in_bounds (BitVec.toInt o8 + (3 : ℤ)))) ∧ (∀(o8 : BitVec 63), (if i = o7 then BitVec.toInt o8 = BitVec.toInt max1 + (1 : ℤ) else ∃(o9 : BitVec 63), BitVec.toInt o9 = (2 : ℤ) * BitVec.toInt i ∧ BitVec.toInt o8 = BitVec.toInt o9 + (3 : ℤ)) → ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i < Int.ofNat (List.length (ArrayInt63.elts arr2))) ∧ (∀(arr3 : ArrayInt63.array63), ArrayInt63.size arr3 = ArrayInt63.size arr2 → ArrayInt63.elts arr3 = List.set (ArrayInt63.elts arr2) (Int.toNat (BitVec.toInt i)) (BitVec.toInt o8) → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i1 + (1 : ℤ) → (ArrayInt63.elts arr3)[Int.toNat j]! = f j))))) ∧ ((∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toInt o6 + (1 : ℤ) → (ArrayInt63.elts arr2)[Int.toNat j]! = f j) → int'63_in_bounds (BitVec.toInt max1 - (1 : ℤ)) ∧ (∀(o7 : BitVec 63), BitVec.toInt o7 = BitVec.toInt max1 - (1 : ℤ) → (¬(2 : ℤ) = (0 : ℤ) ∧ int'63_in_bounds (Int.tdiv (BitVec.toInt o7) (2 : ℤ))) ∧ (∀(o8 : BitVec 63), BitVec.toInt o8 = Int.tdiv (BitVec.toInt o7) (2 : ℤ) → ((BitVec.toInt max1 < BitVec.toInt int'63_max ∧ (3 : ℤ) ≤ BitVec.toInt max1) ∧ (List.length nexts1 = List.length marked1 ∧ Int.ofNat (List.length marked1) = BitVec.toInt max1 + (1 : ℤ)) ∧ (BitVec.toInt max1 - (1 : ℤ)) / (2 : ℤ) = BitVec.toInt o8 ∧ Int.ofNat (List.length (ArrayInt63.elts arr2)) = BitVec.toInt o8 + (1 : ℤ) ∧ EulerSieveSpec.inv_nexts nexts1 (Int.ofNat (List.length nexts1)) ∧ EulerSieveSpec.all_eliminated_marked marked1 nexts1 ∧ (∀(i : ℤ), (3 : ℤ) ≤ i ∧ i ≤ BitVec.toInt max1 → i % (2 : ℤ) = (0 : ℤ) → marked1[Int.toNat i]! = true) ∧ (∀(i : ℤ), (3 : ℤ) ≤ i ∧ i < BitVec.toInt max1 - (1 : ℤ) → i % (2 : ℤ) = (1 : ℤ) → nexts1[Int.toNat i]! % (2 : ℤ) = (1 : ℤ) ∨ nexts1[Int.toNat i]! = BitVec.toInt max1 + (1 : ℤ)) ∧ (nexts1[Int.toNat (BitVec.toInt max1)]! = BitVec.toInt max1 + (1 : ℤ) ∧ ((BitVec.toInt max1 - (1 : ℤ)) % (2 : ℤ) = (0 : ℤ) → nexts1[Int.toNat (BitVec.toInt max1 - (1 : ℤ))]! = BitVec.toInt max1) ∧ ((BitVec.toInt max1 - (1 : ℤ)) % (2 : ℤ) = (1 : ℤ) → nexts1[Int.toNat (BitVec.toInt max1 - (1 : ℤ))]! = BitVec.toInt max1 + (1 : ℤ))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt o8 → -(BitVec.toInt max1 + (1 : ℤ)) ≤ (ArrayInt63.elts arr2)[Int.toNat i]! ∧ (ArrayInt63.elts arr2)[Int.toNat i]! ≤ BitVec.toInt max1 + (1 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt o8 → (marked1[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true) = ((ArrayInt63.elts arr2)[Int.toNat i]! < (0 : ℤ))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt o8 → ¬marked1[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true → (ArrayInt63.elts arr2)[Int.toNat i]! = nexts1[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt o8 → marked1[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true → (ArrayInt63.elts arr2)[Int.toNat i]! = -nexts1[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt o8 → (i < abs ((ArrayInt63.elts arr2)[Int.toNat i]!) / (2 : ℤ) ∧ abs ((ArrayInt63.elts arr2)[Int.toNat i]!) / (2 : ℤ) ≤ BitVec.toInt o8 + (1 : ℤ)) ∧ abs ((ArrayInt63.elts arr2)[Int.toNat i]!) ≤ BitVec.toInt max1 + (1 : ℤ)) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt o8 → i < j ∧ j < abs ((ArrayInt63.elts arr2)[Int.toNat i]!) / (2 : ℤ) → (ArrayInt63.elts arr2)[Int.toNat j]! < (0 : ℤ))) ∧ (∀(result : t), nexts result = nexts1 ∧ marked result = marked1 ∧ arr result = arr2 ∧ max result = max1 ∧ max_arr result = o8 → max result = max1 ∧ (((marked result)[(0 : ℕ)]! = (marked result)[(1 : ℕ)]! ∧ (marked result)[(1 : ℕ)]! = true) ∧ ¬(marked result)[(2 : ℕ)]! = true) ∧ (∀(i : ℤ), (1 : ℤ) ≤ i ∧ i ≤ (BitVec.toInt max1 - (1 : ℤ)) / (2 : ℤ) → ¬(marked result)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i ≤ (BitVec.toInt max1 + (1 : ℤ)) / (2 : ℤ) → (2 : ℤ) * i ≤ BitVec.toInt max1 → (marked result)[Int.toNat ((2 : ℤ) * i)]! = true) ∧ (∀(i : ℤ), (1 : ℤ) ≤ i ∧ i ≤ (BitVec.toInt max1 - (1 : ℤ)) / (2 : ℤ) → (2 : ℤ) * i + (1 : ℤ) < BitVec.toInt max1 - (1 : ℤ) → (nexts result)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = (2 : ℤ) * i + (3 : ℤ)) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i ≤ (BitVec.toInt max1 - (1 : ℤ)) / (2 : ℤ) → (2 : ℤ) * i < BitVec.toInt max1 - (1 : ℤ) → (nexts result)[Int.toNat ((2 : ℤ) * i)]! = (2 : ℤ) * i + (1 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt max1 → (marked result)[Int.toNat i]! = true → i < (2 : ℤ) ∨ (2 : ℤ) ∣  i))))))) ∧ (BitVec.toInt o6 + (1 : ℤ) < (1 : ℤ) → int'63_in_bounds (BitVec.toInt max1 - (1 : ℤ)) ∧ (∀(o7 : BitVec 63), BitVec.toInt o7 = BitVec.toInt max1 - (1 : ℤ) → (¬(2 : ℤ) = (0 : ℤ) ∧ int'63_in_bounds (Int.tdiv (BitVec.toInt o7) (2 : ℤ))) ∧ (∀(o8 : BitVec 63), BitVec.toInt o8 = Int.tdiv (BitVec.toInt o7) (2 : ℤ) → ((BitVec.toInt max1 < BitVec.toInt int'63_max ∧ (3 : ℤ) ≤ BitVec.toInt max1) ∧ (List.length nexts1 = List.length marked1 ∧ Int.ofNat (List.length marked1) = BitVec.toInt max1 + (1 : ℤ)) ∧ (BitVec.toInt max1 - (1 : ℤ)) / (2 : ℤ) = BitVec.toInt o8 ∧ Int.ofNat (List.length (ArrayInt63.elts arr1)) = BitVec.toInt o8 + (1 : ℤ) ∧ EulerSieveSpec.inv_nexts nexts1 (Int.ofNat (List.length nexts1)) ∧ EulerSieveSpec.all_eliminated_marked marked1 nexts1 ∧ (∀(i : ℤ), (3 : ℤ) ≤ i ∧ i ≤ BitVec.toInt max1 → i % (2 : ℤ) = (0 : ℤ) → marked1[Int.toNat i]! = true) ∧ (∀(i : ℤ), (3 : ℤ) ≤ i ∧ i < BitVec.toInt max1 - (1 : ℤ) → i % (2 : ℤ) = (1 : ℤ) → nexts1[Int.toNat i]! % (2 : ℤ) = (1 : ℤ) ∨ nexts1[Int.toNat i]! = BitVec.toInt max1 + (1 : ℤ)) ∧ (nexts1[Int.toNat (BitVec.toInt max1)]! = BitVec.toInt max1 + (1 : ℤ) ∧ ((BitVec.toInt max1 - (1 : ℤ)) % (2 : ℤ) = (0 : ℤ) → nexts1[Int.toNat (BitVec.toInt max1 - (1 : ℤ))]! = BitVec.toInt max1) ∧ ((BitVec.toInt max1 - (1 : ℤ)) % (2 : ℤ) = (1 : ℤ) → nexts1[Int.toNat (BitVec.toInt max1 - (1 : ℤ))]! = BitVec.toInt max1 + (1 : ℤ))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt o8 → -(BitVec.toInt max1 + (1 : ℤ)) ≤ (ArrayInt63.elts arr1)[Int.toNat i]! ∧ (ArrayInt63.elts arr1)[Int.toNat i]! ≤ BitVec.toInt max1 + (1 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt o8 → (marked1[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true) = ((ArrayInt63.elts arr1)[Int.toNat i]! < (0 : ℤ))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt o8 → ¬marked1[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true → (ArrayInt63.elts arr1)[Int.toNat i]! = nexts1[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt o8 → marked1[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true → (ArrayInt63.elts arr1)[Int.toNat i]! = -nexts1[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]!) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt o8 → (i < abs ((ArrayInt63.elts arr1)[Int.toNat i]!) / (2 : ℤ) ∧ abs ((ArrayInt63.elts arr1)[Int.toNat i]!) / (2 : ℤ) ≤ BitVec.toInt o8 + (1 : ℤ)) ∧ abs ((ArrayInt63.elts arr1)[Int.toNat i]!) ≤ BitVec.toInt max1 + (1 : ℤ)) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt o8 → i < j ∧ j < abs ((ArrayInt63.elts arr1)[Int.toNat i]!) / (2 : ℤ) → (ArrayInt63.elts arr1)[Int.toNat j]! < (0 : ℤ))) ∧ (∀(result : t), nexts result = nexts1 ∧ marked result = marked1 ∧ arr result = arr1 ∧ max result = max1 ∧ max_arr result = o8 → max result = max1 ∧ (((marked result)[(0 : ℕ)]! = (marked result)[(1 : ℕ)]! ∧ (marked result)[(1 : ℕ)]! = true) ∧ ¬(marked result)[(2 : ℕ)]! = true) ∧ (∀(i : ℤ), (1 : ℤ) ≤ i ∧ i ≤ (BitVec.toInt max1 - (1 : ℤ)) / (2 : ℤ) → ¬(marked result)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = true) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i ≤ (BitVec.toInt max1 + (1 : ℤ)) / (2 : ℤ) → (2 : ℤ) * i ≤ BitVec.toInt max1 → (marked result)[Int.toNat ((2 : ℤ) * i)]! = true) ∧ (∀(i : ℤ), (1 : ℤ) ≤ i ∧ i ≤ (BitVec.toInt max1 - (1 : ℤ)) / (2 : ℤ) → (2 : ℤ) * i + (1 : ℤ) < BitVec.toInt max1 - (1 : ℤ) → (nexts result)[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! = (2 : ℤ) * i + (3 : ℤ)) ∧ (∀(i : ℤ), (2 : ℤ) ≤ i ∧ i ≤ (BitVec.toInt max1 - (1 : ℤ)) / (2 : ℤ) → (2 : ℤ) * i < BitVec.toInt max1 - (1 : ℤ) → (nexts result)[Int.toNat ((2 : ℤ) * i)]! = (2 : ℤ) * i + (1 : ℤ)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i ≤ BitVec.toInt max1 → (marked result)[Int.toNat i]! = true → i < (2 : ℤ) ∨ (2 : ℤ) ∣  i)))))))))))))))
  := sorry
end euler_sieve_EulerSieveImpl_createqtvc
