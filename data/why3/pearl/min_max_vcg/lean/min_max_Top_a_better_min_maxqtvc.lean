import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace min_max_Top_a_better_min_maxqtvc
noncomputable def is_min (m : ℤ) (a : List ℤ) (lo : ℤ) (hi : ℤ) := (∃(i : ℤ), (lo ≤ i ∧ i < hi ∧ hi ≤ Int.ofNat (List.length a)) ∧ a[Int.toNat i]! = m) ∧ (∀(i : ℤ), lo ≤ i ∧ i < hi → m ≤ a[Int.toNat i]!)
noncomputable def is_max (m : ℤ) (a : List ℤ) (lo : ℤ) (hi : ℤ) := (∃(i : ℤ), (lo ≤ i ∧ i < hi ∧ hi ≤ Int.ofNat (List.length a)) ∧ a[Int.toNat i]! = m) ∧ (∀(i : ℤ), lo ≤ i ∧ i < hi → a[Int.toNat i]! ≤ m)
theorem a_better_min_max'vc (a : List ℤ) (fact0 : (1 : ℤ) ≤ Int.ofNat (List.length a)) : let n : ℤ := Int.ofNat (List.length a); ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length a)) ∧ (let o1 : ℤ := a[(0 : ℕ)]!; ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length a)) ∧ (let o2 : ℤ := a[(0 : ℕ)]!; ¬(2 : ℤ) = (0 : ℤ) ∧ (∀(o3 : ℤ), (if Int.tmod n (2 : ℤ) = (0 : ℤ) then o3 = (2 : ℤ) else o3 = (1 : ℤ)) → (o3 = (2 : ℤ) → ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length a)) ∧ (0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < Int.ofNat (List.length a)) ∧ (∀(min : ℤ) (max : ℤ), (if o3 = (2 : ℤ) then if a[(0 : ℕ)]! < a[(1 : ℕ)]! then max = a[(1 : ℕ)]! ∧ min = o1 else min = a[(1 : ℕ)]! ∧ max = o2 else min = o1 ∧ max = o2) → (Int.tmod o3 (2 : ℤ) = Int.tmod n (2 : ℤ) ∧ is_min min a (0 : ℤ) o3 ∧ is_max max a (0 : ℤ) o3) ∧ (∀(min1 : ℤ) (max1 : ℤ) (i : ℤ), Int.tmod i (2 : ℤ) = Int.tmod n (2 : ℤ) ∧ is_min min1 a (0 : ℤ) i ∧ is_max max1 a (0 : ℤ) i → (if i < n then (let o4 : ℤ := i + (1 : ℤ); ((0 : ℤ) ≤ o4 ∧ o4 < Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if a[Int.toNat i]! < a[Int.toNat o4]! then let o5 : ℤ := i + (1 : ℤ); ((0 : ℤ) ≤ o5 ∧ o5 < Int.ofNat (List.length a)) ∧ (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) else ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let o5 : ℤ := i + (1 : ℤ); (0 : ℤ) ≤ o5 ∧ o5 < Int.ofNat (List.length a)))) ∧ (∀(x : ℤ) (y : ℤ), (if a[Int.toNat i]! < a[Int.toNat (i + (1 : ℤ))]! then x = a[Int.toNat i]! ∧ y = a[Int.toNat (i + (1 : ℤ))]! else x = a[Int.toNat (i + (1 : ℤ))]! ∧ y = a[Int.toNat i]!) → (∀(min2 : ℤ), (if x < min1 then min2 = x else min2 = min1) → (∀(max2 : ℤ), (if max1 < y then max2 = y else max2 = max1) → ((0 : ℤ) ≤ n - i ∧ n - (i + (2 : ℤ)) < n - i) ∧ Int.tmod (i + (2 : ℤ)) (2 : ℤ) = Int.tmod n (2 : ℤ) ∧ is_min min2 a (0 : ℤ) (i + (2 : ℤ)) ∧ is_max max2 a (0 : ℤ) (i + (2 : ℤ))))) else is_min min1 a (0 : ℤ) (Int.ofNat (List.length a)) ∧ is_max max1 a (0 : ℤ) (Int.ofNat (List.length a))))))))
  := sorry
end min_max_Top_a_better_min_maxqtvc
