import Why3.Base
import Why3.why3.Ref.Ref
import Why3.ocaml.Exceptions
open Classical
open Lean4Why3
namespace hillel_challenge_Unique_uniqueqtvc
noncomputable def mem (x : ℤ) (a : List ℤ) (i : ℤ) := ∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < i) ∧ a[Int.toNat j]! = x
theorem unique'vc (a : List ℤ) : let n : ℤ := Int.ofNat (List.length a); ∀(h : Finmap (fun (_ : ℤ) => Unit)), h = (∅ : Finmap (fun (_ : ℤ) => Unit)) → (0 : ℤ) ≤ n ∧ (∀(res : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → res[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length res) = n → (let o1 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (∀(x : ℤ), mem x a (0 : ℤ) = (x ∈ h)) ∧ (∀(x : ℤ), mem x a (0 : ℤ) = mem x res (0 : ℤ)) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < (0 : ℤ) → ¬res[Int.toNat i]! = res[Int.toNat j]!)) ∧ (∀(len : ℤ) (res1 : List ℤ) (h1 : Finmap (fun (_ : ℤ) => Unit)), List.length res1 = List.length res → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ ((0 : ℤ) ≤ len ∧ len ≤ i) ∧ (∀(x : ℤ), mem x a i = (x ∈ h1)) ∧ (∀(x : ℤ), mem x a i = mem x res1 len) ∧ (∀(i1 : ℤ) (j : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < j ∧ j < len → ¬res1[Int.toNat i1]! = res1[Int.toNat j]!) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if ¬a[Int.toNat i]! ∈ h1 then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (∀(h2 : Finmap (fun (_ : ℤ) => Unit)), h2 = Finmap.insert (a[Int.toNat i]!) () h1 → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let o2 : ℤ := a[Int.toNat i]!; ((0 : ℤ) ≤ len ∧ len < Int.ofNat (List.length res1)) ∧ (List.length (List.set res1 (Int.toNat len) o2) = List.length res1 → getElem! (List.set res1 (Int.toNat len) o2) ∘ Int.toNat = Function.update (getElem! res1 ∘ Int.toNat) len o2 → ((0 : ℤ) ≤ len + (1 : ℤ) ∧ len + (1 : ℤ) ≤ i + (1 : ℤ)) ∧ (∀(x : ℤ), mem x a (i + (1 : ℤ)) = (x ∈ h2)) ∧ (∀(x : ℤ), mem x a (i + (1 : ℤ)) = mem x (List.set res1 (Int.toNat len) o2) (len + (1 : ℤ))) ∧ (∀(i1 : ℤ) (j : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < j ∧ j < len + (1 : ℤ) → ¬(List.set res1 (Int.toNat len) o2)[Int.toNat i1]! = (List.set res1 (Int.toNat len) o2)[Int.toNat j]!)))) else ((0 : ℤ) ≤ len ∧ len ≤ i + (1 : ℤ)) ∧ (∀(x : ℤ), mem x a (i + (1 : ℤ)) = (x ∈ h1)) ∧ (∀(x : ℤ), mem x a (i + (1 : ℤ)) = mem x res1 len) ∧ (∀(i1 : ℤ) (j : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < j ∧ j < len → ¬res1[Int.toNat i1]! = res1[Int.toNat j]!))) ∧ (((0 : ℤ) ≤ len ∧ len ≤ o1 + (1 : ℤ)) ∧ (∀(x : ℤ), mem x a (o1 + (1 : ℤ)) = (x ∈ h1)) ∧ (∀(x : ℤ), mem x a (o1 + (1 : ℤ)) = mem x res1 len) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < len → ¬res1[Int.toNat i]! = res1[Int.toNat j]!) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ len ∧ (0 : ℤ) + len ≤ Int.ofNat (List.length res1)) ∧ (∀(result : List ℤ), Int.ofNat (List.length result) = len ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < len → result[Int.toNat i]! = res1[Int.toNat ((0 : ℤ) + i)]!) → (∀(x : ℤ), mem x result (Int.ofNat (List.length result)) = mem x a (Int.ofNat (List.length a))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length result) → ¬result[Int.toNat i]! = result[Int.toNat j]!))))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) + (0 : ℤ) ≤ Int.ofNat (List.length res)) ∧ (∀(result : List ℤ), Int.ofNat (List.length result) = (0 : ℤ) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (0 : ℤ) → result[Int.toNat i]! = res[Int.toNat ((0 : ℤ) + i)]!) → (∀(x : ℤ), mem x result (Int.ofNat (List.length result)) = mem x a (Int.ofNat (List.length a))) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length result) → ¬result[Int.toNat i]! = result[Int.toNat j]!)))))
  := sorry
end hillel_challenge_Unique_uniqueqtvc
