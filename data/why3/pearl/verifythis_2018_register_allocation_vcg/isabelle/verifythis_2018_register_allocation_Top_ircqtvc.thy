theory verifythis_2018_register_allocation_Top_ircqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.ocaml_Exceptions"
begin
typedecl  var
typedecl  set
consts to_fset :: "set \<Rightarrow> var fset"
consts mk :: "var fset \<Rightarrow> set"
axiomatization where mk'spec:   "to_fset (mk s) = s"
  for s :: "var fset"
consts choose1 :: "set \<Rightarrow> var"
axiomatization where choose'spec:   "choose1 s |\<in>| to_fset s"
 if "\<not>to_fset s = fempty"
  for s :: "set"
typedecl 'v t
consts to_fmap :: "'v t \<Rightarrow> (var, 'v) fmap"
consts rem :: "var \<Rightarrow> set t \<Rightarrow> set t"
axiomatization where rem'spec'2:   "\<not>v |\<in>| fmdom (to_fmap (rem v g))"
 if "v |\<in>| fmdom (to_fmap g)"
  for v :: "var"
  and g :: "set t"
axiomatization where rem'spec'1:   "k |\<in>| fmdom (to_fmap (rem v g)) \<longleftrightarrow> \<not>k = v \<and> k |\<in>| fmdom (to_fmap g)"
 if "v |\<in>| fmdom (to_fmap g)"
  for v :: "var"
  and g :: "set t"
  and k :: "var"
axiomatization where rem'spec'0:   "to_fset (the (fmlookup (to_fmap (rem v g)) k)) = fset_remove v (to_fset (the (fmlookup (to_fmap g) k)))"
 if "v |\<in>| fmdom (to_fmap g)"
 and "k |\<in>| fmdom (to_fmap (rem v g))"
  for v :: "var"
  and g :: "set t"
  and k :: "var"
axiomatization where rem'spec:   "int (fcard (fset_of_fmap (to_fmap (rem v g)))) = int (fcard (fset_of_fmap (to_fmap g))) - (1 :: int)"
 if "v |\<in>| fmdom (to_fmap g)"
  for v :: "var"
  and g :: "set t"
consts replace :: "var \<Rightarrow> var \<Rightarrow> set \<Rightarrow> set"
axiomatization where replace'spec'1:   "u |\<in>| to_fset (replace v u s) \<longleftrightarrow> u |\<in>| to_fset s \<or> v |\<in>| to_fset s"
 if "\<not>v = u"
  for v :: "var"
  and u :: "var"
  and s :: "set"
axiomatization where replace'spec'0:   "\<not>v |\<in>| to_fset (replace v u s)"
 if "\<not>v = u"
  for v :: "var"
  and u :: "var"
  and s :: "set"
axiomatization where replace'spec:   "w |\<in>| to_fset (replace v u s) \<longleftrightarrow> w |\<in>| to_fset s"
 if "\<not>v = u"
 and "\<not>w = u"
 and "\<not>w = v"
  for v :: "var"
  and u :: "var"
  and w :: "var"
  and s :: "set"
consts merge :: "var \<Rightarrow> var \<Rightarrow> set t \<Rightarrow> set t"
axiomatization where merge'spec'2:   "k |\<in>| fmdom (to_fmap (merge v u g)) \<longleftrightarrow> \<not>k = v \<and> k |\<in>| fmdom (to_fmap g)"
 if "\<not>v = u"
 and "v |\<in>| fmdom (to_fmap g)"
 and "u |\<in>| fmdom (to_fmap g)"
  for v :: "var"
  and u :: "var"
  and g :: "set t"
  and k :: "var"
axiomatization where merge'spec'1:   "to_fset (the (fmlookup (to_fmap (merge v u g)) u)) = to_fset (replace v u (the (fmlookup (to_fmap g) u))) |\<union>| to_fset (replace v u (the (fmlookup (to_fmap g) v)))"
 if "\<not>v = u"
 and "v |\<in>| fmdom (to_fmap g)"
 and "u |\<in>| fmdom (to_fmap g)"
  for v :: "var"
  and u :: "var"
  and g :: "set t"
axiomatization where merge'spec'0:   "to_fset (the (fmlookup (to_fmap (merge v u g)) k)) = to_fset (replace v u (the (fmlookup (to_fmap g) k)))"
 if "\<not>v = u"
 and "v |\<in>| fmdom (to_fmap g)"
 and "u |\<in>| fmdom (to_fmap g)"
 and "k |\<in>| fmdom (to_fmap (merge v u g))"
 and "\<not>k = u"
  for v :: "var"
  and u :: "var"
  and g :: "set t"
  and k :: "var"
axiomatization where merge'spec:   "int (fcard (fset_of_fmap (to_fmap (merge v u g)))) = int (fcard (fset_of_fmap (to_fmap g))) - (1 :: int)"
 if "\<not>v = u"
 and "v |\<in>| fmdom (to_fmap g)"
 and "u |\<in>| fmdom (to_fmap g)"
  for v :: "var"
  and u :: "var"
  and g :: "set t"
consts all_from :: "set \<Rightarrow> var t \<Rightarrow> set"
axiomatization where all_from'spec:   "v |\<in>| to_fset (all_from s a) \<longleftrightarrow> (\<exists>(k :: var). k |\<in>| to_fset s \<and> fmlookup (to_fmap a) k = Some v)"
  for v :: "var"
  and s :: "set"
  and a :: "var t"
definition no_collision :: "set t \<Rightarrow> var t \<Rightarrow> _"
  where "no_collision g a \<longleftrightarrow> (\<forall>(u :: var) (v :: var). u |\<in>| fmdom (to_fmap g) \<longrightarrow> v |\<in>| fmdom (to_fmap g) \<longrightarrow> u |\<in>| fmdom (to_fmap a) \<longrightarrow> v |\<in>| fmdom (to_fmap a) \<longrightarrow> v |\<in>| to_fset (the (fmlookup (to_fmap g) u)) \<longrightarrow> \<not>the (fmlookup (to_fmap a) u) = the (fmlookup (to_fmap a) v))" for g a
definition irrefl :: "set t \<Rightarrow> _"
  where "irrefl g \<longleftrightarrow> (\<forall>(u :: var). u |\<in>| fmdom (to_fmap g) \<longrightarrow> \<not>u |\<in>| to_fset (the (fmlookup (to_fmap g) u)))" for g
definition sym :: "set t \<Rightarrow> _"
  where "sym g \<longleftrightarrow> (\<forall>(u :: var) (v :: var). u |\<in>| fmdom (to_fmap g) \<longrightarrow> v |\<in>| fmdom (to_fmap g) \<longrightarrow> v |\<in>| to_fset (the (fmlookup (to_fmap g) u)) \<longrightarrow> u |\<in>| to_fset (the (fmlookup (to_fmap g) v)))" for g
theorem irc'vc:
  fixes r :: "set"
  fixes g :: "set t"
  fixes o1 :: "var option"
  assumes fact0: "\<forall>(v :: var). v |\<in>| to_fset r \<longrightarrow> v |\<in>| fmdom (to_fmap g)"
  assumes fact1: "irrefl g"
  assumes fact2: "sym g"
  assumes fact3: "case o1 of None \<Rightarrow> (\<forall>(v :: var). v |\<in>| fmdom (to_fmap g) \<longrightarrow> v |\<in>| to_fset r) | Some v \<Rightarrow> v |\<in>| fmdom (to_fmap g) \<and> \<not>v |\<in>| to_fset r"
  shows "case o1 of None \<Rightarrow> (\<forall>(result :: var t). (\<forall>(u :: var). u |\<in>| fmdom (to_fmap result) \<longleftrightarrow> u |\<in>| to_fset r) \<and> (\<forall>(u :: var). u |\<in>| fmdom (to_fmap result) \<longrightarrow> the (fmlookup (to_fmap result) u) = u) \<longrightarrow> (\<forall>(u :: var). u |\<in>| fmdom (to_fmap result) \<longleftrightarrow> u |\<in>| fmdom (to_fmap g)) \<and> (\<forall>(u :: var) (v :: var). fmlookup (to_fmap result) u = Some v \<longrightarrow> v |\<in>| fmdom (to_fmap g)) \<and> (\<forall>(k :: var). k |\<in>| to_fset r \<longrightarrow> fmlookup (to_fmap result) k = Some k) \<and> no_collision g result) | Some v \<Rightarrow> (\<forall>(o2 :: var option). (case o2 of None \<Rightarrow> True | Some u \<Rightarrow> \<not>u = v \<and> u |\<in>| fmdom (to_fmap g) \<and> \<not>v |\<in>| to_fset (the (fmlookup (to_fmap g) u))) \<longrightarrow> (case o2 of None \<Rightarrow> v |\<in>| fmdom (to_fmap g) \<and> (let s :: set = fm_contents (to_fmap g) v in s = the (fmlookup (to_fmap g) v) \<longrightarrow> v |\<in>| fmdom (to_fmap g) \<and> (let o3 :: set t = rem v g in \<not>v |\<in>| fmdom (to_fmap o3) \<and> (\<forall>(k :: var). k |\<in>| fmdom (to_fmap o3) \<longleftrightarrow> \<not>k = v \<and> k |\<in>| fmdom (to_fmap g)) \<and> (\<forall>(k :: var). k |\<in>| fmdom (to_fmap o3) \<longrightarrow> to_fset (the (fmlookup (to_fmap o3) k)) = fset_remove v (to_fset (the (fmlookup (to_fmap g) k)))) \<and> int (fcard (fset_of_fmap (to_fmap o3))) = int (fcard (fset_of_fmap (to_fmap g))) - (1 :: int) \<longrightarrow> (((0 :: int) \<le> int (fcard (fset_of_fmap (to_fmap g))) \<and> fcard (fset_of_fmap (to_fmap o3)) < fcard (fset_of_fmap (to_fmap g))) \<and> (\<forall>(v1 :: var). v1 |\<in>| to_fset r \<longrightarrow> v1 |\<in>| fmdom (to_fmap o3)) \<and> irrefl o3 \<and> sym o3) \<and> (\<forall>(a :: var t). (\<forall>(u :: var). u |\<in>| fmdom (to_fmap a) \<longleftrightarrow> u |\<in>| fmdom (to_fmap o3)) \<and> (\<forall>(u :: var) (v1 :: var). fmlookup (to_fmap a) u = Some v1 \<longrightarrow> v1 |\<in>| fmdom (to_fmap o3)) \<and> (\<forall>(k :: var). k |\<in>| to_fset r \<longrightarrow> fmlookup (to_fmap a) k = Some k) \<and> no_collision o3 a \<longrightarrow> (\<forall>(o4 :: var option). (case o4 of None \<Rightarrow> (\<forall>(u :: var). u |\<in>| to_fset r \<longrightarrow> (\<exists>(v1 :: var). v1 |\<in>| to_fset s \<and> fmlookup (to_fmap a) v1 = Some u)) | Some res \<Rightarrow> res |\<in>| to_fset r \<and> (\<forall>(v1 :: var). v1 |\<in>| to_fset s \<longrightarrow> v1 |\<in>| fmdom (to_fmap a) \<longrightarrow> \<not>res = the (fmlookup (to_fmap a) v1))) \<longrightarrow> (case o4 of Some av \<Rightarrow> (\<forall>(result :: var t). to_fmap result = fmupd v av (to_fmap a) \<longrightarrow> (\<forall>(u :: var). u |\<in>| fmdom (to_fmap result) \<longleftrightarrow> u |\<in>| fmdom (to_fmap g)) \<and> (\<forall>(u :: var) (v1 :: var). fmlookup (to_fmap result) u = Some v1 \<longrightarrow> v1 |\<in>| fmdom (to_fmap g)) \<and> (\<forall>(k :: var). k |\<in>| to_fset r \<longrightarrow> fmlookup (to_fmap result) k = Some k) \<and> no_collision g result) | None \<Rightarrow> (\<forall>(result :: var t). to_fmap result = fmupd v v (to_fmap a) \<longrightarrow> (\<forall>(u :: var). u |\<in>| fmdom (to_fmap result) \<longleftrightarrow> u |\<in>| fmdom (to_fmap g)) \<and> (\<forall>(u :: var) (v1 :: var). fmlookup (to_fmap result) u = Some v1 \<longrightarrow> v1 |\<in>| fmdom (to_fmap g)) \<and> (\<forall>(k :: var). k |\<in>| to_fset r \<longrightarrow> fmlookup (to_fmap result) k = Some k) \<and> no_collision g result)))))) | Some u \<Rightarrow> (\<not>v = u \<and> v |\<in>| fmdom (to_fmap g) \<and> u |\<in>| fmdom (to_fmap g)) \<and> (let o3 :: set t = merge v u g in (\<forall>(k :: var). k |\<in>| fmdom (to_fmap o3) \<longleftrightarrow> \<not>k = v \<and> k |\<in>| fmdom (to_fmap g)) \<and> to_fset (the (fmlookup (to_fmap o3) u)) = to_fset (replace v u (the (fmlookup (to_fmap g) u))) |\<union>| to_fset (replace v u (the (fmlookup (to_fmap g) v))) \<and> (\<forall>(k :: var). k |\<in>| fmdom (to_fmap o3) \<longrightarrow> \<not>k = u \<longrightarrow> to_fset (the (fmlookup (to_fmap o3) k)) = to_fset (replace v u (the (fmlookup (to_fmap g) k)))) \<and> int (fcard (fset_of_fmap (to_fmap o3))) = int (fcard (fset_of_fmap (to_fmap g))) - (1 :: int) \<longrightarrow> (((0 :: int) \<le> int (fcard (fset_of_fmap (to_fmap g))) \<and> fcard (fset_of_fmap (to_fmap o3)) < fcard (fset_of_fmap (to_fmap g))) \<and> (\<forall>(v1 :: var). v1 |\<in>| to_fset r \<longrightarrow> v1 |\<in>| fmdom (to_fmap o3)) \<and> irrefl o3 \<and> sym o3) \<and> (\<forall>(a :: var t). (\<forall>(u1 :: var). u1 |\<in>| fmdom (to_fmap a) \<longleftrightarrow> u1 |\<in>| fmdom (to_fmap o3)) \<and> (\<forall>(u1 :: var) (v1 :: var). fmlookup (to_fmap a) u1 = Some v1 \<longrightarrow> v1 |\<in>| fmdom (to_fmap o3)) \<and> (\<forall>(k :: var). k |\<in>| to_fset r \<longrightarrow> fmlookup (to_fmap a) k = Some k) \<and> no_collision o3 a \<longrightarrow> u |\<in>| fmdom (to_fmap a) \<and> (let o4 :: var = fm_contents (to_fmap a) u in o4 = the (fmlookup (to_fmap a) u) \<longrightarrow> (\<forall>(result :: var t). to_fmap result = fmupd v o4 (to_fmap a) \<longrightarrow> (\<forall>(u1 :: var). u1 |\<in>| fmdom (to_fmap result) \<longleftrightarrow> u1 |\<in>| fmdom (to_fmap g)) \<and> (\<forall>(u1 :: var) (v1 :: var). fmlookup (to_fmap result) u1 = Some v1 \<longrightarrow> v1 |\<in>| fmdom (to_fmap g)) \<and> (\<forall>(k :: var). k |\<in>| to_fset r \<longrightarrow> fmlookup (to_fmap result) k = Some k) \<and> no_collision g result))))))"
  sorry
end
