import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
import Why3.map.MapExchange
open Classical
open Lean4Why3
namespace mex_MexArrayInPlace_mexqtvc
noncomputable def mem (x : ℤ) (a : List ℤ) := ∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ a[Int.toNat i]! = x
axiom placed : List ℤ -> ℤ -> Bool
axiom placed'def (a : List ℤ) (i : ℤ) : (placed a i = true) = (a[Int.toNat i]! = i)
theorem mex'vc (a : List ℤ) : let n : ℤ := Int.ofNat (List.length a); (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → (0 : ℤ) ≤ a[Int.toNat j]! ∧ a[Int.toNat j]! < n → a[Int.toNat (a[Int.toNat j]!)]! = a[Int.toNat j]!)) ∧ (∀(i : ℤ) (a1 : List ℤ), List.length a1 = List.length a → ((0 : ℤ) ≤ i ∧ i ≤ n) ∧ (∀(x : ℤ), mem x a1 = mem x a) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → (0 : ℤ) ≤ a1[Int.toNat j]! ∧ a1[Int.toNat j]! < n → a1[Int.toNat (a1[Int.toNat j]!)]! = a1[Int.toNat j]!) → (if i < n then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (let x : ℤ := a1[Int.toNat i]!; (¬x < (0 : ℤ) → ¬n ≤ x → (0 : ℤ) ≤ x ∧ x < Int.ofNat (List.length a1)) ∧ (∀(o1 : Bool), (if x < (0 : ℤ) then o1 = true else if n ≤ x then o1 = true else o1 = (if a1[Int.toNat x]! = x then true else false)) → (if o1 = true then ((0 : ℤ) ≤ n - i + n - NumOf.numof (placed a1) (0 : ℤ) n ∧ n - (i + (1 : ℤ)) + n - NumOf.numof (placed a1) (0 : ℤ) n < n - i + n - NumOf.numof (placed a1) (0 : ℤ) n) ∧ ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ n) ∧ (∀(x1 : ℤ), mem x1 a1 = mem x1 a) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → (0 : ℤ) ≤ a1[Int.toNat j]! ∧ a1[Int.toNat j]! < n → a1[Int.toNat (a1[Int.toNat j]!)]! = a1[Int.toNat j]!) else if x < i then (((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ x ∧ x < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 i x → ((0 : ℤ) ≤ n - i + n - NumOf.numof (placed a1) (0 : ℤ) n ∧ n - (i + (1 : ℤ)) + n - NumOf.numof (placed a2) (0 : ℤ) n < n - i + n - NumOf.numof (placed a1) (0 : ℤ) n) ∧ ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ n) ∧ (∀(x1 : ℤ), mem x1 a2 = mem x1 a) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → (0 : ℤ) ≤ a2[Int.toNat j]! ∧ a2[Int.toNat j]! < n → a2[Int.toNat (a2[Int.toNat j]!)]! = a2[Int.toNat j]!)) else (((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ x ∧ x < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 i x → ((0 : ℤ) ≤ n - i + n - NumOf.numof (placed a1) (0 : ℤ) n ∧ n - i + n - NumOf.numof (placed a2) (0 : ℤ) n < n - i + n - NumOf.numof (placed a1) (0 : ℤ) n) ∧ ((0 : ℤ) ≤ i ∧ i ≤ n) ∧ (∀(x1 : ℤ), mem x1 a2 = mem x1 a) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → (0 : ℤ) ≤ a2[Int.toNat j]! ∧ a2[Int.toNat j]! < n → a2[Int.toNat (a2[Int.toNat j]!)]! = a2[Int.toNat j]!))))) else let o1 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → a1[Int.toNat j]! = j) ∧ (∀(i1 : ℤ), ((0 : ℤ) ≤ i1 ∧ i1 ≤ o1) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i1 → a1[Int.toNat j]! = j) → ((0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a1)) ∧ (if ¬a1[Int.toNat i1]! = i1 then ((0 : ℤ) ≤ i1 ∧ i1 ≤ Int.ofNat (List.length a1)) ∧ ¬mem i1 a ∧ (∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < i1 → mem x a) else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i1 + (1 : ℤ) → a1[Int.toNat j]! = j)) ∧ ((∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < o1 + (1 : ℤ) → a1[Int.toNat j]! = j) → ((0 : ℤ) ≤ n ∧ n ≤ Int.ofNat (List.length a1)) ∧ ¬mem n a ∧ (∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < n → mem x a))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → ((0 : ℤ) ≤ n ∧ n ≤ Int.ofNat (List.length a1)) ∧ ¬mem n a ∧ (∀(x : ℤ), (0 : ℤ) ≤ x ∧ x < n → mem x a))))
  := sorry
end mex_MexArrayInPlace_mexqtvc
