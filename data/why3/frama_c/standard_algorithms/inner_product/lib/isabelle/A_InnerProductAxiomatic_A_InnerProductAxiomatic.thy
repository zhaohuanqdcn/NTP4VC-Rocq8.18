theory A_InnerProductAxiomatic_A_InnerProductAxiomatic
  imports "NTP4Verif.NTP4Verif" "Why3STD.Qed_Qed" "Why3STD.Memory_Memory" "Why3STD.Cint_Cint" "../../lib/isabelle/Compound_Compound" "../../lib/isabelle/Axiomatic_Axiomatic"
begin
consts l_innerproduct :: "(addr \<Rightarrow> int) \<Rightarrow> addr \<Rightarrow> addr \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int"
axiomatization where Q_InnerProductEmpty:   "l_innerproduct mint_0 a b n init_0 = init_0"
 if "n \<le> (0 :: int)"
 and "is_sint32 init_0"
  for n :: "int"
  and init_0 :: "int"
  and mint_0 :: "addr \<Rightarrow> int"
  and a :: "addr"
  and b :: "addr"
axiomatization where Q_InnerProductNext:   "(0 :: int) < n \<longrightarrow> is_sint32 init_0 \<longrightarrow> l_innerproduct mint_0 a b (n - (1 :: int)) init_0 + mint_0 (shift a (n - (1 :: int))) * mint_0 (shift b (n - (1 :: int))) = l_innerproduct mint_0 a b n init_0"
  for n :: "int"
  and init_0 :: "int"
  and mint_0 :: "addr \<Rightarrow> int"
  and a :: "addr"
  and b :: "addr"
axiomatization where Q_InnerProductRead:   "l_innerproduct mint_1 a b n init_0 = l_innerproduct mint_0 a b n init_0"
 if "is_sint32 init_0"
 and "p_unchanged_1' mint_0 mint_1 a (0 :: int) n"
 and "p_unchanged_1' mint_0 mint_1 b (0 :: int) n"
  for init_0 :: "int"
  and mint_0 :: "addr \<Rightarrow> int"
  and mint_1 :: "addr \<Rightarrow> int"
  and a :: "addr"
  and n :: "int"
  and b :: "addr"
end
