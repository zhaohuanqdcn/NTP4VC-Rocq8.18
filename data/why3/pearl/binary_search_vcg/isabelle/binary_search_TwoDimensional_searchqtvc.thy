theory binary_search_TwoDimensional_searchqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.matrix_Matrix"
begin
theorem search'vc:
  fixes m :: "int matrix"
  fixes v :: "int"
  assumes fact0: "\<forall>(i :: int). (0 :: int) \<le> i \<and> i < rows m \<longrightarrow> (\<forall>(j1 :: int) (j2 :: int). (0 :: int) \<le> j1 \<and> j1 \<le> j2 \<and> j2 < columns m \<longrightarrow> get m i j1 \<le> get m i j2)"
  assumes fact1: "\<forall>(j :: int). (0 :: int) \<le> j \<and> j < columns m \<longrightarrow> (\<forall>(i1 :: int) (i2 :: int). (0 :: int) \<le> i1 \<and> i1 \<le> i2 \<and> i2 < rows m \<longrightarrow> get m i1 j \<le> get m i2 j)"
  shows "let o1 :: int = columns m - (1 :: int) in (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> rows m) \<and> (-(1 :: int) \<le> o1 \<and> o1 < columns m) \<and> (\<forall>(i' :: int) (j' :: int). (0 :: int) \<le> i' \<and> i' < rows m \<longrightarrow> (0 :: int) \<le> j' \<and> j' < columns m \<longrightarrow> i' < (0 :: int) \<or> o1 < j' \<longrightarrow> \<not>get m i' j' = v)) \<and> (\<forall>(j :: int) (i :: int). ((0 :: int) \<le> i \<and> i \<le> rows m) \<and> (-(1 :: int) \<le> j \<and> j < columns m) \<and> (\<forall>(i' :: int) (j' :: int). (0 :: int) \<le> i' \<and> i' < rows m \<longrightarrow> (0 :: int) \<le> j' \<and> j' < columns m \<longrightarrow> i' < i \<or> j < j' \<longrightarrow> \<not>get m i' j' = v) \<longrightarrow> (\<forall>(o2 :: bool). (if i < rows m then o2 = (if (0 :: int) \<le> j then True else False) else o2 = False) \<longrightarrow> (if o2 = True then valid_index m i j \<and> (let x :: int = elts m i j in if x = v then \<exists>(i1 :: int) (j1 :: int). ((0 :: int) \<le> i1 \<and> i1 < rows m) \<and> ((0 :: int) \<le> j1 \<and> j1 < columns m) \<and> get m i1 j1 = v else if x < v then ((0 :: int) \<le> rows m - i + j \<and> rows m - (i + (1 :: int)) + j < rows m - i + j) \<and> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> rows m) \<and> (-(1 :: int) \<le> j \<and> j < columns m) \<and> (\<forall>(i' :: int) (j' :: int). (0 :: int) \<le> i' \<and> i' < rows m \<longrightarrow> (0 :: int) \<le> j' \<and> j' < columns m \<longrightarrow> i' < i + (1 :: int) \<or> j < j' \<longrightarrow> \<not>get m i' j' = v) else ((0 :: int) \<le> rows m - i + j \<and> rows m - i + (j - (1 :: int)) < rows m - i + j) \<and> ((0 :: int) \<le> i \<and> i \<le> rows m) \<and> (-(1 :: int) \<le> j - (1 :: int) \<and> j - (1 :: int) < columns m) \<and> (\<forall>(i' :: int) (j' :: int). (0 :: int) \<le> i' \<and> i' < rows m \<longrightarrow> (0 :: int) \<le> j' \<and> j' < columns m \<longrightarrow> i' < i \<or> j - (1 :: int) < j' \<longrightarrow> \<not>get m i' j' = v)) else \<not>(\<exists>(i1 :: int) (j1 :: int). ((0 :: int) \<le> i1 \<and> i1 < rows m) \<and> ((0 :: int) \<le> j1 \<and> j1 < columns m) \<and> get m i1 j1 = v))))"
  sorry
end
