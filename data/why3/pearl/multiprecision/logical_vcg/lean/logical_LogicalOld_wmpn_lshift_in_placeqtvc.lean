import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
open Classical
open Lean4Why3
namespace logical_LogicalOld_wmpn_lshift_in_placeqtvc
theorem wmpn_lshift_in_place'vc (cnt : BitVec 64) (x : C.ptr (BitVec 64)) (sz : BitVec 32) (fact0 : (0 : ℤ) < BitVec.toUInt cnt) (fact1 : BitVec.toUInt cnt < (64 : ℤ)) (fact2 : C.valid x (BitVec.toInt sz)) (fact3 : C.writable x = true) (fact4 : (0 : ℤ) < BitVec.toInt sz) : int'32_in_bounds (BitVec.toInt sz - (1 : ℤ)) ∧ (∀(msb : BitVec 32), BitVec.toInt msb = BitVec.toInt sz - (1 : ℤ) → (C.min x ≤ C.offset x + BitVec.toInt msb ∧ C.offset x + BitVec.toInt msb ≤ C.max x) ∧ (∀(o1 : C.ptr (BitVec 64)), C.offset o1 = C.offset x + BitVec.toInt msb ∧ C.plength o1 = C.plength x ∧ C.pelts o1 = C.pelts x ∧ C.data o1 = C.data x ∧ C.min o1 = C.min x ∧ C.max o1 = C.max x ∧ C.zone1 o1 = C.zone1 x ∧ C.writable o1 = C.writable x → (C.min x ≤ C.offset x + BitVec.toInt msb ∧ C.offset x + BitVec.toInt msb ≤ C.max x) ∧ (∀(o2 : C.ptr (BitVec 64)), C.offset o2 = C.offset x + BitVec.toInt msb ∧ C.plength o2 = C.plength x ∧ C.pelts o2 = C.pelts x ∧ C.data o2 = C.data x ∧ C.min o2 = C.min x ∧ C.max o2 = C.max x ∧ C.zone1 o2 = C.zone1 x ∧ C.writable o2 = C.writable x → (C.min o1 ≤ C.offset o1 ∧ C.offset o1 < C.max o1) ∧ ((0 : ℤ) < BitVec.toUInt cnt ∧ BitVec.toUInt cnt < (64 : ℤ)) ∧ (∀(l : BitVec 64) (retval : BitVec 64), BitVec.toUInt l + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt retval = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) * BitVec.toUInt (C.pelts o1 (C.offset o1)) ∧ BitVec.toUInt l % HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) = (0 : ℤ) ∧ BitVec.toUInt l ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) ∧ BitVec.toUInt retval < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) → (let c : ℤ := HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)); (((0 : ℤ) ≤ BitVec.toInt msb ∧ BitVec.toInt msb < BitVec.toInt sz) ∧ ((18446744073709551615 : ℤ) + (1 : ℤ)) * Lemmas.value_sub (C.pelts x) (C.offset x + BitVec.toInt msb + (1 : ℤ)) (C.offset x + BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz - BitVec.toInt msb)) * BitVec.toUInt retval + BitVec.toUInt l = Lemmas.value o2 (BitVec.toInt sz - BitVec.toInt msb) * c ∧ C.offset o1 = C.offset x + BitVec.toInt msb ∧ C.offset o2 = C.offset x + BitVec.toInt msb ∧ C.plength o2 = C.plength x ∧ C.min o2 = C.min x ∧ C.max o2 = C.max x ∧ C.pelts o2 = C.pelts x ∧ C.plength o1 = C.plength x ∧ C.min o1 = C.min x ∧ C.max o1 = C.max x ∧ C.writable o1 = true ∧ C.pelts o1 = C.pelts x ∧ BitVec.toUInt l ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - c) ∧ (∀(i : BitVec 32) (high : BitVec 64) (oxp : C.ptr (BitVec 64)) (xp : C.ptr (BitVec 64)) (x1 : C.ptr (BitVec 64)), List.length (C.data x1) = List.length (C.data x) ∧ C.offset x1 = C.offset x ∧ C.min x1 = C.min x ∧ C.max x1 = C.max x ∧ C.writable x1 = C.writable x ∧ C.zone1 x1 = C.zone1 x → ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i < BitVec.toInt sz) ∧ ((18446744073709551615 : ℤ) + (1 : ℤ)) * Lemmas.value_sub (C.pelts x1) (C.offset x1 + BitVec.toInt i + (1 : ℤ)) (C.offset x1 + BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz - BitVec.toInt i)) * BitVec.toUInt retval + BitVec.toUInt high = Lemmas.value oxp (BitVec.toInt sz - BitVec.toInt i) * c ∧ C.offset xp = C.offset x1 + BitVec.toInt i ∧ C.offset oxp = C.offset x1 + BitVec.toInt i ∧ C.plength oxp = C.plength x1 ∧ C.min oxp = C.min x1 ∧ C.max oxp = C.max x1 ∧ C.pelts oxp = C.pelts x ∧ C.plength xp = C.plength x1 ∧ C.min xp = C.min x1 ∧ C.max xp = C.max x1 ∧ C.writable xp = true ∧ C.pelts xp = C.pelts x1 ∧ BitVec.toUInt high ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - c ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ BitVec.toInt i → C.pelts x1 (C.offset x1 + j) = C.pelts x (C.offset x1 + j)) → (if (0 : ℤ) < BitVec.toInt i then (C.min xp ≤ C.offset xp + -(1 : ℤ) ∧ C.offset xp + -(1 : ℤ) ≤ C.max xp) ∧ (∀(o3 : C.ptr (BitVec 64)), C.offset o3 = C.offset xp + -(1 : ℤ) ∧ C.plength o3 = C.plength xp ∧ C.pelts o3 = C.pelts xp ∧ C.data o3 = C.data xp ∧ C.min o3 = C.min xp ∧ C.max o3 = C.max xp ∧ C.zone1 o3 = C.zone1 xp ∧ C.writable o3 = C.writable xp → (C.min oxp ≤ C.offset oxp + -(1 : ℤ) ∧ C.offset oxp + -(1 : ℤ) ≤ C.max oxp) ∧ (∀(o4 : C.ptr (BitVec 64)), C.offset o4 = C.offset oxp + -(1 : ℤ) ∧ C.plength o4 = C.plength oxp ∧ C.pelts o4 = C.pelts oxp ∧ C.data o4 = C.data oxp ∧ C.min o4 = C.min oxp ∧ C.max o4 = C.max oxp ∧ C.zone1 o4 = C.zone1 oxp ∧ C.writable o4 = C.writable oxp → (C.min o3 ≤ C.offset o3 ∧ C.offset o3 < C.max o3) ∧ (C.min o4 ≤ C.offset o4 ∧ C.offset o4 < C.max o4) ∧ ((0 : ℤ) < BitVec.toUInt cnt ∧ BitVec.toUInt cnt < (64 : ℤ)) ∧ (∀(l1 : BitVec 64) (h : BitVec 64), BitVec.toUInt l1 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt h = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) * BitVec.toUInt (C.pelts o3 (C.offset o3)) ∧ BitVec.toUInt l1 % HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) = (0 : ℤ) ∧ BitVec.toUInt l1 ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) ∧ BitVec.toUInt h < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt)) → uint'64_in_bounds (BitVec.toUInt high + BitVec.toUInt h) ∧ (∀(v : BitVec 64), BitVec.toUInt v = BitVec.toUInt high + BitVec.toUInt h → uint'64_in_bounds (BitVec.toUInt high + BitVec.toUInt h) ∧ (∀(o5 : BitVec 64), BitVec.toUInt o5 = BitVec.toUInt high + BitVec.toUInt h → ((C.min o3 ≤ C.offset o3 + (1 : ℤ) ∧ C.offset o3 + (1 : ℤ) < C.max o3) ∧ C.writable o3 = true) ∧ (∀(xp1 : C.ptr (BitVec 64)) (x2 : C.ptr (BitVec 64)), C.data xp1 = C.data x2 ∧ List.length (C.data x2) = List.length (C.data o3) ∧ C.offset xp1 = C.offset o3 ∧ C.min xp1 = C.min o3 ∧ C.max xp1 = C.max o3 ∧ C.writable xp1 = C.writable o3 ∧ C.zone1 xp1 = C.zone1 o3 → C.data xp1 = C.data x2 ∧ List.length (C.data x2) = List.length (C.data o3) ∧ C.offset xp1 = C.offset o3 ∧ C.min xp1 = C.min o3 ∧ C.max xp1 = C.max o3 ∧ C.writable xp1 = C.writable o3 ∧ C.zone1 xp1 = C.zone1 o3 → List.length (C.data x2) = List.length (C.data x1) ∧ C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.max x2 = C.max x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → C.pelts xp1 = Function.update (C.pelts o3) (C.offset xp1 + (1 : ℤ)) o5 ∧ C.pelts xp1 (C.offset xp1 + (1 : ℤ)) = o5 → int'32_in_bounds (BitVec.toInt i - (1 : ℤ)) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt i - (1 : ℤ) → BitVec.toInt o6 < BitVec.toInt i ∧ ((0 : ℤ) ≤ BitVec.toInt o6 ∧ BitVec.toInt o6 < BitVec.toInt sz) ∧ ((18446744073709551615 : ℤ) + (1 : ℤ)) * Lemmas.value_sub (C.pelts x2) (C.offset x2 + BitVec.toInt o6 + (1 : ℤ)) (C.offset x2 + BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz - BitVec.toInt o6)) * BitVec.toUInt retval + BitVec.toUInt l1 = Lemmas.value o4 (BitVec.toInt sz - BitVec.toInt o6) * c ∧ C.offset xp1 = C.offset x2 + BitVec.toInt o6 ∧ C.offset o4 = C.offset x2 + BitVec.toInt o6 ∧ C.plength o4 = C.plength x2 ∧ C.min o4 = C.min x2 ∧ C.max o4 = C.max x2 ∧ C.pelts o4 = C.pelts x ∧ C.plength xp1 = C.plength x2 ∧ C.min xp1 = C.min x2 ∧ C.max xp1 = C.max x2 ∧ C.writable xp1 = true ∧ C.pelts xp1 = C.pelts x2 ∧ BitVec.toUInt l1 ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - c ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j ≤ BitVec.toInt o6 → C.pelts x2 (C.offset x2 + j) = C.pelts x (C.offset x2 + j))))))))) else ((C.min x1 ≤ C.offset x1 ∧ C.offset x1 < C.max x1) ∧ C.writable x1 = true) ∧ (∀(x2 : C.ptr (BitVec 64)), List.length (C.data x2) = List.length (C.data x1) ∧ C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.max x2 = C.max x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → C.pelts x2 = Function.update (C.pelts x1) (C.offset x2) high → Lemmas.value x2 (BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz)) * BitVec.toUInt retval = Lemmas.value x (BitVec.toInt sz) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt))))))))))
  := sorry
end logical_LogicalOld_wmpn_lshift_in_placeqtvc
