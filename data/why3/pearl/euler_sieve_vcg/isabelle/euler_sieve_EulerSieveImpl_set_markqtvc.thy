theory euler_sieve_EulerSieveImpl_set_markqtvc
  imports "NTP4Verif.NTP4Verif" "./euler_sieve_ArithmeticResults" "./euler_sieve_DivisibilityResults" "./euler_sieve_EulerSieveSpec" "mach.array_ArrayInt63"
begin
typedecl  t
consts nexts :: "t \<Rightarrow> int list"
consts marked :: "t \<Rightarrow> bool list"
consts arr :: "t \<Rightarrow> array_ArrayInt63.array63"
consts max :: "t \<Rightarrow> 63 word"
consts max_arr :: "t \<Rightarrow> 63 word"
axiomatization where t'invariant'0:   "sint (max self) < sint int'63_max"
  for self :: "t"
axiomatization where t'invariant'1:   "(3 :: int) \<le> sint (max self)"
  for self :: "t"
axiomatization where t'invariant'2:   "length (nexts self) = length (marked self)"
  for self :: "t"
axiomatization where t'invariant'3:   "int (length (marked self)) = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'4:   "(sint (max self) - (1 :: int)) ediv (2 :: int) = sint (max_arr self)"
  for self :: "t"
axiomatization where t'invariant'5:   "int (length (elts (arr self))) = sint (max_arr self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'6:   "inv_nexts (nexts self) (int (length (nexts self)))"
  for self :: "t"
axiomatization where t'invariant'7:   "all_eliminated_marked (marked self) (nexts self)"
  for self :: "t"
axiomatization where t'invariant'8:   "\<forall>(i :: int). (3 :: int) \<le> i \<and> i \<le> sint (max self) \<longrightarrow> i emod (2 :: int) = (0 :: int) \<longrightarrow> marked self ! nat i = True"
  for self :: "t"
axiomatization where t'invariant'9:   "\<forall>(i :: int). (3 :: int) \<le> i \<and> i < sint (max self) - (1 :: int) \<longrightarrow> i emod (2 :: int) = (1 :: int) \<longrightarrow> nexts self ! nat i emod (2 :: int) = (1 :: int) \<or> nexts self ! nat i = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'10:   "nexts self ! nat (sint (max self)) = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'11:   "(sint (max self) - (1 :: int)) emod (2 :: int) = (0 :: int) \<longrightarrow> nexts self ! nat (sint (max self) - (1 :: int)) = sint (max self)"
  for self :: "t"
axiomatization where t'invariant'12:   "(sint (max self) - (1 :: int)) emod (2 :: int) = (1 :: int) \<longrightarrow> nexts self ! nat (sint (max self) - (1 :: int)) = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'13:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> -(sint (max self) + (1 :: int)) \<le> elts (arr self) ! nat i \<and> elts (arr self) ! nat i \<le> sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'14:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> marked self ! nat ((2 :: int) * i + (1 :: int)) = True \<longleftrightarrow> elts (arr self) ! nat i < (0 :: int)"
  for self :: "t"
axiomatization where t'invariant'15:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> \<not>marked self ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts (arr self) ! nat i = nexts self ! nat ((2 :: int) * i + (1 :: int))"
  for self :: "t"
axiomatization where t'invariant'16:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> marked self ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts (arr self) ! nat i = -nexts self ! nat ((2 :: int) * i + (1 :: int))"
  for self :: "t"
axiomatization where t'invariant'17:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> (i < abs (elts (arr self) ! nat i) ediv (2 :: int) \<and> abs (elts (arr self) ! nat i) ediv (2 :: int) \<le> sint (max_arr self) + (1 :: int)) \<and> abs (elts (arr self) ! nat i) \<le> sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'18:   "\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> i < j \<and> j < abs (elts (arr self) ! nat i) ediv (2 :: int) \<longrightarrow> elts (arr self) ! nat j < (0 :: int)"
  for self :: "t"
definition t'eq :: "t \<Rightarrow> t \<Rightarrow> _"
  where "t'eq a b \<longleftrightarrow> nexts a = nexts b \<and> marked a = marked b \<and> arr a = arr b \<and> max a = max b \<and> max_arr a = max_arr b" for a b
axiomatization where t'inj:   "a = b"
 if "t'eq a b"
  for a :: "t"
  and b :: "t"
theorem set_mark'vc:
  fixes i :: "63 word"
  fixes t1 :: "t"
  assumes fact0: "(0 :: int) \<le> sint i"
  assumes fact1: "sint i \<le> sint (max t1)"
  assumes fact2: "sint i emod (2 :: int) = (1 :: int)"
  shows "\<not>(2 :: int) = (0 :: int)"
  and "int'63_in_bounds (sint i cdiv (2 :: int))"
  and "\<forall>(x :: 63 word). sint x = sint i cdiv (2 :: int) \<longrightarrow> (let o1 :: array_ArrayInt63.array63 = arr t1 in ((0 :: int) \<le> sint x \<and> sint x < int (length (elts o1))) \<and> (\<forall>(o2 :: 63 word). sint o2 = elts o1 ! nat (sint x) \<longrightarrow> (if (0 :: int) \<le> sint o2 then let o3 :: array_ArrayInt63.array63 = arr t1 in ((0 :: int) \<le> sint x \<and> sint x < int (length (elts o3))) \<and> (\<forall>(o4 :: 63 word). sint o4 = elts o3 ! nat (sint x) \<longrightarrow> int'63_in_bounds (-sint o4) \<and> (\<forall>(o5 :: 63 word). sint o5 = -sint o4 \<longrightarrow> (let o6 :: array_ArrayInt63.array63 = arr t1 in ((0 :: int) \<le> sint x \<and> sint x < int (length (elts o6))) \<and> (\<forall>(t_arr :: array_ArrayInt63.array63). array_ArrayInt63.size t_arr = array_ArrayInt63.size o6 \<longrightarrow> array_ArrayInt63.size t_arr = array_ArrayInt63.size (arr t1) \<longrightarrow> elts t_arr = (elts o6)[nat (sint x) := sint o5] \<longrightarrow> (let o7 :: bool = True; o8 :: int = sint i in ((0 :: int) \<le> o8 \<and> o8 < int (length (marked t1))) \<and> (let o9 :: bool list = (marked t1)[nat o8 := o7] in length o9 = length (marked t1) \<and> o9 ! nat o8 = o7 \<and> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < int (length (marked t1))) \<and> \<not>j = o8 \<longrightarrow> o9 ! nat j = marked t1 ! nat j) \<longrightarrow> (\<forall>(t2 :: t). ((sint (max t1) < sint int'63_max \<and> (3 :: int) \<le> sint (max t1)) \<and> (length (nexts t1) = length o9 \<and> int (length o9) = sint (max t1) + (1 :: int)) \<and> (sint (max t1) - (1 :: int)) ediv (2 :: int) = sint (max_arr t1) \<and> int (length (elts t_arr)) = sint (max_arr t1) + (1 :: int) \<and> inv_nexts (nexts t1) (int (length (nexts t1))) \<and> all_eliminated_marked o9 (nexts t1) \<and> (\<forall>(i1 :: int). (3 :: int) \<le> i1 \<and> i1 \<le> sint (max t1) \<longrightarrow> i1 emod (2 :: int) = (0 :: int) \<longrightarrow> o9 ! nat i1 = True) \<and> (\<forall>(i1 :: int). (3 :: int) \<le> i1 \<and> i1 < sint (max t1) - (1 :: int) \<longrightarrow> i1 emod (2 :: int) = (1 :: int) \<longrightarrow> nexts t1 ! nat i1 emod (2 :: int) = (1 :: int) \<or> nexts t1 ! nat i1 = sint (max t1) + (1 :: int)) \<and> (nexts t1 ! nat (sint (max t1)) = sint (max t1) + (1 :: int) \<and> ((sint (max t1) - (1 :: int)) emod (2 :: int) = (0 :: int) \<longrightarrow> nexts t1 ! nat (sint (max t1) - (1 :: int)) = sint (max t1)) \<and> ((sint (max t1) - (1 :: int)) emod (2 :: int) = (1 :: int) \<longrightarrow> nexts t1 ! nat (sint (max t1) - (1 :: int)) = sint (max t1) + (1 :: int))) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 \<le> sint (max_arr t1) \<longrightarrow> -(sint (max t1) + (1 :: int)) \<le> elts t_arr ! nat i1 \<and> elts t_arr ! nat i1 \<le> sint (max t1) + (1 :: int)) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 \<le> sint (max_arr t1) \<longrightarrow> o9 ! nat ((2 :: int) * i1 + (1 :: int)) = True \<longleftrightarrow> elts t_arr ! nat i1 < (0 :: int)) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 \<le> sint (max_arr t1) \<longrightarrow> \<not>o9 ! nat ((2 :: int) * i1 + (1 :: int)) = True \<longrightarrow> elts t_arr ! nat i1 = nexts t1 ! nat ((2 :: int) * i1 + (1 :: int))) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 \<le> sint (max_arr t1) \<longrightarrow> o9 ! nat ((2 :: int) * i1 + (1 :: int)) = True \<longrightarrow> elts t_arr ! nat i1 = -nexts t1 ! nat ((2 :: int) * i1 + (1 :: int))) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 \<le> sint (max_arr t1) \<longrightarrow> (i1 < abs (elts t_arr ! nat i1) ediv (2 :: int) \<and> abs (elts t_arr ! nat i1) ediv (2 :: int) \<le> sint (max_arr t1) + (1 :: int)) \<and> abs (elts t_arr ! nat i1) \<le> sint (max t1) + (1 :: int)) \<and> (\<forall>(i1 :: int) (j :: int). (0 :: int) \<le> i1 \<and> i1 \<le> sint (max_arr t1) \<longrightarrow> i1 < j \<and> j < abs (elts t_arr ! nat i1) ediv (2 :: int) \<longrightarrow> elts t_arr ! nat j < (0 :: int))) \<and> (max_arr t1 = max_arr t2 \<and> max t1 = max t2 \<and> t_arr = arr t2 \<and> o9 = marked t2 \<and> nexts t1 = nexts t2 \<longrightarrow> marked t2 = (marked t1)[nat (sint i) := True])))))))) else let o3 :: bool = True; o4 :: int = sint i; o5 :: bool list = marked t1 in ((0 :: int) \<le> o4 \<and> o4 < int (length o5)) \<and> (let o6 :: bool list = o5[nat o4 := o3] in length o6 = length o5 \<and> o6 ! nat o4 = o3 \<and> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < int (length o5)) \<and> \<not>j = o4 \<longrightarrow> o6 ! nat j = o5 ! nat j) \<longrightarrow> (\<forall>(t2 :: t). ((sint (max t1) < sint int'63_max \<and> (3 :: int) \<le> sint (max t1)) \<and> (length (nexts t1) = length o6 \<and> int (length o6) = sint (max t1) + (1 :: int)) \<and> (sint (max t1) - (1 :: int)) ediv (2 :: int) = sint (max_arr t1) \<and> int (length (elts (arr t1))) = sint (max_arr t1) + (1 :: int) \<and> inv_nexts (nexts t1) (int (length (nexts t1))) \<and> all_eliminated_marked o6 (nexts t1) \<and> (\<forall>(i1 :: int). (3 :: int) \<le> i1 \<and> i1 \<le> sint (max t1) \<longrightarrow> i1 emod (2 :: int) = (0 :: int) \<longrightarrow> o6 ! nat i1 = True) \<and> (\<forall>(i1 :: int). (3 :: int) \<le> i1 \<and> i1 < sint (max t1) - (1 :: int) \<longrightarrow> i1 emod (2 :: int) = (1 :: int) \<longrightarrow> nexts t1 ! nat i1 emod (2 :: int) = (1 :: int) \<or> nexts t1 ! nat i1 = sint (max t1) + (1 :: int)) \<and> (nexts t1 ! nat (sint (max t1)) = sint (max t1) + (1 :: int) \<and> ((sint (max t1) - (1 :: int)) emod (2 :: int) = (0 :: int) \<longrightarrow> nexts t1 ! nat (sint (max t1) - (1 :: int)) = sint (max t1)) \<and> ((sint (max t1) - (1 :: int)) emod (2 :: int) = (1 :: int) \<longrightarrow> nexts t1 ! nat (sint (max t1) - (1 :: int)) = sint (max t1) + (1 :: int))) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 \<le> sint (max_arr t1) \<longrightarrow> -(sint (max t1) + (1 :: int)) \<le> elts (arr t1) ! nat i1 \<and> elts (arr t1) ! nat i1 \<le> sint (max t1) + (1 :: int)) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 \<le> sint (max_arr t1) \<longrightarrow> o6 ! nat ((2 :: int) * i1 + (1 :: int)) = True \<longleftrightarrow> elts (arr t1) ! nat i1 < (0 :: int)) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 \<le> sint (max_arr t1) \<longrightarrow> \<not>o6 ! nat ((2 :: int) * i1 + (1 :: int)) = True \<longrightarrow> elts (arr t1) ! nat i1 = nexts t1 ! nat ((2 :: int) * i1 + (1 :: int))) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 \<le> sint (max_arr t1) \<longrightarrow> o6 ! nat ((2 :: int) * i1 + (1 :: int)) = True \<longrightarrow> elts (arr t1) ! nat i1 = -nexts t1 ! nat ((2 :: int) * i1 + (1 :: int))) \<and> (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 \<le> sint (max_arr t1) \<longrightarrow> (i1 < abs (elts (arr t1) ! nat i1) ediv (2 :: int) \<and> abs (elts (arr t1) ! nat i1) ediv (2 :: int) \<le> sint (max_arr t1) + (1 :: int)) \<and> abs (elts (arr t1) ! nat i1) \<le> sint (max t1) + (1 :: int)) \<and> (\<forall>(i1 :: int) (j :: int). (0 :: int) \<le> i1 \<and> i1 \<le> sint (max_arr t1) \<longrightarrow> i1 < j \<and> j < abs (elts (arr t1) ! nat i1) ediv (2 :: int) \<longrightarrow> elts (arr t1) ! nat j < (0 :: int))) \<and> (max_arr t1 = max_arr t2 \<and> max t1 = max t2 \<and> arr t1 = arr t2 \<and> o6 = marked t2 \<and> nexts t1 = nexts t2 \<longrightarrow> marked t2 = (marked t1)[nat (sint i) := True]))))))"
  sorry
end
