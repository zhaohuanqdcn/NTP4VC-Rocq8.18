theory get_str_Get_str_wmpn_get_strqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "mach.c_UChar" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/powm_Powm" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/sub_1_Sub_1" "../../lib/isabelle/stringlemmas_String_lemmas" "../../lib/isabelle/base_info_BaseInfo"
begin
theorem wmpn_get_str'vc:
  fixes sz :: "32 word"
  fixes un :: "32 word"
  fixes sp :: "8 word ptr"
  fixes up :: "64 word ptr"
  fixes base :: "32 word"
  assumes fact0: "(0 :: int) < sint sz"
  assumes fact1: "(0 :: int) < sint un"
  assumes fact2: "valid sp (sint sz)"
  assumes fact3: "valid up (sint un)"
  assumes fact4: "writable sp = True"
  assumes fact5: "writable up = True"
  assumes fact6: "((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint un \<le> sint base ^\<^sub>i (sint sz - (1 :: int))"
  assumes fact7: "(0 :: int) < uint (pelts up (offset up + sint un - (1 :: int)))"
  assumes fact8: "(2 :: int) \<le> sint base"
  assumes fact9: "sint base \<le> (256 :: int)"
  assumes fact10: "(64 :: int) * sint un + (7 :: int) \<le> (2147483647 :: int)"
  shows "(0 :: int) \<le> sint base"
  and "\<forall>(o1 :: 64 word). uint o1 = sint base \<longrightarrow> ((2 :: int) \<le> uint o1 \<and> uint o1 \<le> (256 :: int)) \<and> (\<forall>(bits :: 32 word). ((0 :: int) \<le> uint bits \<and> uint bits \<le> (8 :: int)) \<and> (\<not>uint bits = (0 :: int) \<longrightarrow> (2 :: int) ^\<^sub>i uint bits = uint o1) \<and> (uint bits = (0 :: int) \<longrightarrow> (\<forall>(n :: int). (0 :: int) \<le> n \<longrightarrow> \<not>(2 :: int) ^\<^sub>i n = uint o1)) \<longrightarrow> (uint bits = (0 :: int) \<longrightarrow> bits = (0 :: 32 word)) \<longrightarrow> (if \<not>bits = (0 :: 32 word) then int'32_in_bounds ((64 :: int) * sint un) \<and> (\<forall>(o2 :: 32 word). sint o2 = (64 :: int) * sint un \<longrightarrow> ((1 :: int) \<le> sint un \<and> valid up (sint un) \<and> ((1 :: int) \<le> uint bits \<and> uint bits \<le> (8 :: int)) \<and> valid sp ((sint o2 + uint bits - (1 :: int)) ediv uint bits) \<and> (0 :: int) \<le> sint o2 \<and> value up (sint un) < (2 :: int) ^\<^sub>i sint o2 \<and> (0 :: int) < uint (pelts up (offset up + sint un - (1 :: int))) \<and> (64 :: int) * sint un + (7 :: int) \<le> (2147483647 :: int) \<and> writable sp = True) \<and> (\<forall>(sp1 :: 8 word ptr). length (data sp1) = length (data sp) \<and> offset sp1 = offset sp \<and> c_C.min sp1 = c_C.min sp \<and> c_C.max sp1 = c_C.max sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> (\<forall>(result :: 32 word). in_base ((2 :: int) ^\<^sub>i uint bits) (pelts sp1) (offset sp1) (offset sp1 + uint result) \<and> svalue ((2 :: int) ^\<^sub>i uint bits) sp1 (uint result) = value up (sint un) \<and> ((0 :: int) < uint result \<and> uint result \<le> (sint o2 + uint bits - (1 :: int)) ediv uint bits) \<and> (0 :: int) < uint (pelts sp1 (offset sp1)) \<and> (\<forall>(j :: int). j < offset sp1 \<or> offset sp1 + (sint o2 + uint bits - (1 :: int)) ediv uint bits \<le> j \<longrightarrow> pelts sp1 j = pelts sp j) \<longrightarrow> in_base (sint base) (pelts sp1) (offset sp1) (offset sp1 + uint result) \<and> svalue (sint base) sp1 (uint result) = value up (sint un) \<and> ((0 :: int) < uint result \<and> uint result < sint sz) \<and> (0 :: int) < uint (pelts sp1 (offset sp1))))) else (0 :: int) \<le> sint base \<and> (\<forall>(o2 :: 64 word). uint o2 = sint base \<longrightarrow> ((2 :: int) \<le> uint o2 \<and> uint o2 \<le> (256 :: int)) \<and> (\<forall>(info :: wmpn_base_info). b info = uint o2 \<longrightarrow> (valid up (sint un) \<and> (1 :: int) \<le> sint un \<and> b info = sint base \<and> writable up = True \<and> writable sp = True \<and> (0 :: int) < uint (pelts up (offset up + sint un - (1 :: int))) \<and> (0 :: int) < sint sz \<and> valid sp (sint sz) \<and> value up (sint un) < sint base ^\<^sub>i (sint sz - (1 :: int))) \<and> (\<forall>(sp1 :: 8 word ptr). length (data sp1) = length (data sp) \<and> offset sp1 = offset sp \<and> c_C.min sp1 = c_C.min sp \<and> c_C.max sp1 = c_C.max sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> (\<forall>(result :: 32 word). ((0 :: int) \<le> uint result \<and> uint result < sint sz) \<and> svalue (sint base) sp1 (uint result) = value up (sint un) \<and> in_base (sint base) (pelts sp1) (offset sp1) (offset sp1 + uint result) \<and> (0 :: int) < uint (pelts sp1 (offset sp1)) \<and> (\<forall>(j :: int). j < offset sp1 \<or> offset sp1 + sint sz \<le> j \<longrightarrow> pelts sp1 j = pelts sp j) \<longrightarrow> in_base (sint base) (pelts sp1) (offset sp1) (offset sp1 + uint result) \<and> svalue (sint base) sp1 (uint result) = value up (sint un) \<and> ((0 :: int) < uint result \<and> uint result < sint sz) \<and> (0 :: int) < uint (pelts sp1 (offset sp1))))))))"
  sorry
end
