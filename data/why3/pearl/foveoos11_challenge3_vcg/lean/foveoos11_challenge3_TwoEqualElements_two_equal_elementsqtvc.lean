import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace foveoos11_challenge3_TwoEqualElements_two_equal_elementsqtvc
noncomputable def appear_twice (a : List ℤ) (v : ℤ) (u : ℤ) := ∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i < u) ∧ a[Int.toNat i]! = v ∧ (∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < u) ∧ ¬j = i ∧ a[Int.toNat j]! = v)
theorem two_equal_elements'vc (a : List ℤ) (n : ℤ) (fact0 : Int.ofNat (List.length a) = n + (2 : ℤ)) (fact1 : (2 : ℤ) ≤ n) (fact2 : ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → (0 : ℤ) ≤ a[Int.toNat i]! ∧ a[Int.toNat i]! < n) (fact3 : ∃(v1 : ℤ), appear_twice a v1 (n + (2 : ℤ)) ∧ (∃(v2 : ℤ), appear_twice a v2 (n + (2 : ℤ)) ∧ ¬v2 = v1)) : (0 : ℤ) ≤ n ∧ (∀(deja_vu : List Bool), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → deja_vu[Int.toNat i]! = false) ∧ Int.ofNat (List.length deja_vu) = n → (let o1 : ℤ := n + (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → ((∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < n → (if deja_vu[Int.toNat v]! = true then ∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < (0 : ℤ)) ∧ a[Int.toNat j]! = v else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → ¬a[Int.toNat j]! = v)) ∧ (∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < n → ¬appear_twice a v (0 : ℤ)) ∧ (∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < n → ¬v = -(1 : ℤ) → ¬appear_twice a v (0 : ℤ))) ∧ (∀(v2 : ℤ) (v1 : ℤ) (deja_vu1 : List Bool), List.length deja_vu1 = List.length deja_vu → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ (v1 = -(1 : ℤ) → v2 = -(1 : ℤ)) ∧ (¬v1 = -(1 : ℤ) → appear_twice a v1 i) ∧ (¬v2 = -(1 : ℤ) → appear_twice a v2 i ∧ ¬v2 = v1) ∧ (∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < n → (if deja_vu1[Int.toNat v]! = true then ∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < i) ∧ a[Int.toNat j]! = v else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → ¬a[Int.toNat j]! = v)) ∧ (v1 = -(1 : ℤ) → (∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < n → ¬appear_twice a v i)) ∧ (v2 = -(1 : ℤ) → (∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < n → ¬v = v1 → ¬appear_twice a v i)) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let v : ℤ := a[Int.toNat i]!; ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length deja_vu1)) ∧ (if deja_vu1[Int.toNat v]! = true then if v1 = -(1 : ℤ) then (v = -(1 : ℤ) → v2 = -(1 : ℤ)) ∧ (¬v = -(1 : ℤ) → appear_twice a v (i + (1 : ℤ))) ∧ (¬v2 = -(1 : ℤ) → appear_twice a v2 (i + (1 : ℤ)) ∧ ¬v2 = v) ∧ (∀(v3 : ℤ), (0 : ℤ) ≤ v3 ∧ v3 < n → (if deja_vu1[Int.toNat v3]! = true then ∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < i + (1 : ℤ)) ∧ a[Int.toNat j]! = v3 else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → ¬a[Int.toNat j]! = v3)) ∧ (v = -(1 : ℤ) → (∀(v3 : ℤ), (0 : ℤ) ≤ v3 ∧ v3 < n → ¬appear_twice a v3 (i + (1 : ℤ)))) ∧ (v2 = -(1 : ℤ) → (∀(v3 : ℤ), (0 : ℤ) ≤ v3 ∧ v3 < n → ¬v3 = v → ¬appear_twice a v3 (i + (1 : ℤ)))) else ∀(o2 : Bool), (if v2 = -(1 : ℤ) then o2 = (if v = v1 then false else true) else o2 = false) → (if o2 = true then (v1 = -(1 : ℤ) → v = -(1 : ℤ)) ∧ (¬v1 = -(1 : ℤ) → appear_twice a v1 (i + (1 : ℤ))) ∧ (¬v = -(1 : ℤ) → appear_twice a v (i + (1 : ℤ)) ∧ ¬v = v1) ∧ (∀(v3 : ℤ), (0 : ℤ) ≤ v3 ∧ v3 < n → (if deja_vu1[Int.toNat v3]! = true then ∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < i + (1 : ℤ)) ∧ a[Int.toNat j]! = v3 else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → ¬a[Int.toNat j]! = v3)) ∧ (v1 = -(1 : ℤ) → (∀(v3 : ℤ), (0 : ℤ) ≤ v3 ∧ v3 < n → ¬appear_twice a v3 (i + (1 : ℤ)))) ∧ (v = -(1 : ℤ) → (∀(v3 : ℤ), (0 : ℤ) ≤ v3 ∧ v3 < n → ¬v3 = v1 → ¬appear_twice a v3 (i + (1 : ℤ)))) else (v1 = -(1 : ℤ) → v2 = -(1 : ℤ)) ∧ (¬v1 = -(1 : ℤ) → appear_twice a v1 (i + (1 : ℤ))) ∧ (¬v2 = -(1 : ℤ) → appear_twice a v2 (i + (1 : ℤ)) ∧ ¬v2 = v1) ∧ (∀(v3 : ℤ), (0 : ℤ) ≤ v3 ∧ v3 < n → (if deja_vu1[Int.toNat v3]! = true then ∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < i + (1 : ℤ)) ∧ a[Int.toNat j]! = v3 else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → ¬a[Int.toNat j]! = v3)) ∧ (v1 = -(1 : ℤ) → (∀(v3 : ℤ), (0 : ℤ) ≤ v3 ∧ v3 < n → ¬appear_twice a v3 (i + (1 : ℤ)))) ∧ (v2 = -(1 : ℤ) → (∀(v3 : ℤ), (0 : ℤ) ≤ v3 ∧ v3 < n → ¬v3 = v1 → ¬appear_twice a v3 (i + (1 : ℤ))))) else let o2 : Bool := true; ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length deja_vu1)) ∧ (List.length (List.set deja_vu1 (Int.toNat v) o2) = List.length deja_vu1 → getElem! (List.set deja_vu1 (Int.toNat v) o2) ∘ Int.toNat = Function.update (getElem! deja_vu1 ∘ Int.toNat) v o2 → (v1 = -(1 : ℤ) → v2 = -(1 : ℤ)) ∧ (¬v1 = -(1 : ℤ) → appear_twice a v1 (i + (1 : ℤ))) ∧ (¬v2 = -(1 : ℤ) → appear_twice a v2 (i + (1 : ℤ)) ∧ ¬v2 = v1) ∧ (∀(v3 : ℤ), (0 : ℤ) ≤ v3 ∧ v3 < n → (if (List.set deja_vu1 (Int.toNat v) o2)[Int.toNat v3]! = true then ∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < i + (1 : ℤ)) ∧ a[Int.toNat j]! = v3 else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → ¬a[Int.toNat j]! = v3)) ∧ (v1 = -(1 : ℤ) → (∀(v3 : ℤ), (0 : ℤ) ≤ v3 ∧ v3 < n → ¬appear_twice a v3 (i + (1 : ℤ)))) ∧ (v2 = -(1 : ℤ) → (∀(v3 : ℤ), (0 : ℤ) ≤ v3 ∧ v3 < n → ¬v3 = v1 → ¬appear_twice a v3 (i + (1 : ℤ)))))))) ∧ ((v1 = -(1 : ℤ) → v2 = -(1 : ℤ)) ∧ (¬v1 = -(1 : ℤ) → appear_twice a v1 (o1 + (1 : ℤ))) ∧ (¬v2 = -(1 : ℤ) → appear_twice a v2 (o1 + (1 : ℤ)) ∧ ¬v2 = v1) ∧ (∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < n → (if deja_vu1[Int.toNat v]! = true then ∃(j : ℤ), ((0 : ℤ) ≤ j ∧ j < o1 + (1 : ℤ)) ∧ a[Int.toNat j]! = v else ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < o1 + (1 : ℤ) → ¬a[Int.toNat j]! = v)) ∧ (v1 = -(1 : ℤ) → (∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < n → ¬appear_twice a v (o1 + (1 : ℤ)))) ∧ (v2 = -(1 : ℤ) → (∀(v : ℤ), (0 : ℤ) ≤ v ∧ v < n → ¬v = v1 → ¬appear_twice a v (o1 + (1 : ℤ)))) → appear_twice a v1 (n + (2 : ℤ)) ∧ appear_twice a v2 (n + (2 : ℤ)) ∧ ¬v1 = v2))) ∧ ¬o1 + (1 : ℤ) < (0 : ℤ)))
  := sorry
end foveoos11_challenge3_TwoEqualElements_two_equal_elementsqtvc
