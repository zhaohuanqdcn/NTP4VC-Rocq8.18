theory coincidence_count_list_CoincidenceCountAnyType_coincidence_countqtvc
  imports "NTP4Verif.NTP4Verif"
begin
typedecl  t
consts eq :: "t \<Rightarrow> t \<Rightarrow> bool"
axiomatization where eq'spec:   "eq x y \<longleftrightarrow> x = y"
  for x :: "t"
  and y :: "t"
typedecl  set
consts to_fset :: "set \<Rightarrow> t fset"
consts mk :: "t fset \<Rightarrow> set"
axiomatization where mk'spec:   "to_fset (mk s) = s"
  for s :: "t fset"
consts choose1 :: "set \<Rightarrow> t"
axiomatization where choose'spec:   "choose1 s |\<in>| to_fset s"
 if "\<not>to_fset s = fempty"
  for s :: "set"
consts rel :: "t \<Rightarrow> t \<Rightarrow> bool"
axiomatization where Trans:   "rel x z"
 if "rel x y"
 and "rel y z"
  for x :: "t"
  and y :: "t"
  and z :: "t"
axiomatization where Asymm:   "\<not>rel y x"
 if "rel x y"
  for x :: "t"
  and y :: "t"
axiomatization where Trichotomy:   "rel x y \<or> rel y x \<or> x = y"
  for x :: "t"
  and y :: "t"
inductive sorted :: "t list \<Rightarrow> bool" where
   Sorted_Nil: "sorted (Nil :: t list)"
 | Sorted_One: "sorted (Cons x (Nil :: t list))" for x :: "t"
 | Sorted_Two: "rel x y \<Longrightarrow> sorted (Cons y l) \<Longrightarrow> sorted (Cons x (Cons y l))" for x :: "t" and y :: "t" and l :: "t list"
axiomatization where sorted_mem:   "(\<forall>(y :: t). y \<in> set l \<longrightarrow> rel x y) \<and> sorted l \<longleftrightarrow> sorted (Cons x l)"
  for l :: "t list"
  and x :: "t"
axiomatization where sorted_append:   "sorted l1 \<and> sorted l2 \<and> (\<forall>(x :: t) (y :: t). x \<in> set l1 \<longrightarrow> y \<in> set l2 \<longrightarrow> rel x y) \<longleftrightarrow> sorted (l1 @ l2)"
  for l1 :: "t list"
  and l2 :: "t list"
theorem coincidence_count'vc:
  fixes a :: "t list"
  fixes b :: "t list"
  assumes fact0: "sorted a"
  assumes fact1: "sorted b"
  shows "case b of Cons x x1 \<Rightarrow> (case a of Cons x2 x3 \<Rightarrow> (eq x2 x \<longleftrightarrow> x2 = x) \<longrightarrow> (if eq x2 x then ((case a of Nil \<Rightarrow> False | Cons _ f \<Rightarrow> f = x3) \<or> a = x3 \<and> (case b of Nil \<Rightarrow> False | Cons _ f \<Rightarrow> f = x1)) \<and> sorted x3 \<and> sorted x1 else if rel x2 x then (case a of Nil \<Rightarrow> False | Cons _ f \<Rightarrow> f = x3) \<and> sorted x3 \<and> sorted b else (case b of Nil \<Rightarrow> False | Cons _ f \<Rightarrow> f = x1) \<and> sorted a \<and> sorted x1) | _ \<Rightarrow> True) | _ \<Rightarrow> True"
  and "\<forall>(result :: set). (case b of Cons x x1 \<Rightarrow> (case a of Cons x2 x3 \<Rightarrow> (eq x2 x \<longleftrightarrow> x2 = x) \<and> (if eq x2 x then \<exists>(o1 :: set). to_fset o1 = fset_of_list x3 |\<inter>| fset_of_list x1 \<and> to_fset result = finsert x2 (to_fset o1) \<and> (if x2 |\<in>| to_fset o1 then fcard (to_fset result) = fcard (to_fset o1) else int (fcard (to_fset result)) = int (fcard (to_fset o1)) + (1 :: int)) else if rel x2 x then to_fset result = fset_of_list x3 |\<inter>| fset_of_list b else to_fset result = fset_of_list a |\<inter>| fset_of_list x1) | _ \<Rightarrow> to_fset result = fempty \<and> int (fcard (to_fset result)) = (0 :: int)) | _ \<Rightarrow> to_fset result = fempty \<and> int (fcard (to_fset result)) = (0 :: int)) \<longrightarrow> to_fset result = fset_of_list a |\<inter>| fset_of_list b"
  sorry
end
