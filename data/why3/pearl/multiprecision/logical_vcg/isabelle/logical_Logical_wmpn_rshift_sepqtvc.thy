theory logical_Logical_wmpn_rshift_sepqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "../../lib/isabelle/logical_LogicalUtil" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/ptralias_Alias"
begin
theorem wmpn_rshift_sep'vc:
  fixes x :: "64 word ptr"
  fixes sz :: "32 word"
  fixes r :: "64 word ptr"
  fixes cnt :: "64 word"
  assumes fact0: "valid x (sint sz)"
  assumes fact1: "valid r (sint sz)"
  assumes fact2: "(0 :: int) < uint cnt"
  assumes fact3: "uint cnt < (64 :: int)"
  assumes fact4: "(0 :: int) < sint sz"
  assumes fact5: "writable r = True"
  shows "valid r (sint sz)"
  and "valid x (sint sz)"
  and "(0 :: int) \<le> sint sz"
  and "writable r = True"
  and "\<forall>(x1 :: 64 word ptr) (r1 :: 64 word ptr). offset x1 = offset x \<and> writable x1 = writable x \<and> zone1 x1 = zone1 x \<longrightarrow> offset r1 = offset r \<and> writable r1 = writable r \<and> zone1 r1 = zone1 r \<longrightarrow> (\<forall>(nr :: 64 word ptr) (nx :: 64 word ptr) (m :: mem). writable nr = True \<and> value nx (sint sz) = value x (sint sz) \<and> (valid nr (sint sz) \<and> valid nx (sint sz)) \<and> ((0 :: int) \<le> offset nx \<and> offset nx + sint sz \<le> offset nr) \<and> (zr m = zone1 r1 \<and> zx m = zone1 x1) \<and> (sint (mr m) = c_C.max r \<and> sint (mx m) = c_C.max x) \<and> (lr m = lx m \<and> lx m = sz) \<and> ok m = True \<and> map_eq_sub_shift (pelts nx) (pelts x1) (offset nx) (offset x1) (sint sz) \<and> map_eq_sub_shift (pelts nr) (pelts r1) (offset nr) (offset r1) (sint sz) \<and> (pelts r1 = pelts r \<and> pelts x1 = pelts x) \<and> (plength r1 = plength r \<and> plength x1 = plength x) \<and> (c_C.min r1 = c_C.min r \<and> c_C.min x1 = c_C.min x) \<and> data nr = data nx \<longrightarrow> (((0 :: int) < uint cnt \<and> uint cnt < (64 :: int)) \<and> valid nx (sint sz) \<and> valid nr (sint sz) \<and> (0 :: int) < sint sz \<and> writable nr = True \<and> (offset nr \<le> offset nx \<or> offset nx + sint sz \<le> offset nr)) \<and> (\<forall>(nx1 :: 64 word ptr) (nr1 :: 64 word ptr). data nx1 = data nr1 \<and> length (data nr1) = length (data nx) \<and> offset nx1 = offset nx \<and> c_C.min nx1 = c_C.min nx \<and> c_C.max nx1 = c_C.max nx \<and> writable nx1 = writable nx \<and> zone1 nx1 = zone1 nx \<longrightarrow> length (data nr1) = length (data nr) \<and> offset nr1 = offset nr \<and> c_C.min nr1 = c_C.min nr \<and> c_C.max nr1 = c_C.max nr \<and> writable nr1 = writable nr \<and> zone1 nr1 = zone1 nr \<longrightarrow> (\<forall>(res :: 64 word). uint res + ((18446744073709551615 :: int) + (1 :: int)) * value nr1 (sint sz) = value nx (sint sz) * (2 :: int) ^\<^sub>i ((64 :: int) - uint cnt) \<and> (\<forall>(j :: int). j < offset nr1 \<or> offset nr1 + sint sz \<le> j \<longrightarrow> pelts nr1 j = pelts nr j) \<and> (c_C.min nr1 = c_C.min nr \<and> c_C.max nr1 = c_C.max nr \<and> plength nr1 = plength nr) \<and> c_C.min nx1 = c_C.min nx \<and> c_C.max nx1 = c_C.max nx \<and> plength nx1 = plength nx \<longrightarrow> ((writable r1 = True \<and> writable nr1 = True) \<and> ok m = True \<and> (0 :: int) \<le> sint sz \<and> ((0 :: int) \<le> offset nx1 \<and> offset nx1 + sint sz \<le> offset nr1) \<and> (zx m = zone1 x1 \<and> zr m = zone1 r1) \<and> lx m = lr m \<and> lr m = sz) \<and> (\<forall>(m1 :: mem) (nx2 :: 64 word ptr) (nr2 :: 64 word ptr) (x2 :: 64 word ptr) (r2 :: 64 word ptr). zr m1 = zr m \<and> zx m1 = zx m \<and> zy m1 = zy m \<and> mr m1 = mr m \<and> mx m1 = mx m \<and> my m1 = my m \<and> lr m1 = lr m \<and> lx m1 = lx m \<and> ly m1 = ly m \<longrightarrow> offset nx2 = offset nx1 \<and> writable nx2 = writable nx1 \<and> zone1 nx2 = zone1 nx1 \<longrightarrow> offset nr2 = offset nr1 \<and> writable nr2 = writable nr1 \<and> zone1 nr2 = zone1 nr1 \<longrightarrow> offset x2 = offset x1 \<and> c_C.min x2 = c_C.min x1 \<and> writable x2 = writable x1 \<and> zone1 x2 = zone1 x1 \<longrightarrow> offset r2 = offset r1 \<and> c_C.min r2 = c_C.min r1 \<and> writable r2 = writable r1 \<and> zone1 r2 = zone1 r1 \<longrightarrow> (c_C.max x2 = sint (mx m1) \<and> c_C.max r2 = sint (mr m1)) \<and> map_eq_sub_shift (pelts nx1) (pelts x2) (offset nx2) (offset x2) (sint sz) \<and> map_eq_sub_shift (pelts nr1) (pelts r2) (offset nr2) (offset r2) (sint sz) \<and> (\<forall>(j :: int). j < offset x2 \<or> offset x2 + sint sz \<le> j \<longrightarrow> pelts x2 j = pelts x1 j) \<and> (\<forall>(j :: int). j < offset r2 \<or> offset r2 + sint sz \<le> j \<longrightarrow> pelts r2 j = pelts r1 j) \<and> (plength x2 = plength x1 \<and> plength r2 = plength r1) \<and> c_C.min r2 = c_C.min r1 \<and> c_C.min x2 = c_C.min x1 \<longrightarrow> uint res + ((18446744073709551615 :: int) + (1 :: int)) * value r2 (sint sz) = value x2 (sint sz) * (2 :: int) ^\<^sub>i ((64 :: int) - uint cnt) \<and> (\<forall>(j :: int). j < offset r2 \<or> offset r2 + sint sz \<le> j \<longrightarrow> pelts r2 j = pelts r j) \<and> pelts x2 = pelts x \<and> (c_C.min x2 = c_C.min x \<and> c_C.max x2 = c_C.max x \<and> plength x2 = plength x) \<and> c_C.min r2 = c_C.min r \<and> c_C.max r2 = c_C.max r \<and> plength r2 = plength r))))"
  sorry
end
