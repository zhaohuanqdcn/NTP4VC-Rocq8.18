import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
import Why3.int.Sum
import Why3.map.MapExt
import Why3.map.MapPermut
import Why3.matrix.Matrix
open Classical
open Lean4Why3
namespace verifythis_2021_shearsort_ShearSort_sort_columnqtvc
axiom column :  {α : Type} -> [Inhabited α] -> Matrix.matrix α -> ℤ -> ℤ -> α
axiom column'def {α : Type} [Inhabited α] (m : Matrix.matrix α) (j : ℤ) (i : ℤ) : column m j i = Matrix.elts m i j
axiom moccf :  {α : Type} -> [Inhabited α] -> α -> (ℤ -> ℤ -> α) -> ℤ -> ℤ -> ℤ
axiom moccf'def {α : Type} [Inhabited α] (x : α) (e : ℤ -> ℤ -> α) (c : ℤ) (i : ℤ) : moccf x e c i = Int.ofNat (Lean4Why3.map_occ x (e i) (0 : ℤ) c)
noncomputable def mocc {α : Type} [Inhabited α] (x : α) (e : ℤ -> ℤ -> α) (r : ℤ) (c : ℤ) := int.Sum.sum (moccf x e c) (0 : ℤ) r
axiom compose :  {γ : Type} -> [Inhabited γ] ->  {β : Type} -> [Inhabited β] ->  {α : Type} -> [Inhabited α] -> (β -> γ) -> (α -> β) -> α -> γ
axiom compose'def {γ : Type} {α : Type} {β : Type} [Inhabited γ] [Inhabited α] [Inhabited β] (g : β -> γ) (f : α -> β) (x : α) : compose g f x = g (f x)
theorem sort_column'vc (j : ℤ) (m : Matrix.matrix ℤ) (fact0 : (0 : ℤ) ≤ j) (fact1 : j < Matrix.columns m) : let o1 : ℤ := Matrix.rows m; (0 : ℤ) ≤ o1 ∧ (∀(a : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o1 → a[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length a) = o1 → (let o2 : ℤ := Matrix.rows m - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < (0 : ℤ) → (getElem! a ∘ Int.toNat) k = Matrix.elts m k j) ∧ (∀(a1 : List ℤ), List.length a1 = List.length a → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o2) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i → (getElem! a1 ∘ Int.toNat) k = Matrix.elts m k j) → Matrix.valid_index m i j ∧ (let o3 : ℤ := Matrix.elts m i j; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (List.length (List.set a1 (Int.toNat i) o3) = List.length a1 → getElem! (List.set a1 (Int.toNat i) o3) ∘ Int.toNat = Function.update (getElem! a1 ∘ Int.toNat) i o3 → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i + (1 : ℤ) → (getElem! (List.set a1 (Int.toNat i) o3) ∘ Int.toNat) k = Matrix.elts m k j)))) ∧ ((∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < o2 + (1 : ℤ) → (getElem! a1 ∘ Int.toNat) k = Matrix.elts m k j) → (∀(a2 : List ℤ), List.length a2 = List.length a1 → (∀(i : ℤ) (j1 : ℤ), (0 : ℤ) ≤ i ∧ i ≤ j1 ∧ j1 < Int.ofNat (List.length a2) → a2[Int.toNat i]! ≤ a2[Int.toNat j1]!) ∧ MapPermut.permut (getElem! a2 ∘ Int.toNat) (getElem! a1 ∘ Int.toNat) (0 : ℤ) (Int.ofNat (List.length a2)) → (let o3 : ℤ := Matrix.rows m - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < (0 : ℤ) → (getElem! a2 ∘ Int.toNat) k = Matrix.elts m k j) ∧ (∀(m1 : Matrix.matrix ℤ), Matrix.rows m1 = Matrix.rows m ∧ Matrix.columns m1 = Matrix.columns m → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o3) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i → (getElem! a2 ∘ Int.toNat) k = Matrix.elts m1 k j) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m1) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m1) ∧ ¬l = j → Matrix.elts m1 k l = Matrix.elts m k l) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a2)) ∧ Matrix.valid_index m1 i j ∧ (∀(m2 : Matrix.matrix ℤ), Matrix.rows m2 = Matrix.rows m1 ∧ Matrix.columns m2 = Matrix.columns m1 → Matrix.elts m2 = Function.update (Matrix.elts m1) i (Function.update (Matrix.elts m1 i) j (a2[Int.toNat i]!)) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i + (1 : ℤ) → (getElem! a2 ∘ Int.toNat) k = Matrix.elts m2 k j) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m2) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m2) ∧ ¬l = j → Matrix.elts m2 k l = Matrix.elts m k l))) ∧ ((∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < o3 + (1 : ℤ) → (getElem! a2 ∘ Int.toNat) k = Matrix.elts m1 k j) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m1) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m1) ∧ ¬l = j → Matrix.elts m1 k l = Matrix.elts m k l) → (∀(i : ℤ) (k : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m1 ∧ ((0 : ℤ) ≤ k ∧ k < Matrix.columns m1) ∧ ¬k = j → Matrix.elts m1 i k = Matrix.elts m i k) ∧ (∀(i : ℤ) (k : ℤ), (0 : ℤ) ≤ i ∧ i ≤ k ∧ k < Matrix.rows m1 → Matrix.elts m1 i j ≤ Matrix.elts m1 k j) ∧ MapPermut.permut (column m1 j) (column m j) (0 : ℤ) (Matrix.rows m1)))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → (∀(i : ℤ) (k : ℤ), (0 : ℤ) ≤ i ∧ i ≤ k ∧ k < Matrix.rows m → Matrix.elts m i j ≤ Matrix.elts m k j) ∧ MapPermut.permut (column m j) (column m j) (0 : ℤ) (Matrix.rows m))))))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → (∀(a1 : List ℤ), List.length a1 = List.length a → (∀(i : ℤ) (j1 : ℤ), (0 : ℤ) ≤ i ∧ i ≤ j1 ∧ j1 < Int.ofNat (List.length a1) → a1[Int.toNat i]! ≤ a1[Int.toNat j1]!) ∧ MapPermut.permut (getElem! a1 ∘ Int.toNat) (getElem! a ∘ Int.toNat) (0 : ℤ) (Int.ofNat (List.length a1)) → (let o3 : ℤ := Matrix.rows m - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < (0 : ℤ) → (getElem! a1 ∘ Int.toNat) k = Matrix.elts m k j) ∧ (∀(m1 : Matrix.matrix ℤ), Matrix.rows m1 = Matrix.rows m ∧ Matrix.columns m1 = Matrix.columns m → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o3) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i → (getElem! a1 ∘ Int.toNat) k = Matrix.elts m1 k j) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m1) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m1) ∧ ¬l = j → Matrix.elts m1 k l = Matrix.elts m k l) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ Matrix.valid_index m1 i j ∧ (∀(m2 : Matrix.matrix ℤ), Matrix.rows m2 = Matrix.rows m1 ∧ Matrix.columns m2 = Matrix.columns m1 → Matrix.elts m2 = Function.update (Matrix.elts m1) i (Function.update (Matrix.elts m1 i) j (a1[Int.toNat i]!)) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i + (1 : ℤ) → (getElem! a1 ∘ Int.toNat) k = Matrix.elts m2 k j) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m2) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m2) ∧ ¬l = j → Matrix.elts m2 k l = Matrix.elts m k l))) ∧ ((∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < o3 + (1 : ℤ) → (getElem! a1 ∘ Int.toNat) k = Matrix.elts m1 k j) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m1) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m1) ∧ ¬l = j → Matrix.elts m1 k l = Matrix.elts m k l) → (∀(i : ℤ) (k : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m1 ∧ ((0 : ℤ) ≤ k ∧ k < Matrix.columns m1) ∧ ¬k = j → Matrix.elts m1 i k = Matrix.elts m i k) ∧ (∀(i : ℤ) (k : ℤ), (0 : ℤ) ≤ i ∧ i ≤ k ∧ k < Matrix.rows m1 → Matrix.elts m1 i j ≤ Matrix.elts m1 k j) ∧ MapPermut.permut (column m1 j) (column m j) (0 : ℤ) (Matrix.rows m1)))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → (∀(i : ℤ) (k : ℤ), (0 : ℤ) ≤ i ∧ i ≤ k ∧ k < Matrix.rows m → Matrix.elts m i j ≤ Matrix.elts m k j) ∧ MapPermut.permut (column m j) (column m j) (0 : ℤ) (Matrix.rows m)))))))
  := sorry
end verifythis_2021_shearsort_ShearSort_sort_columnqtvc
