import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Sum
import pearl.maximum_subarray_vcg.lean.maximum_subarray.Spec
open Classical
open Lean4Why3
namespace maximum_subarray_Algo1_maximum_subarrayqtvc
theorem maximum_subarray'vc (a : List ℤ) : let n : ℤ := Int.ofNat (List.length a); let o1 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → ((((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ)) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ n) ∧ (0 : ℤ) = List.sum (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a))) ∧ Spec.maxsublo a (0 : ℤ) (0 : ℤ)) ∧ (∀(ms : ℤ) (hi : ℤ) (lo : ℤ), (∀(l : ℤ), ((0 : ℤ) ≤ l ∧ l ≤ o1) ∧ (((0 : ℤ) ≤ lo ∧ lo ≤ l) ∧ (lo ≤ hi ∧ hi ≤ n) ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ Spec.maxsublo a l ms → (l ≤ n + (1 : ℤ) → ((((0 : ℤ) ≤ lo ∧ lo ≤ l) ∧ (lo ≤ hi ∧ hi ≤ n) ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ Spec.maxsublo a l ms ∧ (∀(h' : ℤ), l ≤ h' ∧ h' < l → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h' - Int.toNat l) a)) ≤ ms)) ∧ (∀(ms1 : ℤ) (hi1 : ℤ) (lo1 : ℤ), (∀(h : ℤ), (l ≤ h ∧ h ≤ n) ∧ (((0 : ℤ) ≤ lo1 ∧ lo1 ≤ l) ∧ (lo1 ≤ hi1 ∧ hi1 ≤ n) ∧ ms1 = List.sum (List.drop (Int.toNat lo1) (List.take (Int.toNat hi1 - Int.toNat lo1) a))) ∧ Spec.maxsublo a l ms1 ∧ (∀(h' : ℤ), l ≤ h' ∧ h' < h → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h' - Int.toNat l) a)) ≤ ms1) → (let o2 : ℤ := h - (1 : ℤ); (l ≤ o2 + (1 : ℤ) → ((0 : ℤ) = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat l - Int.toNat l) a)) ∧ ((0 : ℤ) ≤ lo1 ∧ lo1 ≤ l) ∧ (lo1 ≤ hi1 ∧ hi1 ≤ n) ∧ ms1 = List.sum (List.drop (Int.toNat lo1) (List.take (Int.toNat hi1 - Int.toNat lo1) a))) ∧ (∀(s : ℤ), (∀(i : ℤ), (l ≤ i ∧ i ≤ o2) ∧ s = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat i - Int.toNat l) a)) ∧ ((0 : ℤ) ≤ lo1 ∧ lo1 ≤ l) ∧ (lo1 ≤ hi1 ∧ hi1 ≤ n) ∧ ms1 = List.sum (List.drop (Int.toNat lo1) (List.take (Int.toNat hi1 - Int.toNat lo1) a)) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ s + a[Int.toNat i]! = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat l) a)) ∧ ((0 : ℤ) ≤ lo1 ∧ lo1 ≤ l) ∧ (lo1 ≤ hi1 ∧ hi1 ≤ n) ∧ ms1 = List.sum (List.drop (Int.toNat lo1) (List.take (Int.toNat hi1 - Int.toNat lo1) a))) ∧ (s = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat (o2 + (1 : ℤ)) - Int.toNat l) a)) ∧ ((0 : ℤ) ≤ lo1 ∧ lo1 ≤ l) ∧ (lo1 ≤ hi1 ∧ hi1 ≤ n) ∧ ms1 = List.sum (List.drop (Int.toNat lo1) (List.take (Int.toNat hi1 - Int.toNat lo1) a)) → (if ms1 < s then (((0 : ℤ) ≤ l ∧ l ≤ l) ∧ (l ≤ h ∧ h ≤ n) ∧ s = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a))) ∧ Spec.maxsublo a l s ∧ (∀(h' : ℤ), l ≤ h' ∧ h' < h + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h' - Int.toNat l) a)) ≤ s) else (((0 : ℤ) ≤ lo1 ∧ lo1 ≤ l) ∧ (lo1 ≤ hi1 ∧ hi1 ≤ n) ∧ ms1 = List.sum (List.drop (Int.toNat lo1) (List.take (Int.toNat hi1 - Int.toNat lo1) a))) ∧ Spec.maxsublo a l ms1 ∧ (∀(h' : ℤ), l ≤ h' ∧ h' < h + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h' - Int.toNat l) a)) ≤ ms1))))) ∧ (o2 + (1 : ℤ) < l → (if ms1 < (0 : ℤ) then (((0 : ℤ) ≤ l ∧ l ≤ l) ∧ (l ≤ h ∧ h ≤ n) ∧ (0 : ℤ) = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a))) ∧ Spec.maxsublo a l (0 : ℤ) ∧ (∀(h' : ℤ), l ≤ h' ∧ h' < h + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h' - Int.toNat l) a)) ≤ (0 : ℤ)) else (((0 : ℤ) ≤ lo1 ∧ lo1 ≤ l) ∧ (lo1 ≤ hi1 ∧ hi1 ≤ n) ∧ ms1 = List.sum (List.drop (Int.toNat lo1) (List.take (Int.toNat hi1 - Int.toNat lo1) a))) ∧ Spec.maxsublo a l ms1 ∧ (∀(h' : ℤ), l ≤ h' ∧ h' < h + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h' - Int.toNat l) a)) ≤ ms1))))) ∧ ((((0 : ℤ) ≤ lo1 ∧ lo1 ≤ l) ∧ (lo1 ≤ hi1 ∧ hi1 ≤ n) ∧ ms1 = List.sum (List.drop (Int.toNat lo1) (List.take (Int.toNat hi1 - Int.toNat lo1) a))) ∧ Spec.maxsublo a l ms1 ∧ (∀(h' : ℤ), l ≤ h' ∧ h' < n + (1 : ℤ) → List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h' - Int.toNat l) a)) ≤ ms1) → (((0 : ℤ) ≤ lo1 ∧ lo1 ≤ l + (1 : ℤ)) ∧ (lo1 ≤ hi1 ∧ hi1 ≤ n) ∧ ms1 = List.sum (List.drop (Int.toNat lo1) (List.take (Int.toNat hi1 - Int.toNat lo1) a))) ∧ Spec.maxsublo a (l + (1 : ℤ)) ms1))) ∧ (n + (1 : ℤ) < l → (((0 : ℤ) ≤ lo ∧ lo ≤ l + (1 : ℤ)) ∧ (lo ≤ hi ∧ hi ≤ n) ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ Spec.maxsublo a (l + (1 : ℤ)) ms)) ∧ ((((0 : ℤ) ≤ lo ∧ lo ≤ o1 + (1 : ℤ)) ∧ (lo ≤ hi ∧ hi ≤ n) ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ Spec.maxsublo a (o1 + (1 : ℤ)) ms → (((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ Int.ofNat (List.length a)) ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ Spec.maxsub a ms))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length a)) ∧ (0 : ℤ) = List.sum (List.drop (0 : ℕ) (List.take ((0 : ℕ) - (0 : ℕ)) a))) ∧ Spec.maxsub a (0 : ℤ))
  := sorry
end maximum_subarray_Algo1_maximum_subarrayqtvc
