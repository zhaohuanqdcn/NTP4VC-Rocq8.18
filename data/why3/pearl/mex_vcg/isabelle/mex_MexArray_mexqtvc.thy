theory mex_MexArray_mexqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.pigeon_Pigeonhole"
begin
definition mem :: "int \<Rightarrow> int list \<Rightarrow> _"
  where "mem x a \<longleftrightarrow> (\<exists>(i :: int). ((0 :: int) \<le> i \<and> i < int (length a)) \<and> a ! nat i = x)" for x a
consts identity :: "int \<Rightarrow> int"
axiomatization where identity_def:   "identity y = y"
  for y :: "int"
theorem mex'vc:
  fixes a :: "int list"
  shows "let n :: int = int (length a) in (0 :: int) \<le> n \<and> (\<forall>(used :: bool list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> used ! nat i = False) \<and> int (length used) = n \<longrightarrow> (let o1 :: int \<Rightarrow> int = identity; o2 :: int = n - (1 :: int) in ((0 :: int) \<le> o2 + (1 :: int) \<longrightarrow> ((\<forall>(x :: int). (0 :: int) \<le> x \<and> x < n \<longrightarrow> used ! nat x = True \<longrightarrow> mem x a \<and> ((0 :: int) \<le> o1 x \<and> o1 x < n) \<and> a ! nat (o1 x) = x) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> (0 :: int) \<le> a ! nat j \<and> a ! nat j < n \<longrightarrow> used ! nat (a ! nat j) = True \<and> ((0 :: int) \<le> o1 (a ! nat j) \<and> o1 (a ! nat j) < n) \<and> a ! nat (o1 (a ! nat j)) = a ! nat j)) \<and> (\<forall>(idx :: int \<Rightarrow> int) (used1 :: bool list). length used1 = length used \<longrightarrow> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o2) \<and> (\<forall>(x :: int). (0 :: int) \<le> x \<and> x < n \<longrightarrow> used1 ! nat x = True \<longrightarrow> mem x a \<and> ((0 :: int) \<le> idx x \<and> idx x < n) \<and> a ! nat (idx x) = x) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> (0 :: int) \<le> a ! nat j \<and> a ! nat j < n \<longrightarrow> used1 ! nat (a ! nat j) = True \<and> ((0 :: int) \<le> idx (a ! nat j) \<and> idx (a ! nat j) < n) \<and> a ! nat (idx (a ! nat j)) = a ! nat j) \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (let x :: int = a ! nat i in \<forall>(o3 :: bool). (if (0 :: int) \<le> x then o3 = (if x < n then True else False) else o3 = False) \<longrightarrow> (if o3 = True then let o4 :: bool = True in ((0 :: int) \<le> x \<and> x < int (length used1)) \<and> (length (used1[nat x := o4]) = length used1 \<longrightarrow> nth (used1[nat x := o4]) o nat = (nth used1 o nat)(x := o4) \<longrightarrow> (\<forall>(x1 :: int). (0 :: int) \<le> x1 \<and> x1 < n \<longrightarrow> used1[nat x := o4] ! nat x1 = True \<longrightarrow> mem x1 a \<and> ((0 :: int) \<le> (idx(x := i)) x1 \<and> (idx(x := i)) x1 < n) \<and> a ! nat ((idx(x := i)) x1) = x1) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> (0 :: int) \<le> a ! nat j \<and> a ! nat j < n \<longrightarrow> used1[nat x := o4] ! nat (a ! nat j) = True \<and> ((0 :: int) \<le> (idx(x := i)) (a ! nat j) \<and> (idx(x := i)) (a ! nat j) < n) \<and> a ! nat ((idx(x := i)) (a ! nat j)) = a ! nat j)) else (\<forall>(x1 :: int). (0 :: int) \<le> x1 \<and> x1 < n \<longrightarrow> used1 ! nat x1 = True \<longrightarrow> mem x1 a \<and> ((0 :: int) \<le> idx x1 \<and> idx x1 < n) \<and> a ! nat (idx x1) = x1) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> (0 :: int) \<le> a ! nat j \<and> a ! nat j < n \<longrightarrow> used1 ! nat (a ! nat j) = True \<and> ((0 :: int) \<le> idx (a ! nat j) \<and> idx (a ! nat j) < n) \<and> a ! nat (idx (a ! nat j)) = a ! nat j)))) \<and> ((\<forall>(x :: int). (0 :: int) \<le> x \<and> x < n \<longrightarrow> used1 ! nat x = True \<longrightarrow> mem x a \<and> ((0 :: int) \<le> idx x \<and> idx x < n) \<and> a ! nat (idx x) = x) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < o2 + (1 :: int) \<longrightarrow> (0 :: int) \<le> a ! nat j \<and> a ! nat j < n \<longrightarrow> used1 ! nat (a ! nat j) = True \<and> ((0 :: int) \<le> idx (a ! nat j) \<and> idx (a ! nat j) < n) \<and> a ! nat (idx (a ! nat j)) = a ! nat j) \<longrightarrow> (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> used1 ! nat j = True \<and> (0 :: int) \<le> idx j \<and> idx j < n) \<and> (if (0 :: int) \<le> -(1 :: int) then ((0 :: int) \<le> -(1 :: int) \<and> -(1 :: int) < n) \<and> a ! nat (-(1 :: int)) = n else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> \<not>a ! nat j = n)) \<and> (\<forall>(posn :: int) (r :: int). ((0 :: int) \<le> r \<and> r \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < r \<longrightarrow> used1 ! nat j = True \<and> (0 :: int) \<le> idx j \<and> idx j < n) \<and> (if (0 :: int) \<le> posn then ((0 :: int) \<le> posn \<and> posn < n) \<and> a ! nat posn = n else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < r \<longrightarrow> \<not>a ! nat j = n) \<longrightarrow> (r < n \<longrightarrow> (0 :: int) \<le> r \<and> r < int (length used1)) \<and> (\<forall>(o3 :: bool). (if r < n then o3 = used1 ! nat r else o3 = False) \<longrightarrow> (if o3 = True then ((0 :: int) \<le> r \<and> r < int (length a)) \<and> (if a ! nat r = n then ((0 :: int) \<le> n - r \<and> n - (r + (1 :: int)) < n - r) \<and> ((0 :: int) \<le> r + (1 :: int) \<and> r + (1 :: int) \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < r + (1 :: int) \<longrightarrow> used1 ! nat j = True \<and> (0 :: int) \<le> idx j \<and> idx j < n) \<and> (if (0 :: int) \<le> r then ((0 :: int) \<le> r \<and> r < n) \<and> a ! nat r = n else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < r + (1 :: int) \<longrightarrow> \<not>a ! nat j = n) else ((0 :: int) \<le> n - r \<and> n - (r + (1 :: int)) < n - r) \<and> ((0 :: int) \<le> r + (1 :: int) \<and> r + (1 :: int) \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < r + (1 :: int) \<longrightarrow> used1 ! nat j = True \<and> (0 :: int) \<le> idx j \<and> idx j < n) \<and> (if (0 :: int) \<le> posn then ((0 :: int) \<le> posn \<and> posn < n) \<and> a ! nat posn = n else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < r + (1 :: int) \<longrightarrow> \<not>a ! nat j = n)) else \<forall>(o4 :: bool). (if r = n then o4 = (if (0 :: int) \<le> posn then True else False) else o4 = False) \<longrightarrow> (o4 = True \<longrightarrow> (let o5 :: int \<Rightarrow> int = idx(n := posn); o6 :: int = n + (1 :: int) in ((0 :: int) \<le> n \<and> n < o6) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < o6 \<longrightarrow> (0 :: int) \<le> o5 i \<and> o5 i < n))) \<and> ((o4 = True \<longrightarrow> (let o5 :: int \<Rightarrow> int = idx(n := posn) in \<exists>(i1 :: int) (i2 :: int). ((0 :: int) \<le> i1 \<and> i1 < i2 \<and> i2 < n + (1 :: int)) \<and> o5 i1 = o5 i2)) \<longrightarrow> ((0 :: int) \<le> r \<and> r \<le> int (length a)) \<and> \<not>mem r a \<and> (\<forall>(x :: int). (0 :: int) \<le> x \<and> x < r \<longrightarrow> mem x a)))))))) \<and> (o2 + (1 :: int) < (0 :: int) \<longrightarrow> (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> used ! nat j = True \<and> (0 :: int) \<le> o1 j \<and> o1 j < n) \<and> (if (0 :: int) \<le> -(1 :: int) then ((0 :: int) \<le> -(1 :: int) \<and> -(1 :: int) < n) \<and> a ! nat (-(1 :: int)) = n else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> \<not>a ! nat j = n)) \<and> (\<forall>(posn :: int) (r :: int). ((0 :: int) \<le> r \<and> r \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < r \<longrightarrow> used ! nat j = True \<and> (0 :: int) \<le> o1 j \<and> o1 j < n) \<and> (if (0 :: int) \<le> posn then ((0 :: int) \<le> posn \<and> posn < n) \<and> a ! nat posn = n else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < r \<longrightarrow> \<not>a ! nat j = n) \<longrightarrow> (r < n \<longrightarrow> (0 :: int) \<le> r \<and> r < int (length used)) \<and> (\<forall>(o3 :: bool). (if r < n then o3 = used ! nat r else o3 = False) \<longrightarrow> (if o3 = True then ((0 :: int) \<le> r \<and> r < int (length a)) \<and> (if a ! nat r = n then ((0 :: int) \<le> n - r \<and> n - (r + (1 :: int)) < n - r) \<and> ((0 :: int) \<le> r + (1 :: int) \<and> r + (1 :: int) \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < r + (1 :: int) \<longrightarrow> used ! nat j = True \<and> (0 :: int) \<le> o1 j \<and> o1 j < n) \<and> (if (0 :: int) \<le> r then ((0 :: int) \<le> r \<and> r < n) \<and> a ! nat r = n else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < r + (1 :: int) \<longrightarrow> \<not>a ! nat j = n) else ((0 :: int) \<le> n - r \<and> n - (r + (1 :: int)) < n - r) \<and> ((0 :: int) \<le> r + (1 :: int) \<and> r + (1 :: int) \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < r + (1 :: int) \<longrightarrow> used ! nat j = True \<and> (0 :: int) \<le> o1 j \<and> o1 j < n) \<and> (if (0 :: int) \<le> posn then ((0 :: int) \<le> posn \<and> posn < n) \<and> a ! nat posn = n else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < r + (1 :: int) \<longrightarrow> \<not>a ! nat j = n)) else \<forall>(o4 :: bool). (if r = n then o4 = (if (0 :: int) \<le> posn then True else False) else o4 = False) \<longrightarrow> (o4 = True \<longrightarrow> (let o5 :: int \<Rightarrow> int = o1(n := posn); o6 :: int = n + (1 :: int) in ((0 :: int) \<le> n \<and> n < o6) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < o6 \<longrightarrow> (0 :: int) \<le> o5 i \<and> o5 i < n))) \<and> ((o4 = True \<longrightarrow> (let o5 :: int \<Rightarrow> int = o1(n := posn) in \<exists>(i1 :: int) (i2 :: int). ((0 :: int) \<le> i1 \<and> i1 < i2 \<and> i2 < n + (1 :: int)) \<and> o5 i1 = o5 i2)) \<longrightarrow> ((0 :: int) \<le> r \<and> r \<le> int (length a)) \<and> \<not>mem r a \<and> (\<forall>(x :: int). (0 :: int) \<le> x \<and> x < r \<longrightarrow> mem x a))))))))"
  sorry
end
