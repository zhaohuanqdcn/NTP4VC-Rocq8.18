import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
open Classical
open Lean4Why3
namespace mergesort_array_Merge_mergeqtvc
axiom elt : Type
axiom inhabited_axiom_elt : Inhabited elt
attribute [instance] inhabited_axiom_elt
axiom le : elt -> elt -> Prop
axiom Refl (x : elt) : le x x
axiom Trans (x : elt) (y : elt) (z : elt) (fact0 : le x y) (fact1 : le y z) : le x z
axiom Total (x : elt) (y : elt) : le x y ∨ le y x
noncomputable def sorted_sub (a : List elt) (l : ℤ) (u : ℤ) := ∀(i1 : ℤ) (i2 : ℤ), l ≤ i1 ∧ i1 < i2 ∧ i2 < u → le (a[Int.toNat i1]!) (a[Int.toNat i2]!)
noncomputable def sorted (a : List elt) := ∀(i1 : ℤ) (i2 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < i2 ∧ i2 < Int.ofNat (List.length a) → le (a[Int.toNat i1]!) (a[Int.toNat i2]!)
theorem merge'vc (l : ℤ) (m : ℤ) (r : ℤ) (tmp : List elt) (a : List elt) (fact0 : (0 : ℤ) ≤ l) (fact1 : l ≤ m) (fact2 : m ≤ r) (fact3 : r ≤ Int.ofNat (List.length tmp)) (fact4 : List.length tmp = List.length a) (fact5 : sorted_sub tmp l m) (fact6 : sorted_sub tmp m r) : let o1 : ℤ := r - (1 : ℤ); (l ≤ o1 + (1 : ℤ) → ((l ≤ l ∧ l ≤ m ∧ m ≤ m ∧ m ≤ r) ∧ l - l + m - m = l - l ∧ sorted_sub a l l ∧ (∀(x : ℤ) (y : ℤ), l ≤ x ∧ x < l → l ≤ y ∧ y < m → le (a[Int.toNat x]!) (tmp[Int.toNat y]!)) ∧ (∀(x : ℤ) (y : ℤ), l ≤ x ∧ x < l → m ≤ y ∧ y < r → le (a[Int.toNat x]!) (tmp[Int.toNat y]!)) ∧ (∀(v : elt), Int.ofNat (Lean4Why3.map_occ v (getElem! tmp ∘ Int.toNat) l l) + Int.ofNat (Lean4Why3.map_occ v (getElem! tmp ∘ Int.toNat) m m) = Int.ofNat (Lean4Why3.map_occ v (getElem! a ∘ Int.toNat) l l))) ∧ (∀(j : ℤ) (i : ℤ) (a1 : List elt), List.length a1 = List.length a → (∀(k : ℤ), (l ≤ k ∧ k ≤ o1) ∧ (l ≤ i ∧ i ≤ m ∧ m ≤ j ∧ j ≤ r) ∧ i - l + j - m = k - l ∧ sorted_sub a1 l k ∧ (∀(x : ℤ) (y : ℤ), l ≤ x ∧ x < k → i ≤ y ∧ y < m → le (a1[Int.toNat x]!) (tmp[Int.toNat y]!)) ∧ (∀(x : ℤ) (y : ℤ), l ≤ x ∧ x < k → j ≤ y ∧ y < r → le (a1[Int.toNat x]!) (tmp[Int.toNat y]!)) ∧ (∀(v : elt), Int.ofNat (Lean4Why3.map_occ v (getElem! tmp ∘ Int.toNat) l i) + Int.ofNat (Lean4Why3.map_occ v (getElem! tmp ∘ Int.toNat) m j) = Int.ofNat (Lean4Why3.map_occ v (getElem! a1 ∘ Int.toNat) l k)) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < l ∨ r ≤ i1 ∧ i1 < Int.ofNat (List.length a1) → a1[Int.toNat i1]! = a[Int.toNat i1]!) → (i < m → ¬j = r → ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length tmp)) ∧ (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length tmp)) ∧ (∀(o2 : Bool), (if i < m then if j = r then o2 = true else o2 = (if le (tmp[Int.toNat i]!) (tmp[Int.toNat j]!) then true else false) else o2 = false) → (if o2 = true then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length tmp)) ∧ (let o3 : elt := tmp[Int.toNat i]!; ((0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length a1)) ∧ (List.length (List.set a1 (Int.toNat k) o3) = List.length a1 → getElem! (List.set a1 (Int.toNat k) o3) ∘ Int.toNat = Function.update (getElem! a1 ∘ Int.toNat) k o3 → (l ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ m ∧ m ≤ j ∧ j ≤ r) ∧ i + (1 : ℤ) - l + j - m = k + (1 : ℤ) - l ∧ sorted_sub (List.set a1 (Int.toNat k) o3) l (k + (1 : ℤ)) ∧ (∀(x : ℤ) (y : ℤ), l ≤ x ∧ x < k + (1 : ℤ) → i + (1 : ℤ) ≤ y ∧ y < m → le ((List.set a1 (Int.toNat k) o3)[Int.toNat x]!) (tmp[Int.toNat y]!)) ∧ (∀(x : ℤ) (y : ℤ), l ≤ x ∧ x < k + (1 : ℤ) → j ≤ y ∧ y < r → le ((List.set a1 (Int.toNat k) o3)[Int.toNat x]!) (tmp[Int.toNat y]!)) ∧ (∀(v : elt), Int.ofNat (Lean4Why3.map_occ v (getElem! tmp ∘ Int.toNat) l (i + (1 : ℤ))) + Int.ofNat (Lean4Why3.map_occ v (getElem! tmp ∘ Int.toNat) m j) = Int.ofNat (Lean4Why3.map_occ v (getElem! (List.set a1 (Int.toNat k) o3) ∘ Int.toNat) l (k + (1 : ℤ)))) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < l ∨ r ≤ i1 ∧ i1 < Int.ofNat (List.length (List.set a1 (Int.toNat k) o3)) → (List.set a1 (Int.toNat k) o3)[Int.toNat i1]! = a[Int.toNat i1]!))) else ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length tmp)) ∧ (let o3 : elt := tmp[Int.toNat j]!; ((0 : ℤ) ≤ k ∧ k < Int.ofNat (List.length a1)) ∧ (List.length (List.set a1 (Int.toNat k) o3) = List.length a1 → getElem! (List.set a1 (Int.toNat k) o3) ∘ Int.toNat = Function.update (getElem! a1 ∘ Int.toNat) k o3 → (l ≤ i ∧ i ≤ m ∧ m ≤ j + (1 : ℤ) ∧ j + (1 : ℤ) ≤ r) ∧ i - l + (j + (1 : ℤ)) - m = k + (1 : ℤ) - l ∧ sorted_sub (List.set a1 (Int.toNat k) o3) l (k + (1 : ℤ)) ∧ (∀(x : ℤ) (y : ℤ), l ≤ x ∧ x < k + (1 : ℤ) → i ≤ y ∧ y < m → le ((List.set a1 (Int.toNat k) o3)[Int.toNat x]!) (tmp[Int.toNat y]!)) ∧ (∀(x : ℤ) (y : ℤ), l ≤ x ∧ x < k + (1 : ℤ) → j + (1 : ℤ) ≤ y ∧ y < r → le ((List.set a1 (Int.toNat k) o3)[Int.toNat x]!) (tmp[Int.toNat y]!)) ∧ (∀(v : elt), Int.ofNat (Lean4Why3.map_occ v (getElem! tmp ∘ Int.toNat) l i) + Int.ofNat (Lean4Why3.map_occ v (getElem! tmp ∘ Int.toNat) m (j + (1 : ℤ))) = Int.ofNat (Lean4Why3.map_occ v (getElem! (List.set a1 (Int.toNat k) o3) ∘ Int.toNat) l (k + (1 : ℤ)))) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < l ∨ r ≤ i1 ∧ i1 < Int.ofNat (List.length (List.set a1 (Int.toNat k) o3)) → (List.set a1 (Int.toNat k) o3)[Int.toNat i1]! = a[Int.toNat i1]!)))))) ∧ ((l ≤ i ∧ i ≤ m ∧ m ≤ j ∧ j ≤ r) ∧ i - l + j - m = o1 + (1 : ℤ) - l ∧ sorted_sub a1 l (o1 + (1 : ℤ)) ∧ (∀(x : ℤ) (y : ℤ), l ≤ x ∧ x < o1 + (1 : ℤ) → i ≤ y ∧ y < m → le (a1[Int.toNat x]!) (tmp[Int.toNat y]!)) ∧ (∀(x : ℤ) (y : ℤ), l ≤ x ∧ x < o1 + (1 : ℤ) → j ≤ y ∧ y < r → le (a1[Int.toNat x]!) (tmp[Int.toNat y]!)) ∧ (∀(v : elt), Int.ofNat (Lean4Why3.map_occ v (getElem! tmp ∘ Int.toNat) l i) + Int.ofNat (Lean4Why3.map_occ v (getElem! tmp ∘ Int.toNat) m j) = Int.ofNat (Lean4Why3.map_occ v (getElem! a1 ∘ Int.toNat) l (o1 + (1 : ℤ)))) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < l ∨ r ≤ i1 ∧ i1 < Int.ofNat (List.length a1) → a1[Int.toNat i1]! = a[Int.toNat i1]!) → sorted_sub a1 l r ∧ List.permut_sub tmp a1 (Int.toNat l) (Int.toNat r) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < l ∨ r ≤ i1 ∧ i1 < Int.ofNat (List.length a1) → a1[Int.toNat i1]! = a[Int.toNat i1]!)))) ∧ (o1 + (1 : ℤ) < l → sorted_sub a l r ∧ List.permut_sub tmp a (Int.toNat l) (Int.toNat r))
  := sorry
end mergesort_array_Merge_mergeqtvc
