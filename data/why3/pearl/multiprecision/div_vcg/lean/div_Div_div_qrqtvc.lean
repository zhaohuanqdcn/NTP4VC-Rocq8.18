import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.mul.Mul
open Classical
open Lean4Why3
namespace div_Div_div_qrqtvc
noncomputable def reciprocal (v : BitVec 64) (d : BitVec 64) := BitVec.toUInt v = (((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) - (1 : ℤ)) / BitVec.toUInt d - ((18446744073709551615 : ℤ) + (1 : ℤ))
noncomputable def reciprocal_3by2 (v : BitVec 64) (dh : BitVec 64) (dl : BitVec 64) := BitVec.toUInt v = (((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) - (1 : ℤ)) / (BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh) - ((18446744073709551615 : ℤ) + (1 : ℤ))
noncomputable def normalized (x : C.ptr (BitVec 64)) (sz : BitVec 32) := C.valid x (BitVec.toInt sz) ∧ ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt (C.pelts x (C.offset x + BitVec.toInt sz - (1 : ℤ)))
theorem div_qr'vc (sy : BitVec 32) (sx : BitVec 32) (x : C.ptr (BitVec 64)) (y : C.ptr (BitVec 64)) (q : C.ptr (BitVec 64)) (r : C.ptr (BitVec 64)) (nx : C.ptr (BitVec 64)) (ny : C.ptr (BitVec 64)) (o1 : Bool) (fact0 : (1 : ℤ) ≤ BitVec.toInt sy) (fact1 : BitVec.toInt sy ≤ BitVec.toInt sx) (fact2 : BitVec.toInt sx ≤ (2147483647 : ℤ) - (1 : ℤ)) (fact3 : C.valid x (BitVec.toInt sx)) (fact4 : C.valid y (BitVec.toInt sy)) (fact5 : C.valid q (BitVec.toInt sx - BitVec.toInt sy + (1 : ℤ))) (fact6 : C.valid r (BitVec.toInt sy)) (fact7 : C.valid nx (BitVec.toInt sx + (1 : ℤ))) (fact8 : C.valid ny (BitVec.toInt sy)) (fact9 : C.writable nx = true) (fact10 : C.writable ny = true) (fact11 : (0 : ℤ) < BitVec.toUInt (C.pelts y (C.offset y + BitVec.toInt sy - (1 : ℤ)))) (fact12 : C.writable q = true) (fact13 : C.writable r = true) (fact14 : BitVec.toInt sy = BitVec.toInt (1 : BitVec 32) → o1 = true) (fact15 : o1 = true → sy = (1 : BitVec 32)) : if o1 = true then (C.min y ≤ C.offset y ∧ C.offset y < C.max y) ∧ (let o2 : BitVec 64 := C.pelts y (C.offset y); (C.valid x (BitVec.toInt sx) ∧ C.valid q (BitVec.toInt sx) ∧ C.writable q = true ∧ (0 : ℤ) < BitVec.toInt sx ∧ (0 : ℤ) < BitVec.toUInt o2) ∧ (∀(q1 : C.ptr (BitVec 64)), List.length (C.data q1) = List.length (C.data q) ∧ C.offset q1 = C.offset q ∧ C.min q1 = C.min q ∧ C.max q1 = C.max q ∧ C.writable q1 = C.writable q ∧ C.zone1 q1 = C.zone1 q → (∀(lr : BitVec 64), Lemmas.value x (BitVec.toInt sx) = Lemmas.value q1 (BitVec.toInt sx) * BitVec.toUInt o2 + BitVec.toUInt lr ∧ BitVec.toUInt lr < BitVec.toUInt o2 → ((C.min r ≤ C.offset r ∧ C.offset r < C.max r) ∧ C.writable r = true) ∧ (∀(r1 : C.ptr (BitVec 64)), List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → C.pelts r1 = Function.update (C.pelts r) (C.offset r1) lr → Lemmas.value x (BitVec.toInt sx) = Lemmas.value q1 (BitVec.toInt sx - BitVec.toInt sy + (1 : ℤ)) * Lemmas.value y (BitVec.toInt sy) + Lemmas.value r1 (BitVec.toInt sy) ∧ Lemmas.value r1 (BitVec.toInt sy) < Lemmas.value y (BitVec.toInt sy))))) else ∀(o2 : Bool), (BitVec.toInt sy = BitVec.toInt (2 : BitVec 32) → o2 = true) ∧ (o2 = true → sy = (2 : BitVec 32)) → (if o2 = true then int'32_in_bounds (BitVec.toInt sy - (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt sy - (1 : ℤ) → (C.min y ≤ C.offset y + BitVec.toInt o3 ∧ C.offset y + BitVec.toInt o3 < C.max y) ∧ (let o4 : BitVec 64 := C.pelts y (C.offset y + BitVec.toInt o3); (0 : ℤ) < BitVec.toUInt o4 ∧ (∀(clz : BitVec 32), HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)) * BitVec.toUInt o4 < (18446744073709551615 : ℤ) + (1 : ℤ) ∧ (18446744073709551615 : ℤ) + (1 : ℤ) ≤ (2 : ℤ) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)) * BitVec.toUInt o4 ∧ ((0 : ℤ) ≤ BitVec.toInt clz ∧ BitVec.toInt clz < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)) * BitVec.toUInt o4 ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)) → (∀(o5 : Bool), (BitVec.toInt clz = BitVec.toInt (0 : BitVec 32) → o5 = true) ∧ (o5 = true → clz = (0 : BitVec 32)) → (if o5 = true then (C.valid x (BitVec.toInt sx) ∧ C.valid nx (BitVec.toInt sx) ∧ C.writable nx = true) ∧ (∀(nx1 : C.ptr (BitVec 64)), List.length (C.data nx1) = List.length (C.data nx) ∧ C.offset nx1 = C.offset nx ∧ C.min nx1 = C.min nx ∧ C.max nx1 = C.max nx ∧ C.writable nx1 = C.writable nx ∧ C.zone1 nx1 = C.zone1 nx → Lemmas.map_eq_sub_shift (C.pelts nx1) (C.pelts x) (C.offset nx1) (C.offset x) (BitVec.toInt sx) ∧ (∀(j : ℤ), j < C.offset nx1 ∨ C.offset nx1 + BitVec.toInt sx ≤ j → C.pelts nx1 j = C.pelts nx j) → ((C.min nx1 ≤ C.offset nx1 + BitVec.toInt sx ∧ C.offset nx1 + BitVec.toInt sx < C.max nx1) ∧ C.writable nx1 = true) ∧ (∀(nx2 : C.ptr (BitVec 64)), List.length (C.data nx2) = List.length (C.data nx1) ∧ C.offset nx2 = C.offset nx1 ∧ C.min nx2 = C.min nx1 ∧ C.max nx2 = C.max nx1 ∧ C.writable nx2 = C.writable nx1 ∧ C.zone1 nx2 = C.zone1 nx1 → C.pelts nx2 = Function.update (C.pelts nx1) (C.offset nx2 + BitVec.toInt sx) (0 : BitVec 64) ∧ C.pelts nx2 (C.offset nx2 + BitVec.toInt sx) = (0 : BitVec 64) → int'32_in_bounds (BitVec.toInt sx + (1 : ℤ)) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt sx + (1 : ℤ) → ((2 : ℤ) ≤ BitVec.toInt o6 ∧ C.valid nx2 (BitVec.toInt o6) ∧ C.valid y (2 : ℤ) ∧ C.valid q (BitVec.toInt o6 - (2 : ℤ)) ∧ ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt (C.pelts y (C.offset y + (1 : ℤ))) ∧ C.writable q = true ∧ C.writable nx2 = true) ∧ (∀(nx3 : C.ptr (BitVec 64)) (q1 : C.ptr (BitVec 64)), List.length (C.data nx3) = List.length (C.data nx2) ∧ C.offset nx3 = C.offset nx2 ∧ C.min nx3 = C.min nx2 ∧ C.max nx3 = C.max nx2 ∧ C.writable nx3 = C.writable nx2 ∧ C.zone1 nx3 = C.zone1 nx2 → List.length (C.data q1) = List.length (C.data q) ∧ C.offset q1 = C.offset q ∧ C.min q1 = C.min q ∧ C.max q1 = C.max q ∧ C.writable q1 = C.writable q ∧ C.zone1 q1 = C.zone1 q → (∀(x_qh : BitVec 64), Lemmas.value nx2 (BitVec.toInt o6) = (Lemmas.value q1 (BitVec.toInt o6 - (2 : ℤ)) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o6 - (2 : ℤ))) * BitVec.toUInt x_qh) * Lemmas.value y (2 : ℤ) + Lemmas.value nx3 (2 : ℤ) ∧ Lemmas.value nx3 (2 : ℤ) < Lemmas.value y (2 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toUInt x_qh ∧ BitVec.toUInt x_qh ≤ (1 : ℤ) → (C.valid nx3 (BitVec.toInt sy) ∧ C.valid r (BitVec.toInt sy) ∧ C.writable r = true) ∧ (∀(r1 : C.ptr (BitVec 64)), List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → Lemmas.map_eq_sub_shift (C.pelts r1) (C.pelts nx3) (C.offset r1) (C.offset nx3) (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sy ≤ j → C.pelts r1 j = C.pelts r j) → Lemmas.value x (BitVec.toInt sx) = Lemmas.value q1 (BitVec.toInt sx - BitVec.toInt sy + (1 : ℤ)) * Lemmas.value y (BitVec.toInt sy) + Lemmas.value r1 (BitVec.toInt sy) ∧ Lemmas.value r1 (BitVec.toInt sy) < Lemmas.value y (BitVec.toInt sy))))))) else (0 : ℤ) ≤ BitVec.toInt clz ∧ (∀(o6 : BitVec 64), BitVec.toUInt o6 = BitVec.toInt clz → (((0 : ℤ) < BitVec.toUInt o6 ∧ BitVec.toUInt o6 < (64 : ℤ)) ∧ C.valid ny (BitVec.toInt sy) ∧ C.valid y (BitVec.toInt sy) ∧ C.writable ny = true ∧ (0 : ℤ) < BitVec.toInt sy) ∧ (∀(ny1 : C.ptr (BitVec 64)), List.length (C.data ny1) = List.length (C.data ny) ∧ C.offset ny1 = C.offset ny ∧ C.min ny1 = C.min ny ∧ C.max ny1 = C.max ny ∧ C.writable ny1 = C.writable ny ∧ C.zone1 ny1 = C.zone1 ny → (∀(x_c : BitVec 64), Lemmas.value ny1 (BitVec.toInt sy) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sy)) * BitVec.toUInt x_c = Lemmas.value y (BitVec.toInt sy) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o6)) → (0 : ℤ) ≤ BitVec.toInt clz ∧ (∀(o7 : BitVec 64), BitVec.toUInt o7 = BitVec.toInt clz → (((0 : ℤ) < BitVec.toUInt o7 ∧ BitVec.toUInt o7 < (64 : ℤ)) ∧ C.valid nx (BitVec.toInt sx) ∧ C.valid x (BitVec.toInt sx) ∧ C.writable nx = true ∧ (0 : ℤ) < BitVec.toInt sx) ∧ (∀(nx1 : C.ptr (BitVec 64)), List.length (C.data nx1) = List.length (C.data nx) ∧ C.offset nx1 = C.offset nx ∧ C.min nx1 = C.min nx ∧ C.max nx1 = C.max nx ∧ C.writable nx1 = C.writable nx ∧ C.zone1 nx1 = C.zone1 nx → (∀(h : BitVec 64), Lemmas.value nx1 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt h = Lemmas.value x (BitVec.toInt sx) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o7)) → ((C.min nx1 ≤ C.offset nx1 + BitVec.toInt sx ∧ C.offset nx1 + BitVec.toInt sx < C.max nx1) ∧ C.writable nx1 = true) ∧ (∀(nx2 : C.ptr (BitVec 64)), List.length (C.data nx2) = List.length (C.data nx1) ∧ C.offset nx2 = C.offset nx1 ∧ C.min nx2 = C.min nx1 ∧ C.max nx2 = C.max nx1 ∧ C.writable nx2 = C.writable nx1 ∧ C.zone1 nx2 = C.zone1 nx1 → C.pelts nx2 = Function.update (C.pelts nx1) (C.offset nx2 + BitVec.toInt sx) h ∧ C.pelts nx2 (C.offset nx2 + BitVec.toInt sx) = h → int'32_in_bounds (BitVec.toInt sx + (1 : ℤ)) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt sx + (1 : ℤ) → ((2 : ℤ) ≤ BitVec.toInt o8 ∧ C.valid nx2 (BitVec.toInt o8) ∧ C.valid ny1 (2 : ℤ) ∧ C.valid q (BitVec.toInt o8 - (2 : ℤ)) ∧ ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt (C.pelts ny1 (C.offset ny1 + (1 : ℤ))) ∧ C.writable q = true ∧ C.writable nx2 = true) ∧ (∀(nx3 : C.ptr (BitVec 64)) (q1 : C.ptr (BitVec 64)), List.length (C.data nx3) = List.length (C.data nx2) ∧ C.offset nx3 = C.offset nx2 ∧ C.min nx3 = C.min nx2 ∧ C.max nx3 = C.max nx2 ∧ C.writable nx3 = C.writable nx2 ∧ C.zone1 nx3 = C.zone1 nx2 → List.length (C.data q1) = List.length (C.data q) ∧ C.offset q1 = C.offset q ∧ C.min q1 = C.min q ∧ C.max q1 = C.max q ∧ C.writable q1 = C.writable q ∧ C.zone1 q1 = C.zone1 q → (∀(x_qh : BitVec 64), Lemmas.value nx2 (BitVec.toInt o8) = (Lemmas.value q1 (BitVec.toInt o8 - (2 : ℤ)) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o8 - (2 : ℤ))) * BitVec.toUInt x_qh) * Lemmas.value ny1 (2 : ℤ) + Lemmas.value nx3 (2 : ℤ) ∧ Lemmas.value nx3 (2 : ℤ) < Lemmas.value ny1 (2 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toUInt x_qh ∧ BitVec.toUInt x_qh ≤ (1 : ℤ) → (0 : ℤ) ≤ BitVec.toInt clz ∧ (∀(o9 : BitVec 64), BitVec.toUInt o9 = BitVec.toInt clz → (C.valid nx3 (BitVec.toInt sy) ∧ C.valid r (BitVec.toInt sy) ∧ ((0 : ℤ) < BitVec.toUInt o9 ∧ BitVec.toUInt o9 < (64 : ℤ)) ∧ (0 : ℤ) < BitVec.toInt sy ∧ C.writable r = true) ∧ (∀(r1 : C.ptr (BitVec 64)), List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → (∀(x_l : BitVec 64), BitVec.toUInt x_l + ((18446744073709551615 : ℤ) + (1 : ℤ)) * Lemmas.value r1 (BitVec.toInt sy) = Lemmas.value nx3 (BitVec.toInt sy) * HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - BitVec.toUInt o9)) → Lemmas.value x (BitVec.toInt sx) = Lemmas.value q1 (BitVec.toInt sx - BitVec.toInt sy + (1 : ℤ)) * Lemmas.value y (BitVec.toInt sy) + Lemmas.value r1 (BitVec.toInt sy) ∧ Lemmas.value r1 (BitVec.toInt sy) < Lemmas.value y (BitVec.toInt sy))))))))))))))))))) else int'32_in_bounds (BitVec.toInt sy - (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt sy - (1 : ℤ) → (C.min y ≤ C.offset y + BitVec.toInt o3 ∧ C.offset y + BitVec.toInt o3 < C.max y) ∧ int'32_in_bounds (BitVec.toInt sx - (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt sx - (1 : ℤ) → (C.min x ≤ C.offset x + BitVec.toInt o4 ∧ C.offset x + BitVec.toInt o4 < C.max x) ∧ (∀(adjust : BitVec 32), (if BitVec.toUInt (C.pelts y (C.offset y + BitVec.toInt o3)) ≤ BitVec.toUInt (C.pelts x (C.offset x + BitVec.toInt o4)) then adjust = (1 : BitVec 32) else adjust = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt sy - (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt sy - (1 : ℤ) → (C.min y ≤ C.offset y + BitVec.toInt o5 ∧ C.offset y + BitVec.toInt o5 < C.max y) ∧ (let o6 : BitVec 64 := C.pelts y (C.offset y + BitVec.toInt o5); (0 : ℤ) < BitVec.toUInt o6 ∧ (∀(clz : BitVec 32), HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)) * BitVec.toUInt o6 < (18446744073709551615 : ℤ) + (1 : ℤ) ∧ (18446744073709551615 : ℤ) + (1 : ℤ) ≤ (2 : ℤ) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)) * BitVec.toUInt o6 ∧ ((0 : ℤ) ≤ BitVec.toInt clz ∧ BitVec.toInt clz < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)) * BitVec.toUInt o6 ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)) → (let p : ℤ := HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)); ∀(o7 : Bool), (BitVec.toInt clz = BitVec.toInt (0 : BitVec 32) → o7 = true) ∧ (o7 = true → clz = (0 : BitVec 32)) → (if o7 = true then (C.valid x (BitVec.toInt sx) ∧ C.valid nx (BitVec.toInt sx) ∧ C.writable nx = true) ∧ (∀(nx1 : C.ptr (BitVec 64)), List.length (C.data nx1) = List.length (C.data nx) ∧ C.offset nx1 = C.offset nx ∧ C.min nx1 = C.min nx ∧ C.max nx1 = C.max nx ∧ C.writable nx1 = C.writable nx ∧ C.zone1 nx1 = C.zone1 nx → Lemmas.map_eq_sub_shift (C.pelts nx1) (C.pelts x) (C.offset nx1) (C.offset x) (BitVec.toInt sx) ∧ (∀(j : ℤ), j < C.offset nx1 ∨ C.offset nx1 + BitVec.toInt sx ≤ j → C.pelts nx1 j = C.pelts nx j) → ((C.min nx1 ≤ C.offset nx1 + BitVec.toInt sx ∧ C.offset nx1 + BitVec.toInt sx < C.max nx1) ∧ C.writable nx1 = true) ∧ (∀(nx2 : C.ptr (BitVec 64)), List.length (C.data nx2) = List.length (C.data nx1) ∧ C.offset nx2 = C.offset nx1 ∧ C.min nx2 = C.min nx1 ∧ C.max nx2 = C.max nx1 ∧ C.writable nx2 = C.writable nx1 ∧ C.zone1 nx2 = C.zone1 nx1 → C.pelts nx2 = Function.update (C.pelts nx1) (C.offset nx2 + BitVec.toInt sx) (0 : BitVec 64) ∧ C.pelts nx2 (C.offset nx2 + BitVec.toInt sx) = (0 : BitVec 64) → int'32_in_bounds (BitVec.toInt sx + BitVec.toInt adjust) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt sx + BitVec.toInt adjust → (((3 : ℤ) ≤ BitVec.toInt sy ∧ BitVec.toInt sy ≤ BitVec.toInt o8) ∧ C.valid nx2 (BitVec.toInt o8) ∧ C.valid y (BitVec.toInt sy) ∧ C.valid q (BitVec.toInt o8 - BitVec.toInt sy) ∧ C.writable q = true ∧ C.writable nx2 = true ∧ normalized y sy) ∧ (∀(nx3 : C.ptr (BitVec 64)) (q1 : C.ptr (BitVec 64)), List.length (C.data nx3) = List.length (C.data nx2) ∧ C.offset nx3 = C.offset nx2 ∧ C.min nx3 = C.min nx2 ∧ C.max nx3 = C.max nx2 ∧ C.writable nx3 = C.writable nx2 ∧ C.zone1 nx3 = C.zone1 nx2 → List.length (C.data q1) = List.length (C.data q) ∧ C.offset q1 = C.offset q ∧ C.min q1 = C.min q ∧ C.max q1 = C.max q ∧ C.writable q1 = C.writable q ∧ C.zone1 q1 = C.zone1 q → (∀(x_qh : BitVec 64), Lemmas.value nx2 (BitVec.toInt o8) = (Lemmas.value q1 (BitVec.toInt o8 - BitVec.toInt sy) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o8 - BitVec.toInt sy)) * BitVec.toUInt x_qh) * Lemmas.value y (BitVec.toInt sy) + Lemmas.value nx3 (BitVec.toInt sy) ∧ Lemmas.value nx3 (BitVec.toInt sy) < Lemmas.value y (BitVec.toInt sy) ∧ (0 : ℤ) ≤ BitVec.toUInt x_qh ∧ BitVec.toUInt x_qh ≤ (1 : ℤ) → (C.valid nx3 (BitVec.toInt sy) ∧ C.valid r (BitVec.toInt sy) ∧ C.writable r = true) ∧ (∀(r1 : C.ptr (BitVec 64)), List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → Lemmas.map_eq_sub_shift (C.pelts r1) (C.pelts nx3) (C.offset r1) (C.offset nx3) (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sy ≤ j → C.pelts r1 j = C.pelts r j) → (∀(o9 : Bool), (BitVec.toInt adjust = BitVec.toInt (0 : BitVec 32) → o9 = true) ∧ (o9 = true → adjust = (0 : BitVec 32)) → (if o9 = true then int'32_in_bounds (BitVec.toInt sx - BitVec.toInt sy) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt sx - BitVec.toInt sy → ((C.min q1 ≤ C.offset q1 + BitVec.toInt o10 ∧ C.offset q1 + BitVec.toInt o10 < C.max q1) ∧ C.writable q1 = true) ∧ (∀(q2 : C.ptr (BitVec 64)), List.length (C.data q2) = List.length (C.data q1) ∧ C.offset q2 = C.offset q1 ∧ C.min q2 = C.min q1 ∧ C.max q2 = C.max q1 ∧ C.writable q2 = C.writable q1 ∧ C.zone1 q2 = C.zone1 q1 → C.pelts q2 = Function.update (C.pelts q1) (C.offset q2 + BitVec.toInt o10) (0 : BitVec 64) ∧ C.pelts q2 (C.offset q2 + BitVec.toInt o10) = (0 : BitVec 64) → Lemmas.value q2 (BitVec.toInt sx - BitVec.toInt sy + (1 : ℤ)) = Lemmas.value q1 (BitVec.toInt sx - BitVec.toInt sy + BitVec.toInt adjust))) else Lemmas.value q1 (BitVec.toInt sx - BitVec.toInt sy + (1 : ℤ)) = Lemmas.value q1 (BitVec.toInt sx - BitVec.toInt sy + BitVec.toInt adjust))) ∧ (∀(q2 : C.ptr (BitVec 64)), List.length (C.data q2) = List.length (C.data q1) ∧ C.offset q2 = C.offset q1 ∧ C.min q2 = C.min q1 ∧ C.max q2 = C.max q1 ∧ C.writable q2 = C.writable q1 ∧ C.zone1 q2 = C.zone1 q1 → Lemmas.value q2 (BitVec.toInt sx - BitVec.toInt sy + (1 : ℤ)) = Lemmas.value q1 (BitVec.toInt sx - BitVec.toInt sy + BitVec.toInt adjust) → Lemmas.value x (BitVec.toInt sx) = Lemmas.value q2 (BitVec.toInt sx - BitVec.toInt sy + (1 : ℤ)) * Lemmas.value y (BitVec.toInt sy) + Lemmas.value r1 (BitVec.toInt sy) ∧ Lemmas.value r1 (BitVec.toInt sy) < Lemmas.value y (BitVec.toInt sy)))))))) else (0 : ℤ) ≤ BitVec.toInt clz ∧ (∀(o8 : BitVec 64), BitVec.toUInt o8 = BitVec.toInt clz → (((0 : ℤ) < BitVec.toUInt o8 ∧ BitVec.toUInt o8 < (64 : ℤ)) ∧ C.valid ny (BitVec.toInt sy) ∧ C.valid y (BitVec.toInt sy) ∧ C.writable ny = true ∧ (0 : ℤ) < BitVec.toInt sy) ∧ (∀(ny1 : C.ptr (BitVec 64)), List.length (C.data ny1) = List.length (C.data ny) ∧ C.offset ny1 = C.offset ny ∧ C.min ny1 = C.min ny ∧ C.max ny1 = C.max ny ∧ C.writable ny1 = C.writable ny ∧ C.zone1 ny1 = C.zone1 ny → (∀(x_c : BitVec 64), Lemmas.value ny1 (BitVec.toInt sy) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sy)) * BitVec.toUInt x_c = Lemmas.value y (BitVec.toInt sy) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o8)) → (normalized ny1 sy ∧ Lemmas.value ny1 (BitVec.toInt sy) = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)) * Lemmas.value y (BitVec.toInt sy)) ∧ (normalized ny1 sy ∧ Lemmas.value ny1 (BitVec.toInt sy) = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt clz)) * Lemmas.value y (BitVec.toInt sy) → (0 : ℤ) ≤ BitVec.toInt clz ∧ (∀(o9 : BitVec 64), BitVec.toUInt o9 = BitVec.toInt clz → (((0 : ℤ) < BitVec.toUInt o9 ∧ BitVec.toUInt o9 < (64 : ℤ)) ∧ C.valid nx (BitVec.toInt sx) ∧ C.valid x (BitVec.toInt sx) ∧ C.writable nx = true ∧ (0 : ℤ) < BitVec.toInt sx) ∧ (∀(nx1 : C.ptr (BitVec 64)), List.length (C.data nx1) = List.length (C.data nx) ∧ C.offset nx1 = C.offset nx ∧ C.min nx1 = C.min nx ∧ C.max nx1 = C.max nx ∧ C.writable nx1 = C.writable nx ∧ C.zone1 nx1 = C.zone1 nx → (∀(h : BitVec 64), Lemmas.value nx1 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt h = Lemmas.value x (BitVec.toInt sx) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o9)) → ((C.min nx1 ≤ C.offset nx1 + BitVec.toInt sx ∧ C.offset nx1 + BitVec.toInt sx < C.max nx1) ∧ C.writable nx1 = true) ∧ (∀(nx2 : C.ptr (BitVec 64)), List.length (C.data nx2) = List.length (C.data nx1) ∧ C.offset nx2 = C.offset nx1 ∧ C.min nx2 = C.min nx1 ∧ C.max nx2 = C.max nx1 ∧ C.writable nx2 = C.writable nx1 ∧ C.zone1 nx2 = C.zone1 nx1 → C.pelts nx2 = Function.update (C.pelts nx1) (C.offset nx2 + BitVec.toInt sx) h ∧ C.pelts nx2 (C.offset nx2 + BitVec.toInt sx) = h → (∀(o10 : Bool), (BitVec.toInt adjust = BitVec.toInt (1 : BitVec 32) → o10 = true) ∧ (o10 = true → adjust = (1 : BitVec 32)) → Lemmas.value nx2 (BitVec.toInt sx + BitVec.toInt adjust) = p * Lemmas.value x (BitVec.toInt sx)) ∧ (Lemmas.value nx2 (BitVec.toInt sx + BitVec.toInt adjust) = p * Lemmas.value x (BitVec.toInt sx) → int'32_in_bounds (BitVec.toInt sx + BitVec.toInt adjust) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt sx + BitVec.toInt adjust → (((3 : ℤ) ≤ BitVec.toInt sy ∧ BitVec.toInt sy ≤ BitVec.toInt o10) ∧ C.valid nx2 (BitVec.toInt o10) ∧ C.valid ny1 (BitVec.toInt sy) ∧ C.valid q (BitVec.toInt o10 - BitVec.toInt sy) ∧ C.writable q = true ∧ C.writable nx2 = true ∧ normalized ny1 sy) ∧ (∀(nx3 : C.ptr (BitVec 64)) (q1 : C.ptr (BitVec 64)), List.length (C.data nx3) = List.length (C.data nx2) ∧ C.offset nx3 = C.offset nx2 ∧ C.min nx3 = C.min nx2 ∧ C.max nx3 = C.max nx2 ∧ C.writable nx3 = C.writable nx2 ∧ C.zone1 nx3 = C.zone1 nx2 → List.length (C.data q1) = List.length (C.data q) ∧ C.offset q1 = C.offset q ∧ C.min q1 = C.min q ∧ C.max q1 = C.max q ∧ C.writable q1 = C.writable q ∧ C.zone1 q1 = C.zone1 q → (∀(x_qh : BitVec 64), Lemmas.value nx2 (BitVec.toInt o10) = (Lemmas.value q1 (BitVec.toInt o10 - BitVec.toInt sy) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o10 - BitVec.toInt sy)) * BitVec.toUInt x_qh) * Lemmas.value ny1 (BitVec.toInt sy) + Lemmas.value nx3 (BitVec.toInt sy) ∧ Lemmas.value nx3 (BitVec.toInt sy) < Lemmas.value ny1 (BitVec.toInt sy) ∧ (0 : ℤ) ≤ BitVec.toUInt x_qh ∧ BitVec.toUInt x_qh ≤ (1 : ℤ) → (0 : ℤ) ≤ BitVec.toInt clz ∧ (∀(o11 : BitVec 64), BitVec.toUInt o11 = BitVec.toInt clz → (C.valid nx3 (BitVec.toInt sy) ∧ C.valid r (BitVec.toInt sy) ∧ ((0 : ℤ) < BitVec.toUInt o11 ∧ BitVec.toUInt o11 < (64 : ℤ)) ∧ (0 : ℤ) < BitVec.toInt sy ∧ C.writable r = true) ∧ (∀(r1 : C.ptr (BitVec 64)), List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → (∀(x_l : BitVec 64), BitVec.toUInt x_l + ((18446744073709551615 : ℤ) + (1 : ℤ)) * Lemmas.value r1 (BitVec.toInt sy) = Lemmas.value nx3 (BitVec.toInt sy) * HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - BitVec.toUInt o11)) → Lemmas.value nx3 (BitVec.toInt sy) = p * Lemmas.value r1 (BitVec.toInt sy) ∧ (Lemmas.value nx3 (BitVec.toInt sy) = p * Lemmas.value r1 (BitVec.toInt sy) → (∀(o12 : Bool), (BitVec.toInt adjust = BitVec.toInt (0 : BitVec 32) → o12 = true) ∧ (o12 = true → adjust = (0 : BitVec 32)) → (if o12 = true then int'32_in_bounds (BitVec.toInt sx - BitVec.toInt sy) ∧ (∀(o13 : BitVec 32), BitVec.toInt o13 = BitVec.toInt sx - BitVec.toInt sy → ((C.min q1 ≤ C.offset q1 + BitVec.toInt o13 ∧ C.offset q1 + BitVec.toInt o13 < C.max q1) ∧ C.writable q1 = true) ∧ (∀(q2 : C.ptr (BitVec 64)), List.length (C.data q2) = List.length (C.data q1) ∧ C.offset q2 = C.offset q1 ∧ C.min q2 = C.min q1 ∧ C.max q2 = C.max q1 ∧ C.writable q2 = C.writable q1 ∧ C.zone1 q2 = C.zone1 q1 → C.pelts q2 = Function.update (C.pelts q1) (C.offset q2 + BitVec.toInt o13) (0 : BitVec 64) ∧ C.pelts q2 (C.offset q2 + BitVec.toInt o13) = (0 : BitVec 64) → Lemmas.value q2 (BitVec.toInt sx - BitVec.toInt sy + (1 : ℤ)) = Lemmas.value q1 (BitVec.toInt sx - BitVec.toInt sy + BitVec.toInt adjust))) else Lemmas.value q1 (BitVec.toInt sx - BitVec.toInt sy + (1 : ℤ)) = Lemmas.value q1 (BitVec.toInt sx - BitVec.toInt sy + BitVec.toInt adjust))) ∧ (∀(q2 : C.ptr (BitVec 64)), List.length (C.data q2) = List.length (C.data q1) ∧ C.offset q2 = C.offset q1 ∧ C.min q2 = C.min q1 ∧ C.max q2 = C.max q1 ∧ C.writable q2 = C.writable q1 ∧ C.zone1 q2 = C.zone1 q1 → Lemmas.value q2 (BitVec.toInt sx - BitVec.toInt sy + (1 : ℤ)) = Lemmas.value q1 (BitVec.toInt sx - BitVec.toInt sy + BitVec.toInt adjust) → Lemmas.value x (BitVec.toInt sx) = Lemmas.value q2 (BitVec.toInt sx - BitVec.toInt sy + (1 : ℤ)) * Lemmas.value y (BitVec.toInt sy) + Lemmas.value r1 (BitVec.toInt sy) ∧ Lemmas.value r1 (BitVec.toInt sy) < Lemmas.value y (BitVec.toInt sy)))))))))))))))))))))))))))
  := sorry
end div_Div_div_qrqtvc
