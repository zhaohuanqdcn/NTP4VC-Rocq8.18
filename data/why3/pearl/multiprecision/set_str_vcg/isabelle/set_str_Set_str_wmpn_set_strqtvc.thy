theory set_str_Set_str_wmpn_set_strqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "mach.c_UChar" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/powm_Powm" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/sub_1_Sub_1" "../../lib/isabelle/stringlemmas_String_lemmas" "../../lib/isabelle/base_info_BaseInfo"
begin
theorem wmpn_set_str'vc:
  fixes sp :: "8 word ptr"
  fixes sn :: "32 word"
  fixes rp :: "64 word ptr"
  fixes sz :: "32 word"
  fixes base :: "32 word"
  assumes fact0: "valid sp (uint sn)"
  assumes fact1: "valid rp (sint sz)"
  assumes fact2: "(0 :: int) < sint sz"
  assumes fact3: "(0 :: int) \<le> uint sn"
  assumes fact4: "sint base ^\<^sub>i uint sn \<le> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint sz - (1 :: int))"
  assumes fact5: "(2 :: int) \<le> sint base"
  assumes fact6: "sint base \<le> (256 :: int)"
  assumes fact7: "writable rp = True"
  assumes fact8: "in_base (sint base) (pelts sp) (offset sp) (offset sp + uint sn)"
  assumes fact9: "uint sn = (0 :: int) \<longrightarrow> sn = (0 :: 32 word)"
  shows "if sn = (0 :: 32 word) then (0 :: int) \<le> sint sz - (1 :: int) \<and> value rp (0 :: int) = svalue (sint base) sp (uint sn) \<and> ((0 :: int) < uint sn \<longrightarrow> (0 :: int) < uint (pelts sp (offset sp)) \<longrightarrow> (0 :: int) < uint (pelts rp (offset rp + (0 :: int) - (1 :: int)))) else (0 :: int) \<le> sint base \<and> (\<forall>(o1 :: 64 word). uint o1 = sint base \<longrightarrow> ((2 :: int) \<le> uint o1 \<and> uint o1 \<le> (256 :: int)) \<and> (\<forall>(bits :: 32 word). ((0 :: int) \<le> uint bits \<and> uint bits \<le> (8 :: int)) \<and> (\<not>uint bits = (0 :: int) \<longrightarrow> (2 :: int) ^\<^sub>i uint bits = uint o1) \<and> (uint bits = (0 :: int) \<longrightarrow> (\<forall>(n :: int). (0 :: int) \<le> n \<longrightarrow> \<not>(2 :: int) ^\<^sub>i n = uint o1)) \<longrightarrow> (uint bits = (0 :: int) \<longrightarrow> bits = (0 :: 32 word)) \<longrightarrow> (if \<not>bits = (0 :: 32 word) then int'32_in_bounds (sint sz - (1 :: int)) \<and> (\<forall>(o2 :: 32 word). sint o2 = sint sz - (1 :: int) \<longrightarrow> (((0 :: int) < uint sn \<and> uint sn \<le> (2147483647 :: int)) \<and> (0 :: int) < sint o2 \<and> valid rp (sint o2) \<and> valid sp (uint sn) \<and> ((1 :: int) \<le> uint bits \<and> uint bits \<le> (8 :: int)) \<and> (2 :: int) ^\<^sub>i (uint bits * uint sn) \<le> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o2 \<and> writable rp = True \<and> in_base ((2 :: int) ^\<^sub>i uint bits) (pelts sp) (offset sp) (offset sp + uint sn)) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(r :: 32 word). ((0 :: int) \<le> sint r \<and> sint r \<le> sint o2) \<and> value rp1 (sint r) = svalue ((2 :: int) ^\<^sub>i uint bits) sp (uint sn) \<and> ((0 :: int) < sint r \<longrightarrow> (0 :: int) < uint (pelts rp1 (offset rp1 + sint r - (1 :: int)))) \<longrightarrow> sint r \<le> sint sz - (1 :: int) \<and> value rp1 (sint r) = svalue (sint base) sp (uint sn) \<and> ((0 :: int) < uint sn \<longrightarrow> (0 :: int) < uint (pelts sp (offset sp)) \<longrightarrow> (0 :: int) < uint (pelts rp1 (offset rp1 + sint r - (1 :: int))))))) else (0 :: int) \<le> sint base \<and> (\<forall>(o2 :: 64 word). uint o2 = sint base \<longrightarrow> ((2 :: int) \<le> uint o2 \<and> uint o2 \<le> (256 :: int)) \<and> (\<forall>(info :: wmpn_base_info). b info = uint o2 \<longrightarrow> (0 :: int) \<le> sint base \<and> (\<forall>(o3 :: 64 word). uint o3 = sint base \<longrightarrow> int'32_in_bounds (sint sz - (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint sz - (1 :: int) \<longrightarrow> (((0 :: int) < uint sn \<and> uint sn \<le> (2147483647 :: int)) \<and> (0 :: int) < sint o4 \<and> valid rp (sint o4) \<and> valid sp (uint sn) \<and> ((2 :: int) \<le> uint o3 \<and> uint o3 \<le> (256 :: int)) \<and> uint o3 ^\<^sub>i uint sn \<le> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o4 \<and> writable rp = True \<and> in_base (uint o3) (pelts sp) (offset sp) (offset sp + uint sn) \<and> b info = uint o3) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> (\<forall>(r :: 32 word). ((0 :: int) < svalue (uint o3) sp (uint sn) \<longrightarrow> (1 :: int) \<le> sint r \<and> sint r \<le> sint o4) \<and> value rp1 (sint r) = svalue (uint o3) sp (uint sn) \<and> ((0 :: int) < svalue (uint o3) sp (uint sn) \<longrightarrow> (0 :: int) < uint (pelts rp1 (offset rp1 + sint r - (1 :: int)))) \<and> (svalue (uint o3) sp (uint sn) = (0 :: int) \<longrightarrow> sint r = (1 :: int)) \<and> (0 :: int) < sint r \<longrightarrow> sint r \<le> sint sz - (1 :: int) \<and> value rp1 (sint r) = svalue (sint base) sp (uint sn) \<and> ((0 :: int) < uint sn \<longrightarrow> (0 :: int) < uint (pelts sp (offset sp)) \<longrightarrow> (0 :: int) < uint (pelts rp1 (offset rp1 + sint r - (1 :: int)))))))))))))"
  sorry
end
