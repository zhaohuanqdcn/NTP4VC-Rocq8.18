import Why3.Base
open Classical
open Lean4Why3
namespace gcd_vc_sp_BinaryGcd_binary_gcdqtvc
theorem binary_gcd'vc (u : ℤ) (v : ℤ) (fact0 : (0 : ℤ) ≤ u) (fact1 : (0 : ℤ) ≤ v) : (if u < v then ((0 : ℤ) ≤ v ∧ u < v ∨ v = u ∧ (0 : ℤ) ≤ u ∧ v < u) ∧ (0 : ℤ) ≤ v ∧ (0 : ℤ) ≤ u else ¬v = (0 : ℤ) → ¬(2 : ℤ) = (0 : ℤ) ∧ (if Int.tmod u (2 : ℤ) = (0 : ℤ) then ¬(2 : ℤ) = (0 : ℤ) ∧ (if Int.tmod v (2 : ℤ) = (0 : ℤ) then ¬(2 : ℤ) = (0 : ℤ) ∧ (let o1 : ℤ := Int.tdiv v (2 : ℤ); ¬(2 : ℤ) = (0 : ℤ) ∧ (let o2 : ℤ := Int.tdiv u (2 : ℤ); ((0 : ℤ) ≤ v ∧ o1 < v ∨ v = o1 ∧ (0 : ℤ) ≤ u ∧ o2 < u) ∧ (0 : ℤ) ≤ o2 ∧ (0 : ℤ) ≤ o1)) else ¬(2 : ℤ) = (0 : ℤ) ∧ (let o1 : ℤ := Int.tdiv u (2 : ℤ); ((0 : ℤ) ≤ u ∧ o1 < u) ∧ (0 : ℤ) ≤ o1 ∧ (0 : ℤ) ≤ v)) else ¬(2 : ℤ) = (0 : ℤ) ∧ (if Int.tmod v (2 : ℤ) = (0 : ℤ) then ¬(2 : ℤ) = (0 : ℤ) ∧ (let o1 : ℤ := Int.tdiv v (2 : ℤ); ((0 : ℤ) ≤ v ∧ o1 < v) ∧ (0 : ℤ) ≤ u ∧ (0 : ℤ) ≤ o1) else ¬(2 : ℤ) = (0 : ℤ) ∧ (let o1 : ℤ := Int.tdiv (u - v) (2 : ℤ); ((0 : ℤ) ≤ u ∧ o1 < u) ∧ (0 : ℤ) ≤ o1 ∧ (0 : ℤ) ≤ v)))) ∧ (∀(result : ℤ), (if u < v then result = Int.ofNat (Int.gcd v u) else if v = (0 : ℤ) then result = u else if Int.tmod u (2 : ℤ) = (0 : ℤ) then if Int.tmod v (2 : ℤ) = (0 : ℤ) then result = (2 : ℤ) * Int.ofNat (Int.gcd (Int.tdiv u (2 : ℤ)) (Int.tdiv v (2 : ℤ))) else result = Int.ofNat (Int.gcd (Int.tdiv u (2 : ℤ)) v) else if Int.tmod v (2 : ℤ) = (0 : ℤ) then result = Int.ofNat (Int.gcd u (Int.tdiv v (2 : ℤ))) else result = Int.ofNat (Int.gcd (Int.tdiv (u - v) (2 : ℤ)) v)) → result = Int.ofNat (Int.gcd u v))
  := sorry
end gcd_vc_sp_BinaryGcd_binary_gcdqtvc
