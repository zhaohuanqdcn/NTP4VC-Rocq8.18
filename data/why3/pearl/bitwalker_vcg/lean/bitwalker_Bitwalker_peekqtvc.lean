import Why3.Base
import Why3.why3.WellFounded.WellFounded
import Why3.why3.Ref.Ref
import Why3.mach.bv.BVCheck8
import Why3.mach.bv.BVCheck32
import Why3.mach.bv.BVCheck64
open Classical
open Lean4Why3
namespace bitwalker_Bitwalker_peekqtvc
noncomputable def nth8_stream (stream : List (BitVec 8)) (pos : ℤ) := (stream[Int.toNat (pos / (8 : ℤ))]!)[Int.toNat ((7 : ℤ) - pos % (8 : ℤ))]!
noncomputable def maxvalue (len : BitVec 32) := (1 : BitVec 64) <<< BitVec.toNat (BitVec.zeroExtend 64 len)
theorem peek'vc (len : BitVec 32) (start : BitVec 32) (addr : List (BitVec 8)) (fact0 : BitVec.toUInt len ≤ (64 : ℤ)) (fact1 : BitVec.toUInt start + BitVec.toUInt len < (4294967296 : ℤ)) (fact2 : (8 : ℤ) * Int.ofNat (List.length addr) < (4294967296 : ℤ)) : (BitVec.toUInt start + BitVec.toUInt len < (4294967296 : ℤ) ∨ BitVec.zeroExtend 128 start + BitVec.zeroExtend 128 len ≤ BitVec.zeroExtend 128 (4294967295 : BitVec 32)) ∧ (BitVec.toUInt (start + len) = BitVec.toUInt start + BitVec.toUInt len → (if (8 : ℤ) * Int.ofNat (List.length addr) < BitVec.toUInt (start + len) then BitVec.toUInt start + BitVec.toUInt len ≤ (8 : ℤ) * Int.ofNat (List.length addr) → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toUInt len → (0 : BitVec 64)[Int.toNat i]! = nth8_stream addr (BitVec.toUInt start + BitVec.toUInt len - i - (1 : ℤ))) ∧ (∀(i : ℤ), BitVec.toUInt len ≤ i ∧ i < (64 : ℤ) → (0 : BitVec 64)[Int.toNat i]! = false) else (BitVec.toUInt len ≤ (64 : ℤ) ∨ (64 : BitVec 32) ≥ len) ∧ (let lstart : BitVec 32 := (64 : BitVec 32) - len; BitVec.toUInt lstart = (64 : ℤ) - BitVec.toUInt len → (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toUInt len) ∧ (∀(j : ℤ), BitVec.toUInt len - (0 : ℤ) ≤ j ∧ j < BitVec.toUInt len → (0 : BitVec 64)[Int.toNat j]! = nth8_stream addr (BitVec.toUInt start + BitVec.toUInt len - j - (1 : ℤ))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toUInt len - (0 : ℤ) → (0 : BitVec 64)[Int.toNat j]! = false) ∧ (∀(j : ℤ), BitVec.toUInt len ≤ j ∧ j < (64 : ℤ) → (0 : BitVec 64)[Int.toNat j]! = false)) ∧ (∀(i : BitVec 32) (retval : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt i ∧ BitVec.toUInt i ≤ BitVec.toUInt len) ∧ (∀(j : ℤ), BitVec.toUInt len - BitVec.toUInt i ≤ j ∧ j < BitVec.toUInt len → retval[Int.toNat j]! = nth8_stream addr (BitVec.toUInt start + BitVec.toUInt len - j - (1 : ℤ))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toUInt len - BitVec.toUInt i → retval[Int.toNat j]! = false) ∧ (∀(j : ℤ), BitVec.toUInt len ≤ j ∧ j < (64 : ℤ) → retval[Int.toNat j]! = false) → (if i < len then (BitVec.toUInt start + BitVec.toUInt i < (4294967296 : ℤ) ∨ BitVec.zeroExtend 128 start + BitVec.zeroExtend 128 i ≤ BitVec.zeroExtend 128 (4294967295 : BitVec 32)) ∧ (BitVec.toUInt (start + i) = BitVec.toUInt start + BitVec.toUInt i → ((8 : ℤ) * Int.ofNat (List.length addr) < (4294967296 : ℤ) ∧ BitVec.toUInt (start + i) < (8 : ℤ) * Int.ofNat (List.length addr)) ∧ (BitVec.toUInt lstart + BitVec.toUInt i < (4294967296 : ℤ) ∨ BitVec.zeroExtend 128 lstart + BitVec.zeroExtend 128 i ≤ BitVec.zeroExtend 128 (4294967295 : BitVec 32)) ∧ (BitVec.toUInt (lstart + i) = BitVec.toUInt lstart + BitVec.toUInt i → BitVec.toUInt (lstart + i) < (64 : ℤ) ∧ (∀(o1 : BitVec 64), (∀(i1 : ℤ), ((0 : ℤ) ≤ i1 ∧ i1 < (64 : ℤ)) ∧ ¬i1 = (63 : ℤ) - BitVec.toUInt (lstart + i) → o1[Int.toNat i1]! = retval[Int.toNat i1]!) ∧ nth8_stream addr (BitVec.toUInt (start + i)) = o1[Int.toNat ((63 : ℤ) - BitVec.toUInt (lstart + i))]! → (BitVec.toUInt i + (1 : ℤ) < (4294967296 : ℤ) ∨ BitVec.zeroExtend 128 i + BitVec.zeroExtend 128 (1 : BitVec 32) ≤ BitVec.zeroExtend 128 (4294967295 : BitVec 32)) ∧ (BitVec.toUInt (i + (1 : BitVec 32)) = BitVec.toUInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt len - BitVec.toUInt i ∧ BitVec.toUInt len - BitVec.toUInt (i + (1 : BitVec 32)) < BitVec.toUInt len - BitVec.toUInt i) ∧ ((0 : ℤ) ≤ BitVec.toUInt (i + (1 : BitVec 32)) ∧ BitVec.toUInt (i + (1 : BitVec 32)) ≤ BitVec.toUInt len) ∧ (∀(j : ℤ), BitVec.toUInt len - BitVec.toUInt (i + (1 : BitVec 32)) ≤ j ∧ j < BitVec.toUInt len → o1[Int.toNat j]! = nth8_stream addr (BitVec.toUInt start + BitVec.toUInt len - j - (1 : ℤ))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toUInt len - BitVec.toUInt (i + (1 : BitVec 32)) → o1[Int.toNat j]! = false) ∧ (∀(j : ℤ), BitVec.toUInt len ≤ j ∧ j < (64 : ℤ) → o1[Int.toNat j]! = false))))) else ((8 : ℤ) * Int.ofNat (List.length addr) < BitVec.toUInt start + BitVec.toUInt len → retval = (0 : BitVec 64)) ∧ (BitVec.toUInt start + BitVec.toUInt len ≤ (8 : ℤ) * Int.ofNat (List.length addr) → (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < BitVec.toUInt len → retval[Int.toNat i1]! = nth8_stream addr (BitVec.toUInt start + BitVec.toUInt len - i1 - (1 : ℤ))) ∧ (∀(i1 : ℤ), BitVec.toUInt len ≤ i1 ∧ i1 < (64 : ℤ) → retval[Int.toNat i1]! = false)))))))
  := sorry
end bitwalker_Bitwalker_peekqtvc
