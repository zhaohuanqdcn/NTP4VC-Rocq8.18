import Why3.Base
import pearl.vstte12_tree_reconstruction_vcg.lean.vstte12_tree_reconstruction.Tree
open Classical
open Lean4Why3
namespace vstte12_tree_reconstruction_ZipperBased_tcqtvc
noncomputable def forest_depths : List (ℤ × Tree.tree) -> List ℤ
  | ([] : List (ℤ × Tree.tree)) => ([] : List ℤ)
  | (List.cons (d, t) r) => Tree.depths d t ++ forest_depths r
noncomputable def greedy : ℤ -> ℤ -> Tree.tree -> Prop
  | d, d1, t1 => ¬d = d1 ∧ (match t1 with | Tree.tree.Leaf => True | Tree.tree.Node l1 _ => greedy d (d1 + (1 : ℤ)) l1)
inductive g : List (ℤ × Tree.tree) -> Prop where
 | Gnil : g ([] : List (ℤ × Tree.tree))
 | Gone (d : ℤ) (t : Tree.tree) : g (List.cons (d, t) ([] : List (ℤ × Tree.tree)))
 | Gtwo (d1 : ℤ) (d2 : ℤ) (t2 : Tree.tree) (t1 : Tree.tree) (l : List (ℤ × Tree.tree)) : greedy d1 d2 t2 → g (List.cons (d1, t1) l) → g (List.cons (d2, t2) (List.cons (d1, t1) l))
noncomputable def only_leaf : List (ℤ × Tree.tree) -> Prop
  | ([] : List (ℤ × Tree.tree)) => True
  | (List.cons (x, t) r) => t = Tree.tree.Leaf ∧ only_leaf r
theorem tc'vc (left1 : List (ℤ × Tree.tree)) (right1 : List (ℤ × Tree.tree)) (fact0 : g left1) (fact1 : match left1 with | List.cons (d1, _) ([] : List (ℤ × Tree.tree)) => ¬d1 = (0 : ℤ) ∨ ¬right1 = ([] : List (ℤ × Tree.tree)) | _ => True) (fact2 : match right1 with | List.cons (d2, t2) right' => only_leaf right' ∧ (match t2 with | Tree.tree.Node l2 _ => g (List.cons (d2 + (1 : ℤ), l2) left1) | Tree.tree.Leaf => True) | ([] : List (ℤ × Tree.tree)) => True) : match right1 with | ([] : List (ℤ × Tree.tree)) => (∀(t : Tree.tree), ¬Tree.depths (0 : ℤ) t = forest_depths (List.reverse left1 ++ right1)) | List.cons x x1 => (match x1 with | ([] : List (ℤ × Tree.tree)) => (match x with | (x2, x3) => (match left1 with | ([] : List (ℤ × Tree.tree)) => (if x2 = (0 : ℤ) then Tree.depths (0 : ℤ) x3 = forest_depths (List.reverse left1 ++ right1) else ∀(t : Tree.tree), ¬Tree.depths (0 : ℤ) t = forest_depths (List.reverse left1 ++ right1)) | List.cons x4 x5 => (match x4 with | (x6, x7) => (if x6 = x2 then let o1 : ℤ := x6 - (1 : ℤ); let o2 : List (ℤ × Tree.tree) := List.cons (o1, Tree.tree.Node x7 x3) x1; (((0 : ℤ) ≤ Int.ofNat (List.length left1) + (2 : ℤ) * Int.ofNat (List.length right1) ∧ Int.ofNat (List.length x5) + (2 : ℤ) * Int.ofNat (List.length o2) < Int.ofNat (List.length left1) + (2 : ℤ) * Int.ofNat (List.length right1)) ∧ g x5 ∧ (match x5 with | List.cons (d1, _) ([] : List (ℤ × Tree.tree)) => True | _ => True) ∧ only_leaf x1 ∧ g (List.cons (o1 + (1 : ℤ), x7) x5)) ∧ (∀(result : Tree.tree), Tree.depths (0 : ℤ) result = forest_depths (List.reverse x5 ++ o2) → Tree.depths (0 : ℤ) result = forest_depths (List.reverse left1 ++ right1)) ∧ ((∀(t : Tree.tree), ¬Tree.depths (0 : ℤ) t = forest_depths (List.reverse x5 ++ o2)) → (∀(t : Tree.tree), ¬Tree.depths (0 : ℤ) t = forest_depths (List.reverse left1 ++ right1))) else let o1 : List (ℤ × Tree.tree) := List.cons (x2, x3) left1; (((0 : ℤ) ≤ Int.ofNat (List.length left1) + (2 : ℤ) * Int.ofNat (List.length right1) ∧ Int.ofNat (List.length o1) + (2 : ℤ) * Int.ofNat (List.length x1) < Int.ofNat (List.length left1) + (2 : ℤ) * Int.ofNat (List.length right1)) ∧ g o1 ∧ (match left1 with | ([] : List (ℤ × Tree.tree)) => ¬x2 = (0 : ℤ) ∨ ¬x1 = ([] : List (ℤ × Tree.tree)) | _ => True) ∧ (match x1 with | List.cons (d2, t2) right' => only_leaf right' ∧ (match t2 with | Tree.tree.Node l2 _ => g (List.cons (d2 + (1 : ℤ), l2) o1) | Tree.tree.Leaf => True) | ([] : List (ℤ × Tree.tree)) => True)) ∧ (∀(result : Tree.tree), Tree.depths (0 : ℤ) result = forest_depths (List.reverse o1 ++ x1) → Tree.depths (0 : ℤ) result = forest_depths (List.reverse left1 ++ right1)) ∧ ((∀(t : Tree.tree), ¬Tree.depths (0 : ℤ) t = forest_depths (List.reverse o1 ++ x1)) → (∀(t : Tree.tree), ¬Tree.depths (0 : ℤ) t = forest_depths (List.reverse left1 ++ right1))))))) | _ => (match x with | (x2, x3) => (match left1 with | ([] : List (ℤ × Tree.tree)) => (let o1 : List (ℤ × Tree.tree) := List.cons (x2, x3) ([] : List (ℤ × Tree.tree)); (((0 : ℤ) ≤ Int.ofNat (List.length left1) + (2 : ℤ) * Int.ofNat (List.length right1) ∧ Int.ofNat (List.length o1) + (2 : ℤ) * Int.ofNat (List.length x1) < Int.ofNat (List.length left1) + (2 : ℤ) * Int.ofNat (List.length right1)) ∧ g o1 ∧ (¬x2 = (0 : ℤ) ∨ ¬x1 = ([] : List (ℤ × Tree.tree))) ∧ (match x1 with | List.cons (d2, t2) right' => only_leaf right' ∧ (match t2 with | Tree.tree.Node l2 _ => g (List.cons (d2 + (1 : ℤ), l2) o1) | Tree.tree.Leaf => True) | ([] : List (ℤ × Tree.tree)) => True)) ∧ (∀(result : Tree.tree), Tree.depths (0 : ℤ) result = forest_depths (List.reverse o1 ++ x1) → Tree.depths (0 : ℤ) result = forest_depths (List.reverse left1 ++ right1)) ∧ ((∀(t : Tree.tree), ¬Tree.depths (0 : ℤ) t = forest_depths (List.reverse o1 ++ x1)) → (∀(t : Tree.tree), ¬Tree.depths (0 : ℤ) t = forest_depths (List.reverse left1 ++ right1)))) | List.cons x4 x5 => (match x4 with | (x6, x7) => (if x6 = x2 then let o1 : ℤ := x6 - (1 : ℤ); let o2 : List (ℤ × Tree.tree) := List.cons (o1, Tree.tree.Node x7 x3) x1; (((0 : ℤ) ≤ Int.ofNat (List.length left1) + (2 : ℤ) * Int.ofNat (List.length right1) ∧ Int.ofNat (List.length x5) + (2 : ℤ) * Int.ofNat (List.length o2) < Int.ofNat (List.length left1) + (2 : ℤ) * Int.ofNat (List.length right1)) ∧ g x5 ∧ (match x5 with | List.cons (d1, _) ([] : List (ℤ × Tree.tree)) => True | _ => True) ∧ only_leaf x1 ∧ g (List.cons (o1 + (1 : ℤ), x7) x5)) ∧ (∀(result : Tree.tree), Tree.depths (0 : ℤ) result = forest_depths (List.reverse x5 ++ o2) → Tree.depths (0 : ℤ) result = forest_depths (List.reverse left1 ++ right1)) ∧ ((∀(t : Tree.tree), ¬Tree.depths (0 : ℤ) t = forest_depths (List.reverse x5 ++ o2)) → (∀(t : Tree.tree), ¬Tree.depths (0 : ℤ) t = forest_depths (List.reverse left1 ++ right1))) else let o1 : List (ℤ × Tree.tree) := List.cons (x2, x3) left1; (((0 : ℤ) ≤ Int.ofNat (List.length left1) + (2 : ℤ) * Int.ofNat (List.length right1) ∧ Int.ofNat (List.length o1) + (2 : ℤ) * Int.ofNat (List.length x1) < Int.ofNat (List.length left1) + (2 : ℤ) * Int.ofNat (List.length right1)) ∧ g o1 ∧ (match left1 with | ([] : List (ℤ × Tree.tree)) => ¬x2 = (0 : ℤ) ∨ ¬x1 = ([] : List (ℤ × Tree.tree)) | _ => True) ∧ (match x1 with | List.cons (d2, t2) right' => only_leaf right' ∧ (match t2 with | Tree.tree.Node l2 _ => g (List.cons (d2 + (1 : ℤ), l2) o1) | Tree.tree.Leaf => True) | ([] : List (ℤ × Tree.tree)) => True)) ∧ (∀(result : Tree.tree), Tree.depths (0 : ℤ) result = forest_depths (List.reverse o1 ++ x1) → Tree.depths (0 : ℤ) result = forest_depths (List.reverse left1 ++ right1)) ∧ ((∀(t : Tree.tree), ¬Tree.depths (0 : ℤ) t = forest_depths (List.reverse o1 ++ x1)) → (∀(t : Tree.tree), ¬Tree.depths (0 : ℤ) t = forest_depths (List.reverse left1 ++ right1))))))))
  := sorry
end vstte12_tree_reconstruction_ZipperBased_tcqtvc
