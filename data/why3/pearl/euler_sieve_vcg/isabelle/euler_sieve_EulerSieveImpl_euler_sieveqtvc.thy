theory euler_sieve_EulerSieveImpl_euler_sieveqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "./euler_sieve_ArithmeticResults" "./euler_sieve_DivisibilityResults" "./euler_sieve_EulerSieveSpec" "mach.array_ArrayInt63"
begin
typedecl  t
consts nexts :: "t \<Rightarrow> int list"
consts marked :: "t \<Rightarrow> bool list"
consts arr :: "t \<Rightarrow> array_ArrayInt63.array63"
consts max :: "t \<Rightarrow> 63 word"
consts max_arr :: "t \<Rightarrow> 63 word"
axiomatization where t'invariant'0:   "sint (max self) < sint int'63_max"
  for self :: "t"
axiomatization where t'invariant'1:   "(3 :: int) \<le> sint (max self)"
  for self :: "t"
axiomatization where t'invariant'2:   "length (nexts self) = length (marked self)"
  for self :: "t"
axiomatization where t'invariant'3:   "int (length (marked self)) = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'4:   "(sint (max self) - (1 :: int)) ediv (2 :: int) = sint (max_arr self)"
  for self :: "t"
axiomatization where t'invariant'5:   "int (length (elts (arr self))) = sint (max_arr self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'6:   "inv_nexts (nexts self) (int (length (nexts self)))"
  for self :: "t"
axiomatization where t'invariant'7:   "all_eliminated_marked (marked self) (nexts self)"
  for self :: "t"
axiomatization where t'invariant'8:   "\<forall>(i :: int). (3 :: int) \<le> i \<and> i \<le> sint (max self) \<longrightarrow> i emod (2 :: int) = (0 :: int) \<longrightarrow> marked self ! nat i = True"
  for self :: "t"
axiomatization where t'invariant'9:   "\<forall>(i :: int). (3 :: int) \<le> i \<and> i < sint (max self) - (1 :: int) \<longrightarrow> i emod (2 :: int) = (1 :: int) \<longrightarrow> nexts self ! nat i emod (2 :: int) = (1 :: int) \<or> nexts self ! nat i = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'10:   "nexts self ! nat (sint (max self)) = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'11:   "(sint (max self) - (1 :: int)) emod (2 :: int) = (0 :: int) \<longrightarrow> nexts self ! nat (sint (max self) - (1 :: int)) = sint (max self)"
  for self :: "t"
axiomatization where t'invariant'12:   "(sint (max self) - (1 :: int)) emod (2 :: int) = (1 :: int) \<longrightarrow> nexts self ! nat (sint (max self) - (1 :: int)) = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'13:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> -(sint (max self) + (1 :: int)) \<le> elts (arr self) ! nat i \<and> elts (arr self) ! nat i \<le> sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'14:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> marked self ! nat ((2 :: int) * i + (1 :: int)) = True \<longleftrightarrow> elts (arr self) ! nat i < (0 :: int)"
  for self :: "t"
axiomatization where t'invariant'15:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> \<not>marked self ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts (arr self) ! nat i = nexts self ! nat ((2 :: int) * i + (1 :: int))"
  for self :: "t"
axiomatization where t'invariant'16:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> marked self ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts (arr self) ! nat i = -nexts self ! nat ((2 :: int) * i + (1 :: int))"
  for self :: "t"
axiomatization where t'invariant'17:   "\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> (i < abs (elts (arr self) ! nat i) ediv (2 :: int) \<and> abs (elts (arr self) ! nat i) ediv (2 :: int) \<le> sint (max_arr self) + (1 :: int)) \<and> abs (elts (arr self) ! nat i) \<le> sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'18:   "\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> sint (max_arr self) \<longrightarrow> i < j \<and> j < abs (elts (arr self) ! nat i) ediv (2 :: int) \<longrightarrow> elts (arr self) ! nat j < (0 :: int)"
  for self :: "t"
definition t'eq :: "t \<Rightarrow> t \<Rightarrow> _"
  where "t'eq a b \<longleftrightarrow> nexts a = nexts b \<and> marked a = marked b \<and> arr a = arr b \<and> max a = max b \<and> max_arr a = max_arr b" for a b
axiomatization where t'inj:   "a = b"
 if "t'eq a b"
  for a :: "t"
  and b :: "t"
definition inv_count :: "int list \<Rightarrow> int \<Rightarrow> _"
  where "inv_count arr1 min \<longleftrightarrow> (\<forall>(i :: int). min \<le> i \<and> i < int (length arr1) \<longrightarrow> (i < abs (arr1 ! nat i) ediv (2 :: int) \<and> abs (arr1 ! nat i) ediv (2 :: int) \<le> int (length arr1)) \<and> (-sint int'63_max \<le> arr1 ! nat i \<and> arr1 ! nat i \<le> sint int'63_max) \<and> (\<forall>(j :: int). i < j \<and> j < abs (arr1 ! nat i) ediv (2 :: int) \<longrightarrow> arr1 ! nat j < (0 :: int)) \<and> (\<forall>(j :: int). (2 :: int) * i + (1 :: int) < j \<and> j < abs (arr1 ! nat i) \<longrightarrow> \<not>prime j))" for arr1 min
theorem euler_sieve'vc:
  fixes max1 :: "63 word"
  assumes fact0: "sint max1 < sint int'63_max"
  assumes fact1: "(3 :: int) \<le> sint max1"
  shows "sint max1 < sint int'63_max"
  and "(3 :: int) \<le> sint max1"
  and "\<forall>(t1 :: t). max t1 = max1 \<and> ((marked t1 ! (0 :: nat) = marked t1 ! (1 :: nat) \<and> marked t1 ! (1 :: nat) = True) \<and> \<not>marked t1 ! (2 :: nat) = True) \<and> (\<forall>(i :: int). (1 :: int) \<le> i \<and> i \<le> (sint max1 - (1 :: int)) ediv (2 :: int) \<longrightarrow> \<not>marked t1 ! nat ((2 :: int) * i + (1 :: int)) = True) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i \<le> (sint max1 + (1 :: int)) ediv (2 :: int) \<longrightarrow> (2 :: int) * i \<le> sint max1 \<longrightarrow> marked t1 ! nat ((2 :: int) * i) = True) \<and> (\<forall>(i :: int). (1 :: int) \<le> i \<and> i \<le> (sint max1 - (1 :: int)) ediv (2 :: int) \<longrightarrow> (2 :: int) * i + (1 :: int) < sint max1 - (1 :: int) \<longrightarrow> nexts t1 ! nat ((2 :: int) * i + (1 :: int)) = (2 :: int) * i + (3 :: int)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i \<le> (sint max1 - (1 :: int)) ediv (2 :: int) \<longrightarrow> (2 :: int) * i < sint max1 - (1 :: int) \<longrightarrow> nexts t1 ! nat ((2 :: int) * i) = (2 :: int) * i + (1 :: int)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> sint max1 \<longrightarrow> marked t1 ! nat i = True \<longrightarrow> i < (2 :: int) \<or> (2 :: int) dvd i) \<longrightarrow> (\<forall>(t2 :: t). array_ArrayInt63.size (arr t2) = array_ArrayInt63.size (arr t1) \<longrightarrow> (\<forall>(n :: 63 word). (max_arr t1 = max_arr t2 \<and> max t1 = max t2) \<and> ((3 :: int) \<le> sint n \<and> sint n \<le> sint max1) \<and> sint n * sint n \<le> sint max1 \<and> previously_marked_multiples (marked t2) (sint n) \<and> only_multiples_marked (marked t2) (sint n) \<and> not_marked_impl_next_not_marked (marked t2) (nexts t2) (sint n) \<and> inv_remove_products (nexts t2) (marked t2) (sint n) \<longrightarrow> ((((3 :: int) \<le> sint n \<and> sint n \<le> sint (max t2)) \<and> sint n * sint n \<le> sint (max t2)) \<and> inv_remove_products (nexts t2) (marked t2) (sint n) \<and> previously_marked_multiples (marked t2) (sint n) \<and> only_multiples_marked (marked t2) (sint n) \<and> not_marked_impl_next_not_marked (marked t2) (nexts t2) (sint n)) \<and> (\<forall>(t3 :: t). array_ArrayInt63.size (arr t3) = array_ArrayInt63.size (arr t2) \<longrightarrow> max_arr t2 = max_arr t3 \<and> max t2 = max t3 \<longrightarrow> inv_remove_products (nexts t3) (marked t3) (sint n) \<and> not_marked_impl_next_not_marked (marked t3) (nexts t3) (nexts t3 ! nat (sint n)) \<and> previously_marked_multiples (marked t3) (nexts t3 ! nat (sint n)) \<and> only_multiples_marked (marked t3) (nexts t3 ! nat (sint n)) \<longrightarrow> (((3 :: int) \<le> sint n \<and> sint n \<le> sint (max t3)) \<and> sint n emod (2 :: int) = (1 :: int)) \<and> (\<forall>(nn :: 63 word). ((3 :: int) \<le> sint nn \<and> sint nn \<le> sint (max t3) + (1 :: int)) \<and> sint nn = nexts t3 ! nat (sint n) \<and> (sint nn emod (2 :: int) = (1 :: int) \<or> sint nn = sint (max t3) + (1 :: int)) \<longrightarrow> (\<not>sint nn = (0 :: int) \<and> int'63_in_bounds (sint max1 cdiv sint nn)) \<and> (\<forall>(o1 :: 63 word). sint o1 = sint max1 cdiv sint nn \<longrightarrow> (if sint nn \<le> sint o1 then ((0 :: int) \<le> sint max1 + (1 :: int) - sint n \<and> sint max1 + (1 :: int) - sint nn < sint max1 + (1 :: int) - sint n) \<and> ((3 :: int) \<le> sint nn \<and> sint nn \<le> sint max1) \<and> sint nn * sint nn \<le> sint max1 \<and> previously_marked_multiples (marked t3) (sint nn) \<and> only_multiples_marked (marked t3) (sint nn) \<and> not_marked_impl_next_not_marked (marked t3) (nexts t3) (sint nn) \<and> inv_remove_products (nexts t3) (marked t3) (sint nn) else \<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length (marked t3)) \<longrightarrow> \<not>marked t3 ! nat i = True \<longleftrightarrow> prime i)))))) \<and> (if (9 :: int) \<le> sint max1 then (((3 :: int) \<le> (3 :: int) \<and> (3 :: int) \<le> sint max1) \<and> (3 :: int) * (3 :: int) \<le> sint max1 \<and> previously_marked_multiples (marked t1) (3 :: int) \<and> only_multiples_marked (marked t1) (3 :: int) \<and> not_marked_impl_next_not_marked (marked t1) (nexts t1) (3 :: int) \<and> inv_remove_products (nexts t1) (marked t1) (3 :: int)) \<and> (\<forall>(t2 :: t). array_ArrayInt63.size (arr t2) = array_ArrayInt63.size (arr t1) \<longrightarrow> max_arr t1 = max_arr t2 \<and> max t1 = max t2 \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length (marked t2)) \<longrightarrow> \<not>marked t2 ! nat i = True \<longleftrightarrow> prime i) \<longrightarrow> (let o1 :: array_ArrayInt63.array63 = arr t2 in ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length (elts o1))) \<and> (\<forall>(t_arr :: array_ArrayInt63.array63). array_ArrayInt63.size t_arr = array_ArrayInt63.size o1 \<longrightarrow> array_ArrayInt63.size t_arr = array_ArrayInt63.size (arr t2) \<longrightarrow> elts t_arr = (elts o1)[nat (0 :: int) := sint (2 :: 63 word)] \<longrightarrow> (((1 :: int) \<le> (1 :: int) \<and> (1 :: int) \<le> sint (max_arr t2) + (1 :: int)) \<and> (1 :: int) \<le> (1 :: int) \<and> ((2 :: int) * (1 :: int) + (1 :: int) \<le> sint max1 \<longrightarrow> (0 :: int) \<le> elts t_arr ! (1 :: nat)) \<and> ((2 :: int) * (1 :: int) + (1 :: int) \<le> sint max1 \<longrightarrow> prime ((2 :: int) * (1 :: int) + (1 :: int))) \<and> inv_count (elts t_arr) (1 :: int) \<and> ordered (elts t_arr) (1 :: int) \<and> all_inf_or_eq (elts t_arr) (1 :: int) ((2 :: int) * (1 :: int)) \<and> (\<forall>(i :: int). (1 :: int) \<le> i \<and> i \<le> sint (max_arr t2) \<longrightarrow> (0 :: int) \<le> elts t_arr ! nat i \<longleftrightarrow> prime ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (1 :: int) \<longrightarrow> prime (elts t_arr ! nat i)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i < (2 :: int) * (1 :: int) + (1 :: int) \<longrightarrow> prime i \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < (1 :: int)) \<and> elts t_arr ! nat j = i))) \<and> (\<forall>(p :: 63 word) (cnt :: 63 word) (t_arr1 :: array_ArrayInt63.array63). array_ArrayInt63.size t_arr1 = array_ArrayInt63.size t_arr \<longrightarrow> ((1 :: int) \<le> sint p \<and> sint p \<le> sint (max_arr t2) + (1 :: int)) \<and> ((1 :: int) \<le> sint cnt \<and> sint cnt \<le> sint p) \<and> ((2 :: int) * sint p + (1 :: int) \<le> sint max1 \<longrightarrow> (0 :: int) \<le> elts t_arr1 ! nat (sint p)) \<and> ((2 :: int) * sint p + (1 :: int) \<le> sint max1 \<longrightarrow> prime ((2 :: int) * sint p + (1 :: int))) \<and> inv_count (elts t_arr1) (sint cnt) \<and> ordered (elts t_arr1) (sint cnt) \<and> all_inf_or_eq (elts t_arr1) (sint cnt) ((2 :: int) * sint p) \<and> (\<forall>(i :: int). sint cnt \<le> i \<and> i \<le> sint (max_arr t2) \<longrightarrow> (0 :: int) \<le> elts t_arr1 ! nat i \<longleftrightarrow> prime ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < sint cnt \<longrightarrow> prime (elts t_arr1 ! nat i)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i < (2 :: int) * sint p + (1 :: int) \<longrightarrow> prime i \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < sint cnt) \<and> elts t_arr1 ! nat j = i)) \<longrightarrow> int'63_in_bounds ((2 :: int) * sint p) \<and> (\<forall>(o2 :: 63 word). sint o2 = (2 :: int) * sint p \<longrightarrow> int'63_in_bounds (sint o2 + (1 :: int)) \<and> (\<forall>(o3 :: 63 word). sint o3 = sint o2 + (1 :: int) \<longrightarrow> (if sint o3 \<le> sint max1 then ((0 :: int) \<le> sint p \<and> sint p < int (length (elts t_arr1))) \<and> (\<forall>(o4 :: 63 word). sint o4 = elts t_arr1 ! nat (sint p) \<longrightarrow> (\<not>(2 :: int) = (0 :: int) \<and> int'63_in_bounds (sint o4 cdiv (2 :: int))) \<and> (\<forall>(next :: 63 word). sint next = sint o4 cdiv (2 :: int) \<longrightarrow> (if sint next \<le> sint (max_arr t2) then ((0 :: int) \<le> sint next \<and> sint next < int (length (elts t_arr1))) \<and> (\<forall>(o5 :: 63 word). sint o5 = elts t_arr1 ! nat (sint next) \<longrightarrow> (if sint o5 < (0 :: int) then ((0 :: int) \<le> sint next \<and> sint next < int (length (elts t_arr1))) \<and> (\<forall>(o6 :: 63 word). sint o6 = elts t_arr1 ! nat (sint next) \<longrightarrow> int'63_in_bounds (-sint o6) \<and> (\<forall>(o7 :: 63 word). sint o7 = -sint o6 \<longrightarrow> ((0 :: int) \<le> sint p \<and> sint p < int (length (elts t_arr1))) \<and> (\<forall>(t_arr2 :: array_ArrayInt63.array63). array_ArrayInt63.size t_arr2 = array_ArrayInt63.size t_arr1 \<longrightarrow> array_ArrayInt63.size t_arr2 = array_ArrayInt63.size t_arr1 \<longrightarrow> elts t_arr2 = (elts t_arr1)[nat (sint p) := sint o7] \<longrightarrow> ((0 :: int) \<le> sint (max_arr t2) + (1 :: int) - sint p \<and> sint (max_arr t2) + (1 :: int) - sint p < sint (max_arr t2) + (1 :: int) - sint p \<or> (0 :: int) \<le> sint max1 + (1 :: int) - elts t_arr1 ! nat (sint p) \<and> sint max1 + (1 :: int) - elts t_arr2 ! nat (sint p) < sint max1 + (1 :: int) - elts t_arr1 ! nat (sint p)) \<and> ((1 :: int) \<le> sint p \<and> sint p \<le> sint (max_arr t2) + (1 :: int)) \<and> ((1 :: int) \<le> sint cnt \<and> sint cnt \<le> sint p) \<and> ((2 :: int) * sint p + (1 :: int) \<le> sint max1 \<longrightarrow> (0 :: int) \<le> elts t_arr2 ! nat (sint p)) \<and> ((2 :: int) * sint p + (1 :: int) \<le> sint max1 \<longrightarrow> prime ((2 :: int) * sint p + (1 :: int))) \<and> inv_count (elts t_arr2) (sint cnt) \<and> ordered (elts t_arr2) (sint cnt) \<and> all_inf_or_eq (elts t_arr2) (sint cnt) ((2 :: int) * sint p) \<and> (\<forall>(i :: int). sint cnt \<le> i \<and> i \<le> sint (max_arr t2) \<longrightarrow> (0 :: int) \<le> elts t_arr2 ! nat i \<longleftrightarrow> prime ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < sint cnt \<longrightarrow> prime (elts t_arr2 ! nat i)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i < (2 :: int) * sint p + (1 :: int) \<longrightarrow> prime i \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < sint cnt) \<and> elts t_arr2 ! nat j = i))))) else int'63_in_bounds ((2 :: int) * sint p) \<and> (\<forall>(o6 :: 63 word). sint o6 = (2 :: int) * sint p \<longrightarrow> int'63_in_bounds (sint o6 + (1 :: int)) \<and> (\<forall>(o7 :: 63 word). sint o7 = sint o6 + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint cnt \<and> sint cnt < int (length (elts t_arr1))) \<and> (\<forall>(t_arr2 :: array_ArrayInt63.array63). array_ArrayInt63.size t_arr2 = array_ArrayInt63.size t_arr1 \<longrightarrow> array_ArrayInt63.size t_arr2 = array_ArrayInt63.size t_arr1 \<longrightarrow> elts t_arr2 = (elts t_arr1)[nat (sint cnt) := sint o7] \<longrightarrow> int'63_in_bounds (sint cnt + (1 :: int)) \<and> (\<forall>(o8 :: 63 word). sint o8 = sint cnt + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint (max_arr t2) + (1 :: int) - sint p \<and> sint (max_arr t2) + (1 :: int) - sint next < sint (max_arr t2) + (1 :: int) - sint p \<or> sint (max_arr t2) + (1 :: int) - sint p = sint (max_arr t2) + (1 :: int) - sint next \<and> (0 :: int) \<le> sint max1 + (1 :: int) - elts t_arr1 ! nat (sint p) \<and> sint max1 + (1 :: int) - elts t_arr2 ! nat (sint next) < sint max1 + (1 :: int) - elts t_arr1 ! nat (sint p)) \<and> ((1 :: int) \<le> sint next \<and> sint next \<le> sint (max_arr t2) + (1 :: int)) \<and> ((1 :: int) \<le> sint o8 \<and> sint o8 \<le> sint next) \<and> ((2 :: int) * sint next + (1 :: int) \<le> sint max1 \<longrightarrow> (0 :: int) \<le> elts t_arr2 ! nat (sint next)) \<and> ((2 :: int) * sint next + (1 :: int) \<le> sint max1 \<longrightarrow> prime ((2 :: int) * sint next + (1 :: int))) \<and> inv_count (elts t_arr2) (sint o8) \<and> ordered (elts t_arr2) (sint o8) \<and> all_inf_or_eq (elts t_arr2) (sint o8) ((2 :: int) * sint next) \<and> (\<forall>(i :: int). sint o8 \<le> i \<and> i \<le> sint (max_arr t2) \<longrightarrow> (0 :: int) \<le> elts t_arr2 ! nat i \<longleftrightarrow> prime ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < sint o8 \<longrightarrow> prime (elts t_arr2 ! nat i)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i < (2 :: int) * sint next + (1 :: int) \<longrightarrow> prime i \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < sint o8) \<and> elts t_arr2 ! nat j = i)))))))) else int'63_in_bounds ((2 :: int) * sint p) \<and> (\<forall>(o5 :: 63 word). sint o5 = (2 :: int) * sint p \<longrightarrow> int'63_in_bounds (sint o5 + (1 :: int)) \<and> (\<forall>(o6 :: 63 word). sint o6 = sint o5 + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint cnt \<and> sint cnt < int (length (elts t_arr1))) \<and> (\<forall>(t_arr2 :: array_ArrayInt63.array63). array_ArrayInt63.size t_arr2 = array_ArrayInt63.size t_arr1 \<longrightarrow> array_ArrayInt63.size t_arr2 = array_ArrayInt63.size t_arr1 \<longrightarrow> elts t_arr2 = (elts t_arr1)[nat (sint cnt) := sint o6] \<longrightarrow> int'63_in_bounds (sint cnt + (1 :: int)) \<and> (\<forall>(o7 :: 63 word). sint o7 = sint cnt + (1 :: int) \<longrightarrow> int'63_in_bounds (sint (max_arr t2) + (1 :: int)) \<and> (\<forall>(o8 :: 63 word). sint o8 = sint (max_arr t2) + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint (max_arr t2) + (1 :: int) - sint p \<and> sint (max_arr t2) + (1 :: int) - sint o8 < sint (max_arr t2) + (1 :: int) - sint p \<or> sint (max_arr t2) + (1 :: int) - sint p = sint (max_arr t2) + (1 :: int) - sint o8 \<and> (0 :: int) \<le> sint max1 + (1 :: int) - elts t_arr1 ! nat (sint p) \<and> sint max1 + (1 :: int) - elts t_arr2 ! nat (sint o8) < sint max1 + (1 :: int) - elts t_arr1 ! nat (sint p)) \<and> ((1 :: int) \<le> sint o8 \<and> sint o8 \<le> sint (max_arr t2) + (1 :: int)) \<and> ((1 :: int) \<le> sint o7 \<and> sint o7 \<le> sint o8) \<and> ((2 :: int) * sint o8 + (1 :: int) \<le> sint max1 \<longrightarrow> (0 :: int) \<le> elts t_arr2 ! nat (sint o8)) \<and> ((2 :: int) * sint o8 + (1 :: int) \<le> sint max1 \<longrightarrow> prime ((2 :: int) * sint o8 + (1 :: int))) \<and> inv_count (elts t_arr2) (sint o7) \<and> ordered (elts t_arr2) (sint o7) \<and> all_inf_or_eq (elts t_arr2) (sint o7) ((2 :: int) * sint o8) \<and> (\<forall>(i :: int). sint o7 \<le> i \<and> i \<le> sint (max_arr t2) \<longrightarrow> (0 :: int) \<le> elts t_arr2 ! nat i \<longleftrightarrow> prime ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < sint o7 \<longrightarrow> prime (elts t_arr2 ! nat i)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i < (2 :: int) * sint o8 + (1 :: int) \<longrightarrow> prime i \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < sint o7) \<and> elts t_arr2 ! nat j = i)))))))))) else ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> sint cnt \<and> (0 :: int) + sint cnt \<le> int (length (elts t_arr1))) \<and> (\<forall>(result :: array_ArrayInt63.array63). int (length (elts result)) = sint cnt \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < sint cnt \<longrightarrow> elts result ! nat i = elts t_arr1 ! nat ((0 :: int) + i)) \<longrightarrow> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < j \<and> j < int (length (elts result)) \<longrightarrow> elts result ! nat i < elts result ! nat j) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length (elts result)) \<longrightarrow> (2 :: int) \<le> elts result ! nat i \<and> elts result ! nat i \<le> sint max1) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length (elts result)) \<longrightarrow> prime (elts result ! nat i)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i \<le> sint max1 \<longrightarrow> prime i \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < int (length (elts result))) \<and> elts result ! nat j = i)))))))))) else let o1 :: array_ArrayInt63.array63 = arr t1 in ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length (elts o1))) \<and> (\<forall>(t_arr :: array_ArrayInt63.array63). array_ArrayInt63.size t_arr = array_ArrayInt63.size o1 \<longrightarrow> array_ArrayInt63.size t_arr = array_ArrayInt63.size (arr t1) \<longrightarrow> elts t_arr = (elts o1)[nat (0 :: int) := sint (2 :: 63 word)] \<longrightarrow> (((1 :: int) \<le> (1 :: int) \<and> (1 :: int) \<le> sint (max_arr t1) + (1 :: int)) \<and> (1 :: int) \<le> (1 :: int) \<and> ((2 :: int) * (1 :: int) + (1 :: int) \<le> sint max1 \<longrightarrow> (0 :: int) \<le> elts t_arr ! (1 :: nat)) \<and> ((2 :: int) * (1 :: int) + (1 :: int) \<le> sint max1 \<longrightarrow> prime ((2 :: int) * (1 :: int) + (1 :: int))) \<and> inv_count (elts t_arr) (1 :: int) \<and> ordered (elts t_arr) (1 :: int) \<and> all_inf_or_eq (elts t_arr) (1 :: int) ((2 :: int) * (1 :: int)) \<and> (\<forall>(i :: int). (1 :: int) \<le> i \<and> i \<le> sint (max_arr t1) \<longrightarrow> (0 :: int) \<le> elts t_arr ! nat i \<longleftrightarrow> prime ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (1 :: int) \<longrightarrow> prime (elts t_arr ! nat i)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i < (2 :: int) * (1 :: int) + (1 :: int) \<longrightarrow> prime i \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < (1 :: int)) \<and> elts t_arr ! nat j = i))) \<and> (\<forall>(p :: 63 word) (cnt :: 63 word) (t_arr1 :: array_ArrayInt63.array63). array_ArrayInt63.size t_arr1 = array_ArrayInt63.size t_arr \<longrightarrow> ((1 :: int) \<le> sint p \<and> sint p \<le> sint (max_arr t1) + (1 :: int)) \<and> ((1 :: int) \<le> sint cnt \<and> sint cnt \<le> sint p) \<and> ((2 :: int) * sint p + (1 :: int) \<le> sint max1 \<longrightarrow> (0 :: int) \<le> elts t_arr1 ! nat (sint p)) \<and> ((2 :: int) * sint p + (1 :: int) \<le> sint max1 \<longrightarrow> prime ((2 :: int) * sint p + (1 :: int))) \<and> inv_count (elts t_arr1) (sint cnt) \<and> ordered (elts t_arr1) (sint cnt) \<and> all_inf_or_eq (elts t_arr1) (sint cnt) ((2 :: int) * sint p) \<and> (\<forall>(i :: int). sint cnt \<le> i \<and> i \<le> sint (max_arr t1) \<longrightarrow> (0 :: int) \<le> elts t_arr1 ! nat i \<longleftrightarrow> prime ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < sint cnt \<longrightarrow> prime (elts t_arr1 ! nat i)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i < (2 :: int) * sint p + (1 :: int) \<longrightarrow> prime i \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < sint cnt) \<and> elts t_arr1 ! nat j = i)) \<longrightarrow> int'63_in_bounds ((2 :: int) * sint p) \<and> (\<forall>(o2 :: 63 word). sint o2 = (2 :: int) * sint p \<longrightarrow> int'63_in_bounds (sint o2 + (1 :: int)) \<and> (\<forall>(o3 :: 63 word). sint o3 = sint o2 + (1 :: int) \<longrightarrow> (if sint o3 \<le> sint max1 then ((0 :: int) \<le> sint p \<and> sint p < int (length (elts t_arr1))) \<and> (\<forall>(o4 :: 63 word). sint o4 = elts t_arr1 ! nat (sint p) \<longrightarrow> (\<not>(2 :: int) = (0 :: int) \<and> int'63_in_bounds (sint o4 cdiv (2 :: int))) \<and> (\<forall>(next :: 63 word). sint next = sint o4 cdiv (2 :: int) \<longrightarrow> (if sint next \<le> sint (max_arr t1) then ((0 :: int) \<le> sint next \<and> sint next < int (length (elts t_arr1))) \<and> (\<forall>(o5 :: 63 word). sint o5 = elts t_arr1 ! nat (sint next) \<longrightarrow> (if sint o5 < (0 :: int) then ((0 :: int) \<le> sint next \<and> sint next < int (length (elts t_arr1))) \<and> (\<forall>(o6 :: 63 word). sint o6 = elts t_arr1 ! nat (sint next) \<longrightarrow> int'63_in_bounds (-sint o6) \<and> (\<forall>(o7 :: 63 word). sint o7 = -sint o6 \<longrightarrow> ((0 :: int) \<le> sint p \<and> sint p < int (length (elts t_arr1))) \<and> (\<forall>(t_arr2 :: array_ArrayInt63.array63). array_ArrayInt63.size t_arr2 = array_ArrayInt63.size t_arr1 \<longrightarrow> array_ArrayInt63.size t_arr2 = array_ArrayInt63.size t_arr1 \<longrightarrow> elts t_arr2 = (elts t_arr1)[nat (sint p) := sint o7] \<longrightarrow> ((0 :: int) \<le> sint (max_arr t1) + (1 :: int) - sint p \<and> sint (max_arr t1) + (1 :: int) - sint p < sint (max_arr t1) + (1 :: int) - sint p \<or> (0 :: int) \<le> sint max1 + (1 :: int) - elts t_arr1 ! nat (sint p) \<and> sint max1 + (1 :: int) - elts t_arr2 ! nat (sint p) < sint max1 + (1 :: int) - elts t_arr1 ! nat (sint p)) \<and> ((1 :: int) \<le> sint p \<and> sint p \<le> sint (max_arr t1) + (1 :: int)) \<and> ((1 :: int) \<le> sint cnt \<and> sint cnt \<le> sint p) \<and> ((2 :: int) * sint p + (1 :: int) \<le> sint max1 \<longrightarrow> (0 :: int) \<le> elts t_arr2 ! nat (sint p)) \<and> ((2 :: int) * sint p + (1 :: int) \<le> sint max1 \<longrightarrow> prime ((2 :: int) * sint p + (1 :: int))) \<and> inv_count (elts t_arr2) (sint cnt) \<and> ordered (elts t_arr2) (sint cnt) \<and> all_inf_or_eq (elts t_arr2) (sint cnt) ((2 :: int) * sint p) \<and> (\<forall>(i :: int). sint cnt \<le> i \<and> i \<le> sint (max_arr t1) \<longrightarrow> (0 :: int) \<le> elts t_arr2 ! nat i \<longleftrightarrow> prime ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < sint cnt \<longrightarrow> prime (elts t_arr2 ! nat i)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i < (2 :: int) * sint p + (1 :: int) \<longrightarrow> prime i \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < sint cnt) \<and> elts t_arr2 ! nat j = i))))) else int'63_in_bounds ((2 :: int) * sint p) \<and> (\<forall>(o6 :: 63 word). sint o6 = (2 :: int) * sint p \<longrightarrow> int'63_in_bounds (sint o6 + (1 :: int)) \<and> (\<forall>(o7 :: 63 word). sint o7 = sint o6 + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint cnt \<and> sint cnt < int (length (elts t_arr1))) \<and> (\<forall>(t_arr2 :: array_ArrayInt63.array63). array_ArrayInt63.size t_arr2 = array_ArrayInt63.size t_arr1 \<longrightarrow> array_ArrayInt63.size t_arr2 = array_ArrayInt63.size t_arr1 \<longrightarrow> elts t_arr2 = (elts t_arr1)[nat (sint cnt) := sint o7] \<longrightarrow> int'63_in_bounds (sint cnt + (1 :: int)) \<and> (\<forall>(o8 :: 63 word). sint o8 = sint cnt + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint (max_arr t1) + (1 :: int) - sint p \<and> sint (max_arr t1) + (1 :: int) - sint next < sint (max_arr t1) + (1 :: int) - sint p \<or> sint (max_arr t1) + (1 :: int) - sint p = sint (max_arr t1) + (1 :: int) - sint next \<and> (0 :: int) \<le> sint max1 + (1 :: int) - elts t_arr1 ! nat (sint p) \<and> sint max1 + (1 :: int) - elts t_arr2 ! nat (sint next) < sint max1 + (1 :: int) - elts t_arr1 ! nat (sint p)) \<and> ((1 :: int) \<le> sint next \<and> sint next \<le> sint (max_arr t1) + (1 :: int)) \<and> ((1 :: int) \<le> sint o8 \<and> sint o8 \<le> sint next) \<and> ((2 :: int) * sint next + (1 :: int) \<le> sint max1 \<longrightarrow> (0 :: int) \<le> elts t_arr2 ! nat (sint next)) \<and> ((2 :: int) * sint next + (1 :: int) \<le> sint max1 \<longrightarrow> prime ((2 :: int) * sint next + (1 :: int))) \<and> inv_count (elts t_arr2) (sint o8) \<and> ordered (elts t_arr2) (sint o8) \<and> all_inf_or_eq (elts t_arr2) (sint o8) ((2 :: int) * sint next) \<and> (\<forall>(i :: int). sint o8 \<le> i \<and> i \<le> sint (max_arr t1) \<longrightarrow> (0 :: int) \<le> elts t_arr2 ! nat i \<longleftrightarrow> prime ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < sint o8 \<longrightarrow> prime (elts t_arr2 ! nat i)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i < (2 :: int) * sint next + (1 :: int) \<longrightarrow> prime i \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < sint o8) \<and> elts t_arr2 ! nat j = i)))))))) else int'63_in_bounds ((2 :: int) * sint p) \<and> (\<forall>(o5 :: 63 word). sint o5 = (2 :: int) * sint p \<longrightarrow> int'63_in_bounds (sint o5 + (1 :: int)) \<and> (\<forall>(o6 :: 63 word). sint o6 = sint o5 + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint cnt \<and> sint cnt < int (length (elts t_arr1))) \<and> (\<forall>(t_arr2 :: array_ArrayInt63.array63). array_ArrayInt63.size t_arr2 = array_ArrayInt63.size t_arr1 \<longrightarrow> array_ArrayInt63.size t_arr2 = array_ArrayInt63.size t_arr1 \<longrightarrow> elts t_arr2 = (elts t_arr1)[nat (sint cnt) := sint o6] \<longrightarrow> int'63_in_bounds (sint cnt + (1 :: int)) \<and> (\<forall>(o7 :: 63 word). sint o7 = sint cnt + (1 :: int) \<longrightarrow> int'63_in_bounds (sint (max_arr t1) + (1 :: int)) \<and> (\<forall>(o8 :: 63 word). sint o8 = sint (max_arr t1) + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint (max_arr t1) + (1 :: int) - sint p \<and> sint (max_arr t1) + (1 :: int) - sint o8 < sint (max_arr t1) + (1 :: int) - sint p \<or> sint (max_arr t1) + (1 :: int) - sint p = sint (max_arr t1) + (1 :: int) - sint o8 \<and> (0 :: int) \<le> sint max1 + (1 :: int) - elts t_arr1 ! nat (sint p) \<and> sint max1 + (1 :: int) - elts t_arr2 ! nat (sint o8) < sint max1 + (1 :: int) - elts t_arr1 ! nat (sint p)) \<and> ((1 :: int) \<le> sint o8 \<and> sint o8 \<le> sint (max_arr t1) + (1 :: int)) \<and> ((1 :: int) \<le> sint o7 \<and> sint o7 \<le> sint o8) \<and> ((2 :: int) * sint o8 + (1 :: int) \<le> sint max1 \<longrightarrow> (0 :: int) \<le> elts t_arr2 ! nat (sint o8)) \<and> ((2 :: int) * sint o8 + (1 :: int) \<le> sint max1 \<longrightarrow> prime ((2 :: int) * sint o8 + (1 :: int))) \<and> inv_count (elts t_arr2) (sint o7) \<and> ordered (elts t_arr2) (sint o7) \<and> all_inf_or_eq (elts t_arr2) (sint o7) ((2 :: int) * sint o8) \<and> (\<forall>(i :: int). sint o7 \<le> i \<and> i \<le> sint (max_arr t1) \<longrightarrow> (0 :: int) \<le> elts t_arr2 ! nat i \<longleftrightarrow> prime ((2 :: int) * i + (1 :: int))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < sint o7 \<longrightarrow> prime (elts t_arr2 ! nat i)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i < (2 :: int) * sint o8 + (1 :: int) \<longrightarrow> prime i \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < sint o7) \<and> elts t_arr2 ! nat j = i)))))))))) else ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> sint cnt \<and> (0 :: int) + sint cnt \<le> int (length (elts t_arr1))) \<and> (\<forall>(result :: array_ArrayInt63.array63). int (length (elts result)) = sint cnt \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < sint cnt \<longrightarrow> elts result ! nat i = elts t_arr1 ! nat ((0 :: int) + i)) \<longrightarrow> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < j \<and> j < int (length (elts result)) \<longrightarrow> elts result ! nat i < elts result ! nat j) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length (elts result)) \<longrightarrow> (2 :: int) \<le> elts result ! nat i \<and> elts result ! nat i \<le> sint max1) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length (elts result)) \<longrightarrow> prime (elts result ! nat i)) \<and> (\<forall>(i :: int). (2 :: int) \<le> i \<and> i \<le> sint max1 \<longrightarrow> prime i \<longrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < int (length (elts result))) \<and> elts result ! nat j = i)))))))))"
  sorry
end
