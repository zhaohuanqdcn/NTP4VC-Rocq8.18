import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.mpz.Z
import pearl.multiprecision.lib.lean.mpz.Zutil
open Classical
open Lean4Why3
namespace mpz_div2exp_Zdiv2exp_wmpz_tdiv_q_2expqtvc
theorem wmpz_tdiv_q_2exp'vc (mpz : Z.mpz_memo) (r : Z.mpz_ptr) (u : Z.mpz_ptr) (cnt : BitVec 64) (fact0 : (1 : ℤ) ≤ Z.alloc mpz r) (fact1 : (1 : ℤ) ≤ Z.alloc mpz u) (fact2 : Z.readers mpz r = (0 : ℤ)) (fact3 : Z.readers mpz u = (0 : ℤ)) (fact4 : Z.abs_size mpz u + Int.tdiv (BitVec.toUInt cnt) (64 : ℤ) + (1 : ℤ) ≤ (2147483647 : ℤ)) : -(2 : ℤ) < Z.readers mpz u ∧ (∀(un : BitVec 32), BitVec.toInt un = Z.sgn mpz u * Z.abs_size mpz u → (¬(64 : ℤ) = (0 : ℤ) ∧ uint'64_in_bounds (Int.tdiv (BitVec.toUInt cnt) (64 : ℤ))) ∧ (∀(o1 : BitVec 64), BitVec.toUInt o1 = Int.tdiv (BitVec.toUInt cnt) (64 : ℤ) → BitVec.toUInt o1 ≤ (2147483647 : ℤ) ∧ (∀(limb_cnt : BitVec 32), BitVec.toInt limb_cnt = BitVec.toUInt o1 → -(2147483648 : ℤ) < BitVec.toInt un ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = abs (BitVec.toInt un) → int'32_in_bounds (BitVec.toInt o2 - BitVec.toInt limb_cnt) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt o2 - BitVec.toInt limb_cnt → (if BitVec.toInt o3 ≤ (0 : ℤ) then (-(1 : ℤ) ≤ Z.readers mpz r ∧ Z.readers mpz r ≤ (0 : ℤ)) ∧ (∀(mpz1 : Z.mpz_memo), Z.alloc mpz1 = Z.alloc mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.readers mpz1 = Z.readers mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz1 mpz) ∧ Z.abs_size mpz1 r = (0 : ℤ) ∧ Z.abs_value_of mpz1 r = (0 : ℤ) → Z.value_of r mpz1 = Int.tdiv (Z.value_of u mpz) (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt))) ∧ (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz1 mpz) ∧ Z.readers mpz1 r = (0 : ℤ) ∧ Z.readers mpz1 u = (0 : ℤ)) else (Z.readers mpz r = (0 : ℤ) ∧ (1 : ℤ) ≤ Z.alloc mpz r) ∧ (∀(mpz1 : Z.mpz_memo), Z.sgn mpz1 = Z.sgn mpz → (∀(rp : C.ptr (BitVec 64)), (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz1 mpz) ∧ Z.readers mpz1 r = -(1 : ℤ) ∧ Z.abs_value_of mpz1 r = Lemmas.value rp (Z.abs_size mpz1 r) ∧ Z.zones mpz1 r = C.zone1 rp ∧ C.offset rp = (0 : ℤ) ∧ C.plength rp = Z.alloc mpz1 r ∧ C.min rp = (0 : ℤ) ∧ C.max rp = C.plength rp ∧ C.writable rp = true ∧ Z.abs_size mpz1 r = Z.abs_size mpz r ∧ Lemmas.value rp (Z.abs_size mpz r) = Z.abs_value_of mpz r ∧ (if Z.alloc mpz r < BitVec.toInt o3 then Z.alloc mpz1 r = BitVec.toInt o3 else Z.alloc mpz1 r = Z.alloc mpz r) → (¬(64 : ℤ) = (0 : ℤ) ∧ uint'64_in_bounds (Int.tmod (BitVec.toUInt cnt) (64 : ℤ))) ∧ (∀(c : BitVec 64), BitVec.toUInt c = Int.tmod (BitVec.toUInt cnt) (64 : ℤ) → Z.mpz_eq u r = (u = r) → (if Z.mpz_eq u r then (C.min rp ≤ C.offset rp + BitVec.toInt limb_cnt ∧ C.offset rp + BitVec.toInt limb_cnt ≤ C.max rp) ∧ (∀(up : C.ptr (BitVec 64)), C.offset up = C.offset rp + BitVec.toInt limb_cnt ∧ C.plength up = C.plength rp ∧ C.pelts up = C.pelts rp ∧ C.data up = C.data rp ∧ C.min up = C.min rp ∧ C.max up = C.max rp ∧ C.zone1 up = C.zone1 rp ∧ C.writable up = C.writable rp → (∀(o4 : Bool), (BitVec.toUInt c = BitVec.toUInt (0 : BitVec 64) → o4 = true) ∧ (o4 = true → c = (0 : BitVec 64)) → (if ¬o4 = true then (((0 : ℤ) < BitVec.toUInt c ∧ BitVec.toUInt c < (64 : ℤ)) ∧ C.valid up (BitVec.toInt o3) ∧ C.valid rp (BitVec.toInt o3) ∧ (0 : ℤ) < BitVec.toInt o3 ∧ C.writable rp = true ∧ (C.offset rp ≤ C.offset up ∨ C.offset up + BitVec.toInt o3 ≤ C.offset rp)) ∧ (∀(up1 : C.ptr (BitVec 64)) (rp1 : C.ptr (BitVec 64)), C.data up1 = C.data rp1 ∧ List.length (C.data rp1) = List.length (C.data up) ∧ C.offset up1 = C.offset up ∧ C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(x_m : BitVec 64), BitVec.toUInt x_m + ((18446744073709551615 : ℤ) + (1 : ℤ)) * Lemmas.value rp1 (BitVec.toInt o3) = Lemmas.value up (BitVec.toInt o3) * HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - BitVec.toUInt c)) ∧ (∀(j : ℤ), j < C.offset rp1 ∨ C.offset rp1 + BitVec.toInt o3 ≤ j → C.pelts rp1 j = C.pelts rp j) ∧ (C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.plength rp1 = C.plength rp) ∧ C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.plength up1 = C.plength up → ¬(18446744073709551615 : ℤ) + (1 : ℤ) = (0 : ℤ) ∧ int'32_in_bounds (BitVec.toInt o3 - (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt o3 - (1 : ℤ) → (C.min rp1 ≤ C.offset rp1 + BitVec.toInt o5 ∧ C.offset rp1 + BitVec.toInt o5 < C.max rp1) ∧ (let o6 : BitVec 64 := C.pelts rp1 (C.offset rp1 + BitVec.toInt o5); ∀(o7 : Bool), (BitVec.toUInt o6 = BitVec.toUInt (0 : BitVec 64) → o7 = true) ∧ (o7 = true → o6 = (0 : BitVec 64)) → (∀(o8 : BitVec 32), (if o7 = true then o8 = (1 : BitVec 32) else o8 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt o3 - BitVec.toInt o8) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt o3 - BitVec.toInt o8 → -(2 : ℤ) < Z.readers mpz1 u ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = Z.sgn mpz1 u * Z.abs_size mpz1 u → (¬(0 : ℤ) ≤ BitVec.toInt o10 → int'32_in_bounds (-BitVec.toInt o9)) ∧ ((¬(0 : ℤ) ≤ BitVec.toInt o10 → (∃(nrn : BitVec 32), BitVec.toInt nrn = -BitVec.toInt o9)) → -(2 : ℤ) < Z.readers mpz1 u ∧ (∀(o11 : BitVec 32), BitVec.toInt o11 = Z.sgn mpz1 u * Z.abs_size mpz1 u → (¬(0 : ℤ) ≤ BitVec.toInt o11 → int'32_in_bounds (-BitVec.toInt o9)) ∧ (∀(o12 : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt o11 then o12 = o9 else BitVec.toInt o12 = -BitVec.toInt o9) → (Z.zones mpz1 r = C.zone1 rp1 ∧ Z.readers mpz1 r = -(1 : ℤ) ∧ C.offset rp1 = (0 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ abs (BitVec.toInt o12) ≤ C.plength rp1 ∧ C.plength rp1 = Z.alloc mpz1 r ∧ (¬BitVec.toInt o12 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o12) - (1 : ℤ))) ≤ Lemmas.value rp1 (abs (BitVec.toInt o12)))) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz2 mpz1) ∧ (Z.sgn mpz2 r = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o12) ∧ (Z.sgn mpz2 r = -(1 : ℤ)) = (BitVec.toInt o12 < (0 : ℤ)) ∧ Z.abs_size mpz2 r = abs (BitVec.toInt o12) ∧ Z.abs_value_of mpz2 r = Lemmas.value rp1 (abs (BitVec.toInt o12)) → (Z.zones mpz2 r = C.zone1 rp1 ∧ Z.readers mpz2 r = -(1 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ Z.abs_value_of mpz2 r = Lemmas.value rp1 (Z.abs_size mpz2 r)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 r = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = r → Z.readers mpz3 y = Z.readers mpz2 y) → Z.value_of r mpz3 = Int.tdiv (Z.value_of u mpz) (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt))) ∧ (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz3 mpz) ∧ Z.readers mpz3 r = (0 : ℤ) ∧ Z.readers mpz3 u = (0 : ℤ))))))))))))) else (C.valid up (BitVec.toInt o3) ∧ C.valid rp (BitVec.toInt o3) ∧ C.writable rp = true ∧ (C.offset rp ≤ C.offset up ∨ C.offset up + BitVec.toInt o3 ≤ C.offset rp)) ∧ (∀(up1 : C.ptr (BitVec 64)) (rp1 : C.ptr (BitVec 64)), C.data up1 = C.data rp1 ∧ List.length (C.data rp1) = List.length (C.data up) ∧ C.offset up1 = C.offset up ∧ C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → Lemmas.map_eq_sub_shift (C.pelts rp1) (C.pelts up) (C.offset rp1) (C.offset up1) (BitVec.toInt o3) ∧ (∀(j : ℤ), j < C.offset rp1 ∨ C.offset rp1 + BitVec.toInt o3 ≤ j → C.pelts rp1 j = C.pelts rp j) → -(2 : ℤ) < Z.readers mpz1 u ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = Z.sgn mpz1 u * Z.abs_size mpz1 u → (¬(0 : ℤ) ≤ BitVec.toInt o5 → int'32_in_bounds (-BitVec.toInt o3)) ∧ ((¬(0 : ℤ) ≤ BitVec.toInt o5 → (∃(nrn : BitVec 32), BitVec.toInt nrn = -BitVec.toInt o3)) → -(2 : ℤ) < Z.readers mpz1 u ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = Z.sgn mpz1 u * Z.abs_size mpz1 u → (¬(0 : ℤ) ≤ BitVec.toInt o6 → int'32_in_bounds (-BitVec.toInt o3)) ∧ (∀(o7 : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt o6 then o7 = o3 else BitVec.toInt o7 = -BitVec.toInt o3) → (Z.zones mpz1 r = C.zone1 rp1 ∧ Z.readers mpz1 r = -(1 : ℤ) ∧ C.offset rp1 = (0 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ abs (BitVec.toInt o7) ≤ C.plength rp1 ∧ C.plength rp1 = Z.alloc mpz1 r ∧ (¬BitVec.toInt o7 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o7) - (1 : ℤ))) ≤ Lemmas.value rp1 (abs (BitVec.toInt o7)))) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz2 mpz1) ∧ (Z.sgn mpz2 r = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o7) ∧ (Z.sgn mpz2 r = -(1 : ℤ)) = (BitVec.toInt o7 < (0 : ℤ)) ∧ Z.abs_size mpz2 r = abs (BitVec.toInt o7) ∧ Z.abs_value_of mpz2 r = Lemmas.value rp1 (abs (BitVec.toInt o7)) → (Z.zones mpz2 r = C.zone1 rp1 ∧ Z.readers mpz2 r = -(1 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ Z.abs_value_of mpz2 r = Lemmas.value rp1 (Z.abs_size mpz2 r)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 r = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = r → Z.readers mpz3 y = Z.readers mpz2 y) → Z.value_of r mpz3 = Int.tdiv (Z.value_of u mpz) (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt))) ∧ (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz3 mpz) ∧ Z.readers mpz3 r = (0 : ℤ) ∧ Z.readers mpz3 u = (0 : ℤ))))))))))) else Z.mpz_unchanged u mpz1 mpz ∧ (Z.readers mpz1 u = Z.readers mpz u ∧ (-(2 : ℤ) < Z.readers mpz1 u → Z.abs_value_of mpz1 u = Z.abs_value_of mpz u ∧ Z.alloc mpz1 u = Z.alloc mpz u ∧ Z.abs_size mpz1 u = Z.abs_size mpz u ∧ Z.sgn mpz1 u = Z.sgn mpz u ∧ Z.readers mpz1 u = Z.readers mpz u ∧ Z.zones mpz1 u = Z.zones mpz u) → (0 : ℤ) ≤ Z.readers mpz1 u ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(up0 : C.ptr (BitVec 64)), Z.readers mpz2 u = Z.readers mpz1 u + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬u = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value up0 (Z.abs_size mpz2 u) = Z.abs_value_of mpz2 u ∧ C.plength up0 = Z.alloc mpz2 u ∧ C.offset up0 = (0 : ℤ) ∧ C.min up0 = (0 : ℤ) ∧ C.max up0 = C.plength up0 ∧ C.zone1 up0 = Z.zones mpz2 u → (C.min up0 ≤ C.offset up0 + BitVec.toInt limb_cnt ∧ C.offset up0 + BitVec.toInt limb_cnt ≤ C.max up0) ∧ (∀(up : C.ptr (BitVec 64)), C.offset up = C.offset up0 + BitVec.toInt limb_cnt ∧ C.plength up = C.plength up0 ∧ C.pelts up = C.pelts up0 ∧ C.data up = C.data up0 ∧ C.min up = C.min up0 ∧ C.max up = C.max up0 ∧ C.zone1 up = C.zone1 up0 ∧ C.writable up = C.writable up0 → (∀(o4 : Bool), (BitVec.toUInt c = BitVec.toUInt (0 : BitVec 64) → o4 = true) ∧ (o4 = true → c = (0 : BitVec 64)) → (if ¬o4 = true then (C.valid up (BitVec.toInt o3) ∧ C.valid rp (BitVec.toInt o3) ∧ ((0 : ℤ) < BitVec.toUInt c ∧ BitVec.toUInt c < (64 : ℤ)) ∧ (0 : ℤ) < BitVec.toInt o3 ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(x_m : BitVec 64), BitVec.toUInt x_m + ((18446744073709551615 : ℤ) + (1 : ℤ)) * Lemmas.value rp1 (BitVec.toInt o3) = Lemmas.value up (BitVec.toInt o3) * HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - BitVec.toUInt c)) → ¬(18446744073709551615 : ℤ) + (1 : ℤ) = (0 : ℤ) ∧ int'32_in_bounds (BitVec.toInt o3 - (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt o3 - (1 : ℤ) → (C.min rp1 ≤ C.offset rp1 + BitVec.toInt o5 ∧ C.offset rp1 + BitVec.toInt o5 < C.max rp1) ∧ (let o6 : BitVec 64 := C.pelts rp1 (C.offset rp1 + BitVec.toInt o5); ∀(o7 : Bool), (BitVec.toUInt o6 = BitVec.toUInt (0 : BitVec 64) → o7 = true) ∧ (o7 = true → o6 = (0 : BitVec 64)) → (∀(o8 : BitVec 32), (if o7 = true then o8 = (1 : BitVec 32) else o8 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt o3 - BitVec.toInt o8) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt o3 - BitVec.toInt o8 → (Z.zones mpz2 u = C.zone1 up0 ∧ (1 : ℤ) ≤ Z.readers mpz2 u ∧ C.min up0 = (0 : ℤ) ∧ C.max up0 = C.plength up0) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 u = Z.readers mpz2 u - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u → Z.readers mpz3 y = Z.readers mpz2 y) → -(2 : ℤ) < Z.readers mpz3 u ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = Z.sgn mpz3 u * Z.abs_size mpz3 u → (¬(0 : ℤ) ≤ BitVec.toInt o10 → int'32_in_bounds (-BitVec.toInt o9)) ∧ ((¬(0 : ℤ) ≤ BitVec.toInt o10 → (∃(nrn : BitVec 32), BitVec.toInt nrn = -BitVec.toInt o9)) → -(2 : ℤ) < Z.readers mpz3 u ∧ (∀(o11 : BitVec 32), BitVec.toInt o11 = Z.sgn mpz3 u * Z.abs_size mpz3 u → (¬(0 : ℤ) ≤ BitVec.toInt o11 → int'32_in_bounds (-BitVec.toInt o9)) ∧ (∀(o12 : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt o11 then o12 = o9 else BitVec.toInt o12 = -BitVec.toInt o9) → (Z.zones mpz3 r = C.zone1 rp1 ∧ Z.readers mpz3 r = -(1 : ℤ) ∧ C.offset rp1 = (0 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ abs (BitVec.toInt o12) ≤ C.plength rp1 ∧ C.plength rp1 = Z.alloc mpz3 r ∧ (¬BitVec.toInt o12 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o12) - (1 : ℤ))) ≤ Lemmas.value rp1 (abs (BitVec.toInt o12)))) ∧ (∀(mpz4 : Z.mpz_memo), Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.readers mpz4 = Z.readers mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz4 mpz3) ∧ (Z.sgn mpz4 r = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o12) ∧ (Z.sgn mpz4 r = -(1 : ℤ)) = (BitVec.toInt o12 < (0 : ℤ)) ∧ Z.abs_size mpz4 r = abs (BitVec.toInt o12) ∧ Z.abs_value_of mpz4 r = Lemmas.value rp1 (abs (BitVec.toInt o12)) → (Z.zones mpz4 r = C.zone1 rp1 ∧ Z.readers mpz4 r = -(1 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ Z.abs_value_of mpz4 r = Lemmas.value rp1 (Z.abs_size mpz4 r)) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 r = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = r → Z.readers mpz5 y = Z.readers mpz4 y) → Z.value_of r mpz5 = Int.tdiv (Z.value_of u mpz) (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt))) ∧ (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz5 mpz) ∧ Z.readers mpz5 r = (0 : ℤ) ∧ Z.readers mpz5 u = (0 : ℤ)))))))))))))) else (C.valid up (BitVec.toInt o3) ∧ C.valid rp (BitVec.toInt o3) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → Lemmas.map_eq_sub_shift (C.pelts rp1) (C.pelts up) (C.offset rp1) (C.offset up) (BitVec.toInt o3) ∧ (∀(j : ℤ), j < C.offset rp1 ∨ C.offset rp1 + BitVec.toInt o3 ≤ j → C.pelts rp1 j = C.pelts rp j) → (Z.zones mpz2 u = C.zone1 up0 ∧ (1 : ℤ) ≤ Z.readers mpz2 u ∧ C.min up0 = (0 : ℤ) ∧ C.max up0 = C.plength up0) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 u = Z.readers mpz2 u - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u → Z.readers mpz3 y = Z.readers mpz2 y) → -(2 : ℤ) < Z.readers mpz3 u ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = Z.sgn mpz3 u * Z.abs_size mpz3 u → (¬(0 : ℤ) ≤ BitVec.toInt o5 → int'32_in_bounds (-BitVec.toInt o3)) ∧ ((¬(0 : ℤ) ≤ BitVec.toInt o5 → (∃(nrn : BitVec 32), BitVec.toInt nrn = -BitVec.toInt o3)) → -(2 : ℤ) < Z.readers mpz3 u ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = Z.sgn mpz3 u * Z.abs_size mpz3 u → (¬(0 : ℤ) ≤ BitVec.toInt o6 → int'32_in_bounds (-BitVec.toInt o3)) ∧ (∀(o7 : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt o6 then o7 = o3 else BitVec.toInt o7 = -BitVec.toInt o3) → (Z.zones mpz3 r = C.zone1 rp1 ∧ Z.readers mpz3 r = -(1 : ℤ) ∧ C.offset rp1 = (0 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ abs (BitVec.toInt o7) ≤ C.plength rp1 ∧ C.plength rp1 = Z.alloc mpz3 r ∧ (¬BitVec.toInt o7 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o7) - (1 : ℤ))) ≤ Lemmas.value rp1 (abs (BitVec.toInt o7)))) ∧ (∀(mpz4 : Z.mpz_memo), Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.readers mpz4 = Z.readers mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → (∀(y : Z.mpz_ptr), ¬y = r → Z.mpz_unchanged y mpz4 mpz3) ∧ (Z.sgn mpz4 r = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o7) ∧ (Z.sgn mpz4 r = -(1 : ℤ)) = (BitVec.toInt o7 < (0 : ℤ)) ∧ Z.abs_size mpz4 r = abs (BitVec.toInt o7) ∧ Z.abs_value_of mpz4 r = Lemmas.value rp1 (abs (BitVec.toInt o7)) → (Z.zones mpz4 r = C.zone1 rp1 ∧ Z.readers mpz4 r = -(1 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ Z.abs_value_of mpz4 r = Lemmas.value rp1 (Z.abs_size mpz4 r)) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 r = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = r → Z.readers mpz5 y = Z.readers mpz4 y) → Z.value_of r mpz5 = Int.tdiv (Z.value_of u mpz) (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt cnt))) ∧ (∀(x : Z.mpz_ptr), ¬x = r → Z.mpz_unchanged x mpz5 mpz) ∧ Z.readers mpz5 r = (0 : ℤ) ∧ Z.readers mpz5 u = (0 : ℤ)))))))))))))))))))))))))
  := sorry
end mpz_div2exp_Zdiv2exp_wmpz_tdiv_q_2expqtvc
