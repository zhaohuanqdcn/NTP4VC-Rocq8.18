import Why3.Base
import Why3.string.StringBuffer
open Classical
open Lean4Why3
namespace string_base64_encoding_Base64_get_padqtvc
noncomputable def int2b64 (i : ℤ) := if (0 : ℤ) ≤ i ∧ i ≤ (25 : ℤ) then BitVec.ofNat 8 (Int.toNat (i + (65 : ℤ))) else if (26 : ℤ) ≤ i ∧ i ≤ (51 : ℤ) then BitVec.ofNat 8 (Int.toNat (i - (26 : ℤ) + (97 : ℤ))) else if (52 : ℤ) ≤ i ∧ i ≤ (61 : ℤ) then BitVec.ofNat 8 (Int.toNat (i - (52 : ℤ) + (48 : ℤ))) else if i = (62 : ℤ) then BitVec.ofNat 8 (43 : ℕ) else if i = (63 : ℤ) then BitVec.ofNat 8 (47 : ℕ) else BitVec.ofNat 8 (0 : ℕ)
noncomputable def valid_b64_char (c : BitVec 8) := (65 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (90 : ℤ) ∨ (97 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (122 : ℤ) ∨ (48 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (57 : ℤ) ∨ BitVec.toInt c = (43 : ℤ) ∨ BitVec.toInt c = (47 : ℤ)
noncomputable def b642int (c : BitVec 8) := if (65 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (90 : ℤ) then BitVec.toInt c - (65 : ℤ) else if (97 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (122 : ℤ) then BitVec.toInt c - (97 : ℤ) + (26 : ℤ) else if (48 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (57 : ℤ) then BitVec.toInt c - (48 : ℤ) + (52 : ℤ) else if BitVec.toInt c = (43 : ℤ) then (62 : ℤ) else if BitVec.toInt c = (47 : ℤ) then (63 : ℤ) else if c = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) then (0 : ℤ) else (64 : ℤ)
noncomputable def get_pad (s : List (BitVec 8)) := if (1 : ℤ) ≤ Int.ofNat (List.length s) ∧ s[Int.toNat (Int.ofNat (List.length s) - (1 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) then if (2 : ℤ) ≤ Int.ofNat (List.length s) ∧ s[Int.toNat (Int.ofNat (List.length s) - (2 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) then (2 : ℤ) else (1 : ℤ) else (0 : ℤ)
theorem get_pad'vc (o1 : BitVec 63) (s : List (BitVec 8)) (fact0 : BitVec.toInt o1 = Int.ofNat (List.length s)) (fact1 : (0 : ℤ) ≤ Int.ofNat (List.length s)) : if (1 : ℤ) ≤ BitVec.toInt o1 then ∀(o2 : BitVec 63), BitVec.toInt o2 = Int.ofNat (List.length s) ∧ (0 : ℤ) ≤ Int.ofNat (List.length s) → int'63_in_bounds (BitVec.toInt o2 - (1 : ℤ)) ∧ (∀(o3 : BitVec 63), BitVec.toInt o3 = BitVec.toInt o2 - (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 < Int.ofNat (List.length s)) ∧ (if s[Int.toNat (BitVec.toInt o3)]! = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) then ∀(o4 : BitVec 63), BitVec.toInt o4 = Int.ofNat (List.length s) ∧ (0 : ℤ) ≤ Int.ofNat (List.length s) → (if (2 : ℤ) ≤ BitVec.toInt o4 then ∀(o5 : BitVec 63), BitVec.toInt o5 = Int.ofNat (List.length s) ∧ (0 : ℤ) ≤ Int.ofNat (List.length s) → int'63_in_bounds (BitVec.toInt o5 - (2 : ℤ)) ∧ (∀(o6 : BitVec 63), BitVec.toInt o6 = BitVec.toInt o5 - (2 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o6 ∧ BitVec.toInt o6 < Int.ofNat (List.length s)) ∧ (∀(result : BitVec 63), (if s[Int.toNat (BitVec.toInt o6)]! = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) then result = (2 : BitVec 63) else result = (1 : BitVec 63)) → BitVec.toInt result = get_pad s)) else BitVec.toInt (1 : BitVec 63) = get_pad s) else (0 : ℤ) = get_pad s)) else (0 : ℤ) = get_pad s
  := sorry
end string_base64_encoding_Base64_get_padqtvc
