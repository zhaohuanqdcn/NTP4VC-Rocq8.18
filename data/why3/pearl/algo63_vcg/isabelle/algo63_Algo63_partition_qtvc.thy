theory algo63_Algo63_partition_qtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut"
begin
theorem partition_'vc:
  fixes m :: "int"
  fixes n :: "int"
  fixes a :: "int list"
  fixes f :: "int"
  assumes fact0: "(0 :: int) \<le> m"
  assumes fact1: "m < n"
  assumes fact2: "n < int (length a)"
  assumes fact3: "m \<le> f"
  assumes fact4: "f \<le> n"
  shows "(0 :: int) \<le> f"
  and "f < int (length a)"
  and "let x :: int = a ! nat f in (\<forall>(j :: int) (i :: int) (a1 :: int list). length a1 = length a \<longrightarrow> ((m \<le> j \<and> j \<le> n) \<and> m \<le> i \<and> i \<le> n) \<and> permut_sub' a a1 (nat m) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). m \<le> r \<and> r < i \<longrightarrow> a1 ! nat r \<le> x) \<and> (\<forall>(r :: int). j < r \<and> r \<le> n \<longrightarrow> x \<le> a1 ! nat r) \<and> a1 ! nat f = x \<longrightarrow> ((m \<le> i \<and> i \<le> n) \<and> (\<forall>(r :: int). m \<le> r \<and> r < i \<longrightarrow> a1 ! nat r \<le> x)) \<and> (\<forall>(i1 :: int). (m \<le> i1 \<and> i1 \<le> n) \<and> (\<forall>(r :: int). m \<le> r \<and> r < i1 \<longrightarrow> a1 ! nat r \<le> x) \<longrightarrow> (i1 < n \<longrightarrow> (0 :: int) \<le> i1 \<and> i1 < int (length a1)) \<and> (\<forall>(o1 :: bool). (if i1 < n then o1 = (if a1 ! nat i1 \<le> x then True else False) else o1 = False) \<longrightarrow> (if o1 = True then ((0 :: int) \<le> n - i1 \<and> n - (i1 + (1 :: int)) < n - i1) \<and> (m \<le> i1 + (1 :: int) \<and> i1 + (1 :: int) \<le> n) \<and> (\<forall>(r :: int). m \<le> r \<and> r < i1 + (1 :: int) \<longrightarrow> a1 ! nat r \<le> x) else ((m \<le> j \<and> j \<le> n) \<and> (\<forall>(r :: int). j < r \<and> r \<le> n \<longrightarrow> x \<le> a1 ! nat r)) \<and> (\<forall>(j1 :: int). (m \<le> j1 \<and> j1 \<le> n) \<and> (\<forall>(r :: int). j1 < r \<and> r \<le> n \<longrightarrow> x \<le> a1 ! nat r) \<longrightarrow> (m < j1 \<longrightarrow> (0 :: int) \<le> j1 \<and> j1 < int (length a1)) \<and> (\<forall>(o2 :: bool). (if m < j1 then o2 = (if x \<le> a1 ! nat j1 then True else False) else o2 = False) \<longrightarrow> (if o2 = True then ((0 :: int) \<le> j1 \<and> j1 - (1 :: int) < j1) \<and> (m \<le> j1 - (1 :: int) \<and> j1 - (1 :: int) \<le> n) \<and> (\<forall>(r :: int). j1 - (1 :: int) < r \<and> r \<le> n \<longrightarrow> x \<le> a1 ! nat r) else if i1 < j1 then (((0 :: int) \<le> m \<and> m \<le> i1 \<and> i1 \<le> n \<and> n < int (length a1)) \<and> m \<le> j1 \<and> j1 \<le> n) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 i1 j1 \<and> permut_sub' a1 a2 (nat m) (nat (n + (1 :: int))) \<longrightarrow> (((0 :: int) \<le> (1 :: int) + j - i \<and> (1 :: int) + (j1 - (1 :: int)) - (i1 + (1 :: int)) < (1 :: int) + j - i) \<and> ((m \<le> j1 - (1 :: int) \<and> j1 - (1 :: int) \<le> n) \<and> m \<le> i1 + (1 :: int) \<and> i1 + (1 :: int) \<le> n) \<and> permut_sub' a a2 (nat m) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). m \<le> r \<and> r < i1 + (1 :: int) \<longrightarrow> a2 ! nat r \<le> x) \<and> (\<forall>(r :: int). j1 - (1 :: int) < r \<and> r \<le> n \<longrightarrow> x \<le> a2 ! nat r) \<and> a2 ! nat f = x) \<and> (\<forall>(j2 :: int) (i2 :: int) (a3 :: int list). length a3 = length a2 \<longrightarrow> (m \<le> j2 \<and> j2 \<le> i2 \<and> i2 \<le> n) \<and> permut_sub' a2 a3 (nat m) (nat (n + (1 :: int))) \<and> (i2 = n \<or> x < a3 ! nat i2) \<and> (j2 = m \<or> a3 ! nat j2 < x) \<and> a3 ! nat f = x \<and> (\<forall>(r :: int). m \<le> r \<and> r < i2 \<longrightarrow> a3 ! nat r \<le> x) \<and> (\<forall>(r :: int). j2 < r \<and> r \<le> n \<longrightarrow> x \<le> a3 ! nat r) \<longrightarrow> (m \<le> j2 \<and> j2 \<le> i2 \<and> i2 \<le> n) \<and> permut_sub' a1 a3 (nat m) (nat (n + (1 :: int))) \<and> (i2 = n \<or> x < a3 ! nat i2) \<and> (j2 = m \<or> a3 ! nat j2 < x) \<and> a3 ! nat f = x \<and> (\<forall>(r :: int). m \<le> r \<and> r < i2 \<longrightarrow> a3 ! nat r \<le> x) \<and> (\<forall>(r :: int). j2 < r \<and> r \<le> n \<longrightarrow> x \<le> a3 ! nat r))) else (m \<le> j1 \<and> j1 \<le> i1 \<and> i1 \<le> n) \<and> permut_sub' a1 a1 (nat m) (nat (n + (1 :: int))) \<and> (i1 = n \<or> x < a1 ! nat i1) \<and> (j1 = m \<or> a1 ! nat j1 < x) \<and> a1 ! nat f = x \<and> (\<forall>(r :: int). m \<le> r \<and> r < i1 \<longrightarrow> a1 ! nat r \<le> x) \<and> (\<forall>(r :: int). j1 < r \<and> r \<le> n \<longrightarrow> x \<le> a1 ! nat r)))))))) \<and> (((m \<le> n \<and> n \<le> n) \<and> m \<le> m \<and> m \<le> n) \<and> permut_sub' a a (nat m) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). m \<le> r \<and> r < m \<longrightarrow> a ! nat r \<le> x) \<and> (\<forall>(r :: int). n < r \<and> r \<le> n \<longrightarrow> x \<le> a ! nat r) \<and> a ! nat f = x) \<and> (\<forall>(j :: int) (i :: int) (a1 :: int list). length a1 = length a \<longrightarrow> (m \<le> j \<and> j \<le> i \<and> i \<le> n) \<and> permut_sub' a a1 (nat m) (nat (n + (1 :: int))) \<and> (i = n \<or> x < a1 ! nat i) \<and> (j = m \<or> a1 ! nat j < x) \<and> a1 ! nat f = x \<and> (\<forall>(r :: int). m \<le> r \<and> r < i \<longrightarrow> a1 ! nat r \<le> x) \<and> (\<forall>(r :: int). j < r \<and> r \<le> n \<longrightarrow> x \<le> a1 ! nat r) \<longrightarrow> (if i < f then (((0 :: int) \<le> m \<and> m \<le> i \<and> i \<le> n \<and> n < int (length a1)) \<and> m \<le> f \<and> f \<le> n) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 i f \<and> permut_sub' a1 a2 (nat m) (nat (n + (1 :: int))) \<longrightarrow> (m \<le> j \<and> j < i + (1 :: int) \<and> i + (1 :: int) \<le> n) \<and> permut_sub' a a2 (nat m) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). m \<le> r \<and> r \<le> j \<longrightarrow> a2 ! nat r \<le> x) \<and> (\<forall>(r :: int). j < r \<and> r < i + (1 :: int) \<longrightarrow> a2 ! nat r = x) \<and> (\<forall>(r :: int). i + (1 :: int) \<le> r \<and> r \<le> n \<longrightarrow> x \<le> a2 ! nat r)) else if f < j then (((0 :: int) \<le> m \<and> m \<le> f \<and> f \<le> n \<and> n < int (length a1)) \<and> m \<le> j \<and> j \<le> n) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 f j \<and> permut_sub' a1 a2 (nat m) (nat (n + (1 :: int))) \<longrightarrow> (m \<le> j - (1 :: int) \<and> j - (1 :: int) < i \<and> i \<le> n) \<and> permut_sub' a a2 (nat m) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). m \<le> r \<and> r \<le> j - (1 :: int) \<longrightarrow> a2 ! nat r \<le> x) \<and> (\<forall>(r :: int). j - (1 :: int) < r \<and> r < i \<longrightarrow> a2 ! nat r = x) \<and> (\<forall>(r :: int). i \<le> r \<and> r \<le> n \<longrightarrow> x \<le> a2 ! nat r)) else (m \<le> j \<and> j < i \<and> i \<le> n) \<and> permut_sub' a a1 (nat m) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). m \<le> r \<and> r \<le> j \<longrightarrow> a1 ! nat r \<le> x) \<and> (\<forall>(r :: int). j < r \<and> r < i \<longrightarrow> a1 ! nat r = x) \<and> (\<forall>(r :: int). i \<le> r \<and> r \<le> n \<longrightarrow> x \<le> a1 ! nat r)))"
  sorry
end
