theory maximum_subarray_Algo5_maximum_subarrayqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_Sum"
begin
theorem maximum_subarray'vc:
  fixes a :: "int list"
  shows "let o1 :: int = int (length a) - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> (0 :: int) \<longrightarrow> sum_list (drop (nat l) (take ((0 :: nat) - nat l) a)) \<le> (0 :: int)) \<and> ((0 :: int) \<le> (0 :: int) \<and> sum_list (drop (0 :: nat) (take ((0 :: nat) - (0 :: nat)) a)) = (0 :: int)) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> (0 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h - nat l) a)) \<le> (0 :: int)) \<and> (0 :: int) \<le> (0 :: int) \<and> sum_list (drop (0 :: nat) (take ((0 :: nat) - (0 :: nat)) a)) = (0 :: int)) \<and> (\<forall>(cl :: int) (hi :: int) (lo :: int) (curmax :: int) (maxsum :: int). (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o1) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i \<longrightarrow> sum_list (drop (nat l) (take (nat i - nat l) a)) \<le> curmax) \<and> (((0 :: int) \<le> cl \<and> cl \<le> i) \<and> sum_list (drop (nat cl) (take (nat i - nat cl) a)) = curmax) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i \<longrightarrow> sum_list (drop (nat l) (take (nat h - nat l) a)) \<le> maxsum) \<and> ((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> i) \<and> sum_list (drop (nat lo) (take (nat hi - nat lo) a)) = maxsum \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if curmax + a ! nat i < (0 :: int) then if maxsum < (0 :: int) then (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat (i + (1 :: int)) - nat l) a)) \<le> (0 :: int)) \<and> (((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> sum_list (drop (nat (i + (1 :: int))) (take (nat (i + (1 :: int)) - nat (i + (1 :: int))) a)) = (0 :: int)) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h - nat l) a)) \<le> (0 :: int)) \<and> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> sum_list (drop (nat (i + (1 :: int))) (take (nat (i + (1 :: int)) - nat (i + (1 :: int))) a)) = (0 :: int) else (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat (i + (1 :: int)) - nat l) a)) \<le> (0 :: int)) \<and> (((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> sum_list (drop (nat (i + (1 :: int))) (take (nat (i + (1 :: int)) - nat (i + (1 :: int))) a)) = (0 :: int)) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h - nat l) a)) \<le> maxsum) \<and> ((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> i + (1 :: int)) \<and> sum_list (drop (nat lo) (take (nat hi - nat lo) a)) = maxsum else if maxsum < curmax + a ! nat i then (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat (i + (1 :: int)) - nat l) a)) \<le> curmax + a ! nat i) \<and> (((0 :: int) \<le> cl \<and> cl \<le> i + (1 :: int)) \<and> sum_list (drop (nat cl) (take (nat (i + (1 :: int)) - nat cl) a)) = curmax + a ! nat i) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h - nat l) a)) \<le> curmax + a ! nat i) \<and> ((0 :: int) \<le> cl \<and> cl \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> sum_list (drop (nat cl) (take (nat (i + (1 :: int)) - nat cl) a)) = curmax + a ! nat i else (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat (i + (1 :: int)) - nat l) a)) \<le> curmax + a ! nat i) \<and> (((0 :: int) \<le> cl \<and> cl \<le> i + (1 :: int)) \<and> sum_list (drop (nat cl) (take (nat (i + (1 :: int)) - nat cl) a)) = curmax + a ! nat i) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h - nat l) a)) \<le> maxsum) \<and> ((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> i + (1 :: int)) \<and> sum_list (drop (nat lo) (take (nat hi - nat lo) a)) = maxsum)) \<and> ((\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> o1 + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat (o1 + (1 :: int)) - nat l) a)) \<le> curmax) \<and> (((0 :: int) \<le> cl \<and> cl \<le> o1 + (1 :: int)) \<and> sum_list (drop (nat cl) (take (nat (o1 + (1 :: int)) - nat cl) a)) = curmax) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> o1 + (1 :: int) \<longrightarrow> sum_list (drop (nat l) (take (nat h - nat l) a)) \<le> maxsum) \<and> ((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> o1 + (1 :: int)) \<and> sum_list (drop (nat lo) (take (nat hi - nat lo) a)) = maxsum \<longrightarrow> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> int (length a) \<longrightarrow> sum_list (drop (nat l) (take (nat h - nat l) a)) \<le> maxsum) \<and> (\<exists>(l :: int) (h :: int). ((0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> int (length a)) \<and> sum_list (drop (nat l) (take (nat h - nat l) a)) = maxsum)))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> int (length a) \<longrightarrow> sum_list (drop (nat l) (take (nat h - nat l) a)) \<le> (0 :: int)) \<and> (\<exists>(l :: int) (h :: int). ((0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> int (length a)) \<and> sum_list (drop (nat l) (take (nat h - nat l) a)) = (0 :: int)))"
  sorry
end
