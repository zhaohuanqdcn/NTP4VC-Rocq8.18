theory div_Div_wmpn_divrem_1qtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_LogicalOld"
begin
definition reciprocal :: "64 word \<Rightarrow> 64 word \<Rightarrow> _"
  where "reciprocal v d \<longleftrightarrow> uint v = (((18446744073709551615 :: int) + (1 :: int)) * ((18446744073709551615 :: int) + (1 :: int)) - (1 :: int)) ediv uint d - ((18446744073709551615 :: int) + (1 :: int))" for v d
theorem wmpn_divrem_1'vc:
  fixes x :: "64 word ptr"
  fixes sz :: "32 word"
  fixes q :: "64 word ptr"
  fixes y :: "64 word"
  assumes fact0: "valid x (sint sz)"
  assumes fact1: "valid q (sint sz)"
  assumes fact2: "writable q = True"
  assumes fact3: "(0 :: int) < sint sz"
  assumes fact4: "(0 :: int) < uint y"
  shows "int'32_in_bounds (sint sz - (1 :: int))"
  and "\<forall>(msb :: 32 word). sint msb = sint sz - (1 :: int) \<longrightarrow> (0 :: int) < uint y \<and> (\<forall>(clz :: 32 word). (2 :: int) ^\<^sub>i sint clz * uint y \<le> (18446744073709551615 :: int) \<and> (18446744073709551615 :: int) < (2 :: int) * (2 :: int) ^\<^sub>i sint clz * uint y \<and> (0 :: int) \<le> sint clz \<and> sint clz < (64 :: int) \<longrightarrow> (if (0 :: int) < sint clz then let mult :: int = (2 :: int) ^\<^sub>i sint clz in (0 :: int) \<le> sint clz \<and> (\<forall>(o1 :: 64 word). uint o1 = sint clz \<longrightarrow> (((0 :: int) \<le> uint o1 \<and> uint o1 < (64 :: int)) \<and> (2 :: int) ^\<^sub>i uint o1 * uint y \<le> (18446744073709551615 :: int)) \<and> (\<forall>(ry :: 64 word). uint ry = (2 :: int) ^\<^sub>i uint o1 * uint y \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint ry \<and> (\<forall>(v :: 64 word). reciprocal v ry \<longrightarrow> ((-(1 :: int) \<le> sint msb \<and> sint msb \<le> sint msb) \<and> (0 :: int) < uint ry \<and> mult * value_sub (pelts x) (offset x + sint msb + (1 :: int)) (offset x + sint sz) = value_sub (pelts q) (offset q + sint msb + (1 :: int)) (offset q + sint sz) * uint ry + (0 :: int) \<and> (0 :: int) \<le> (18446744073709551615 :: int) + (1 :: int) - mult \<and> (0 :: int) emod mult = (0 :: int)) \<and> (\<forall>(r :: 64 word) (i :: 32 word) (q1 :: 64 word ptr). length (data q1) = length (data q) \<and> offset q1 = offset q \<and> c_C.min q1 = c_C.min q \<and> c_C.max q1 = c_C.max q \<and> writable q1 = writable q \<and> zone1 q1 = zone1 q \<longrightarrow> (-(1 :: int) \<le> sint i \<and> sint i \<le> sint msb) \<and> uint r < uint ry \<and> mult * value_sub (pelts x) (offset x + sint i + (1 :: int)) (offset x + sint sz) = value_sub (pelts q1) (offset q1 + sint i + (1 :: int)) (offset q1 + sint sz) * uint ry + uint r \<and> uint r \<le> (18446744073709551615 :: int) + (1 :: int) - mult \<and> uint r emod mult = (0 :: int) \<longrightarrow> (if (0 :: int) \<le> sint i then (c_C.min x \<le> offset x + sint i \<and> offset x + sint i < c_C.max x) \<and> (0 :: int) \<le> sint clz \<and> (\<forall>(o2 :: 64 word). uint o2 = sint clz \<longrightarrow> ((0 :: int) < uint o2 \<and> uint o2 < (64 :: int)) \<and> (\<forall>(l :: 64 word) (h :: 64 word). uint l + ((18446744073709551615 :: int) + (1 :: int)) * uint h = (2 :: int) ^\<^sub>i uint o2 * uint (pelts x (offset x + sint i)) \<and> uint l emod (2 :: int) ^\<^sub>i uint o2 = (0 :: int) \<and> uint l \<le> (18446744073709551615 :: int) + (1 :: int) - (2 :: int) ^\<^sub>i uint o2 \<and> uint h < (2 :: int) ^\<^sub>i uint o2 \<longrightarrow> uint'64_in_bounds (uint r + uint h) \<and> (\<forall>(o3 :: 64 word). uint o3 = uint r + uint h \<longrightarrow> (((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint ry \<and> uint o3 < uint ry \<and> reciprocal v ry) \<and> (\<forall>(qu :: 64 word) (rem :: 64 word). uint qu * uint ry + uint rem = uint l + ((18446744073709551615 :: int) + (1 :: int)) * uint o3 \<and> (0 :: int) \<le> uint rem \<and> uint rem < uint ry \<longrightarrow> \<not>mult = (0 :: int) \<and> (let o4 :: int = offset q1 + sint sz; o5 :: int = offset q1 + (1 :: int) + sint i; o6 :: int = offset q1 + sint i; o7 :: int \<Rightarrow> 64 word = pelts q1 in (o5 \<le> o4 \<and> (o6 < o5 \<or> o4 \<le> o6)) \<and> (value_sub o7 o5 o4 = value_sub (o7(o6 := qu)) o5 o4 \<longrightarrow> ((c_C.min q1 \<le> offset q1 + sint i \<and> offset q1 + sint i < c_C.max q1) \<and> writable q1 = True) \<and> (\<forall>(q2 :: 64 word ptr). length (data q2) = length (data q1) \<and> offset q2 = offset q1 \<and> c_C.min q2 = c_C.min q1 \<and> c_C.max q2 = c_C.max q1 \<and> writable q2 = writable q1 \<and> zone1 q2 = zone1 q1 \<longrightarrow> pelts q2 = (pelts q1)(offset q2 + sint i := qu) \<and> pelts q2 (offset q2 + sint i) = qu \<longrightarrow> int'32_in_bounds (sint i - (1 :: int)) \<and> (\<forall>(o8 :: 32 word). sint o8 = sint i - (1 :: int) \<longrightarrow> sint o8 < sint i \<and> (-(1 :: int) \<le> sint o8 \<and> sint o8 \<le> sint msb) \<and> uint rem < uint ry \<and> mult * value_sub (pelts x) (offset x + sint o8 + (1 :: int)) (offset x + sint sz) = value_sub (pelts q2) (offset q2 + sint o8 + (1 :: int)) (offset q2 + sint sz) * uint ry + uint rem \<and> uint rem \<le> (18446744073709551615 :: int) + (1 :: int) - mult \<and> uint rem emod mult = (0 :: int))))))))) else (0 :: int) \<le> sint clz \<and> (\<forall>(o2 :: 64 word). uint o2 = sint clz \<longrightarrow> (((0 :: int) \<le> uint o2 \<and> uint o2 < (64 :: int)) \<and> uint r emod (2 :: int) ^\<^sub>i uint o2 = (0 :: int)) \<and> (\<forall>(res :: 64 word). uint r = (2 :: int) ^\<^sub>i uint o2 * uint res \<longrightarrow> (0 :: int) \<le> sint clz \<and> (\<forall>(o3 :: 64 word). uint o3 = sint clz \<longrightarrow> (((0 :: int) \<le> uint o3 \<and> uint o3 < (64 :: int)) \<and> uint r emod (2 :: int) ^\<^sub>i uint o3 = (0 :: int)) \<and> (\<forall>(result :: 64 word). uint r = (2 :: int) ^\<^sub>i uint o3 * uint result \<longrightarrow> value x (sint sz) = value q1 (sint sz) * uint y + uint result \<and> uint result < uint y))))))))) else ((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint y \<and> (\<forall>(v :: 64 word). reciprocal v y \<longrightarrow> ((-(1 :: int) \<le> sint msb \<and> sint msb \<le> sint msb) \<and> (0 :: int) < uint y \<and> value_sub (pelts x) (offset x + sint msb + (1 :: int)) (offset x + sint sz) = value_sub (pelts q) (offset q + sint msb + (1 :: int)) (offset q + sint sz) * uint y + (0 :: int)) \<and> (\<forall>(r :: 64 word) (i :: 32 word) (q1 :: 64 word ptr). length (data q1) = length (data q) \<and> offset q1 = offset q \<and> c_C.min q1 = c_C.min q \<and> c_C.max q1 = c_C.max q \<and> writable q1 = writable q \<and> zone1 q1 = zone1 q \<longrightarrow> (-(1 :: int) \<le> sint i \<and> sint i \<le> sint msb) \<and> uint r < uint y \<and> value_sub (pelts x) (offset x + sint i + (1 :: int)) (offset x + sint sz) = value_sub (pelts q1) (offset q1 + sint i + (1 :: int)) (offset q1 + sint sz) * uint y + uint r \<longrightarrow> (if (0 :: int) \<le> sint i then (c_C.min x \<le> offset x + sint i \<and> offset x + sint i < c_C.max x) \<and> (((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint y \<and> uint r < uint y \<and> reciprocal v y) \<and> (\<forall>(qu :: 64 word) (rem :: 64 word). uint qu * uint y + uint rem = uint (pelts x (offset x + sint i)) + ((18446744073709551615 :: int) + (1 :: int)) * uint r \<and> (0 :: int) \<le> uint rem \<and> uint rem < uint y \<longrightarrow> (let o1 :: int = offset q1 + sint sz; o2 :: int = offset q1 + (1 :: int) + sint i; o3 :: int = offset q1 + sint i; o4 :: int \<Rightarrow> 64 word = pelts q1 in (o2 \<le> o1 \<and> (o3 < o2 \<or> o1 \<le> o3)) \<and> (value_sub o4 o2 o1 = value_sub (o4(o3 := qu)) o2 o1 \<longrightarrow> ((c_C.min q1 \<le> offset q1 + sint i \<and> offset q1 + sint i < c_C.max q1) \<and> writable q1 = True) \<and> (\<forall>(q2 :: 64 word ptr). length (data q2) = length (data q1) \<and> offset q2 = offset q1 \<and> c_C.min q2 = c_C.min q1 \<and> c_C.max q2 = c_C.max q1 \<and> writable q2 = writable q1 \<and> zone1 q2 = zone1 q1 \<longrightarrow> pelts q2 = (pelts q1)(offset q2 + sint i := qu) \<and> pelts q2 (offset q2 + sint i) = qu \<longrightarrow> int'32_in_bounds (sint i - (1 :: int)) \<and> (\<forall>(o5 :: 32 word). sint o5 = sint i - (1 :: int) \<longrightarrow> sint o5 < sint i \<and> (-(1 :: int) \<le> sint o5 \<and> sint o5 \<le> sint msb) \<and> uint rem < uint y \<and> value_sub (pelts x) (offset x + sint o5 + (1 :: int)) (offset x + sint sz) = value_sub (pelts q2) (offset q2 + sint o5 + (1 :: int)) (offset q2 + sint sz) * uint y + uint rem))))) else value x (sint sz) = value q1 (sint sz) * uint y + uint r \<and> uint r < uint y)))))"
  sorry
end
