theory verifythis_2019_cartesian_trees_Top_smaller_leftqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.exn_Exn"
begin
axiomatization where Trans:   "z \<le> x"
 if "y \<le> x"
 and "z \<le> y"
  for y :: "int"
  and x :: "int"
  and z :: "int"
inductive sorted :: "int list \<Rightarrow> bool" where
   Sorted_Nil: "sorted (Nil :: int list)"
 | Sorted_One: "sorted (Cons x (Nil :: int list))" for x :: "int"
 | Sorted_Two: "y \<le> x \<Longrightarrow> sorted (Cons y l) \<Longrightarrow> sorted (Cons x (Cons y l))" for y :: "int" and x :: "int" and l :: "int list"
axiomatization where sorted_mem:   "(\<forall>(y :: int). y \<in> set l \<longrightarrow> y \<le> x) \<and> sorted l \<longleftrightarrow> sorted (Cons x l)"
  for l :: "int list"
  and x :: "int"
axiomatization where sorted_append:   "sorted l1 \<and> sorted l2 \<and> (\<forall>(x :: int) (y :: int). x \<in> set l1 \<longrightarrow> y \<in> set l2 \<longrightarrow> y \<le> x) \<longleftrightarrow> sorted (l1 @ l2)"
  for l1 :: "int list"
  and l2 :: "int list"
consts destruct :: "'xi list \<Rightarrow> 'xi \<times> 'xi list"
axiomatization where destruct'def:   "case l of Cons h t \<Rightarrow> destruct l = (h, t) | _ \<Rightarrow> False"
 if "\<not>is_Nil l"
  for l :: "'xi list"
consts peek :: "'xi list \<Rightarrow> 'xi"
axiomatization where peek'def:   "case destruct l of (h, _) \<Rightarrow> peek l = h"
 if "\<not>is_Nil l"
  for l :: "'xi list"
axiomatization where peek'spec:   "peek l \<in> set l"
 if "\<not>is_Nil l"
  for l :: "'xi list"
consts tail :: "'xi list \<Rightarrow> 'xi list"
axiomatization where tail'def:   "case destruct l of (_, t) \<Rightarrow> tail l = t"
 if "\<not>is_Nil l"
  for l :: "'xi list"
theorem smaller_left'vc:
  fixes s :: "int list"
  shows "let n :: int = int (length s) in (0 :: int) \<le> n \<and> (\<forall>(left1 :: int list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> left1 ! nat i = -(1 :: int)) \<and> int (length left1) = n \<longrightarrow> (let o1 :: int = int (length s) - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((\<forall>(z :: int). z \<in> set (Nil :: int list) \<longrightarrow> (0 :: int) \<le> z \<and> z < (0 :: int)) \<and> (\<not>is_Nil (Nil :: int list) \<longrightarrow> peek (Nil :: int list) = (0 :: int) - (1 :: int)) \<and> sorted (Nil :: int list) \<and> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < (0 :: int) \<longrightarrow> left1 ! nat y < y) \<and> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < (0 :: int) \<longrightarrow> (0 :: int) \<le> left1 ! nat y \<longrightarrow> s ! nat (left1 ! nat y) < s ! nat y) \<and> (\<forall>(z :: int). (0 :: int) \<le> z \<and> z < (0 :: int) \<longrightarrow> (\<exists>(y :: int). (z \<le> y \<and> y < (0 :: int)) \<and> y \<in> set (Nil :: int list) \<and> s ! nat y \<le> s ! nat z)) \<and> (\<forall>(y :: int) (z :: int). (0 :: int) \<le> y \<and> y < (0 :: int) \<longrightarrow> left1 ! nat y < z \<and> z < y \<longrightarrow> s ! nat y \<le> s ! nat z)) \<and> (\<forall>(my_stack :: int list) (left2 :: int list). length left2 = length left1 \<longrightarrow> (\<forall>(x :: int). ((0 :: int) \<le> x \<and> x \<le> o1) \<and> (\<forall>(z :: int). z \<in> set my_stack \<longrightarrow> (0 :: int) \<le> z \<and> z < x) \<and> (is_Nil my_stack \<longrightarrow> x = (0 :: int)) \<and> (\<not>is_Nil my_stack \<longrightarrow> peek my_stack = x - (1 :: int)) \<and> sorted my_stack \<and> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < x \<longrightarrow> left2 ! nat y < y) \<and> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < x \<longrightarrow> (0 :: int) \<le> left2 ! nat y \<longrightarrow> s ! nat (left2 ! nat y) < s ! nat y) \<and> (\<forall>(z :: int). (0 :: int) \<le> z \<and> z < x \<longrightarrow> (\<exists>(y :: int). (z \<le> y \<and> y < x) \<and> y \<in> set my_stack \<and> s ! nat y \<le> s ! nat z)) \<and> (\<forall>(y :: int) (z :: int). (0 :: int) \<le> y \<and> y < x \<longrightarrow> left2 ! nat y < z \<and> z < y \<longrightarrow> s ! nat y \<le> s ! nat z) \<longrightarrow> ((\<forall>(z :: int). z \<in> set my_stack \<longrightarrow> (0 :: int) \<le> z \<and> z < x) \<and> sorted my_stack \<and> (\<forall>(z :: int). z \<in> set my_stack \<longrightarrow> s ! nat x \<le> s ! nat z \<or> z \<in> set my_stack) \<and> (\<forall>(z :: int). \<not>is_Nil my_stack \<longrightarrow> z \<in> set my_stack \<longrightarrow> z \<le> peek my_stack) \<and> (\<forall>(z :: int). \<not>is_Nil my_stack \<longrightarrow> peek my_stack < z \<and> z < x \<longrightarrow> s ! nat x \<le> s ! nat z) \<and> (\<forall>(z :: int). is_Nil my_stack \<longrightarrow> (0 :: int) \<le> z \<and> z < x \<longrightarrow> s ! nat x \<le> s ! nat z)) \<and> (\<forall>(my_stack1 :: int list). (\<forall>(z :: int). z \<in> set my_stack1 \<longrightarrow> (0 :: int) \<le> z \<and> z < x) \<and> sorted my_stack1 \<and> (\<forall>(z :: int). z \<in> set my_stack \<longrightarrow> s ! nat x \<le> s ! nat z \<or> z \<in> set my_stack1) \<and> (\<forall>(z :: int). \<not>is_Nil my_stack1 \<longrightarrow> z \<in> set my_stack1 \<longrightarrow> z \<le> peek my_stack1) \<and> (\<forall>(z :: int). \<not>is_Nil my_stack1 \<longrightarrow> peek my_stack1 < z \<and> z < x \<longrightarrow> s ! nat x \<le> s ! nat z) \<and> (\<forall>(z :: int). is_Nil my_stack1 \<longrightarrow> (0 :: int) \<le> z \<and> z < x \<longrightarrow> s ! nat x \<le> s ! nat z) \<longrightarrow> (is_Nil my_stack1 \<longleftrightarrow> my_stack1 = (Nil :: int list)) \<longrightarrow> (\<not>is_Nil my_stack1 \<longrightarrow> ((0 :: int) \<le> x \<and> x < int (length s)) \<and> \<not>is_Nil my_stack1 \<and> (let o2 :: int = peek my_stack1 in o2 \<in> set my_stack1 \<longrightarrow> (0 :: int) \<le> o2 \<and> o2 < int (length s))) \<and> (\<forall>(o2 :: bool). (if \<not>is_Nil my_stack1 then let o3 :: int = peek my_stack1 in o3 \<in> set my_stack1 \<and> o2 = (if s ! nat x \<le> s ! nat o3 then True else False) else o2 = False) \<longrightarrow> (if o2 = True then \<not>is_Nil my_stack1 \<and> ((0 :: int) \<le> int (length my_stack1) \<and> length (tail my_stack1) < length my_stack1) \<and> (\<forall>(z :: int). z \<in> set (tail my_stack1) \<longrightarrow> (0 :: int) \<le> z \<and> z < x) \<and> sorted (tail my_stack1) \<and> (\<forall>(z :: int). z \<in> set my_stack \<longrightarrow> s ! nat x \<le> s ! nat z \<or> z \<in> set (tail my_stack1)) \<and> (\<forall>(z :: int). \<not>is_Nil (tail my_stack1) \<longrightarrow> z \<in> set (tail my_stack1) \<longrightarrow> z \<le> peek (tail my_stack1)) \<and> (\<forall>(z :: int). \<not>is_Nil (tail my_stack1) \<longrightarrow> peek (tail my_stack1) < z \<and> z < x \<longrightarrow> s ! nat x \<le> s ! nat z) \<and> (\<forall>(z :: int). is_Nil (tail my_stack1) \<longrightarrow> (0 :: int) \<le> z \<and> z < x \<longrightarrow> s ! nat x \<le> s ! nat z) else (is_Nil my_stack1 \<longleftrightarrow> my_stack1 = (Nil :: int list)) \<longrightarrow> (if is_Nil my_stack1 then ((0 :: int) \<le> x \<and> x < int (length left2)) \<and> (length (left2[nat x := -(1 :: int)]) = length left2 \<longrightarrow> nth (left2[nat x := -(1 :: int)]) o nat = (nth left2 o nat)(x := -(1 :: int)) \<longrightarrow> (\<forall>(z :: int). z \<in> set (Cons x my_stack1) \<longrightarrow> (0 :: int) \<le> z \<and> z < x + (1 :: int)) \<and> (is_Nil (Cons x my_stack1) \<longrightarrow> x + (1 :: int) = (0 :: int)) \<and> (\<not>is_Nil (Cons x my_stack1) \<longrightarrow> peek (Cons x my_stack1) = x + (1 :: int) - (1 :: int)) \<and> sorted (Cons x my_stack1) \<and> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < x + (1 :: int) \<longrightarrow> left2[nat x := -(1 :: int)] ! nat y < y) \<and> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < x + (1 :: int) \<longrightarrow> (0 :: int) \<le> left2[nat x := -(1 :: int)] ! nat y \<longrightarrow> s ! nat (left2[nat x := -(1 :: int)] ! nat y) < s ! nat y) \<and> (\<forall>(z :: int). (0 :: int) \<le> z \<and> z < x + (1 :: int) \<longrightarrow> (\<exists>(y :: int). (z \<le> y \<and> y < x + (1 :: int)) \<and> y \<in> set (Cons x my_stack1) \<and> s ! nat y \<le> s ! nat z)) \<and> (\<forall>(y :: int) (z :: int). (0 :: int) \<le> y \<and> y < x + (1 :: int) \<longrightarrow> left2[nat x := -(1 :: int)] ! nat y < z \<and> z < y \<longrightarrow> s ! nat y \<le> s ! nat z)) else \<not>is_Nil my_stack1 \<and> (let o3 :: int = peek my_stack1 in o3 \<in> set my_stack1 \<longrightarrow> ((0 :: int) \<le> x \<and> x < int (length left2)) \<and> (length (left2[nat x := o3]) = length left2 \<longrightarrow> nth (left2[nat x := o3]) o nat = (nth left2 o nat)(x := o3) \<longrightarrow> (\<forall>(z :: int). z \<in> set (Cons x my_stack1) \<longrightarrow> (0 :: int) \<le> z \<and> z < x + (1 :: int)) \<and> (is_Nil (Cons x my_stack1) \<longrightarrow> x + (1 :: int) = (0 :: int)) \<and> (\<not>is_Nil (Cons x my_stack1) \<longrightarrow> peek (Cons x my_stack1) = x + (1 :: int) - (1 :: int)) \<and> sorted (Cons x my_stack1) \<and> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < x + (1 :: int) \<longrightarrow> left2[nat x := o3] ! nat y < y) \<and> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < x + (1 :: int) \<longrightarrow> (0 :: int) \<le> left2[nat x := o3] ! nat y \<longrightarrow> s ! nat (left2[nat x := o3] ! nat y) < s ! nat y) \<and> (\<forall>(z :: int). (0 :: int) \<le> z \<and> z < x + (1 :: int) \<longrightarrow> (\<exists>(y :: int). (z \<le> y \<and> y < x + (1 :: int)) \<and> y \<in> set (Cons x my_stack1) \<and> s ! nat y \<le> s ! nat z)) \<and> (\<forall>(y :: int) (z :: int). (0 :: int) \<le> y \<and> y < x + (1 :: int) \<longrightarrow> left2[nat x := o3] ! nat y < z \<and> z < y \<longrightarrow> s ! nat y \<le> s ! nat z)))))))) \<and> ((\<forall>(z :: int). z \<in> set my_stack \<longrightarrow> (0 :: int) \<le> z \<and> z < o1 + (1 :: int)) \<and> (is_Nil my_stack \<longrightarrow> o1 + (1 :: int) = (0 :: int)) \<and> (\<not>is_Nil my_stack \<longrightarrow> peek my_stack = o1 + (1 :: int) - (1 :: int)) \<and> sorted my_stack \<and> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < o1 + (1 :: int) \<longrightarrow> left2 ! nat y < y) \<and> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < o1 + (1 :: int) \<longrightarrow> (0 :: int) \<le> left2 ! nat y \<longrightarrow> s ! nat (left2 ! nat y) < s ! nat y) \<and> (\<forall>(z :: int). (0 :: int) \<le> z \<and> z < o1 + (1 :: int) \<longrightarrow> (\<exists>(y :: int). (z \<le> y \<and> y < o1 + (1 :: int)) \<and> y \<in> set my_stack \<and> s ! nat y \<le> s ! nat z)) \<and> (\<forall>(y :: int) (z :: int). (0 :: int) \<le> y \<and> y < o1 + (1 :: int) \<longrightarrow> left2 ! nat y < z \<and> z < y \<longrightarrow> s ! nat y \<le> s ! nat z) \<longrightarrow> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < int (length s) \<longrightarrow> left2 ! nat y < y) \<and> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < int (length s) \<longrightarrow> (0 :: int) \<le> left2 ! nat y \<longrightarrow> s ! nat (left2 ! nat y) < s ! nat y) \<and> (\<forall>(x :: int) (z :: int). (0 :: int) \<le> x \<and> x < int (length s) \<longrightarrow> left2 ! nat x < z \<and> z < x \<longrightarrow> s ! nat x \<le> s ! nat z) \<and> length left2 = length s))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < int (length s) \<longrightarrow> left1 ! nat y < y) \<and> (\<forall>(y :: int). (0 :: int) \<le> y \<and> y < int (length s) \<longrightarrow> (0 :: int) \<le> left1 ! nat y \<longrightarrow> s ! nat (left1 ! nat y) < s ! nat y) \<and> (\<forall>(x :: int) (z :: int). (0 :: int) \<le> x \<and> x < int (length s) \<longrightarrow> left1 ! nat x < z \<and> z < x \<longrightarrow> s ! nat x \<le> s ! nat z) \<and> length left1 = length s)))"
  sorry
end
