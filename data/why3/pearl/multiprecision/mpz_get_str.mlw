module Zget_str

use int.Int
use int.EuclideanDivision
use int.Power
use mach.int.Int32
use mach.int.UInt32
use mach.int.Int32GMP
use ref.Ref
use mach.c.C
use mach.c.UChar
use lemmas.Lemmas
use import mach.int.UInt64GMP as Limb
use types.Types
use types.Int32Eq
use types.UInt64Eq
use int.Abs
use util.Util
use mpz.Z
use mpz.Zutil
use string.Char
use mach.c.String
use array.Array
use map.Map
use base_info.BaseInfo
use stringlemmas.String_lemmas
use stringlemmas.Conversions
use stringlemmas.String_value
use get_str.Get_str

function effective (b:int) : int
  = if (abs b < 2) then 10 else abs b

let ghost pow_mon_strict (b x y:int) : unit
  requires { 0 < b }
  requires { 0 <= x /\ 0 <= y }
  requires { 0 <= power b x < power b y }
  ensures  { x < y }
= ()

let ghost pow_mon (b x y:int) : unit
  requires { 1 < b }
  requires { 0 <= x /\ 0 <= y }
  requires { 0 <= power b x <= power b y }
  ensures  { x <= y }
= ()

let partial wmpz_get_str (sp: ptr char) (ghost sz:int32)
                 (base:int32) (u: mpz_ptr) : ptr char
  requires { valid sp sz }
  requires { writable sp }
  requires { 2 <= sz }
  requires { mpz.abs_value_of[u] < power (effective base) (sz-2) }
  requires { mpz.readers[u] = 0 }
  requires { 64 * mpz.abs_size[u] + 7 <= max_int32 }
  requires { -36 <= base <= 62 }
  ensures { result = sp }
  ensures { valid_string sp }
  ensures { string_in_base (effective base) (pelts sp) (offset sp) }
  ensures { forall x. mpz_unchanged x mpz (old mpz) }
  ensures { value_text (effective base) (pelts sp) (offset sp)
            = value_of u mpz }

=
  label Start in
  let ghost ob = base in
  let digits = begin ensures { base < 0 -> result = numupstring }
                     ensures { 0 <= base <= 36 -> result = numlowstring }
                     ensures { 36 < base -> result = numuplowstring }
                     ensures { effective base <= String.length result }
    if base > 36
    then "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    else if base >= 0
    then "0123456789abcdefghijklmnopqrstuvwxyz"
    else "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" end in
  let ref base = base in
  begin ensures { base = effective ob }
    if base <= 0 then base <- - base;
    if base <= 1 then base <- 10;
  end;
  let un = abs_size_of u in
  if un = 0
  then begin
    C.set_ofs sp 0 zero_num;
    C.set_ofs sp 1 zero_char;
    return sp
  end;
  let ref i : int32 = 0 in
  let ref sn : int32 = 0 in
  if size_of u < 0
  then begin
    C.set_ofs sp 0 minus_char;
    i <- i+1
  end;
  let bits = wmpn_base_power_of_two_p (Limb.of_int32 base) in
  let up = get_read_ptr u in
  label Open in
  let usp, ghost mem = open_from_charptr sp in
  let ghost ousp = pure { usp } in
  let uspi = C.incr usp i in
  if (bits <> 0)
  then begin
    let ghost um = C.get_ofs up (un - 1) in
    let (ghost sb) = wmpn_limb_size_in_base_2 um in
    let ghost ub = 64 * (un - 1) + (Limb.to_int32 sb) in
    let g = wmpn_get_str_bits uspi bits up un ub in
    sn <- i + UInt32.to_int32 g;
  end else begin
    let info = wmpn_get_base_info (Limb.of_int32 base) in
    let tp = salloc (UInt32.of_int32 un) in
    wmpn_copyd_sep tp up un;
    let g = wmpn_get_str_other uspi (sz - i) base info tp un in
    sn <- i + UInt32.to_int32 g;
  end;
  let ghost ousp = pure { usp } in
  close_from_charptr sp usp mem;
  label Conv in
  for j = i to sn - 1 do
    invariant { i <= j <= sn }
    invariant { forall k. offset sp + j <= offset sp + k < offset sp + sn ->
                (pelts sp)[offset sp + k] = (pelts sp at Conv)[offset sp + k] }
    invariant { 0 <= ob <= 36 ->
                to_lowercase_text (pelts ousp) (pelts sp)
                                  (offset sp) (offset sp + j) }
    invariant { 36 < ob ->
                to_bothcase_text (pelts ousp) (pelts sp)
                                  (offset sp) (offset sp + j) }
    invariant { ob < 0 ->
                to_uppercase_text (pelts ousp) (pelts sp)
                                  (offset sp) (offset sp + j) }
    invariant { abs_value_sub_text base (pelts sp)
                                        (offset sp + i) (offset sp + j)
                = svalue_sub base (pelts ousp) (offset ousp + i)
                                               (offset ousp + j) }
    invariant { forall k. offset sp <= k < offset sp + j
                -> code (pelts sp)[k] <> 0 }
    invariant { text_in_base base (pelts sp) (offset sp + i) (offset sp + j) }
    invariant { i = 1 -> (pelts sp)[offset sp] = minus_char }
    invariant { i = 0 -> j > i -> (pelts sp)[offset sp] <> minus_char }
    label L in
    let ghost osp = pure { sp } in
    let cj = UChar.of_char (C.get_ofs sp j) in
    let dc = String.get digits (UChar.to_int32 cj) in
    C.set_ofs sp j dc;
  done;
  let ghost osp = pure { sp } in
  C.set_ofs sp sn zero_char;
  release_reader u up;
  return sp

end
