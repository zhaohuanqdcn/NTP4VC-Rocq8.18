theory div_Div_wmpn_divrem_2qtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/mul_Mul"
begin
definition reciprocal :: "64 word \<Rightarrow> 64 word \<Rightarrow> _"
  where "reciprocal v d \<longleftrightarrow> uint v = (((18446744073709551615 :: int) + (1 :: int)) * ((18446744073709551615 :: int) + (1 :: int)) - (1 :: int)) ediv uint d - ((18446744073709551615 :: int) + (1 :: int))" for v d
definition reciprocal_3by2 :: "64 word \<Rightarrow> 64 word \<Rightarrow> 64 word \<Rightarrow> _"
  where "reciprocal_3by2 v dh dl \<longleftrightarrow> uint v = (((18446744073709551615 :: int) + (1 :: int)) * ((18446744073709551615 :: int) + (1 :: int)) * ((18446744073709551615 :: int) + (1 :: int)) - (1 :: int)) ediv (uint dl + ((18446744073709551615 :: int) + (1 :: int)) * uint dh) - ((18446744073709551615 :: int) + (1 :: int))" for v dh dl
definition normalized :: "64 word ptr \<Rightarrow> 32 word \<Rightarrow> _"
  where "normalized x sz \<longleftrightarrow> valid x (sint sz) \<and> ((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint (pelts x (offset x + sint sz - (1 :: int)))" for x sz
theorem wmpn_divrem_2'vc:
  fixes sx :: "32 word"
  fixes x :: "64 word ptr"
  fixes y :: "64 word ptr"
  fixes q :: "64 word ptr"
  assumes fact0: "(2 :: int) \<le> sint sx"
  assumes fact1: "valid x (sint sx)"
  assumes fact2: "valid y (2 :: int)"
  assumes fact3: "valid q (sint sx - (2 :: int))"
  assumes fact4: "((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint (pelts y (offset y + (1 :: int)))"
  assumes fact5: "writable q = True"
  assumes fact6: "writable x = True"
  shows "int'32_in_bounds (sint sx - (2 :: int))"
  and "\<forall>(o1 :: 32 word). sint o1 = sint sx - (2 :: int) \<longrightarrow> (c_C.min x \<le> offset x + sint o1 \<and> offset x + sint o1 \<le> c_C.max x) \<and> (\<forall>(o2 :: 64 word ptr). offset o2 = offset x + sint o1 \<and> plength o2 = plength x \<and> pelts o2 = pelts x \<and> data o2 = data x \<and> c_C.min o2 = c_C.min x \<and> c_C.max o2 = c_C.max x \<and> zone1 o2 = zone1 x \<and> writable o2 = writable x \<longrightarrow> (c_C.min y \<le> offset y + (1 :: int) \<and> offset y + (1 :: int) < c_C.max y) \<and> (let dh :: 64 word = pelts y (offset y + (1 :: int)) in (c_C.min y \<le> offset y \<and> offset y < c_C.max y) \<and> (let dl :: 64 word = pelts y (offset y) in (c_C.min o2 \<le> offset o2 + (1 :: int) \<and> offset o2 + (1 :: int) < c_C.max o2) \<and> (let o3 :: 64 word = pelts o2 (offset o2 + (1 :: int)) in (c_C.min o2 \<le> offset o2 \<and> offset o2 < c_C.max o2) \<and> (let o4 :: 64 word = pelts o2 (offset o2) in int'32_in_bounds (sint sx - (2 :: int)) \<and> (\<forall>(o5 :: 32 word). sint o5 = sint sx - (2 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint dh \<and> (\<forall>(dinv :: 64 word). reciprocal_3by2 dinv dh dl \<longrightarrow> ((if uint dh \<le> uint o3 then if uint dh < uint o3 then True else True = (if uint dl \<le> uint o4 then True else False) else True = False) \<longrightarrow> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (1 :: int)) \<and> (\<forall>(r0 :: 64 word) (b :: 64 word). uint r0 - ((18446744073709551615 :: int) + (1 :: int)) * uint b = uint o4 - uint dl - (0 :: int) \<and> (0 :: int) \<le> uint b \<and> uint b \<le> (1 :: int) \<longrightarrow> (0 :: int) \<le> uint b \<and> uint b \<le> (1 :: int))) \<and> (\<forall>(rh :: 64 word) (rl :: 64 word) (qh :: 64 word). (\<exists>(o6 :: bool). (if uint dh \<le> uint o3 then if uint dh < uint o3 then o6 = True else o6 = (if uint dl \<le> uint o4 then True else False) else o6 = False) \<and> (if o6 = True then \<exists>(d :: 64 word). (uint rl - ((18446744073709551615 :: int) + (1 :: int)) * uint d = uint o4 - uint dl - (0 :: int) \<and> (0 :: int) \<le> uint d \<and> uint d \<le> (1 :: int)) \<and> (\<exists>(d1 :: 64 word). (uint rh - ((18446744073709551615 :: int) + (1 :: int)) * uint d1 = uint o3 - uint dh - uint d \<and> (0 :: int) \<le> uint d1 \<and> uint d1 \<le> (1 :: int)) \<and> qh = (1 :: 64 word)) else (rh = o3 \<and> rl = o4) \<and> qh = (0 :: 64 word))) \<longrightarrow> (((0 :: int) \<le> sint o5 \<and> sint o5 \<le> sint sx - (2 :: int)) \<and> offset o2 = offset x + sint o5 \<and> plength o2 = plength x \<and> c_C.min o2 = c_C.min x \<and> c_C.max o2 = c_C.max x \<and> pelts o2 = pelts x \<and> writable o2 = True \<and> value x (sint sx) = (value_sub (pelts q) (offset q + sint o5) (offset q + sint sx - (2 :: int)) + uint qh * ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint sx - (2 :: int) - sint o5)) * value y (2 :: int) * ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o5 + value x (sint o5) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o5 * (uint rl + ((18446744073709551615 :: int) + (1 :: int)) * uint rh) \<and> uint rl + ((18446744073709551615 :: int) + (1 :: int)) * uint rh < uint dl + ((18446744073709551615 :: int) + (1 :: int)) * uint dh) \<and> (\<forall>(i :: 32 word) (rl1 :: 64 word) (rh1 :: 64 word) (xp :: 64 word ptr) (q1 :: 64 word ptr). length (data q1) = length (data q) \<and> offset q1 = offset q \<and> c_C.min q1 = c_C.min q \<and> c_C.max q1 = c_C.max q \<and> writable q1 = writable q \<and> zone1 q1 = zone1 q \<longrightarrow> ((0 :: int) \<le> sint i \<and> sint i \<le> sint sx - (2 :: int)) \<and> offset xp = offset x + sint i \<and> plength xp = plength x \<and> c_C.min xp = c_C.min x \<and> c_C.max xp = c_C.max x \<and> pelts xp = pelts x \<and> writable xp = True \<and> value x (sint sx) = (value_sub (pelts q1) (offset q1 + sint i) (offset q1 + sint sx - (2 :: int)) + uint qh * ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint sx - (2 :: int) - sint i)) * value y (2 :: int) * ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint i + value x (sint i) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint i * (uint rl1 + ((18446744073709551615 :: int) + (1 :: int)) * uint rh1) \<and> uint rl1 + ((18446744073709551615 :: int) + (1 :: int)) * uint rh1 < uint dl + ((18446744073709551615 :: int) + (1 :: int)) * uint dh \<longrightarrow> (if (0 :: int) < sint i then (c_C.min xp \<le> offset xp + -(1 :: int) \<and> offset xp + -(1 :: int) \<le> c_C.max xp) \<and> (\<forall>(o6 :: 64 word ptr). offset o6 = offset xp + -(1 :: int) \<and> plength o6 = plength xp \<and> pelts o6 = pelts xp \<and> data o6 = data xp \<and> c_C.min o6 = c_C.min xp \<and> c_C.max o6 = c_C.max xp \<and> zone1 o6 = zone1 xp \<and> writable o6 = writable xp \<longrightarrow> (c_C.min o6 \<le> offset o6 \<and> offset o6 < c_C.max o6) \<and> (((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint dh \<and> reciprocal_3by2 dinv dh dl \<and> uint rl1 + ((18446744073709551615 :: int) + (1 :: int)) * uint rh1 < uint dl + ((18446744073709551615 :: int) + (1 :: int)) * uint dh) \<and> (\<forall>(qu :: 64 word) (r0 :: 64 word) (r1 :: 64 word). uint qu * uint dl + ((18446744073709551615 :: int) + (1 :: int)) * uint qu * uint dh + uint r0 + ((18446744073709551615 :: int) + (1 :: int)) * uint r1 = uint (pelts o6 (offset o6)) + ((18446744073709551615 :: int) + (1 :: int)) * uint rl1 + ((18446744073709551615 :: int) + (1 :: int)) * ((18446744073709551615 :: int) + (1 :: int)) * uint rh1 \<and> (0 :: int) \<le> uint r0 + ((18446744073709551615 :: int) + (1 :: int)) * uint r1 \<and> uint r0 + ((18446744073709551615 :: int) + (1 :: int)) * uint r1 < uint dl + ((18446744073709551615 :: int) + (1 :: int)) * uint dh \<longrightarrow> int'32_in_bounds (sint i - (1 :: int)) \<and> (\<forall>(o7 :: 32 word). sint o7 = sint i - (1 :: int) \<longrightarrow> ((c_C.min q1 \<le> offset q1 + sint o7 \<and> offset q1 + sint o7 < c_C.max q1) \<and> writable q1 = True) \<and> (\<forall>(q2 :: 64 word ptr). length (data q2) = length (data q1) \<and> offset q2 = offset q1 \<and> c_C.min q2 = c_C.min q1 \<and> c_C.max q2 = c_C.max q1 \<and> writable q2 = writable q1 \<and> zone1 q2 = zone1 q1 \<longrightarrow> pelts q2 = (pelts q1)(offset q2 + sint o7 := qu) \<and> pelts q2 (offset q2 + sint o7) = qu \<longrightarrow> sint o7 < sint i \<and> ((0 :: int) \<le> sint o7 \<and> sint o7 \<le> sint sx - (2 :: int)) \<and> offset o6 = offset x + sint o7 \<and> plength o6 = plength x \<and> c_C.min o6 = c_C.min x \<and> c_C.max o6 = c_C.max x \<and> pelts o6 = pelts x \<and> writable o6 = True \<and> value x (sint sx) = (value_sub (pelts q2) (offset q2 + sint o7) (offset q2 + sint sx - (2 :: int)) + uint qh * ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint sx - (2 :: int) - sint o7)) * value y (2 :: int) * ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o7 + value x (sint o7) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o7 * (uint r0 + ((18446744073709551615 :: int) + (1 :: int)) * uint r1) \<and> uint r0 + ((18446744073709551615 :: int) + (1 :: int)) * uint r1 < uint dl + ((18446744073709551615 :: int) + (1 :: int)) * uint dh)))) else ((c_C.min x \<le> offset x + (1 :: int) \<and> offset x + (1 :: int) < c_C.max x) \<and> writable x = True) \<and> (\<forall>(x1 :: 64 word ptr). length (data x1) = length (data x) \<and> offset x1 = offset x \<and> c_C.min x1 = c_C.min x \<and> c_C.max x1 = c_C.max x \<and> writable x1 = writable x \<and> zone1 x1 = zone1 x \<longrightarrow> pelts x1 = (pelts x)(offset x1 + (1 :: int) := rh1) \<and> pelts x1 (offset x1 + (1 :: int)) = rh1 \<longrightarrow> ((c_C.min x1 \<le> offset x1 \<and> offset x1 < c_C.max x1) \<and> writable x1 = True) \<and> (\<forall>(x2 :: 64 word ptr). length (data x2) = length (data x1) \<and> offset x2 = offset x1 \<and> c_C.min x2 = c_C.min x1 \<and> c_C.max x2 = c_C.max x1 \<and> writable x2 = writable x1 \<and> zone1 x2 = zone1 x1 \<longrightarrow> pelts x2 = (pelts x1)(offset x2 := rl1) \<longrightarrow> value x (sint sx) = (value q1 (sint sx - (2 :: int)) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (sint sx - (2 :: int)) * uint qh) * value y (2 :: int) + value x2 (2 :: int) \<and> value x2 (2 :: int) < value y (2 :: int) \<and> (0 :: int) \<le> uint qh \<and> uint qh \<le> (1 :: int)))))))))))))"
  sorry
end
