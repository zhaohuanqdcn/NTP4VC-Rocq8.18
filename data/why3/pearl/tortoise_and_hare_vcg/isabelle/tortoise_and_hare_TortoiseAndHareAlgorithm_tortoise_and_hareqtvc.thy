theory tortoise_and_hare_TortoiseAndHareAlgorithm_tortoise_and_hareqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_Iter" "Why3STD.pigeon_Pigeonhole"
begin
consts f :: "int \<Rightarrow> int"
consts m :: "int"
axiomatization where m_positive:   "(0 :: int) < m"
axiomatization where f_range'0:   "(0 :: int) \<le> f x"
 if "(0 :: int) \<le> x"
 and "x < m"
  for x :: "int"
axiomatization where f_range'1:   "f x < m"
 if "(0 :: int) \<le> x"
 and "x < m"
  for x :: "int"
consts x0 :: "int"
axiomatization where x0'def'0:   "(0 :: int) \<le> x0"
axiomatization where x0'def'1:   "x0 < m"
consts f_closure :: "int \<Rightarrow> int"
axiomatization where f_closure_def:   "f_closure y = f y"
  for y :: "int"
definition x :: "int \<Rightarrow> int"
  where "x i = iter f_closure i x0" for i
theorem tortoise_and_hare'vc:
  fixes mu :: "int"
  fixes lambda :: "int"
  assumes fact0: "(0 :: int) \<le> mu"
  assumes fact1: "mu < m"
  assumes fact2: "(1 :: int) \<le> lambda"
  assumes fact3: "lambda \<le> m"
  assumes fact4: "mu + lambda \<le> m"
  assumes fact5: "x (mu + lambda) = x mu"
  assumes fact6: "\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < j \<and> j < mu + lambda \<longrightarrow> \<not>x i = x j"
  shows "(1 :: int) \<le> (1 :: int)"
  and "(1 :: int) \<le> mu + lambda"
  and "f x0 = x (1 :: int)"
  and "f (f x0) = x ((2 :: int) * (1 :: int))"
  and "\<forall>(i :: int). (1 :: int) \<le> i \<and> i < (1 :: int) \<longrightarrow> \<not>x i = x ((2 :: int) * i)"
  and "\<forall>(n :: int). ((1 :: int) \<le> n \<and> n \<le> mu + lambda) \<and> (\<forall>(i :: int). (1 :: int) \<le> i \<and> i < n \<longrightarrow> \<not>x i = x ((2 :: int) * i)) \<longrightarrow> (if \<not>x n = x ((2 :: int) * n) then \<not>mu + lambda < n + (1 :: int) \<and> (\<not>mu + lambda < n + (1 :: int) \<longrightarrow> ((0 :: int) \<le> mu + lambda - n \<and> mu + lambda - (n + (1 :: int)) < mu + lambda - n) \<and> ((1 :: int) \<le> n + (1 :: int) \<and> n + (1 :: int) \<le> mu + lambda) \<and> f (x n) = x (n + (1 :: int)) \<and> f (f (x ((2 :: int) * n))) = x ((2 :: int) * (n + (1 :: int))) \<and> (\<forall>(i :: int). (1 :: int) \<le> i \<and> i < n + (1 :: int) \<longrightarrow> \<not>x i = x ((2 :: int) * i))) else (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> mu) \<and> (x0 = x (0 :: int) \<and> x n = x (n + (0 :: int))) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> \<not>x j = x (n + j)) \<and> (\<forall>(j :: int). (0 :: int) < j \<and> j < (0 :: int) \<longrightarrow> \<not>x (n + j) = x n)) \<and> (\<forall>(lam :: int) (i :: int). ((0 :: int) \<le> i \<and> i \<le> mu) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> \<not>x j = x (n + j)) \<and> (if lam = (0 :: int) then \<forall>(j :: int). (0 :: int) < j \<and> j < i \<longrightarrow> \<not>x (n + j) = x n else lam = lambda) \<longrightarrow> (if \<not>x i = x (n + i) then \<forall>(o1 :: bool). (if lam = (0 :: int) then o1 = (if (0 :: int) < i then if x (n + i) = x n then True else False else False) else o1 = False) \<longrightarrow> (if o1 = True then ((0 :: int) \<le> mu - i \<and> mu - (i + (1 :: int)) < mu - i) \<and> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> mu) \<and> (f (x i) = x (i + (1 :: int)) \<and> f (x (n + i)) = x (n + (i + (1 :: int)))) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> \<not>x j = x (n + j)) \<and> (if i = (0 :: int) then \<forall>(j :: int). (0 :: int) < j \<and> j < i + (1 :: int) \<longrightarrow> \<not>x (n + j) = x n else i = lambda) else ((0 :: int) \<le> mu - i \<and> mu - (i + (1 :: int)) < mu - i) \<and> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> mu) \<and> (f (x i) = x (i + (1 :: int)) \<and> f (x (n + i)) = x (n + (i + (1 :: int)))) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> \<not>x j = x (n + j)) \<and> (if lam = (0 :: int) then \<forall>(j :: int). (0 :: int) < j \<and> j < i + (1 :: int) \<longrightarrow> \<not>x (n + j) = x n else lam = lambda)) else \<forall>(l :: int). (if lam = (0 :: int) then l = n else l = lam) \<longrightarrow> (((0 :: int) \<le> i \<and> i < m) \<and> ((1 :: int) \<le> l \<and> l \<le> m) \<and> i + l \<le> m \<and> x (i + l) = x i) \<and> (\<forall>(i1 :: int) (j :: int). (0 :: int) \<le> i1 \<and> i1 < j \<and> j < i + l \<longrightarrow> \<not>x i1 = x j))))"
  sorry
end
