theory get_str_Get_str_wmpn_get_str_otherqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "mach.c_UChar" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/powm_Powm" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/sub_1_Sub_1" "../../lib/isabelle/stringlemmas_String_lemmas" "../../lib/isabelle/base_info_BaseInfo"
begin
theorem wmpn_get_str_other'vc:
  fixes up :: "64 word ptr"
  fixes un :: "32 word"
  fixes info :: "wmpn_base_info"
  fixes base :: "32 word"
  fixes sp :: "8 word ptr"
  fixes sz :: "32 word"
  assumes fact0: "valid up (sint un)"
  assumes fact1: "(1 :: int) \<le> sint un"
  assumes fact2: "b info = sint base"
  assumes fact3: "writable up = True"
  assumes fact4: "writable sp = True"
  assumes fact5: "(0 :: int) < uint (pelts up (offset up + sint un - (1 :: int)))"
  assumes fact6: "(0 :: int) < sint sz"
  assumes fact7: "valid sp (sint sz)"
  assumes fact8: "value up (sint un) < sint base ^\<^sub>i (sint sz - (1 :: int))"
  shows "(0 :: int) \<le> sint base"
  and "\<forall>(o1 :: 64 word). uint o1 = sint base \<longrightarrow> (0 :: int) < uint o1 \<and> (\<forall>(o2 :: 32 word). (2 :: int) ^\<^sub>i sint o2 * uint o1 \<le> (18446744073709551615 :: int) \<and> (18446744073709551615 :: int) < (2 :: int) * (2 :: int) ^\<^sub>i sint o2 * uint o1 \<and> (0 :: int) \<le> sint o2 \<and> sint o2 < (64 :: int) \<longrightarrow> (0 :: int) \<le> sint o2 \<and> (\<forall>(shift :: 64 word). uint shift = sint o2 \<longrightarrow> (0 :: int) \<le> sint base \<and> (\<forall>(o3 :: 64 word). uint o3 = sint base \<longrightarrow> (((0 :: int) \<le> uint shift \<and> uint shift < (64 :: int)) \<and> (2 :: int) ^\<^sub>i uint shift * uint o3 \<le> (18446744073709551615 :: int)) \<and> (\<forall>(d1 :: 64 word). uint d1 = (2 :: int) ^\<^sub>i uint shift * uint o3 \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint d1 \<and> (\<forall>(di :: 64 word). reciprocal di d1 \<longrightarrow> (let vu :: int = value up (sint un) in (if (1 :: int) < sint un then (0 :: int) \<le> sint un \<and> (\<forall>(o4 :: 32 word). uint o4 = sint un \<longrightarrow> (0 :: int) \<le> uint o4 \<and> (\<forall>(tp :: 64 word ptr). plength tp = uint o4 \<and> offset tp = (0 :: int) \<and> c_C.min tp = (0 :: int) \<and> c_C.max tp = uint o4 \<and> writable tp = True \<longrightarrow> (svalue_le (sint base) sp (0 :: int) + sint base ^\<^sub>i (0 :: int) * value up (sint un) = vu \<and> ((1 :: int) \<le> sint un \<and> sint un \<le> sint un) \<and> sint un - sint un \<le> (0 :: int) \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < sint sz) \<and> (0 :: int) = (0 :: int) * uint (base_info_BaseInfo.exp info) \<and> in_base (sint base) (pelts sp) (offset sp) (offset sp + (0 :: int)) \<and> (0 :: int) < uint (pelts up (offset up + sint un - (1 :: int)))) \<and> (\<forall>(loopi :: int) (tp1 :: 64 word ptr) (n :: 32 word) (sn :: 32 word) (up1 :: 64 word ptr) (sp1 :: 8 word ptr). length (data tp1) = length (data tp) \<and> offset tp1 = offset tp \<and> c_C.min tp1 = c_C.min tp \<and> c_C.max tp1 = c_C.max tp \<and> writable tp1 = writable tp \<and> zone1 tp1 = zone1 tp \<longrightarrow> length (data up1) = length (data up) \<and> offset up1 = offset up \<and> c_C.min up1 = c_C.min up \<and> c_C.max up1 = c_C.max up \<and> writable up1 = writable up \<and> zone1 up1 = zone1 up \<longrightarrow> length (data sp1) = length (data sp) \<and> offset sp1 = offset sp \<and> c_C.min sp1 = c_C.min sp \<and> c_C.max sp1 = c_C.max sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> svalue_le (sint base) sp1 (sint sn) + sint base ^\<^sub>i sint sn * value up1 (sint n) = vu \<and> ((1 :: int) \<le> sint n \<and> sint n \<le> sint un) \<and> sint un - sint n \<le> loopi \<and> ((0 :: int) \<le> sint sn \<and> sint sn < sint sz) \<and> sint sn = loopi * uint (base_info_BaseInfo.exp info) \<and> in_base (sint base) (pelts sp1) (offset sp1) (offset sp1 + sint sn) \<and> (0 :: int) < uint (pelts up1 (offset up1 + sint n - (1 :: int))) \<and> (\<forall>(j :: int). j < offset sp1 \<or> offset sp1 + sint sz \<le> j \<longrightarrow> pelts sp1 j = pelts sp j) \<longrightarrow> (if (1 :: int) < sint n then let o5 :: 64 word = bb info in (valid up1 (sint n) \<and> valid tp1 (sint n) \<and> writable tp1 = True \<and> (0 :: int) < sint n \<and> (0 :: int) < uint o5) \<and> (\<forall>(tp2 :: 64 word ptr). length (data tp2) = length (data tp1) \<and> offset tp2 = offset tp1 \<and> c_C.min tp2 = c_C.min tp1 \<and> c_C.max tp2 = c_C.max tp1 \<and> writable tp2 = writable tp1 \<and> zone1 tp2 = zone1 tp1 \<longrightarrow> (\<forall>(o6 :: 64 word). value up1 (sint n) = value tp2 (sint n) * uint o5 + uint o6 \<and> uint o6 < uint o5 \<longrightarrow> (valid tp2 (sint n) \<and> valid up1 (sint n) \<and> writable up1 = True) \<and> (\<forall>(up2 :: 64 word ptr). length (data up2) = length (data up1) \<and> offset up2 = offset up1 \<and> c_C.min up2 = c_C.min up1 \<and> c_C.max up2 = c_C.max up1 \<and> writable up2 = writable up1 \<and> zone1 up2 = zone1 up1 \<longrightarrow> map_eq_sub_shift (pelts up2) (pelts tp2) (offset up2) (offset tp2) (sint n) \<and> (\<forall>(j :: int). j < offset up2 \<or> offset up2 + sint n \<le> j \<longrightarrow> pelts up2 j = pelts up1 j) \<longrightarrow> int'32_in_bounds (sint n - (1 :: int)) \<and> (\<forall>(o7 :: 32 word). sint o7 = sint n - (1 :: int) \<longrightarrow> (c_C.min up2 \<le> offset up2 + sint o7 \<and> offset up2 + sint o7 < c_C.max up2) \<and> (let o8 :: 64 word = pelts up2 (offset up2 + sint o7) in \<forall>(o9 :: bool). (uint o8 = uint (0 :: 64 word) \<longrightarrow> o9 = True) \<and> (o9 = True \<longrightarrow> o8 = (0 :: 64 word)) \<longrightarrow> (\<forall>(o10 :: 32 word). (if o9 = True then o10 = (1 :: 32 word) else o10 = (0 :: 32 word)) \<longrightarrow> int'32_in_bounds (sint n - sint o10) \<and> (\<forall>(o11 :: 32 word). sint o11 = sint n - sint o10 \<longrightarrow> (c_C.min sp1 \<le> offset sp1 + sint sn \<and> offset sp1 + sint sn \<le> c_C.max sp1) \<and> (\<forall>(spn :: 8 word ptr). offset spn = offset sp1 + sint sn \<and> plength spn = plength sp1 \<and> pelts spn = pelts sp1 \<and> data spn = data sp1 \<and> c_C.min spn = c_C.min sp1 \<and> c_C.max spn = c_C.max sp1 \<and> zone1 spn = zone1 sp1 \<and> writable spn = writable sp1 \<longrightarrow> (let o12 :: 32 word = base_info_BaseInfo.exp info in uint o12 \<le> (2147483647 :: int) \<and> (\<forall>(o13 :: 32 word). sint o13 = uint o12 \<longrightarrow> int'32_in_bounds (sint o13 + (1 :: int)) \<and> (\<forall>(o14 :: 32 word). sint o14 = sint o13 + (1 :: int) \<longrightarrow> (((2 :: int) \<le> b info \<and> b info \<le> (256 :: int)) \<and> writable spn = True \<and> ((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint d1 \<and> ((0 :: int) \<le> uint shift \<and> uint shift \<le> (63 :: int)) \<and> b info * (2 :: int) ^\<^sub>i uint shift = uint d1 \<and> reciprocal di d1 \<and> valid spn (sint o14) \<and> (0 :: int) < sint o14 \<and> uint o6 < b info ^\<^sub>i sint o14) \<and> (\<forall>(spn1 :: 8 word ptr) (sp2 :: 8 word ptr). data spn1 = data sp2 \<and> length (data sp2) = length (data spn) \<and> offset spn1 = offset spn \<and> c_C.min spn1 = c_C.min spn \<and> c_C.max spn1 = c_C.max spn \<and> writable spn1 = writable spn \<and> zone1 spn1 = zone1 spn \<longrightarrow> length (data sp2) = length (data sp1) \<and> offset sp2 = offset sp1 \<and> c_C.min sp2 = c_C.min sp1 \<and> c_C.max sp2 = c_C.max sp1 \<and> writable sp2 = writable sp1 \<and> zone1 sp2 = zone1 sp1 \<longrightarrow> (\<forall>(o15 :: 32 word). svalue_le (b info) spn1 (uint o15) = uint o6 \<and> ((0 :: int) \<le> uint o15 \<and> uint o15 \<le> sint o14) \<and> ((0 :: int) < uint o15 \<longrightarrow> (0 :: int) < uint (pelts spn1 (offset spn1 + uint o15 - (1 :: int)))) \<and> (\<forall>(i :: int). i < offset spn1 \<or> offset spn1 + uint o15 \<le> i \<longrightarrow> pelts spn1 i = pelts spn i) \<and> in_base (b info) (pelts spn1) (offset spn1) (offset spn1 + uint o15) \<longrightarrow> uint o15 \<le> (2147483647 :: int) \<and> (\<forall>(o16 :: 32 word). sint o16 = uint o15 \<longrightarrow> int'32_in_bounds (sint sn + sint o16) \<and> (\<forall>(o17 :: 32 word). sint o17 = sint sn + sint o16 \<longrightarrow> (uint o15 \<le> uint (base_info_BaseInfo.exp info) \<and> sint o17 = sint sn + uint o15 \<and> in_base (sint base) (pelts sp2) (offset sp2) (offset sp2 + sint o17) \<and> svalue_le (sint base) sp2 (sint o17) + sint base ^\<^sub>i (sint o17 - uint o15 + uint (base_info_BaseInfo.exp info)) * value up2 (sint o11) = vu \<and> (\<forall>(j :: int). j < offset sp2 \<or> offset sp2 + sint sz \<le> j \<longrightarrow> pelts sp2 j = pelts sp j)) \<and> (\<forall>(sdone :: 32 word) (sn1 :: 32 word) (sp3 :: 8 word ptr). length (data sp3) = length (data sp2) \<and> offset sp3 = offset sp2 \<and> c_C.min sp3 = c_C.min sp2 \<and> c_C.max sp3 = c_C.max sp2 \<and> writable sp3 = writable sp2 \<and> zone1 sp3 = zone1 sp2 \<longrightarrow> uint sdone \<le> uint (base_info_BaseInfo.exp info) \<and> sint sn1 = sint sn + uint sdone \<and> in_base (sint base) (pelts sp3) (offset sp3) (offset sp3 + sint sn1) \<and> svalue_le (sint base) sp3 (sint sn1) + sint base ^\<^sub>i (sint sn1 - uint sdone + uint (base_info_BaseInfo.exp info)) * value up2 (sint o11) = vu \<and> (\<forall>(j :: int). j < offset sp3 \<or> offset sp3 + sint sz \<le> j \<longrightarrow> pelts sp3 j = pelts sp j) \<longrightarrow> (if uint sdone < uint (base_info_BaseInfo.exp info) then ((c_C.min sp3 \<le> offset sp3 + sint sn1 \<and> offset sp3 + sint sn1 < c_C.max sp3) \<and> writable sp3 = True) \<and> (\<forall>(sp4 :: 8 word ptr). length (data sp4) = length (data sp3) \<and> offset sp4 = offset sp3 \<and> c_C.min sp4 = c_C.min sp3 \<and> c_C.max sp4 = c_C.max sp3 \<and> writable sp4 = writable sp3 \<and> zone1 sp4 = zone1 sp3 \<longrightarrow> pelts sp4 = (pelts sp3)(offset sp4 + sint sn1 := 0 :: 8 word) \<and> pelts sp4 (offset sp4 + sint sn1) = (0 :: 8 word) \<longrightarrow> int'32_in_bounds (sint sn1 + (1 :: int)) \<and> (\<forall>(o18 :: 32 word). sint o18 = sint sn1 + (1 :: int) \<longrightarrow> uint'32_in_bounds (uint sdone + (1 :: int)) \<and> (\<forall>(o19 :: 32 word). uint o19 = uint sdone + (1 :: int) \<longrightarrow> ((0 :: int) \<le> uint (base_info_BaseInfo.exp info) - uint sdone \<and> uint (base_info_BaseInfo.exp info) - uint o19 < uint (base_info_BaseInfo.exp info) - uint sdone) \<and> uint o19 \<le> uint (base_info_BaseInfo.exp info) \<and> sint o18 = sint sn + uint o19 \<and> in_base (sint base) (pelts sp4) (offset sp4) (offset sp4 + sint o18) \<and> svalue_le (sint base) sp4 (sint o18) + sint base ^\<^sub>i (sint o18 - uint o19 + uint (base_info_BaseInfo.exp info)) * value up2 (sint o11) = vu \<and> (\<forall>(j :: int). j < offset sp4 \<or> offset sp4 + sint sz \<le> j \<longrightarrow> pelts sp4 j = pelts sp j)))) else ((0 :: int) \<le> value up1 (sint n) \<and> value up2 (sint o11) < value up1 (sint n)) \<and> svalue_le (sint base) sp3 (sint sn1) + sint base ^\<^sub>i sint sn1 * value up2 (sint o11) = vu \<and> ((1 :: int) \<le> sint o11 \<and> sint o11 \<le> sint un) \<and> sint un - sint o11 \<le> loopi + (1 :: int) \<and> ((0 :: int) \<le> sint sn1 \<and> sint sn1 < sint sz) \<and> sint sn1 = (loopi + (1 :: int)) * uint (base_info_BaseInfo.exp info) \<and> in_base (sint base) (pelts sp3) (offset sp3) (offset sp3 + sint sn1) \<and> (0 :: int) < uint (pelts up2 (offset up2 + sint o11 - (1 :: int))) \<and> (\<forall>(j :: int). j < offset sp3 \<or> offset sp3 + sint sz \<le> j \<longrightarrow> pelts sp3 j = pelts sp j)))))))))))))))))) else svalue_le (sint base) sp1 (sint sn) + sint base ^\<^sub>i sint sn * value up1 (1 :: int) = vu \<and> in_base (sint base) (pelts sp1) (offset sp1) (offset sp1 + sint sn) \<and> ((0 :: int) \<le> sint sn \<and> sint sn < sint sz) \<and> (0 :: int) < value up1 (1 :: int) \<and> (\<forall>(j :: int). j < offset sp1 \<or> offset sp1 + sint sz \<le> j \<longrightarrow> pelts sp1 j = pelts sp j))))) else svalue_le (sint base) sp (0 :: int) + sint base ^\<^sub>i (0 :: int) * value up (1 :: int) = vu \<and> in_base (sint base) (pelts sp) (offset sp) (offset sp + (0 :: int)) \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < sint sz) \<and> (0 :: int) < value up (1 :: int)) \<and> (\<forall>(sn :: 32 word) (up1 :: 64 word ptr) (sp1 :: 8 word ptr). length (data up1) = length (data up) \<and> offset up1 = offset up \<and> c_C.min up1 = c_C.min up \<and> c_C.max up1 = c_C.max up \<and> writable up1 = writable up \<and> zone1 up1 = zone1 up \<longrightarrow> length (data sp1) = length (data sp) \<and> offset sp1 = offset sp \<and> c_C.min sp1 = c_C.min sp \<and> c_C.max sp1 = c_C.max sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> svalue_le (sint base) sp1 (sint sn) + sint base ^\<^sub>i sint sn * value up1 (1 :: int) = vu \<and> in_base (sint base) (pelts sp1) (offset sp1) (offset sp1 + sint sn) \<and> ((0 :: int) \<le> sint sn \<and> sint sn < sint sz) \<and> (0 :: int) < value up1 (1 :: int) \<and> (\<forall>(j :: int). j < offset sp1 \<or> offset sp1 + sint sz \<le> j \<longrightarrow> pelts sp1 j = pelts sp j) \<longrightarrow> (c_C.min up1 \<le> offset up1 \<and> offset up1 < c_C.max up1) \<and> (let o4 :: 64 word = pelts up1 (offset up1) in (c_C.min sp1 \<le> offset sp1 + sint sn \<and> offset sp1 + sint sn \<le> c_C.max sp1) \<and> (\<forall>(spn :: 8 word ptr). offset spn = offset sp1 + sint sn \<and> plength spn = plength sp1 \<and> pelts spn = pelts sp1 \<and> data spn = data sp1 \<and> c_C.min spn = c_C.min sp1 \<and> c_C.max spn = c_C.max sp1 \<and> zone1 spn = zone1 sp1 \<and> writable spn = writable sp1 \<longrightarrow> int'32_in_bounds (sint sz - (1 :: int)) \<and> (\<forall>(o5 :: 32 word). sint o5 = sint sz - (1 :: int) \<longrightarrow> int'32_in_bounds (sint o5 - sint sn) \<and> (\<forall>(o6 :: 32 word). sint o6 = sint o5 - sint sn \<longrightarrow> (((2 :: int) \<le> b info \<and> b info \<le> (256 :: int)) \<and> writable spn = True \<and> ((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint d1 \<and> ((0 :: int) \<le> uint shift \<and> uint shift \<le> (63 :: int)) \<and> b info * (2 :: int) ^\<^sub>i uint shift = uint d1 \<and> reciprocal di d1 \<and> valid spn (sint o6) \<and> (0 :: int) < sint o6 \<and> uint o4 < b info ^\<^sub>i sint o6) \<and> (\<forall>(spn1 :: 8 word ptr) (sp2 :: 8 word ptr). data spn1 = data sp2 \<and> length (data sp2) = length (data spn) \<and> offset spn1 = offset spn \<and> c_C.min spn1 = c_C.min spn \<and> c_C.max spn1 = c_C.max spn \<and> writable spn1 = writable spn \<and> zone1 spn1 = zone1 spn \<longrightarrow> length (data sp2) = length (data sp1) \<and> offset sp2 = offset sp1 \<and> c_C.min sp2 = c_C.min sp1 \<and> c_C.max sp2 = c_C.max sp1 \<and> writable sp2 = writable sp1 \<and> zone1 sp2 = zone1 sp1 \<longrightarrow> (\<forall>(sdone :: 32 word). svalue_le (b info) spn1 (uint sdone) = uint o4 \<and> ((0 :: int) \<le> uint sdone \<and> uint sdone \<le> sint o6) \<and> ((0 :: int) < uint sdone \<longrightarrow> (0 :: int) < uint (pelts spn1 (offset spn1 + uint sdone - (1 :: int)))) \<and> (\<forall>(i :: int). i < offset spn1 \<or> offset spn1 + uint sdone \<le> i \<longrightarrow> pelts spn1 i = pelts spn i) \<and> in_base (b info) (pelts spn1) (offset spn1) (offset spn1 + uint sdone) \<longrightarrow> uint sdone \<le> (2147483647 :: int) \<and> (\<forall>(o7 :: 32 word). sint o7 = uint sdone \<longrightarrow> int'32_in_bounds (sint sn + sint o7) \<and> (\<forall>(o8 :: 32 word). sint o8 = sint sn + sint o7 \<longrightarrow> (((0 :: int) \<le> (2 :: int) * (0 :: int) + (1 :: int) \<and> (2 :: int) * (0 :: int) + (1 :: int) \<le> sint o8 + (1 :: int)) \<and> in_base (sint base) (pelts sp2) (offset sp2) (offset sp2 + sint o8) \<and> svalue_sub (sint base) (pelts sp2) (offset sp2) (offset sp2 + (0 :: int)) = svalue_le_sub (sint base) (pelts sp2) (offset sp2 + sint o8 - (0 :: int)) (offset sp2 + sint o8) \<and> svalue_sub (sint base) (pelts sp2) (offset sp2 + sint o8 - (0 :: int)) (offset sp2 + sint o8) = svalue_le_sub (sint base) (pelts sp2) (offset sp2) (offset sp2 + (0 :: int)) \<and> ((0 :: int) < (0 :: int) \<longrightarrow> (0 :: int) < uint (pelts sp2 (offset sp2))) \<and> (\<forall>(j :: int). j < offset sp2 \<or> offset sp2 + sint sz \<le> j \<longrightarrow> pelts sp2 j = pelts sp j)) \<and> (\<forall>(i :: 32 word) (sp3 :: 8 word ptr). length (data sp3) = length (data sp2) \<and> offset sp3 = offset sp2 \<and> c_C.min sp3 = c_C.min sp2 \<and> c_C.max sp3 = c_C.max sp2 \<and> writable sp3 = writable sp2 \<and> zone1 sp3 = zone1 sp2 \<longrightarrow> ((0 :: int) \<le> (2 :: int) * sint i + (1 :: int) \<and> (2 :: int) * sint i + (1 :: int) \<le> sint o8 + (1 :: int)) \<and> (\<forall>(j :: int). offset sp3 + sint i \<le> j \<and> j < offset sp3 + sint o8 - sint i \<longrightarrow> pelts sp3 j = pelts sp2 j) \<and> in_base (sint base) (pelts sp3) (offset sp3) (offset sp3 + sint o8) \<and> svalue_sub (sint base) (pelts sp3) (offset sp3) (offset sp3 + sint i) = svalue_le_sub (sint base) (pelts sp2) (offset sp3 + sint o8 - sint i) (offset sp3 + sint o8) \<and> svalue_sub (sint base) (pelts sp3) (offset sp3 + sint o8 - sint i) (offset sp3 + sint o8) = svalue_le_sub (sint base) (pelts sp2) (offset sp3) (offset sp3 + sint i) \<and> svalue_le_sub (sint base) (pelts sp3) (offset sp3 + sint i) (offset sp3 + sint o8 - sint i) = svalue_le_sub (sint base) (pelts sp2) (offset sp3 + sint i) (offset sp3 + sint o8 - sint i) \<and> ((0 :: int) < sint i \<longrightarrow> (0 :: int) < uint (pelts sp3 (offset sp3))) \<and> (\<forall>(j :: int). j < offset sp3 \<or> offset sp3 + sint sz \<le> j \<longrightarrow> pelts sp3 j = pelts sp j) \<longrightarrow> int'32_in_bounds ((2 :: int) * sint i) \<and> (\<forall>(o9 :: 32 word). sint o9 = (2 :: int) * sint i \<longrightarrow> int'32_in_bounds (sint o9 + (1 :: int)) \<and> (\<forall>(o10 :: 32 word). sint o10 = sint o9 + (1 :: int) \<longrightarrow> (if sint o10 < sint o8 then (c_C.min sp3 \<le> offset sp3 + sint i \<and> offset sp3 + sint i < c_C.max sp3) \<and> (let t :: 8 word = pelts sp3 (offset sp3 + sint i) in int'32_in_bounds (sint o8 - sint i) \<and> (\<forall>(o11 :: 32 word). sint o11 = sint o8 - sint i \<longrightarrow> int'32_in_bounds (sint o11 - (1 :: int)) \<and> (\<forall>(o12 :: 32 word). sint o12 = sint o11 - (1 :: int) \<longrightarrow> (c_C.min sp3 \<le> offset sp3 + sint o12 \<and> offset sp3 + sint o12 < c_C.max sp3) \<and> (let o13 :: 8 word = pelts sp3 (offset sp3 + sint o12) in ((c_C.min sp3 \<le> offset sp3 + sint i \<and> offset sp3 + sint i < c_C.max sp3) \<and> writable sp3 = True) \<and> (\<forall>(sp4 :: 8 word ptr). length (data sp4) = length (data sp3) \<and> offset sp4 = offset sp3 \<and> c_C.min sp4 = c_C.min sp3 \<and> c_C.max sp4 = c_C.max sp3 \<and> writable sp4 = writable sp3 \<and> zone1 sp4 = zone1 sp3 \<longrightarrow> pelts sp4 = (pelts sp3)(offset sp4 + sint i := o13) \<and> pelts sp4 (offset sp4 + sint i) = o13 \<longrightarrow> int'32_in_bounds (sint o8 - sint i) \<and> (\<forall>(o14 :: 32 word). sint o14 = sint o8 - sint i \<longrightarrow> int'32_in_bounds (sint o14 - (1 :: int)) \<and> (\<forall>(o15 :: 32 word). sint o15 = sint o14 - (1 :: int) \<longrightarrow> ((c_C.min sp4 \<le> offset sp4 + sint o15 \<and> offset sp4 + sint o15 < c_C.max sp4) \<and> writable sp4 = True) \<and> (\<forall>(sp5 :: 8 word ptr). length (data sp5) = length (data sp4) \<and> offset sp5 = offset sp4 \<and> c_C.min sp5 = c_C.min sp4 \<and> c_C.max sp5 = c_C.max sp4 \<and> writable sp5 = writable sp4 \<and> zone1 sp5 = zone1 sp4 \<longrightarrow> pelts sp5 = (pelts sp4)(offset sp5 + sint o15 := t) \<and> pelts sp5 (offset sp5 + sint o15) = t \<longrightarrow> int'32_in_bounds (sint i + (1 :: int)) \<and> (\<forall>(o16 :: 32 word). sint o16 = sint i + (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint o8 - sint i \<and> sint o8 - sint o16 < sint o8 - sint i) \<and> ((0 :: int) \<le> (2 :: int) * sint o16 + (1 :: int) \<and> (2 :: int) * sint o16 + (1 :: int) \<le> sint o8 + (1 :: int)) \<and> (\<forall>(j :: int). offset sp5 + sint o16 \<le> j \<and> j < offset sp5 + sint o8 - sint o16 \<longrightarrow> pelts sp5 j = pelts sp2 j) \<and> in_base (sint base) (pelts sp5) (offset sp5) (offset sp5 + sint o8) \<and> svalue_sub (sint base) (pelts sp5) (offset sp5) (offset sp5 + sint o16) = svalue_le_sub (sint base) (pelts sp2) (offset sp5 + sint o8 - sint o16) (offset sp5 + sint o8) \<and> svalue_sub (sint base) (pelts sp5) (offset sp5 + sint o8 - sint o16) (offset sp5 + sint o8) = svalue_le_sub (sint base) (pelts sp2) (offset sp5) (offset sp5 + sint o16) \<and> svalue_le_sub (sint base) (pelts sp5) (offset sp5 + sint o16) (offset sp5 + sint o8 - sint o16) = svalue_le_sub (sint base) (pelts sp2) (offset sp5 + sint o16) (offset sp5 + sint o8 - sint o16) \<and> ((0 :: int) < sint o16 \<longrightarrow> (0 :: int) < uint (pelts sp5 (offset sp5))) \<and> (\<forall>(j :: int). j < offset sp5 \<or> offset sp5 + sint sz \<le> j \<longrightarrow> pelts sp5 j = pelts sp j)))))))))) else (0 :: int) \<le> sint o8 \<and> (\<forall>(result :: 32 word). uint result = sint o8 \<longrightarrow> ((0 :: int) \<le> uint result \<and> uint result < sint sz) \<and> svalue (sint base) sp3 (uint result) = value up (sint un) \<and> in_base (sint base) (pelts sp3) (offset sp3) (offset sp3 + uint result) \<and> (0 :: int) < uint (pelts sp3 (offset sp3)) \<and> (\<forall>(j :: int). j < offset sp3 \<or> offset sp3 + sint sz \<le> j \<longrightarrow> pelts sp3 j = pelts sp j)))))))))))))))))))))"
  sorry
end
