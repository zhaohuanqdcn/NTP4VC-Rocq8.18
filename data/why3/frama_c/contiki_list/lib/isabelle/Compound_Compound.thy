theory Compound_Compound
  imports "NTP4Verif.NTP4Verif" "Why3STD.Qed_Qed" "Why3STD.Memory_Memory" "../../lib/isabelle/S1_list_S1_list"
begin
definition load_s1_list :: "addr \<Rightarrow> (addr \<Rightarrow> real) \<Rightarrow> (addr \<Rightarrow> addr) \<Rightarrow> s1_list"
  where "load_s1_list p mflt_0 mptr_0 = s1_list'mk (mptr_0 (shift p (0 :: int))) (mflt_0 (shift p (1 :: int))) (mflt_0 (shift p (2 :: int))) (mflt_0 (shift p (3 :: int)))" for p mflt_0 mptr_0
axiomatization where Q_Load_S1_list_update_Mflt:   "load_s1_list p (mflt_0(q := v)) mptr_0 = load_s1_list p mflt_0 mptr_0"
 if "separated p (4 :: int) q (1 :: int)"
  for p :: "addr"
  and q :: "addr"
  and mflt_0 :: "addr \<Rightarrow> real"
  and v :: "real"
  and mptr_0 :: "addr \<Rightarrow> addr"
axiomatization where Q_Load_S1_list_eqmem_Mflt:   "load_s1_list p mflt_1 mptr_0 = load_s1_list p mflt_0 mptr_0"
 if "included p (4 :: int) q k"
 and "eqmem mflt_0 mflt_1 q k"
  for p :: "addr"
  and q :: "addr"
  and k :: "int"
  and mflt_0 :: "addr \<Rightarrow> real"
  and mflt_1 :: "addr \<Rightarrow> real"
  and mptr_0 :: "addr \<Rightarrow> addr"
axiomatization where Q_Load_S1_list_havoc_Mflt:   "load_s1_list p mflt_1 mptr_0 = load_s1_list p mflt_0 mptr_0"
 if "havoc mflt_2 mflt_0 q k = mflt_1"
 and "separated p (4 :: int) q k"
  for mflt_2 :: "addr \<Rightarrow> real"
  and mflt_0 :: "addr \<Rightarrow> real"
  and q :: "addr"
  and k :: "int"
  and mflt_1 :: "addr \<Rightarrow> real"
  and p :: "addr"
  and mptr_0 :: "addr \<Rightarrow> addr"
axiomatization where Q_Load_S1_list_update_Mptr:   "load_s1_list p mflt_0 (mptr_0(q := v)) = load_s1_list p mflt_0 mptr_0"
 if "separated p (4 :: int) q (1 :: int)"
  for p :: "addr"
  and q :: "addr"
  and mflt_0 :: "addr \<Rightarrow> real"
  and mptr_0 :: "addr \<Rightarrow> addr"
  and v :: "addr"
axiomatization where Q_Load_S1_list_eqmem_Mptr:   "load_s1_list p mflt_0 mptr_1 = load_s1_list p mflt_0 mptr_0"
 if "included p (4 :: int) q k"
 and "eqmem mptr_0 mptr_1 q k"
  for p :: "addr"
  and q :: "addr"
  and k :: "int"
  and mptr_0 :: "addr \<Rightarrow> addr"
  and mptr_1 :: "addr \<Rightarrow> addr"
  and mflt_0 :: "addr \<Rightarrow> real"
axiomatization where Q_Load_S1_list_havoc_Mptr:   "load_s1_list p mflt_0 mptr_1 = load_s1_list p mflt_0 mptr_0"
 if "havoc mptr_2 mptr_0 q k = mptr_1"
 and "separated p (4 :: int) q k"
  for mptr_2 :: "addr \<Rightarrow> addr"
  and mptr_0 :: "addr \<Rightarrow> addr"
  and q :: "addr"
  and k :: "int"
  and mptr_1 :: "addr \<Rightarrow> addr"
  and p :: "addr"
  and mflt_0 :: "addr \<Rightarrow> real"
end
