import Why3.Base
import Why3.why3.Ref.Ref
import pearl.schorr_waite_with_ghost_monitor_vcg.lean.schorr_waite_with_ghost_monitor.Memory
import pearl.schorr_waite_with_ghost_monitor_vcg.lean.schorr_waite_with_ghost_monitor.GraphShape
open Classical
open Lean4Why3
namespace schorr_waite_with_ghost_monitor_SchorrWaite_schorr_waiteqtvc
theorem schorr_waite'vc (root : Memory.loc) (graph : Finset Memory.loc) (heap : Memory.memory) (fact0 : root ∈ graph) (fact1 : ∀(l : Memory.loc), l ∈ graph ∧ ¬l = Memory.null → Memory.left1 heap l ∈ graph ∧ Memory.right1 heap l ∈ graph) (fact2 : ∀(x : Memory.loc), x ∈ graph → ¬Memory.mark heap x = true) : (∀(p : Memory.loc) (t : Memory.loc) (pc : ℤ) (heap1 : Memory.memory), (0 : ℤ) ≤ pc ∧ pc < (2 : ℤ) → (if pc = (0 : ℤ) then (pc = (0 : ℤ) → True) ∧ (pc = (1 : ℤ) ∧ ¬(¬p = Memory.null ∨ ¬t = Memory.null ∧ ¬Memory.mark heap1 t = true) → (1 : ℤ) = (2 : ℤ) ∧ root = t ∧ Memory.null = p) ∧ (pc = (1 : ℤ) ∧ (¬p = Memory.null ∨ ¬t = Memory.null ∧ ¬Memory.mark heap1 t = true) → ((t = Memory.null ∨ Memory.mark heap1 t = true) ∧ Memory.color heap1 p = true → root = p ∧ Memory.null = Memory.right1 heap1 p ∧ Memory.update (Memory.right1 heap1) (Memory.right1 heap1) p t) ∧ ((t = Memory.null ∨ Memory.mark heap1 t = true) ∧ ¬Memory.color heap1 p = true → Memory.null = p ∧ root = Memory.right1 heap1 p ∧ Memory.update (Memory.right1 heap1) (Memory.right1 heap1) Memory.null (Memory.left1 heap1 p) ∧ Memory.update (Memory.left1 heap1) (Memory.left1 heap1) Memory.null t ∧ Memory.update (Memory.color heap1) (Memory.color heap1) Memory.null true) ∧ (¬(t = Memory.null ∨ Memory.mark heap1 t = true) → Memory.null = t ∧ root = Memory.left1 heap1 t ∧ Memory.update (Memory.left1 heap1) (Memory.left1 heap1) t p ∧ Memory.update (Memory.mark heap1) (Memory.mark heap1) Memory.null true ∧ Memory.update (Memory.color heap1) (Memory.color heap1) Memory.null false)) else pc = (1 : ℤ) ∧ (∀(o1 : Bool), (if ¬p = Memory.null then o1 = true else if ¬t = Memory.null then o1 = (if Memory.mark heap1 t = true then false else true) else o1 = false) → (if o1 = true then ∀(o2 : Bool), (if t = Memory.null then o2 = true else o2 = Memory.mark heap1 t) → (if o2 = true then ¬p = Memory.null ∧ (if Memory.color heap1 p = true then ¬p = Memory.null ∧ ¬p = Memory.null ∧ (∀(heap2 : Memory.memory), Memory.left1 heap2 = Memory.left1 heap1 ∧ Memory.mark heap2 = Memory.mark heap1 ∧ Memory.color heap2 = Memory.color heap1 → Memory.update (Memory.right1 heap2) (Memory.right1 heap1) p t → (pc = (0 : ℤ) → p = root ∧ Memory.right1 heap1 p = Memory.null ∧ heap2 = heap1) ∧ (pc = (1 : ℤ) ∧ ¬(¬p = Memory.null ∨ ¬t = Memory.null ∧ ¬Memory.mark heap1 t = true) → (1 : ℤ) = (2 : ℤ) ∧ p = t ∧ Memory.right1 heap1 p = p ∧ heap2 = heap1) ∧ (pc = (1 : ℤ) ∧ (¬p = Memory.null ∨ ¬t = Memory.null ∧ ¬Memory.mark heap1 t = true) → ((t = Memory.null ∨ Memory.mark heap1 t = true) ∧ Memory.color heap1 p = true → Memory.update (Memory.right1 heap2) (Memory.right1 heap1) p t ∧ Memory.left1 heap2 = Memory.left1 heap1 ∧ Memory.mark heap2 = Memory.mark heap1 ∧ Memory.color heap2 = Memory.color heap1) ∧ ((t = Memory.null ∨ Memory.mark heap1 t = true) ∧ ¬Memory.color heap1 p = true → Memory.right1 heap1 p = p ∧ p = Memory.right1 heap1 p ∧ Memory.update (Memory.right1 heap2) (Memory.right1 heap1) (Memory.right1 heap1 p) (Memory.left1 heap1 p) ∧ Memory.update (Memory.left1 heap2) (Memory.left1 heap1) (Memory.right1 heap1 p) t ∧ Memory.update (Memory.color heap2) (Memory.color heap1) (Memory.right1 heap1 p) true ∧ Memory.mark heap2 = Memory.mark heap1) ∧ (¬(t = Memory.null ∨ Memory.mark heap1 t = true) → Memory.right1 heap1 p = t ∧ p = Memory.left1 heap1 t ∧ Memory.update (Memory.left1 heap2) (Memory.left1 heap1) t p ∧ Memory.update (Memory.mark heap2) (Memory.mark heap1) (Memory.right1 heap1 p) true ∧ Memory.update (Memory.color heap2) (Memory.color heap1) (Memory.right1 heap1 p) false ∧ Memory.right1 heap2 = Memory.right1 heap1))) else ¬p = Memory.null ∧ ¬p = Memory.null ∧ ¬p = Memory.null ∧ (∀(heap2 : Memory.memory), Memory.left1 heap2 = Memory.left1 heap1 ∧ Memory.mark heap2 = Memory.mark heap1 ∧ Memory.color heap2 = Memory.color heap1 → Memory.update (Memory.right1 heap2) (Memory.right1 heap1) p (Memory.left1 heap1 p) → ¬p = Memory.null ∧ (∀(heap3 : Memory.memory), Memory.right1 heap3 = Memory.right1 heap2 ∧ Memory.mark heap3 = Memory.mark heap2 ∧ Memory.color heap3 = Memory.color heap2 → Memory.update (Memory.left1 heap3) (Memory.left1 heap2) p t → ¬p = Memory.null ∧ (∀(heap4 : Memory.memory), Memory.left1 heap4 = Memory.left1 heap3 ∧ Memory.right1 heap4 = Memory.right1 heap3 ∧ Memory.mark heap4 = Memory.mark heap3 → Memory.update (Memory.color heap4) (Memory.color heap3) p true → (pc = (0 : ℤ) → Memory.right1 heap1 p = root ∧ p = Memory.null ∧ heap4 = heap1) ∧ (pc = (1 : ℤ) ∧ ¬(¬p = Memory.null ∨ ¬t = Memory.null ∧ ¬Memory.mark heap1 t = true) → (1 : ℤ) = (2 : ℤ) ∧ Memory.right1 heap1 p = t ∧ heap4 = heap1) ∧ (pc = (1 : ℤ) ∧ (¬p = Memory.null ∨ ¬t = Memory.null ∧ ¬Memory.mark heap1 t = true) → ((t = Memory.null ∨ Memory.mark heap1 t = true) ∧ Memory.color heap1 p = true → Memory.right1 heap1 p = p ∧ p = Memory.right1 heap1 p ∧ Memory.update (Memory.right1 heap4) (Memory.right1 heap1) p t ∧ Memory.left1 heap4 = Memory.left1 heap1 ∧ Memory.mark heap4 = Memory.mark heap1 ∧ Memory.color heap4 = Memory.color heap1) ∧ ((t = Memory.null ∨ Memory.mark heap1 t = true) ∧ ¬Memory.color heap1 p = true → Memory.update (Memory.right1 heap4) (Memory.right1 heap1) p (Memory.left1 heap1 p) ∧ Memory.update (Memory.left1 heap4) (Memory.left1 heap1) p t ∧ Memory.update (Memory.color heap4) (Memory.color heap1) p true ∧ Memory.mark heap4 = Memory.mark heap1) ∧ (¬(t = Memory.null ∨ Memory.mark heap1 t = true) → p = t ∧ Memory.right1 heap1 p = Memory.left1 heap1 t ∧ Memory.update (Memory.left1 heap4) (Memory.left1 heap1) t p ∧ Memory.update (Memory.mark heap4) (Memory.mark heap1) p true ∧ Memory.update (Memory.color heap4) (Memory.color heap1) p false ∧ Memory.right1 heap4 = Memory.right1 heap1)))))) else ¬t = Memory.null ∧ ¬t = Memory.null ∧ (∀(heap2 : Memory.memory), Memory.right1 heap2 = Memory.right1 heap1 ∧ Memory.mark heap2 = Memory.mark heap1 ∧ Memory.color heap2 = Memory.color heap1 → Memory.update (Memory.left1 heap2) (Memory.left1 heap1) t p → ¬t = Memory.null ∧ (∀(heap3 : Memory.memory), Memory.left1 heap3 = Memory.left1 heap2 ∧ Memory.right1 heap3 = Memory.right1 heap2 ∧ Memory.color heap3 = Memory.color heap2 → Memory.update (Memory.mark heap3) (Memory.mark heap2) t true → ¬t = Memory.null ∧ (∀(heap4 : Memory.memory), Memory.left1 heap4 = Memory.left1 heap3 ∧ Memory.right1 heap4 = Memory.right1 heap3 ∧ Memory.mark heap4 = Memory.mark heap3 → Memory.update (Memory.color heap4) (Memory.color heap3) t false → (pc = (0 : ℤ) → Memory.left1 heap1 t = root ∧ t = Memory.null ∧ heap4 = heap1) ∧ (pc = (1 : ℤ) ∧ ¬(¬p = Memory.null ∨ ¬t = Memory.null ∧ ¬Memory.mark heap1 t = true) → (1 : ℤ) = (2 : ℤ) ∧ Memory.left1 heap1 t = t ∧ t = p ∧ heap4 = heap1) ∧ (pc = (1 : ℤ) ∧ (¬p = Memory.null ∨ ¬t = Memory.null ∧ ¬Memory.mark heap1 t = true) → ((t = Memory.null ∨ Memory.mark heap1 t = true) ∧ Memory.color heap1 p = true → Memory.left1 heap1 t = p ∧ t = Memory.right1 heap1 p ∧ Memory.update (Memory.right1 heap4) (Memory.right1 heap1) p t ∧ Memory.left1 heap4 = Memory.left1 heap1 ∧ Memory.mark heap4 = Memory.mark heap1 ∧ Memory.color heap4 = Memory.color heap1) ∧ ((t = Memory.null ∨ Memory.mark heap1 t = true) ∧ ¬Memory.color heap1 p = true → t = p ∧ Memory.left1 heap1 t = Memory.right1 heap1 p ∧ Memory.update (Memory.right1 heap4) (Memory.right1 heap1) t (Memory.left1 heap1 p) ∧ Memory.update (Memory.left1 heap4) (Memory.left1 heap1) t t ∧ Memory.update (Memory.color heap4) (Memory.color heap1) t true ∧ Memory.mark heap4 = Memory.mark heap1) ∧ (¬(t = Memory.null ∨ Memory.mark heap1 t = true) → Memory.update (Memory.left1 heap4) (Memory.left1 heap1) t p ∧ Memory.update (Memory.mark heap4) (Memory.mark heap1) t true ∧ Memory.update (Memory.color heap4) (Memory.color heap1) t false ∧ Memory.right1 heap4 = Memory.right1 heap1)))))) else (pc = (0 : ℤ) → (2 : ℤ) = (1 : ℤ) ∧ t = root ∧ p = Memory.null) ∧ (pc = (1 : ℤ) ∧ ¬(¬p = Memory.null ∨ ¬t = Memory.null ∧ ¬Memory.mark heap1 t = true) → True) ∧ (pc = (1 : ℤ) ∧ (¬p = Memory.null ∨ ¬t = Memory.null ∧ ¬Memory.mark heap1 t = true) → (2 : ℤ) = (1 : ℤ) ∧ ((t = Memory.null ∨ Memory.mark heap1 t = true) ∧ Memory.color heap1 p = true → t = p ∧ p = Memory.right1 heap1 p ∧ Memory.update (Memory.right1 heap1) (Memory.right1 heap1) p t) ∧ ((t = Memory.null ∨ Memory.mark heap1 t = true) ∧ ¬Memory.color heap1 p = true → t = Memory.right1 heap1 p ∧ Memory.update (Memory.right1 heap1) (Memory.right1 heap1) p (Memory.left1 heap1 p) ∧ Memory.update (Memory.left1 heap1) (Memory.left1 heap1) p t ∧ Memory.update (Memory.color heap1) (Memory.color heap1) p true) ∧ (¬(t = Memory.null ∨ Memory.mark heap1 t = true) → p = t ∧ t = Memory.left1 heap1 t ∧ Memory.update (Memory.left1 heap1) (Memory.left1 heap1) t p ∧ Memory.update (Memory.mark heap1) (Memory.mark heap1) p true ∧ Memory.update (Memory.color heap1) (Memory.color heap1) p false)))))) ∧ (∀(p : Memory.loc) (t : Memory.loc) (heap1 : Memory.memory) (gray_nodes : Finset Memory.loc), t ∈ graph ∧ GraphShape.well_colored_on graph gray_nodes heap (Memory.mark heap1) ∧ (∀(x : Memory.loc), ¬x = Memory.null ∧ ¬Memory.mark heap1 x = true → Memory.left1 heap1 x = Memory.left1 heap x ∧ Memory.right1 heap1 x = Memory.right1 heap x) → (∀(o1 : Bool), (if t = Memory.null then o1 = true else o1 = Memory.mark heap1 t) → (if o1 = true then GraphShape.unchanged_structure heap1 heap1 ∧ GraphShape.well_colored_on graph gray_nodes heap (Memory.mark heap1) ∧ (¬t = Memory.null → Memory.mark heap1 t = true) else let new_gray : Finset Memory.loc := insert t gray_nodes; ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < (2 : ℤ)) ∧ (∀(p1 : Memory.loc) (t1 : Memory.loc) (pc : ℤ) (heap2 : Memory.memory), ((1 : ℤ) = (0 : ℤ) → pc = (1 : ℤ) ∧ t1 = root ∧ p1 = Memory.null ∧ heap2 = heap1) ∧ (¬(¬p = Memory.null ∨ ¬t = Memory.null ∧ ¬Memory.mark heap1 t = true) → pc = (2 : ℤ) ∧ t1 = t ∧ p1 = p ∧ heap2 = heap1) ∧ (¬p = Memory.null ∨ ¬t = Memory.null ∧ ¬Memory.mark heap1 t = true → pc = (1 : ℤ) ∧ ((t = Memory.null ∨ Memory.mark heap1 t = true) ∧ Memory.color heap1 p = true → t1 = p ∧ p1 = Memory.right1 heap1 p ∧ Memory.update (Memory.right1 heap2) (Memory.right1 heap1) p t ∧ Memory.left1 heap2 = Memory.left1 heap1 ∧ Memory.mark heap2 = Memory.mark heap1 ∧ Memory.color heap2 = Memory.color heap1) ∧ ((t = Memory.null ∨ Memory.mark heap1 t = true) ∧ ¬Memory.color heap1 p = true → p1 = p ∧ t1 = Memory.right1 heap1 p ∧ Memory.update (Memory.right1 heap2) (Memory.right1 heap1) p1 (Memory.left1 heap1 p) ∧ Memory.update (Memory.left1 heap2) (Memory.left1 heap1) p1 t ∧ Memory.update (Memory.color heap2) (Memory.color heap1) p1 true ∧ Memory.mark heap2 = Memory.mark heap1) ∧ (¬(t = Memory.null ∨ Memory.mark heap1 t = true) → p1 = t ∧ t1 = Memory.left1 heap1 t ∧ Memory.update (Memory.left1 heap2) (Memory.left1 heap1) t p ∧ Memory.update (Memory.mark heap2) (Memory.mark heap1) p1 true ∧ Memory.update (Memory.color heap2) (Memory.color heap1) p1 false ∧ Memory.right1 heap2 = Memory.right1 heap1)) → (((0 : ℤ) ≤ Int.ofNat (Finset.card graph) - Int.ofNat (Finset.card gray_nodes) ∧ Int.ofNat (Finset.card graph) - Int.ofNat (Finset.card new_gray) < Int.ofNat (Finset.card graph) - Int.ofNat (Finset.card gray_nodes)) ∧ pc = (1 : ℤ) ∧ t1 ∈ graph ∧ GraphShape.well_colored_on graph new_gray heap (Memory.mark heap2) ∧ (∀(x : Memory.loc), ¬x = Memory.null ∧ ¬Memory.mark heap2 x = true → Memory.left1 heap2 x = Memory.left1 heap x ∧ Memory.right1 heap2 x = Memory.right1 heap x)) ∧ (∀(heap3 : Memory.memory), GraphShape.unchanged_structure heap2 heap3 ∧ GraphShape.well_colored_on graph new_gray heap (Memory.mark heap3) ∧ (¬t1 = Memory.null → Memory.mark heap3 t1 = true) ∧ (∀(x : Memory.loc), ¬x = Memory.null → ¬GraphShape.path heap t1 x ∨ Memory.mark heap2 x = true → Memory.mark heap3 x = Memory.mark heap2 x ∧ Memory.color heap3 x = Memory.color heap2 x) → ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < (2 : ℤ)) ∧ (∀(p2 : Memory.loc) (t2 : Memory.loc) (pc1 : ℤ) (heap4 : Memory.memory), ((1 : ℤ) = (0 : ℤ) → pc1 = (1 : ℤ) ∧ t2 = root ∧ p2 = Memory.null ∧ heap4 = heap3) ∧ (¬(¬p1 = Memory.null ∨ ¬t1 = Memory.null ∧ ¬Memory.mark heap3 t1 = true) → pc1 = (2 : ℤ) ∧ t2 = t1 ∧ p2 = p1 ∧ heap4 = heap3) ∧ (¬p1 = Memory.null ∨ ¬t1 = Memory.null ∧ ¬Memory.mark heap3 t1 = true → pc1 = (1 : ℤ) ∧ ((t1 = Memory.null ∨ Memory.mark heap3 t1 = true) ∧ Memory.color heap3 p1 = true → t2 = p1 ∧ p2 = Memory.right1 heap3 p1 ∧ Memory.update (Memory.right1 heap4) (Memory.right1 heap3) p1 t1 ∧ Memory.left1 heap4 = Memory.left1 heap3 ∧ Memory.mark heap4 = Memory.mark heap3 ∧ Memory.color heap4 = Memory.color heap3) ∧ ((t1 = Memory.null ∨ Memory.mark heap3 t1 = true) ∧ ¬Memory.color heap3 p1 = true → p2 = p1 ∧ t2 = Memory.right1 heap3 p1 ∧ Memory.update (Memory.right1 heap4) (Memory.right1 heap3) p2 (Memory.left1 heap3 p1) ∧ Memory.update (Memory.left1 heap4) (Memory.left1 heap3) p2 t1 ∧ Memory.update (Memory.color heap4) (Memory.color heap3) p2 true ∧ Memory.mark heap4 = Memory.mark heap3) ∧ (¬(t1 = Memory.null ∨ Memory.mark heap3 t1 = true) → p2 = t1 ∧ t2 = Memory.left1 heap3 t1 ∧ Memory.update (Memory.left1 heap4) (Memory.left1 heap3) t1 p1 ∧ Memory.update (Memory.mark heap4) (Memory.mark heap3) p2 true ∧ Memory.update (Memory.color heap4) (Memory.color heap3) p2 false ∧ Memory.right1 heap4 = Memory.right1 heap3)) → (((0 : ℤ) ≤ Int.ofNat (Finset.card graph) - Int.ofNat (Finset.card gray_nodes) ∧ Int.ofNat (Finset.card graph) - Int.ofNat (Finset.card new_gray) < Int.ofNat (Finset.card graph) - Int.ofNat (Finset.card gray_nodes)) ∧ pc1 = (1 : ℤ) ∧ t2 ∈ graph ∧ GraphShape.well_colored_on graph new_gray heap (Memory.mark heap4) ∧ (∀(x : Memory.loc), ¬x = Memory.null ∧ ¬Memory.mark heap4 x = true → Memory.left1 heap4 x = Memory.left1 heap x ∧ Memory.right1 heap4 x = Memory.right1 heap x)) ∧ (∀(heap5 : Memory.memory), GraphShape.unchanged_structure heap4 heap5 ∧ GraphShape.well_colored_on graph new_gray heap (Memory.mark heap5) ∧ (¬t2 = Memory.null → Memory.mark heap5 t2 = true) ∧ (∀(x : Memory.loc), ¬x = Memory.null → ¬GraphShape.path heap t2 x ∨ Memory.mark heap4 x = true → Memory.mark heap5 x = Memory.mark heap4 x ∧ Memory.color heap5 x = Memory.color heap4 x) → ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < (2 : ℤ)) ∧ (∀(p3 : Memory.loc) (t3 : Memory.loc) (pc2 : ℤ) (heap6 : Memory.memory), ((1 : ℤ) = (0 : ℤ) → pc2 = (1 : ℤ) ∧ t3 = root ∧ p3 = Memory.null ∧ heap6 = heap5) ∧ (¬(¬p2 = Memory.null ∨ ¬t2 = Memory.null ∧ ¬Memory.mark heap5 t2 = true) → pc2 = (2 : ℤ) ∧ t3 = t2 ∧ p3 = p2 ∧ heap6 = heap5) ∧ (¬p2 = Memory.null ∨ ¬t2 = Memory.null ∧ ¬Memory.mark heap5 t2 = true → pc2 = (1 : ℤ) ∧ ((t2 = Memory.null ∨ Memory.mark heap5 t2 = true) ∧ Memory.color heap5 p2 = true → t3 = p2 ∧ p3 = Memory.right1 heap5 p2 ∧ Memory.update (Memory.right1 heap6) (Memory.right1 heap5) p2 t2 ∧ Memory.left1 heap6 = Memory.left1 heap5 ∧ Memory.mark heap6 = Memory.mark heap5 ∧ Memory.color heap6 = Memory.color heap5) ∧ ((t2 = Memory.null ∨ Memory.mark heap5 t2 = true) ∧ ¬Memory.color heap5 p2 = true → p3 = p2 ∧ t3 = Memory.right1 heap5 p2 ∧ Memory.update (Memory.right1 heap6) (Memory.right1 heap5) p3 (Memory.left1 heap5 p2) ∧ Memory.update (Memory.left1 heap6) (Memory.left1 heap5) p3 t2 ∧ Memory.update (Memory.color heap6) (Memory.color heap5) p3 true ∧ Memory.mark heap6 = Memory.mark heap5) ∧ (¬(t2 = Memory.null ∨ Memory.mark heap5 t2 = true) → p3 = t2 ∧ t3 = Memory.left1 heap5 t2 ∧ Memory.update (Memory.left1 heap6) (Memory.left1 heap5) t2 p2 ∧ Memory.update (Memory.mark heap6) (Memory.mark heap5) p3 true ∧ Memory.update (Memory.color heap6) (Memory.color heap5) p3 false ∧ Memory.right1 heap6 = Memory.right1 heap5)) → pc2 = (1 : ℤ) ∧ (t3 = t ∧ p3 = p) ∧ GraphShape.unchanged_structure heap1 heap6 ∧ GraphShape.well_colored_on graph gray_nodes heap (Memory.mark heap6) ∧ (¬t3 = Memory.null → Memory.mark heap6 t3 = true) ∧ (∀(x : Memory.loc), ¬x = Memory.null → ¬GraphShape.path heap t3 x ∨ Memory.mark heap1 x = true → Memory.mark heap6 x = Memory.mark heap1 x ∧ Memory.color heap6 x = Memory.color heap1 x))))))))) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < (2 : ℤ) ∧ (((0 : ℤ) = (1 : ℤ) → (1 : ℤ) = (2 : ℤ) ∧ root = Memory.null) → (let o1 : Finset Memory.loc := (∅ : Finset Memory.loc); (root ∈ graph ∧ GraphShape.well_colored_on graph o1 heap (Memory.mark heap) ∧ (∀(x : Memory.loc), ¬x = Memory.null ∧ ¬Memory.mark heap x = true → True)) ∧ (∀(heap1 : Memory.memory), GraphShape.unchanged_structure heap heap1 ∧ GraphShape.well_colored_on graph o1 heap (Memory.mark heap1) ∧ (¬root = Memory.null → Memory.mark heap1 root = true) ∧ (∀(x : Memory.loc), ¬x = Memory.null → ¬GraphShape.path heap root x ∨ Memory.mark heap x = true → Memory.mark heap1 x = Memory.mark heap x ∧ Memory.color heap1 x = Memory.color heap x) → ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < (2 : ℤ)) ∧ (∀(p : Memory.loc) (t : Memory.loc) (pc : ℤ) (heap2 : Memory.memory), ((1 : ℤ) = (0 : ℤ) → pc = (1 : ℤ) ∧ t = root ∧ p = Memory.null ∧ heap2 = heap1) ∧ (¬(¬True ∨ ¬root = Memory.null ∧ ¬Memory.mark heap1 root = true) → pc = (2 : ℤ) ∧ t = root ∧ p = Memory.null ∧ heap2 = heap1) ∧ (¬True ∨ ¬root = Memory.null ∧ ¬Memory.mark heap1 root = true → pc = (1 : ℤ) ∧ ((root = Memory.null ∨ Memory.mark heap1 root = true) ∧ Memory.color heap1 Memory.null = true → t = Memory.null ∧ p = Memory.right1 heap1 Memory.null ∧ Memory.update (Memory.right1 heap2) (Memory.right1 heap1) Memory.null root ∧ Memory.left1 heap2 = Memory.left1 heap1 ∧ Memory.mark heap2 = Memory.mark heap1 ∧ Memory.color heap2 = Memory.color heap1) ∧ ((root = Memory.null ∨ Memory.mark heap1 root = true) ∧ ¬Memory.color heap1 Memory.null = true → p = Memory.null ∧ t = Memory.right1 heap1 Memory.null ∧ Memory.update (Memory.right1 heap2) (Memory.right1 heap1) p (Memory.left1 heap1 Memory.null) ∧ Memory.update (Memory.left1 heap2) (Memory.left1 heap1) p root ∧ Memory.update (Memory.color heap2) (Memory.color heap1) p true ∧ Memory.mark heap2 = Memory.mark heap1) ∧ (¬(root = Memory.null ∨ Memory.mark heap1 root = true) → p = root ∧ t = Memory.left1 heap1 root ∧ Memory.update (Memory.left1 heap2) (Memory.left1 heap1) root Memory.null ∧ Memory.update (Memory.mark heap2) (Memory.mark heap1) p true ∧ Memory.update (Memory.color heap2) (Memory.color heap1) p false ∧ Memory.right1 heap2 = Memory.right1 heap1)) → GraphShape.unchanged_structure heap heap2 ∧ (∀(x : Memory.loc), GraphShape.path heap root x ∧ ¬x = Memory.null → Memory.mark heap2 x = true) ∧ (∀(x : Memory.loc), ¬GraphShape.path heap root x ∧ ¬x = Memory.null → Memory.mark heap2 x = Memory.mark heap x)))))
  := sorry
end schorr_waite_with_ghost_monitor_SchorrWaite_schorr_waiteqtvc
