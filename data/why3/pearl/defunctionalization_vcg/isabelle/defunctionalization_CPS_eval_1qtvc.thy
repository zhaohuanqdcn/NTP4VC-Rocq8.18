theory defunctionalization_CPS_eval_1qtvc
  imports "NTP4Verif.NTP4Verif" "./defunctionalization_Expr" "./defunctionalization_DirectSem"
begin
consts o1 :: "(int \<Rightarrow> 'a) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a"
consts result :: "(int \<Rightarrow> 'a) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a"
consts o2 :: "(int \<Rightarrow> 'a) \<Rightarrow> expr \<Rightarrow> int \<Rightarrow> 'a"
consts result1 :: "(int \<Rightarrow> 'a) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a"
consts o3 :: "(int \<Rightarrow> 'a) \<Rightarrow> expr \<Rightarrow> int \<Rightarrow> 'a"
consts result2 :: "(int \<Rightarrow> 'a) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a"
consts o4 :: "(int \<Rightarrow> 'a) \<Rightarrow> expr \<Rightarrow> int \<Rightarrow> 'a"
axiomatization where o'def:   "o1 k v1 v2 = k (v1 - v2)"
  for k :: "int \<Rightarrow> 'a"
  and v1 :: "int"
  and v2 :: "int"
axiomatization where result'def:   "result k v1 v2 = k (v1 - v2)"
  for k :: "int \<Rightarrow> 'a"
  and v1 :: "int"
  and v2 :: "int"
axiomatization where o'def1:   "o2 k e2 v1 = result k v1 (eval_0 e2)"
  for k :: "int \<Rightarrow> 'a"
  and e2 :: "expr"
  and v1 :: "int"
axiomatization where result'def1:   "result1 k v1 v2 = k (v1 - v2)"
  for k :: "int \<Rightarrow> 'a"
  and v1 :: "int"
  and v2 :: "int"
axiomatization where o'def2:   "o3 k e2 v1 = result1 k v1 (eval_0 e2)"
  for k :: "int \<Rightarrow> 'a"
  and e2 :: "expr"
  and v1 :: "int"
axiomatization where result'def2:   "result2 k v1 v2 = k (v1 - v2)"
  for k :: "int \<Rightarrow> 'a"
  and v1 :: "int"
  and v2 :: "int"
axiomatization where o'def3:   "o4 k e2 v1 = result2 k v1 (eval_0 e2)"
  for k :: "int \<Rightarrow> 'a"
  and e2 :: "expr"
  and v1 :: "int"
theorem eval_1'vc:
  fixes e :: "expr"
  fixes k :: "int \<Rightarrow> 'a"
  shows "case e of Cte n \<Rightarrow> True | Sub e1 e2 \<Rightarrow> (case e of Cte _ \<Rightarrow> False | Sub f f1 \<Rightarrow> f = e2 \<or> f1 = e2) \<and> (case e of Cte _ \<Rightarrow> False | Sub f f1 \<Rightarrow> f = e1 \<or> f1 = e1)"
  and "\<forall>(result3 :: 'a). (case e of Cte n \<Rightarrow> result3 = k n | Sub e1 e2 \<Rightarrow> result3 = o4 k e2 (eval_0 e1)) \<longrightarrow> result3 = k (eval_0 e)"
  sorry
end
