theory euler_sieve_EulerSieveImpl_tqtvc
  imports "NTP4Verif.NTP4Verif" "./euler_sieve_ArithmeticResults" "./euler_sieve_DivisibilityResults" "./euler_sieve_EulerSieveSpec" "mach.array_ArrayInt63"
begin
consts o1 :: "int \<Rightarrow> bool"
consts o2 :: "int \<Rightarrow> int"
axiomatization where o'def:   "o1 i = True \<longleftrightarrow> i < (2 :: int)"
  for i :: "int"
axiomatization where o'def1:   "o2 i = i + (1 :: int)"
  for i :: "int"
theorem t'vc:
  shows "(0 :: int) \<le> (2 :: int)"
  and "\<forall>(o3 :: array_ArrayInt63.array63). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (2 :: int) \<longrightarrow> elts o3 ! nat i = sint (Groups.uminus_class.uminus (2 :: 63 word))) \<and> int (length (elts o3)) = (2 :: int) \<longrightarrow> ((0 :: int) \<le> (1 :: int) \<and> (1 :: int) < int (length (elts o3))) \<and> (\<forall>(o4 :: array_ArrayInt63.array63). length (elts o4) = length (elts o3) \<and> elts o4 = (elts o3)[nat (1 :: int) := sint (4 :: 63 word)] \<longrightarrow> (let o5 :: int \<Rightarrow> bool = o1 in (0 :: int) \<le> (4 :: int) \<and> (let o6 :: bool list = create_list (4 :: int) o5 in int (length o6) = (4 :: int) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (4 :: int) \<longrightarrow> o6 ! nat i = o5 i) \<longrightarrow> (let o7 :: int \<Rightarrow> int = o2 in (0 :: int) \<le> (4 :: int) \<and> (let o8 :: int list = create_list (4 :: int) o7 in int (length o8) = (4 :: int) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (4 :: int) \<longrightarrow> o8 ! nat i = o7 i) \<longrightarrow> ((3 :: int) < sint int'63_max \<and> (3 :: int) \<le> (3 :: int)) \<and> ((3 :: int) < sint int'63_max \<and> (3 :: int) \<le> (3 :: int) \<longrightarrow> (length o8 = length o6 \<and> int (length o6) = (3 :: int) + (1 :: int)) \<and> (length o8 = length o6 \<and> int (length o6) = (3 :: int) + (1 :: int) \<longrightarrow> ((3 :: int) - (1 :: int)) ediv (2 :: int) = (1 :: int) \<and> (((3 :: int) - (1 :: int)) ediv (2 :: int) = (1 :: int) \<longrightarrow> int (length (elts o4)) = (1 :: int) + (1 :: int) \<and> (int (length (elts o4)) = (1 :: int) + (1 :: int) \<longrightarrow> inv_nexts o8 (int (length o8)) \<and> (inv_nexts o8 (int (length o8)) \<longrightarrow> all_eliminated_marked o6 o8 \<and> (all_eliminated_marked o6 o8 \<longrightarrow> (\<forall>(i :: int). (3 :: int) \<le> i \<and> i \<le> (3 :: int) \<longrightarrow> i emod (2 :: int) = (0 :: int) \<longrightarrow> o6 ! nat i = True) \<and> ((\<forall>(i :: int). (3 :: int) \<le> i \<and> i \<le> (3 :: int) \<longrightarrow> i emod (2 :: int) = (0 :: int) \<longrightarrow> o6 ! nat i = True) \<longrightarrow> (\<forall>(i :: int). (3 :: int) \<le> i \<and> i < (3 :: int) - (1 :: int) \<longrightarrow> i emod (2 :: int) = (1 :: int) \<longrightarrow> o8 ! nat i emod (2 :: int) = (1 :: int) \<or> o8 ! nat i = (3 :: int) + (1 :: int)) \<and> ((\<forall>(i :: int). (3 :: int) \<le> i \<and> i < (3 :: int) - (1 :: int) \<longrightarrow> i emod (2 :: int) = (1 :: int) \<longrightarrow> o8 ! nat i emod (2 :: int) = (1 :: int) \<or> o8 ! nat i = (3 :: int) + (1 :: int)) \<longrightarrow> (o8 ! (3 :: nat) = (3 :: int) + (1 :: int) \<and> (((3 :: int) - (1 :: int)) emod (2 :: int) = (0 :: int) \<longrightarrow> o8 ! nat ((3 :: int) - (1 :: int)) = (3 :: int)) \<and> (((3 :: int) - (1 :: int)) emod (2 :: int) = (1 :: int) \<longrightarrow> o8 ! nat ((3 :: int) - (1 :: int)) = (3 :: int) + (1 :: int))) \<and> (o8 ! (3 :: nat) = (3 :: int) + (1 :: int) \<and> (((3 :: int) - (1 :: int)) emod (2 :: int) = (0 :: int) \<longrightarrow> o8 ! nat ((3 :: int) - (1 :: int)) = (3 :: int)) \<and> (((3 :: int) - (1 :: int)) emod (2 :: int) = (1 :: int) \<longrightarrow> o8 ! nat ((3 :: int) - (1 :: int)) = (3 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (1 :: int) \<longrightarrow> -((3 :: int) + (1 :: int)) \<le> elts o4 ! nat i \<and> elts o4 ! nat i \<le> (3 :: int) + (1 :: int)) \<and> ((\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (1 :: int) \<longrightarrow> -((3 :: int) + (1 :: int)) \<le> elts o4 ! nat i \<and> elts o4 ! nat i \<le> (3 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (1 :: int) \<longrightarrow> o6 ! nat ((2 :: int) * i + (1 :: int)) = True \<longleftrightarrow> elts o4 ! nat i < (0 :: int)) \<and> ((\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (1 :: int) \<longrightarrow> o6 ! nat ((2 :: int) * i + (1 :: int)) = True \<longleftrightarrow> elts o4 ! nat i < (0 :: int)) \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (1 :: int) \<longrightarrow> \<not>o6 ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts o4 ! nat i = o8 ! nat ((2 :: int) * i + (1 :: int))) \<and> ((\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (1 :: int) \<longrightarrow> \<not>o6 ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts o4 ! nat i = o8 ! nat ((2 :: int) * i + (1 :: int))) \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (1 :: int) \<longrightarrow> o6 ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts o4 ! nat i = -o8 ! nat ((2 :: int) * i + (1 :: int))) \<and> ((\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (1 :: int) \<longrightarrow> o6 ! nat ((2 :: int) * i + (1 :: int)) = True \<longrightarrow> elts o4 ! nat i = -o8 ! nat ((2 :: int) * i + (1 :: int))) \<longrightarrow> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (1 :: int) \<longrightarrow> (i < abs (elts o4 ! nat i) ediv (2 :: int) \<and> abs (elts o4 ! nat i) ediv (2 :: int) \<le> (1 :: int) + (1 :: int)) \<and> abs (elts o4 ! nat i) \<le> (3 :: int) + (1 :: int)) \<and> ((\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (1 :: int) \<longrightarrow> (i < abs (elts o4 ! nat i) ediv (2 :: int) \<and> abs (elts o4 ! nat i) ediv (2 :: int) \<le> (1 :: int) + (1 :: int)) \<and> abs (elts o4 ! nat i) \<le> (3 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i \<le> (1 :: int) \<longrightarrow> i < j \<and> j < abs (elts o4 ! nat i) ediv (2 :: int) \<longrightarrow> elts o4 ! nat j < (0 :: int)))))))))))))))))))))"
  sorry
end
