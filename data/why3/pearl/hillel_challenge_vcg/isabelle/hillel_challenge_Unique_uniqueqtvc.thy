theory hillel_challenge_Unique_uniqueqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.ocaml_Exceptions"
begin
definition mem :: "int \<Rightarrow> int list \<Rightarrow> int \<Rightarrow> _"
  where "mem x a i \<longleftrightarrow> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < i) \<and> a ! nat j = x)" for x a i
theorem unique'vc:
  fixes a :: "int list"
  shows "let n :: int = int (length a) in \<forall>(h :: (int, unit) fmap). h = fmempty \<longrightarrow> (0 :: int) \<le> n \<and> (\<forall>(res :: int list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> res ! nat i = (0 :: int)) \<and> int (length res) = n \<longrightarrow> (let o1 :: int = n - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((0 :: int) \<le> (0 :: int) \<and> (\<forall>(x :: int). mem x a (0 :: int) \<longleftrightarrow> x |\<in>| fmdom h) \<and> (\<forall>(x :: int). mem x a (0 :: int) \<longleftrightarrow> mem x res (0 :: int)) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < j \<and> j < (0 :: int) \<longrightarrow> \<not>res ! nat i = res ! nat j)) \<and> (\<forall>(len :: int) (res1 :: int list) (h1 :: (int, unit) fmap). length res1 = length res \<longrightarrow> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o1) \<and> ((0 :: int) \<le> len \<and> len \<le> i) \<and> (\<forall>(x :: int). mem x a i \<longleftrightarrow> x |\<in>| fmdom h1) \<and> (\<forall>(x :: int). mem x a i \<longleftrightarrow> mem x res1 len) \<and> (\<forall>(i1 :: int) (j :: int). (0 :: int) \<le> i1 \<and> i1 < j \<and> j < len \<longrightarrow> \<not>res1 ! nat i1 = res1 ! nat j) \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if \<not>a ! nat i |\<in>| fmdom h1 then ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (\<forall>(h2 :: (int, unit) fmap). h2 = fmupd (a ! nat i) () h1 \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (let o2 :: int = a ! nat i in ((0 :: int) \<le> len \<and> len < int (length res1)) \<and> (length (res1[nat len := o2]) = length res1 \<longrightarrow> nth (res1[nat len := o2]) o nat = (nth res1 o nat)(len := o2) \<longrightarrow> ((0 :: int) \<le> len + (1 :: int) \<and> len + (1 :: int) \<le> i + (1 :: int)) \<and> (\<forall>(x :: int). mem x a (i + (1 :: int)) \<longleftrightarrow> x |\<in>| fmdom h2) \<and> (\<forall>(x :: int). mem x a (i + (1 :: int)) \<longleftrightarrow> mem x (res1[nat len := o2]) (len + (1 :: int))) \<and> (\<forall>(i1 :: int) (j :: int). (0 :: int) \<le> i1 \<and> i1 < j \<and> j < len + (1 :: int) \<longrightarrow> \<not>res1[nat len := o2] ! nat i1 = res1[nat len := o2] ! nat j)))) else ((0 :: int) \<le> len \<and> len \<le> i + (1 :: int)) \<and> (\<forall>(x :: int). mem x a (i + (1 :: int)) \<longleftrightarrow> x |\<in>| fmdom h1) \<and> (\<forall>(x :: int). mem x a (i + (1 :: int)) \<longleftrightarrow> mem x res1 len) \<and> (\<forall>(i1 :: int) (j :: int). (0 :: int) \<le> i1 \<and> i1 < j \<and> j < len \<longrightarrow> \<not>res1 ! nat i1 = res1 ! nat j))) \<and> (((0 :: int) \<le> len \<and> len \<le> o1 + (1 :: int)) \<and> (\<forall>(x :: int). mem x a (o1 + (1 :: int)) \<longleftrightarrow> x |\<in>| fmdom h1) \<and> (\<forall>(x :: int). mem x a (o1 + (1 :: int)) \<longleftrightarrow> mem x res1 len) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < j \<and> j < len \<longrightarrow> \<not>res1 ! nat i = res1 ! nat j) \<longrightarrow> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> len \<and> (0 :: int) + len \<le> int (length res1)) \<and> (\<forall>(result :: int list). int (length result) = len \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < len \<longrightarrow> result ! nat i = res1 ! nat ((0 :: int) + i)) \<longrightarrow> (\<forall>(x :: int). mem x result (int (length result)) \<longleftrightarrow> mem x a (int (length a))) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < j \<and> j < int (length result) \<longrightarrow> \<not>result ! nat i = result ! nat j))))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) + (0 :: int) \<le> int (length res)) \<and> (\<forall>(result :: int list). int (length result) = (0 :: int) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < (0 :: int) \<longrightarrow> result ! nat i = res ! nat ((0 :: int) + i)) \<longrightarrow> (\<forall>(x :: int). mem x result (int (length result)) \<longleftrightarrow> mem x a (int (length a))) \<and> (\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < j \<and> j < int (length result) \<longrightarrow> \<not>result ! nat i = result ! nat j)))))"
  sorry
end
