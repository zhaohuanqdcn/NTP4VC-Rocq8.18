(* ---------------------------------------------------------- *)
(* --- Complete behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_complete_zero_s2_smaller_s1_smaller_s1_s2_smaller___
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Complete behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq'":
*)
goal goal0:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((i = 0) \/
   ((forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
     (t_1[(shift_sint8 a_1 i_1)] = t_1[(shift_sint8 a i_1)])) /\
    (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
     (t_1[(shift_sint8 a i_1)] <> 0)) /\
    (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
     (t_1[(shift_sint8 a_1 i_1)] <> 0))) \/
   ((forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
     (t_1[(shift_sint8 a i_1)] <> 0)) /\
    (exists i_1 : int. (0 <= i_1) /\ (i_1 < i) /\
     ((p_length_of_str_is t t_1 a_1 i_1)))) \/
   ((forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
     (t_1[(shift_sint8 a_1 i_1)] <> 0)) /\
    (exists i_1 : int. (0 <= i_1) /\ (i_1 < i) /\
     ((p_length_of_str_is t t_1 a i_1)))) \/
   ((forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
     (t_1[(shift_sint8 a i_1)] <> 0)) /\
    (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
     (t_1[(shift_sint8 a_1 i_1)] <> 0)) /\
    (exists i_1 : int.
     (t_1[(shift_sint8 a_1 i_1)] <> t_1[(shift_sint8 a i_1)]) /\
     (0 <= i_1) /\ (i_1 < i))) \/
   (exists i_2 i_1 : int. (i_2 <> i_1) /\ (0 <= i_1) /\ (i_1 < i) /\
    (0 <= i_2) /\ (i_2 < i) /\ ((p_length_of_str_is t t_1 a i_1)) /\
    ((p_length_of_str_is t t_1 a_1 i_2))) \/
   (exists i_1 : int. (0 <= i_1) /\ (i_1 < i) /\
    ((p_length_of_str_is t t_1 a i_1)) /\
    ((p_length_of_str_is t t_1 a_1 i_1)) /\
    (forall i_2 : int. (0 <= i_2) -> (i_2 < i_1) ->
     (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)]))) \/
   (exists i_1 : int. (0 <= i_1) /\ (i_1 < i) /\
    ((p_length_of_str_is t t_1 a i_1)) /\
    ((p_length_of_str_is t t_1 a_1 i_1)) /\
    (exists i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] <> t_1[(shift_sint8 a i_2)]) /\
     (0 <= i_2) /\ (i_2 <= i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (1/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller___
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (1/27)":
*)
goal goal1:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((i <> 0) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (2/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (2/27)":
*)
goal goal2:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((i <> 0) \/
   (exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a_1 i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (3/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (3/27)":
*)
goal goal3:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((i <> 0) \/
   (exists i_1 : int.
    (t_1[(shift_sint8 a_1 i_1)] <> t_1[(shift_sint8 a i_1)]) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (4/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (4/27)":
*)
goal goal4:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((i <> 0) \/
   (forall i_1 : int.
    (t_1[(shift_sint8 a_1 i_1)] = t_1[(shift_sint8 a i_1)]) \/ (i_1 < 0) \/
    (i <= i_1)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (5/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____5
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (5/27)":
*)
goal goal5:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((exists i_1 : int.
    (t_1[(shift_sint8 a_1 i_1)] <> t_1[(shift_sint8 a i_1)]) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a_1 i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (6/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____6
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (6/27)":
*)
goal goal6:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((exists i_1 : int.
    (t_1[(shift_sint8 a_1 i_1)] <> t_1[(shift_sint8 a i_1)]) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (7/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____7
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (7/27)":
*)
goal goal7:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1))) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a_1 i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (8/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____8
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (8/27)":
*)
goal goal8:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((forall i_1 : int.
    (t_1[(shift_sint8 a_1 i_1)] = t_1[(shift_sint8 a i_1)]) \/ (i_1 < 0) \/
    (i <= i_1)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a_1 i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (9/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____9
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (9/27)":
*)
goal goal9:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((forall i_1 : int.
    (t_1[(shift_sint8 a_1 i_1)] = t_1[(shift_sint8 a i_1)]) \/ (i_1 < 0) \/
    (i <= i_1)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (10/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____10
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (10/27)":
*)
goal goal10:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((i <> 0) \/
   (forall i_2 i_1 : int. (i_2 = i_1) \/ (i_1 < 0) \/ (i <= i_1) \/
    (i_2 < 0) \/ (i <= i_2) \/ (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_2))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (11/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____11
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (11/27)":
*)
goal goal11:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1))) \/
   (forall i_2 i_1 : int. (i_2 = i_1) \/ (i_1 < 0) \/ (i <= i_1) \/
    (i_2 < 0) \/ (i <= i_2) \/ (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_2))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (12/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____12
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (12/27)":
*)
goal goal12:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a_1 i_1))) \/
   (forall i_2 i_1 : int. (i_2 = i_1) \/ (i_1 < 0) \/ (i <= i_1) \/
    (i_2 < 0) \/ (i <= i_2) \/ (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_2))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (13/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____13
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (13/27)":
*)
goal goal13:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((i <> 0) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (exists i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] <> t_1[(shift_sint8 a i_2)]) /\
     (0 <= i_2) /\ (i_2 < i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (14/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____14
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (14/27)":
*)
goal goal14:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((i <> 0) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (forall i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)]) \/ (i_2 < 0) \/
     (i_1 < i_2))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (15/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____15
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (15/27)":
*)
goal goal15:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((exists i_1 : int.
    (t_1[(shift_sint8 a_1 i_1)] <> t_1[(shift_sint8 a i_1)]) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_2 i_1 : int. (i_2 = i_1) \/ (i_1 < 0) \/ (i <= i_1) \/
    (i_2 < 0) \/ (i <= i_2) \/ (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_2))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (16/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____16
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (16/27)":
*)
goal goal16:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((forall i_1 : int.
    (t_1[(shift_sint8 a_1 i_1)] = t_1[(shift_sint8 a i_1)]) \/ (i_1 < 0) \/
    (i <= i_1)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_2 i_1 : int. (i_2 = i_1) \/ (i_1 < 0) \/ (i <= i_1) \/
    (i_2 < 0) \/ (i <= i_2) \/ (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_2))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (17/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____17
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (17/27)":
*)
goal goal17:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((forall i_2 i_1 : int. (i_2 = i_1) \/ (i_1 < 0) \/ (i <= i_1) \/
    (i_2 < 0) \/ (i <= i_2) \/ (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_2))) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (exists i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] <> t_1[(shift_sint8 a i_2)]) /\
     (0 <= i_2) /\ (i_2 < i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (18/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____18
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (18/27)":
*)
goal goal18:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((forall i_2 i_1 : int. (i_2 = i_1) \/ (i_1 < 0) \/ (i <= i_1) \/
    (i_2 < 0) \/ (i <= i_2) \/ (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_2))) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (forall i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)]) \/ (i_2 < 0) \/
     (i_1 < i_2))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (19/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____19
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (19/27)":
*)
goal goal19:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (forall i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)]) \/ (i_2 < 0) \/
     (i_1 < i_2))) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (exists i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] <> t_1[(shift_sint8 a i_2)]) /\
     (0 <= i_2) /\ (i_2 < i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (20/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____20
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (20/27)":
*)
goal goal20:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1))) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (exists i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] <> t_1[(shift_sint8 a i_2)]) /\
     (0 <= i_2) /\ (i_2 < i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (21/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____21
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (21/27)":
*)
goal goal21:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1))) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (forall i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)]) \/ (i_2 < 0) \/
     (i_1 < i_2))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (22/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____22
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (22/27)":
*)
goal goal22:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a_1 i_1))) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (exists i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] <> t_1[(shift_sint8 a i_2)]) /\
     (0 <= i_2) /\ (i_2 < i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (23/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____23
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (23/27)":
*)
goal goal23:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a_1 i_1))) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (forall i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)]) \/ (i_2 < 0) \/
     (i_1 < i_2))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (24/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____24
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (24/27)":
*)
goal goal24:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((exists i_1 : int.
    (t_1[(shift_sint8 a_1 i_1)] <> t_1[(shift_sint8 a i_1)]) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (exists i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] <> t_1[(shift_sint8 a i_2)]) /\
     (0 <= i_2) /\ (i_2 < i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (25/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____25
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (25/27)":
*)
goal goal25:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((exists i_1 : int.
    (t_1[(shift_sint8 a_1 i_1)] <> t_1[(shift_sint8 a i_1)]) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (forall i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)]) \/ (i_2 < 0) \/
     (i_1 < i_2))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (26/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____26
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (26/27)":
*)
goal goal26:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((forall i_1 : int.
    (t_1[(shift_sint8 a_1 i_1)] = t_1[(shift_sint8 a i_1)]) \/ (i_1 < 0) \/
    (i <= i_1)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (exists i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] <> t_1[(shift_sint8 a i_2)]) /\
     (0 <= i_2) /\ (i_2 < i_1))))

end

(* ---------------------------------------------------------- *)
(* --- Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (27/27) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_disjoint_zero_s2_smaller_s1_smaller_s1_s2_smaller____27
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Disjoint behaviors 'zero', 's2_smaller', 's1_smaller', 's1_s2_smaller',
                   'larger_n_not_eq', 'larger_n_eq', 'normal_n_not_eq',
                   'normal_n_eq' (27/27)":
*)
goal goal27:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((forall i_1 : int.
    (t_1[(shift_sint8 a_1 i_1)] = t_1[(shift_sint8 a i_1)]) \/ (i_1 < 0) \/
    (i <= i_1)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (exists i_1 : int. (t_1[(shift_sint8 a_1 i_1)] = 0) /\ (0 <= i_1) /\
    (i_1 < i)) \/
   (forall i_1 : int. (i_1 < 0) \/ (i <= i_1) \/
    (not (p_length_of_str_is t t_1 a i_1)) \/
    (not (p_length_of_str_is t t_1 a_1 i_1)) \/
    (forall i_2 : int.
     (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)]) \/ (i_2 < 0) \/
     (i_1 < i_2))))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file strncmp.c, line 70) (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_loop_inv_3_preserved_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file strncmp.c, line 70) (1/2)":
*)
goal goal28:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = i_1 - i in
  let a_2 = (shift_sint8 a x) in
  let x_1 = t_1[a_2] in
  let a_3 = (shift_sint8 a_1 x) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i <> 0) ->
  (x_1 <> 0) ->
  (t_1[a_3] = x_1) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_4 i_1)) ->
  ((valid_rw t a_5 i_1)) ->
  ((separated a_5 i_1 a_4 i_1)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 ((shift_sint8 a i_1)))) ->
  ((addr_le a_3 ((shift_sint8 a_1 i_1)))) ->
  ((is_sint8 x_1)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])) ->
  (((to_uint32 (i - 1))) <= i_1)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file strncmp.c, line 71) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_loop_inv_4_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file strncmp.c, line 71)":
*)
goal goal29:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = i_1 - i in
  let a_2 = (shift_sint8 a x) in
  let x_1 = t_1[a_2] in
  let a_3 = (shift_sint8 a_1 x) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i <> 0) ->
  (x_1 <> 0) ->
  (t_1[a_3] = x_1) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (0 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((i_2 + ((to_uint32 (i - 1)))) < i_1) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_4 i_1)) ->
  ((valid_rw t a_5 i_1)) ->
  ((separated a_5 i_1 a_4 i_1)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 ((shift_sint8 a i_1)))) ->
  ((addr_le a_3 ((shift_sint8 a_1 i_1)))) ->
  ((is_sint8 x_1)) ->
  (forall i_3 : int. (0 <= i_3) -> ((i_3 + i) < i_1) ->
   (t_1[(shift_sint8 a_1 i_3)] = t_1[(shift_sint8 a i_3)])) ->
  (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file strncmp.c, line 72) (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_loop_inv_5_preserved_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file strncmp.c, line 72) (1/2)":
*)
goal goal30:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = - i in
  let x_1 = i_1 - i in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = t_1[a_2] in
  let a_3 = (shift_sint8 a x_1) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i <> 0) ->
  (x_2 <> 0) ->
  (x_2 = t_1[a_3]) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_4 i_1)) ->
  ((valid_rw t a_5 i_1)) ->
  ((separated a_4 i_1 a_5 i_1)) ->
  ((addr_le a a_3)) ->
  ((addr_le a_1 a_2)) ->
  ((addr_le a_3 ((shift_sint8 a i_1)))) ->
  ((addr_le a_2 ((shift_sint8 a_1 i_1)))) ->
  ((is_sint8 x_2)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])) ->
  ((addr_le a ((shift_sint8 a (1 + i_1 - i)))))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file strncmp.c, line 72) (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_loop_inv_5_preserved_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file strncmp.c, line 72) (2/2)":
*)
goal goal31:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = - i in
  let x_1 = i_1 - i in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = t_1[a_2] in
  let a_3 = (shift_sint8 a x_1) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  let a_6 = (shift_sint8 a i_1) in
  (i <> 0) ->
  (x_2 <> 0) ->
  (x_2 = t_1[a_3]) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_4 i_1)) ->
  ((valid_rw t a_5 i_1)) ->
  ((separated a_4 i_1 a_5 i_1)) ->
  ((addr_le a a_3)) ->
  ((addr_le a_1 a_2)) ->
  ((addr_le a_3 a_6)) ->
  ((addr_le a_2 ((shift_sint8 a_1 i_1)))) ->
  ((is_sint8 x_2)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])) ->
  ((addr_le ((shift_sint8 a (1 + i_1 - i))) a_6))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file strncmp.c, line 72) (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_loop_inv_5_established_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Establishment of Invariant (file strncmp.c, line 72) (1/2)":
*)
goal goal32:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((addr_le a_1 a_1))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file strncmp.c, line 72) (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_loop_inv_5_established_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Establishment of Invariant (file strncmp.c, line 72) (2/2)":
*)
goal goal33:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_3 i a_2 i)) ->
  ((addr_le a_1 ((shift_sint8 a_1 i))))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file strncmp.c, line 73) (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_loop_inv_6_preserved_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file strncmp.c, line 73) (1/2)":
*)
goal goal34:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = - i in
  let x_1 = i_1 - i in
  let a_2 = (shift_sint8 a x_1) in
  let x_2 = t_1[a_2] in
  let a_3 = (shift_sint8 a_1 x_1) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i <> 0) ->
  (x_2 <> 0) ->
  (t_1[a_3] = x_2) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_4 i_1)) ->
  ((valid_rw t a_5 i_1)) ->
  ((separated a_5 i_1 a_4 i_1)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 ((shift_sint8 a i_1)))) ->
  ((addr_le a_3 ((shift_sint8 a_1 i_1)))) ->
  ((is_sint8 x_2)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])) ->
  ((addr_le a ((shift_sint8 a (1 + i_1 - i)))))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file strncmp.c, line 73) (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_loop_inv_6_preserved_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file strncmp.c, line 73) (2/2)":
*)
goal goal35:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = - i in
  let x_1 = i_1 - i in
  let a_2 = (shift_sint8 a x_1) in
  let x_2 = t_1[a_2] in
  let a_3 = (shift_sint8 a_1 x_1) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  let a_6 = (shift_sint8 a i_1) in
  (i <> 0) ->
  (x_2 <> 0) ->
  (t_1[a_3] = x_2) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_4 i_1)) ->
  ((valid_rw t a_5 i_1)) ->
  ((separated a_5 i_1 a_4 i_1)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 a_6)) ->
  ((addr_le a_3 ((shift_sint8 a_1 i_1)))) ->
  ((is_sint8 x_2)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])) ->
  ((addr_le ((shift_sint8 a (1 + i_1 - i))) a_6))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file strncmp.c, line 73) (1/2) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_loop_inv_6_established_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Establishment of Invariant (file strncmp.c, line 73) (1/2)":
*)
goal goal36:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_2 i a_3 i)) ->
  ((addr_le a_1 a_1))

end

(* ---------------------------------------------------------- *)
(* --- Establishment of Invariant (file strncmp.c, line 73) (2/2) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_loop_inv_6_established_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Establishment of Invariant (file strncmp.c, line 73) (2/2)":
*)
goal goal37:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a 0) in
  let a_3 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((valid_rw t a_2 i)) ->
  ((valid_rw t a_3 i)) ->
  ((separated a_2 i a_3 i)) ->
  ((addr_le a_1 ((shift_sint8 a_1 i))))

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file strncmp.c, line 74) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_loop_inv_7_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file strncmp.c, line 74)":
*)
goal goal38:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = i_1 - i in
  let a_2 = (shift_sint8 a_1 x) in
  let x_1 = t_1[a_2] in
  let a_3 = (shift_sint8 a x) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i <> 0) ->
  (x_1 <> 0) ->
  (x_1 = t_1[a_3]) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_4 i_1)) ->
  ((valid_rw t a_5 i_1)) ->
  ((separated a_4 i_1 a_5 i_1)) ->
  ((addr_le a a_3)) ->
  ((addr_le a_1 a_2)) ->
  ((addr_le a_3 ((shift_sint8 a i_1)))) ->
  ((addr_le a_2 ((shift_sint8 a_1 i_1)))) ->
  ((is_sint8 x_1)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])) ->
  ((1 + ((to_uint32 (i - 1)))) = i)

end

(* ---------------------------------------------------------- *)
(* --- Preservation of Invariant (file strncmp.c, line 75) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_loop_inv_8_preserved
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Preservation of Invariant (file strncmp.c, line 75)":
*)
goal goal39:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = i_1 - i in
  let a_2 = (shift_sint8 a x) in
  let x_1 = t_1[a_2] in
  let a_3 = (shift_sint8 a_1 x) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i <> 0) ->
  (x_1 <> 0) ->
  (t_1[a_3] = x_1) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_4 i_1)) ->
  ((valid_rw t a_5 i_1)) ->
  ((separated a_5 i_1 a_4 i_1)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 ((shift_sint8 a i_1)))) ->
  ((addr_le a_3 ((shift_sint8 a_1 i_1)))) ->
  ((is_sint8 x_1)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])) ->
  ((1 + ((to_uint32 (i - 1)))) = i)

end

(* ---------------------------------------------------------- *)
(* --- Decreasing of Loop variant at loop (file strncmp.c, line 80) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_loop_term_decrease
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Decreasing of Loop variant at loop (file strncmp.c, line 80)":
*)
goal goal40:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = i_1 - i in
  let a_2 = (shift_sint8 a x) in
  let x_1 = t_1[a_2] in
  let a_3 = (shift_sint8 a_1 x) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i <> 0) ->
  (x_1 <> 0) ->
  (t_1[a_3] = x_1) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_4 i_1)) ->
  ((valid_rw t a_5 i_1)) ->
  ((separated a_5 i_1 a_4 i_1)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 ((shift_sint8 a i_1)))) ->
  ((addr_le a_3 ((shift_sint8 a_1 i_1)))) ->
  ((is_sint8 x_1)) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i) < i_1) ->
   (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])) ->
  (((to_uint32 (i - 1))) < i)

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'larger_n_eq' (file strncmp.c, line 30) in 'strncmp' (1/3) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_larger_n_eq_post_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Post-condition for 'larger_n_eq' (file strncmp.c, line 30) in 'strncmp' (1/3)":
*)
goal goal41:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = i - i_1 in
  let a_2 = (shift_sint8 a_1 x) in
  let x_1 = t_1[a_2] in
  let a_3 = (shift_sint8 a x) in
  let x_2 = t_1[a_3] in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i_1 <> 0) ->
  (x_1 <> x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_4 i)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i)) ->
  ((addr_le a a_3)) ->
  ((addr_le a_1 a_2)) ->
  ((addr_le a_3 ((shift_sint8 a i)))) ->
  ((addr_le a_2 ((shift_sint8 a_1 i)))) ->
  ((is_sint8 x_2)) ->
  ((is_sint8 x_1)) ->
  ((is_sint32 (x_1 - x_2))) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])) ->
  (forall i_2 : int. (0 <= i_2) -> ((i_2 + i_1) < i) ->
   (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (t_1[(shift_sint8 a i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (t_1[(shift_sint8 a_1 i_2)] <> 0)) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'larger_n_not_eq' (file strncmp.c, line 36) in 'strncmp' (2/3) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_larger_n_not_eq_post_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Post-condition for 'larger_n_not_eq' (file strncmp.c, line 36) in 'strncmp' (2/3)":
*)
goal goal42:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = i - i_1 in
  let a_2 = (shift_sint8 a x) in
  let a_3 = (shift_sint8 a_1 x) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i_1 <> 0) ->
  (t_1[(shift_sint8 a_1 i_2)] <> t_1[(shift_sint8 a i_2)]) ->
  (t_1[a_2] = 0) ->
  (t_1[a_3] = 0) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (i_2 < i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_4 i)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 ((shift_sint8 a i)))) ->
  ((addr_le a_3 ((shift_sint8 a_1 i)))) ->
  (forall i_3 : int. (0 <= i_3) -> ((i_3 + i_1) < i) ->
   (t_1[(shift_sint8 a_1 i_3)] = t_1[(shift_sint8 a i_3)])) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i) ->
   (t_1[(shift_sint8 a i_3)] <> 0)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i) ->
   (t_1[(shift_sint8 a_1 i_3)] <> 0)) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'larger_n_not_eq' (file strncmp.c, line 36) in 'strncmp' (3/3) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_larger_n_not_eq_post_part3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint

(*
goal WP "expl:Post-condition for 'larger_n_not_eq' (file strncmp.c, line 36) in 'strncmp' (3/3)":
*)
goal goal43:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a i) in
  let a_3 = (shift_sint8 a_1 i) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (t_1[(shift_sint8 a_1 i_1)] <> t_1[(shift_sint8 a i_1)]) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i_1 < i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 a_2)) ->
  ((addr_le a_3 a_3)) ->
  ((valid_rw t a_4 i)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (t_1[(shift_sint8 a i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (t_1[(shift_sint8 a_1 i_2)] <> 0)) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'normal_n_eq' (file strncmp.c, line 19) in 'strncmp' (1/3) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_normal_n_eq_post_part1
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'normal_n_eq' (file strncmp.c, line 19) in 'strncmp' (1/3)":
*)
goal goal44:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = i - i_1 in
  let a_2 = (shift_sint8 a_1 x) in
  let x_1 = t_1[a_2] in
  let a_3 = (shift_sint8 a x) in
  let x_2 = t_1[a_3] in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i_1 <> 0) ->
  (x_1 <> x_2) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (i_2 < i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((p_length_of_str_is t t_1 a i_2)) ->
  ((p_length_of_str_is t t_1 a_1 i_2)) ->
  ((valid_rw t a_4 i)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i)) ->
  ((addr_le a a_3)) ->
  ((addr_le a_1 a_2)) ->
  ((addr_le a_3 ((shift_sint8 a i)))) ->
  ((addr_le a_2 ((shift_sint8 a_1 i)))) ->
  ((is_sint8 x_2)) ->
  ((is_sint8 x_1)) ->
  ((is_sint32 (x_1 - x_2))) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i_2) ->
   (t_1[(shift_sint8 a_1 i_3)] = t_1[(shift_sint8 a i_3)])) ->
  (forall i_3 : int. (0 <= i_3) -> ((i_3 + i_1) < i) ->
   (t_1[(shift_sint8 a_1 i_3)] = t_1[(shift_sint8 a i_3)])) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'normal_n_not_eq' (file strncmp.c, line 24) in 'strncmp' (2/3) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_normal_n_not_eq_post_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'normal_n_not_eq' (file strncmp.c, line 24) in 'strncmp' (2/3)":
*)
goal goal45:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = i - i_1 in
  let a_2 = (shift_sint8 a x) in
  let a_3 = (shift_sint8 a_1 x) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i_1 <> 0) ->
  (t_1[(shift_sint8 a_1 i_2)] <> t_1[(shift_sint8 a i_2)]) ->
  (t_1[a_2] = 0) ->
  (t_1[a_3] = 0) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (0 <= i_3) ->
  (i_3 < i) ->
  (i_2 <= i_3) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((p_length_of_str_is t t_1 a i_3)) ->
  ((p_length_of_str_is t t_1 a_1 i_3)) ->
  ((valid_rw t a_4 i)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 ((shift_sint8 a i)))) ->
  ((addr_le a_3 ((shift_sint8 a_1 i)))) ->
  (forall i_4 : int. (0 <= i_4) -> ((i_4 + i_1) < i) ->
   (t_1[(shift_sint8 a_1 i_4)] = t_1[(shift_sint8 a i_4)])) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 'normal_n_not_eq' (file strncmp.c, line 24) in 'strncmp' (3/3) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_normal_n_not_eq_post_part3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 'normal_n_not_eq' (file strncmp.c, line 24) in 'strncmp' (3/3)":
*)
goal goal46:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a i) in
  let a_3 = (shift_sint8 a_1 i) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (t_1[(shift_sint8 a_1 i_1)] <> t_1[(shift_sint8 a i_1)]) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (i_2 < i) ->
  (i_1 <= i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((p_length_of_str_is t t_1 a i_2)) ->
  ((p_length_of_str_is t t_1 a_1 i_2)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 a_2)) ->
  ((addr_le a_3 a_3)) ->
  ((valid_rw t a_4 i)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i) ->
   (t_1[(shift_sint8 a_1 i_3)] = t_1[(shift_sint8 a i_3)])) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 's1_s2_smaller' (file strncmp.c, line 41) in 'strncmp' (2/3) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_s1_s2_smaller_post_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 's1_s2_smaller' (file strncmp.c, line 41) in 'strncmp' (2/3)":
*)
goal goal47:
  forall i_3 i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = i - i_1 in
  let a_2 = (shift_sint8 a x) in
  let a_3 = (shift_sint8 a_1 x) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i_1 <> 0) ->
  (i_3 <> i_2) ->
  (t_1[a_2] = 0) ->
  (t_1[a_3] = 0) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (i_2 < i) ->
  (0 <= i_3) ->
  (i_3 < i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((p_length_of_str_is t t_1 a i_2)) ->
  ((p_length_of_str_is t t_1 a_1 i_3)) ->
  ((valid_rw t a_4 i)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 ((shift_sint8 a i)))) ->
  ((addr_le a_3 ((shift_sint8 a_1 i)))) ->
  (forall i_4 : int. (0 <= i_4) -> ((i_4 + i_1) < i) ->
   (t_1[(shift_sint8 a_1 i_4)] = t_1[(shift_sint8 a i_4)])) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 's1_s2_smaller' (file strncmp.c, line 41) in 'strncmp' (3/3) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_s1_s2_smaller_post_part3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Compound.Compound

(*
goal WP "expl:Post-condition for 's1_s2_smaller' (file strncmp.c, line 41) in 'strncmp' (3/3)":
*)
goal goal48:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a i) in
  let a_3 = (shift_sint8 a_1 i) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i_2 <> i_1) ->
  (0 <= i) ->
  (0 <= i_1) ->
  (i_1 < i) ->
  (0 <= i_2) ->
  (i_2 < i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((p_length_of_str_is t t_1 a i_1)) ->
  ((p_length_of_str_is t t_1 a_1 i_2)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 a_2)) ->
  ((addr_le a_3 a_3)) ->
  ((valid_rw t a_4 i)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i) ->
   (t_1[(shift_sint8 a_1 i_3)] = t_1[(shift_sint8 a i_3)])) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 's1_smaller' (file strncmp.c, line 46) in 'strncmp' (2/3) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_s1_smaller_post_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 's1_smaller' (file strncmp.c, line 46) in 'strncmp' (2/3)":
*)
goal goal49:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = i - i_1 in
  let a_2 = (shift_sint8 a x) in
  let a_3 = (shift_sint8 a_1 x) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i_1 <> 0) ->
  (t_1[a_2] = 0) ->
  (t_1[a_3] = 0) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (i_2 < i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((p_length_of_str_is t t_1 a_1 i_2)) ->
  ((valid_rw t a_4 i)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 ((shift_sint8 a i)))) ->
  ((addr_le a_3 ((shift_sint8 a_1 i)))) ->
  (forall i_3 : int. (0 <= i_3) -> ((i_3 + i_1) < i) ->
   (t_1[(shift_sint8 a_1 i_3)] = t_1[(shift_sint8 a i_3)])) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i) ->
   (t_1[(shift_sint8 a i_3)] <> 0)) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 's1_smaller' (file strncmp.c, line 46) in 'strncmp' (3/3) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_s1_smaller_post_part3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Compound.Compound

(*
goal WP "expl:Post-condition for 's1_smaller' (file strncmp.c, line 46) in 'strncmp' (3/3)":
*)
goal goal50:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a i) in
  let a_3 = (shift_sint8 a_1 i) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (0 <= i_1) ->
  (i_1 < i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((p_length_of_str_is t t_1 a_1 i_1)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 a_2)) ->
  ((addr_le a_3 a_3)) ->
  ((valid_rw t a_4 i)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (t_1[(shift_sint8 a i_2)] <> 0)) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 's2_smaller' (file strncmp.c, line 51) in 'strncmp' (2/3) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_s2_smaller_post_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Compound.Compound
use import Cint.Cint
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition for 's2_smaller' (file strncmp.c, line 51) in 'strncmp' (2/3)":
*)
goal goal51:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = i - i_1 in
  let a_2 = (shift_sint8 a x) in
  let a_3 = (shift_sint8 a_1 x) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (i_1 <> 0) ->
  (t_1[a_2] = 0) ->
  (t_1[a_3] = 0) ->
  (0 <= i) ->
  (i_1 <= i) ->
  (0 <= i_1) ->
  (0 <= i_2) ->
  (i_2 < i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((p_length_of_str_is t t_1 a i_2)) ->
  ((valid_rw t a_4 i)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 ((shift_sint8 a i)))) ->
  ((addr_le a_3 ((shift_sint8 a_1 i)))) ->
  (forall i_3 : int. (0 <= i_3) -> ((i_3 + i_1) < i) ->
   (t_1[(shift_sint8 a_1 i_3)] = t_1[(shift_sint8 a i_3)])) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i) ->
   (t_1[(shift_sint8 a_1 i_3)] <> 0)) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Post-condition for 's2_smaller' (file strncmp.c, line 51) in 'strncmp' (3/3) --- *)
(* ---------------------------------------------------------- *)
theory VCstrncmp_s2_smaller_post_part3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Axiomatic.Axiomatic
use import Compound.Compound

(*
goal WP "expl:Post-condition for 's2_smaller' (file strncmp.c, line 51) in 'strncmp' (3/3)":
*)
goal goal52:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let a_2 = (shift_sint8 a i) in
  let a_3 = (shift_sint8 a_1 i) in
  let a_4 = (shift_sint8 a 0) in
  let a_5 = (shift_sint8 a_1 0) in
  (0 <= i) ->
  (0 <= i_1) ->
  (i_1 < i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint32 i)) ->
  ((p_length_of_str_is t t_1 a i_1)) ->
  ((addr_le a a_2)) ->
  ((addr_le a_1 a_3)) ->
  ((addr_le a_2 a_2)) ->
  ((addr_le a_3 a_3)) ->
  ((valid_rw t a_4 i)) ->
  ((valid_rw t a_5 i)) ->
  ((separated a_5 i a_4 i)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (t_1[(shift_sint8 a_1 i_2)] = t_1[(shift_sint8 a i_2)])) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (t_1[(shift_sint8 a_1 i_2)] <> 0)) ->
  false

end

