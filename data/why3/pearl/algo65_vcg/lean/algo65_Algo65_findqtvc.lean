import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
open Classical
open Lean4Why3
namespace algo65_Algo65_findqtvc
theorem find'vc (m : ℤ) (k : ℤ) (n : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ m) (fact1 : m ≤ k) (fact2 : k ≤ n) (fact3 : n < Int.ofNat (List.length a)) : if m < n then ((0 : ℤ) ≤ m ∧ m < n ∧ n < Int.ofNat (List.length a)) ∧ (∀(j : ℤ) (i : ℤ) (a1 : List ℤ), List.length a1 = List.length a → (m ≤ j ∧ j < i ∧ i ≤ n) ∧ List.permut_sub' a a1 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), m ≤ r ∧ r ≤ j → a1[Int.toNat r]! ≤ (42 : ℤ)) ∧ (∀(r : ℤ), j < r ∧ r < i → a1[Int.toNat r]! = (42 : ℤ)) ∧ (∀(r : ℤ), i ≤ r ∧ r ≤ n → (42 : ℤ) ≤ a1[Int.toNat r]!) → (if k ≤ j then (((0 : ℤ) ≤ n - m ∧ j - m < n - m) ∧ (0 : ℤ) ≤ m ∧ m ≤ k ∧ k ≤ j ∧ j < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → List.permut_sub' a1 a2 (Int.toNat m) (Int.toNat (j + (1 : ℤ))) ∧ (∀(r : ℤ), m ≤ r ∧ r ≤ k → a2[Int.toNat r]! ≤ a2[Int.toNat k]!) ∧ (∀(r : ℤ), k ≤ r ∧ r ≤ j → a2[Int.toNat k]! ≤ a2[Int.toNat r]!) → (if i ≤ k then (((0 : ℤ) ≤ n - m ∧ n - i < n - m) ∧ (0 : ℤ) ≤ i ∧ i ≤ k ∧ k ≤ n ∧ n < Int.ofNat (List.length a2)) ∧ (∀(a3 : List ℤ), List.length a3 = List.length a2 → List.permut_sub' a2 a3 (Int.toNat i) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), i ≤ r ∧ r ≤ k → a3[Int.toNat r]! ≤ a3[Int.toNat k]!) ∧ (∀(r : ℤ), k ≤ r ∧ r ≤ n → a3[Int.toNat k]! ≤ a3[Int.toNat r]!) → List.permut_sub' a a3 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), m ≤ r ∧ r ≤ k → a3[Int.toNat r]! ≤ a3[Int.toNat k]!) ∧ (∀(r : ℤ), k ≤ r ∧ r ≤ n → a3[Int.toNat k]! ≤ a3[Int.toNat r]!)) else List.permut_sub' a a2 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), m ≤ r ∧ r ≤ k → a2[Int.toNat r]! ≤ a2[Int.toNat k]!) ∧ (∀(r : ℤ), k ≤ r ∧ r ≤ n → a2[Int.toNat k]! ≤ a2[Int.toNat r]!))) else if i ≤ k then (((0 : ℤ) ≤ n - m ∧ n - i < n - m) ∧ (0 : ℤ) ≤ i ∧ i ≤ k ∧ k ≤ n ∧ n < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → List.permut_sub' a1 a2 (Int.toNat i) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), i ≤ r ∧ r ≤ k → a2[Int.toNat r]! ≤ a2[Int.toNat k]!) ∧ (∀(r : ℤ), k ≤ r ∧ r ≤ n → a2[Int.toNat k]! ≤ a2[Int.toNat r]!) → List.permut_sub' a a2 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), m ≤ r ∧ r ≤ k → a2[Int.toNat r]! ≤ a2[Int.toNat k]!) ∧ (∀(r : ℤ), k ≤ r ∧ r ≤ n → a2[Int.toNat k]! ≤ a2[Int.toNat r]!)) else List.permut_sub' a a1 (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), m ≤ r ∧ r ≤ k → a1[Int.toNat r]! ≤ a1[Int.toNat k]!) ∧ (∀(r : ℤ), k ≤ r ∧ r ≤ n → a1[Int.toNat k]! ≤ a1[Int.toNat r]!))) else List.permut_sub' a a (Int.toNat m) (Int.toNat (n + (1 : ℤ))) ∧ (∀(r : ℤ), m ≤ r ∧ r ≤ k → a[Int.toNat r]! ≤ a[Int.toNat k]!) ∧ (∀(r : ℤ), k ≤ r ∧ r ≤ n → a[Int.toNat k]! ≤ a[Int.toNat r]!)
  := sorry
end algo65_Algo65_findqtvc
