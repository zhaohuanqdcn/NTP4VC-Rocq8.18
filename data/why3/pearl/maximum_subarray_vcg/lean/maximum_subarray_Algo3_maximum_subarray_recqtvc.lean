import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Sum
import pearl.maximum_subarray_vcg.lean.maximum_subarray.Spec
open Classical
open Lean4Why3
namespace maximum_subarray_Algo3_maximum_subarray_recqtvc
theorem maximum_subarray_rec'vc (l : ℤ) (h : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ l) (fact1 : l ≤ h) (fact2 : h ≤ Int.ofNat (List.length a)) : if h = l then ((l ≤ l ∧ l ≤ h ∧ h ≤ h) ∧ (0 : ℤ) = List.sum (List.drop (Int.toNat l) (List.take (Int.toNat h - Int.toNat l) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ (0 : ℤ)) else ¬(2 : ℤ) = (0 : ℤ) ∧ (let mid : ℤ := l + Int.tdiv (h - l) (2 : ℤ); let o1 : ℤ := mid - (1 : ℤ); (l - (1 : ℤ) ≤ o1 → (((l ≤ mid ∧ mid ≤ mid) ∧ (0 : ℤ) = List.sum (List.drop (Int.toNat mid) (List.take (Int.toNat mid - Int.toNat mid) a))) ∧ (∀(l' : ℤ), o1 < l' ∧ l' ≤ mid → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat mid - Int.toNat l') a)) ≤ (0 : ℤ)) ∧ (0 : ℤ) = List.sum (List.drop (Int.toNat (o1 + (1 : ℤ))) (List.take (Int.toNat mid - Int.toNat (o1 + (1 : ℤ))) a))) ∧ (∀(s : ℤ) (ms : ℤ) (lo : ℤ), (∀(i : ℤ), (i ≤ o1 ∧ l ≤ i) ∧ ((l ≤ lo ∧ lo ≤ mid) ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat mid - Int.toNat lo) a))) ∧ (∀(l' : ℤ), i < l' ∧ l' ≤ mid → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat mid - Int.toNat l') a)) ≤ ms) ∧ s = List.sum (List.drop (Int.toNat (i + (1 : ℤ))) (List.take (Int.toNat mid - Int.toNat (i + (1 : ℤ))) a)) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if ms < s + a[Int.toNat i]! then ((l ≤ i ∧ i ≤ mid) ∧ s + a[Int.toNat i]! = List.sum (List.drop (Int.toNat i) (List.take (Int.toNat mid - Int.toNat i) a))) ∧ (∀(l' : ℤ), i - (1 : ℤ) < l' ∧ l' ≤ mid → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat mid - Int.toNat l') a)) ≤ s + a[Int.toNat i]!) ∧ s + a[Int.toNat i]! = List.sum (List.drop (Int.toNat (i - (1 : ℤ) + (1 : ℤ))) (List.take (Int.toNat mid - Int.toNat (i - (1 : ℤ) + (1 : ℤ))) a)) else ((l ≤ lo ∧ lo ≤ mid) ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat mid - Int.toNat lo) a))) ∧ (∀(l' : ℤ), i - (1 : ℤ) < l' ∧ l' ≤ mid → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat mid - Int.toNat l') a)) ≤ ms) ∧ s + a[Int.toNat i]! = List.sum (List.drop (Int.toNat (i - (1 : ℤ) + (1 : ℤ))) (List.take (Int.toNat mid - Int.toNat (i - (1 : ℤ) + (1 : ℤ))) a)))) ∧ (((l ≤ lo ∧ lo ≤ mid) ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat mid - Int.toNat lo) a))) ∧ (∀(l' : ℤ), l - (1 : ℤ) < l' ∧ l' ≤ mid → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat mid - Int.toNat l') a)) ≤ ms) ∧ s = List.sum (List.drop (Int.toNat (l - (1 : ℤ) + (1 : ℤ))) (List.take (Int.toNat mid - Int.toNat (l - (1 : ℤ) + (1 : ℤ))) a)) → (let o2 : ℤ := h - (1 : ℤ); (mid ≤ o2 + (1 : ℤ) → (((l ≤ lo ∧ lo ≤ mid ∧ mid ≤ mid ∧ mid ≤ h) ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat mid - Int.toNat lo) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ mid ∧ mid ≤ h' ∧ h' ≤ mid → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms) ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat mid - Int.toNat lo) a))) ∧ (∀(s1 : ℤ) (ms1 : ℤ) (hi : ℤ), (∀(i : ℤ), (mid ≤ i ∧ i ≤ o2) ∧ ((l ≤ lo ∧ lo ≤ mid ∧ mid ≤ hi ∧ hi ≤ h) ∧ ms1 = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ mid ∧ mid ≤ h' ∧ h' ≤ i → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms1) ∧ s1 = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat i - Int.toNat lo) a)) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if ms1 < s1 + a[Int.toNat i]! then ((l ≤ lo ∧ lo ≤ mid ∧ mid ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ h) ∧ s1 + a[Int.toNat i]! = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat lo) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ mid ∧ mid ≤ h' ∧ h' ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ s1 + a[Int.toNat i]!) ∧ s1 + a[Int.toNat i]! = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat lo) a)) else ((l ≤ lo ∧ lo ≤ mid ∧ mid ≤ hi ∧ hi ≤ h) ∧ ms1 = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ mid ∧ mid ≤ h' ∧ h' ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms1) ∧ s1 + a[Int.toNat i]! = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat lo) a)))) ∧ (((l ≤ lo ∧ lo ≤ mid ∧ mid ≤ hi ∧ hi ≤ h) ∧ ms1 = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ mid ∧ mid ≤ h' ∧ h' ≤ o2 + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms1) ∧ s1 = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat (o2 + (1 : ℤ)) - Int.toNat lo) a)) → (((0 : ℤ) ≤ h - l ∧ mid - l < h - l) ∧ (0 : ℤ) ≤ l ∧ l ≤ mid ∧ mid ≤ Int.ofNat (List.length a)) ∧ (∀(hi' : ℤ) (lo' : ℤ), (l ≤ lo' ∧ lo' ≤ hi' ∧ hi' ≤ mid) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ mid → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a))) → (if ms1 < List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a)) then let o3 : ℤ := mid + (1 : ℤ); (((0 : ℤ) ≤ h - l ∧ h - o3 < h - l) ∧ (0 : ℤ) ≤ o3 ∧ o3 ≤ h ∧ h ≤ Int.ofNat (List.length a)) ∧ (∀(hi'1 : ℤ) (lo'1 : ℤ), (o3 ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), o3 ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) → (if List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a)) < List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a)) then (l ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) else (l ≤ lo' ∧ lo' ≤ hi' ∧ hi' ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a))))) else let o3 : ℤ := mid + (1 : ℤ); (((0 : ℤ) ≤ h - l ∧ h - o3 < h - l) ∧ (0 : ℤ) ≤ o3 ∧ o3 ≤ h ∧ h ≤ Int.ofNat (List.length a)) ∧ (∀(hi'1 : ℤ) (lo'1 : ℤ), (o3 ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), o3 ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) → (if ms1 < List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a)) then (l ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) else ((l ≤ lo ∧ lo ≤ hi ∧ hi ≤ h) ∧ ms1 = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat hi - Int.toNat lo) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms1)))))))) ∧ (o2 + (1 : ℤ) < mid → (((0 : ℤ) ≤ h - l ∧ mid - l < h - l) ∧ (0 : ℤ) ≤ l ∧ l ≤ mid ∧ mid ≤ Int.ofNat (List.length a)) ∧ (∀(hi' : ℤ) (lo' : ℤ), (l ≤ lo' ∧ lo' ≤ hi' ∧ hi' ≤ mid) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ mid → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a))) → (if ms < List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a)) then let o3 : ℤ := mid + (1 : ℤ); (((0 : ℤ) ≤ h - l ∧ h - o3 < h - l) ∧ (0 : ℤ) ≤ o3 ∧ o3 ≤ h ∧ h ≤ Int.ofNat (List.length a)) ∧ (∀(hi'1 : ℤ) (lo'1 : ℤ), (o3 ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), o3 ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) → (if List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a)) < List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a)) then (l ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) else (l ≤ lo' ∧ lo' ≤ hi' ∧ hi' ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a))))) else let o3 : ℤ := mid + (1 : ℤ); (((0 : ℤ) ≤ h - l ∧ h - o3 < h - l) ∧ (0 : ℤ) ≤ o3 ∧ o3 ≤ h ∧ h ≤ Int.ofNat (List.length a)) ∧ (∀(hi'1 : ℤ) (lo'1 : ℤ), (o3 ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), o3 ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) → (if ms < List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a)) then (l ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) else ((l ≤ lo ∧ lo ≤ mid ∧ mid ≤ h) ∧ ms = List.sum (List.drop (Int.toNat lo) (List.take (Int.toNat mid - Int.toNat lo) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms)))))))))) ∧ (o1 < l - (1 : ℤ) → (let o2 : ℤ := h - (1 : ℤ); (mid ≤ o2 + (1 : ℤ) → (((l ≤ mid ∧ mid ≤ mid ∧ mid ≤ mid ∧ mid ≤ h) ∧ (0 : ℤ) = List.sum (List.drop (Int.toNat mid) (List.take (Int.toNat mid - Int.toNat mid) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ mid ∧ mid ≤ h' ∧ h' ≤ mid → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ (0 : ℤ)) ∧ (0 : ℤ) = List.sum (List.drop (Int.toNat mid) (List.take (Int.toNat mid - Int.toNat mid) a))) ∧ (∀(s : ℤ) (ms : ℤ) (hi : ℤ), (∀(i : ℤ), (mid ≤ i ∧ i ≤ o2) ∧ ((l ≤ mid ∧ mid ≤ mid ∧ mid ≤ hi ∧ hi ≤ h) ∧ ms = List.sum (List.drop (Int.toNat mid) (List.take (Int.toNat hi - Int.toNat mid) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ mid ∧ mid ≤ h' ∧ h' ≤ i → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms) ∧ s = List.sum (List.drop (Int.toNat mid) (List.take (Int.toNat i - Int.toNat mid) a)) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if ms < s + a[Int.toNat i]! then ((l ≤ mid ∧ mid ≤ mid ∧ mid ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ h) ∧ s + a[Int.toNat i]! = List.sum (List.drop (Int.toNat mid) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat mid) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ mid ∧ mid ≤ h' ∧ h' ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ s + a[Int.toNat i]!) ∧ s + a[Int.toNat i]! = List.sum (List.drop (Int.toNat mid) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat mid) a)) else ((l ≤ mid ∧ mid ≤ mid ∧ mid ≤ hi ∧ hi ≤ h) ∧ ms = List.sum (List.drop (Int.toNat mid) (List.take (Int.toNat hi - Int.toNat mid) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ mid ∧ mid ≤ h' ∧ h' ≤ i + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms) ∧ s + a[Int.toNat i]! = List.sum (List.drop (Int.toNat mid) (List.take (Int.toNat (i + (1 : ℤ)) - Int.toNat mid) a)))) ∧ (((l ≤ mid ∧ mid ≤ mid ∧ mid ≤ hi ∧ hi ≤ h) ∧ ms = List.sum (List.drop (Int.toNat mid) (List.take (Int.toNat hi - Int.toNat mid) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ mid ∧ mid ≤ h' ∧ h' ≤ o2 + (1 : ℤ) → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms) ∧ s = List.sum (List.drop (Int.toNat mid) (List.take (Int.toNat (o2 + (1 : ℤ)) - Int.toNat mid) a)) → (((0 : ℤ) ≤ h - l ∧ mid - l < h - l) ∧ (0 : ℤ) ≤ l ∧ l ≤ mid ∧ mid ≤ Int.ofNat (List.length a)) ∧ (∀(hi' : ℤ) (lo' : ℤ), (l ≤ lo' ∧ lo' ≤ hi' ∧ hi' ≤ mid) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ mid → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a))) → (if ms < List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a)) then let o3 : ℤ := mid + (1 : ℤ); (((0 : ℤ) ≤ h - l ∧ h - o3 < h - l) ∧ (0 : ℤ) ≤ o3 ∧ o3 ≤ h ∧ h ≤ Int.ofNat (List.length a)) ∧ (∀(hi'1 : ℤ) (lo'1 : ℤ), (o3 ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), o3 ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) → (if List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a)) < List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a)) then (l ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) else (l ≤ lo' ∧ lo' ≤ hi' ∧ hi' ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a))))) else let o3 : ℤ := mid + (1 : ℤ); (((0 : ℤ) ≤ h - l ∧ h - o3 < h - l) ∧ (0 : ℤ) ≤ o3 ∧ o3 ≤ h ∧ h ≤ Int.ofNat (List.length a)) ∧ (∀(hi'1 : ℤ) (lo'1 : ℤ), (o3 ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), o3 ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) → (if ms < List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a)) then (l ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) else ((l ≤ mid ∧ mid ≤ hi ∧ hi ≤ h) ∧ ms = List.sum (List.drop (Int.toNat mid) (List.take (Int.toNat hi - Int.toNat mid) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ ms)))))))) ∧ (o2 + (1 : ℤ) < mid → (((0 : ℤ) ≤ h - l ∧ mid - l < h - l) ∧ (0 : ℤ) ≤ l ∧ l ≤ mid ∧ mid ≤ Int.ofNat (List.length a)) ∧ (∀(hi' : ℤ) (lo' : ℤ), (l ≤ lo' ∧ lo' ≤ hi' ∧ hi' ≤ mid) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ mid → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a))) → (if (0 : ℤ) < List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a)) then let o3 : ℤ := mid + (1 : ℤ); (((0 : ℤ) ≤ h - l ∧ h - o3 < h - l) ∧ (0 : ℤ) ≤ o3 ∧ o3 ≤ h ∧ h ≤ Int.ofNat (List.length a)) ∧ (∀(hi'1 : ℤ) (lo'1 : ℤ), (o3 ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), o3 ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) → (if List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a)) < List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a)) then (l ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) else (l ≤ lo' ∧ lo' ≤ hi' ∧ hi' ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo') (List.take (Int.toNat hi' - Int.toNat lo') a))))) else let o3 : ℤ := mid + (1 : ℤ); (((0 : ℤ) ≤ h - l ∧ h - o3 < h - l) ∧ (0 : ℤ) ≤ o3 ∧ o3 ≤ h ∧ h ≤ Int.ofNat (List.length a)) ∧ (∀(hi'1 : ℤ) (lo'1 : ℤ), (o3 ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), o3 ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) → (if (0 : ℤ) < List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a)) then (l ≤ lo'1 ∧ lo'1 ≤ hi'1 ∧ hi'1 ≤ h) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ List.sum (List.drop (Int.toNat lo'1) (List.take (Int.toNat hi'1 - Int.toNat lo'1) a))) else ((l ≤ mid ∧ mid ≤ mid ∧ mid ≤ h) ∧ (0 : ℤ) = List.sum (List.drop (Int.toNat mid) (List.take (Int.toNat mid - Int.toNat mid) a))) ∧ (∀(l' : ℤ) (h' : ℤ), l ≤ l' ∧ l' ≤ h' ∧ h' ≤ h → List.sum (List.drop (Int.toNat l') (List.take (Int.toNat h' - Int.toNat l') a)) ≤ (0 : ℤ))))))))))
  := sorry
end maximum_subarray_Algo3_maximum_subarray_recqtvc
