theory verifythis_2017_odd_even_sort_rearranging_Top_array_maxqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_Sum" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut" "Why3STD.array_IntArraySorted"
begin
theorem array_max'vc:
  fixes a :: "int list"
  shows "if int (length a) = (0 :: int) then \<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length a) \<longrightarrow> a ! nat j \<le> (0 :: int) else ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length a)) \<and> (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> int (length a)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> a ! nat j \<le> a ! (0 :: nat))) \<and> (\<forall>(i :: int) (m :: int). ((0 :: int) \<le> i \<and> i \<le> int (length a)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> a ! nat j \<le> m) \<longrightarrow> (if i < int (length a) then ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if m < a ! nat i then ((0 :: int) \<le> i \<and> i < int (length a)) \<and> ((0 :: int) \<le> int (length a) - i \<and> int (length a) - (i + (1 :: int)) < int (length a) - i) \<and> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> int (length a)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> a ! nat j \<le> a ! nat i) else ((0 :: int) \<le> int (length a) - i \<and> int (length a) - (i + (1 :: int)) < int (length a) - i) \<and> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> int (length a)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> a ! nat j \<le> m)) else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < int (length a) \<longrightarrow> a ! nat j \<le> m))"
  sorry
end
