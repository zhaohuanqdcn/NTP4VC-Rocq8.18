import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace binary_search_vc_sp_BinarySearch_binary_searchqtvc
theorem binary_search'vc (a : List ℤ) (v : ℤ) (fact0 : ∀(i1 : ℤ) (i2 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ i2 ∧ i2 < Int.ofNat (List.length a) → a[Int.toNat i1]! ≤ a[Int.toNat i2]!) : (let o1 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); (((0 : ℤ) ≤ (0 : ℤ) ∧ o1 < Int.ofNat (List.length a)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → a[Int.toNat i]! = v → (0 : ℤ) ≤ i ∧ i ≤ o1)) ∧ (∀(l : ℤ) (u : ℤ), ((0 : ℤ) ≤ l ∧ u < Int.ofNat (List.length a)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → a[Int.toNat i]! = v → l ≤ i ∧ i ≤ u) → l ≤ u → (¬(2 : ℤ) = (0 : ℤ) ∧ (let m : ℤ := l + Int.tdiv (u - l) (2 : ℤ); ((0 : ℤ) ≤ m ∧ m < Int.ofNat (List.length a)) ∧ (¬a[Int.toNat m]! < v → (0 : ℤ) ≤ m ∧ m < Int.ofNat (List.length a)))) ∧ (∀(l1 : ℤ) (u1 : ℤ), (let m : ℤ := l + Int.tdiv (u - l) (2 : ℤ); if a[Int.toNat m]! < v then l1 = m + (1 : ℤ) ∧ u1 = u else (v < a[Int.toNat m]! ∧ u1 = m - (1 : ℤ)) ∧ l1 = l) → ((0 : ℤ) ≤ u - l ∧ u1 - l1 < u - l) ∧ ((0 : ℤ) ≤ l1 ∧ u1 < Int.ofNat (List.length a)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → a[Int.toNat i]! = v → l1 ≤ i ∧ i ≤ u1)))) ∧ ((∃(l : ℤ) (u : ℤ), (((0 : ℤ) ≤ l ∧ u < Int.ofNat (List.length a)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → a[Int.toNat i]! = v → l ≤ i ∧ i ≤ u)) ∧ ¬l ≤ u) → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → ¬a[Int.toNat i]! = v)) ∧ (∀(r : ℤ), (∃(l : ℤ) (u : ℤ), (((0 : ℤ) ≤ l ∧ u < Int.ofNat (List.length a)) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a) → a[Int.toNat i]! = v → l ≤ i ∧ i ≤ u)) ∧ l ≤ u ∧ (let m : ℤ := l + Int.tdiv (u - l) (2 : ℤ); ¬a[Int.toNat m]! < v ∧ ¬v < a[Int.toNat m]! ∧ r = m)) → ((0 : ℤ) ≤ r ∧ r < Int.ofNat (List.length a)) ∧ a[Int.toNat r]! = v)
  := sorry
end binary_search_vc_sp_BinarySearch_binary_searchqtvc
