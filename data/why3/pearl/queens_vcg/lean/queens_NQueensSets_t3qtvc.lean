import Why3.Base
import Why3.why3.Ref.Ref
import pearl.queens_vcg.lean.queens.S
import pearl.queens_vcg.lean.queens.Solution
open Classical
open Lean4Why3
namespace queens_NQueensSets_t3qtvc
theorem t3'vc (k : ℤ) (a : Finset ℤ) (s : ℤ) (col : ℤ -> ℤ) (b : Finset ℤ) (c : Finset ℤ) (sol : ℤ -> ℤ -> ℤ) (fact0 : (0 : ℤ) ≤ k) (fact1 : k + Int.ofNat (Finset.card a) = Solution.n) (fact2 : (0 : ℤ) ≤ s) (fact3 : ∀(i : ℤ), (i ∈ a) = (((0 : ℤ) ≤ i ∧ i < Solution.n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k → ¬col j = i))) (fact4 : ∀(i : ℤ), (0 : ℤ) ≤ i → (¬i ∈ b) = (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k → ¬col j = i + j - k)) (fact5 : ∀(i : ℤ), (0 : ℤ) ≤ i → (¬i ∈ c) = (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k → ¬col j = i + k - j)) (fact6 : Solution.partial_solution k col) : if ¬a = ∅ then ∀(o1 : Finset ℤ), o1 = a \ b → (∀(o2 : Finset ℤ), o2 = o1 \ c → ((((0 : ℤ) = s - s ∧ (0 : ℤ) ≤ s - s) ∧ o2 ⊆ (a \ b) \ c ∧ Solution.partial_solution k col ∧ Solution.sorted sol s s ∧ (∀(i : ℤ) (j : ℤ), i ∈ o2 \ o2 → j ∈ o2 → i < j)) ∧ (∀(i : ℤ), s ≤ i ∧ i < s → Solution.partial_solution Solution.n (sol i) ∧ Solution.eq_prefix col (sol i) k ∧ sol i k ∈ o2 \ o2) ∧ (∀(t : ℤ -> ℤ), Solution.partial_solution Solution.n t ∧ Solution.eq_prefix col t k ∧ t k ∈ o2 \ o2 → t k ∈ o2 ∧ ¬t k ∈ o2 ∧ (∃(i : ℤ), (s ≤ i ∧ i < s) ∧ Solution.eq_prefix t (sol i) Solution.n)) ∧ Solution.eq_prefix col col k ∧ Solution.eq_prefix sol sol s) ∧ (∀(e : Finset ℤ) (s1 : ℤ) (sol1 : ℤ -> ℤ -> ℤ) (col1 : ℤ -> ℤ), ((0 : ℤ) ≤ s1 - s ∧ e ⊆ (a \ b) \ c ∧ Solution.partial_solution k col1 ∧ Solution.sorted sol1 s s1 ∧ (∀(i : ℤ) (j : ℤ), i ∈ o2 \ e → j ∈ e → i < j)) ∧ (∀(i : ℤ), s ≤ i ∧ i < s1 → Solution.partial_solution Solution.n (sol1 i) ∧ Solution.eq_prefix col1 (sol1 i) k ∧ sol1 i k ∈ o2 \ e) ∧ (∀(t : ℤ -> ℤ), Solution.partial_solution Solution.n t ∧ Solution.eq_prefix col1 t k ∧ t k ∈ o2 \ e → t k ∈ o2 ∧ ¬t k ∈ e ∧ (∃(i : ℤ), (s ≤ i ∧ i < s1) ∧ Solution.eq_prefix t (sol1 i) Solution.n)) ∧ Solution.eq_prefix col col1 k ∧ Solution.eq_prefix sol sol1 s → (if ¬e = ∅ then ¬e = ∅ ∧ (∀(o3 : Finset ℤ), o3 = insert (Finset.min'' e) c ∧ (if (Finset.min'' e) ∈ c then Finset.card o3 = Finset.card c else Int.ofNat (Finset.card o3) = Int.ofNat (Finset.card c) + (1 : ℤ)) → (∀(o4 : Finset ℤ), (∀(i : ℤ), (i ∈ o4) = ((0 : ℤ) ≤ i ∧ i + (1 : ℤ) ∈ o3)) → (∀(o5 : Finset ℤ), o5 = insert (Finset.min'' e) b ∧ (if (Finset.min'' e) ∈ b then Finset.card o5 = Finset.card b else Int.ofNat (Finset.card o5) = Int.ofNat (Finset.card b) + (1 : ℤ)) → (∀(o6 : Finset ℤ), (∀(i : ℤ), (i ∈ o6) = ((1 : ℤ) ≤ i ∧ i - (1 : ℤ) ∈ o5)) → (∀(o7 : Finset ℤ), o7 = Finset.erase a (Finset.min'' e) ∧ (if (Finset.min'' e) ∈ a then Int.ofNat (Finset.card o7) = Int.ofNat (Finset.card a) - (1 : ℤ) else Finset.card o7 = Finset.card a) → (((0 : ℤ) ≤ Int.ofNat (Finset.card a) ∧ Finset.card o7 < Finset.card a) ∧ (0 : ℤ) ≤ k + (1 : ℤ) ∧ k + (1 : ℤ) + Int.ofNat (Finset.card o7) = Solution.n ∧ (0 : ℤ) ≤ s1 ∧ (∀(i : ℤ), (i ∈ o7) = (((0 : ℤ) ≤ i ∧ i < Solution.n) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k + (1 : ℤ) → ¬Function.update col1 k (Finset.min'' e) j = i))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i → (¬i ∈ o6) = (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k + (1 : ℤ) → ¬Function.update col1 k (Finset.min'' e) j = i + j - (k + (1 : ℤ)))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i → (¬i ∈ o4) = (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < k + (1 : ℤ) → ¬Function.update col1 k (Finset.min'' e) j = i + (k + (1 : ℤ)) - j)) ∧ Solution.partial_solution (k + (1 : ℤ)) (Function.update col1 k (Finset.min'' e))) ∧ (∀(s2 : ℤ) (sol2 : ℤ -> ℤ -> ℤ) (col2 : ℤ -> ℤ), (0 : ℤ) ≤ s2 - s1 ∧ Solution.sorted sol2 s1 s2 ∧ (∀(t : ℤ -> ℤ), (Solution.partial_solution Solution.n t ∧ Solution.eq_prefix col2 t (k + (1 : ℤ))) = (∃(i : ℤ), (s1 ≤ i ∧ i < s2) ∧ Solution.eq_prefix t (sol2 i) Solution.n)) ∧ Solution.eq_prefix (Function.update col1 k (Finset.min'' e)) col2 (k + (1 : ℤ)) ∧ Solution.eq_prefix sol1 sol2 s1 → (∀(o8 : Finset ℤ), o8 = Finset.erase e (Finset.min'' e) ∧ (if (Finset.min'' e) ∈ e then Int.ofNat (Finset.card o8) = Int.ofNat (Finset.card e) - (1 : ℤ) else Finset.card o8 = Finset.card e) → ((0 : ℤ) ≤ Int.ofNat (Finset.card e) ∧ Finset.card o8 < Finset.card e) ∧ ((s1 - s + (s2 - s1) = s2 - s ∧ (0 : ℤ) ≤ s2 - s) ∧ k + (1 : ℤ) - (1 : ℤ) = k ∧ o8 ⊆ (a \ b) \ c ∧ Solution.partial_solution (k + (1 : ℤ) - (1 : ℤ)) col2 ∧ Solution.sorted sol2 s s2 ∧ (∀(i : ℤ) (j : ℤ), i ∈ o2 \ o8 → j ∈ o8 → i < j)) ∧ (∀(i : ℤ), s ≤ i ∧ i < s2 → Solution.partial_solution Solution.n (sol2 i) ∧ Solution.eq_prefix col2 (sol2 i) (k + (1 : ℤ) - (1 : ℤ)) ∧ sol2 i (k + (1 : ℤ) - (1 : ℤ)) ∈ o2 \ o8) ∧ (∀(t : ℤ -> ℤ), Solution.partial_solution Solution.n t ∧ Solution.eq_prefix col2 t (k + (1 : ℤ) - (1 : ℤ)) ∧ t (k + (1 : ℤ) - (1 : ℤ)) ∈ o2 \ o8 → t (k + (1 : ℤ) - (1 : ℤ)) ∈ o2 ∧ ¬t (k + (1 : ℤ) - (1 : ℤ)) ∈ o8 ∧ (∃(i : ℤ), (s ≤ i ∧ i < s2) ∧ Solution.eq_prefix t (sol2 i) Solution.n)) ∧ Solution.eq_prefix col col2 (k + (1 : ℤ) - (1 : ℤ)) ∧ Solution.eq_prefix sol sol2 s))))))) else (0 : ℤ) ≤ s1 - s ∧ Solution.sorted sol1 s s1 ∧ (∀(t : ℤ -> ℤ), (Solution.partial_solution Solution.n t ∧ Solution.eq_prefix col1 t k) = (∃(i : ℤ), (s ≤ i ∧ i < s1) ∧ Solution.eq_prefix t (sol1 i) Solution.n)) ∧ Solution.eq_prefix col col1 k ∧ Solution.eq_prefix sol sol1 s))) else ((1 : ℤ) = s + (1 : ℤ) - s ∧ (0 : ℤ) ≤ s + (1 : ℤ) - s) ∧ Solution.sorted (Function.update sol s col) s (s + (1 : ℤ)) ∧ (∀(t : ℤ -> ℤ), (Solution.partial_solution Solution.n t ∧ Solution.eq_prefix col t k) = (∃(i : ℤ), (s ≤ i ∧ i < s + (1 : ℤ)) ∧ Solution.eq_prefix t (Function.update sol s col i) Solution.n)) ∧ Solution.eq_prefix col col k ∧ Solution.eq_prefix sol (Function.update sol s col) s
  := sorry
end queens_NQueensSets_t3qtvc
