import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
import Why3.array.IntArraySorted
open Classical
open Lean4Why3
namespace quicksort_Quicksort3way_quick_recqtvc
noncomputable def qs_partition (a1 : List ℤ) (a2 : List ℤ) (l : ℤ) (ml : ℤ) (mr : ℤ) (r : ℤ) (v : ℤ) := List.permut_sub' a1 a2 (Int.toNat l) (Int.toNat r) ∧ (∀(j : ℤ), l ≤ j ∧ j < ml → a2[Int.toNat j]! < v) ∧ (∀(j : ℤ), ml ≤ j ∧ j < mr → a2[Int.toNat j]! = v) ∧ (∀(j : ℤ), mr ≤ j ∧ j < r → v < a2[Int.toNat j]!)
theorem quick_rec'vc (l : ℤ) (r : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ l) (fact1 : l ≤ r) (fact2 : r ≤ Int.ofNat (List.length a)) : if l + (1 : ℤ) < r then ((0 : ℤ) ≤ l ∧ l < Int.ofNat (List.length a)) ∧ (let v : ℤ := a[Int.toNat l]!; let o1 : ℤ := l + (1 : ℤ); ((l ≤ l ∧ l < o1 ∧ o1 ≤ r ∧ r ≤ r) ∧ (∀(j : ℤ), l ≤ j ∧ j < l → a[Int.toNat j]! < v) ∧ (∀(j : ℤ), l ≤ j ∧ j < o1 → a[Int.toNat j]! = v) ∧ (∀(j : ℤ), r ≤ j ∧ j < r → v < a[Int.toNat j]!) ∧ List.permut_sub' a a (Int.toNat l) (Int.toNat r)) ∧ (∀(i : ℤ) (mr : ℤ) (ml : ℤ) (a1 : List ℤ), List.length a1 = List.length a → (l ≤ ml ∧ ml < i ∧ i ≤ mr ∧ mr ≤ r) ∧ (∀(j : ℤ), l ≤ j ∧ j < ml → a1[Int.toNat j]! < v) ∧ (∀(j : ℤ), ml ≤ j ∧ j < i → a1[Int.toNat j]! = v) ∧ (∀(j : ℤ), mr ≤ j ∧ j < r → v < a1[Int.toNat j]!) ∧ List.permut_sub' a a1 (Int.toNat l) (Int.toNat r) → (if i < mr then ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (if a1[Int.toNat i]! < v then (((0 : ℤ) ≤ ml ∧ ml < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 ml i → ((0 : ℤ) ≤ mr - i ∧ mr - (i + (1 : ℤ)) < mr - i) ∧ (l ≤ ml + (1 : ℤ) ∧ ml + (1 : ℤ) < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ mr ∧ mr ≤ r) ∧ (∀(j : ℤ), l ≤ j ∧ j < ml + (1 : ℤ) → a2[Int.toNat j]! < v) ∧ (∀(j : ℤ), ml + (1 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → a2[Int.toNat j]! = v) ∧ (∀(j : ℤ), mr ≤ j ∧ j < r → v < a2[Int.toNat j]!) ∧ List.permut_sub' a a2 (Int.toNat l) (Int.toNat r)) else ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (if v < a1[Int.toNat i]! then (((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ mr - (1 : ℤ) ∧ mr - (1 : ℤ) < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 i (mr - (1 : ℤ)) → ((0 : ℤ) ≤ mr - i ∧ mr - (1 : ℤ) - i < mr - i) ∧ (l ≤ ml ∧ ml < i ∧ i ≤ mr - (1 : ℤ) ∧ mr - (1 : ℤ) ≤ r) ∧ (∀(j : ℤ), l ≤ j ∧ j < ml → a2[Int.toNat j]! < v) ∧ (∀(j : ℤ), ml ≤ j ∧ j < i → a2[Int.toNat j]! = v) ∧ (∀(j : ℤ), mr - (1 : ℤ) ≤ j ∧ j < r → v < a2[Int.toNat j]!) ∧ List.permut_sub' a a2 (Int.toNat l) (Int.toNat r)) else ((0 : ℤ) ≤ mr - i ∧ mr - (i + (1 : ℤ)) < mr - i) ∧ (l ≤ ml ∧ ml < i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ mr ∧ mr ≤ r) ∧ (∀(j : ℤ), l ≤ j ∧ j < ml → a1[Int.toNat j]! < v) ∧ (∀(j : ℤ), ml ≤ j ∧ j < i + (1 : ℤ) → a1[Int.toNat j]! = v) ∧ (∀(j : ℤ), mr ≤ j ∧ j < r → v < a1[Int.toNat j]!) ∧ List.permut_sub' a a1 (Int.toNat l) (Int.toNat r))) else (((0 : ℤ) ≤ r - l ∧ ml - l < r - l) ∧ (0 : ℤ) ≤ l ∧ l ≤ ml ∧ ml ≤ Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → IntArraySorted.sorted_sub1 a2 l ml ∧ List.permut_sub' a1 a2 (Int.toNat l) (Int.toNat ml) → (((0 : ℤ) ≤ r - l ∧ r - mr < r - l) ∧ (0 : ℤ) ≤ mr ∧ mr ≤ r ∧ r ≤ Int.ofNat (List.length a2)) ∧ (∀(a3 : List ℤ), List.length a3 = List.length a2 → IntArraySorted.sorted_sub1 a3 mr r ∧ List.permut_sub' a2 a3 (Int.toNat mr) (Int.toNat r) → IntArraySorted.sorted_sub1 a3 l r ∧ List.permut_sub' a a3 (Int.toNat l) (Int.toNat r)))))) else IntArraySorted.sorted_sub1 a l r ∧ List.permut_sub' a a (Int.toNat l) (Int.toNat r)
  := sorry
end quicksort_Quicksort3way_quick_recqtvc
