theory sqrt_Sqrt1_sqrt1qtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "Why3STD.real_Truncate" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "mach.fxp_Fxp"
begin
theorem sqrt1'vc:
  fixes rp :: "64 word ptr"
  fixes a0 :: "64 word"
  fixes a :: "fxp"
  assumes fact0: "valid rp (1 :: int)"
  assumes fact1: "(4611686018427387904 :: int) \<le> uint a0"
  assumes fact2: "writable rp = True"
  assumes fact3: "ival a = a0"
  assumes fact4: "rval a = real_of_int (uint a0) * pow2 (-(64 :: int))"
  assumes fact5: "iexp a = -(64 :: int)"
  shows "(1 :: Real.real) / (4) \<le> rval a"
  and "rval a \<le> (18446744073709551615 :: Real.real) / (18446744073709551616)"
  and "iexp a = -(64 :: int)"
  and "\<forall>(x0 :: fxp). iexp x0 = -(8 :: int) \<and> ((256 :: int) \<le> uint (ival x0) \<and> uint (ival x0) \<le> (511 :: int)) \<and> ((1 :: Real.real) \<le> rval x0 \<and> rval x0 \<le> (2 :: Real.real)) \<and> (let rsa :: real = (1 :: Real.real) / sqrt (rval a); e0 :: real = (rval x0 - rsa) / rsa in -((281 :: Real.real) / (100000)) \<le> e0 \<and> e0 \<le> (531 :: Real.real) / (200000)) \<longrightarrow> ((0 :: Real.real) \<le> rval a \<and> rval a \<le> real_of_int (18446744073709551615 :: int) * pow2 (iexp a)) \<and> (\<forall>(a1 :: fxp). rval a1 = trunc_at (rval a) (iexp a + (31 :: int)) \<and> iexp a1 = iexp a + (31 :: int) \<longrightarrow> (\<forall>(o1 :: fxp). ival o1 = (196608 :: 64 word) \<and> rval o1 = real_of_int (196608 :: int) * pow2 (-(49 :: int)) \<and> iexp o1 = -(49 :: int) \<longrightarrow> (\<forall>(o2 :: fxp). ival o2 = (562949953421312 :: 64 word) \<and> rval o2 = real_of_int (562949953421312 :: int) * pow2 (-(49 :: int)) \<and> iexp o2 = -(49 :: int) \<longrightarrow> iexp o2 = iexp o1 \<and> (\<forall>(m1 :: fxp). rval m1 = rval o2 - rval o1 \<and> iexp m1 = iexp o2 \<longrightarrow> (\<forall>(o3 :: fxp). rval o3 = rval x0 * rval x0 \<and> iexp o3 = iexp x0 + iexp x0 \<longrightarrow> (\<forall>(o4 :: fxp). rval o4 = rval o3 * rval a1 \<and> iexp o4 = iexp o3 + iexp a1 \<longrightarrow> iexp m1 = iexp o4 \<and> (\<forall>(t1' :: fxp). rval t1' = rval m1 - rval o4 \<and> iexp t1' = iexp m1 \<longrightarrow> (real_of_int (-(9223372036854775808 :: int)) * pow2 (iexp t1') \<le> rval t1' \<and> rval t1' \<le> real_of_int (9223372036854775807 :: int) * pow2 (iexp t1')) \<and> (\<forall>(t1 :: fxp). rval t1 = trunc_at (rval t1') (iexp t1' + (16 :: int)) \<and> iexp t1 = iexp t1' + (16 :: int) \<longrightarrow> (\<forall>(o5 :: fxp). rval o5 = rval x0 * rval t1 \<and> iexp o5 = iexp x0 + iexp t1 \<longrightarrow> (real_of_int (-(9223372036854775808 :: int)) * pow2 (iexp o5) \<le> rval o5 \<and> rval o5 \<le> real_of_int (9223372036854775807 :: int) * pow2 (iexp o5)) \<and> (\<forall>(o6 :: fxp). rval o6 = trunc_at (rval o5 * pow2 (-(1 :: int))) (iexp o5 + (18 :: int) - (1 :: int)) \<and> iexp o6 = iexp o5 + (18 :: int) - (1 :: int) \<longrightarrow> (\<forall>(o7 :: fxp). rval o7 = rval x0 \<and> iexp o7 = iexp x0 - uint (16 :: 64 word) \<longrightarrow> iexp o7 = iexp o6 \<and> (\<forall>(x1 :: fxp). rval x1 = rval o7 + rval o6 \<and> iexp x1 = iexp o7 \<longrightarrow> ((0 :: Real.real) \<le> rval a \<and> rval a \<le> real_of_int (18446744073709551615 :: int) * pow2 (iexp a)) \<and> (\<forall>(a2 :: fxp). rval a2 = trunc_at (rval a) (iexp a + (24 :: int)) \<and> iexp a2 = iexp a + (24 :: int) \<longrightarrow> (\<forall>(u1 :: fxp). rval u1 = rval x1 * rval a2 \<and> iexp u1 = iexp x1 + iexp a2 \<longrightarrow> ((0 :: Real.real) \<le> rval u1 \<and> rval u1 \<le> real_of_int (18446744073709551615 :: int) * pow2 (iexp u1)) \<and> (\<forall>(u2 :: fxp). rval u2 = trunc_at (rval u1) (iexp u1 + (25 :: int)) \<and> iexp u2 = iexp u1 + (25 :: int) \<longrightarrow> (\<forall>(m2 :: fxp). ival m2 = (2473901162496 :: 64 word) \<and> rval m2 = real_of_int (2473901162496 :: int) * pow2 (-(78 :: int)) \<and> iexp m2 = -(78 :: int) \<longrightarrow> (\<forall>(o8 :: fxp). rval o8 = rval u2 * rval u2 \<and> iexp o8 = iexp u2 + iexp u2 \<longrightarrow> (\<forall>(o9 :: fxp). rval o9 = rval a \<and> iexp o9 = iexp a - uint (14 :: 64 word) \<longrightarrow> iexp o9 = iexp o8 \<and> (\<forall>(o10 :: fxp). rval o10 = rval o9 - rval o8 \<and> iexp o10 = iexp o9 \<longrightarrow> iexp o10 = iexp m2 \<and> (\<forall>(t2' :: fxp). rval t2' = rval o10 - rval m2 \<and> iexp t2' = iexp o10 \<longrightarrow> (real_of_int (-(9223372036854775808 :: int)) * pow2 (iexp t2') \<le> rval t2' \<and> rval t2' \<le> real_of_int (9223372036854775807 :: int) * pow2 (iexp t2')) \<and> (\<forall>(t2 :: fxp). rval t2 = trunc_at (rval t2') (iexp t2' + (24 :: int)) \<and> iexp t2 = iexp t2' + (24 :: int) \<longrightarrow> (\<forall>(o11 :: fxp). rval o11 = rval x1 * rval t2 \<and> iexp o11 = iexp x1 + iexp t2 \<longrightarrow> (real_of_int (-(9223372036854775808 :: int)) * pow2 (iexp o11) \<le> rval o11 \<and> rval o11 \<le> real_of_int (9223372036854775807 :: int) * pow2 (iexp o11)) \<and> (\<forall>(o12 :: fxp). rval o12 = trunc_at (rval o11 * pow2 (-(1 :: int))) (iexp o11 + (15 :: int) - (1 :: int)) \<and> iexp o12 = iexp o11 + (15 :: int) - (1 :: int) \<longrightarrow> iexp u1 = iexp o12 \<and> (\<forall>(x2 :: fxp). rval x2 = rval u1 + rval o12 \<and> iexp x2 = iexp u1 \<longrightarrow> ((0 :: Real.real) \<le> rval x2 \<and> rval x2 \<le> real_of_int (18446744073709551615 :: int) * pow2 (iexp x2)) \<and> (\<forall>(x :: fxp). rval x = trunc_at (rval x2) (iexp x2 + (32 :: int)) \<and> iexp x = iexp x2 + (32 :: int) \<longrightarrow> (let o13 :: 64 word = ival x in uint'64_in_bounds (uint o13 * uint o13) \<and> (\<forall>(o14 :: 64 word). uint o14 = uint o13 * uint o13 \<longrightarrow> uint'64_in_bounds (uint a0 - (1 :: int)) \<and> (\<forall>(o15 :: 64 word). uint o15 = uint a0 - (1 :: int) \<longrightarrow> uint'64_in_bounds ((2 :: int) * uint o13) \<and> (\<forall>(o16 :: 64 word). uint o16 = (2 :: int) * uint o13 \<longrightarrow> uint'64_in_bounds (uint o14 + uint o16) \<and> (\<forall>(o17 :: 64 word). uint o17 = uint o14 + uint o16 \<longrightarrow> (if uint o17 \<le> uint o15 then uint'64_in_bounds ((2 :: int) * uint o13) \<and> (\<forall>(o18 :: 64 word). uint o18 = (2 :: int) * uint o13 \<longrightarrow> uint'64_in_bounds (uint o14 + uint o18) \<and> (\<forall>(o19 :: 64 word). uint o19 = uint o14 + uint o18 \<longrightarrow> uint'64_in_bounds (uint o19 + (1 :: int)) \<and> (\<forall>(o20 :: 64 word). uint o20 = uint o19 + (1 :: int) \<longrightarrow> uint'64_in_bounds (uint o13 + (1 :: int)) \<and> (\<forall>(o21 :: 64 word). uint o21 = uint o13 + (1 :: int) \<longrightarrow> uint'64_in_bounds (uint a0 - uint o20) \<and> (\<forall>(o22 :: 64 word). uint o22 = uint a0 - uint o20 \<longrightarrow> ((c_C.min rp \<le> offset rp \<and> offset rp < c_C.max rp) \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> pelts rp1 = (pelts rp)(offset rp1 := o22) \<longrightarrow> (uint o21 * uint o21 \<le> uint a0 \<and> uint a0 < (uint o21 + (1 :: int)) * (uint o21 + (1 :: int))) \<and> uint o21 * uint o21 + uint (pelts rp1 (offset rp1)) = uint a0 \<and> uint (pelts rp1 (offset rp1)) \<le> (2 :: int) * uint o21)))))) else uint'64_in_bounds (uint a0 - uint o14) \<and> (\<forall>(o18 :: 64 word). uint o18 = uint a0 - uint o14 \<longrightarrow> ((c_C.min rp \<le> offset rp \<and> offset rp < c_C.max rp) \<and> writable rp = True) \<and> (\<forall>(rp1 :: 64 word ptr). length (data rp1) = length (data rp) \<and> offset rp1 = offset rp \<and> c_C.min rp1 = c_C.min rp \<and> c_C.max rp1 = c_C.max rp \<and> writable rp1 = writable rp \<and> zone1 rp1 = zone1 rp \<longrightarrow> pelts rp1 = (pelts rp)(offset rp1 := o18) \<longrightarrow> (uint o13 * uint o13 \<le> uint a0 \<and> uint a0 < (uint o13 + (1 :: int)) * (uint o13 + (1 :: int))) \<and> uint o13 * uint o13 + uint (pelts rp1 (offset rp1)) = uint a0 \<and> uint (pelts rp1 (offset rp1)) \<le> (2 :: int) * uint o13)))))))))))))))))))))))))))))))))"
  sorry
end
