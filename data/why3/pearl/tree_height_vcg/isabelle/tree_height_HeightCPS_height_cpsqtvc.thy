theory tree_height_HeightCPS_height_cpsqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.bintree_Tree" "Why3STD.bintree_Height"
begin
consts o1 :: "(int \<Rightarrow> 'b) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'b"
consts result :: "(int \<Rightarrow> 'b) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'b"
consts o2 :: "(int \<Rightarrow> 'b) \<Rightarrow> 'a tree \<Rightarrow> int \<Rightarrow> 'b"
consts result1 :: "(int \<Rightarrow> 'b) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'b"
consts o3 :: "(int \<Rightarrow> 'b) \<Rightarrow> 'a tree \<Rightarrow> int \<Rightarrow> 'b"
consts result2 :: "(int \<Rightarrow> 'b) \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'b"
consts o4 :: "(int \<Rightarrow> 'b) \<Rightarrow> 'a tree \<Rightarrow> int \<Rightarrow> 'b"
axiomatization where o'def:   "o1 k hl hr = k ((1 :: int) + max hl hr)"
  for k :: "int \<Rightarrow> 'b"
  and hl :: "int"
  and hr :: "int"
axiomatization where result'def:   "result k hl hr = k ((1 :: int) + max hl hr)"
  for k :: "int \<Rightarrow> 'b"
  and hl :: "int"
  and hr :: "int"
axiomatization where o'def1:   "o2 k r hl = result k hl (height r)"
  for k :: "int \<Rightarrow> 'b"
  and r :: "'a tree"
  and hl :: "int"
axiomatization where result'def1:   "result1 k hl hr = k ((1 :: int) + max hl hr)"
  for k :: "int \<Rightarrow> 'b"
  and hl :: "int"
  and hr :: "int"
axiomatization where o'def2:   "o3 k r hl = result1 k hl (height r)"
  for k :: "int \<Rightarrow> 'b"
  and r :: "'a tree"
  and hl :: "int"
axiomatization where result'def2:   "result2 k hl hr = k ((1 :: int) + max hl hr)"
  for k :: "int \<Rightarrow> 'b"
  and hl :: "int"
  and hr :: "int"
axiomatization where o'def3:   "o4 k r hl = result2 k hl (height r)"
  for k :: "int \<Rightarrow> 'b"
  and r :: "'a tree"
  and hl :: "int"
theorem height_cps'vc:
  fixes t :: "'a tree"
  fixes k :: "int \<Rightarrow> 'b"
  shows "case t of (Empty :: 'a tree) \<Rightarrow> True | Node l _ r \<Rightarrow> (case t of (Empty :: 'a tree) \<Rightarrow> False | Node f _ f1 \<Rightarrow> f = r \<or> f1 = r) \<and> (case t of (Empty :: 'a tree) \<Rightarrow> False | Node f _ f1 \<Rightarrow> f = l \<or> f1 = l)"
  and "\<forall>(result3 :: 'b). (case t of (Empty :: 'a tree) \<Rightarrow> result3 = k (0 :: int) | Node l _ r \<Rightarrow> result3 = o4 k r (height l)) \<longrightarrow> result3 = k (height t)"
  sorry
end
