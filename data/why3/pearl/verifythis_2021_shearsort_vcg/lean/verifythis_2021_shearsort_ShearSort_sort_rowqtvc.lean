import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
import Why3.int.Sum
import Why3.map.MapExt
import Why3.map.MapPermut
import Why3.matrix.Matrix
open Classical
open Lean4Why3
namespace verifythis_2021_shearsort_ShearSort_sort_rowqtvc
axiom column :  {α : Type} -> [Inhabited α] -> Matrix.matrix α -> ℤ -> ℤ -> α
axiom column'def {α : Type} [Inhabited α] (m : Matrix.matrix α) (j : ℤ) (i : ℤ) : column m j i = Matrix.elts m i j
axiom moccf :  {α : Type} -> [Inhabited α] -> α -> (ℤ -> ℤ -> α) -> ℤ -> ℤ -> ℤ
axiom moccf'def {α : Type} [Inhabited α] (x : α) (e : ℤ -> ℤ -> α) (c : ℤ) (i : ℤ) : moccf x e c i = Int.ofNat (Lean4Why3.map_occ x (e i) (0 : ℤ) c)
noncomputable def mocc {α : Type} [Inhabited α] (x : α) (e : ℤ -> ℤ -> α) (r : ℤ) (c : ℤ) := int.Sum.sum (moccf x e c) (0 : ℤ) r
axiom compose :  {γ : Type} -> [Inhabited γ] ->  {β : Type} -> [Inhabited β] ->  {α : Type} -> [Inhabited α] -> (β -> γ) -> (α -> β) -> α -> γ
axiom compose'def {γ : Type} {α : Type} {β : Type} [Inhabited γ] [Inhabited α] [Inhabited β] (g : β -> γ) (f : α -> β) (x : α) : compose g f x = g (f x)
theorem sort_row'vc (i : ℤ) (m : Matrix.matrix ℤ) (ascending : Bool) (fact0 : (0 : ℤ) ≤ i) (fact1 : i < Matrix.rows m) : let o1 : ℤ := Matrix.columns m; (0 : ℤ) ≤ o1 ∧ (∀(a : List ℤ), (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < o1 → a[Int.toNat i1]! = (0 : ℤ)) ∧ Int.ofNat (List.length a) = o1 → (let o2 : ℤ := Matrix.columns m - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < (0 : ℤ) → (getElem! a ∘ Int.toNat) k = Matrix.elts m i k) ∧ (∀(a1 : List ℤ), List.length a1 = List.length a → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j ≤ o2) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < j → (getElem! a1 ∘ Int.toNat) k = Matrix.elts m i k) → Matrix.valid_index m i j ∧ (let o3 : ℤ := Matrix.elts m i j; ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a1)) ∧ (List.length (List.set a1 (Int.toNat j) o3) = List.length a1 → getElem! (List.set a1 (Int.toNat j) o3) ∘ Int.toNat = Function.update (getElem! a1 ∘ Int.toNat) j o3 → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < j + (1 : ℤ) → (getElem! (List.set a1 (Int.toNat j) o3) ∘ Int.toNat) k = Matrix.elts m i k)))) ∧ ((∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < o2 + (1 : ℤ) → (getElem! a1 ∘ Int.toNat) k = Matrix.elts m i k) → (∀(a2 : List ℤ), List.length a2 = List.length a1 → (∀(i1 : ℤ) (j : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ j ∧ j < Int.ofNat (List.length a2) → a2[Int.toNat i1]! ≤ a2[Int.toNat j]!) ∧ MapPermut.permut (getElem! a2 ∘ Int.toNat) (getElem! a1 ∘ Int.toNat) (0 : ℤ) (Int.ofNat (List.length a2)) → (if ¬ascending = true then let o3 : ℤ := Int.ofNat (List.length a2) - (1 : ℤ); (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ o3 + (1 : ℤ) ∧ o3 + (1 : ℤ) ≤ Int.ofNat (List.length a2)) ∧ (0 : ℤ) + o3 = Int.ofNat (List.length a2) - (1 : ℤ) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) ∨ o3 < j ∧ j < Int.ofNat (List.length a2) → (getElem! a2 ∘ Int.toNat) j = (getElem! a2 ∘ Int.toNat) (Int.ofNat (List.length a2) - (1 : ℤ) - j)) ∧ MapPermut.permut (getElem! a2 ∘ Int.toNat) (getElem! a2 ∘ Int.toNat) (0 : ℤ) (Int.ofNat (List.length a2))) ∧ (∀(v : ℤ) (u : ℤ) (a3 : List ℤ), List.length a3 = List.length a2 → ((0 : ℤ) ≤ u ∧ u ≤ v + (1 : ℤ) ∧ v + (1 : ℤ) ≤ Int.ofNat (List.length a3)) ∧ u + v = Int.ofNat (List.length a3) - (1 : ℤ) ∧ (∀(j : ℤ), u ≤ j ∧ j ≤ v → (getElem! a3 ∘ Int.toNat) j = (getElem! a2 ∘ Int.toNat) j) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < u ∨ v < j ∧ j < Int.ofNat (List.length a3) → (getElem! a3 ∘ Int.toNat) j = (getElem! a2 ∘ Int.toNat) (Int.ofNat (List.length a3) - (1 : ℤ) - j)) ∧ MapPermut.permut (getElem! a2 ∘ Int.toNat) (getElem! a3 ∘ Int.toNat) (0 : ℤ) (Int.ofNat (List.length a3)) → (if u < v then let e : ℤ -> ℤ := getElem! a3 ∘ Int.toNat; ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length a3)) ∧ (let tmp : ℤ := a3[Int.toNat v]!; ((0 : ℤ) ≤ u ∧ u < Int.ofNat (List.length a3)) ∧ (let o4 : ℤ := a3[Int.toNat u]!; ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length a3)) ∧ (List.length (List.set a3 (Int.toNat v) o4) = List.length a3 → getElem! (List.set a3 (Int.toNat v) o4) ∘ Int.toNat = Function.update (getElem! a3 ∘ Int.toNat) v o4 → ((0 : ℤ) ≤ u ∧ u < Int.ofNat (List.length (List.set a3 (Int.toNat v) o4))) ∧ (List.length (List.set (List.set a3 (Int.toNat v) o4) (Int.toNat u) tmp) = List.length (List.set a3 (Int.toNat v) o4) → getElem! (List.set (List.set a3 (Int.toNat v) o4) (Int.toNat u) tmp) ∘ Int.toNat = Function.update (getElem! (List.set a3 (Int.toNat v) o4) ∘ Int.toNat) u tmp → (let o5 : ℤ := Int.ofNat (List.length (List.set (List.set a3 (Int.toNat v) o4) (Int.toNat u) tmp)); let o6 : ℤ -> ℤ := getElem! (List.set (List.set a3 (Int.toNat v) o4) (Int.toNat u) tmp) ∘ Int.toNat; ((((0 : ℤ) ≤ u ∧ u < o5) ∧ (0 : ℤ) ≤ v ∧ v < o5) ∧ (∀(i1 : ℤ), ((0 : ℤ) ≤ i1 ∧ i1 ≤ o5) ∧ ¬i1 = u ∧ ¬i1 = v → o6 i1 = e i1) ∧ o6 u = e v ∧ o6 v = e u) ∧ (MapPermut.permut o6 e (0 : ℤ) o5 → ((0 : ℤ) ≤ v - u ∧ v - (1 : ℤ) - (u + (1 : ℤ)) < v - u) ∧ ((0 : ℤ) ≤ u + (1 : ℤ) ∧ u + (1 : ℤ) ≤ v - (1 : ℤ) + (1 : ℤ) ∧ v - (1 : ℤ) + (1 : ℤ) ≤ Int.ofNat (List.length (List.set (List.set a3 (Int.toNat v) o4) (Int.toNat u) tmp))) ∧ u + (1 : ℤ) + (v - (1 : ℤ)) = Int.ofNat (List.length (List.set (List.set a3 (Int.toNat v) o4) (Int.toNat u) tmp)) - (1 : ℤ) ∧ (∀(j : ℤ), u + (1 : ℤ) ≤ j ∧ j ≤ v - (1 : ℤ) → (getElem! (List.set (List.set a3 (Int.toNat v) o4) (Int.toNat u) tmp) ∘ Int.toNat) j = (getElem! a2 ∘ Int.toNat) j) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < u + (1 : ℤ) ∨ v - (1 : ℤ) < j ∧ j < Int.ofNat (List.length (List.set (List.set a3 (Int.toNat v) o4) (Int.toNat u) tmp)) → (getElem! (List.set (List.set a3 (Int.toNat v) o4) (Int.toNat u) tmp) ∘ Int.toNat) j = (getElem! a2 ∘ Int.toNat) (Int.ofNat (List.length (List.set (List.set a3 (Int.toNat v) o4) (Int.toNat u) tmp)) - (1 : ℤ) - j)) ∧ MapPermut.permut (getElem! a2 ∘ Int.toNat) (getElem! (List.set (List.set a3 (Int.toNat v) o4) (Int.toNat u) tmp) ∘ Int.toNat) (0 : ℤ) (Int.ofNat (List.length (List.set (List.set a3 (Int.toNat v) o4) (Int.toNat u) tmp))))))))) else let o4 : ℤ := Matrix.columns m - (1 : ℤ); ((0 : ℤ) ≤ o4 + (1 : ℤ) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < (0 : ℤ) → (getElem! a3 ∘ Int.toNat) k = Matrix.elts m i k) ∧ (∀(m1 : Matrix.matrix ℤ), Matrix.rows m1 = Matrix.rows m ∧ Matrix.columns m1 = Matrix.columns m → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j ≤ o4) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < j → (getElem! a3 ∘ Int.toNat) k = Matrix.elts m1 i k) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m1) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m1) ∧ ¬k = i → Matrix.elts m1 k l = Matrix.elts m k l) → ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a3)) ∧ Matrix.valid_index m1 i j ∧ (∀(m2 : Matrix.matrix ℤ), Matrix.rows m2 = Matrix.rows m1 ∧ Matrix.columns m2 = Matrix.columns m1 → Matrix.elts m2 = Function.update (Matrix.elts m1) i (Function.update (Matrix.elts m1 i) j (a3[Int.toNat j]!)) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < j + (1 : ℤ) → (getElem! a3 ∘ Int.toNat) k = Matrix.elts m2 i k) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m2) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m2) ∧ ¬k = i → Matrix.elts m2 k l = Matrix.elts m k l))) ∧ ((∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < o4 + (1 : ℤ) → (getElem! a3 ∘ Int.toNat) k = Matrix.elts m1 i k) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m1) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m1) ∧ ¬k = i → Matrix.elts m1 k l = Matrix.elts m k l) → (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j < Matrix.rows m1 ∧ ((0 : ℤ) ≤ k ∧ k < Matrix.columns m1) ∧ ¬j = i → Matrix.elts m1 j k = Matrix.elts m j k) ∧ (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k ∧ k < Matrix.columns m1 → (let a4 : ℤ := Matrix.elts m1 i j; let b : ℤ := Matrix.elts m1 i k; if ascending = true then a4 ≤ b else b ≤ a4)) ∧ MapPermut.permut (Matrix.elts m1 i) (Matrix.elts m i) (0 : ℤ) (Matrix.columns m1)))) ∧ (o4 + (1 : ℤ) < (0 : ℤ) → (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k ∧ k < Matrix.columns m → (let a4 : ℤ := Matrix.elts m i j; let b : ℤ := Matrix.elts m i k; if ascending = true then a4 ≤ b else b ≤ a4)) ∧ MapPermut.permut (Matrix.elts m i) (Matrix.elts m i) (0 : ℤ) (Matrix.columns m)))) else let o3 : ℤ := Matrix.columns m - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < (0 : ℤ) → (getElem! a2 ∘ Int.toNat) k = Matrix.elts m i k) ∧ (∀(m1 : Matrix.matrix ℤ), Matrix.rows m1 = Matrix.rows m ∧ Matrix.columns m1 = Matrix.columns m → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j ≤ o3) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < j → (getElem! a2 ∘ Int.toNat) k = Matrix.elts m1 i k) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m1) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m1) ∧ ¬k = i → Matrix.elts m1 k l = Matrix.elts m k l) → ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a2)) ∧ Matrix.valid_index m1 i j ∧ (∀(m2 : Matrix.matrix ℤ), Matrix.rows m2 = Matrix.rows m1 ∧ Matrix.columns m2 = Matrix.columns m1 → Matrix.elts m2 = Function.update (Matrix.elts m1) i (Function.update (Matrix.elts m1 i) j (a2[Int.toNat j]!)) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < j + (1 : ℤ) → (getElem! a2 ∘ Int.toNat) k = Matrix.elts m2 i k) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m2) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m2) ∧ ¬k = i → Matrix.elts m2 k l = Matrix.elts m k l))) ∧ ((∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < o3 + (1 : ℤ) → (getElem! a2 ∘ Int.toNat) k = Matrix.elts m1 i k) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m1) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m1) ∧ ¬k = i → Matrix.elts m1 k l = Matrix.elts m k l) → (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j < Matrix.rows m1 ∧ ((0 : ℤ) ≤ k ∧ k < Matrix.columns m1) ∧ ¬j = i → Matrix.elts m1 j k = Matrix.elts m j k) ∧ (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k ∧ k < Matrix.columns m1 → (let a3 : ℤ := Matrix.elts m1 i j; let b : ℤ := Matrix.elts m1 i k; if ascending = true then a3 ≤ b else b ≤ a3)) ∧ MapPermut.permut (Matrix.elts m1 i) (Matrix.elts m i) (0 : ℤ) (Matrix.columns m1)))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k ∧ k < Matrix.columns m → (let a3 : ℤ := Matrix.elts m i j; let b : ℤ := Matrix.elts m i k; if ascending = true then a3 ≤ b else b ≤ a3)) ∧ MapPermut.permut (Matrix.elts m i) (Matrix.elts m i) (0 : ℤ) (Matrix.columns m))))))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → (∀(a1 : List ℤ), List.length a1 = List.length a → (∀(i1 : ℤ) (j : ℤ), (0 : ℤ) ≤ i1 ∧ i1 ≤ j ∧ j < Int.ofNat (List.length a1) → a1[Int.toNat i1]! ≤ a1[Int.toNat j]!) ∧ MapPermut.permut (getElem! a1 ∘ Int.toNat) (getElem! a ∘ Int.toNat) (0 : ℤ) (Int.ofNat (List.length a1)) → (if ¬ascending = true then let o3 : ℤ := Int.ofNat (List.length a1) - (1 : ℤ); (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ o3 + (1 : ℤ) ∧ o3 + (1 : ℤ) ≤ Int.ofNat (List.length a1)) ∧ (0 : ℤ) + o3 = Int.ofNat (List.length a1) - (1 : ℤ) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) ∨ o3 < j ∧ j < Int.ofNat (List.length a1) → (getElem! a1 ∘ Int.toNat) j = (getElem! a1 ∘ Int.toNat) (Int.ofNat (List.length a1) - (1 : ℤ) - j)) ∧ MapPermut.permut (getElem! a1 ∘ Int.toNat) (getElem! a1 ∘ Int.toNat) (0 : ℤ) (Int.ofNat (List.length a1))) ∧ (∀(v : ℤ) (u : ℤ) (a2 : List ℤ), List.length a2 = List.length a1 → ((0 : ℤ) ≤ u ∧ u ≤ v + (1 : ℤ) ∧ v + (1 : ℤ) ≤ Int.ofNat (List.length a2)) ∧ u + v = Int.ofNat (List.length a2) - (1 : ℤ) ∧ (∀(j : ℤ), u ≤ j ∧ j ≤ v → (getElem! a2 ∘ Int.toNat) j = (getElem! a1 ∘ Int.toNat) j) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < u ∨ v < j ∧ j < Int.ofNat (List.length a2) → (getElem! a2 ∘ Int.toNat) j = (getElem! a1 ∘ Int.toNat) (Int.ofNat (List.length a2) - (1 : ℤ) - j)) ∧ MapPermut.permut (getElem! a1 ∘ Int.toNat) (getElem! a2 ∘ Int.toNat) (0 : ℤ) (Int.ofNat (List.length a2)) → (if u < v then let e : ℤ -> ℤ := getElem! a2 ∘ Int.toNat; ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length a2)) ∧ (let tmp : ℤ := a2[Int.toNat v]!; ((0 : ℤ) ≤ u ∧ u < Int.ofNat (List.length a2)) ∧ (let o4 : ℤ := a2[Int.toNat u]!; ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length a2)) ∧ (List.length (List.set a2 (Int.toNat v) o4) = List.length a2 → getElem! (List.set a2 (Int.toNat v) o4) ∘ Int.toNat = Function.update (getElem! a2 ∘ Int.toNat) v o4 → ((0 : ℤ) ≤ u ∧ u < Int.ofNat (List.length (List.set a2 (Int.toNat v) o4))) ∧ (List.length (List.set (List.set a2 (Int.toNat v) o4) (Int.toNat u) tmp) = List.length (List.set a2 (Int.toNat v) o4) → getElem! (List.set (List.set a2 (Int.toNat v) o4) (Int.toNat u) tmp) ∘ Int.toNat = Function.update (getElem! (List.set a2 (Int.toNat v) o4) ∘ Int.toNat) u tmp → (let o5 : ℤ := Int.ofNat (List.length (List.set (List.set a2 (Int.toNat v) o4) (Int.toNat u) tmp)); let o6 : ℤ -> ℤ := getElem! (List.set (List.set a2 (Int.toNat v) o4) (Int.toNat u) tmp) ∘ Int.toNat; ((((0 : ℤ) ≤ u ∧ u < o5) ∧ (0 : ℤ) ≤ v ∧ v < o5) ∧ (∀(i1 : ℤ), ((0 : ℤ) ≤ i1 ∧ i1 ≤ o5) ∧ ¬i1 = u ∧ ¬i1 = v → o6 i1 = e i1) ∧ o6 u = e v ∧ o6 v = e u) ∧ (MapPermut.permut o6 e (0 : ℤ) o5 → ((0 : ℤ) ≤ v - u ∧ v - (1 : ℤ) - (u + (1 : ℤ)) < v - u) ∧ ((0 : ℤ) ≤ u + (1 : ℤ) ∧ u + (1 : ℤ) ≤ v - (1 : ℤ) + (1 : ℤ) ∧ v - (1 : ℤ) + (1 : ℤ) ≤ Int.ofNat (List.length (List.set (List.set a2 (Int.toNat v) o4) (Int.toNat u) tmp))) ∧ u + (1 : ℤ) + (v - (1 : ℤ)) = Int.ofNat (List.length (List.set (List.set a2 (Int.toNat v) o4) (Int.toNat u) tmp)) - (1 : ℤ) ∧ (∀(j : ℤ), u + (1 : ℤ) ≤ j ∧ j ≤ v - (1 : ℤ) → (getElem! (List.set (List.set a2 (Int.toNat v) o4) (Int.toNat u) tmp) ∘ Int.toNat) j = (getElem! a1 ∘ Int.toNat) j) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < u + (1 : ℤ) ∨ v - (1 : ℤ) < j ∧ j < Int.ofNat (List.length (List.set (List.set a2 (Int.toNat v) o4) (Int.toNat u) tmp)) → (getElem! (List.set (List.set a2 (Int.toNat v) o4) (Int.toNat u) tmp) ∘ Int.toNat) j = (getElem! a1 ∘ Int.toNat) (Int.ofNat (List.length (List.set (List.set a2 (Int.toNat v) o4) (Int.toNat u) tmp)) - (1 : ℤ) - j)) ∧ MapPermut.permut (getElem! a1 ∘ Int.toNat) (getElem! (List.set (List.set a2 (Int.toNat v) o4) (Int.toNat u) tmp) ∘ Int.toNat) (0 : ℤ) (Int.ofNat (List.length (List.set (List.set a2 (Int.toNat v) o4) (Int.toNat u) tmp))))))))) else let o4 : ℤ := Matrix.columns m - (1 : ℤ); ((0 : ℤ) ≤ o4 + (1 : ℤ) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < (0 : ℤ) → (getElem! a2 ∘ Int.toNat) k = Matrix.elts m i k) ∧ (∀(m1 : Matrix.matrix ℤ), Matrix.rows m1 = Matrix.rows m ∧ Matrix.columns m1 = Matrix.columns m → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j ≤ o4) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < j → (getElem! a2 ∘ Int.toNat) k = Matrix.elts m1 i k) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m1) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m1) ∧ ¬k = i → Matrix.elts m1 k l = Matrix.elts m k l) → ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a2)) ∧ Matrix.valid_index m1 i j ∧ (∀(m2 : Matrix.matrix ℤ), Matrix.rows m2 = Matrix.rows m1 ∧ Matrix.columns m2 = Matrix.columns m1 → Matrix.elts m2 = Function.update (Matrix.elts m1) i (Function.update (Matrix.elts m1 i) j (a2[Int.toNat j]!)) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < j + (1 : ℤ) → (getElem! a2 ∘ Int.toNat) k = Matrix.elts m2 i k) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m2) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m2) ∧ ¬k = i → Matrix.elts m2 k l = Matrix.elts m k l))) ∧ ((∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < o4 + (1 : ℤ) → (getElem! a2 ∘ Int.toNat) k = Matrix.elts m1 i k) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m1) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m1) ∧ ¬k = i → Matrix.elts m1 k l = Matrix.elts m k l) → (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j < Matrix.rows m1 ∧ ((0 : ℤ) ≤ k ∧ k < Matrix.columns m1) ∧ ¬j = i → Matrix.elts m1 j k = Matrix.elts m j k) ∧ (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k ∧ k < Matrix.columns m1 → (let a3 : ℤ := Matrix.elts m1 i j; let b : ℤ := Matrix.elts m1 i k; if ascending = true then a3 ≤ b else b ≤ a3)) ∧ MapPermut.permut (Matrix.elts m1 i) (Matrix.elts m i) (0 : ℤ) (Matrix.columns m1)))) ∧ (o4 + (1 : ℤ) < (0 : ℤ) → (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k ∧ k < Matrix.columns m → (let a3 : ℤ := Matrix.elts m i j; let b : ℤ := Matrix.elts m i k; if ascending = true then a3 ≤ b else b ≤ a3)) ∧ MapPermut.permut (Matrix.elts m i) (Matrix.elts m i) (0 : ℤ) (Matrix.columns m)))) else let o3 : ℤ := Matrix.columns m - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < (0 : ℤ) → (getElem! a1 ∘ Int.toNat) k = Matrix.elts m i k) ∧ (∀(m1 : Matrix.matrix ℤ), Matrix.rows m1 = Matrix.rows m ∧ Matrix.columns m1 = Matrix.columns m → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j ≤ o3) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < j → (getElem! a1 ∘ Int.toNat) k = Matrix.elts m1 i k) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m1) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m1) ∧ ¬k = i → Matrix.elts m1 k l = Matrix.elts m k l) → ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a1)) ∧ Matrix.valid_index m1 i j ∧ (∀(m2 : Matrix.matrix ℤ), Matrix.rows m2 = Matrix.rows m1 ∧ Matrix.columns m2 = Matrix.columns m1 → Matrix.elts m2 = Function.update (Matrix.elts m1) i (Function.update (Matrix.elts m1 i) j (a1[Int.toNat j]!)) → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < j + (1 : ℤ) → (getElem! a1 ∘ Int.toNat) k = Matrix.elts m2 i k) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m2) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m2) ∧ ¬k = i → Matrix.elts m2 k l = Matrix.elts m k l))) ∧ ((∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < o3 + (1 : ℤ) → (getElem! a1 ∘ Int.toNat) k = Matrix.elts m1 i k) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < Matrix.rows m1) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m1) ∧ ¬k = i → Matrix.elts m1 k l = Matrix.elts m k l) → (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j < Matrix.rows m1 ∧ ((0 : ℤ) ≤ k ∧ k < Matrix.columns m1) ∧ ¬j = i → Matrix.elts m1 j k = Matrix.elts m j k) ∧ (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k ∧ k < Matrix.columns m1 → (let a2 : ℤ := Matrix.elts m1 i j; let b : ℤ := Matrix.elts m1 i k; if ascending = true then a2 ≤ b else b ≤ a2)) ∧ MapPermut.permut (Matrix.elts m1 i) (Matrix.elts m i) (0 : ℤ) (Matrix.columns m1)))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → (∀(j : ℤ) (k : ℤ), (0 : ℤ) ≤ j ∧ j ≤ k ∧ k < Matrix.columns m → (let a2 : ℤ := Matrix.elts m i j; let b : ℤ := Matrix.elts m i k; if ascending = true then a2 ≤ b else b ≤ a2)) ∧ MapPermut.permut (Matrix.elts m i) (Matrix.elts m i) (0 : ℤ) (Matrix.columns m)))))))
  := sorry
end verifythis_2021_shearsort_ShearSort_sort_rowqtvc
