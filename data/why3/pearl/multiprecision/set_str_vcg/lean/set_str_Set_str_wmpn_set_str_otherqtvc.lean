import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import Why3.mach.c.UChar
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.powm.Powm
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.valuation.Valuation
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.sub_1.Sub_1
import pearl.multiprecision.lib.lean.stringlemmas.String_lemmas
import pearl.multiprecision.lib.lean.base_info.BaseInfo
open Classical
open Lean4Why3
namespace set_str_Set_str_wmpn_set_str_otherqtvc
theorem wmpn_set_str_other'vc (sn : BitVec 32) (sz : BitVec 32) (rp : C.ptr (BitVec 64)) (sp : C.ptr (BitVec 8)) (b : BitVec 64) (info : BaseInfo.wmpn_base_info) (fact0 : (0 : ℤ) < BitVec.toUInt sn) (fact1 : BitVec.toUInt sn ≤ (2147483647 : ℤ)) (fact2 : (0 : ℤ) < BitVec.toInt sz) (fact3 : C.valid rp (BitVec.toInt sz)) (fact4 : C.valid sp (BitVec.toUInt sn)) (fact5 : (2 : ℤ) ≤ BitVec.toUInt b) (fact6 : BitVec.toUInt b ≤ (256 : ℤ)) (fact7 : HPow.hPow (BitVec.toUInt b) (Int.toNat (BitVec.toUInt sn)) ≤ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz))) (fact8 : C.writable rp = true) (fact9 : String_lemmas.in_base (BitVec.toUInt b) (C.pelts sp) (C.offset sp) (C.offset sp + BitVec.toUInt sn)) (fact10 : BaseInfo.b info = BitVec.toUInt b) : let o1 : BitVec 32 := BaseInfo.exp info; uint'32_in_bounds (BitVec.toUInt sn - (1 : ℤ)) ∧ (∀(o2 : BitVec 32), BitVec.toUInt o2 = BitVec.toUInt sn - (1 : ℤ) → (¬BitVec.toUInt o1 = (0 : ℤ) ∧ uint'32_in_bounds (Int.tmod (BitVec.toUInt o2) (BitVec.toUInt o1))) ∧ (∀(o3 : BitVec 32), BitVec.toUInt o3 = Int.tmod (BitVec.toUInt o2) (BitVec.toUInt o1) → uint'32_in_bounds ((1 : ℤ) + BitVec.toUInt o3) ∧ (∀(o4 : BitVec 32), BitVec.toUInt o4 = (1 : ℤ) + BitVec.toUInt o3 → (C.min sp ≤ C.offset sp ∧ C.offset sp < C.max sp) ∧ (∀(o5 : BitVec 64), BitVec.toUInt o5 = BitVec.toInt (C.pelts sp (C.offset sp)) → (((1 : ℤ) ≤ BitVec.toUInt o4 ∧ BitVec.toUInt o4 ≤ BitVec.toUInt sn) ∧ ((1 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ BitVec.toUInt sn) ∧ BitVec.toUInt o5 = String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp) (C.offset sp + (1 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toUInt o5 ∧ BitVec.toUInt o5 < HPow.hPow (BitVec.toUInt b) (1 : ℕ)) ∧ (1 : ℤ) + BitVec.toUInt o4 - (1 : ℤ) = (1 : ℤ) + (BitVec.toUInt sn - (1 : ℤ)) % BitVec.toUInt (BaseInfo.exp info) ∧ ((1 : ℤ) = BitVec.toUInt sn → BitVec.toUInt o4 = (1 : ℤ))) ∧ (∀(j : BitVec 32) (w : BitVec 64) (k : BitVec 32), ((1 : ℤ) ≤ BitVec.toUInt k ∧ BitVec.toUInt k ≤ BitVec.toUInt sn) ∧ ((1 : ℤ) ≤ BitVec.toInt j ∧ BitVec.toInt j ≤ BitVec.toUInt sn) ∧ BitVec.toUInt w = String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp) (C.offset sp + BitVec.toInt j) ∧ ((0 : ℤ) ≤ BitVec.toUInt w ∧ BitVec.toUInt w < HPow.hPow (BitVec.toUInt b) (Int.toNat (BitVec.toInt j))) ∧ BitVec.toInt j + BitVec.toUInt k - (1 : ℤ) = (1 : ℤ) + (BitVec.toUInt sn - (1 : ℤ)) % BitVec.toUInt (BaseInfo.exp info) ∧ (BitVec.toInt j = BitVec.toUInt sn → BitVec.toUInt k = (1 : ℤ)) → uint'32_in_bounds (BitVec.toUInt k - (1 : ℤ)) ∧ (∀(o6 : BitVec 32), BitVec.toUInt o6 = BitVec.toUInt k - (1 : ℤ) → (if (0 : ℤ) < BitVec.toUInt o6 then (C.min sp ≤ C.offset sp + BitVec.toInt j ∧ C.offset sp + BitVec.toInt j < C.max sp) ∧ (∀(sj : BitVec 64), BitVec.toUInt sj = BitVec.toInt (C.pelts sp (C.offset sp + BitVec.toInt j)) → uint'64_in_bounds (BitVec.toUInt w * BitVec.toUInt b) ∧ (∀(o7 : BitVec 64), BitVec.toUInt o7 = BitVec.toUInt w * BitVec.toUInt b → uint'64_in_bounds (BitVec.toUInt o7 + BitVec.toUInt sj) ∧ (∀(o8 : BitVec 64), BitVec.toUInt o8 = BitVec.toUInt o7 + BitVec.toUInt sj → int'32_in_bounds (BitVec.toInt j + (1 : ℤ)) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt j + (1 : ℤ) → BitVec.toUInt o6 < BitVec.toUInt k ∧ ((1 : ℤ) ≤ BitVec.toUInt o6 ∧ BitVec.toUInt o6 ≤ BitVec.toUInt sn) ∧ ((1 : ℤ) ≤ BitVec.toInt o9 ∧ BitVec.toInt o9 ≤ BitVec.toUInt sn) ∧ BitVec.toUInt o8 = String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp) (C.offset sp + BitVec.toInt o9) ∧ ((0 : ℤ) ≤ BitVec.toUInt o8 ∧ BitVec.toUInt o8 < HPow.hPow (BitVec.toUInt b) (Int.toNat (BitVec.toInt o9))) ∧ BitVec.toInt o9 + BitVec.toUInt o6 - (1 : ℤ) = (1 : ℤ) + (BitVec.toUInt sn - (1 : ℤ)) % BitVec.toUInt (BaseInfo.exp info) ∧ (BitVec.toInt o9 = BitVec.toUInt sn → BitVec.toUInt o6 = (1 : ℤ)))))) else ((C.min rp ≤ C.offset rp ∧ C.offset rp < C.max rp) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → C.pelts rp1 = Function.update (C.pelts rp) (C.offset rp1) w → (((0 : ℤ) ≤ BitVec.toInt j ∧ BitVec.toInt j ≤ BitVec.toUInt sn) ∧ Lemmas.value rp1 (1 : ℤ) = String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp) (C.offset sp + BitVec.toInt j) ∧ BitVec.toInt j ≤ BitVec.toUInt sn ∧ ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ BitVec.toInt sz) ∧ ((0 : ℤ) < String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toInt j) → (0 : ℤ) < BitVec.toUInt (C.pelts rp1 (C.offset rp1 + (1 : ℤ) - (1 : ℤ)))) ∧ (BitVec.toUInt sn - BitVec.toInt j) % BitVec.toUInt (BaseInfo.exp info) = (0 : ℤ)) ∧ (∀(rn : BitVec 32) (j1 : BitVec 32) (rp2 : C.ptr (BitVec 64)), List.length (C.data rp2) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → ((0 : ℤ) ≤ BitVec.toInt j1 ∧ BitVec.toInt j1 ≤ BitVec.toUInt sn) ∧ Lemmas.value rp2 (BitVec.toInt rn) = String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp) (C.offset sp + BitVec.toInt j1) ∧ BitVec.toInt j1 ≤ BitVec.toUInt sn ∧ ((0 : ℤ) ≤ BitVec.toInt rn ∧ BitVec.toInt rn ≤ BitVec.toInt sz) ∧ ((0 : ℤ) < String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toInt j1) → (0 : ℤ) < BitVec.toUInt (C.pelts rp2 (C.offset rp2 + BitVec.toInt rn - (1 : ℤ)))) ∧ (String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toInt j1) = (0 : ℤ) → BitVec.toInt rn = (1 : ℤ)) ∧ (BitVec.toUInt sn - BitVec.toInt j1) % BitVec.toUInt (BaseInfo.exp info) = (0 : ℤ) → BitVec.toUInt sn ≤ (2147483647 : ℤ) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toUInt sn → (if BitVec.toInt j1 < BitVec.toInt o7 then (C.min sp ≤ C.offset sp + BitVec.toInt j1 ∧ C.offset sp + BitVec.toInt j1 < C.max sp) ∧ (∀(o8 : BitVec 64), BitVec.toUInt o8 = BitVec.toInt (C.pelts sp (C.offset sp + BitVec.toInt j1)) → int'32_in_bounds (BitVec.toInt j1 + (1 : ℤ)) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt j1 + (1 : ℤ) → (let o10 : BitVec 32 := BaseInfo.exp info; uint'32_in_bounds (BitVec.toUInt o10 - (1 : ℤ)) ∧ (∀(o11 : BitVec 32), BitVec.toUInt o11 = BitVec.toUInt o10 - (1 : ℤ) → ((1 : ℤ) ≤ BitVec.toUInt o11 + (1 : ℤ) → (BitVec.toUInt o8 = String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp + BitVec.toInt j1) (C.offset sp + BitVec.toInt o9) ∧ ((1 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ BitVec.toUInt (BaseInfo.exp info)) ∧ BitVec.toInt o9 = BitVec.toInt j1 + (1 : ℤ)) ∧ (∀(j2 : BitVec 32) (w1 : BitVec 64), (∀(k1 : BitVec 32), let k2 : ℤ := BitVec.toUInt k1; ((1 : ℤ) ≤ k2 ∧ k2 ≤ BitVec.toUInt o11) ∧ BitVec.toUInt w1 = String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp + BitVec.toInt j1) (C.offset sp + BitVec.toInt j2) ∧ ((1 : ℤ) ≤ k2 ∧ k2 ≤ BitVec.toUInt (BaseInfo.exp info)) ∧ BitVec.toInt j2 = BitVec.toInt j1 + k2 → (C.min sp ≤ C.offset sp + BitVec.toInt j2 ∧ C.offset sp + BitVec.toInt j2 < C.max sp) ∧ (∀(sj : BitVec 64), BitVec.toUInt sj = BitVec.toInt (C.pelts sp (C.offset sp + BitVec.toInt j2)) → uint'64_in_bounds (BitVec.toUInt w1 * BitVec.toUInt b) ∧ (∀(o12 : BitVec 64), BitVec.toUInt o12 = BitVec.toUInt w1 * BitVec.toUInt b → uint'64_in_bounds (BitVec.toUInt o12 + BitVec.toUInt sj) ∧ (∀(o13 : BitVec 64), BitVec.toUInt o13 = BitVec.toUInt o12 + BitVec.toUInt sj → int'32_in_bounds (BitVec.toInt j2 + (1 : ℤ)) ∧ (∀(o14 : BitVec 32), BitVec.toInt o14 = BitVec.toInt j2 + (1 : ℤ) → BitVec.toUInt o13 = String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp + BitVec.toInt j1) (C.offset sp + BitVec.toInt o14) ∧ ((1 : ℤ) ≤ k2 + (1 : ℤ) ∧ k2 + (1 : ℤ) ≤ BitVec.toUInt (BaseInfo.exp info)) ∧ BitVec.toInt o14 = BitVec.toInt j1 + (k2 + (1 : ℤ))))))) ∧ (BitVec.toUInt w1 = String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp + BitVec.toInt j1) (C.offset sp + BitVec.toInt j2) ∧ ((1 : ℤ) ≤ BitVec.toUInt o11 + (1 : ℤ) ∧ BitVec.toUInt o11 + (1 : ℤ) ≤ BitVec.toUInt (BaseInfo.exp info)) ∧ BitVec.toInt j2 = BitVec.toInt j1 + (BitVec.toUInt o11 + (1 : ℤ)) → (C.valid rp2 (BitVec.toInt rn) ∧ C.writable rp2 = true) ∧ (∀(rp3 : C.ptr (BitVec 64)), List.length (C.data rp3) = List.length (C.data rp2) ∧ C.offset rp3 = C.offset rp2 ∧ C.min rp3 = C.min rp2 ∧ C.max rp3 = C.max rp2 ∧ C.writable rp3 = C.writable rp2 ∧ C.zone1 rp3 = C.zone1 rp2 → (∀(o12 : BitVec 64), Lemmas.value rp3 (BitVec.toInt rn) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt rn)) * BitVec.toUInt o12 = Lemmas.value rp2 (BitVec.toInt rn) * BitVec.toUInt (BaseInfo.bb info) ∧ (∀(j3 : ℤ), j3 < C.offset rp3 ∨ C.offset rp3 + BitVec.toInt rn ≤ j3 → C.pelts rp3 j3 = C.pelts rp2 j3) → (C.valid rp3 (BitVec.toInt rn) ∧ (0 : ℤ) < BitVec.toInt rn ∧ C.writable rp3 = true) ∧ (∀(rp4 : C.ptr (BitVec 64)), List.length (C.data rp4) = List.length (C.data rp3) ∧ C.offset rp4 = C.offset rp3 ∧ C.min rp4 = C.min rp3 ∧ C.max rp4 = C.max rp3 ∧ C.writable rp4 = C.writable rp3 ∧ C.zone1 rp4 = C.zone1 rp3 → (∀(cy1 : BitVec 64), Lemmas.value rp4 (BitVec.toInt rn) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt rn)) * BitVec.toUInt cy1 = Lemmas.value rp3 (BitVec.toInt rn) + BitVec.toUInt w1 ∧ ((0 : ℤ) ≤ BitVec.toUInt cy1 ∧ BitVec.toUInt cy1 ≤ (1 : ℤ)) ∧ (∀(j3 : ℤ), j3 < C.offset rp4 ∨ C.offset rp4 + BitVec.toInt rn ≤ j3 → C.pelts rp4 j3 = C.pelts rp3 j3) → uint'64_in_bounds (BitVec.toUInt o12 + BitVec.toUInt cy1) ∧ (∀(o13 : BitVec 64), BitVec.toUInt o13 = BitVec.toUInt o12 + BitVec.toUInt cy1 → (if (0 : ℤ) < BitVec.toUInt o13 then ((C.min rp4 ≤ C.offset rp4 + BitVec.toInt rn ∧ C.offset rp4 + BitVec.toInt rn < C.max rp4) ∧ C.writable rp4 = true) ∧ (∀(rp5 : C.ptr (BitVec 64)), List.length (C.data rp5) = List.length (C.data rp4) ∧ C.offset rp5 = C.offset rp4 ∧ C.min rp5 = C.min rp4 ∧ C.max rp5 = C.max rp4 ∧ C.writable rp5 = C.writable rp4 ∧ C.zone1 rp5 = C.zone1 rp4 → C.pelts rp5 = Function.update (C.pelts rp4) (C.offset rp5 + BitVec.toInt rn) o13 ∧ C.pelts rp5 (C.offset rp5 + BitVec.toInt rn) = o13 → int'32_in_bounds (BitVec.toInt rn + (1 : ℤ)) ∧ (∀(o14 : BitVec 32), BitVec.toInt o14 = BitVec.toInt rn + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt sn - BitVec.toInt j1 ∧ BitVec.toUInt sn - BitVec.toInt j2 < BitVec.toUInt sn - BitVec.toInt j1) ∧ ((0 : ℤ) ≤ BitVec.toInt j2 ∧ BitVec.toInt j2 ≤ BitVec.toUInt sn) ∧ Lemmas.value rp5 (BitVec.toInt o14) = String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp) (C.offset sp + BitVec.toInt j2) ∧ BitVec.toInt j2 ≤ BitVec.toUInt sn ∧ ((0 : ℤ) ≤ BitVec.toInt o14 ∧ BitVec.toInt o14 ≤ BitVec.toInt sz) ∧ ((0 : ℤ) < String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toInt j2) → (0 : ℤ) < BitVec.toUInt (C.pelts rp5 (C.offset rp5 + BitVec.toInt o14 - (1 : ℤ)))) ∧ (String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toInt j2) = (0 : ℤ) → BitVec.toInt o14 = (1 : ℤ)) ∧ (BitVec.toUInt sn - BitVec.toInt j2) % BitVec.toUInt (BaseInfo.exp info) = (0 : ℤ))) else ((0 : ℤ) ≤ BitVec.toUInt sn - BitVec.toInt j1 ∧ BitVec.toUInt sn - BitVec.toInt j2 < BitVec.toUInt sn - BitVec.toInt j1) ∧ ((0 : ℤ) ≤ BitVec.toInt j2 ∧ BitVec.toInt j2 ≤ BitVec.toUInt sn) ∧ Lemmas.value rp4 (BitVec.toInt rn) = String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp) (C.offset sp + BitVec.toInt j2) ∧ BitVec.toInt j2 ≤ BitVec.toUInt sn ∧ ((0 : ℤ) ≤ BitVec.toInt rn ∧ BitVec.toInt rn ≤ BitVec.toInt sz) ∧ ((0 : ℤ) < String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toInt j2) → (0 : ℤ) < BitVec.toUInt (C.pelts rp4 (C.offset rp4 + BitVec.toInt rn - (1 : ℤ)))) ∧ (String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toInt j2) = (0 : ℤ) → BitVec.toInt rn = (1 : ℤ)) ∧ (BitVec.toUInt sn - BitVec.toInt j2) % BitVec.toUInt (BaseInfo.exp info) = (0 : ℤ)))))))))) ∧ (BitVec.toUInt o11 + (1 : ℤ) < (1 : ℤ) → (C.valid rp2 (BitVec.toInt rn) ∧ C.writable rp2 = true) ∧ (∀(rp3 : C.ptr (BitVec 64)), List.length (C.data rp3) = List.length (C.data rp2) ∧ C.offset rp3 = C.offset rp2 ∧ C.min rp3 = C.min rp2 ∧ C.max rp3 = C.max rp2 ∧ C.writable rp3 = C.writable rp2 ∧ C.zone1 rp3 = C.zone1 rp2 → (∀(o12 : BitVec 64), Lemmas.value rp3 (BitVec.toInt rn) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt rn)) * BitVec.toUInt o12 = Lemmas.value rp2 (BitVec.toInt rn) * BitVec.toUInt (BaseInfo.bb info) ∧ (∀(j2 : ℤ), j2 < C.offset rp3 ∨ C.offset rp3 + BitVec.toInt rn ≤ j2 → C.pelts rp3 j2 = C.pelts rp2 j2) → (C.valid rp3 (BitVec.toInt rn) ∧ (0 : ℤ) < BitVec.toInt rn ∧ C.writable rp3 = true) ∧ (∀(rp4 : C.ptr (BitVec 64)), List.length (C.data rp4) = List.length (C.data rp3) ∧ C.offset rp4 = C.offset rp3 ∧ C.min rp4 = C.min rp3 ∧ C.max rp4 = C.max rp3 ∧ C.writable rp4 = C.writable rp3 ∧ C.zone1 rp4 = C.zone1 rp3 → (∀(cy1 : BitVec 64), Lemmas.value rp4 (BitVec.toInt rn) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt rn)) * BitVec.toUInt cy1 = Lemmas.value rp3 (BitVec.toInt rn) + BitVec.toUInt o8 ∧ ((0 : ℤ) ≤ BitVec.toUInt cy1 ∧ BitVec.toUInt cy1 ≤ (1 : ℤ)) ∧ (∀(j2 : ℤ), j2 < C.offset rp4 ∨ C.offset rp4 + BitVec.toInt rn ≤ j2 → C.pelts rp4 j2 = C.pelts rp3 j2) → uint'64_in_bounds (BitVec.toUInt o12 + BitVec.toUInt cy1) ∧ (∀(o13 : BitVec 64), BitVec.toUInt o13 = BitVec.toUInt o12 + BitVec.toUInt cy1 → (if (0 : ℤ) < BitVec.toUInt o13 then ((C.min rp4 ≤ C.offset rp4 + BitVec.toInt rn ∧ C.offset rp4 + BitVec.toInt rn < C.max rp4) ∧ C.writable rp4 = true) ∧ (∀(rp5 : C.ptr (BitVec 64)), List.length (C.data rp5) = List.length (C.data rp4) ∧ C.offset rp5 = C.offset rp4 ∧ C.min rp5 = C.min rp4 ∧ C.max rp5 = C.max rp4 ∧ C.writable rp5 = C.writable rp4 ∧ C.zone1 rp5 = C.zone1 rp4 → C.pelts rp5 = Function.update (C.pelts rp4) (C.offset rp5 + BitVec.toInt rn) o13 ∧ C.pelts rp5 (C.offset rp5 + BitVec.toInt rn) = o13 → int'32_in_bounds (BitVec.toInt rn + (1 : ℤ)) ∧ (∀(o14 : BitVec 32), BitVec.toInt o14 = BitVec.toInt rn + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toUInt sn - BitVec.toInt j1 ∧ BitVec.toUInt sn - BitVec.toInt o9 < BitVec.toUInt sn - BitVec.toInt j1) ∧ ((0 : ℤ) ≤ BitVec.toInt o9 ∧ BitVec.toInt o9 ≤ BitVec.toUInt sn) ∧ Lemmas.value rp5 (BitVec.toInt o14) = String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp) (C.offset sp + BitVec.toInt o9) ∧ BitVec.toInt o9 ≤ BitVec.toUInt sn ∧ ((0 : ℤ) ≤ BitVec.toInt o14 ∧ BitVec.toInt o14 ≤ BitVec.toInt sz) ∧ ((0 : ℤ) < String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toInt o9) → (0 : ℤ) < BitVec.toUInt (C.pelts rp5 (C.offset rp5 + BitVec.toInt o14 - (1 : ℤ)))) ∧ (String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toInt o9) = (0 : ℤ) → BitVec.toInt o14 = (1 : ℤ)) ∧ (BitVec.toUInt sn - BitVec.toInt o9) % BitVec.toUInt (BaseInfo.exp info) = (0 : ℤ))) else ((0 : ℤ) ≤ BitVec.toUInt sn - BitVec.toInt j1 ∧ BitVec.toUInt sn - BitVec.toInt o9 < BitVec.toUInt sn - BitVec.toInt j1) ∧ ((0 : ℤ) ≤ BitVec.toInt o9 ∧ BitVec.toInt o9 ≤ BitVec.toUInt sn) ∧ Lemmas.value rp4 (BitVec.toInt rn) = String_lemmas.svalue_sub (BitVec.toUInt b) (C.pelts sp) (C.offset sp) (C.offset sp + BitVec.toInt o9) ∧ BitVec.toInt o9 ≤ BitVec.toUInt sn ∧ ((0 : ℤ) ≤ BitVec.toInt rn ∧ BitVec.toInt rn ≤ BitVec.toInt sz) ∧ ((0 : ℤ) < String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toInt o9) → (0 : ℤ) < BitVec.toUInt (C.pelts rp4 (C.offset rp4 + BitVec.toInt rn - (1 : ℤ)))) ∧ (String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toInt o9) = (0 : ℤ) → BitVec.toInt rn = (1 : ℤ)) ∧ (BitVec.toUInt sn - BitVec.toInt o9) % BitVec.toUInt (BaseInfo.exp info) = (0 : ℤ)))))))))))) else ((0 : ℤ) < String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toUInt sn) → (1 : ℤ) ≤ BitVec.toInt rn ∧ BitVec.toInt rn ≤ BitVec.toInt sz) ∧ Lemmas.value rp2 (BitVec.toInt rn) = String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toUInt sn) ∧ ((0 : ℤ) < String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toUInt sn) → (0 : ℤ) < BitVec.toUInt (C.pelts rp2 (C.offset rp2 + BitVec.toInt rn - (1 : ℤ)))) ∧ (String_lemmas.svalue (BitVec.toUInt b) sp (BitVec.toUInt sn) = (0 : ℤ) → BitVec.toInt rn = (1 : ℤ)) ∧ (0 : ℤ) < BitVec.toInt rn)))))))))))
  := sorry
end set_str_Set_str_wmpn_set_str_otherqtvc
