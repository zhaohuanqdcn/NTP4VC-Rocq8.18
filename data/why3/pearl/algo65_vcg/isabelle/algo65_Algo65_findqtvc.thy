theory algo65_Algo65_findqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut"
begin
theorem find'vc:
  fixes m :: "int"
  fixes k :: "int"
  fixes n :: "int"
  fixes a :: "int list"
  assumes fact0: "(0 :: int) \<le> m"
  assumes fact1: "m \<le> k"
  assumes fact2: "k \<le> n"
  assumes fact3: "n < int (length a)"
  shows "if m < n then ((0 :: int) \<le> m \<and> m < n \<and> n < int (length a)) \<and> (\<forall>(j :: int) (i :: int) (a1 :: int list). length a1 = length a \<longrightarrow> (m \<le> j \<and> j < i \<and> i \<le> n) \<and> permut_sub' a a1 (nat m) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). m \<le> r \<and> r \<le> j \<longrightarrow> a1 ! nat r \<le> (42 :: int)) \<and> (\<forall>(r :: int). j < r \<and> r < i \<longrightarrow> a1 ! nat r = (42 :: int)) \<and> (\<forall>(r :: int). i \<le> r \<and> r \<le> n \<longrightarrow> (42 :: int) \<le> a1 ! nat r) \<longrightarrow> (if k \<le> j then (((0 :: int) \<le> n - m \<and> j - m < n - m) \<and> (0 :: int) \<le> m \<and> m \<le> k \<and> k \<le> j \<and> j < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> permut_sub' a1 a2 (nat m) (nat (j + (1 :: int))) \<and> (\<forall>(r :: int). m \<le> r \<and> r \<le> k \<longrightarrow> a2 ! nat r \<le> a2 ! nat k) \<and> (\<forall>(r :: int). k \<le> r \<and> r \<le> j \<longrightarrow> a2 ! nat k \<le> a2 ! nat r) \<longrightarrow> (if i \<le> k then (((0 :: int) \<le> n - m \<and> n - i < n - m) \<and> (0 :: int) \<le> i \<and> i \<le> k \<and> k \<le> n \<and> n < int (length a2)) \<and> (\<forall>(a3 :: int list). length a3 = length a2 \<longrightarrow> permut_sub' a2 a3 (nat i) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). i \<le> r \<and> r \<le> k \<longrightarrow> a3 ! nat r \<le> a3 ! nat k) \<and> (\<forall>(r :: int). k \<le> r \<and> r \<le> n \<longrightarrow> a3 ! nat k \<le> a3 ! nat r) \<longrightarrow> permut_sub' a a3 (nat m) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). m \<le> r \<and> r \<le> k \<longrightarrow> a3 ! nat r \<le> a3 ! nat k) \<and> (\<forall>(r :: int). k \<le> r \<and> r \<le> n \<longrightarrow> a3 ! nat k \<le> a3 ! nat r)) else permut_sub' a a2 (nat m) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). m \<le> r \<and> r \<le> k \<longrightarrow> a2 ! nat r \<le> a2 ! nat k) \<and> (\<forall>(r :: int). k \<le> r \<and> r \<le> n \<longrightarrow> a2 ! nat k \<le> a2 ! nat r))) else if i \<le> k then (((0 :: int) \<le> n - m \<and> n - i < n - m) \<and> (0 :: int) \<le> i \<and> i \<le> k \<and> k \<le> n \<and> n < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> permut_sub' a1 a2 (nat i) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). i \<le> r \<and> r \<le> k \<longrightarrow> a2 ! nat r \<le> a2 ! nat k) \<and> (\<forall>(r :: int). k \<le> r \<and> r \<le> n \<longrightarrow> a2 ! nat k \<le> a2 ! nat r) \<longrightarrow> permut_sub' a a2 (nat m) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). m \<le> r \<and> r \<le> k \<longrightarrow> a2 ! nat r \<le> a2 ! nat k) \<and> (\<forall>(r :: int). k \<le> r \<and> r \<le> n \<longrightarrow> a2 ! nat k \<le> a2 ! nat r)) else permut_sub' a a1 (nat m) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). m \<le> r \<and> r \<le> k \<longrightarrow> a1 ! nat r \<le> a1 ! nat k) \<and> (\<forall>(r :: int). k \<le> r \<and> r \<le> n \<longrightarrow> a1 ! nat k \<le> a1 ! nat r))) else permut_sub' a a (nat m) (nat (n + (1 :: int))) \<and> (\<forall>(r :: int). m \<le> r \<and> r \<le> k \<longrightarrow> a ! nat r \<le> a ! nat k) \<and> (\<forall>(r :: int). k \<le> r \<and> r \<le> n \<longrightarrow> a ! nat k \<le> a ! nat r)"
  sorry
end
