import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mpz.Z
import pearl.multiprecision.lib.lean.mpz.Zutil
open Classical
open Lean4Why3
namespace mpz_div_Zdiv_wmpz_tdiv_qr_uiqtvc
theorem wmpz_tdiv_qr_ui'vc (mpz : Z.mpz_memo) (dividend : Z.mpz_ptr) (quot : Z.mpz_ptr) (rem : Z.mpz_ptr) (divisor : BitVec 64) (fact0 : (0 : ℤ) < Z.alloc mpz dividend) (fact1 : (0 : ℤ) < Z.alloc mpz quot) (fact2 : (0 : ℤ) < Z.alloc mpz rem) (fact3 : Z.readers mpz dividend = (0 : ℤ)) (fact4 : Z.readers mpz quot = (0 : ℤ)) (fact5 : Z.readers mpz rem = (0 : ℤ)) (fact6 : ¬quot = rem) (fact7 : (0 : ℤ) < BitVec.toUInt divisor) : -(2 : ℤ) < Z.readers mpz dividend ∧ (∀(ns : BitVec 32), BitVec.toInt ns = Z.sgn mpz dividend * Z.abs_size mpz dividend → (∀(o1 : Bool), (BitVec.toInt ns = BitVec.toInt (0 : BitVec 32) → o1 = true) ∧ (o1 = true → ns = (0 : BitVec 32)) → (if o1 = true then (-(1 : ℤ) ≤ Z.readers mpz quot ∧ Z.readers mpz quot ≤ (0 : ℤ)) ∧ (∀(mpz1 : Z.mpz_memo), Z.alloc mpz1 = Z.alloc mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.readers mpz1 = Z.readers mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(y : Z.mpz_ptr), ¬y = quot → Z.mpz_unchanged y mpz1 mpz) ∧ Z.abs_size mpz1 quot = (0 : ℤ) ∧ Z.abs_value_of mpz1 quot = (0 : ℤ) → (-(1 : ℤ) ≤ Z.readers mpz1 rem ∧ Z.readers mpz1 rem ≤ (0 : ℤ)) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = rem → Z.mpz_unchanged y mpz2 mpz1) ∧ Z.abs_size mpz2 rem = (0 : ℤ) ∧ Z.abs_value_of mpz2 rem = (0 : ℤ) → Z.value_of quot mpz2 * BitVec.toUInt divisor + Z.value_of rem mpz2 = Z.value_of dividend mpz ∧ (0 : ℤ) = Z.abs_value_of mpz2 rem ∧ ((0 : ℤ) ≤ Z.abs_value_of mpz2 rem ∧ Z.abs_value_of mpz2 rem < BitVec.toUInt divisor) ∧ (∀(x : Z.mpz_ptr), ¬x = quot → ¬x = rem → Z.mpz_unchanged x mpz2 mpz) ∧ Z.readers mpz2 dividend = (0 : ℤ) ∧ Z.readers mpz2 quot = (0 : ℤ) ∧ Z.readers mpz2 rem = (0 : ℤ))) else -(2147483648 : ℤ) < BitVec.toInt ns ∧ (∀(nn : BitVec 32), BitVec.toInt nn = abs (BitVec.toInt ns) → (Z.readers mpz quot = (0 : ℤ) ∧ (1 : ℤ) ≤ Z.alloc mpz quot) ∧ (∀(mpz1 : Z.mpz_memo), Z.sgn mpz1 = Z.sgn mpz → (∀(qp : C.ptr (BitVec 64)), (∀(y : Z.mpz_ptr), ¬y = quot → Z.mpz_unchanged y mpz1 mpz) ∧ Z.readers mpz1 quot = -(1 : ℤ) ∧ Z.abs_value_of mpz1 quot = Lemmas.value qp (Z.abs_size mpz1 quot) ∧ Z.zones mpz1 quot = C.zone1 qp ∧ C.offset qp = (0 : ℤ) ∧ C.plength qp = Z.alloc mpz1 quot ∧ C.min qp = (0 : ℤ) ∧ C.max qp = C.plength qp ∧ C.writable qp = true ∧ Z.abs_size mpz1 quot = Z.abs_size mpz quot ∧ Lemmas.value qp (Z.abs_size mpz quot) = Z.abs_value_of mpz quot ∧ (if Z.alloc mpz quot < BitVec.toInt nn then Z.alloc mpz1 quot = BitVec.toInt nn else Z.alloc mpz1 quot = Z.alloc mpz quot) → Z.mpz_eq quot dividend = (quot = dividend) → (¬Z.mpz_eq quot dividend → Z.mpz_unchanged dividend mpz1 mpz) ∧ ((¬Z.mpz_eq quot dividend → Z.readers mpz1 dividend = Z.readers mpz dividend ∧ (-(2 : ℤ) < Z.readers mpz1 dividend → Z.abs_value_of mpz1 dividend = Z.abs_value_of mpz dividend ∧ Z.alloc mpz1 dividend = Z.alloc mpz dividend ∧ Z.abs_size mpz1 dividend = Z.abs_size mpz dividend ∧ Z.sgn mpz1 dividend = Z.sgn mpz dividend ∧ Z.readers mpz1 dividend = Z.readers mpz dividend ∧ Z.zones mpz1 dividend = Z.zones mpz dividend)) → Z.mpz_unchanged rem mpz1 mpz ∧ (Z.readers mpz1 rem = Z.readers mpz rem ∧ (-(2 : ℤ) < Z.readers mpz1 rem → Z.abs_value_of mpz1 rem = Z.abs_value_of mpz rem ∧ Z.alloc mpz1 rem = Z.alloc mpz rem ∧ Z.abs_size mpz1 rem = Z.abs_size mpz rem ∧ Z.sgn mpz1 rem = Z.sgn mpz rem ∧ Z.readers mpz1 rem = Z.readers mpz rem ∧ Z.zones mpz1 rem = Z.zones mpz rem) → Z.mpz_eq quot dividend = (quot = dividend) → (if Z.mpz_eq quot dividend then (0 : ℤ) ≤ BitVec.toInt nn ∧ (∀(o2 : BitVec 32), BitVec.toUInt o2 = BitVec.toInt nn → (0 : ℤ) ≤ BitVec.toUInt o2 ∧ (∀(np : C.ptr (BitVec 64)), C.plength np = BitVec.toUInt o2 ∧ C.offset np = (0 : ℤ) ∧ C.min np = (0 : ℤ) ∧ C.max np = BitVec.toUInt o2 ∧ C.writable np = true → (C.valid qp (BitVec.toInt nn) ∧ C.valid np (BitVec.toInt nn) ∧ C.writable np = true) ∧ (∀(np1 : C.ptr (BitVec 64)) (qp1 : C.ptr (BitVec 64)), C.offset np1 = C.offset np ∧ C.writable np1 = C.writable np ∧ C.zone1 np1 = C.zone1 np → C.offset qp1 = C.offset qp ∧ C.writable qp1 = C.writable qp ∧ C.zone1 qp1 = C.zone1 qp → Lemmas.map_eq_sub_shift (C.pelts np1) (C.pelts qp) (C.offset np1) (C.offset qp) (BitVec.toInt nn) ∧ (∀(j : ℤ), j < C.offset np1 ∨ C.offset np1 + BitVec.toInt nn ≤ j → C.pelts np1 j = C.pelts np j) ∧ (∀(j : ℤ), C.pelts qp1 j = C.pelts qp j) ∧ (C.min qp1 = C.min qp ∧ C.max qp1 = C.max qp ∧ C.plength qp1 = C.plength qp) ∧ C.min np1 = C.min np ∧ C.max np1 = C.max np ∧ C.plength np1 = C.plength np → (C.valid np1 (BitVec.toInt nn) ∧ C.valid qp1 (BitVec.toInt nn) ∧ C.writable qp1 = true ∧ (0 : ℤ) < BitVec.toInt nn ∧ (0 : ℤ) < BitVec.toUInt divisor) ∧ (∀(qp2 : C.ptr (BitVec 64)), List.length (C.data qp2) = List.length (C.data qp1) ∧ C.offset qp2 = C.offset qp1 ∧ C.min qp2 = C.min qp1 ∧ C.max qp2 = C.max qp1 ∧ C.writable qp2 = C.writable qp1 ∧ C.zone1 qp2 = C.zone1 qp1 → (∀(o3 : BitVec 64), Lemmas.value np1 (BitVec.toInt nn) = Lemmas.value qp2 (BitVec.toInt nn) * BitVec.toUInt divisor + BitVec.toUInt o3 ∧ BitVec.toUInt o3 < BitVec.toUInt divisor → (∀(o4 : Bool), (BitVec.toUInt o3 = BitVec.toUInt (0 : BitVec 64) → o4 = true) ∧ (o4 = true → o3 = (0 : BitVec 64)) → (if o4 = true then (-(1 : ℤ) ≤ Z.readers mpz1 rem ∧ Z.readers mpz1 rem ≤ (0 : ℤ)) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = rem → Z.mpz_unchanged y mpz2 mpz1) ∧ Z.abs_size mpz2 rem = (0 : ℤ) ∧ Z.abs_value_of mpz2 rem = (0 : ℤ) → int'32_in_bounds (BitVec.toInt nn - (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt nn - (1 : ℤ) → (C.min qp2 ≤ C.offset qp2 + BitVec.toInt o5 ∧ C.offset qp2 + BitVec.toInt o5 < C.max qp2) ∧ (let qh : BitVec 64 := C.pelts qp2 (C.offset qp2 + BitVec.toInt o5); ∀(o6 : Bool), (BitVec.toUInt qh = BitVec.toUInt (0 : BitVec 64) → o6 = true) ∧ (o6 = true → qh = (0 : BitVec 64)) → (∀(o7 : BitVec 32), (if o6 = true then o7 = (1 : BitVec 32) else o7 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt nn - BitVec.toInt o7) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt nn - BitVec.toInt o7 → (¬(0 : ℤ) ≤ BitVec.toInt ns → int'32_in_bounds (-BitVec.toInt o8)) ∧ (∀(qs : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt ns then qs = o8 else BitVec.toInt qs = -BitVec.toInt o8) → (Z.zones mpz2 quot = C.zone1 qp2 ∧ Z.readers mpz2 quot = -(1 : ℤ) ∧ C.offset qp2 = (0 : ℤ) ∧ C.min qp2 = (0 : ℤ) ∧ C.max qp2 = C.plength qp2 ∧ abs (BitVec.toInt qs) ≤ C.plength qp2 ∧ C.plength qp2 = Z.alloc mpz2 quot ∧ (¬BitVec.toInt qs = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt qs) - (1 : ℤ))) ≤ Lemmas.value qp2 (abs (BitVec.toInt qs)))) ∧ (∀(mpz3 : Z.mpz_memo), Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.readers mpz3 = Z.readers mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → (∀(y : Z.mpz_ptr), ¬y = quot → Z.mpz_unchanged y mpz3 mpz2) ∧ (Z.sgn mpz3 quot = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt qs) ∧ (Z.sgn mpz3 quot = -(1 : ℤ)) = (BitVec.toInt qs < (0 : ℤ)) ∧ Z.abs_size mpz3 quot = abs (BitVec.toInt qs) ∧ Z.abs_value_of mpz3 quot = Lemmas.value qp2 (abs (BitVec.toInt qs)) → (Z.zones mpz3 quot = C.zone1 qp2 ∧ Z.readers mpz3 quot = -(1 : ℤ) ∧ C.min qp2 = (0 : ℤ) ∧ C.max qp2 = C.plength qp2 ∧ Z.abs_value_of mpz3 quot = Lemmas.value qp2 (Z.abs_size mpz3 quot)) ∧ (∀(mpz4 : Z.mpz_memo), Z.abs_value_of mpz4 = Z.abs_value_of mpz3 ∧ Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → Z.readers mpz4 quot = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = quot → Z.readers mpz4 y = Z.readers mpz3 y) → Z.mpz_unchanged rem mpz4 mpz2 ∧ (Z.readers mpz4 rem = Z.readers mpz2 rem ∧ (-(2 : ℤ) < Z.readers mpz4 rem → Z.abs_value_of mpz4 rem = Z.abs_value_of mpz2 rem ∧ Z.alloc mpz4 rem = Z.alloc mpz2 rem ∧ Z.abs_size mpz4 rem = Z.abs_size mpz2 rem ∧ Z.sgn mpz4 rem = Z.sgn mpz2 rem ∧ Z.readers mpz4 rem = Z.readers mpz2 rem ∧ Z.zones mpz4 rem = Z.zones mpz2 rem) → Z.value_of quot mpz4 * BitVec.toUInt divisor + Z.value_of rem mpz4 = Z.value_of dividend mpz ∧ BitVec.toUInt o3 = Z.abs_value_of mpz4 rem ∧ ((0 : ℤ) ≤ Z.abs_value_of mpz4 rem ∧ Z.abs_value_of mpz4 rem < BitVec.toUInt divisor) ∧ (∀(x : Z.mpz_ptr), ¬x = quot → ¬x = rem → Z.mpz_unchanged x mpz4 mpz) ∧ Z.readers mpz4 dividend = (0 : ℤ) ∧ Z.readers mpz4 quot = (0 : ℤ) ∧ Z.readers mpz4 rem = (0 : ℤ)))))))))) else ∀(rs : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt ns then rs = (1 : BitVec 32) else rs = -(1 : BitVec 32)) → Z.readers mpz1 rem = (0 : ℤ) ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(rp : C.ptr (BitVec 64)), Z.readers mpz2 rem = -(1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬rem = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value rp (Z.abs_size mpz2 rem) = Z.abs_value_of mpz2 rem ∧ C.plength rp = Z.alloc mpz2 rem ∧ C.offset rp = (0 : ℤ) ∧ C.min rp = (0 : ℤ) ∧ C.max rp = C.plength rp ∧ C.writable rp = true ∧ C.zone1 rp = Z.zones mpz2 rem → ((C.min rp ≤ C.offset rp ∧ C.offset rp < C.max rp) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → C.pelts rp1 = Function.update (C.pelts rp) (C.offset rp1) o3 → (Z.zones mpz2 rem = C.zone1 rp1 ∧ Z.readers mpz2 rem = -(1 : ℤ) ∧ C.offset rp1 = (0 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ abs (BitVec.toInt rs) ≤ C.plength rp1 ∧ C.plength rp1 = Z.alloc mpz2 rem ∧ (¬BitVec.toInt rs = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt rs) - (1 : ℤ))) ≤ Lemmas.value rp1 (abs (BitVec.toInt rs)))) ∧ (∀(mpz3 : Z.mpz_memo), Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.readers mpz3 = Z.readers mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → (∀(y : Z.mpz_ptr), ¬y = rem → Z.mpz_unchanged y mpz3 mpz2) ∧ (Z.sgn mpz3 rem = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt rs) ∧ (Z.sgn mpz3 rem = -(1 : ℤ)) = (BitVec.toInt rs < (0 : ℤ)) ∧ Z.abs_size mpz3 rem = abs (BitVec.toInt rs) ∧ Z.abs_value_of mpz3 rem = Lemmas.value rp1 (abs (BitVec.toInt rs)) → (Z.zones mpz3 rem = C.zone1 rp1 ∧ Z.readers mpz3 rem = -(1 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ Z.abs_value_of mpz3 rem = Lemmas.value rp1 (Z.abs_size mpz3 rem)) ∧ (∀(mpz4 : Z.mpz_memo), Z.abs_value_of mpz4 = Z.abs_value_of mpz3 ∧ Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → Z.readers mpz4 rem = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = rem → Z.readers mpz4 y = Z.readers mpz3 y) → int'32_in_bounds (BitVec.toInt nn - (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt nn - (1 : ℤ) → (C.min qp2 ≤ C.offset qp2 + BitVec.toInt o5 ∧ C.offset qp2 + BitVec.toInt o5 < C.max qp2) ∧ (let qh : BitVec 64 := C.pelts qp2 (C.offset qp2 + BitVec.toInt o5); ∀(o6 : Bool), (BitVec.toUInt qh = BitVec.toUInt (0 : BitVec 64) → o6 = true) ∧ (o6 = true → qh = (0 : BitVec 64)) → (∀(o7 : BitVec 32), (if o6 = true then o7 = (1 : BitVec 32) else o7 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt nn - BitVec.toInt o7) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt nn - BitVec.toInt o7 → (¬(0 : ℤ) ≤ BitVec.toInt ns → int'32_in_bounds (-BitVec.toInt o8)) ∧ (∀(qs : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt ns then qs = o8 else BitVec.toInt qs = -BitVec.toInt o8) → (Z.zones mpz4 quot = C.zone1 qp2 ∧ Z.readers mpz4 quot = -(1 : ℤ) ∧ C.offset qp2 = (0 : ℤ) ∧ C.min qp2 = (0 : ℤ) ∧ C.max qp2 = C.plength qp2 ∧ abs (BitVec.toInt qs) ≤ C.plength qp2 ∧ C.plength qp2 = Z.alloc mpz4 quot ∧ (¬BitVec.toInt qs = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt qs) - (1 : ℤ))) ≤ Lemmas.value qp2 (abs (BitVec.toInt qs)))) ∧ (∀(mpz5 : Z.mpz_memo), Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.readers mpz5 = Z.readers mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → (∀(y : Z.mpz_ptr), ¬y = quot → Z.mpz_unchanged y mpz5 mpz4) ∧ (Z.sgn mpz5 quot = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt qs) ∧ (Z.sgn mpz5 quot = -(1 : ℤ)) = (BitVec.toInt qs < (0 : ℤ)) ∧ Z.abs_size mpz5 quot = abs (BitVec.toInt qs) ∧ Z.abs_value_of mpz5 quot = Lemmas.value qp2 (abs (BitVec.toInt qs)) → (Z.zones mpz5 quot = C.zone1 qp2 ∧ Z.readers mpz5 quot = -(1 : ℤ) ∧ C.min qp2 = (0 : ℤ) ∧ C.max qp2 = C.plength qp2 ∧ Z.abs_value_of mpz5 quot = Lemmas.value qp2 (Z.abs_size mpz5 quot)) ∧ (∀(mpz6 : Z.mpz_memo), Z.abs_value_of mpz6 = Z.abs_value_of mpz5 ∧ Z.alloc mpz6 = Z.alloc mpz5 ∧ Z.abs_size mpz6 = Z.abs_size mpz5 ∧ Z.sgn mpz6 = Z.sgn mpz5 ∧ Z.zones mpz6 = Z.zones mpz5 → Z.readers mpz6 quot = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = quot → Z.readers mpz6 y = Z.readers mpz5 y) → Z.mpz_unchanged rem mpz6 mpz4 ∧ (Z.readers mpz6 rem = Z.readers mpz4 rem ∧ (-(2 : ℤ) < Z.readers mpz6 rem → Z.abs_value_of mpz6 rem = Z.abs_value_of mpz4 rem ∧ Z.alloc mpz6 rem = Z.alloc mpz4 rem ∧ Z.abs_size mpz6 rem = Z.abs_size mpz4 rem ∧ Z.sgn mpz6 rem = Z.sgn mpz4 rem ∧ Z.readers mpz6 rem = Z.readers mpz4 rem ∧ Z.zones mpz6 rem = Z.zones mpz4 rem) → Z.value_of quot mpz6 * BitVec.toUInt divisor + Z.value_of rem mpz6 = Z.value_of dividend mpz ∧ BitVec.toUInt o3 = Z.abs_value_of mpz6 rem ∧ ((0 : ℤ) ≤ Z.abs_value_of mpz6 rem ∧ Z.abs_value_of mpz6 rem < BitVec.toUInt divisor) ∧ (∀(x : Z.mpz_ptr), ¬x = quot → ¬x = rem → Z.mpz_unchanged x mpz6 mpz) ∧ Z.readers mpz6 dividend = (0 : ℤ) ∧ Z.readers mpz6 quot = (0 : ℤ) ∧ Z.readers mpz6 rem = (0 : ℤ))))))))))))))))))))) else (0 : ℤ) ≤ Z.readers mpz1 dividend ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(np : C.ptr (BitVec 64)), Z.readers mpz2 dividend = Z.readers mpz1 dividend + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬dividend = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value np (Z.abs_size mpz2 dividend) = Z.abs_value_of mpz2 dividend ∧ C.plength np = Z.alloc mpz2 dividend ∧ C.offset np = (0 : ℤ) ∧ C.min np = (0 : ℤ) ∧ C.max np = C.plength np ∧ C.zone1 np = Z.zones mpz2 dividend → (C.valid np (BitVec.toInt nn) ∧ C.valid qp (BitVec.toInt nn) ∧ C.writable qp = true ∧ (0 : ℤ) < BitVec.toInt nn ∧ (0 : ℤ) < BitVec.toUInt divisor) ∧ (∀(qp1 : C.ptr (BitVec 64)), List.length (C.data qp1) = List.length (C.data qp) ∧ C.offset qp1 = C.offset qp ∧ C.min qp1 = C.min qp ∧ C.max qp1 = C.max qp ∧ C.writable qp1 = C.writable qp ∧ C.zone1 qp1 = C.zone1 qp → (∀(o2 : BitVec 64), Lemmas.value np (BitVec.toInt nn) = Lemmas.value qp1 (BitVec.toInt nn) * BitVec.toUInt divisor + BitVec.toUInt o2 ∧ BitVec.toUInt o2 < BitVec.toUInt divisor → (Z.zones mpz2 dividend = C.zone1 np ∧ (1 : ℤ) ≤ Z.readers mpz2 dividend ∧ C.min np = (0 : ℤ) ∧ C.max np = C.plength np) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 dividend = Z.readers mpz2 dividend - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = dividend → Z.readers mpz3 y = Z.readers mpz2 y) → Z.mpz_eq rem dividend = (rem = dividend) → (¬Z.mpz_eq rem dividend → Z.mpz_unchanged rem mpz3 mpz) ∧ ((¬Z.mpz_eq rem dividend → Z.readers mpz3 rem = Z.readers mpz rem ∧ (-(2 : ℤ) < Z.readers mpz3 rem → Z.abs_value_of mpz3 rem = Z.abs_value_of mpz rem ∧ Z.alloc mpz3 rem = Z.alloc mpz rem ∧ Z.abs_size mpz3 rem = Z.abs_size mpz rem ∧ Z.sgn mpz3 rem = Z.sgn mpz rem ∧ Z.readers mpz3 rem = Z.readers mpz rem ∧ Z.zones mpz3 rem = Z.zones mpz rem)) → (∀(o3 : Bool), (BitVec.toUInt o2 = BitVec.toUInt (0 : BitVec 64) → o3 = true) ∧ (o3 = true → o2 = (0 : BitVec 64)) → (if o3 = true then (-(1 : ℤ) ≤ Z.readers mpz3 rem ∧ Z.readers mpz3 rem ≤ (0 : ℤ)) ∧ (∀(mpz4 : Z.mpz_memo), Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.readers mpz4 = Z.readers mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → (∀(y : Z.mpz_ptr), ¬y = rem → Z.mpz_unchanged y mpz4 mpz3) ∧ Z.abs_size mpz4 rem = (0 : ℤ) ∧ Z.abs_value_of mpz4 rem = (0 : ℤ) → int'32_in_bounds (BitVec.toInt nn - (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt nn - (1 : ℤ) → (C.min qp1 ≤ C.offset qp1 + BitVec.toInt o4 ∧ C.offset qp1 + BitVec.toInt o4 < C.max qp1) ∧ (let qh : BitVec 64 := C.pelts qp1 (C.offset qp1 + BitVec.toInt o4); ∀(o5 : Bool), (BitVec.toUInt qh = BitVec.toUInt (0 : BitVec 64) → o5 = true) ∧ (o5 = true → qh = (0 : BitVec 64)) → (∀(o6 : BitVec 32), (if o5 = true then o6 = (1 : BitVec 32) else o6 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt nn - BitVec.toInt o6) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt nn - BitVec.toInt o6 → (¬(0 : ℤ) ≤ BitVec.toInt ns → int'32_in_bounds (-BitVec.toInt o7)) ∧ (∀(qs : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt ns then qs = o7 else BitVec.toInt qs = -BitVec.toInt o7) → (Z.zones mpz4 quot = C.zone1 qp1 ∧ Z.readers mpz4 quot = -(1 : ℤ) ∧ C.offset qp1 = (0 : ℤ) ∧ C.min qp1 = (0 : ℤ) ∧ C.max qp1 = C.plength qp1 ∧ abs (BitVec.toInt qs) ≤ C.plength qp1 ∧ C.plength qp1 = Z.alloc mpz4 quot ∧ (¬BitVec.toInt qs = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt qs) - (1 : ℤ))) ≤ Lemmas.value qp1 (abs (BitVec.toInt qs)))) ∧ (∀(mpz5 : Z.mpz_memo), Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.readers mpz5 = Z.readers mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → (∀(y : Z.mpz_ptr), ¬y = quot → Z.mpz_unchanged y mpz5 mpz4) ∧ (Z.sgn mpz5 quot = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt qs) ∧ (Z.sgn mpz5 quot = -(1 : ℤ)) = (BitVec.toInt qs < (0 : ℤ)) ∧ Z.abs_size mpz5 quot = abs (BitVec.toInt qs) ∧ Z.abs_value_of mpz5 quot = Lemmas.value qp1 (abs (BitVec.toInt qs)) → (Z.zones mpz5 quot = C.zone1 qp1 ∧ Z.readers mpz5 quot = -(1 : ℤ) ∧ C.min qp1 = (0 : ℤ) ∧ C.max qp1 = C.plength qp1 ∧ Z.abs_value_of mpz5 quot = Lemmas.value qp1 (Z.abs_size mpz5 quot)) ∧ (∀(mpz6 : Z.mpz_memo), Z.abs_value_of mpz6 = Z.abs_value_of mpz5 ∧ Z.alloc mpz6 = Z.alloc mpz5 ∧ Z.abs_size mpz6 = Z.abs_size mpz5 ∧ Z.sgn mpz6 = Z.sgn mpz5 ∧ Z.zones mpz6 = Z.zones mpz5 → Z.readers mpz6 quot = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = quot → Z.readers mpz6 y = Z.readers mpz5 y) → Z.mpz_unchanged rem mpz6 mpz4 ∧ (Z.readers mpz6 rem = Z.readers mpz4 rem ∧ (-(2 : ℤ) < Z.readers mpz6 rem → Z.abs_value_of mpz6 rem = Z.abs_value_of mpz4 rem ∧ Z.alloc mpz6 rem = Z.alloc mpz4 rem ∧ Z.abs_size mpz6 rem = Z.abs_size mpz4 rem ∧ Z.sgn mpz6 rem = Z.sgn mpz4 rem ∧ Z.readers mpz6 rem = Z.readers mpz4 rem ∧ Z.zones mpz6 rem = Z.zones mpz4 rem) → Z.value_of quot mpz6 * BitVec.toUInt divisor + Z.value_of rem mpz6 = Z.value_of dividend mpz ∧ BitVec.toUInt o2 = Z.abs_value_of mpz6 rem ∧ ((0 : ℤ) ≤ Z.abs_value_of mpz6 rem ∧ Z.abs_value_of mpz6 rem < BitVec.toUInt divisor) ∧ (∀(x : Z.mpz_ptr), ¬x = quot → ¬x = rem → Z.mpz_unchanged x mpz6 mpz) ∧ Z.readers mpz6 dividend = (0 : ℤ) ∧ Z.readers mpz6 quot = (0 : ℤ) ∧ Z.readers mpz6 rem = (0 : ℤ)))))))))) else ∀(rs : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt ns then rs = (1 : BitVec 32) else rs = -(1 : BitVec 32)) → Z.readers mpz3 rem = (0 : ℤ) ∧ (∀(mpz4 : Z.mpz_memo), Z.abs_value_of mpz4 = Z.abs_value_of mpz3 ∧ Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → (∀(rp : C.ptr (BitVec 64)), Z.readers mpz4 rem = -(1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬rem = y → Z.readers mpz4 y = Z.readers mpz3 y) ∧ Lemmas.value rp (Z.abs_size mpz4 rem) = Z.abs_value_of mpz4 rem ∧ C.plength rp = Z.alloc mpz4 rem ∧ C.offset rp = (0 : ℤ) ∧ C.min rp = (0 : ℤ) ∧ C.max rp = C.plength rp ∧ C.writable rp = true ∧ C.zone1 rp = Z.zones mpz4 rem → ((C.min rp ≤ C.offset rp ∧ C.offset rp < C.max rp) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → C.pelts rp1 = Function.update (C.pelts rp) (C.offset rp1) o2 → (Z.zones mpz4 rem = C.zone1 rp1 ∧ Z.readers mpz4 rem = -(1 : ℤ) ∧ C.offset rp1 = (0 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ abs (BitVec.toInt rs) ≤ C.plength rp1 ∧ C.plength rp1 = Z.alloc mpz4 rem ∧ (¬BitVec.toInt rs = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt rs) - (1 : ℤ))) ≤ Lemmas.value rp1 (abs (BitVec.toInt rs)))) ∧ (∀(mpz5 : Z.mpz_memo), Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.readers mpz5 = Z.readers mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → (∀(y : Z.mpz_ptr), ¬y = rem → Z.mpz_unchanged y mpz5 mpz4) ∧ (Z.sgn mpz5 rem = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt rs) ∧ (Z.sgn mpz5 rem = -(1 : ℤ)) = (BitVec.toInt rs < (0 : ℤ)) ∧ Z.abs_size mpz5 rem = abs (BitVec.toInt rs) ∧ Z.abs_value_of mpz5 rem = Lemmas.value rp1 (abs (BitVec.toInt rs)) → (Z.zones mpz5 rem = C.zone1 rp1 ∧ Z.readers mpz5 rem = -(1 : ℤ) ∧ C.min rp1 = (0 : ℤ) ∧ C.max rp1 = C.plength rp1 ∧ Z.abs_value_of mpz5 rem = Lemmas.value rp1 (Z.abs_size mpz5 rem)) ∧ (∀(mpz6 : Z.mpz_memo), Z.abs_value_of mpz6 = Z.abs_value_of mpz5 ∧ Z.alloc mpz6 = Z.alloc mpz5 ∧ Z.abs_size mpz6 = Z.abs_size mpz5 ∧ Z.sgn mpz6 = Z.sgn mpz5 ∧ Z.zones mpz6 = Z.zones mpz5 → Z.readers mpz6 rem = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = rem → Z.readers mpz6 y = Z.readers mpz5 y) → int'32_in_bounds (BitVec.toInt nn - (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt nn - (1 : ℤ) → (C.min qp1 ≤ C.offset qp1 + BitVec.toInt o4 ∧ C.offset qp1 + BitVec.toInt o4 < C.max qp1) ∧ (let qh : BitVec 64 := C.pelts qp1 (C.offset qp1 + BitVec.toInt o4); ∀(o5 : Bool), (BitVec.toUInt qh = BitVec.toUInt (0 : BitVec 64) → o5 = true) ∧ (o5 = true → qh = (0 : BitVec 64)) → (∀(o6 : BitVec 32), (if o5 = true then o6 = (1 : BitVec 32) else o6 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt nn - BitVec.toInt o6) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt nn - BitVec.toInt o6 → (¬(0 : ℤ) ≤ BitVec.toInt ns → int'32_in_bounds (-BitVec.toInt o7)) ∧ (∀(qs : BitVec 32), (if (0 : ℤ) ≤ BitVec.toInt ns then qs = o7 else BitVec.toInt qs = -BitVec.toInt o7) → (Z.zones mpz6 quot = C.zone1 qp1 ∧ Z.readers mpz6 quot = -(1 : ℤ) ∧ C.offset qp1 = (0 : ℤ) ∧ C.min qp1 = (0 : ℤ) ∧ C.max qp1 = C.plength qp1 ∧ abs (BitVec.toInt qs) ≤ C.plength qp1 ∧ C.plength qp1 = Z.alloc mpz6 quot ∧ (¬BitVec.toInt qs = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt qs) - (1 : ℤ))) ≤ Lemmas.value qp1 (abs (BitVec.toInt qs)))) ∧ (∀(mpz7 : Z.mpz_memo), Z.alloc mpz7 = Z.alloc mpz6 ∧ Z.readers mpz7 = Z.readers mpz6 ∧ Z.zones mpz7 = Z.zones mpz6 → (∀(y : Z.mpz_ptr), ¬y = quot → Z.mpz_unchanged y mpz7 mpz6) ∧ (Z.sgn mpz7 quot = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt qs) ∧ (Z.sgn mpz7 quot = -(1 : ℤ)) = (BitVec.toInt qs < (0 : ℤ)) ∧ Z.abs_size mpz7 quot = abs (BitVec.toInt qs) ∧ Z.abs_value_of mpz7 quot = Lemmas.value qp1 (abs (BitVec.toInt qs)) → (Z.zones mpz7 quot = C.zone1 qp1 ∧ Z.readers mpz7 quot = -(1 : ℤ) ∧ C.min qp1 = (0 : ℤ) ∧ C.max qp1 = C.plength qp1 ∧ Z.abs_value_of mpz7 quot = Lemmas.value qp1 (Z.abs_size mpz7 quot)) ∧ (∀(mpz8 : Z.mpz_memo), Z.abs_value_of mpz8 = Z.abs_value_of mpz7 ∧ Z.alloc mpz8 = Z.alloc mpz7 ∧ Z.abs_size mpz8 = Z.abs_size mpz7 ∧ Z.sgn mpz8 = Z.sgn mpz7 ∧ Z.zones mpz8 = Z.zones mpz7 → Z.readers mpz8 quot = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = quot → Z.readers mpz8 y = Z.readers mpz7 y) → Z.mpz_unchanged rem mpz8 mpz6 ∧ (Z.readers mpz8 rem = Z.readers mpz6 rem ∧ (-(2 : ℤ) < Z.readers mpz8 rem → Z.abs_value_of mpz8 rem = Z.abs_value_of mpz6 rem ∧ Z.alloc mpz8 rem = Z.alloc mpz6 rem ∧ Z.abs_size mpz8 rem = Z.abs_size mpz6 rem ∧ Z.sgn mpz8 rem = Z.sgn mpz6 rem ∧ Z.readers mpz8 rem = Z.readers mpz6 rem ∧ Z.zones mpz8 rem = Z.zones mpz6 rem) → Z.value_of quot mpz8 * BitVec.toUInt divisor + Z.value_of rem mpz8 = Z.value_of dividend mpz ∧ BitVec.toUInt o2 = Z.abs_value_of mpz8 rem ∧ ((0 : ℤ) ≤ Z.abs_value_of mpz8 rem ∧ Z.abs_value_of mpz8 rem < BitVec.toUInt divisor) ∧ (∀(x : Z.mpz_ptr), ¬x = quot → ¬x = rem → Z.mpz_unchanged x mpz8 mpz) ∧ Z.readers mpz8 dividend = (0 : ℤ) ∧ Z.readers mpz8 quot = (0 : ℤ) ∧ Z.readers mpz8 rem = (0 : ℤ)))))))))))))))))))))))))))))))
  := sorry
end mpz_div_Zdiv_wmpz_tdiv_qr_uiqtvc
