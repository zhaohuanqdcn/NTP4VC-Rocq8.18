theory sudoku_Solver_check_valid_chunkqtvc
  imports "NTP4Verif.NTP4Verif" "./sudoku_Grid"
begin
definition valid_chunk_up_to :: "(int \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> int list \<Rightarrow> int list \<Rightarrow> int \<Rightarrow> _"
  where "valid_chunk_up_to g i start offsets off \<longleftrightarrow> (let s :: int = start ! nat i in \<forall>(o1 :: int) (o2 :: int). ((0 :: int) \<le> o1 \<and> o1 < off) \<and> ((0 :: int) \<le> o2 \<and> o2 < off) \<and> \<not>o1 = o2 \<longrightarrow> (let i1 :: int = s + offsets ! nat o1; i2 :: int = s + offsets ! nat o2 in ((1 :: int) \<le> g i1 \<and> g i1 \<le> (9 :: int)) \<and> (1 :: int) \<le> g i2 \<and> g i2 \<le> (9 :: int) \<longrightarrow> \<not>g i1 = g i2))" for g i start offsets off
theorem check_valid_chunk'vc:
  fixes g :: "int list"
  fixes i :: "int"
  fixes start :: "int list"
  fixes offsets :: "int list"
  assumes fact0: "int (length g) = (81 :: int)"
  assumes fact1: "valid_values (nth g o nat)"
  assumes fact2: "is_index i"
  assumes fact3: "chunk_valid_indexes start offsets"
  shows "(0 :: int) \<le> i"
  and "i < int (length start)"
  and "let s :: int = start ! nat i in (0 :: int) \<le> (10 :: int) \<and> (\<forall>(b :: bool list). (\<forall>(i1 :: int). (0 :: int) \<le> i1 \<and> i1 < (10 :: int) \<longrightarrow> b ! nat i1 = False) \<and> int (length b) = (10 :: int) \<longrightarrow> ((0 :: int) \<le> (8 :: int) + (1 :: int) \<longrightarrow> (valid_chunk_up_to (nth g o nat) i start offsets (0 :: int) \<and> (\<forall>(o1 :: int). (0 :: int) \<le> o1 \<and> o1 < (0 :: int) \<longrightarrow> (let v :: int = g ! nat (s + offsets ! nat o1) in (1 :: int) \<le> v \<and> v \<le> (9 :: int) \<longrightarrow> b ! nat v = True)) \<and> (\<forall>(j :: int). (1 :: int) \<le> j \<and> j \<le> (9 :: int) \<longrightarrow> b ! nat j = True \<longrightarrow> (\<exists>(o1 :: int). ((0 :: int) \<le> o1 \<and> o1 < (0 :: int)) \<and> (nth g o nat) (s + offsets ! nat o1) = j))) \<and> (\<forall>(b1 :: bool list). length b1 = length b \<longrightarrow> (\<forall>(off :: int). ((0 :: int) \<le> off \<and> off \<le> (8 :: int)) \<and> valid_chunk_up_to (nth g o nat) i start offsets off \<and> (\<forall>(o1 :: int). (0 :: int) \<le> o1 \<and> o1 < off \<longrightarrow> (let v :: int = g ! nat (s + offsets ! nat o1) in (1 :: int) \<le> v \<and> v \<le> (9 :: int) \<longrightarrow> b1 ! nat v = True)) \<and> (\<forall>(j :: int). (1 :: int) \<le> j \<and> j \<le> (9 :: int) \<longrightarrow> b1 ! nat j = True \<longrightarrow> (\<exists>(o1 :: int). ((0 :: int) \<le> o1 \<and> o1 < off) \<and> (nth g o nat) (s + offsets ! nat o1) = j)) \<longrightarrow> ((0 :: int) \<le> off \<and> off < int (length offsets)) \<and> (let o1 :: int = s + offsets ! nat off in ((0 :: int) \<le> o1 \<and> o1 < int (length g)) \<and> (let v :: int = g ! nat o1 in \<forall>(o2 :: bool). (if (1 :: int) \<le> v then o2 = (if v \<le> (9 :: int) then True else False) else o2 = False) \<longrightarrow> (if o2 = True then ((0 :: int) \<le> v \<and> v < int (length b1)) \<and> (if b1 ! nat v = True then \<not>valid_chunk (nth g o nat) i start offsets else let o3 :: bool = True in ((0 :: int) \<le> v \<and> v < int (length b1)) \<and> (length (b1[nat v := o3]) = length b1 \<longrightarrow> nth (b1[nat v := o3]) o nat = (nth b1 o nat)(v := o3) \<longrightarrow> valid_chunk_up_to (nth g o nat) i start offsets (off + (1 :: int)) \<and> (\<forall>(o4 :: int). (0 :: int) \<le> o4 \<and> o4 < off + (1 :: int) \<longrightarrow> (let v1 :: int = g ! nat (s + offsets ! nat o4) in (1 :: int) \<le> v1 \<and> v1 \<le> (9 :: int) \<longrightarrow> b1[nat v := o3] ! nat v1 = True)) \<and> (\<forall>(j :: int). (1 :: int) \<le> j \<and> j \<le> (9 :: int) \<longrightarrow> b1[nat v := o3] ! nat j = True \<longrightarrow> (\<exists>(o4 :: int). ((0 :: int) \<le> o4 \<and> o4 < off + (1 :: int)) \<and> (nth g o nat) (s + offsets ! nat o4) = j)))) else valid_chunk_up_to (nth g o nat) i start offsets (off + (1 :: int)) \<and> (\<forall>(o3 :: int). (0 :: int) \<le> o3 \<and> o3 < off + (1 :: int) \<longrightarrow> (let v1 :: int = g ! nat (s + offsets ! nat o3) in (1 :: int) \<le> v1 \<and> v1 \<le> (9 :: int) \<longrightarrow> b1 ! nat v1 = True)) \<and> (\<forall>(j :: int). (1 :: int) \<le> j \<and> j \<le> (9 :: int) \<longrightarrow> b1 ! nat j = True \<longrightarrow> (\<exists>(o3 :: int). ((0 :: int) \<le> o3 \<and> o3 < off + (1 :: int)) \<and> (nth g o nat) (s + offsets ! nat o3) = j)))))) \<and> (valid_chunk_up_to (nth g o nat) i start offsets ((8 :: int) + (1 :: int)) \<and> (\<forall>(o1 :: int). (0 :: int) \<le> o1 \<and> o1 < (8 :: int) + (1 :: int) \<longrightarrow> (let v :: int = g ! nat (s + offsets ! nat o1) in (1 :: int) \<le> v \<and> v \<le> (9 :: int) \<longrightarrow> b1 ! nat v = True)) \<and> (\<forall>(j :: int). (1 :: int) \<le> j \<and> j \<le> (9 :: int) \<longrightarrow> b1 ! nat j = True \<longrightarrow> (\<exists>(o1 :: int). ((0 :: int) \<le> o1 \<and> o1 < (8 :: int) + (1 :: int)) \<and> (nth g o nat) (s + offsets ! nat o1) = j)) \<longrightarrow> valid_chunk (nth g o nat) i start offsets))) \<and> ((8 :: int) + (1 :: int) < (0 :: int) \<longrightarrow> valid_chunk (nth g o nat) i start offsets))"
  sorry
end
