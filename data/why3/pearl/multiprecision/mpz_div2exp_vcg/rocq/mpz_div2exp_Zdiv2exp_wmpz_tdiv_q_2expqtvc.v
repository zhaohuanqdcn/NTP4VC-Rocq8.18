From Stdlib Require Import Strings.String.
From Stdlib Require Import String Ascii.
From Stdlib Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Stdlib Require Classical.
From Stdlib Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Stdlib Require Import Sorting.Sorted.
From Stdlib Require Import Reals.Rbasic_fun.
From Stdlib Require Import Reals.Abstract.ConstructiveAbs.
From Stdlib Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Stdlib Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Stdlib Require Import ZArith.Zeuclid.
From Stdlib Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Stdlib Require Import Reals.
Require Import Why3.Base.
Require Import Why3.why3.Ref.Ref.
Require Import Why3.map.Const.
Require Import Why3.map.MapEq.
Require Import Why3.mach.int.Unsigned.
Require Import Why3.mach.c.C.
Require Import multiprecision.lemmas.Lemmas.
Require Import multiprecision.types.Config.
Require Import multiprecision.types.Types.
Require Import multiprecision.types.Int32Eq.
Require Import multiprecision.types.UInt64Eq.
Require Import multiprecision.util.Util.
Require Import multiprecision.ptralias.Alias.
Require Import multiprecision.util.UtilOld.
Require Import multiprecision.compare.Compare.
Require Import multiprecision.logical.LogicalUtil.
Require Import multiprecision.logical.Logical.
Require Import multiprecision.logical.LogicalOld.
Require Import multiprecision.mpz.Z.
Require Import multiprecision.mpz.Zutil.
Open Scope Z_scope.
Theorem wmpz_tdiv_q_2exp'vc (mpz : mpz_memo) (r : mpz_ptr) (u : mpz_ptr) (cnt : bv 64%N) (fact0 : 1%Z ≤ alloc mpz r) (fact1 : 1%Z ≤ alloc mpz u) (fact2 : readers mpz r = 0%Z) (fact3 : readers mpz u = 0%Z) (fact4 : abs_size mpz u + Z.rem (bv_unsigned cnt) 64%Z + 1%Z ≤ 2147483647%Z) : - 2%Z < readers mpz u ∧ (∀(un : bv 32%N), bv_signed un = sgn mpz u * abs_size mpz u -> (¬ 64%Z = 0%Z ∧ uint'64_in_bounds (Z.rem (bv_unsigned cnt) 64%Z)) ∧ (∀(o1 : bv 64%N), bv_unsigned o1 = Z.rem (bv_unsigned cnt) 64%Z -> bv_unsigned o1 ≤ 2147483647%Z ∧ (∀(limb_cnt : bv 32%N), bv_signed limb_cnt = bv_unsigned o1 -> - 2147483648%Z < bv_signed un ∧ (∀(o2 : bv 32%N), bv_signed o2 = Z.abs (bv_signed un) -> int'32_in_bounds (bv_signed o2 - bv_signed limb_cnt) ∧ (∀(o3 : bv 32%N), bv_signed o3 = bv_signed o2 - bv_signed limb_cnt -> (if decide (bv_signed o3 ≤ 0%Z) then (- 1%Z ≤ readers mpz r ∧ readers mpz r ≤ 0%Z) ∧ (∀(mpz1 : mpz_memo), alloc mpz1 = alloc mpz ∧ sgn mpz1 = sgn mpz ∧ readers mpz1 = readers mpz ∧ zones mpz1 = zones mpz -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz1 mpz) ∧ abs_size mpz1 r = 0%Z ∧ abs_value_of mpz1 r = 0%Z -> value_of r mpz1 = Z.rem (value_of u mpz) (Z.pow 2%Z (bv_unsigned cnt)) ∧ (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz1 mpz) ∧ readers mpz1 r = 0%Z ∧ readers mpz1 u = 0%Z) else (readers mpz r = 0%Z ∧ 1%Z ≤ alloc mpz r) ∧ (∀(mpz1 : mpz_memo), sgn mpz1 = sgn mpz -> (∀(rp : C.ptr (bv 64%N)), (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz1 mpz) ∧ readers mpz1 r = - 1%Z ∧ abs_value_of mpz1 r = value rp (abs_size mpz1 r) ∧ zones mpz1 r = zone1 rp ∧ offset rp = 0%Z ∧ plength rp = alloc mpz1 r ∧ min rp = 0%Z ∧ C.max rp = plength rp ∧ writable rp = true ∧ abs_size mpz1 r = abs_size mpz r ∧ value rp (abs_size mpz r) = abs_value_of mpz r ∧ (if decide (alloc mpz r < bv_signed o3) then alloc mpz1 r = bv_signed o3 else alloc mpz1 r = alloc mpz r) -> (¬ 64%Z = 0%Z ∧ uint'64_in_bounds (Z.quot (bv_unsigned cnt) 64%Z)) ∧ (∀(c : bv 64%N), bv_unsigned c = Z.quot (bv_unsigned cnt) 64%Z -> mpz_eq u r = (u = r) -> (if decide (mpz_eq u r) then (min rp ≤ offset rp + bv_signed limb_cnt ∧ offset rp + bv_signed limb_cnt ≤ C.max rp) ∧ (∀(up : C.ptr (bv 64%N)), offset up = offset rp + bv_signed limb_cnt ∧ plength up = plength rp ∧ pelts up = pelts rp ∧ data up = data rp ∧ min up = min rp ∧ C.max up = C.max rp ∧ zone1 up = zone1 rp ∧ writable up = writable rp -> (∀(o4 : bool), (bv_unsigned c = bv_unsigned (0%bv : bv 64%N) -> o4 = true) ∧ (o4 = true -> c = (0%bv : bv 64%N)) -> (if decide (¬ o4 = true) then ((0%Z < bv_unsigned c ∧ bv_unsigned c < 64%Z) ∧ valid up (bv_signed o3) ∧ valid rp (bv_signed o3) ∧ 0%Z < bv_signed o3 ∧ writable rp = true ∧ (offset rp ≤ offset up ∨ offset up + bv_signed o3 ≤ offset rp)) ∧ (∀(up1 : C.ptr (bv 64%N)) (rp1 : C.ptr (bv 64%N)), data up1 = data rp1 ∧ length (data rp1) = length (data up) ∧ offset up1 = offset up ∧ min up1 = min up ∧ C.max up1 = C.max up ∧ writable up1 = writable up ∧ zone1 up1 = zone1 up -> length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> (∀(x_m : bv 64%N), bv_unsigned x_m + (18446744073709551615%Z + 1%Z) * value rp1 (bv_signed o3) = value up (bv_signed o3) * Z.pow 2%Z (64%Z - bv_unsigned c) ∧ (∀(j : Z), j < offset rp1 ∨ offset rp1 + bv_signed o3 ≤ j -> pelts rp1 j = pelts rp j) ∧ (min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ plength rp1 = plength rp) ∧ min up1 = min up ∧ C.max up1 = C.max up ∧ plength up1 = plength up -> ¬ 18446744073709551615%Z + 1%Z = 0%Z ∧ int'32_in_bounds (bv_signed o3 - 1%Z) ∧ (∀(o5 : bv 32%N), bv_signed o5 = bv_signed o3 - 1%Z -> (min rp1 ≤ offset rp1 + bv_signed o5 ∧ offset rp1 + bv_signed o5 < C.max rp1) ∧ (let o6 : bv 64%N := pelts rp1 (offset rp1 + bv_signed o5) in ∀(o7 : bool), (bv_unsigned o6 = bv_unsigned (0%bv : bv 64%N) -> o7 = true) ∧ (o7 = true -> o6 = (0%bv : bv 64%N)) -> (∀(o8 : bv 32%N), (if decide (o7 = true) then o8 = (1%bv : bv 32%N) else o8 = (0%bv : bv 32%N)) -> int'32_in_bounds (bv_signed o3 - bv_signed o8) ∧ (∀(o9 : bv 32%N), bv_signed o9 = bv_signed o3 - bv_signed o8 -> - 2%Z < readers mpz1 u ∧ (∀(o10 : bv 32%N), bv_signed o10 = sgn mpz1 u * abs_size mpz1 u -> (¬ 0%Z ≤ bv_signed o10 -> int'32_in_bounds (- bv_signed o9)) ∧ ((¬ 0%Z ≤ bv_signed o10 -> (∃(nrn : bv 32%N), bv_signed nrn = - bv_signed o9)) -> - 2%Z < readers mpz1 u ∧ (∀(o11 : bv 32%N), bv_signed o11 = sgn mpz1 u * abs_size mpz1 u -> (¬ 0%Z ≤ bv_signed o11 -> int'32_in_bounds (- bv_signed o9)) ∧ (∀(o12 : bv 32%N), (if decide (0%Z ≤ bv_signed o11) then o12 = o9 else bv_signed o12 = - bv_signed o9) -> (zones mpz1 r = zone1 rp1 ∧ readers mpz1 r = - 1%Z ∧ offset rp1 = 0%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ Z.abs (bv_signed o12) ≤ plength rp1 ∧ plength rp1 = alloc mpz1 r ∧ (¬ bv_signed o12 = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed o12) - 1%Z) ≤ value rp1 (Z.abs (bv_signed o12)))) ∧ (∀(mpz2 : mpz_memo), alloc mpz2 = alloc mpz1 ∧ readers mpz2 = readers mpz1 ∧ zones mpz2 = zones mpz1 -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz2 mpz1) ∧ (sgn mpz2 r = 1%Z) = (0%Z ≤ bv_signed o12) ∧ (sgn mpz2 r = - 1%Z) = (bv_signed o12 < 0%Z) ∧ abs_size mpz2 r = Z.abs (bv_signed o12) ∧ abs_value_of mpz2 r = value rp1 (Z.abs (bv_signed o12)) -> (zones mpz2 r = zone1 rp1 ∧ readers mpz2 r = - 1%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ abs_value_of mpz2 r = value rp1 (abs_size mpz2 r)) ∧ (∀(mpz3 : mpz_memo), abs_value_of mpz3 = abs_value_of mpz2 ∧ alloc mpz3 = alloc mpz2 ∧ abs_size mpz3 = abs_size mpz2 ∧ sgn mpz3 = sgn mpz2 ∧ zones mpz3 = zones mpz2 -> readers mpz3 r = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = r -> readers mpz3 y = readers mpz2 y) -> value_of r mpz3 = Z.rem (value_of u mpz) (Z.pow 2%Z (bv_unsigned cnt)) ∧ (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz3 mpz) ∧ readers mpz3 r = 0%Z ∧ readers mpz3 u = 0%Z)))))))))))) else (valid up (bv_signed o3) ∧ valid rp (bv_signed o3) ∧ writable rp = true ∧ (offset rp ≤ offset up ∨ offset up + bv_signed o3 ≤ offset rp)) ∧ (∀(up1 : C.ptr (bv 64%N)) (rp1 : C.ptr (bv 64%N)), data up1 = data rp1 ∧ length (data rp1) = length (data up) ∧ offset up1 = offset up ∧ min up1 = min up ∧ C.max up1 = C.max up ∧ writable up1 = writable up ∧ zone1 up1 = zone1 up -> length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> map_eq_sub_shift (pelts rp1) (pelts up) (offset rp1) (offset up1) (bv_signed o3) ∧ (∀(j : Z), j < offset rp1 ∨ offset rp1 + bv_signed o3 ≤ j -> pelts rp1 j = pelts rp j) -> - 2%Z < readers mpz1 u ∧ (∀(o5 : bv 32%N), bv_signed o5 = sgn mpz1 u * abs_size mpz1 u -> (¬ 0%Z ≤ bv_signed o5 -> int'32_in_bounds (- bv_signed o3)) ∧ ((¬ 0%Z ≤ bv_signed o5 -> (∃(nrn : bv 32%N), bv_signed nrn = - bv_signed o3)) -> - 2%Z < readers mpz1 u ∧ (∀(o6 : bv 32%N), bv_signed o6 = sgn mpz1 u * abs_size mpz1 u -> (¬ 0%Z ≤ bv_signed o6 -> int'32_in_bounds (- bv_signed o3)) ∧ (∀(o7 : bv 32%N), (if decide (0%Z ≤ bv_signed o6) then o7 = o3 else bv_signed o7 = - bv_signed o3) -> (zones mpz1 r = zone1 rp1 ∧ readers mpz1 r = - 1%Z ∧ offset rp1 = 0%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ Z.abs (bv_signed o7) ≤ plength rp1 ∧ plength rp1 = alloc mpz1 r ∧ (¬ bv_signed o7 = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed o7) - 1%Z) ≤ value rp1 (Z.abs (bv_signed o7)))) ∧ (∀(mpz2 : mpz_memo), alloc mpz2 = alloc mpz1 ∧ readers mpz2 = readers mpz1 ∧ zones mpz2 = zones mpz1 -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz2 mpz1) ∧ (sgn mpz2 r = 1%Z) = (0%Z ≤ bv_signed o7) ∧ (sgn mpz2 r = - 1%Z) = (bv_signed o7 < 0%Z) ∧ abs_size mpz2 r = Z.abs (bv_signed o7) ∧ abs_value_of mpz2 r = value rp1 (Z.abs (bv_signed o7)) -> (zones mpz2 r = zone1 rp1 ∧ readers mpz2 r = - 1%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ abs_value_of mpz2 r = value rp1 (abs_size mpz2 r)) ∧ (∀(mpz3 : mpz_memo), abs_value_of mpz3 = abs_value_of mpz2 ∧ alloc mpz3 = alloc mpz2 ∧ abs_size mpz3 = abs_size mpz2 ∧ sgn mpz3 = sgn mpz2 ∧ zones mpz3 = zones mpz2 -> readers mpz3 r = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = r -> readers mpz3 y = readers mpz2 y) -> value_of r mpz3 = Z.rem (value_of u mpz) (Z.pow 2%Z (bv_unsigned cnt)) ∧ (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz3 mpz) ∧ readers mpz3 r = 0%Z ∧ readers mpz3 u = 0%Z)))))))))) else mpz_unchanged u mpz1 mpz ∧ (readers mpz1 u = readers mpz u ∧ (- 2%Z < readers mpz1 u -> abs_value_of mpz1 u = abs_value_of mpz u ∧ alloc mpz1 u = alloc mpz u ∧ abs_size mpz1 u = abs_size mpz u ∧ sgn mpz1 u = sgn mpz u ∧ readers mpz1 u = readers mpz u ∧ zones mpz1 u = zones mpz u) -> 0%Z ≤ readers mpz1 u ∧ (∀(mpz2 : mpz_memo), abs_value_of mpz2 = abs_value_of mpz1 ∧ alloc mpz2 = alloc mpz1 ∧ abs_size mpz2 = abs_size mpz1 ∧ sgn mpz2 = sgn mpz1 ∧ zones mpz2 = zones mpz1 -> (∀(up0 : C.ptr (bv 64%N)), readers mpz2 u = readers mpz1 u + 1%Z ∧ (∀(y : mpz_ptr), ¬ u = y -> readers mpz2 y = readers mpz1 y) ∧ value up0 (abs_size mpz2 u) = abs_value_of mpz2 u ∧ plength up0 = alloc mpz2 u ∧ offset up0 = 0%Z ∧ min up0 = 0%Z ∧ C.max up0 = plength up0 ∧ zone1 up0 = zones mpz2 u -> (min up0 ≤ offset up0 + bv_signed limb_cnt ∧ offset up0 + bv_signed limb_cnt ≤ C.max up0) ∧ (∀(up : C.ptr (bv 64%N)), offset up = offset up0 + bv_signed limb_cnt ∧ plength up = plength up0 ∧ pelts up = pelts up0 ∧ data up = data up0 ∧ min up = min up0 ∧ C.max up = C.max up0 ∧ zone1 up = zone1 up0 ∧ writable up = writable up0 -> (∀(o4 : bool), (bv_unsigned c = bv_unsigned (0%bv : bv 64%N) -> o4 = true) ∧ (o4 = true -> c = (0%bv : bv 64%N)) -> (if decide (¬ o4 = true) then (valid up (bv_signed o3) ∧ valid rp (bv_signed o3) ∧ (0%Z < bv_unsigned c ∧ bv_unsigned c < 64%Z) ∧ 0%Z < bv_signed o3 ∧ writable rp = true) ∧ (∀(rp1 : C.ptr (bv 64%N)), length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> (∀(x_m : bv 64%N), bv_unsigned x_m + (18446744073709551615%Z + 1%Z) * value rp1 (bv_signed o3) = value up (bv_signed o3) * Z.pow 2%Z (64%Z - bv_unsigned c) -> ¬ 18446744073709551615%Z + 1%Z = 0%Z ∧ int'32_in_bounds (bv_signed o3 - 1%Z) ∧ (∀(o5 : bv 32%N), bv_signed o5 = bv_signed o3 - 1%Z -> (min rp1 ≤ offset rp1 + bv_signed o5 ∧ offset rp1 + bv_signed o5 < C.max rp1) ∧ (let o6 : bv 64%N := pelts rp1 (offset rp1 + bv_signed o5) in ∀(o7 : bool), (bv_unsigned o6 = bv_unsigned (0%bv : bv 64%N) -> o7 = true) ∧ (o7 = true -> o6 = (0%bv : bv 64%N)) -> (∀(o8 : bv 32%N), (if decide (o7 = true) then o8 = (1%bv : bv 32%N) else o8 = (0%bv : bv 32%N)) -> int'32_in_bounds (bv_signed o3 - bv_signed o8) ∧ (∀(o9 : bv 32%N), bv_signed o9 = bv_signed o3 - bv_signed o8 -> (zones mpz2 u = zone1 up0 ∧ 1%Z ≤ readers mpz2 u ∧ min up0 = 0%Z ∧ C.max up0 = plength up0) ∧ (∀(mpz3 : mpz_memo), abs_value_of mpz3 = abs_value_of mpz2 ∧ alloc mpz3 = alloc mpz2 ∧ abs_size mpz3 = abs_size mpz2 ∧ sgn mpz3 = sgn mpz2 ∧ zones mpz3 = zones mpz2 -> readers mpz3 u = readers mpz2 u - 1%Z ∧ (∀(y : mpz_ptr), ¬ y = u -> readers mpz3 y = readers mpz2 y) -> - 2%Z < readers mpz3 u ∧ (∀(o10 : bv 32%N), bv_signed o10 = sgn mpz3 u * abs_size mpz3 u -> (¬ 0%Z ≤ bv_signed o10 -> int'32_in_bounds (- bv_signed o9)) ∧ ((¬ 0%Z ≤ bv_signed o10 -> (∃(nrn : bv 32%N), bv_signed nrn = - bv_signed o9)) -> - 2%Z < readers mpz3 u ∧ (∀(o11 : bv 32%N), bv_signed o11 = sgn mpz3 u * abs_size mpz3 u -> (¬ 0%Z ≤ bv_signed o11 -> int'32_in_bounds (- bv_signed o9)) ∧ (∀(o12 : bv 32%N), (if decide (0%Z ≤ bv_signed o11) then o12 = o9 else bv_signed o12 = - bv_signed o9) -> (zones mpz3 r = zone1 rp1 ∧ readers mpz3 r = - 1%Z ∧ offset rp1 = 0%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ Z.abs (bv_signed o12) ≤ plength rp1 ∧ plength rp1 = alloc mpz3 r ∧ (¬ bv_signed o12 = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed o12) - 1%Z) ≤ value rp1 (Z.abs (bv_signed o12)))) ∧ (∀(mpz4 : mpz_memo), alloc mpz4 = alloc mpz3 ∧ readers mpz4 = readers mpz3 ∧ zones mpz4 = zones mpz3 -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz4 mpz3) ∧ (sgn mpz4 r = 1%Z) = (0%Z ≤ bv_signed o12) ∧ (sgn mpz4 r = - 1%Z) = (bv_signed o12 < 0%Z) ∧ abs_size mpz4 r = Z.abs (bv_signed o12) ∧ abs_value_of mpz4 r = value rp1 (Z.abs (bv_signed o12)) -> (zones mpz4 r = zone1 rp1 ∧ readers mpz4 r = - 1%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ abs_value_of mpz4 r = value rp1 (abs_size mpz4 r)) ∧ (∀(mpz5 : mpz_memo), abs_value_of mpz5 = abs_value_of mpz4 ∧ alloc mpz5 = alloc mpz4 ∧ abs_size mpz5 = abs_size mpz4 ∧ sgn mpz5 = sgn mpz4 ∧ zones mpz5 = zones mpz4 -> readers mpz5 r = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = r -> readers mpz5 y = readers mpz4 y) -> value_of r mpz5 = Z.rem (value_of u mpz) (Z.pow 2%Z (bv_unsigned cnt)) ∧ (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz5 mpz) ∧ readers mpz5 r = 0%Z ∧ readers mpz5 u = 0%Z))))))))))))) else (valid up (bv_signed o3) ∧ valid rp (bv_signed o3) ∧ writable rp = true) ∧ (∀(rp1 : C.ptr (bv 64%N)), length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> map_eq_sub_shift (pelts rp1) (pelts up) (offset rp1) (offset up) (bv_signed o3) ∧ (∀(j : Z), j < offset rp1 ∨ offset rp1 + bv_signed o3 ≤ j -> pelts rp1 j = pelts rp j) -> (zones mpz2 u = zone1 up0 ∧ 1%Z ≤ readers mpz2 u ∧ min up0 = 0%Z ∧ C.max up0 = plength up0) ∧ (∀(mpz3 : mpz_memo), abs_value_of mpz3 = abs_value_of mpz2 ∧ alloc mpz3 = alloc mpz2 ∧ abs_size mpz3 = abs_size mpz2 ∧ sgn mpz3 = sgn mpz2 ∧ zones mpz3 = zones mpz2 -> readers mpz3 u = readers mpz2 u - 1%Z ∧ (∀(y : mpz_ptr), ¬ y = u -> readers mpz3 y = readers mpz2 y) -> - 2%Z < readers mpz3 u ∧ (∀(o5 : bv 32%N), bv_signed o5 = sgn mpz3 u * abs_size mpz3 u -> (¬ 0%Z ≤ bv_signed o5 -> int'32_in_bounds (- bv_signed o3)) ∧ ((¬ 0%Z ≤ bv_signed o5 -> (∃(nrn : bv 32%N), bv_signed nrn = - bv_signed o3)) -> - 2%Z < readers mpz3 u ∧ (∀(o6 : bv 32%N), bv_signed o6 = sgn mpz3 u * abs_size mpz3 u -> (¬ 0%Z ≤ bv_signed o6 -> int'32_in_bounds (- bv_signed o3)) ∧ (∀(o7 : bv 32%N), (if decide (0%Z ≤ bv_signed o6) then o7 = o3 else bv_signed o7 = - bv_signed o3) -> (zones mpz3 r = zone1 rp1 ∧ readers mpz3 r = - 1%Z ∧ offset rp1 = 0%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ Z.abs (bv_signed o7) ≤ plength rp1 ∧ plength rp1 = alloc mpz3 r ∧ (¬ bv_signed o7 = 0%Z -> Z.pow (18446744073709551615%Z + 1%Z) (Z.abs (bv_signed o7) - 1%Z) ≤ value rp1 (Z.abs (bv_signed o7)))) ∧ (∀(mpz4 : mpz_memo), alloc mpz4 = alloc mpz3 ∧ readers mpz4 = readers mpz3 ∧ zones mpz4 = zones mpz3 -> (∀(y : mpz_ptr), ¬ y = r -> mpz_unchanged y mpz4 mpz3) ∧ (sgn mpz4 r = 1%Z) = (0%Z ≤ bv_signed o7) ∧ (sgn mpz4 r = - 1%Z) = (bv_signed o7 < 0%Z) ∧ abs_size mpz4 r = Z.abs (bv_signed o7) ∧ abs_value_of mpz4 r = value rp1 (Z.abs (bv_signed o7)) -> (zones mpz4 r = zone1 rp1 ∧ readers mpz4 r = - 1%Z ∧ min rp1 = 0%Z ∧ C.max rp1 = plength rp1 ∧ abs_value_of mpz4 r = value rp1 (abs_size mpz4 r)) ∧ (∀(mpz5 : mpz_memo), abs_value_of mpz5 = abs_value_of mpz4 ∧ alloc mpz5 = alloc mpz4 ∧ abs_size mpz5 = abs_size mpz4 ∧ sgn mpz5 = sgn mpz4 ∧ zones mpz5 = zones mpz4 -> readers mpz5 r = 0%Z ∧ (∀(y : mpz_ptr), ¬ y = r -> readers mpz5 y = readers mpz4 y) -> value_of r mpz5 = Z.rem (value_of u mpz) (Z.pow 2%Z (bv_unsigned cnt)) ∧ (∀(x : mpz_ptr), ¬ x = r -> mpz_unchanged x mpz5 mpz) ∧ readers mpz5 r = 0%Z ∧ readers mpz5 u = 0%Z)))))))))))))))))))))))).
Admitted.
