theory koda_ruskey_KodaRuskey_enumqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "./koda_ruskey_KodaRuskey_Spec" "./koda_ruskey_Lemmas"
begin
theorem enum'vc:
  fixes f0 :: "forest"
  fixes bits :: "color list"
  fixes st :: "forest list"
  fixes visited :: "(int \<Rightarrow> color) list"
  assumes fact0: "size_forest f0 = int (length bits)"
  assumes fact1: "valid_nums_forest f0 (int (length bits))"
  assumes fact2: "sub st f0 (nth bits o nat)"
  assumes fact3: "\<not>st = (Nil :: forest list)"
  assumes fact4: "any_stack st (nth bits o nat)"
  assumes fact5: "valid_coloring f0 (nth bits o nat)"
  shows "case st of Nil \<Rightarrow> False | Cons E st' \<Rightarrow> (case st' of Nil \<Rightarrow> (let o1 :: int \<Rightarrow> color = nth bits o nat; o2 :: (int \<Rightarrow> color) list = visited @ [o1] in int (length o2) = (1 :: int) + int (length visited) \<and> o2 ! length visited = o1 \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length visited) \<longrightarrow> o2 ! nat i = visited ! nat i) \<longrightarrow> koda_ruskey_Lemmas.inverse st (nth bits o nat) (nth bits o nat) \<and> valid_coloring f0 (nth bits o nat) \<and> stored_solutions f0 (nth bits o nat) st visited o2) | _ \<Rightarrow> (((0 :: int) \<le> size_stack st \<and> size_stack st' < size_stack st \<or> size_stack st = size_stack st' \<and> (case st of Nil \<Rightarrow> False | Cons _ f \<Rightarrow> f = st')) \<and> size_forest f0 = int (length bits) \<and> valid_nums_forest f0 (int (length bits)) \<and> sub st' f0 (nth bits o nat) \<and> \<not>st' = (Nil :: forest list) \<and> any_stack st' (nth bits o nat) \<and> valid_coloring f0 (nth bits o nat)) \<and> (\<forall>(bits1 :: color list) (visited1 :: (int \<Rightarrow> color) list). length bits1 = length bits \<longrightarrow> (\<forall>(i :: int). \<not>mem_stack i st' \<longrightarrow> bits1 ! nat i = bits ! nat i) \<and> koda_ruskey_Lemmas.inverse st' (nth bits o nat) (nth bits1 o nat) \<and> valid_coloring f0 (nth bits1 o nat) \<and> stored_solutions f0 (nth bits1 o nat) st' visited visited1 \<longrightarrow> (\<forall>(i :: int). \<not>mem_stack i st \<longrightarrow> bits1 ! nat i = bits ! nat i) \<and> koda_ruskey_Lemmas.inverse st (nth bits o nat) (nth bits1 o nat) \<and> valid_coloring f0 (nth bits1 o nat) \<and> stored_solutions f0 (nth bits1 o nat) st visited visited1)) | Cons (N i f1 f2) st' \<Rightarrow> (let f = N i f1 f2 in ((0 :: int) \<le> i \<and> i < int (length bits)) \<and> (if bits ! nat i = White then let o1 :: forest list = Cons f2 st' in (((0 :: int) \<le> size_stack st \<and> size_stack o1 < size_stack st \<or> size_stack st = size_stack o1 \<and> (case st of Nil \<Rightarrow> False | Cons _ f3 \<Rightarrow> f3 = o1)) \<and> size_forest f0 = int (length bits) \<and> valid_nums_forest f0 (int (length bits)) \<and> sub o1 f0 (nth bits o nat) \<and> any_stack o1 (nth bits o nat) \<and> valid_coloring f0 (nth bits o nat)) \<and> (\<forall>(bits1 :: color list) (visited1 :: (int \<Rightarrow> color) list). length bits1 = length bits \<longrightarrow> (\<forall>(i1 :: int). \<not>mem_stack i1 o1 \<longrightarrow> bits1 ! nat i1 = bits ! nat i1) \<and> koda_ruskey_Lemmas.inverse o1 (nth bits o nat) (nth bits1 o nat) \<and> valid_coloring f0 (nth bits1 o nat) \<and> stored_solutions f0 (nth bits1 o nat) o1 visited visited1 \<longrightarrow> (let o2 :: color = Black in ((0 :: int) \<le> i \<and> i < int (length bits1)) \<and> (length (bits1[nat i := o2]) = length bits1 \<longrightarrow> nth (bits1[nat i := o2]) o nat = (nth bits1 o nat)(i := o2) \<longrightarrow> (let o3 :: forest list = Cons f1 (Cons f2 st') in (((0 :: int) \<le> size_stack st \<and> size_stack o3 < size_stack st \<or> size_stack st = size_stack o3 \<and> (case st of Nil \<Rightarrow> False | Cons _ f3 \<Rightarrow> f3 = o3)) \<and> size_forest f0 = int (length (bits1[nat i := o2])) \<and> valid_nums_forest f0 (int (length (bits1[nat i := o2]))) \<and> sub o3 f0 (nth (bits1[nat i := o2]) o nat) \<and> any_stack o3 (nth (bits1[nat i := o2]) o nat) \<and> valid_coloring f0 (nth (bits1[nat i := o2]) o nat)) \<and> (\<forall>(bits2 :: color list) (visited2 :: (int \<Rightarrow> color) list). length bits2 = length (bits1[nat i := o2]) \<longrightarrow> (\<forall>(i1 :: int). \<not>mem_stack i1 o3 \<longrightarrow> bits2 ! nat i1 = bits1[nat i := o2] ! nat i1) \<and> koda_ruskey_Lemmas.inverse o3 (nth (bits1[nat i := o2]) o nat) (nth bits2 o nat) \<and> valid_coloring f0 (nth bits2 o nat) \<and> stored_solutions f0 (nth bits2 o nat) o3 visited1 visited2 \<longrightarrow> (\<forall>(i1 :: int). \<not>mem_stack i1 st \<longrightarrow> bits2 ! nat i1 = bits ! nat i1) \<and> koda_ruskey_Lemmas.inverse st (nth bits o nat) (nth bits2 o nat) \<and> valid_coloring f0 (nth bits2 o nat) \<and> stored_solutions f0 (nth bits2 o nat) st visited visited2))))) else let o1 :: forest list = Cons f1 (Cons f2 st') in (((0 :: int) \<le> size_stack st \<and> size_stack o1 < size_stack st \<or> size_stack st = size_stack o1 \<and> (case st of Nil \<Rightarrow> False | Cons _ f3 \<Rightarrow> f3 = o1)) \<and> size_forest f0 = int (length bits) \<and> valid_nums_forest f0 (int (length bits)) \<and> sub o1 f0 (nth bits o nat) \<and> any_stack o1 (nth bits o nat) \<and> valid_coloring f0 (nth bits o nat)) \<and> (\<forall>(bits1 :: color list) (visited1 :: (int \<Rightarrow> color) list). length bits1 = length bits \<longrightarrow> (\<forall>(i1 :: int). \<not>mem_stack i1 o1 \<longrightarrow> bits1 ! nat i1 = bits ! nat i1) \<and> koda_ruskey_Lemmas.inverse o1 (nth bits o nat) (nth bits1 o nat) \<and> valid_coloring f0 (nth bits1 o nat) \<and> stored_solutions f0 (nth bits1 o nat) o1 visited visited1 \<longrightarrow> (let o2 :: color = White in ((0 :: int) \<le> i \<and> i < int (length bits1)) \<and> (length (bits1[nat i := o2]) = length bits1 \<longrightarrow> nth (bits1[nat i := o2]) o nat = (nth bits1 o nat)(i := o2) \<longrightarrow> (let o3 :: forest list = Cons f2 st' in (((0 :: int) \<le> size_stack st \<and> size_stack o3 < size_stack st \<or> size_stack st = size_stack o3 \<and> (case st of Nil \<Rightarrow> False | Cons _ f3 \<Rightarrow> f3 = o3)) \<and> size_forest f0 = int (length (bits1[nat i := o2])) \<and> valid_nums_forest f0 (int (length (bits1[nat i := o2]))) \<and> sub o3 f0 (nth (bits1[nat i := o2]) o nat) \<and> any_stack o3 (nth (bits1[nat i := o2]) o nat) \<and> valid_coloring f0 (nth (bits1[nat i := o2]) o nat)) \<and> (\<forall>(bits2 :: color list) (visited2 :: (int \<Rightarrow> color) list). length bits2 = length (bits1[nat i := o2]) \<longrightarrow> (\<forall>(i1 :: int). \<not>mem_stack i1 o3 \<longrightarrow> bits2 ! nat i1 = bits1[nat i := o2] ! nat i1) \<and> koda_ruskey_Lemmas.inverse o3 (nth (bits1[nat i := o2]) o nat) (nth bits2 o nat) \<and> valid_coloring f0 (nth bits2 o nat) \<and> stored_solutions f0 (nth bits2 o nat) o3 visited1 visited2 \<longrightarrow> (\<forall>(i1 :: int). \<not>mem_stack i1 st \<longrightarrow> bits2 ! nat i1 = bits ! nat i1) \<and> koda_ruskey_Lemmas.inverse st (nth bits o nat) (nth bits2 o nat) \<and> valid_coloring f0 (nth bits2 o nat) \<and> stored_solutions f0 (nth bits2 o nat) st visited visited2)))))))"
  sorry
end
