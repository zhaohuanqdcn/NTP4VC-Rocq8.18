import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.c.C
import Why3.mach.int.Unsigned
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.ptralias.Alias
open Classical
open Lean4Why3
namespace sub_Sub_wmpn_sub_nqtvc
theorem wmpn_sub_n'vc (sz : BitVec 32) (r : C.ptr (BitVec 64)) (x : C.ptr (BitVec 64)) (y : C.ptr (BitVec 64)) (fact0 : (0 : ℤ) ≤ BitVec.toInt sz) (fact1 : C.valid r (BitVec.toInt sz)) (fact2 : C.valid x (BitVec.toInt sz)) (fact3 : C.valid y (BitVec.toInt sz)) (fact4 : C.offset r = C.offset x ∨ C.offset r + BitVec.toInt sz ≤ C.offset x ∨ C.offset x + BitVec.toInt sz ≤ C.offset r) (fact5 : C.offset r = C.offset y ∨ C.offset r + BitVec.toInt sz ≤ C.offset y ∨ C.offset y + BitVec.toInt sz ≤ C.offset r) (fact6 : C.data r = C.data x) (fact7 : C.data x = C.data y) (fact8 : C.writable r = true) : (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt sz ∧ Lemmas.value r (0 : ℤ) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (0 : ℕ) * (0 : ℤ) = Lemmas.value x (0 : ℤ) - Lemmas.value y (0 : ℤ) ∧ C.pelts x = C.pelts r ∧ C.pelts r = C.pelts y ∧ (C.offset r = C.offset x ∨ MapEq.map_eq_sub (C.pelts x) (C.pelts x) (C.offset x) (C.offset x + BitVec.toInt sz)) ∧ (C.offset r = C.offset y ∨ MapEq.map_eq_sub (C.pelts y) (C.pelts y) (C.offset y) (C.offset y + BitVec.toInt sz)) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (1 : ℤ) ∧ (∀(i : BitVec 32) (b : BitVec 64) (y1 : C.ptr (BitVec 64)) (x1 : C.ptr (BitVec 64)) (r1 : C.ptr (BitVec 64)), C.data y1 = C.data r1 ∧ List.length (C.data r1) = List.length (C.data y) ∧ C.offset y1 = C.offset y ∧ C.min y1 = C.min y ∧ C.max y1 = C.max y ∧ C.writable y1 = C.writable y ∧ C.zone1 y1 = C.zone1 y → C.data x1 = C.data r1 ∧ List.length (C.data r1) = List.length (C.data x) ∧ C.offset x1 = C.offset x ∧ C.min x1 = C.min x ∧ C.max x1 = C.max x ∧ C.writable x1 = C.writable x ∧ C.zone1 x1 = C.zone1 x → List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sz) ∧ Lemmas.value r1 (BitVec.toInt i) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt b = Lemmas.value x (BitVec.toInt i) - Lemmas.value y (BitVec.toInt i) ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt i ≤ j → C.pelts r1 j = C.pelts r j) ∧ (C.pelts x1 = C.pelts r1 ∧ C.pelts r1 = C.pelts y1) ∧ (C.offset r1 = C.offset x1 ∨ MapEq.map_eq_sub (C.pelts x1) (C.pelts x) (C.offset x1) (C.offset x1 + BitVec.toInt sz)) ∧ (C.offset r1 = C.offset y1 ∨ MapEq.map_eq_sub (C.pelts y1) (C.pelts y) (C.offset y1) (C.offset y1 + BitVec.toInt sz)) ∧ (0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ) → (if BitVec.toInt i < BitVec.toInt sz then (C.min x1 ≤ C.offset x1 + BitVec.toInt i ∧ C.offset x1 + BitVec.toInt i < C.max x1) ∧ (C.min y1 ≤ C.offset y1 + BitVec.toInt i ∧ C.offset y1 + BitVec.toInt i < C.max y1) ∧ (C.min x ≤ C.offset x + BitVec.toInt i ∧ C.offset x + BitVec.toInt i < C.max x) ∧ (C.min y ≤ C.offset y + BitVec.toInt i ∧ C.offset y + BitVec.toInt i < C.max y) ∧ ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ (∀(res : BitVec 64) (borrow : BitVec 64), BitVec.toUInt res - ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt borrow = BitVec.toUInt (C.pelts x1 (C.offset x1 + BitVec.toInt i)) - BitVec.toUInt (C.pelts y1 (C.offset y1 + BitVec.toInt i)) - BitVec.toUInt b ∧ (0 : ℤ) ≤ BitVec.toUInt borrow ∧ BitVec.toUInt borrow ≤ (1 : ℤ) → ((C.min r1 ≤ C.offset r1 + BitVec.toInt i ∧ C.offset r1 + BitVec.toInt i < C.max r1) ∧ C.writable r1 = true) ∧ (∀(y2 : C.ptr (BitVec 64)) (x2 : C.ptr (BitVec 64)) (r2 : C.ptr (BitVec 64)), C.data y2 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data y1) ∧ C.offset y2 = C.offset y1 ∧ C.min y2 = C.min y1 ∧ C.max y2 = C.max y1 ∧ C.writable y2 = C.writable y1 ∧ C.zone1 y2 = C.zone1 y1 → C.data x2 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data x1) ∧ C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.max x2 = C.max x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → List.length (C.data r2) = List.length (C.data r1) ∧ C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.max r2 = C.max r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → C.pelts r2 = Function.update (C.pelts r1) (C.offset r2 + BitVec.toInt i) res ∧ C.pelts r2 (C.offset r2 + BitVec.toInt i) = res → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt sz - BitVec.toInt i ∧ BitVec.toInt sz - BitVec.toInt o1 < BitVec.toInt sz - BitVec.toInt i) ∧ ((0 : ℤ) ≤ BitVec.toInt o1 ∧ BitVec.toInt o1 ≤ BitVec.toInt sz) ∧ Lemmas.value r2 (BitVec.toInt o1) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o1)) * BitVec.toUInt borrow = Lemmas.value x (BitVec.toInt o1) - Lemmas.value y (BitVec.toInt o1) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt o1 ≤ j → C.pelts r2 j = C.pelts r j) ∧ (C.pelts x2 = C.pelts r2 ∧ C.pelts r2 = C.pelts y2) ∧ (C.offset r2 = C.offset x2 ∨ MapEq.map_eq_sub (C.pelts x2) (C.pelts x) (C.offset x2) (C.offset x2 + BitVec.toInt sz)) ∧ (C.offset r2 = C.offset y2 ∨ MapEq.map_eq_sub (C.pelts y2) (C.pelts y) (C.offset y2) (C.offset y2 + BitVec.toInt sz)) ∧ (0 : ℤ) ≤ BitVec.toUInt borrow ∧ BitVec.toUInt borrow ≤ (1 : ℤ)))) else Lemmas.value r1 (BitVec.toInt sz) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz)) * BitVec.toUInt b = Lemmas.value x (BitVec.toInt sz) - Lemmas.value y (BitVec.toInt sz) ∧ ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sz ≤ j → C.pelts r1 j = C.pelts r j) ∧ (C.offset r1 = C.offset x1 ∨ MapEq.map_eq_sub (C.pelts x1) (C.pelts x) (C.offset x1) (C.offset x1 + BitVec.toInt sz)) ∧ (C.offset r1 = C.offset y1 ∨ MapEq.map_eq_sub (C.pelts y1) (C.pelts y) (C.offset y1) (C.offset y1 + BitVec.toInt sz))))
  := sorry
end sub_Sub_wmpn_sub_nqtvc
