import Why3.Base
import pearl.balance_vcg.lean.balance.Roberval
open Classical
open Lean4Why3
namespace balance_Puzzle12_solve12qtvc
theorem solve12'vc (counter : Roberval.counter) (j : ℤ) (balls : List ℤ) (w : ℤ) (b : Bool) (fact0 : Roberval.v counter = (3 : ℤ)) (fact1 : (0 : ℤ) ≤ j) (fact2 : j < (12 : ℤ)) (fact3 : (12 : ℤ) = Int.ofNat (List.length balls)) (fact4 : ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < (12 : ℤ) → ¬i = j → balls[Int.toNat i]! = w) (fact5 : if b = true then balls[Int.toNat j]! < w else w < balls[Int.toNat j]!) : (0 : ℤ) ≤ (7 : ℤ) ∧ (7 : ℤ) < Int.ofNat (List.length balls) ∧ (0 : ℤ) ≤ (6 : ℤ) ∧ (6 : ℤ) < Int.ofNat (List.length balls) ∧ (0 : ℤ) ≤ (5 : ℤ) ∧ (5 : ℤ) < Int.ofNat (List.length balls) ∧ (0 : ℤ) ≤ (4 : ℤ) ∧ (4 : ℤ) < Int.ofNat (List.length balls) ∧ (let o1 : ℤ := balls[(4 : ℕ)]! + balls[(5 : ℕ)]! + balls[(6 : ℕ)]! + balls[(7 : ℕ)]!; ((0 : ℤ) ≤ (3 : ℤ) ∧ (3 : ℤ) < Int.ofNat (List.length balls)) ∧ ((0 : ℤ) ≤ (2 : ℤ) ∧ (2 : ℤ) < Int.ofNat (List.length balls)) ∧ ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < Int.ofNat (List.length balls)) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o2 : ℤ := balls[(0 : ℕ)]! + balls[(1 : ℕ)]! + balls[(2 : ℕ)]! + balls[(3 : ℕ)]!; (0 : ℤ) < Roberval.v counter ∧ (∀(counter1 : Roberval.counter) (o3 : Roberval.outcome), (match o3 with | Roberval.outcome.Left => o1 < o2 | Roberval.outcome.Equal => o2 = o1 | Roberval.outcome.Right => o2 < o1) ∧ Roberval.v counter1 = Roberval.v counter - (1 : ℤ) → (match o3 with | Roberval.outcome.Equal => ((0 : ℤ) ≤ (10 : ℤ) ∧ (10 : ℤ) < Int.ofNat (List.length balls)) ∧ ((0 : ℤ) ≤ (9 : ℤ) ∧ (9 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o4 : ℤ := balls[(9 : ℕ)]! + balls[(10 : ℕ)]!; ((0 : ℤ) ≤ (8 : ℤ) ∧ (8 : ℤ) < Int.ofNat (List.length balls)) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o5 : ℤ := balls[(0 : ℕ)]! + balls[(8 : ℕ)]!; (0 : ℤ) < Roberval.v counter1 ∧ (∀(counter2 : Roberval.counter) (o6 : Roberval.outcome), (match o6 with | Roberval.outcome.Left => o4 < o5 | Roberval.outcome.Equal => o5 = o4 | Roberval.outcome.Right => o5 < o4) ∧ Roberval.v counter2 = Roberval.v counter1 - (1 : ℤ) → (match o6 with | Roberval.outcome.Equal => ((0 : ℤ) ≤ (11 : ℤ) ∧ (11 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o7 : ℤ := balls[(11 : ℕ)]!; ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o8 : ℤ := balls[(0 : ℕ)]!; (0 : ℤ) < Roberval.v counter2 ∧ (∀(counter3 : Roberval.counter) (o9 : Roberval.outcome), (match o9 with | Roberval.outcome.Left => o7 < o8 | Roberval.outcome.Equal => o8 = o7 | Roberval.outcome.Right => o8 < o7) ∧ Roberval.v counter3 = Roberval.v counter2 - (1 : ℤ) → (∀(result : ℤ) (result1 : Bool), (match o9 with | Roberval.outcome.Right => result = (11 : ℤ) ∧ result1 = false | _ => result = (11 : ℤ) ∧ result1 = true) → result = j ∧ result1 = b)))) | Roberval.outcome.Right => ((0 : ℤ) ≤ (10 : ℤ) ∧ (10 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o7 : ℤ := balls[(10 : ℕ)]!; ((0 : ℤ) ≤ (9 : ℤ) ∧ (9 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o8 : ℤ := balls[(9 : ℕ)]!; (0 : ℤ) < Roberval.v counter2 ∧ (∀(counter3 : Roberval.counter) (o9 : Roberval.outcome), (match o9 with | Roberval.outcome.Left => o7 < o8 | Roberval.outcome.Equal => o8 = o7 | Roberval.outcome.Right => o8 < o7) ∧ Roberval.v counter3 = Roberval.v counter2 - (1 : ℤ) → (∀(result : ℤ) (result1 : Bool), (match o9 with | Roberval.outcome.Equal => result = (8 : ℤ) ∧ result1 = true | Roberval.outcome.Right => result = (10 : ℤ) ∧ result1 = false | Roberval.outcome.Left => result = (9 : ℤ) ∧ result1 = false) → result = j ∧ result1 = b)))) | Roberval.outcome.Left => ((0 : ℤ) ≤ (10 : ℤ) ∧ (10 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o7 : ℤ := balls[(10 : ℕ)]!; ((0 : ℤ) ≤ (9 : ℤ) ∧ (9 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o8 : ℤ := balls[(9 : ℕ)]!; (0 : ℤ) < Roberval.v counter2 ∧ (∀(counter3 : Roberval.counter) (o9 : Roberval.outcome), (match o9 with | Roberval.outcome.Left => o7 < o8 | Roberval.outcome.Equal => o8 = o7 | Roberval.outcome.Right => o8 < o7) ∧ Roberval.v counter3 = Roberval.v counter2 - (1 : ℤ) → (∀(result : ℤ) (result1 : Bool), (match o9 with | Roberval.outcome.Equal => result = (8 : ℤ) ∧ result1 = false | Roberval.outcome.Right => result = (9 : ℤ) ∧ result1 = true | Roberval.outcome.Left => result = (10 : ℤ) ∧ result1 = true) → result = j ∧ result1 = b)))))))) | Roberval.outcome.Right => ((0 : ℤ) ≤ (8 : ℤ) ∧ (8 : ℤ) < Int.ofNat (List.length balls)) ∧ ((0 : ℤ) ≤ (5 : ℤ) ∧ (5 : ℤ) < Int.ofNat (List.length balls)) ∧ ((0 : ℤ) ≤ (2 : ℤ) ∧ (2 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o4 : ℤ := balls[(2 : ℕ)]! + balls[(5 : ℕ)]! + balls[(8 : ℕ)]!; ((0 : ℤ) ≤ (4 : ℤ) ∧ (4 : ℤ) < Int.ofNat (List.length balls)) ∧ ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < Int.ofNat (List.length balls)) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o5 : ℤ := balls[(0 : ℕ)]! + balls[(1 : ℕ)]! + balls[(4 : ℕ)]!; (0 : ℤ) < Roberval.v counter1 ∧ (∀(counter2 : Roberval.counter) (o6 : Roberval.outcome), (match o6 with | Roberval.outcome.Left => o4 < o5 | Roberval.outcome.Equal => o5 = o4 | Roberval.outcome.Right => o5 < o4) ∧ Roberval.v counter2 = Roberval.v counter1 - (1 : ℤ) → (match o6 with | Roberval.outcome.Equal => ((0 : ℤ) ≤ (7 : ℤ) ∧ (7 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o7 : ℤ := balls[(7 : ℕ)]!; ((0 : ℤ) ≤ (6 : ℤ) ∧ (6 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o8 : ℤ := balls[(6 : ℕ)]!; (0 : ℤ) < Roberval.v counter2 ∧ (∀(counter3 : Roberval.counter) (o9 : Roberval.outcome), (match o9 with | Roberval.outcome.Left => o7 < o8 | Roberval.outcome.Equal => o8 = o7 | Roberval.outcome.Right => o8 < o7) ∧ Roberval.v counter3 = Roberval.v counter2 - (1 : ℤ) → (∀(result : ℤ) (result1 : Bool), (match o9 with | Roberval.outcome.Equal => result = (3 : ℤ) ∧ result1 = true | Roberval.outcome.Right => result = (7 : ℤ) ∧ result1 = false | Roberval.outcome.Left => result = (6 : ℤ) ∧ result1 = false) → result = j ∧ result1 = b)))) | Roberval.outcome.Right => ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o7 : ℤ := balls[(1 : ℕ)]!; ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o8 : ℤ := balls[(0 : ℕ)]!; (0 : ℤ) < Roberval.v counter2 ∧ (∀(counter3 : Roberval.counter) (o9 : Roberval.outcome), (match o9 with | Roberval.outcome.Left => o7 < o8 | Roberval.outcome.Equal => o8 = o7 | Roberval.outcome.Right => o8 < o7) ∧ Roberval.v counter3 = Roberval.v counter2 - (1 : ℤ) → (∀(result : ℤ) (result1 : Bool), (match o9 with | Roberval.outcome.Equal => result = (5 : ℤ) ∧ result1 = false | Roberval.outcome.Right => result = (0 : ℤ) ∧ result1 = true | Roberval.outcome.Left => result = (1 : ℤ) ∧ result1 = true) → result = j ∧ result1 = b)))) | Roberval.outcome.Left => ((0 : ℤ) ≤ (8 : ℤ) ∧ (8 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o7 : ℤ := balls[(8 : ℕ)]!; ((0 : ℤ) ≤ (4 : ℤ) ∧ (4 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o8 : ℤ := balls[(4 : ℕ)]!; (0 : ℤ) < Roberval.v counter2 ∧ (∀(counter3 : Roberval.counter) (o9 : Roberval.outcome), (match o9 with | Roberval.outcome.Left => o7 < o8 | Roberval.outcome.Equal => o8 = o7 | Roberval.outcome.Right => o8 < o7) ∧ Roberval.v counter3 = Roberval.v counter2 - (1 : ℤ) → (∀(result : ℤ) (result1 : Bool), (match o9 with | Roberval.outcome.Equal => result = (2 : ℤ) ∧ result1 = true | _ => result = (4 : ℤ) ∧ result1 = false) → result = j ∧ result1 = b)))))))) | Roberval.outcome.Left => ((0 : ℤ) ≤ (8 : ℤ) ∧ (8 : ℤ) < Int.ofNat (List.length balls)) ∧ ((0 : ℤ) ≤ (5 : ℤ) ∧ (5 : ℤ) < Int.ofNat (List.length balls)) ∧ ((0 : ℤ) ≤ (2 : ℤ) ∧ (2 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o4 : ℤ := balls[(2 : ℕ)]! + balls[(5 : ℕ)]! + balls[(8 : ℕ)]!; ((0 : ℤ) ≤ (4 : ℤ) ∧ (4 : ℤ) < Int.ofNat (List.length balls)) ∧ ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < Int.ofNat (List.length balls)) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o5 : ℤ := balls[(0 : ℕ)]! + balls[(1 : ℕ)]! + balls[(4 : ℕ)]!; (0 : ℤ) < Roberval.v counter1 ∧ (∀(counter2 : Roberval.counter) (o6 : Roberval.outcome), (match o6 with | Roberval.outcome.Left => o4 < o5 | Roberval.outcome.Equal => o5 = o4 | Roberval.outcome.Right => o5 < o4) ∧ Roberval.v counter2 = Roberval.v counter1 - (1 : ℤ) → (match o6 with | Roberval.outcome.Equal => ((0 : ℤ) ≤ (7 : ℤ) ∧ (7 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o7 : ℤ := balls[(7 : ℕ)]!; ((0 : ℤ) ≤ (6 : ℤ) ∧ (6 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o8 : ℤ := balls[(6 : ℕ)]!; (0 : ℤ) < Roberval.v counter2 ∧ (∀(counter3 : Roberval.counter) (o9 : Roberval.outcome), (match o9 with | Roberval.outcome.Left => o7 < o8 | Roberval.outcome.Equal => o8 = o7 | Roberval.outcome.Right => o8 < o7) ∧ Roberval.v counter3 = Roberval.v counter2 - (1 : ℤ) → (∀(result : ℤ) (result1 : Bool), (match o9 with | Roberval.outcome.Equal => result = (3 : ℤ) ∧ result1 = false | Roberval.outcome.Right => result = (6 : ℤ) ∧ result1 = true | Roberval.outcome.Left => result = (7 : ℤ) ∧ result1 = true) → result = j ∧ result1 = b)))) | Roberval.outcome.Right => ((0 : ℤ) ≤ (5 : ℤ) ∧ (5 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o7 : ℤ := balls[(5 : ℕ)]!; ((0 : ℤ) ≤ (2 : ℤ) ∧ (2 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o8 : ℤ := balls[(2 : ℕ)]!; (0 : ℤ) < Roberval.v counter2 ∧ (∀(counter3 : Roberval.counter) (o9 : Roberval.outcome), (match o9 with | Roberval.outcome.Left => o7 < o8 | Roberval.outcome.Equal => o8 = o7 | Roberval.outcome.Right => o8 < o7) ∧ Roberval.v counter3 = Roberval.v counter2 - (1 : ℤ) → (∀(result : ℤ) (result1 : Bool), (match o9 with | Roberval.outcome.Equal => result = (4 : ℤ) ∧ result1 = true | Roberval.outcome.Right => result = (5 : ℤ) ∧ result1 = false | Roberval.outcome.Left => result = (2 : ℤ) ∧ result1 = false) → result = j ∧ result1 = b)))) | Roberval.outcome.Left => ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o7 : ℤ := balls[(1 : ℕ)]!; ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length balls)) ∧ (let o8 : ℤ := balls[(0 : ℕ)]!; (0 : ℤ) < Roberval.v counter2 ∧ (∀(counter3 : Roberval.counter) (o9 : Roberval.outcome), (match o9 with | Roberval.outcome.Left => o7 < o8 | Roberval.outcome.Equal => o8 = o7 | Roberval.outcome.Right => o8 < o7) ∧ Roberval.v counter3 = Roberval.v counter2 - (1 : ℤ) → (∀(result : ℤ) (result1 : Bool), (match o9 with | Roberval.outcome.Equal => result = (5 : ℤ) ∧ result1 = true | Roberval.outcome.Right => result = (1 : ℤ) ∧ result1 = false | Roberval.outcome.Left => result = (0 : ℤ) ∧ result1 = false) → result = j ∧ result1 = b))))))))))))
  := sorry
end balance_Puzzle12_solve12qtvc
