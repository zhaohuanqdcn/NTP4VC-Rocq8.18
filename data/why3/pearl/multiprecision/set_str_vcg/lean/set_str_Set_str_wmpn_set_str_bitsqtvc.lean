import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import Why3.mach.c.UChar
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.powm.Powm
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.valuation.Valuation
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.sub_1.Sub_1
import pearl.multiprecision.lib.lean.stringlemmas.String_lemmas
import pearl.multiprecision.lib.lean.base_info.BaseInfo
open Classical
open Lean4Why3
namespace set_str_Set_str_wmpn_set_str_bitsqtvc
theorem wmpn_set_str_bits'vc (sn : BitVec 32) (sz : BitVec 32) (rp : C.ptr (BitVec 64)) (sp : C.ptr (BitVec 8)) (bits : BitVec 32) (fact0 : (0 : ℤ) < BitVec.toUInt sn) (fact1 : BitVec.toUInt sn ≤ (2147483647 : ℤ)) (fact2 : (0 : ℤ) < BitVec.toInt sz) (fact3 : C.valid rp (BitVec.toInt sz)) (fact4 : C.valid sp (BitVec.toUInt sn)) (fact5 : (1 : ℤ) ≤ BitVec.toUInt bits) (fact6 : BitVec.toUInt bits ≤ (8 : ℤ)) (fact7 : HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits * BitVec.toUInt sn)) ≤ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz))) (fact8 : C.writable rp = true) (fact9 : String_lemmas.in_base (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) (C.pelts sp) (C.offset sp) (C.offset sp + BitVec.toUInt sn)) : BitVec.toUInt sn ≤ (2147483647 : ℤ) ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = BitVec.toUInt sn → (let b : ℤ := HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits)); (((0 : ℤ) ≤ BitVec.toInt o1 ∧ BitVec.toInt o1 ≤ BitVec.toUInt sn) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt sz) ∧ (BitVec.toUInt sn - BitVec.toInt o1) * BitVec.toUInt bits = (0 : ℤ) ∧ ((0 : ℤ) < BitVec.toInt o1 → (0 : ℤ) = (64 : ℤ) * (0 : ℤ)) ∧ ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < (64 : ℤ)) ∧ ((0 : ℤ) < (0 : ℤ) → BitVec.toUInt (C.pelts rp (C.offset rp + (0 : ℤ) - (1 : ℤ))) < HPow.hPow (2 : ℤ) (0 : ℕ)) ∧ Lemmas.value rp (0 : ℤ) = String_lemmas.svalue_sub b (C.pelts sp) (C.offset sp + BitVec.toInt o1) (C.offset sp + BitVec.toUInt sn)) ∧ (∀(j : BitVec 32) (shift : BitVec 32) (rn : BitVec 32) (rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → ((0 : ℤ) ≤ BitVec.toInt j ∧ BitVec.toInt j ≤ BitVec.toUInt sn) ∧ ((0 : ℤ) ≤ BitVec.toInt rn ∧ BitVec.toInt rn ≤ BitVec.toInt sz) ∧ ((0 : ℤ) < BitVec.toInt j → (if BitVec.toUInt shift = (0 : ℤ) then (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt rn else (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt rn - (64 : ℤ) + BitVec.toUInt shift)) ∧ ((0 : ℤ) ≤ BitVec.toUInt shift ∧ BitVec.toUInt shift < (64 : ℤ)) ∧ ((0 : ℤ) < BitVec.toUInt shift → BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt rn - (1 : ℤ))) < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt shift))) ∧ (BitVec.toInt rn = (0 : ℤ) → BitVec.toUInt shift = (0 : ℤ)) ∧ Lemmas.value rp1 (BitVec.toInt rn) = String_lemmas.svalue_sub b (C.pelts sp) (C.offset sp + BitVec.toInt j) (C.offset sp + BitVec.toUInt sn) → (if (0 : ℤ) < BitVec.toInt j then int'32_in_bounds (BitVec.toInt j - (1 : ℤ)) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toInt j - (1 : ℤ) → (C.min sp ≤ C.offset sp + BitVec.toInt o2 ∧ C.offset sp + BitVec.toInt o2 < C.max sp) ∧ (∀(sj : BitVec 64), BitVec.toUInt sj = BitVec.toInt (C.pelts sp (C.offset sp + BitVec.toInt o2)) → (BitVec.toUInt shift = (0 : ℤ) → shift = (0 : BitVec 32)) → (if shift = (0 : BitVec 32) then ((C.min rp1 ≤ C.offset rp1 + BitVec.toInt rn ∧ C.offset rp1 + BitVec.toInt rn < C.max rp1) ∧ C.writable rp1 = true) ∧ (∀(rp2 : C.ptr (BitVec 64)), List.length (C.data rp2) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → C.pelts rp2 = Function.update (C.pelts rp1) (C.offset rp2 + BitVec.toInt rn) sj ∧ C.pelts rp2 (C.offset rp2 + BitVec.toInt rn) = sj → int'32_in_bounds (BitVec.toInt rn + (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt rn + (1 : ℤ) → BitVec.toInt o2 < BitVec.toInt j ∧ ((0 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 ≤ BitVec.toUInt sn) ∧ ((0 : ℤ) ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ BitVec.toInt sz) ∧ (BitVec.toUInt sn - BitVec.toInt o2) * BitVec.toUInt bits = (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits ∧ ((0 : ℤ) < BitVec.toInt o2 → (if BitVec.toUInt bits = (0 : ℤ) then (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt o3 else (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt o3 - (64 : ℤ) + BitVec.toUInt bits)) ∧ ((0 : ℤ) ≤ BitVec.toUInt bits ∧ BitVec.toUInt bits < (64 : ℤ)) ∧ ((0 : ℤ) < BitVec.toUInt bits → BitVec.toUInt (C.pelts rp2 (C.offset rp2 + BitVec.toInt o3 - (1 : ℤ))) < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) ∧ (BitVec.toInt o3 = (0 : ℤ) → BitVec.toUInt bits = (0 : ℤ)) ∧ Lemmas.value rp2 (BitVec.toInt o3) = String_lemmas.svalue_sub b (C.pelts sp) (C.offset sp + BitVec.toInt o2) (C.offset sp + BitVec.toUInt sn))) else int'32_in_bounds (BitVec.toInt rn - (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt rn - (1 : ℤ) → (C.min rp1 ≤ C.offset rp1 + BitVec.toInt o3 ∧ C.offset rp1 + BitVec.toInt o3 < C.max rp1) ∧ (let rlow : BitVec 64 := C.pelts rp1 (C.offset rp1 + BitVec.toInt o3); ∀(o4 : BitVec 64), BitVec.toUInt o4 = BitVec.toUInt shift → ((0 : ℤ) ≤ BitVec.toUInt o4 ∧ BitVec.toUInt o4 < (64 : ℤ)) ∧ (∀(slow : BitVec 64), BitVec.toUInt slow = BitVec.toUInt sj * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o4)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → uint'64_in_bounds (BitVec.toUInt rlow + BitVec.toUInt slow) ∧ (∀(nr : BitVec 64), BitVec.toUInt nr = BitVec.toUInt rlow + BitVec.toUInt slow → int'32_in_bounds (BitVec.toInt rn - (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt rn - (1 : ℤ) → ((C.min rp1 ≤ C.offset rp1 + BitVec.toInt o5 ∧ C.offset rp1 + BitVec.toInt o5 < C.max rp1) ∧ C.writable rp1 = true) ∧ (∀(rp2 : C.ptr (BitVec 64)), List.length (C.data rp2) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → C.pelts rp2 = Function.update (C.pelts rp1) (C.offset rp2 + BitVec.toInt o5) nr ∧ C.pelts rp2 (C.offset rp2 + BitVec.toInt o5) = nr → uint'32_in_bounds (BitVec.toUInt shift + BitVec.toUInt bits) ∧ (∀(o6 : BitVec 32), BitVec.toUInt o6 = BitVec.toUInt shift + BitVec.toUInt bits → (if (64 : ℤ) ≤ BitVec.toUInt o6 then uint'32_in_bounds (BitVec.toUInt o6 - (64 : ℤ)) ∧ (∀(o7 : BitVec 32), BitVec.toUInt o7 = BitVec.toUInt o6 - (64 : ℤ) → (if (0 : ℤ) < BitVec.toUInt o7 then uint'32_in_bounds (BitVec.toUInt bits - BitVec.toUInt o7) ∧ (∀(o8 : BitVec 32), BitVec.toUInt o8 = BitVec.toUInt bits - BitVec.toUInt o7 → (∀(o9 : BitVec 64), BitVec.toUInt o9 = BitVec.toUInt o8 → ((0 : ℤ) ≤ BitVec.toUInt o9 ∧ BitVec.toUInt o9 < (64 : ℤ)) ∧ (∀(shigh : BitVec 64), BitVec.toUInt shigh = BitVec.toUInt sj / HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o9)) → ((C.min rp2 ≤ C.offset rp2 + BitVec.toInt rn ∧ C.offset rp2 + BitVec.toInt rn < C.max rp2) ∧ C.writable rp2 = true) ∧ (∀(rp3 : C.ptr (BitVec 64)), List.length (C.data rp3) = List.length (C.data rp2) ∧ C.offset rp3 = C.offset rp2 ∧ C.min rp3 = C.min rp2 ∧ C.max rp3 = C.max rp2 ∧ C.writable rp3 = C.writable rp2 ∧ C.zone1 rp3 = C.zone1 rp2 → C.pelts rp3 = Function.update (C.pelts rp2) (C.offset rp3 + BitVec.toInt rn) shigh ∧ C.pelts rp3 (C.offset rp3 + BitVec.toInt rn) = shigh → int'32_in_bounds (BitVec.toInt rn + (1 : ℤ)) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt rn + (1 : ℤ) → BitVec.toInt o2 < BitVec.toInt j ∧ ((0 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 ≤ BitVec.toUInt sn) ∧ ((0 : ℤ) ≤ BitVec.toInt o10 ∧ BitVec.toInt o10 ≤ BitVec.toInt sz) ∧ (BitVec.toUInt sn - BitVec.toInt o2) * BitVec.toUInt bits = (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits ∧ ((0 : ℤ) < BitVec.toInt o2 → (if BitVec.toUInt o7 = (0 : ℤ) then (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt o10 else (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt o10 - (64 : ℤ) + BitVec.toUInt o7)) ∧ ((0 : ℤ) ≤ BitVec.toUInt o7 ∧ BitVec.toUInt o7 < (64 : ℤ)) ∧ ((0 : ℤ) < BitVec.toUInt o7 → BitVec.toUInt (C.pelts rp3 (C.offset rp3 + BitVec.toInt o10 - (1 : ℤ))) < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o7))) ∧ (BitVec.toInt o10 = (0 : ℤ) → BitVec.toUInt o7 = (0 : ℤ)) ∧ Lemmas.value rp3 (BitVec.toInt o10) = String_lemmas.svalue_sub b (C.pelts sp) (C.offset sp + BitVec.toInt o2) (C.offset sp + BitVec.toUInt sn)))))) else BitVec.toInt o2 < BitVec.toInt j ∧ ((0 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 ≤ BitVec.toUInt sn) ∧ ((0 : ℤ) ≤ BitVec.toInt rn ∧ BitVec.toInt rn ≤ BitVec.toInt sz) ∧ (BitVec.toUInt sn - BitVec.toInt o2) * BitVec.toUInt bits = (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits ∧ ((0 : ℤ) < BitVec.toInt o2 → (if BitVec.toUInt o7 = (0 : ℤ) then (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt rn else (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt rn - (64 : ℤ) + BitVec.toUInt o7)) ∧ ((0 : ℤ) ≤ BitVec.toUInt o7 ∧ BitVec.toUInt o7 < (64 : ℤ)) ∧ ((0 : ℤ) < BitVec.toUInt o7 → BitVec.toUInt (C.pelts rp2 (C.offset rp2 + BitVec.toInt rn - (1 : ℤ))) < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o7))) ∧ (BitVec.toInt rn = (0 : ℤ) → BitVec.toUInt o7 = (0 : ℤ)) ∧ Lemmas.value rp2 (BitVec.toInt rn) = String_lemmas.svalue_sub b (C.pelts sp) (C.offset sp + BitVec.toInt o2) (C.offset sp + BitVec.toUInt sn))) else BitVec.toInt o2 < BitVec.toInt j ∧ ((0 : ℤ) ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 ≤ BitVec.toUInt sn) ∧ ((0 : ℤ) ≤ BitVec.toInt rn ∧ BitVec.toInt rn ≤ BitVec.toInt sz) ∧ (BitVec.toUInt sn - BitVec.toInt o2) * BitVec.toUInt bits = (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits ∧ ((0 : ℤ) < BitVec.toInt o2 → (if BitVec.toUInt o6 = (0 : ℤ) then (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt rn else (BitVec.toUInt sn - BitVec.toInt j) * BitVec.toUInt bits + BitVec.toUInt bits = (64 : ℤ) * BitVec.toInt rn - (64 : ℤ) + BitVec.toUInt o6)) ∧ ((0 : ℤ) ≤ BitVec.toUInt o6 ∧ BitVec.toUInt o6 < (64 : ℤ)) ∧ ((0 : ℤ) < BitVec.toUInt o6 → BitVec.toUInt (C.pelts rp2 (C.offset rp2 + BitVec.toInt rn - (1 : ℤ))) < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o6))) ∧ (BitVec.toInt rn = (0 : ℤ) → BitVec.toUInt o6 = (0 : ℤ)) ∧ Lemmas.value rp2 (BitVec.toInt rn) = String_lemmas.svalue_sub b (C.pelts sp) (C.offset sp + BitVec.toInt o2) (C.offset sp + BitVec.toUInt sn)))))))))))) else ((0 : ℤ) ≤ BitVec.toInt rn ∧ C.valid rp1 (BitVec.toInt rn)) ∧ (∀(rn1 : BitVec 32), ((0 : ℤ) ≤ BitVec.toInt rn1 ∧ BitVec.toInt rn1 ≤ BitVec.toInt rn) ∧ Lemmas.value rp1 (BitVec.toInt rn1) = Lemmas.value rp1 (BitVec.toInt rn) ∧ (BitVec.toInt rn1 = (0 : ℤ) ∨ (0 : ℤ) < BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt rn1 - (1 : ℤ)))) ∧ (BitVec.toInt rn1 = (0 : ℤ) ∨ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt rn1 - (1 : ℤ))) ≤ Lemmas.value rp1 (BitVec.toInt rn1)) → ((0 : ℤ) ≤ BitVec.toInt rn1 ∧ BitVec.toInt rn1 ≤ BitVec.toInt sz) ∧ Lemmas.value rp1 (BitVec.toInt rn1) = String_lemmas.svalue (HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt bits))) sp (BitVec.toUInt sn) ∧ ((0 : ℤ) < BitVec.toInt rn1 → (0 : ℤ) < BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt rn1 - (1 : ℤ)))))))))
  := sorry
end set_str_Set_str_wmpn_set_str_bitsqtvc
