theory schorr_waite_via_recursion_SchorrWaite_schorr_waiteqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "./schorr_waite_via_recursion_Memory" "./schorr_waite_via_recursion_GraphShape"
begin
theorem schorr_waite'vc:
  fixes root :: "loc"
  fixes graph :: "loc fset"
  fixes memo :: "memory"
  assumes fact0: "root |\<in>| graph"
  assumes fact1: "\<forall>(l :: loc) (n :: int). l |\<in>| graph \<and> \<not>l = null \<and> (0 :: int) \<le> n \<and> n < block_size memo l \<longrightarrow> accessor memo l n |\<in>| graph"
  assumes fact2: "\<forall>(x :: loc). x |\<in>| graph \<longrightarrow> \<not>black (colors memo x)"
  shows "\<forall>(p :: loc) (t :: loc) (memo1 :: memory). block_size memo1 = block_size memo \<longrightarrow> (\<not>p = null \<and> (t = null \<or> black (colors memo1 t)) \<longrightarrow> (case colors memo1 p of Black (Some m) \<Rightarrow> (0 :: int) \<le> m \<and> m < block_size memo1 p | _ \<Rightarrow> False)) \<longrightarrow> (\<forall>(o1 :: bool). (if p = null then if t = null then o1 = True else o1 = (if black (colors memo1 t) then True else False) else o1 = False) \<longrightarrow> (if o1 = True then p = null \<and> (t = null \<or> black (colors memo1 t)) else \<forall>(o2 :: bool). (if t = null then o2 = True else o2 = (if black (colors memo1 t) then True else False)) \<longrightarrow> (if o2 = True then \<not>p = null \<and> (case colors memo1 p of Black (Some m) \<Rightarrow> \<not>p = null \<and> (let s :: int = block_size memo1 p in (0 :: int) \<le> s \<longrightarrow> (let n :: int = m + (1 :: int) in if n = s then (\<not>p = null \<and> (0 :: int) \<le> m \<and> m < block_size memo1 p) \<and> (\<not>p = null \<and> (0 :: int) \<le> m \<and> m < block_size memo1 p) \<and> (\<forall>(memo2 :: memory). block_size memo2 = block_size memo1 \<and> colors memo2 = colors memo1 \<longrightarrow> accessor memo2 = (accessor memo1)(p := (accessor memo1 p)(m := t)) \<longrightarrow> (\<not>p = null \<or> \<not>t = null \<and> \<not>black (colors memo1 t)) \<and> (\<not>t = null \<and> \<not>black (colors memo1 t) \<and> block_size memo1 t = (0 :: int) \<longrightarrow> colors memo2 = (colors memo1)(t := Black None) \<and> p = t \<and> accessor memo1 p m = p \<and> accessor memo2 = accessor memo1) \<and> (\<not>t = null \<and> \<not>black (colors memo1 t) \<and> (0 :: int) < block_size memo1 t \<longrightarrow> colors memo2 = (colors memo1)(t := Black (Some (0 :: int))) \<and> p = accessor memo1 t (0 :: int) \<and> accessor memo1 p m = t \<and> accessor memo2 = (accessor memo1)(t := (accessor memo1 t)(0 :: int := p))) \<and> (t = null \<or> black (colors memo1 t) \<longrightarrow> (case colors memo1 p of Black (Some m1) \<Rightarrow> (let n1 :: int = m1 + (1 :: int) in if n1 = block_size memo1 p then accessor memo1 p m = accessor memo1 p m1 \<and> colors memo2 = colors memo1 \<and> accessor memo2 = (accessor memo1)(p := (accessor memo1 p)(m1 := t)) else accessor memo1 p m = p \<and> p = accessor memo1 p n1 \<and> colors memo2 = (colors memo1)(p := Black (Some n1)) \<and> accessor memo2 = (accessor memo1)(p := (accessor memo1 p)(m1 := t, n1 := accessor memo1 p m1))) | _ \<Rightarrow> False))) else (\<not>p = null \<and> (0 :: int) \<le> n \<and> n < block_size memo1 p) \<and> (\<not>p = null \<and> (0 :: int) \<le> m \<and> m < block_size memo1 p) \<and> (\<not>p = null \<and> (0 :: int) \<le> n \<and> n < block_size memo1 p) \<and> (\<forall>(memo2 :: memory). block_size memo2 = block_size memo1 \<and> colors memo2 = colors memo1 \<longrightarrow> accessor memo2 = (accessor memo1)(p := (accessor memo1 p)(n := accessor memo1 p m)) \<longrightarrow> (\<not>p = null \<and> (0 :: int) \<le> m \<and> m < block_size memo2 p) \<and> (\<forall>(memo3 :: memory). block_size memo3 = block_size memo2 \<and> colors memo3 = colors memo2 \<longrightarrow> accessor memo3 = (accessor memo2)(p := (accessor memo2 p)(m := t)) \<longrightarrow> (\<not>p = null \<and> (0 :: int) \<le> n \<and> n < block_size memo3 p) \<and> (\<forall>(memo4 :: memory). block_size memo4 = block_size memo3 \<and> accessor memo4 = accessor memo3 \<longrightarrow> colors memo4 = (colors memo3)(p := Black (Some n)) \<longrightarrow> (\<not>p = null \<or> \<not>t = null \<and> \<not>black (colors memo1 t)) \<and> (\<not>t = null \<and> \<not>black (colors memo1 t) \<and> block_size memo1 t = (0 :: int) \<longrightarrow> colors memo4 = (colors memo1)(t := Black None) \<and> accessor memo1 p n = t \<and> accessor memo4 = accessor memo1) \<and> (\<not>t = null \<and> \<not>black (colors memo1 t) \<and> (0 :: int) < block_size memo1 t \<longrightarrow> colors memo4 = (colors memo1)(t := Black (Some (0 :: int))) \<and> accessor memo1 p n = accessor memo1 t (0 :: int) \<and> p = t \<and> accessor memo4 = (accessor memo1)(t := (accessor memo1 t)(0 :: int := p))) \<and> (t = null \<or> black (colors memo1 t) \<longrightarrow> (case colors memo1 p of Black (Some m1) \<Rightarrow> (let n1 :: int = m1 + (1 :: int) in if n1 = block_size memo1 p then accessor memo1 p n = p \<and> p = accessor memo1 p m1 \<and> colors memo4 = colors memo1 \<and> accessor memo4 = (accessor memo1)(p := (accessor memo1 p)(m1 := t)) else accessor memo1 p n = accessor memo1 p n1 \<and> colors memo4 = (colors memo1)(p := Black (Some n1)) \<and> accessor memo4 = (accessor memo1)(p := (accessor memo1 p)(m1 := t, n1 := accessor memo1 p m1))) | _ \<Rightarrow> False))))))) | _ \<Rightarrow> False) else \<not>t = null \<and> (let s :: int = block_size memo1 t in (0 :: int) \<le> s \<longrightarrow> (if s = (0 :: int) then (\<not>t = null \<and> block_size memo1 t = (0 :: int)) \<and> (\<forall>(memo2 :: memory). block_size memo2 = block_size memo1 \<and> accessor memo2 = accessor memo1 \<longrightarrow> colors memo2 = (colors memo1)(t := Black None) \<longrightarrow> (\<not>p = null \<or> \<not>t = null \<and> \<not>black (colors memo1 t)) \<and> (\<not>t = null \<and> \<not>black (colors memo1 t) \<and> block_size memo1 t = (0 :: int) \<longrightarrow> colors memo2 = (colors memo1)(t := Black None) \<and> accessor memo2 = accessor memo1) \<and> (\<not>t = null \<and> \<not>black (colors memo1 t) \<and> (0 :: int) < block_size memo1 t \<longrightarrow> colors memo2 = (colors memo1)(t := Black (Some (0 :: int))) \<and> t = accessor memo1 t (0 :: int) \<and> p = t \<and> accessor memo2 = (accessor memo1)(t := (accessor memo1 t)(0 :: int := p))) \<and> (t = null \<or> black (colors memo1 t) \<longrightarrow> (case colors memo1 p of Black (Some m) \<Rightarrow> (let n :: int = m + (1 :: int) in if n = block_size memo1 p then t = p \<and> p = accessor memo1 p m \<and> colors memo2 = colors memo1 \<and> accessor memo2 = (accessor memo1)(p := (accessor memo1 p)(m := t)) else t = accessor memo1 p n \<and> colors memo2 = (colors memo1)(p := Black (Some n)) \<and> accessor memo2 = (accessor memo1)(p := (accessor memo1 p)(m := t, n := accessor memo1 p m))) | _ \<Rightarrow> False))) else (\<not>t = null \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) < block_size memo1 t) \<and> (\<not>t = null \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) < block_size memo1 t) \<and> (\<forall>(memo2 :: memory). block_size memo2 = block_size memo1 \<and> colors memo2 = colors memo1 \<longrightarrow> accessor memo2 = (accessor memo1)(t := (accessor memo1 t)(0 :: int := p)) \<longrightarrow> (\<not>t = null \<and> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) < block_size memo2 t) \<and> (\<forall>(memo3 :: memory). block_size memo3 = block_size memo2 \<and> accessor memo3 = accessor memo2 \<longrightarrow> colors memo3 = (colors memo2)(t := Black (Some (0 :: int))) \<longrightarrow> (\<not>p = null \<or> \<not>t = null \<and> \<not>black (colors memo1 t)) \<and> (\<not>t = null \<and> \<not>black (colors memo1 t) \<and> block_size memo1 t = (0 :: int) \<longrightarrow> colors memo3 = (colors memo1)(t := Black None) \<and> accessor memo1 t (0 :: int) = t \<and> t = p \<and> accessor memo3 = accessor memo1) \<and> (\<not>t = null \<and> \<not>black (colors memo1 t) \<and> (0 :: int) < block_size memo1 t \<longrightarrow> colors memo3 = (colors memo1)(t := Black (Some (0 :: int))) \<and> accessor memo3 = (accessor memo1)(t := (accessor memo1 t)(0 :: int := p))) \<and> (t = null \<or> black (colors memo1 t) \<longrightarrow> (case colors memo1 p of Black (Some m) \<Rightarrow> (let n :: int = m + (1 :: int) in if n = block_size memo1 p then accessor memo1 t (0 :: int) = p \<and> t = accessor memo1 p m \<and> colors memo3 = colors memo1 \<and> accessor memo3 = (accessor memo1)(p := (accessor memo1 p)(m := t)) else t = p \<and> accessor memo1 t (0 :: int) = accessor memo1 p n \<and> colors memo3 = (colors memo1)(p := Black (Some n)) \<and> accessor memo3 = (accessor memo1)(p := (accessor memo1 p)(m := t, n := accessor memo1 p m))) | _ \<Rightarrow> False)))))))))"
  and "\<forall>(p :: loc) (t :: loc) (memo1 :: memory). block_size memo1 = block_size memo \<longrightarrow> (\<forall>(gray :: loc fset). well_colored_on graph gray memo (colors memo1) \<and> t |\<in>| graph \<and> (\<forall>(x :: loc) (n :: int). \<not>x = null \<and> \<not>black (colors memo1 x) \<and> (0 :: int) \<le> n \<and> n < block_size memo1 x \<longrightarrow> accessor memo1 x n = accessor memo x n) \<longrightarrow> (\<forall>(o1 :: bool). (if t = null then o1 = True else o1 = (if black (colors memo1 t) then True else False)) \<longrightarrow> (if o1 = True then unchanged memo1 memo1 \<and> well_colored_on graph gray memo (colors memo1) \<and> (black (colors memo1 t) \<or> t = null) else \<not>t = null \<and> (let s :: int = block_size memo1 t in (0 :: int) \<le> s \<longrightarrow> (let g2 :: loc fset = finsert t gray in (\<not>p = null \<and> (t = null \<or> black (colors memo1 t)) \<longrightarrow> (case colors memo1 p of Black (Some m) \<Rightarrow> (0 :: int) \<le> m \<and> m < block_size memo1 p | _ \<Rightarrow> False)) \<and> (\<forall>(p1 :: loc) (t1 :: loc) (memo2 :: memory). block_size memo2 = block_size memo1 \<longrightarrow> ((\<not>p = null \<or> \<not>t = null \<and> \<not>black (colors memo1 t)) \<and> (\<not>t = null \<and> \<not>black (colors memo1 t) \<and> block_size memo1 t = (0 :: int) \<longrightarrow> colors memo2 = (colors memo1)(t := Black None) \<and> t1 = t \<and> p1 = p \<and> accessor memo2 = accessor memo1) \<and> (\<not>t = null \<and> \<not>black (colors memo1 t) \<and> (0 :: int) < block_size memo1 t \<longrightarrow> colors memo2 = (colors memo1)(t := Black (Some (0 :: int))) \<and> t1 = accessor memo1 t (0 :: int) \<and> p1 = t \<and> accessor memo2 = (accessor memo1)(t := (accessor memo1 t)(0 :: int := p))) \<and> (t = null \<or> black (colors memo1 t) \<longrightarrow> (case colors memo1 p of Black (Some m) \<Rightarrow> (let n :: int = m + (1 :: int) in if n = block_size memo1 p then t1 = p \<and> p1 = accessor memo1 p m \<and> colors memo2 = colors memo1 \<and> accessor memo2 = (accessor memo1)(p := (accessor memo1 p)(m := t)) else p1 = p \<and> t1 = accessor memo1 p n \<and> colors memo2 = (colors memo1)(p := Black (Some n)) \<and> accessor memo2 = (accessor memo1)(p := (accessor memo1 p)(m := t, n := accessor memo1 p m))) | _ \<Rightarrow> False)) \<longrightarrow> (if \<not>s = (0 :: int) then let o2 :: int = s - (2 :: int) in ((0 :: int) \<le> o2 + (1 :: int) \<longrightarrow> (well_colored_on graph g2 memo (colors memo2) \<and> p1 = t \<and> t1 = accessor memo p1 (0 :: int) \<and> colors memo2 p1 = Black (Some (0 :: int)) \<and> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < s) \<and> \<not>j = (0 :: int) \<longrightarrow> accessor memo2 p1 j = accessor memo1 p1 j) \<and> accessor memo2 p1 (0 :: int) = p \<and> (\<forall>(l :: loc) (n :: int). \<not>l = null \<and> \<not>l = p1 \<and> (0 :: int) \<le> n \<and> n < block_size memo2 l \<longrightarrow> accessor memo2 l n = accessor memo1 l n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> (let l :: loc = accessor memo2 p1 j in l = null \<or> black (colors memo2 l))) \<and> (\<forall>(l :: loc). \<not>l = null \<longrightarrow> \<not>path memo p1 l \<or> black (colors memo1 l) \<longrightarrow> colors memo2 l = colors memo1 l)) \<and> (\<forall>(p2 :: loc) (t2 :: loc) (memo3 :: memory). block_size memo3 = block_size memo2 \<longrightarrow> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o2) \<and> well_colored_on graph g2 memo (colors memo3) \<and> p2 = t \<and> t2 = accessor memo p2 i \<and> colors memo3 p2 = Black (Some i) \<and> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < s) \<and> \<not>j = i \<longrightarrow> accessor memo3 p2 j = accessor memo1 p2 j) \<and> accessor memo3 p2 i = p \<and> (\<forall>(l :: loc) (n :: int). \<not>l = null \<and> \<not>l = p2 \<and> (0 :: int) \<le> n \<and> n < block_size memo3 l \<longrightarrow> accessor memo3 l n = accessor memo1 l n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> (let l :: loc = accessor memo3 p2 j in l = null \<or> black (colors memo3 l))) \<and> (\<forall>(l :: loc). \<not>l = null \<longrightarrow> \<not>path memo p2 l \<or> black (colors memo1 l) \<longrightarrow> colors memo3 l = colors memo1 l) \<longrightarrow> (((0 :: int) \<le> int (fcard graph) - int (fcard gray) \<and> int (fcard graph) - int (fcard g2) < int (fcard graph) - int (fcard gray)) \<and> well_colored_on graph g2 memo (colors memo3) \<and> t2 |\<in>| graph \<and> (\<forall>(x :: loc) (n :: int). \<not>x = null \<and> \<not>black (colors memo3 x) \<and> (0 :: int) \<le> n \<and> n < block_size memo3 x \<longrightarrow> accessor memo3 x n = accessor memo x n)) \<and> (\<forall>(memo4 :: memory). block_size memo4 = block_size memo3 \<longrightarrow> unchanged memo3 memo4 \<and> well_colored_on graph g2 memo (colors memo4) \<and> (black (colors memo4 t2) \<or> t2 = null) \<and> (\<forall>(x :: loc). \<not>x = null \<longrightarrow> \<not>path memo t2 x \<or> black (colors memo3 x) \<longrightarrow> colors memo4 x = colors memo3 x) \<longrightarrow> (\<not>p2 = null \<and> (t2 = null \<or> black (colors memo4 t2)) \<longrightarrow> (case colors memo4 p2 of Black (Some m) \<Rightarrow> (0 :: int) \<le> m \<and> m < block_size memo4 p2 | _ \<Rightarrow> False)) \<and> (\<forall>(p3 :: loc) (t3 :: loc) (memo5 :: memory). block_size memo5 = block_size memo4 \<longrightarrow> ((\<not>p2 = null \<or> \<not>t2 = null \<and> \<not>black (colors memo4 t2)) \<and> (\<not>t2 = null \<and> \<not>black (colors memo4 t2) \<and> block_size memo4 t2 = (0 :: int) \<longrightarrow> colors memo5 = (colors memo4)(t2 := Black None) \<and> t3 = t2 \<and> p3 = p2 \<and> accessor memo5 = accessor memo4) \<and> (\<not>t2 = null \<and> \<not>black (colors memo4 t2) \<and> (0 :: int) < block_size memo4 t2 \<longrightarrow> colors memo5 = (colors memo4)(t2 := Black (Some (0 :: int))) \<and> t3 = accessor memo4 t2 (0 :: int) \<and> p3 = t2 \<and> accessor memo5 = (accessor memo4)(t2 := (accessor memo4 t2)(0 :: int := p2))) \<and> (t2 = null \<or> black (colors memo4 t2) \<longrightarrow> (case colors memo4 p2 of Black (Some m) \<Rightarrow> (let n :: int = m + (1 :: int) in if n = block_size memo4 p2 then t3 = p2 \<and> p3 = accessor memo4 p2 m \<and> colors memo5 = colors memo4 \<and> accessor memo5 = (accessor memo4)(p2 := (accessor memo4 p2)(m := t2)) else p3 = p2 \<and> t3 = accessor memo4 p2 n \<and> colors memo5 = (colors memo4)(p2 := Black (Some n)) \<and> accessor memo5 = (accessor memo4)(p2 := (accessor memo4 p2)(m := t2, n := accessor memo4 p2 m))) | _ \<Rightarrow> False)) \<longrightarrow> well_colored_on graph g2 memo (colors memo5) \<and> p3 = t \<and> t3 = accessor memo p3 (i + (1 :: int)) \<and> colors memo5 p3 = Black (Some (i + (1 :: int))) \<and> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < s) \<and> \<not>j = i + (1 :: int) \<longrightarrow> accessor memo5 p3 j = accessor memo1 p3 j) \<and> accessor memo5 p3 (i + (1 :: int)) = p \<and> (\<forall>(l :: loc) (n :: int). \<not>l = null \<and> \<not>l = p3 \<and> (0 :: int) \<le> n \<and> n < block_size memo5 l \<longrightarrow> accessor memo5 l n = accessor memo1 l n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> (let l :: loc = accessor memo5 p3 j in l = null \<or> black (colors memo5 l))) \<and> (\<forall>(l :: loc). \<not>l = null \<longrightarrow> \<not>path memo p3 l \<or> black (colors memo1 l) \<longrightarrow> colors memo5 l = colors memo1 l)) \<and> \<not>((p2 = null \<and> (t2 = null \<or> black (colors memo4 t2))) \<and> colors memo5 = colors memo4 \<and> accessor memo5 = accessor memo4)))) \<and> (well_colored_on graph g2 memo (colors memo3) \<and> p2 = t \<and> t2 = accessor memo p2 (o2 + (1 :: int)) \<and> colors memo3 p2 = Black (Some (o2 + (1 :: int))) \<and> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j < s) \<and> \<not>j = o2 + (1 :: int) \<longrightarrow> accessor memo3 p2 j = accessor memo1 p2 j) \<and> accessor memo3 p2 (o2 + (1 :: int)) = p \<and> (\<forall>(l :: loc) (n :: int). \<not>l = null \<and> \<not>l = p2 \<and> (0 :: int) \<le> n \<and> n < block_size memo3 l \<longrightarrow> accessor memo3 l n = accessor memo1 l n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < o2 + (1 :: int) \<longrightarrow> (let l :: loc = accessor memo3 p2 j in l = null \<or> black (colors memo3 l))) \<and> (\<forall>(l :: loc). \<not>l = null \<longrightarrow> \<not>path memo p2 l \<or> black (colors memo1 l) \<longrightarrow> colors memo3 l = colors memo1 l) \<longrightarrow> (((0 :: int) \<le> int (fcard graph) - int (fcard gray) \<and> int (fcard graph) - int (fcard g2) < int (fcard graph) - int (fcard gray)) \<and> well_colored_on graph g2 memo (colors memo3) \<and> t2 |\<in>| graph \<and> (\<forall>(x :: loc) (n :: int). \<not>x = null \<and> \<not>black (colors memo3 x) \<and> (0 :: int) \<le> n \<and> n < block_size memo3 x \<longrightarrow> accessor memo3 x n = accessor memo x n)) \<and> (\<forall>(memo4 :: memory). block_size memo4 = block_size memo3 \<longrightarrow> unchanged memo3 memo4 \<and> well_colored_on graph g2 memo (colors memo4) \<and> (black (colors memo4 t2) \<or> t2 = null) \<and> (\<forall>(x :: loc). \<not>x = null \<longrightarrow> \<not>path memo t2 x \<or> black (colors memo3 x) \<longrightarrow> colors memo4 x = colors memo3 x) \<longrightarrow> (\<not>p2 = null \<and> (t2 = null \<or> black (colors memo4 t2)) \<longrightarrow> (case colors memo4 p2 of Black (Some m) \<Rightarrow> (0 :: int) \<le> m \<and> m < block_size memo4 p2 | _ \<Rightarrow> False)) \<and> (\<forall>(p3 :: loc) (t3 :: loc) (memo5 :: memory). block_size memo5 = block_size memo4 \<longrightarrow> ((\<not>p2 = null \<or> \<not>t2 = null \<and> \<not>black (colors memo4 t2)) \<and> (\<not>t2 = null \<and> \<not>black (colors memo4 t2) \<and> block_size memo4 t2 = (0 :: int) \<longrightarrow> colors memo5 = (colors memo4)(t2 := Black None) \<and> t3 = t2 \<and> p3 = p2 \<and> accessor memo5 = accessor memo4) \<and> (\<not>t2 = null \<and> \<not>black (colors memo4 t2) \<and> (0 :: int) < block_size memo4 t2 \<longrightarrow> colors memo5 = (colors memo4)(t2 := Black (Some (0 :: int))) \<and> t3 = accessor memo4 t2 (0 :: int) \<and> p3 = t2 \<and> accessor memo5 = (accessor memo4)(t2 := (accessor memo4 t2)(0 :: int := p2))) \<and> (t2 = null \<or> black (colors memo4 t2) \<longrightarrow> (case colors memo4 p2 of Black (Some m) \<Rightarrow> (let n :: int = m + (1 :: int) in if n = block_size memo4 p2 then t3 = p2 \<and> p3 = accessor memo4 p2 m \<and> colors memo5 = colors memo4 \<and> accessor memo5 = (accessor memo4)(p2 := (accessor memo4 p2)(m := t2)) else p3 = p2 \<and> t3 = accessor memo4 p2 n \<and> colors memo5 = (colors memo4)(p2 := Black (Some n)) \<and> accessor memo5 = (accessor memo4)(p2 := (accessor memo4 p2)(m := t2, n := accessor memo4 p2 m))) | _ \<Rightarrow> False)) \<longrightarrow> (t3 = t \<and> p3 = p) \<and> unchanged memo1 memo5 \<and> well_colored_on graph gray memo (colors memo5) \<and> (black (colors memo5 t3) \<or> t3 = null) \<and> (\<forall>(x :: loc). \<not>x = null \<longrightarrow> \<not>path memo t3 x \<or> black (colors memo1 x) \<longrightarrow> colors memo5 x = colors memo1 x)) \<and> \<not>((p2 = null \<and> (t2 = null \<or> black (colors memo4 t2))) \<and> colors memo5 = colors memo4 \<and> accessor memo5 = accessor memo4)))))) \<and> (o2 + (1 :: int) < (0 :: int) \<longrightarrow> (((0 :: int) \<le> int (fcard graph) - int (fcard gray) \<and> int (fcard graph) - int (fcard g2) < int (fcard graph) - int (fcard gray)) \<and> well_colored_on graph g2 memo (colors memo2) \<and> t1 |\<in>| graph \<and> (\<forall>(x :: loc) (n :: int). \<not>x = null \<and> \<not>black (colors memo2 x) \<and> (0 :: int) \<le> n \<and> n < block_size memo2 x \<longrightarrow> accessor memo2 x n = accessor memo x n)) \<and> (\<forall>(memo3 :: memory). block_size memo3 = block_size memo2 \<longrightarrow> unchanged memo2 memo3 \<and> well_colored_on graph g2 memo (colors memo3) \<and> (black (colors memo3 t1) \<or> t1 = null) \<and> (\<forall>(x :: loc). \<not>x = null \<longrightarrow> \<not>path memo t1 x \<or> black (colors memo2 x) \<longrightarrow> colors memo3 x = colors memo2 x) \<longrightarrow> (\<not>p1 = null \<and> (t1 = null \<or> black (colors memo3 t1)) \<longrightarrow> (case colors memo3 p1 of Black (Some m) \<Rightarrow> (0 :: int) \<le> m \<and> m < block_size memo3 p1 | _ \<Rightarrow> False)) \<and> (\<forall>(p2 :: loc) (t2 :: loc) (memo4 :: memory). block_size memo4 = block_size memo3 \<longrightarrow> ((\<not>p1 = null \<or> \<not>t1 = null \<and> \<not>black (colors memo3 t1)) \<and> (\<not>t1 = null \<and> \<not>black (colors memo3 t1) \<and> block_size memo3 t1 = (0 :: int) \<longrightarrow> colors memo4 = (colors memo3)(t1 := Black None) \<and> t2 = t1 \<and> p2 = p1 \<and> accessor memo4 = accessor memo3) \<and> (\<not>t1 = null \<and> \<not>black (colors memo3 t1) \<and> (0 :: int) < block_size memo3 t1 \<longrightarrow> colors memo4 = (colors memo3)(t1 := Black (Some (0 :: int))) \<and> t2 = accessor memo3 t1 (0 :: int) \<and> p2 = t1 \<and> accessor memo4 = (accessor memo3)(t1 := (accessor memo3 t1)(0 :: int := p1))) \<and> (t1 = null \<or> black (colors memo3 t1) \<longrightarrow> (case colors memo3 p1 of Black (Some m) \<Rightarrow> (let n :: int = m + (1 :: int) in if n = block_size memo3 p1 then t2 = p1 \<and> p2 = accessor memo3 p1 m \<and> colors memo4 = colors memo3 \<and> accessor memo4 = (accessor memo3)(p1 := (accessor memo3 p1)(m := t1)) else p2 = p1 \<and> t2 = accessor memo3 p1 n \<and> colors memo4 = (colors memo3)(p1 := Black (Some n)) \<and> accessor memo4 = (accessor memo3)(p1 := (accessor memo3 p1)(m := t1, n := accessor memo3 p1 m))) | _ \<Rightarrow> False)) \<longrightarrow> (t2 = t \<and> p2 = p) \<and> unchanged memo1 memo4 \<and> well_colored_on graph gray memo (colors memo4) \<and> (black (colors memo4 t2) \<or> t2 = null) \<and> (\<forall>(x :: loc). \<not>x = null \<longrightarrow> \<not>path memo t2 x \<or> black (colors memo1 x) \<longrightarrow> colors memo4 x = colors memo1 x)) \<and> \<not>((p1 = null \<and> (t1 = null \<or> black (colors memo3 t1))) \<and> colors memo4 = colors memo3 \<and> accessor memo4 = accessor memo3)))) else (t1 = t \<and> p1 = p) \<and> unchanged memo1 memo2 \<and> well_colored_on graph gray memo (colors memo2) \<and> (black (colors memo2 t1) \<or> t1 = null) \<and> (\<forall>(x :: loc). \<not>x = null \<longrightarrow> \<not>path memo t1 x \<or> black (colors memo1 x) \<longrightarrow> colors memo2 x = colors memo1 x))) \<and> \<not>((p = null \<and> (t = null \<or> black (colors memo1 t))) \<and> colors memo2 = colors memo1 \<and> accessor memo2 = accessor memo1)))))))"
  and "let o1 :: loc fset = fempty in (well_colored_on graph o1 memo (colors memo) \<and> root |\<in>| graph) \<and> (\<forall>(memo1 :: memory). block_size memo1 = block_size memo \<longrightarrow> unchanged memo memo1 \<and> well_colored_on graph o1 memo (colors memo1) \<and> (black (colors memo1 root) \<or> root = null) \<and> (\<forall>(x :: loc). \<not>x = null \<longrightarrow> \<not>path memo root x \<or> black (colors memo x) \<longrightarrow> colors memo1 x = colors memo x) \<longrightarrow> (\<not>True \<and> (root = null \<or> black (colors memo1 root)) \<longrightarrow> (case colors memo1 null of Black (Some m) \<Rightarrow> (0 :: int) \<le> m \<and> m < block_size memo1 null | _ \<Rightarrow> False)) \<and> (\<forall>(p :: loc) (t :: loc) (memo2 :: memory). block_size memo2 = block_size memo1 \<longrightarrow> \<not>((\<not>True \<or> \<not>root = null \<and> \<not>black (colors memo1 root)) \<and> (\<not>root = null \<and> \<not>black (colors memo1 root) \<and> block_size memo1 root = (0 :: int) \<longrightarrow> colors memo2 = (colors memo1)(root := Black None) \<and> t = root \<and> p = null \<and> accessor memo2 = accessor memo1) \<and> (\<not>root = null \<and> \<not>black (colors memo1 root) \<and> (0 :: int) < block_size memo1 root \<longrightarrow> colors memo2 = (colors memo1)(root := Black (Some (0 :: int))) \<and> t = accessor memo1 root (0 :: int) \<and> p = root \<and> accessor memo2 = (accessor memo1)(root := (accessor memo1 root)(0 :: int := null))) \<and> (root = null \<or> black (colors memo1 root) \<longrightarrow> (case colors memo1 null of Black (Some m) \<Rightarrow> (let n :: int = m + (1 :: int) in if n = block_size memo1 null then t = null \<and> p = accessor memo1 null m \<and> colors memo2 = colors memo1 \<and> accessor memo2 = (accessor memo1)(null := (accessor memo1 null)(m := root)) else p = null \<and> t = accessor memo1 null n \<and> colors memo2 = (colors memo1)(null := Black (Some n)) \<and> accessor memo2 = (accessor memo1)(null := (accessor memo1 null)(m := root, n := accessor memo1 null m))) | _ \<Rightarrow> False))) \<and> ((root = null \<or> black (colors memo1 root)) \<and> colors memo2 = colors memo1 \<and> accessor memo2 = accessor memo1 \<longrightarrow> unchanged memo memo2 \<and> (\<forall>(x :: loc). path memo root x \<and> \<not>x = null \<longrightarrow> black (colors memo2 x)) \<and> (\<forall>(x :: loc). \<not>path memo root x \<and> \<not>x = null \<longrightarrow> colors memo2 x = colors memo x))))"
  sorry
end
