From Coq Require Import Strings.String.
From Coq Require Import String Ascii.
From Coq Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Coq Require Classical.
From Coq Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Coq Require Import Sorting.Sorted.
From Coq Require Import Reals.Rbasic_fun.
From Coq Require Import Reals.Abstract.ConstructiveAbs.
From Coq Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Coq Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Coq Require Import ZArith.Zeuclid.
From Coq Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Coq Require Import Reals.
Require Import Why3.Base.
Require Import Why3.why3.Ref.Ref.
Require Import Why3.map.Const.
Require Import schorr_waite_via_recursion_vcg.schorr_waite_via_recursion.Memory.
Require Import schorr_waite_via_recursion_vcg.schorr_waite_via_recursion.GraphShape.
Open Scope Z_scope.
Theorem schorr_waite'vc (root : loc) (graph : gset loc) (memo : memory) (fact0 : root ∈ graph) (fact1 : ∀(l : loc) (n : Z), l ∈ graph ∧ ¬ l = null ∧ 0%Z ≤ n ∧ n < block_size memo l -> accessor memo l n ∈ graph) (fact2 : ∀(x : loc), x ∈ graph -> ¬ black (colors memo x)) : (∀(p : loc) (t : loc) (memo1 : memory), block_size memo1 = block_size memo -> (¬ p = null ∧ (t = null ∨ black (colors memo1 t)) -> (match colors memo1 p with | Black (Some m) => 0%Z ≤ m ∧ m < block_size memo1 p | _ => False end)) -> (∀(o1 : bool), (if decide (p = null) then if decide (t = null) then o1 = true else o1 = (if decide (black (colors memo1 t)) then true else false) else o1 = false) -> (if decide (o1 = true) then p = null ∧ (t = null ∨ black (colors memo1 t)) else ∀(o2 : bool), (if decide (t = null) then o2 = true else o2 = (if decide (black (colors memo1 t)) then true else false)) -> (if decide (o2 = true) then ¬ p = null ∧ (match colors memo1 p with | Black (Some m) => ¬ p = null ∧ (let s : Z := block_size memo1 p in 0%Z ≤ s -> (let n : Z := m + 1%Z in if decide (n = s) then (¬ p = null ∧ 0%Z ≤ m ∧ m < block_size memo1 p) ∧ (¬ p = null ∧ 0%Z ≤ m ∧ m < block_size memo1 p) ∧ (∀(memo2 : memory), block_size memo2 = block_size memo1 ∧ colors memo2 = colors memo1 -> accessor memo2 = fun_updt (accessor memo1) p (fun_updt (accessor memo1 p) m t) -> (¬ p = null ∨ ¬ t = null ∧ ¬ black (colors memo1 t)) ∧ (¬ t = null ∧ ¬ black (colors memo1 t) ∧ block_size memo1 t = 0%Z -> colors memo2 = fun_updt (colors memo1) t (Black None) ∧ p = t ∧ accessor memo1 p m = p ∧ accessor memo2 = accessor memo1) ∧ (¬ t = null ∧ ¬ black (colors memo1 t) ∧ 0%Z < block_size memo1 t -> colors memo2 = fun_updt (colors memo1) t (Black (Some 0%Z)) ∧ p = accessor memo1 t 0%Z ∧ accessor memo1 p m = t ∧ accessor memo2 = fun_updt (accessor memo1) t (fun_updt (accessor memo1 t) 0%Z p)) ∧ (t = null ∨ black (colors memo1 t) -> (match colors memo1 p with | Black (Some m1) => (let n1 : Z := m1 + 1%Z in if decide (n1 = block_size memo1 p) then accessor memo1 p m = accessor memo1 p m1 ∧ colors memo2 = colors memo1 ∧ accessor memo2 = fun_updt (accessor memo1) p (fun_updt (accessor memo1 p) m1 t) else accessor memo1 p m = p ∧ p = accessor memo1 p n1 ∧ colors memo2 = fun_updt (colors memo1) p (Black (Some n1)) ∧ accessor memo2 = fun_updt (accessor memo1) p (fun_updt (fun_updt (accessor memo1 p) n1 (accessor memo1 p m1)) m1 t)) | _ => False end))) else (¬ p = null ∧ 0%Z ≤ n ∧ n < block_size memo1 p) ∧ (¬ p = null ∧ 0%Z ≤ m ∧ m < block_size memo1 p) ∧ (¬ p = null ∧ 0%Z ≤ n ∧ n < block_size memo1 p) ∧ (∀(memo2 : memory), block_size memo2 = block_size memo1 ∧ colors memo2 = colors memo1 -> accessor memo2 = fun_updt (accessor memo1) p (fun_updt (accessor memo1 p) n (accessor memo1 p m)) -> (¬ p = null ∧ 0%Z ≤ m ∧ m < block_size memo2 p) ∧ (∀(memo3 : memory), block_size memo3 = block_size memo2 ∧ colors memo3 = colors memo2 -> accessor memo3 = fun_updt (accessor memo2) p (fun_updt (accessor memo2 p) m t) -> (¬ p = null ∧ 0%Z ≤ n ∧ n < block_size memo3 p) ∧ (∀(memo4 : memory), block_size memo4 = block_size memo3 ∧ accessor memo4 = accessor memo3 -> colors memo4 = fun_updt (colors memo3) p (Black (Some n)) -> (¬ p = null ∨ ¬ t = null ∧ ¬ black (colors memo1 t)) ∧ (¬ t = null ∧ ¬ black (colors memo1 t) ∧ block_size memo1 t = 0%Z -> colors memo4 = fun_updt (colors memo1) t (Black None) ∧ accessor memo1 p n = t ∧ accessor memo4 = accessor memo1) ∧ (¬ t = null ∧ ¬ black (colors memo1 t) ∧ 0%Z < block_size memo1 t -> colors memo4 = fun_updt (colors memo1) t (Black (Some 0%Z)) ∧ accessor memo1 p n = accessor memo1 t 0%Z ∧ p = t ∧ accessor memo4 = fun_updt (accessor memo1) t (fun_updt (accessor memo1 t) 0%Z p)) ∧ (t = null ∨ black (colors memo1 t) -> (match colors memo1 p with | Black (Some m1) => (let n1 : Z := m1 + 1%Z in if decide (n1 = block_size memo1 p) then accessor memo1 p n = p ∧ p = accessor memo1 p m1 ∧ colors memo4 = colors memo1 ∧ accessor memo4 = fun_updt (accessor memo1) p (fun_updt (accessor memo1 p) m1 t) else accessor memo1 p n = accessor memo1 p n1 ∧ colors memo4 = fun_updt (colors memo1) p (Black (Some n1)) ∧ accessor memo4 = fun_updt (accessor memo1) p (fun_updt (fun_updt (accessor memo1 p) n1 (accessor memo1 p m1)) m1 t)) | _ => False end))))))) | _ => False end) else ¬ t = null ∧ (let s : Z := block_size memo1 t in 0%Z ≤ s -> (if decide (s = 0%Z) then (¬ t = null ∧ block_size memo1 t = 0%Z) ∧ (∀(memo2 : memory), block_size memo2 = block_size memo1 ∧ accessor memo2 = accessor memo1 -> colors memo2 = fun_updt (colors memo1) t (Black None) -> (¬ p = null ∨ ¬ t = null ∧ ¬ black (colors memo1 t)) ∧ (¬ t = null ∧ ¬ black (colors memo1 t) ∧ block_size memo1 t = 0%Z -> colors memo2 = fun_updt (colors memo1) t (Black None) ∧ accessor memo2 = accessor memo1) ∧ (¬ t = null ∧ ¬ black (colors memo1 t) ∧ 0%Z < block_size memo1 t -> colors memo2 = fun_updt (colors memo1) t (Black (Some 0%Z)) ∧ t = accessor memo1 t 0%Z ∧ p = t ∧ accessor memo2 = fun_updt (accessor memo1) t (fun_updt (accessor memo1 t) 0%Z p)) ∧ (t = null ∨ black (colors memo1 t) -> (match colors memo1 p with | Black (Some m) => (let n : Z := m + 1%Z in if decide (n = block_size memo1 p) then t = p ∧ p = accessor memo1 p m ∧ colors memo2 = colors memo1 ∧ accessor memo2 = fun_updt (accessor memo1) p (fun_updt (accessor memo1 p) m t) else t = accessor memo1 p n ∧ colors memo2 = fun_updt (colors memo1) p (Black (Some n)) ∧ accessor memo2 = fun_updt (accessor memo1) p (fun_updt (fun_updt (accessor memo1 p) n (accessor memo1 p m)) m t)) | _ => False end))) else (¬ t = null ∧ 0%Z ≤ 0%Z ∧ 0%Z < block_size memo1 t) ∧ (¬ t = null ∧ 0%Z ≤ 0%Z ∧ 0%Z < block_size memo1 t) ∧ (∀(memo2 : memory), block_size memo2 = block_size memo1 ∧ colors memo2 = colors memo1 -> accessor memo2 = fun_updt (accessor memo1) t (fun_updt (accessor memo1 t) 0%Z p) -> (¬ t = null ∧ 0%Z ≤ 0%Z ∧ 0%Z < block_size memo2 t) ∧ (∀(memo3 : memory), block_size memo3 = block_size memo2 ∧ accessor memo3 = accessor memo2 -> colors memo3 = fun_updt (colors memo2) t (Black (Some 0%Z)) -> (¬ p = null ∨ ¬ t = null ∧ ¬ black (colors memo1 t)) ∧ (¬ t = null ∧ ¬ black (colors memo1 t) ∧ block_size memo1 t = 0%Z -> colors memo3 = fun_updt (colors memo1) t (Black None) ∧ accessor memo1 t 0%Z = t ∧ t = p ∧ accessor memo3 = accessor memo1) ∧ (¬ t = null ∧ ¬ black (colors memo1 t) ∧ 0%Z < block_size memo1 t -> colors memo3 = fun_updt (colors memo1) t (Black (Some 0%Z)) ∧ accessor memo3 = fun_updt (accessor memo1) t (fun_updt (accessor memo1 t) 0%Z p)) ∧ (t = null ∨ black (colors memo1 t) -> (match colors memo1 p with | Black (Some m) => (let n : Z := m + 1%Z in if decide (n = block_size memo1 p) then accessor memo1 t 0%Z = p ∧ t = accessor memo1 p m ∧ colors memo3 = colors memo1 ∧ accessor memo3 = fun_updt (accessor memo1) p (fun_updt (accessor memo1 p) m t) else t = p ∧ accessor memo1 t 0%Z = accessor memo1 p n ∧ colors memo3 = fun_updt (colors memo1) p (Black (Some n)) ∧ accessor memo3 = fun_updt (accessor memo1) p (fun_updt (fun_updt (accessor memo1 p) n (accessor memo1 p m)) m t)) | _ => False end)))))))))) ∧ (∀(p : loc) (t : loc) (memo1 : memory), block_size memo1 = block_size memo -> (∀(gray : gset loc), well_colored_on graph gray memo (colors memo1) ∧ t ∈ graph ∧ (∀(x : loc) (n : Z), ¬ x = null ∧ ¬ black (colors memo1 x) ∧ 0%Z ≤ n ∧ n < block_size memo1 x -> accessor memo1 x n = accessor memo x n) -> (∀(o1 : bool), (if decide (t = null) then o1 = true else o1 = (if decide (black (colors memo1 t)) then true else false)) -> (if decide (o1 = true) then unchanged memo1 memo1 ∧ well_colored_on graph gray memo (colors memo1) ∧ (black (colors memo1 t) ∨ t = null) else ¬ t = null ∧ (let s : Z := block_size memo1 t in 0%Z ≤ s -> (let g2 : gset loc := insert_set t gray in (¬ p = null ∧ (t = null ∨ black (colors memo1 t)) -> (match colors memo1 p with | Black (Some m) => 0%Z ≤ m ∧ m < block_size memo1 p | _ => False end)) ∧ (∀(p1 : loc) (t1 : loc) (memo2 : memory), block_size memo2 = block_size memo1 -> ((¬ p = null ∨ ¬ t = null ∧ ¬ black (colors memo1 t)) ∧ (¬ t = null ∧ ¬ black (colors memo1 t) ∧ block_size memo1 t = 0%Z -> colors memo2 = fun_updt (colors memo1) t (Black None) ∧ t1 = t ∧ p1 = p ∧ accessor memo2 = accessor memo1) ∧ (¬ t = null ∧ ¬ black (colors memo1 t) ∧ 0%Z < block_size memo1 t -> colors memo2 = fun_updt (colors memo1) t (Black (Some 0%Z)) ∧ t1 = accessor memo1 t 0%Z ∧ p1 = t ∧ accessor memo2 = fun_updt (accessor memo1) t (fun_updt (accessor memo1 t) 0%Z p)) ∧ (t = null ∨ black (colors memo1 t) -> (match colors memo1 p with | Black (Some m) => (let n : Z := m + 1%Z in if decide (n = block_size memo1 p) then t1 = p ∧ p1 = accessor memo1 p m ∧ colors memo2 = colors memo1 ∧ accessor memo2 = fun_updt (accessor memo1) p (fun_updt (accessor memo1 p) m t) else p1 = p ∧ t1 = accessor memo1 p n ∧ colors memo2 = fun_updt (colors memo1) p (Black (Some n)) ∧ accessor memo2 = fun_updt (accessor memo1) p (fun_updt (fun_updt (accessor memo1 p) n (accessor memo1 p m)) m t)) | _ => False end)) -> (if decide (¬ s = 0%Z) then let o2 : Z := s - 2%Z in (0%Z ≤ o2 + 1%Z -> (well_colored_on graph g2 memo (colors memo2) ∧ p1 = t ∧ t1 = accessor memo p1 0%Z ∧ colors memo2 p1 = Black (Some 0%Z) ∧ (∀(j : Z), (0%Z ≤ j ∧ j < s) ∧ ¬ j = 0%Z -> accessor memo2 p1 j = accessor memo1 p1 j) ∧ accessor memo2 p1 0%Z = p ∧ (∀(l : loc) (n : Z), ¬ l = null ∧ ¬ l = p1 ∧ 0%Z ≤ n ∧ n < block_size memo2 l -> accessor memo2 l n = accessor memo1 l n) ∧ (∀(j : Z), 0%Z ≤ j ∧ j < 0%Z -> (let l : loc := accessor memo2 p1 j in l = null ∨ black (colors memo2 l))) ∧ (∀(l : loc), ¬ l = null -> ¬ path memo p1 l ∨ black (colors memo1 l) -> colors memo2 l = colors memo1 l)) ∧ (∀(p2 : loc) (t2 : loc) (memo3 : memory), block_size memo3 = block_size memo2 -> (∀(i : Z), (0%Z ≤ i ∧ i ≤ o2) ∧ well_colored_on graph g2 memo (colors memo3) ∧ p2 = t ∧ t2 = accessor memo p2 i ∧ colors memo3 p2 = Black (Some i) ∧ (∀(j : Z), (0%Z ≤ j ∧ j < s) ∧ ¬ j = i -> accessor memo3 p2 j = accessor memo1 p2 j) ∧ accessor memo3 p2 i = p ∧ (∀(l : loc) (n : Z), ¬ l = null ∧ ¬ l = p2 ∧ 0%Z ≤ n ∧ n < block_size memo3 l -> accessor memo3 l n = accessor memo1 l n) ∧ (∀(j : Z), 0%Z ≤ j ∧ j < i -> (let l : loc := accessor memo3 p2 j in l = null ∨ black (colors memo3 l))) ∧ (∀(l : loc), ¬ l = null -> ¬ path memo p2 l ∨ black (colors memo1 l) -> colors memo3 l = colors memo1 l) -> ((0%Z ≤ Z.of_nat (size graph) - Z.of_nat (size gray) ∧ Z.of_nat (size graph) - Z.of_nat (size g2) < Z.of_nat (size graph) - Z.of_nat (size gray)) ∧ well_colored_on graph g2 memo (colors memo3) ∧ t2 ∈ graph ∧ (∀(x : loc) (n : Z), ¬ x = null ∧ ¬ black (colors memo3 x) ∧ 0%Z ≤ n ∧ n < block_size memo3 x -> accessor memo3 x n = accessor memo x n)) ∧ (∀(memo4 : memory), block_size memo4 = block_size memo3 -> unchanged memo3 memo4 ∧ well_colored_on graph g2 memo (colors memo4) ∧ (black (colors memo4 t2) ∨ t2 = null) ∧ (∀(x : loc), ¬ x = null -> ¬ path memo t2 x ∨ black (colors memo3 x) -> colors memo4 x = colors memo3 x) -> (¬ p2 = null ∧ (t2 = null ∨ black (colors memo4 t2)) -> (match colors memo4 p2 with | Black (Some m) => 0%Z ≤ m ∧ m < block_size memo4 p2 | _ => False end)) ∧ (∀(p3 : loc) (t3 : loc) (memo5 : memory), block_size memo5 = block_size memo4 -> ((¬ p2 = null ∨ ¬ t2 = null ∧ ¬ black (colors memo4 t2)) ∧ (¬ t2 = null ∧ ¬ black (colors memo4 t2) ∧ block_size memo4 t2 = 0%Z -> colors memo5 = fun_updt (colors memo4) t2 (Black None) ∧ t3 = t2 ∧ p3 = p2 ∧ accessor memo5 = accessor memo4) ∧ (¬ t2 = null ∧ ¬ black (colors memo4 t2) ∧ 0%Z < block_size memo4 t2 -> colors memo5 = fun_updt (colors memo4) t2 (Black (Some 0%Z)) ∧ t3 = accessor memo4 t2 0%Z ∧ p3 = t2 ∧ accessor memo5 = fun_updt (accessor memo4) t2 (fun_updt (accessor memo4 t2) 0%Z p2)) ∧ (t2 = null ∨ black (colors memo4 t2) -> (match colors memo4 p2 with | Black (Some m) => (let n : Z := m + 1%Z in if decide (n = block_size memo4 p2) then t3 = p2 ∧ p3 = accessor memo4 p2 m ∧ colors memo5 = colors memo4 ∧ accessor memo5 = fun_updt (accessor memo4) p2 (fun_updt (accessor memo4 p2) m t2) else p3 = p2 ∧ t3 = accessor memo4 p2 n ∧ colors memo5 = fun_updt (colors memo4) p2 (Black (Some n)) ∧ accessor memo5 = fun_updt (accessor memo4) p2 (fun_updt (fun_updt (accessor memo4 p2) n (accessor memo4 p2 m)) m t2)) | _ => False end)) -> well_colored_on graph g2 memo (colors memo5) ∧ p3 = t ∧ t3 = accessor memo p3 (i + 1%Z) ∧ colors memo5 p3 = Black (Some (i + 1%Z)) ∧ (∀(j : Z), (0%Z ≤ j ∧ j < s) ∧ ¬ j = i + 1%Z -> accessor memo5 p3 j = accessor memo1 p3 j) ∧ accessor memo5 p3 (i + 1%Z) = p ∧ (∀(l : loc) (n : Z), ¬ l = null ∧ ¬ l = p3 ∧ 0%Z ≤ n ∧ n < block_size memo5 l -> accessor memo5 l n = accessor memo1 l n) ∧ (∀(j : Z), 0%Z ≤ j ∧ j < i + 1%Z -> (let l : loc := accessor memo5 p3 j in l = null ∨ black (colors memo5 l))) ∧ (∀(l : loc), ¬ l = null -> ¬ path memo p3 l ∨ black (colors memo1 l) -> colors memo5 l = colors memo1 l)) ∧ ¬ ((p2 = null ∧ (t2 = null ∨ black (colors memo4 t2))) ∧ colors memo5 = colors memo4 ∧ accessor memo5 = accessor memo4)))) ∧ (well_colored_on graph g2 memo (colors memo3) ∧ p2 = t ∧ t2 = accessor memo p2 (o2 + 1%Z) ∧ colors memo3 p2 = Black (Some (o2 + 1%Z)) ∧ (∀(j : Z), (0%Z ≤ j ∧ j < s) ∧ ¬ j = o2 + 1%Z -> accessor memo3 p2 j = accessor memo1 p2 j) ∧ accessor memo3 p2 (o2 + 1%Z) = p ∧ (∀(l : loc) (n : Z), ¬ l = null ∧ ¬ l = p2 ∧ 0%Z ≤ n ∧ n < block_size memo3 l -> accessor memo3 l n = accessor memo1 l n) ∧ (∀(j : Z), 0%Z ≤ j ∧ j < o2 + 1%Z -> (let l : loc := accessor memo3 p2 j in l = null ∨ black (colors memo3 l))) ∧ (∀(l : loc), ¬ l = null -> ¬ path memo p2 l ∨ black (colors memo1 l) -> colors memo3 l = colors memo1 l) -> ((0%Z ≤ Z.of_nat (size graph) - Z.of_nat (size gray) ∧ Z.of_nat (size graph) - Z.of_nat (size g2) < Z.of_nat (size graph) - Z.of_nat (size gray)) ∧ well_colored_on graph g2 memo (colors memo3) ∧ t2 ∈ graph ∧ (∀(x : loc) (n : Z), ¬ x = null ∧ ¬ black (colors memo3 x) ∧ 0%Z ≤ n ∧ n < block_size memo3 x -> accessor memo3 x n = accessor memo x n)) ∧ (∀(memo4 : memory), block_size memo4 = block_size memo3 -> unchanged memo3 memo4 ∧ well_colored_on graph g2 memo (colors memo4) ∧ (black (colors memo4 t2) ∨ t2 = null) ∧ (∀(x : loc), ¬ x = null -> ¬ path memo t2 x ∨ black (colors memo3 x) -> colors memo4 x = colors memo3 x) -> (¬ p2 = null ∧ (t2 = null ∨ black (colors memo4 t2)) -> (match colors memo4 p2 with | Black (Some m) => 0%Z ≤ m ∧ m < block_size memo4 p2 | _ => False end)) ∧ (∀(p3 : loc) (t3 : loc) (memo5 : memory), block_size memo5 = block_size memo4 -> ((¬ p2 = null ∨ ¬ t2 = null ∧ ¬ black (colors memo4 t2)) ∧ (¬ t2 = null ∧ ¬ black (colors memo4 t2) ∧ block_size memo4 t2 = 0%Z -> colors memo5 = fun_updt (colors memo4) t2 (Black None) ∧ t3 = t2 ∧ p3 = p2 ∧ accessor memo5 = accessor memo4) ∧ (¬ t2 = null ∧ ¬ black (colors memo4 t2) ∧ 0%Z < block_size memo4 t2 -> colors memo5 = fun_updt (colors memo4) t2 (Black (Some 0%Z)) ∧ t3 = accessor memo4 t2 0%Z ∧ p3 = t2 ∧ accessor memo5 = fun_updt (accessor memo4) t2 (fun_updt (accessor memo4 t2) 0%Z p2)) ∧ (t2 = null ∨ black (colors memo4 t2) -> (match colors memo4 p2 with | Black (Some m) => (let n : Z := m + 1%Z in if decide (n = block_size memo4 p2) then t3 = p2 ∧ p3 = accessor memo4 p2 m ∧ colors memo5 = colors memo4 ∧ accessor memo5 = fun_updt (accessor memo4) p2 (fun_updt (accessor memo4 p2) m t2) else p3 = p2 ∧ t3 = accessor memo4 p2 n ∧ colors memo5 = fun_updt (colors memo4) p2 (Black (Some n)) ∧ accessor memo5 = fun_updt (accessor memo4) p2 (fun_updt (fun_updt (accessor memo4 p2) n (accessor memo4 p2 m)) m t2)) | _ => False end)) -> (t3 = t ∧ p3 = p) ∧ unchanged memo1 memo5 ∧ well_colored_on graph gray memo (colors memo5) ∧ (black (colors memo5 t3) ∨ t3 = null) ∧ (∀(x : loc), ¬ x = null -> ¬ path memo t3 x ∨ black (colors memo1 x) -> colors memo5 x = colors memo1 x)) ∧ ¬ ((p2 = null ∧ (t2 = null ∨ black (colors memo4 t2))) ∧ colors memo5 = colors memo4 ∧ accessor memo5 = accessor memo4)))))) ∧ (o2 + 1%Z < 0%Z -> ((0%Z ≤ Z.of_nat (size graph) - Z.of_nat (size gray) ∧ Z.of_nat (size graph) - Z.of_nat (size g2) < Z.of_nat (size graph) - Z.of_nat (size gray)) ∧ well_colored_on graph g2 memo (colors memo2) ∧ t1 ∈ graph ∧ (∀(x : loc) (n : Z), ¬ x = null ∧ ¬ black (colors memo2 x) ∧ 0%Z ≤ n ∧ n < block_size memo2 x -> accessor memo2 x n = accessor memo x n)) ∧ (∀(memo3 : memory), block_size memo3 = block_size memo2 -> unchanged memo2 memo3 ∧ well_colored_on graph g2 memo (colors memo3) ∧ (black (colors memo3 t1) ∨ t1 = null) ∧ (∀(x : loc), ¬ x = null -> ¬ path memo t1 x ∨ black (colors memo2 x) -> colors memo3 x = colors memo2 x) -> (¬ p1 = null ∧ (t1 = null ∨ black (colors memo3 t1)) -> (match colors memo3 p1 with | Black (Some m) => 0%Z ≤ m ∧ m < block_size memo3 p1 | _ => False end)) ∧ (∀(p2 : loc) (t2 : loc) (memo4 : memory), block_size memo4 = block_size memo3 -> ((¬ p1 = null ∨ ¬ t1 = null ∧ ¬ black (colors memo3 t1)) ∧ (¬ t1 = null ∧ ¬ black (colors memo3 t1) ∧ block_size memo3 t1 = 0%Z -> colors memo4 = fun_updt (colors memo3) t1 (Black None) ∧ t2 = t1 ∧ p2 = p1 ∧ accessor memo4 = accessor memo3) ∧ (¬ t1 = null ∧ ¬ black (colors memo3 t1) ∧ 0%Z < block_size memo3 t1 -> colors memo4 = fun_updt (colors memo3) t1 (Black (Some 0%Z)) ∧ t2 = accessor memo3 t1 0%Z ∧ p2 = t1 ∧ accessor memo4 = fun_updt (accessor memo3) t1 (fun_updt (accessor memo3 t1) 0%Z p1)) ∧ (t1 = null ∨ black (colors memo3 t1) -> (match colors memo3 p1 with | Black (Some m) => (let n : Z := m + 1%Z in if decide (n = block_size memo3 p1) then t2 = p1 ∧ p2 = accessor memo3 p1 m ∧ colors memo4 = colors memo3 ∧ accessor memo4 = fun_updt (accessor memo3) p1 (fun_updt (accessor memo3 p1) m t1) else p2 = p1 ∧ t2 = accessor memo3 p1 n ∧ colors memo4 = fun_updt (colors memo3) p1 (Black (Some n)) ∧ accessor memo4 = fun_updt (accessor memo3) p1 (fun_updt (fun_updt (accessor memo3 p1) n (accessor memo3 p1 m)) m t1)) | _ => False end)) -> (t2 = t ∧ p2 = p) ∧ unchanged memo1 memo4 ∧ well_colored_on graph gray memo (colors memo4) ∧ (black (colors memo4 t2) ∨ t2 = null) ∧ (∀(x : loc), ¬ x = null -> ¬ path memo t2 x ∨ black (colors memo1 x) -> colors memo4 x = colors memo1 x)) ∧ ¬ ((p1 = null ∧ (t1 = null ∨ black (colors memo3 t1))) ∧ colors memo4 = colors memo3 ∧ accessor memo4 = accessor memo3)))) else (t1 = t ∧ p1 = p) ∧ unchanged memo1 memo2 ∧ well_colored_on graph gray memo (colors memo2) ∧ (black (colors memo2 t1) ∨ t1 = null) ∧ (∀(x : loc), ¬ x = null -> ¬ path memo t1 x ∨ black (colors memo1 x) -> colors memo2 x = colors memo1 x))) ∧ ¬ ((p = null ∧ (t = null ∨ black (colors memo1 t))) ∧ colors memo2 = colors memo1 ∧ accessor memo2 = accessor memo1)))))))) ∧ (let o1 : gset loc := (∅ : gset loc) in (well_colored_on graph o1 memo (colors memo) ∧ root ∈ graph) ∧ (∀(memo1 : memory), block_size memo1 = block_size memo -> unchanged memo memo1 ∧ well_colored_on graph o1 memo (colors memo1) ∧ (black (colors memo1 root) ∨ root = null) ∧ (∀(x : loc), ¬ x = null -> ¬ path memo root x ∨ black (colors memo x) -> colors memo1 x = colors memo x) -> (¬ True ∧ (root = null ∨ black (colors memo1 root)) -> (match colors memo1 null with | Black (Some m) => 0%Z ≤ m ∧ m < block_size memo1 null | _ => False end)) ∧ (∀(p : loc) (t : loc) (memo2 : memory), block_size memo2 = block_size memo1 -> ¬ ((¬ True ∨ ¬ root = null ∧ ¬ black (colors memo1 root)) ∧ (¬ root = null ∧ ¬ black (colors memo1 root) ∧ block_size memo1 root = 0%Z -> colors memo2 = fun_updt (colors memo1) root (Black None) ∧ t = root ∧ p = null ∧ accessor memo2 = accessor memo1) ∧ (¬ root = null ∧ ¬ black (colors memo1 root) ∧ 0%Z < block_size memo1 root -> colors memo2 = fun_updt (colors memo1) root (Black (Some 0%Z)) ∧ t = accessor memo1 root 0%Z ∧ p = root ∧ accessor memo2 = fun_updt (accessor memo1) root (fun_updt (accessor memo1 root) 0%Z null)) ∧ (root = null ∨ black (colors memo1 root) -> (match colors memo1 null with | Black (Some m) => (let n : Z := m + 1%Z in if decide (n = block_size memo1 null) then t = null ∧ p = accessor memo1 null m ∧ colors memo2 = colors memo1 ∧ accessor memo2 = fun_updt (accessor memo1) null (fun_updt (accessor memo1 null) m root) else p = null ∧ t = accessor memo1 null n ∧ colors memo2 = fun_updt (colors memo1) null (Black (Some n)) ∧ accessor memo2 = fun_updt (accessor memo1) null (fun_updt (fun_updt (accessor memo1 null) n (accessor memo1 null m)) m root)) | _ => False end))) ∧ ((root = null ∨ black (colors memo1 root)) ∧ colors memo2 = colors memo1 ∧ accessor memo2 = accessor memo1 -> unchanged memo memo2 ∧ (∀(x : loc), path memo root x ∧ ¬ x = null -> black (colors memo2 x)) ∧ (∀(x : loc), ¬ path memo root x ∧ ¬ x = null -> colors memo2 x = colors memo x))))).
Proof.
Admitted.
