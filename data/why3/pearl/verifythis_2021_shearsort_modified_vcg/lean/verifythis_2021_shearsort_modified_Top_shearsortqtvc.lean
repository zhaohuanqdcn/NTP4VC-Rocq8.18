import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
import Why3.int.Sum
import Why3.matrix.Matrix
open Classical
open Lean4Why3
namespace verifythis_2021_shearsort_modified_Top_shearsortqtvc
axiom fc : ℤ -> Matrix.matrix ℤ -> ℤ -> ℤ
axiom fc'def (x : ℤ) (m : Matrix.matrix ℤ) (i : ℤ) : fc x m i = Int.ofNat (Lean4Why3.map_occ x (Matrix.elts m i) (0 : ℤ) (Matrix.columns m))
noncomputable def mocc (x : ℤ) (m : Matrix.matrix ℤ) := int.Sum.sum (fc x m) (0 : ℤ) (Matrix.rows m)
noncomputable def lt (i : ℤ) (j : ℤ) (k : ℤ) (l : ℤ) := i < k ∨ i = k ∧ (if Int.tmod i (2 : ℤ) = (0 : ℤ) then j < l else l < j)
noncomputable def snake_order (m : Matrix.matrix ℤ) := let rw : ℤ := Matrix.rows m; let cl : ℤ := Matrix.columns m; ∀(i : ℤ) (j : ℤ) (k : ℤ) (l : ℤ), (0 : ℤ) ≤ i ∧ i < rw → (0 : ℤ) ≤ j ∧ j < cl → (0 : ℤ) ≤ k ∧ k < rw → (0 : ℤ) ≤ l ∧ l < cl → lt i j k l → Matrix.elts m i j ≤ Matrix.elts m k l
axiom fc1 : Matrix.matrix ℤ -> ℤ -> ℤ -> ℤ -> ℤ -> Bool
axiom fc2 : Matrix.matrix ℤ -> ℤ -> ℤ -> ℤ -> ℤ
axiom fc3 : Matrix.matrix ℤ -> ℤ -> ℤ -> ℤ
axiom fc4 : Matrix.matrix ℤ -> ℤ -> ℤ
axiom fc'def1 (m : Matrix.matrix ℤ) (i : ℤ) (j : ℤ) (k : ℤ) (l : ℤ) : (fc1 m i j k l = true) = (lt i j k l ∧ Matrix.elts m k l < Matrix.elts m i j)
axiom fc'def2 (m : Matrix.matrix ℤ) (i : ℤ) (j : ℤ) (k : ℤ) : fc2 m i j k = NumOf.numof (fc1 m i j k) (0 : ℤ) (Matrix.columns m)
axiom fc'def3 (m : Matrix.matrix ℤ) (i : ℤ) (j : ℤ) : fc3 m i j = int.Sum.sum (fc2 m i j) (0 : ℤ) (Matrix.rows m)
axiom fc'def4 (m : Matrix.matrix ℤ) (i : ℤ) : fc4 m i = int.Sum.sum (fc3 m i) (0 : ℤ) (Matrix.columns m)
noncomputable def inversions (m : Matrix.matrix ℤ) := int.Sum.sum (fc4 m) (0 : ℤ) (Matrix.rows m)
noncomputable def sorted_row (m : Matrix.matrix ℤ) (row : ℤ) (ascending : Bool) := ((0 : ℤ) ≤ row ∧ row < Matrix.rows m) ∧ (if ascending = true then ∀(j : ℤ) (l : ℤ), (0 : ℤ) ≤ j ∧ j ≤ l ∧ l < Matrix.columns m → Matrix.elts m row j ≤ Matrix.elts m row l else ∀(j : ℤ) (l : ℤ), (0 : ℤ) ≤ j ∧ j ≤ l ∧ l < Matrix.columns m → Matrix.elts m row l ≤ Matrix.elts m row j)
noncomputable def sorted_column (m : Matrix.matrix ℤ) (column : ℤ) := ((0 : ℤ) ≤ column ∧ column < Matrix.columns m) ∧ (∀(i : ℤ) (k : ℤ), (0 : ℤ) ≤ i ∧ i ≤ k ∧ k < Matrix.rows m → Matrix.elts m i column ≤ Matrix.elts m k column)
theorem shearsort'vc (m : Matrix.matrix ℤ) (m1 : Matrix.matrix ℤ) (fact0 : Matrix.rows m = Matrix.columns m) (fact1 : Matrix.rows m1 = Matrix.rows m) (fact2 : Matrix.columns m1 = Matrix.columns m) (fact3 : ∀(x : ℤ), mocc x m1 = mocc x m) : let o1 : ℤ := Matrix.columns m - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → ((∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < (0 : ℤ) → sorted_row m1 k (if Int.tmod k (2 : ℤ) = (0 : ℤ) then true else false)) ∧ (∀(x : ℤ), mocc x m1 = mocc x m) ∧ inversions m1 ≤ inversions m1) ∧ (∀(m2 : Matrix.matrix ℤ), Matrix.rows m2 = Matrix.rows m1 ∧ Matrix.columns m2 = Matrix.columns m1 → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i → sorted_row m2 k (if Int.tmod k (2 : ℤ) = (0 : ℤ) then true else false)) ∧ (∀(x : ℤ), mocc x m2 = mocc x m) ∧ inversions m2 ≤ inversions m1 → ¬(2 : ℤ) = (0 : ℤ) ∧ ((0 : ℤ) ≤ i ∧ i < Matrix.rows m2) ∧ (∀(m3 : Matrix.matrix ℤ), Matrix.rows m3 = Matrix.rows m2 ∧ Matrix.columns m3 = Matrix.columns m2 → (∀(i1 : ℤ) (j : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < Matrix.rows m3 → (0 : ℤ) ≤ j ∧ j < Matrix.columns m3 → ¬i1 = i → Matrix.elts m3 i1 j = Matrix.elts m2 i1 j) ∧ (∀(x : ℤ), mocc x m3 = mocc x m2) ∧ sorted_row m3 i (if Int.tmod i (2 : ℤ) = (0 : ℤ) then true else false) ∧ inversions m3 ≤ inversions m2 → (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i + (1 : ℤ) → sorted_row m3 k (if Int.tmod k (2 : ℤ) = (0 : ℤ) then true else false)) ∧ (∀(x : ℤ), mocc x m3 = mocc x m) ∧ inversions m3 ≤ inversions m1)) ∧ ((∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < o1 + (1 : ℤ) → sorted_row m2 k (if Int.tmod k (2 : ℤ) = (0 : ℤ) then true else false)) ∧ (∀(x : ℤ), mocc x m2 = mocc x m) ∧ inversions m2 ≤ inversions m1 → (let o2 : ℤ := Matrix.columns m - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → ((∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < (0 : ℤ) → sorted_column m2 l) ∧ (∀(x : ℤ), mocc x m2 = mocc x m) ∧ inversions m2 ≤ inversions m2) ∧ (∀(nochange : Bool) (m3 : Matrix.matrix ℤ), Matrix.rows m3 = Matrix.rows m2 ∧ Matrix.columns m3 = Matrix.columns m2 → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j ≤ o2) ∧ (nochange = true → (∀(i : ℤ) (j1 : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m3 → (0 : ℤ) ≤ j1 ∧ j1 < Matrix.columns m3 → Matrix.elts m3 i j1 = Matrix.elts m2 i j1)) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < j → sorted_column m3 l) ∧ (∀(x : ℤ), mocc x m3 = mocc x m) ∧ inversions m3 ≤ inversions m2 ∧ (¬nochange = true → inversions m3 < inversions m2) → ((0 : ℤ) ≤ j ∧ j < Matrix.columns m3) ∧ (∀(m4 : Matrix.matrix ℤ), Matrix.rows m4 = Matrix.rows m3 ∧ Matrix.columns m4 = Matrix.columns m3 → (∀(nch : Bool), (∀(i : ℤ) (j1 : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m4 → (0 : ℤ) ≤ j1 ∧ j1 < Matrix.columns m4 → ¬j1 = j → Matrix.elts m4 i j1 = Matrix.elts m3 i j1) ∧ (∀(x : ℤ), mocc x m4 = mocc x m3) ∧ (nch = true → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m4 → Matrix.elts m4 i j = Matrix.elts m3 i j)) ∧ sorted_column m4 j ∧ inversions m4 ≤ inversions m3 ∧ (¬nch = true → inversions m4 < inversions m3) → (if ¬nch = true then (false = true → (∀(i : ℤ) (j1 : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m4 → (0 : ℤ) ≤ j1 ∧ j1 < Matrix.columns m4 → Matrix.elts m4 i j1 = Matrix.elts m2 i j1)) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < j + (1 : ℤ) → sorted_column m4 l) ∧ (∀(x : ℤ), mocc x m4 = mocc x m) ∧ inversions m4 ≤ inversions m2 ∧ (¬false = true → inversions m4 < inversions m2) else (nochange = true → (∀(i : ℤ) (j1 : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m4 → (0 : ℤ) ≤ j1 ∧ j1 < Matrix.columns m4 → Matrix.elts m4 i j1 = Matrix.elts m2 i j1)) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < j + (1 : ℤ) → sorted_column m4 l) ∧ (∀(x : ℤ), mocc x m4 = mocc x m) ∧ inversions m4 ≤ inversions m2 ∧ (¬nochange = true → inversions m4 < inversions m2))))) ∧ ((nochange = true → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m3 → (0 : ℤ) ≤ j ∧ j < Matrix.columns m3 → Matrix.elts m3 i j = Matrix.elts m2 i j)) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < o2 + (1 : ℤ) → sorted_column m3 l) ∧ (∀(x : ℤ), mocc x m3 = mocc x m) ∧ inversions m3 ≤ inversions m2 ∧ (¬nochange = true → inversions m3 < inversions m2) → (if nochange = true then (∀(i : ℤ) (j : ℤ) (k : ℤ) (l : ℤ), ((0 : ℤ) ≤ i ∧ i < Matrix.columns m) ∧ ((0 : ℤ) ≤ j ∧ j < Matrix.columns m) ∧ ((0 : ℤ) ≤ k ∧ k < Matrix.columns m) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m) ∧ lt i j k l → Matrix.elts m3 i j ≤ Matrix.elts m3 k l) ∧ snake_order m3 ∧ (∀(x : ℤ), mocc x m3 = mocc x m) else ((0 : ℤ) ≤ inversions m1 ∧ inversions m3 < inversions m1) ∧ (∀(x : ℤ), mocc x m3 = mocc x m))))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → (∀(i : ℤ) (j : ℤ) (k : ℤ) (l : ℤ), ((0 : ℤ) ≤ i ∧ i < Matrix.columns m) ∧ ((0 : ℤ) ≤ j ∧ j < Matrix.columns m) ∧ ((0 : ℤ) ≤ k ∧ k < Matrix.columns m) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m) ∧ lt i j k l → Matrix.elts m2 i j ≤ Matrix.elts m2 k l) ∧ snake_order m2 ∧ (∀(x : ℤ), mocc x m2 = mocc x m)))))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (let o2 : ℤ := Matrix.columns m - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → ((∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < (0 : ℤ) → sorted_column m1 l) ∧ (∀(x : ℤ), mocc x m1 = mocc x m) ∧ inversions m1 ≤ inversions m1) ∧ (∀(nochange : Bool) (m2 : Matrix.matrix ℤ), Matrix.rows m2 = Matrix.rows m1 ∧ Matrix.columns m2 = Matrix.columns m1 → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j ≤ o2) ∧ (nochange = true → (∀(i : ℤ) (j1 : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m2 → (0 : ℤ) ≤ j1 ∧ j1 < Matrix.columns m2 → Matrix.elts m2 i j1 = Matrix.elts m1 i j1)) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < j → sorted_column m2 l) ∧ (∀(x : ℤ), mocc x m2 = mocc x m) ∧ inversions m2 ≤ inversions m1 ∧ (¬nochange = true → inversions m2 < inversions m1) → ((0 : ℤ) ≤ j ∧ j < Matrix.columns m2) ∧ (∀(m3 : Matrix.matrix ℤ), Matrix.rows m3 = Matrix.rows m2 ∧ Matrix.columns m3 = Matrix.columns m2 → (∀(nch : Bool), (∀(i : ℤ) (j1 : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m3 → (0 : ℤ) ≤ j1 ∧ j1 < Matrix.columns m3 → ¬j1 = j → Matrix.elts m3 i j1 = Matrix.elts m2 i j1) ∧ (∀(x : ℤ), mocc x m3 = mocc x m2) ∧ (nch = true → (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m3 → Matrix.elts m3 i j = Matrix.elts m2 i j)) ∧ sorted_column m3 j ∧ inversions m3 ≤ inversions m2 ∧ (¬nch = true → inversions m3 < inversions m2) → (if ¬nch = true then (false = true → (∀(i : ℤ) (j1 : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m3 → (0 : ℤ) ≤ j1 ∧ j1 < Matrix.columns m3 → Matrix.elts m3 i j1 = Matrix.elts m1 i j1)) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < j + (1 : ℤ) → sorted_column m3 l) ∧ (∀(x : ℤ), mocc x m3 = mocc x m) ∧ inversions m3 ≤ inversions m1 ∧ (¬false = true → inversions m3 < inversions m1) else (nochange = true → (∀(i : ℤ) (j1 : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m3 → (0 : ℤ) ≤ j1 ∧ j1 < Matrix.columns m3 → Matrix.elts m3 i j1 = Matrix.elts m1 i j1)) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < j + (1 : ℤ) → sorted_column m3 l) ∧ (∀(x : ℤ), mocc x m3 = mocc x m) ∧ inversions m3 ≤ inversions m1 ∧ (¬nochange = true → inversions m3 < inversions m1))))) ∧ ((nochange = true → (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < Matrix.rows m2 → (0 : ℤ) ≤ j ∧ j < Matrix.columns m2 → Matrix.elts m2 i j = Matrix.elts m1 i j)) ∧ (∀(l : ℤ), (0 : ℤ) ≤ l ∧ l < o2 + (1 : ℤ) → sorted_column m2 l) ∧ (∀(x : ℤ), mocc x m2 = mocc x m) ∧ inversions m2 ≤ inversions m1 ∧ (¬nochange = true → inversions m2 < inversions m1) → (if nochange = true then (∀(i : ℤ) (j : ℤ) (k : ℤ) (l : ℤ), ((0 : ℤ) ≤ i ∧ i < Matrix.columns m) ∧ ((0 : ℤ) ≤ j ∧ j < Matrix.columns m) ∧ ((0 : ℤ) ≤ k ∧ k < Matrix.columns m) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m) ∧ lt i j k l → Matrix.elts m2 i j ≤ Matrix.elts m2 k l) ∧ snake_order m2 ∧ (∀(x : ℤ), mocc x m2 = mocc x m) else ((0 : ℤ) ≤ inversions m1 ∧ inversions m2 < inversions m1) ∧ (∀(x : ℤ), mocc x m2 = mocc x m))))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → (∀(i : ℤ) (j : ℤ) (k : ℤ) (l : ℤ), ((0 : ℤ) ≤ i ∧ i < Matrix.columns m) ∧ ((0 : ℤ) ≤ j ∧ j < Matrix.columns m) ∧ ((0 : ℤ) ≤ k ∧ k < Matrix.columns m) ∧ ((0 : ℤ) ≤ l ∧ l < Matrix.columns m) ∧ lt i j k l → Matrix.elts m1 i j ≤ Matrix.elts m1 k l) ∧ snake_order m1 ∧ (∀(x : ℤ), mocc x m1 = mocc x m))))
  := sorry
end verifythis_2021_shearsort_modified_Top_shearsortqtvc
