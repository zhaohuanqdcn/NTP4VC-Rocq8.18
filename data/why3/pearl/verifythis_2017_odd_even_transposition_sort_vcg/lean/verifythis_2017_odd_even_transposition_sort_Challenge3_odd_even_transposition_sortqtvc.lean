import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.NumOf
import Why3.int.Sum
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
import Why3.array.IntArraySorted
import Why3.array.Inversions
open Classical
open Lean4Why3
namespace verifythis_2017_odd_even_transposition_sort_Challenge3_odd_even_transposition_sortqtvc
noncomputable def odd_sorted (a : List ℤ) (n : ℤ) := ∀(i : ℤ), (0 : ℤ) ≤ i → (2 : ℤ) * i + (2 : ℤ) < n → a[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]! ≤ a[Int.toNat ((2 : ℤ) * i + (2 : ℤ))]!
noncomputable def even_sorted (a : List ℤ) (n : ℤ) := ∀(i : ℤ), (0 : ℤ) ≤ i → (2 : ℤ) * i + (1 : ℤ) < n → a[Int.toNat ((2 : ℤ) * i)]! ≤ a[Int.toNat ((2 : ℤ) * i + (1 : ℤ))]!
theorem odd_even_transposition_sort'vc (a : List ℤ) : List.Perm a a ∧ (∀(is_sorted : Bool) (a1 : List ℤ), List.length a1 = List.length a → List.Perm a a1 ∧ (is_sorted = true → IntArraySorted.sorted a1) → (if ¬is_sorted = true then (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) = (2 : ℤ) * (0 : ℤ) + (1 : ℤ)) ∧ List.Perm a a1 ∧ odd_sorted a1 (1 : ℤ) ∧ (¬True → Inversions.inversions a1 < Inversions.inversions a1)) ∧ (∀(half_i : ℤ) (is_sorted1 : Bool) (a2 : List ℤ), List.length a2 = List.length a1 → ((0 : ℤ) ≤ half_i ∧ (0 : ℤ) ≤ (2 : ℤ) * half_i + (1 : ℤ)) ∧ List.Perm a a2 ∧ odd_sorted a2 ((2 : ℤ) * half_i + (1 : ℤ)) ∧ (if is_sorted1 = true then Inversions.inversions a2 = Inversions.inversions a1 else Inversions.inversions a2 < Inversions.inversions a1) → (if (2 : ℤ) * half_i + (1 : ℤ) < Int.ofNat (List.length a2) - (1 : ℤ) then let o1 : ℤ := (2 : ℤ) * half_i + (1 : ℤ) + (1 : ℤ); ((0 : ℤ) ≤ o1 ∧ o1 < Int.ofNat (List.length a2)) ∧ ((0 : ℤ) ≤ (2 : ℤ) * half_i + (1 : ℤ) ∧ (2 : ℤ) * half_i + (1 : ℤ) < Int.ofNat (List.length a2)) ∧ (if a2[Int.toNat o1]! < a2[Int.toNat ((2 : ℤ) * half_i + (1 : ℤ))]! then let o2 : ℤ := (2 : ℤ) * half_i + (1 : ℤ) + (1 : ℤ); (((0 : ℤ) ≤ (2 : ℤ) * half_i + (1 : ℤ) ∧ (2 : ℤ) * half_i + (1 : ℤ) < Int.ofNat (List.length a2)) ∧ (0 : ℤ) ≤ o2 ∧ o2 < Int.ofNat (List.length a2)) ∧ (∀(a3 : List ℤ), List.length a3 = List.length a2 → Lean4Why3.arrayExchange a2 a3 ((2 : ℤ) * half_i + (1 : ℤ)) o2 → ((0 : ℤ) ≤ Int.ofNat (List.length a2) - ((2 : ℤ) * half_i + (1 : ℤ)) ∧ Int.ofNat (List.length a3) - ((2 : ℤ) * half_i + (1 : ℤ) + (2 : ℤ)) < Int.ofNat (List.length a2) - ((2 : ℤ) * half_i + (1 : ℤ))) ∧ ((0 : ℤ) ≤ half_i + (1 : ℤ) ∧ (0 : ℤ) ≤ (2 : ℤ) * half_i + (1 : ℤ) + (2 : ℤ) ∧ (2 : ℤ) * half_i + (1 : ℤ) + (2 : ℤ) = (2 : ℤ) * (half_i + (1 : ℤ)) + (1 : ℤ)) ∧ List.Perm a a3 ∧ odd_sorted a3 ((2 : ℤ) * half_i + (1 : ℤ) + (2 : ℤ)) ∧ (if false = true then Inversions.inversions a3 = Inversions.inversions a1 else Inversions.inversions a3 < Inversions.inversions a1)) else ((0 : ℤ) ≤ Int.ofNat (List.length a2) - ((2 : ℤ) * half_i + (1 : ℤ)) ∧ Int.ofNat (List.length a2) - ((2 : ℤ) * half_i + (1 : ℤ) + (2 : ℤ)) < Int.ofNat (List.length a2) - ((2 : ℤ) * half_i + (1 : ℤ))) ∧ ((0 : ℤ) ≤ half_i + (1 : ℤ) ∧ (0 : ℤ) ≤ (2 : ℤ) * half_i + (1 : ℤ) + (2 : ℤ) ∧ (2 : ℤ) * half_i + (1 : ℤ) + (2 : ℤ) = (2 : ℤ) * (half_i + (1 : ℤ)) + (1 : ℤ)) ∧ List.Perm a a2 ∧ odd_sorted a2 ((2 : ℤ) * half_i + (1 : ℤ) + (2 : ℤ)) ∧ (if is_sorted1 = true then Inversions.inversions a2 = Inversions.inversions a1 else Inversions.inversions a2 < Inversions.inversions a1)) else (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) = (2 : ℤ) * (0 : ℤ)) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ List.Perm a a2 ∧ (is_sorted1 = true → odd_sorted a2 (Int.ofNat (List.length a2))) ∧ even_sorted a2 (0 : ℤ) ∧ (if is_sorted1 = true then Inversions.inversions a2 = Inversions.inversions a1 else Inversions.inversions a2 < Inversions.inversions a1) ∧ (is_sorted1 = true ∨ Inversions.inversions a2 < Inversions.inversions a1)) ∧ (∀(half_i1 : ℤ) (is_sorted2 : Bool) (a3 : List ℤ), List.length a3 = List.length a2 → ((0 : ℤ) ≤ half_i1 ∧ (0 : ℤ) ≤ (2 : ℤ) * half_i1) ∧ (0 : ℤ) ≤ (2 : ℤ) * half_i1 ∧ List.Perm a a3 ∧ (is_sorted2 = true → odd_sorted a3 (Int.ofNat (List.length a3))) ∧ even_sorted a3 ((2 : ℤ) * half_i1) ∧ (if is_sorted2 = true then Inversions.inversions a3 = Inversions.inversions a1 else Inversions.inversions a3 < Inversions.inversions a1) ∧ (is_sorted2 = true ∨ Inversions.inversions a3 < Inversions.inversions a1) → (if (2 : ℤ) * half_i1 < Int.ofNat (List.length a3) - (1 : ℤ) then let o1 : ℤ := (2 : ℤ) * half_i1 + (1 : ℤ); ((0 : ℤ) ≤ o1 ∧ o1 < Int.ofNat (List.length a3)) ∧ ((0 : ℤ) ≤ (2 : ℤ) * half_i1 ∧ (2 : ℤ) * half_i1 < Int.ofNat (List.length a3)) ∧ (if a3[Int.toNat o1]! < a3[Int.toNat ((2 : ℤ) * half_i1)]! then let o2 : ℤ := (2 : ℤ) * half_i1 + (1 : ℤ); (((0 : ℤ) ≤ (2 : ℤ) * half_i1 ∧ (2 : ℤ) * half_i1 < Int.ofNat (List.length a3)) ∧ (0 : ℤ) ≤ o2 ∧ o2 < Int.ofNat (List.length a3)) ∧ (∀(a4 : List ℤ), List.length a4 = List.length a3 → Lean4Why3.arrayExchange a3 a4 ((2 : ℤ) * half_i1) o2 → ((0 : ℤ) ≤ Int.ofNat (List.length a3) - (2 : ℤ) * half_i1 ∧ Int.ofNat (List.length a4) - ((2 : ℤ) * half_i1 + (2 : ℤ)) < Int.ofNat (List.length a3) - (2 : ℤ) * half_i1) ∧ ((0 : ℤ) ≤ half_i1 + (1 : ℤ) ∧ (0 : ℤ) ≤ (2 : ℤ) * half_i1 + (2 : ℤ) ∧ (2 : ℤ) * half_i1 + (2 : ℤ) = (2 : ℤ) * (half_i1 + (1 : ℤ))) ∧ (0 : ℤ) ≤ (2 : ℤ) * half_i1 + (2 : ℤ) ∧ List.Perm a a4 ∧ (false = true → odd_sorted a4 (Int.ofNat (List.length a4))) ∧ even_sorted a4 ((2 : ℤ) * half_i1 + (2 : ℤ)) ∧ (if false = true then Inversions.inversions a4 = Inversions.inversions a1 else Inversions.inversions a4 < Inversions.inversions a1) ∧ (false = true ∨ Inversions.inversions a4 < Inversions.inversions a1)) else ((0 : ℤ) ≤ Int.ofNat (List.length a3) - (2 : ℤ) * half_i1 ∧ Int.ofNat (List.length a3) - ((2 : ℤ) * half_i1 + (2 : ℤ)) < Int.ofNat (List.length a3) - (2 : ℤ) * half_i1) ∧ ((0 : ℤ) ≤ half_i1 + (1 : ℤ) ∧ (0 : ℤ) ≤ (2 : ℤ) * half_i1 + (2 : ℤ) ∧ (2 : ℤ) * half_i1 + (2 : ℤ) = (2 : ℤ) * (half_i1 + (1 : ℤ))) ∧ (0 : ℤ) ≤ (2 : ℤ) * half_i1 + (2 : ℤ) ∧ List.Perm a a3 ∧ (is_sorted2 = true → odd_sorted a3 (Int.ofNat (List.length a3))) ∧ even_sorted a3 ((2 : ℤ) * half_i1 + (2 : ℤ)) ∧ (if is_sorted2 = true then Inversions.inversions a3 = Inversions.inversions a1 else Inversions.inversions a3 < Inversions.inversions a1) ∧ (is_sorted2 = true ∨ Inversions.inversions a3 < Inversions.inversions a1)) else ((0 : ℤ) ≤ (if is_sorted = true then (0 : ℤ) else (1 : ℤ)) ∧ (if is_sorted2 = true then (0 : ℤ) else (1 : ℤ)) < (if is_sorted = true then (0 : ℤ) else (1 : ℤ)) ∨ (if is_sorted = true then (0 : ℤ) else (1 : ℤ)) = (if is_sorted2 = true then (0 : ℤ) else (1 : ℤ)) ∧ (0 : ℤ) ≤ Inversions.inversions a1 ∧ Inversions.inversions a3 < Inversions.inversions a1) ∧ List.Perm a a3 ∧ (is_sorted2 = true → IntArraySorted.sorted a3))))) else IntArraySorted.sorted a1 ∧ List.Perm a a1))
  := sorry
end verifythis_2017_odd_even_transposition_sort_Challenge3_odd_even_transposition_sortqtvc
