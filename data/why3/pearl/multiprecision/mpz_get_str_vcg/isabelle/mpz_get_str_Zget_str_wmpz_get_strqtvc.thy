theory mpz_get_str_Zget_str_wmpz_get_strqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "mach.c_String" "mach.c_UChar" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/mpz_Z" "../../lib/isabelle/mpz_Zutil" "../../lib/isabelle/base_info_BaseInfo" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/stringlemmas_String_lemmas" "../../lib/isabelle/stringlemmas_Conversions" "../../lib/isabelle/stringlemmas_String_value" "../../lib/isabelle/get_str_Get_str" "../../lib/isabelle/powm_Powm" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/div_Div" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/sub_1_Sub_1"
begin
definition effective :: "int \<Rightarrow> int"
  where "effective b = (if abs b < (2 :: int) then 10 :: int else abs b)" for b
theorem wmpz_get_str'vc:
  fixes sp :: "char ptr"
  fixes sz :: "32 word"
  fixes mpz :: "mpz_memo"
  fixes u :: "mpz_ptr"
  fixes base :: "32 word"
  assumes fact0: "valid sp (sint sz)"
  assumes fact1: "writable sp = True"
  assumes fact2: "(2 :: int) \<le> sint sz"
  assumes fact3: "abs_value_of mpz u < effective (sint base) ^\<^sub>i (sint sz - (2 :: int))"
  assumes fact4: "readers mpz u = (0 :: int)"
  assumes fact5: "(64 :: int) * abs_size mpz u + (7 :: int) \<le> (2147483647 :: int)"
  assumes fact6: "-(36 :: int) \<le> sint base"
  assumes fact7: "sint base \<le> (62 :: int)"
  shows "\<forall>(result :: string). (if (36 :: int) < sint base then result = ''0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'' else if (0 :: int) \<le> sint base then result = ''0123456789abcdefghijklmnopqrstuvwxyz'' else result = ''0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'') \<longrightarrow> (sint base < (0 :: int) \<longrightarrow> result = ''0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'') \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> result = ''0123456789abcdefghijklmnopqrstuvwxyz'') \<and> ((36 :: int) < sint base \<longrightarrow> result = ''0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'') \<and> effective (sint base) \<le> int (length result)"
  and "\<forall>(digits :: string). (sint base < (0 :: int) \<longrightarrow> digits = ''0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'') \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> digits = ''0123456789abcdefghijklmnopqrstuvwxyz'') \<and> ((36 :: int) < sint base \<longrightarrow> digits = ''0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'') \<and> effective (sint base) \<le> int (length digits) \<longrightarrow> (if sint base \<le> (0 :: int) then int'32_in_bounds (-sint base) \<and> (\<forall>(o1 :: 32 word). sint o1 = -sint base \<longrightarrow> (if sint o1 \<le> (1 :: int) then sint (10 :: 32 word) = effective (sint base) else sint o1 = effective (sint base))) else if sint base \<le> (1 :: int) then sint (10 :: 32 word) = effective (sint base) else sint base = effective (sint base)) \<and> (\<forall>(base1 :: 32 word). sint base1 = effective (sint base) \<longrightarrow> -(2 :: int) < readers mpz u \<and> (\<forall>(un :: 32 word). sint un = abs_size mpz u \<longrightarrow> (\<forall>(o1 :: bool). (sint un = sint (0 :: 32 word) \<longrightarrow> o1 = True) \<and> (o1 = True \<longrightarrow> un = (0 :: 32 word)) \<longrightarrow> (if o1 = True then let o2 :: char = ''0'' ! (0 :: nat) in ((c_C.min sp \<le> offset sp + (0 :: int) \<and> offset sp + (0 :: int) < c_C.max sp) \<and> writable sp = True) \<and> (\<forall>(sp1 :: char ptr). length (data sp1) = length (data sp) \<and> offset sp1 = offset sp \<and> c_C.min sp1 = c_C.min sp \<and> c_C.max sp1 = c_C.max sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> pelts sp1 = (pelts sp)(offset sp1 + (0 :: int) := o2) \<and> pelts sp1 (offset sp1 + (0 :: int)) = o2 \<longrightarrow> (let o3 :: char = zero_char in ((c_C.min sp1 \<le> offset sp1 + (1 :: int) \<and> offset sp1 + (1 :: int) < c_C.max sp1) \<and> writable sp1 = True) \<and> (\<forall>(sp2 :: char ptr). length (data sp2) = length (data sp1) \<and> offset sp2 = offset sp1 \<and> c_C.min sp2 = c_C.min sp1 \<and> c_C.max sp2 = c_C.max sp1 \<and> writable sp2 = writable sp1 \<and> zone1 sp2 = zone1 sp1 \<longrightarrow> pelts sp2 = (pelts sp1)(offset sp2 + (1 :: int) := o3) \<and> pelts sp2 (offset sp2 + (1 :: int)) = o3 \<longrightarrow> valid_string sp2 \<and> stringlemmas_String_value.string_in_base (effective (sint base)) (pelts sp2) (offset sp2) \<and> (\<forall>(x :: mpz_ptr). mpz_unchanged x mpz mpz) \<and> value_text (effective (sint base)) (pelts sp2) (offset sp2) = value_of u mpz))) else -(2 :: int) < readers mpz u \<and> (\<forall>(o2 :: 32 word). sint o2 = sgn mpz u * abs_size mpz u \<longrightarrow> (if sint o2 < (0 :: int) then let o3 :: char = ''-'' ! (0 :: nat) in ((c_C.min sp \<le> offset sp + (0 :: int) \<and> offset sp + (0 :: int) < c_C.max sp) \<and> writable sp = True) \<and> (\<forall>(sp1 :: char ptr). length (data sp1) = length (data sp) \<and> offset sp1 = offset sp \<and> c_C.min sp1 = c_C.min sp \<and> c_C.max sp1 = c_C.max sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> pelts sp1 = (pelts sp)(offset sp1 + (0 :: int) := o3) \<and> pelts sp1 (offset sp1 + (0 :: int)) = o3 \<longrightarrow> int'32_in_bounds ((0 :: int) + (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = (0 :: int) + (1 :: int) \<longrightarrow> (0 :: int) \<le> sint base1 \<and> (\<forall>(o5 :: 64 word). uint o5 = sint base1 \<longrightarrow> ((2 :: int) \<le> uint o5 \<and> uint o5 \<le> (256 :: int)) \<and> (\<forall>(bits :: 32 word). ((0 :: int) \<le> uint bits \<and> uint bits \<le> (8 :: int)) \<and> (\<not>uint bits = (0 :: int) \<longrightarrow> (2 :: int) ^\<^sub>i uint bits = uint o5) \<and> (uint bits = (0 :: int) \<longrightarrow> (\<forall>(n :: int). (0 :: int) \<le> n \<longrightarrow> \<not>(2 :: int) ^\<^sub>i n = uint o5)) \<longrightarrow> (0 :: int) \<le> readers mpz u \<and> (\<forall>(mpz1 :: mpz_memo). abs_value_of mpz1 = abs_value_of mpz \<and> alloc mpz1 = alloc mpz \<and> abs_size mpz1 = abs_size mpz \<and> sgn mpz1 = sgn mpz \<and> zones mpz1 = zones mpz \<longrightarrow> (\<forall>(up :: 64 word ptr). readers mpz1 u = readers mpz u + (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>u = y \<longrightarrow> readers mpz1 y = readers mpz y) \<and> value up (abs_size mpz1 u) = abs_value_of mpz1 u \<and> plength up = alloc mpz1 u \<and> offset up = (0 :: int) \<and> c_C.min up = (0 :: int) \<and> c_C.max up = plength up \<and> zone1 up = zones mpz1 u \<longrightarrow> writable sp1 = True \<and> (\<forall>(sp2 :: char ptr). offset sp2 = offset sp1 \<and> writable sp2 = writable sp1 \<and> zone1 sp2 = zone1 sp1 \<longrightarrow> (\<forall>(usp :: 8 word ptr) (mem :: cast_mem). (c_C.min usp = c_C.min sp1 \<and> c_C.min sp1 = mi mem) \<and> (c_C.max usp = c_C.max sp1 \<and> c_C.max sp1 = ma mem) \<and> zone1 sp1 = z mem \<and> (plength usp = plength sp1 \<and> plength sp1 = l mem) \<and> c_UChar.ok mem = True \<and> offset usp = offset sp1 \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < plength sp1 \<longrightarrow> pelts usp i = uchar_of_char (pelts sp1 i)) \<and> writable usp = True \<longrightarrow> (c_C.min usp \<le> offset usp + sint o4 \<and> offset usp + sint o4 \<le> c_C.max usp) \<and> (\<forall>(uspi :: 8 word ptr). offset uspi = offset usp + sint o4 \<and> plength uspi = plength usp \<and> pelts uspi = pelts usp \<and> data uspi = data usp \<and> c_C.min uspi = c_C.min usp \<and> c_C.max uspi = c_C.max usp \<and> zone1 uspi = zone1 usp \<and> writable uspi = writable usp \<longrightarrow> (uint bits = (0 :: int) \<longrightarrow> bits = (0 :: 32 word)) \<longrightarrow> (if \<not>bits = (0 :: 32 word) then int'32_in_bounds (sint un - (1 :: int)) \<and> (\<forall>(o6 :: 32 word). sint o6 = sint un - (1 :: int) \<longrightarrow> (c_C.min up \<le> offset up + sint o6 \<and> offset up + sint o6 < c_C.max up) \<and> (let um :: 64 word = pelts up (offset up + sint o6) in (0 :: int) < uint um \<and> (\<forall>(sb :: 64 word). ((1 :: int) \<le> uint sb \<and> uint sb \<le> (64 :: int)) \<and> (2 :: int) ^\<^sub>i (uint sb - (1 :: int)) \<le> uint um \<and> uint um < (2 :: int) ^\<^sub>i uint sb \<longrightarrow> uint sb \<le> (2147483647 :: int) \<and> (\<forall>(o7 :: 32 word). sint o7 = uint sb \<longrightarrow> int'32_in_bounds (sint un - (1 :: int)) \<and> (\<forall>(o8 :: 32 word). sint o8 = sint un - (1 :: int) \<longrightarrow> int'32_in_bounds ((64 :: int) * sint o8) \<and> (\<forall>(o9 :: 32 word). sint o9 = (64 :: int) * sint o8 \<longrightarrow> int'32_in_bounds (sint o9 + sint o7) \<and> (\<forall>(ub :: 32 word). sint ub = sint o9 + sint o7 \<longrightarrow> ((1 :: int) \<le> sint un \<and> valid up (sint un) \<and> ((1 :: int) \<le> uint bits \<and> uint bits \<le> (8 :: int)) \<and> valid uspi ((sint ub + uint bits - (1 :: int)) ediv uint bits) \<and> (0 :: int) \<le> sint ub \<and> value up (sint un) < (2 :: int) ^\<^sub>i sint ub \<and> (0 :: int) < uint (pelts up (offset up + sint un - (1 :: int))) \<and> (64 :: int) * sint un + (7 :: int) \<le> (2147483647 :: int) \<and> writable uspi = True) \<and> (\<forall>(uspi1 :: 8 word ptr) (usp1 :: 8 word ptr). data uspi1 = data usp1 \<and> length (data usp1) = length (data uspi) \<and> offset uspi1 = offset uspi \<and> c_C.min uspi1 = c_C.min uspi \<and> c_C.max uspi1 = c_C.max uspi \<and> writable uspi1 = writable uspi \<and> zone1 uspi1 = zone1 uspi \<longrightarrow> length (data usp1) = length (data usp) \<and> offset usp1 = offset usp \<and> c_C.min usp1 = c_C.min usp \<and> c_C.max usp1 = c_C.max usp \<and> writable usp1 = writable usp \<and> zone1 usp1 = zone1 usp \<longrightarrow> (\<forall>(g :: 32 word). in_base ((2 :: int) ^\<^sub>i uint bits) (pelts uspi1) (offset uspi1) (offset uspi1 + uint g) \<and> svalue ((2 :: int) ^\<^sub>i uint bits) uspi1 (uint g) = value up (sint un) \<and> ((0 :: int) < uint g \<and> uint g \<le> (sint ub + uint bits - (1 :: int)) ediv uint bits) \<and> (0 :: int) < uint (pelts uspi1 (offset uspi1)) \<and> (\<forall>(j :: int). j < offset uspi1 \<or> offset uspi1 + (sint ub + uint bits - (1 :: int)) ediv uint bits \<le> j \<longrightarrow> pelts uspi1 j = pelts uspi j) \<longrightarrow> uint g \<le> (2147483647 :: int) \<and> (\<forall>(o10 :: 32 word). sint o10 = uint g \<longrightarrow> int'32_in_bounds (sint o4 + sint o10) \<and> (\<forall>(o11 :: 32 word). sint o11 = sint o4 + sint o10 \<longrightarrow> (c_UChar.ok mem = True \<and> z mem = zone1 sp2 \<and> mi mem = c_C.min usp1 \<and> ma mem = c_C.max usp1 \<and> offset sp2 = offset usp1 \<and> plength usp1 = l mem) \<and> (\<forall>(mem1 :: cast_mem) (sp3 :: char ptr). mi mem1 = mi mem \<and> ma mem1 = ma mem \<and> z mem1 = z mem \<and> l mem1 = l mem \<longrightarrow> offset sp3 = offset sp2 \<and> writable sp3 = writable sp2 \<and> zone1 sp3 = zone1 sp2 \<longrightarrow> (c_C.min sp3 = mi mem1 \<and> c_C.max sp3 = ma mem1) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < plength sp3 \<longrightarrow> pelts sp3 i = char_of_uchar (pelts usp1 i)) \<and> plength sp3 = plength usp1 \<longrightarrow> int'32_in_bounds (sint o11 - (1 :: int)) \<and> (\<forall>(o12 :: 32 word). sint o12 = sint o11 - (1 :: int) \<longrightarrow> (sint o4 \<le> sint o12 + (1 :: int) \<longrightarrow> ((sint o4 \<le> sint o4 \<and> sint o4 \<le> sint o11) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + sint o4)) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + sint o4)) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + sint o4)) \<and> abs_value_sub_text (sint base1) (pelts sp3) (offset sp3 + sint o4) (offset sp3 + sint o4) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + sint o4) (offset usp1 + sint o4) \<and> (\<forall>(k :: int). offset sp3 \<le> k \<and> k < offset sp3 + sint o4 \<longrightarrow> \<not>of_char (pelts sp3 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp3) (offset sp3 + sint o4) (offset sp3 + sint o4) \<and> (sint o4 = (1 :: int) \<longrightarrow> pelts sp3 (offset sp3) = ''-'' ! (0 :: nat)) \<and> (sint o4 = (0 :: int) \<longrightarrow> sint o4 < sint o4 \<longrightarrow> \<not>pelts sp3 (offset sp3) = ''-'' ! (0 :: nat))) \<and> (\<forall>(sp4 :: char ptr). length (data sp4) = length (data sp3) \<and> offset sp4 = offset sp3 \<and> c_C.min sp4 = c_C.min sp3 \<and> c_C.max sp4 = c_C.max sp3 \<and> writable sp4 = writable sp3 \<and> zone1 sp4 = zone1 sp3 \<longrightarrow> (\<forall>(j :: 32 word). let j1 :: int = sint j in (sint o4 \<le> j1 \<and> j1 \<le> sint o12) \<and> (sint o4 \<le> j1 \<and> j1 \<le> sint o11) \<and> (\<forall>(k :: int). offset sp4 + j1 \<le> offset sp4 + k \<and> offset sp4 + k < offset sp4 + sint o11 \<longrightarrow> pelts sp4 (offset sp4 + k) = pelts sp3 (offset sp4 + k)) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + j1)) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + j1)) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + j1)) \<and> abs_value_sub_text (sint base1) (pelts sp4) (offset sp4 + sint o4) (offset sp4 + j1) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + sint o4) (offset usp1 + j1) \<and> (\<forall>(k :: int). offset sp4 \<le> k \<and> k < offset sp4 + j1 \<longrightarrow> \<not>of_char (pelts sp4 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp4) (offset sp4 + sint o4) (offset sp4 + j1) \<and> (sint o4 = (1 :: int) \<longrightarrow> pelts sp4 (offset sp4) = ''-'' ! (0 :: nat)) \<and> (sint o4 = (0 :: int) \<longrightarrow> sint o4 < j1 \<longrightarrow> \<not>pelts sp4 (offset sp4) = ''-'' ! (0 :: nat)) \<longrightarrow> (c_C.min sp4 \<le> offset sp4 + sint j \<and> offset sp4 + sint j < c_C.max sp4) \<and> (let o13 :: char = pelts sp4 (offset sp4 + sint j); cj :: 8 word = uchar_of_char o13 in ((0 :: int) \<le> of_char o13 \<and> of_char o13 \<le> (127 :: int) \<longrightarrow> uint cj = of_char o13) \<longrightarrow> (\<forall>(o14 :: 32 word). sint o14 = uint cj \<longrightarrow> ((0 :: int) \<le> sint o14 \<and> sint o14 \<le> int (length digits)) \<and> (\<forall>(dc :: char). ((0 :: int) \<le> sint o14 \<and> sint o14 < int (length digits) \<longrightarrow> dc = digits ! nat (sint o14)) \<and> (sint o14 = int (length digits) \<longrightarrow> dc = char_of (0 :: int)) \<longrightarrow> ((c_C.min sp4 \<le> offset sp4 + sint j \<and> offset sp4 + sint j < c_C.max sp4) \<and> writable sp4 = True) \<and> (\<forall>(sp5 :: char ptr). length (data sp5) = length (data sp4) \<and> offset sp5 = offset sp4 \<and> c_C.min sp5 = c_C.min sp4 \<and> c_C.max sp5 = c_C.max sp4 \<and> writable sp5 = writable sp4 \<and> zone1 sp5 = zone1 sp4 \<longrightarrow> pelts sp5 = (pelts sp4)(offset sp5 + sint j := dc) \<and> pelts sp5 (offset sp5 + sint j) = dc \<longrightarrow> (sint o4 \<le> j1 + (1 :: int) \<and> j1 + (1 :: int) \<le> sint o11) \<and> (\<forall>(k :: int). offset sp5 + (j1 + (1 :: int)) \<le> offset sp5 + k \<and> offset sp5 + k < offset sp5 + sint o11 \<longrightarrow> pelts sp5 (offset sp5 + k) = pelts sp3 (offset sp5 + k)) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp5) (offset sp5) (offset sp5 + (j1 + (1 :: int)))) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp5) (offset sp5) (offset sp5 + (j1 + (1 :: int)))) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp5) (offset sp5) (offset sp5 + (j1 + (1 :: int)))) \<and> abs_value_sub_text (sint base1) (pelts sp5) (offset sp5 + sint o4) (offset sp5 + (j1 + (1 :: int))) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + sint o4) (offset usp1 + (j1 + (1 :: int))) \<and> (\<forall>(k :: int). offset sp5 \<le> k \<and> k < offset sp5 + (j1 + (1 :: int)) \<longrightarrow> \<not>of_char (pelts sp5 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp5) (offset sp5 + sint o4) (offset sp5 + (j1 + (1 :: int))) \<and> (sint o4 = (1 :: int) \<longrightarrow> pelts sp5 (offset sp5) = ''-'' ! (0 :: nat)) \<and> (sint o4 = (0 :: int) \<longrightarrow> sint o4 < j1 + (1 :: int) \<longrightarrow> \<not>pelts sp5 (offset sp5) = ''-'' ! (0 :: nat))))))) \<and> ((sint o4 \<le> sint o12 + (1 :: int) \<and> sint o12 + (1 :: int) \<le> sint o11) \<and> (\<forall>(k :: int). offset sp4 + (sint o12 + (1 :: int)) \<le> offset sp4 + k \<and> offset sp4 + k < offset sp4 + sint o11 \<longrightarrow> pelts sp4 (offset sp4 + k) = pelts sp3 (offset sp4 + k)) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (sint o12 + (1 :: int)))) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (sint o12 + (1 :: int)))) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (sint o12 + (1 :: int)))) \<and> abs_value_sub_text (sint base1) (pelts sp4) (offset sp4 + sint o4) (offset sp4 + (sint o12 + (1 :: int))) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + sint o4) (offset usp1 + (sint o12 + (1 :: int))) \<and> (\<forall>(k :: int). offset sp4 \<le> k \<and> k < offset sp4 + (sint o12 + (1 :: int)) \<longrightarrow> \<not>of_char (pelts sp4 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp4) (offset sp4 + sint o4) (offset sp4 + (sint o12 + (1 :: int))) \<and> (sint o4 = (1 :: int) \<longrightarrow> pelts sp4 (offset sp4) = ''-'' ! (0 :: nat)) \<and> (sint o4 = (0 :: int) \<longrightarrow> sint o4 < sint o12 + (1 :: int) \<longrightarrow> \<not>pelts sp4 (offset sp4) = ''-'' ! (0 :: nat)) \<longrightarrow> (let o13 :: char = zero_char in ((c_C.min sp4 \<le> offset sp4 + sint o11 \<and> offset sp4 + sint o11 < c_C.max sp4) \<and> writable sp4 = True) \<and> (\<forall>(sp5 :: char ptr). length (data sp5) = length (data sp4) \<and> offset sp5 = offset sp4 \<and> c_C.min sp5 = c_C.min sp4 \<and> c_C.max sp5 = c_C.max sp4 \<and> writable sp5 = writable sp4 \<and> zone1 sp5 = zone1 sp4 \<longrightarrow> pelts sp5 = (pelts sp4)(offset sp5 + sint o11 := o13) \<and> pelts sp5 (offset sp5 + sint o11) = o13 \<longrightarrow> (zones mpz1 u = zone1 up \<and> (1 :: int) \<le> readers mpz1 u \<and> c_C.min up = (0 :: int) \<and> c_C.max up = plength up) \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> readers mpz2 u = readers mpz1 u - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = u \<longrightarrow> readers mpz2 y = readers mpz1 y) \<longrightarrow> valid_string sp5 \<and> stringlemmas_String_value.string_in_base (effective (sint base)) (pelts sp5) (offset sp5) \<and> (\<forall>(x :: mpz_ptr). mpz_unchanged x mpz2 mpz) \<and> value_text (effective (sint base)) (pelts sp5) (offset sp5) = value_of u mpz2)))))) \<and> (sint o12 + (1 :: int) < sint o4 \<longrightarrow> (let o13 :: char = zero_char in ((c_C.min sp3 \<le> offset sp3 + sint o11 \<and> offset sp3 + sint o11 < c_C.max sp3) \<and> writable sp3 = True) \<and> (\<forall>(sp4 :: char ptr). length (data sp4) = length (data sp3) \<and> offset sp4 = offset sp3 \<and> c_C.min sp4 = c_C.min sp3 \<and> c_C.max sp4 = c_C.max sp3 \<and> writable sp4 = writable sp3 \<and> zone1 sp4 = zone1 sp3 \<longrightarrow> pelts sp4 = (pelts sp3)(offset sp4 + sint o11 := o13) \<and> pelts sp4 (offset sp4 + sint o11) = o13 \<longrightarrow> (zones mpz1 u = zone1 up \<and> (1 :: int) \<le> readers mpz1 u \<and> c_C.min up = (0 :: int) \<and> c_C.max up = plength up) \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> readers mpz2 u = readers mpz1 u - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = u \<longrightarrow> readers mpz2 y = readers mpz1 y) \<longrightarrow> valid_string sp4 \<and> stringlemmas_String_value.string_in_base (effective (sint base)) (pelts sp4) (offset sp4) \<and> (\<forall>(x :: mpz_ptr). mpz_unchanged x mpz2 mpz) \<and> value_text (effective (sint base)) (pelts sp4) (offset sp4) = value_of u mpz2))))))))))))))))) else (0 :: int) \<le> sint base1 \<and> (\<forall>(o6 :: 64 word). uint o6 = sint base1 \<longrightarrow> ((2 :: int) \<le> uint o6 \<and> uint o6 \<le> (256 :: int)) \<and> (\<forall>(info :: wmpn_base_info). b info = uint o6 \<longrightarrow> (0 :: int) \<le> sint un \<and> (\<forall>(o7 :: 32 word). uint o7 = sint un \<longrightarrow> (0 :: int) \<le> uint o7 \<and> (\<forall>(tp :: 64 word ptr). plength tp = uint o7 \<and> offset tp = (0 :: int) \<and> c_C.min tp = (0 :: int) \<and> c_C.max tp = uint o7 \<and> writable tp = True \<longrightarrow> (valid up (sint un) \<and> valid tp (sint un) \<and> writable tp = True) \<and> (\<forall>(tp1 :: 64 word ptr) (up1 :: 64 word ptr). offset tp1 = offset tp \<and> writable tp1 = writable tp \<and> zone1 tp1 = zone1 tp \<longrightarrow> offset up1 = offset up \<and> writable up1 = writable up \<and> zone1 up1 = zone1 up \<longrightarrow> map_eq_sub_shift (pelts tp1) (pelts up) (offset tp1) (offset up) (sint un) \<and> (\<forall>(j :: int). j < offset tp1 \<or> offset tp1 + sint un \<le> j \<longrightarrow> pelts tp1 j = pelts tp j) \<and> (\<forall>(j :: int). pelts up1 j = pelts up j) \<and> (c_C.min up1 = c_C.min up \<and> c_C.max up1 = c_C.max up \<and> plength up1 = plength up) \<and> c_C.min tp1 = c_C.min tp \<and> c_C.max tp1 = c_C.max tp \<and> plength tp1 = plength tp \<longrightarrow> int'32_in_bounds (sint sz - sint o4) \<and> (\<forall>(o8 :: 32 word). sint o8 = sint sz - sint o4 \<longrightarrow> (valid tp1 (sint un) \<and> (1 :: int) \<le> sint un \<and> b info = sint base1 \<and> writable tp1 = True \<and> writable uspi = True \<and> (0 :: int) < uint (pelts tp1 (offset tp1 + sint un - (1 :: int))) \<and> (0 :: int) < sint o8 \<and> valid uspi (sint o8) \<and> value tp1 (sint un) < sint base1 ^\<^sub>i (sint o8 - (1 :: int))) \<and> (\<forall>(uspi1 :: 8 word ptr) (usp1 :: 8 word ptr). data uspi1 = data usp1 \<and> length (data usp1) = length (data uspi) \<and> offset uspi1 = offset uspi \<and> c_C.min uspi1 = c_C.min uspi \<and> c_C.max uspi1 = c_C.max uspi \<and> writable uspi1 = writable uspi \<and> zone1 uspi1 = zone1 uspi \<longrightarrow> length (data usp1) = length (data usp) \<and> offset usp1 = offset usp \<and> c_C.min usp1 = c_C.min usp \<and> c_C.max usp1 = c_C.max usp \<and> writable usp1 = writable usp \<and> zone1 usp1 = zone1 usp \<longrightarrow> (\<forall>(g :: 32 word). ((0 :: int) \<le> uint g \<and> uint g < sint o8) \<and> svalue (sint base1) uspi1 (uint g) = value tp1 (sint un) \<and> in_base (sint base1) (pelts uspi1) (offset uspi1) (offset uspi1 + uint g) \<and> (0 :: int) < uint (pelts uspi1 (offset uspi1)) \<and> (\<forall>(j :: int). j < offset uspi1 \<or> offset uspi1 + sint o8 \<le> j \<longrightarrow> pelts uspi1 j = pelts uspi j) \<longrightarrow> uint g \<le> (2147483647 :: int) \<and> (\<forall>(o9 :: 32 word). sint o9 = uint g \<longrightarrow> int'32_in_bounds (sint o4 + sint o9) \<and> (\<forall>(o10 :: 32 word). sint o10 = sint o4 + sint o9 \<longrightarrow> (c_UChar.ok mem = True \<and> z mem = zone1 sp2 \<and> mi mem = c_C.min usp1 \<and> ma mem = c_C.max usp1 \<and> offset sp2 = offset usp1 \<and> plength usp1 = l mem) \<and> (\<forall>(mem1 :: cast_mem) (sp3 :: char ptr). mi mem1 = mi mem \<and> ma mem1 = ma mem \<and> z mem1 = z mem \<and> l mem1 = l mem \<longrightarrow> offset sp3 = offset sp2 \<and> writable sp3 = writable sp2 \<and> zone1 sp3 = zone1 sp2 \<longrightarrow> (c_C.min sp3 = mi mem1 \<and> c_C.max sp3 = ma mem1) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < plength sp3 \<longrightarrow> pelts sp3 i = char_of_uchar (pelts usp1 i)) \<and> plength sp3 = plength usp1 \<longrightarrow> int'32_in_bounds (sint o10 - (1 :: int)) \<and> (\<forall>(o11 :: 32 word). sint o11 = sint o10 - (1 :: int) \<longrightarrow> (sint o4 \<le> sint o11 + (1 :: int) \<longrightarrow> ((sint o4 \<le> sint o4 \<and> sint o4 \<le> sint o10) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + sint o4)) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + sint o4)) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + sint o4)) \<and> abs_value_sub_text (sint base1) (pelts sp3) (offset sp3 + sint o4) (offset sp3 + sint o4) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + sint o4) (offset usp1 + sint o4) \<and> (\<forall>(k :: int). offset sp3 \<le> k \<and> k < offset sp3 + sint o4 \<longrightarrow> \<not>of_char (pelts sp3 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp3) (offset sp3 + sint o4) (offset sp3 + sint o4) \<and> (sint o4 = (1 :: int) \<longrightarrow> pelts sp3 (offset sp3) = ''-'' ! (0 :: nat)) \<and> (sint o4 = (0 :: int) \<longrightarrow> sint o4 < sint o4 \<longrightarrow> \<not>pelts sp3 (offset sp3) = ''-'' ! (0 :: nat))) \<and> (\<forall>(sp4 :: char ptr). length (data sp4) = length (data sp3) \<and> offset sp4 = offset sp3 \<and> c_C.min sp4 = c_C.min sp3 \<and> c_C.max sp4 = c_C.max sp3 \<and> writable sp4 = writable sp3 \<and> zone1 sp4 = zone1 sp3 \<longrightarrow> (\<forall>(j :: 32 word). let j1 :: int = sint j in (sint o4 \<le> j1 \<and> j1 \<le> sint o11) \<and> (sint o4 \<le> j1 \<and> j1 \<le> sint o10) \<and> (\<forall>(k :: int). offset sp4 + j1 \<le> offset sp4 + k \<and> offset sp4 + k < offset sp4 + sint o10 \<longrightarrow> pelts sp4 (offset sp4 + k) = pelts sp3 (offset sp4 + k)) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + j1)) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + j1)) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + j1)) \<and> abs_value_sub_text (sint base1) (pelts sp4) (offset sp4 + sint o4) (offset sp4 + j1) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + sint o4) (offset usp1 + j1) \<and> (\<forall>(k :: int). offset sp4 \<le> k \<and> k < offset sp4 + j1 \<longrightarrow> \<not>of_char (pelts sp4 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp4) (offset sp4 + sint o4) (offset sp4 + j1) \<and> (sint o4 = (1 :: int) \<longrightarrow> pelts sp4 (offset sp4) = ''-'' ! (0 :: nat)) \<and> (sint o4 = (0 :: int) \<longrightarrow> sint o4 < j1 \<longrightarrow> \<not>pelts sp4 (offset sp4) = ''-'' ! (0 :: nat)) \<longrightarrow> (c_C.min sp4 \<le> offset sp4 + sint j \<and> offset sp4 + sint j < c_C.max sp4) \<and> (let o12 :: char = pelts sp4 (offset sp4 + sint j); cj :: 8 word = uchar_of_char o12 in ((0 :: int) \<le> of_char o12 \<and> of_char o12 \<le> (127 :: int) \<longrightarrow> uint cj = of_char o12) \<longrightarrow> (\<forall>(o13 :: 32 word). sint o13 = uint cj \<longrightarrow> ((0 :: int) \<le> sint o13 \<and> sint o13 \<le> int (length digits)) \<and> (\<forall>(dc :: char). ((0 :: int) \<le> sint o13 \<and> sint o13 < int (length digits) \<longrightarrow> dc = digits ! nat (sint o13)) \<and> (sint o13 = int (length digits) \<longrightarrow> dc = char_of (0 :: int)) \<longrightarrow> ((c_C.min sp4 \<le> offset sp4 + sint j \<and> offset sp4 + sint j < c_C.max sp4) \<and> writable sp4 = True) \<and> (\<forall>(sp5 :: char ptr). length (data sp5) = length (data sp4) \<and> offset sp5 = offset sp4 \<and> c_C.min sp5 = c_C.min sp4 \<and> c_C.max sp5 = c_C.max sp4 \<and> writable sp5 = writable sp4 \<and> zone1 sp5 = zone1 sp4 \<longrightarrow> pelts sp5 = (pelts sp4)(offset sp5 + sint j := dc) \<and> pelts sp5 (offset sp5 + sint j) = dc \<longrightarrow> (sint o4 \<le> j1 + (1 :: int) \<and> j1 + (1 :: int) \<le> sint o10) \<and> (\<forall>(k :: int). offset sp5 + (j1 + (1 :: int)) \<le> offset sp5 + k \<and> offset sp5 + k < offset sp5 + sint o10 \<longrightarrow> pelts sp5 (offset sp5 + k) = pelts sp3 (offset sp5 + k)) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp5) (offset sp5) (offset sp5 + (j1 + (1 :: int)))) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp5) (offset sp5) (offset sp5 + (j1 + (1 :: int)))) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp5) (offset sp5) (offset sp5 + (j1 + (1 :: int)))) \<and> abs_value_sub_text (sint base1) (pelts sp5) (offset sp5 + sint o4) (offset sp5 + (j1 + (1 :: int))) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + sint o4) (offset usp1 + (j1 + (1 :: int))) \<and> (\<forall>(k :: int). offset sp5 \<le> k \<and> k < offset sp5 + (j1 + (1 :: int)) \<longrightarrow> \<not>of_char (pelts sp5 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp5) (offset sp5 + sint o4) (offset sp5 + (j1 + (1 :: int))) \<and> (sint o4 = (1 :: int) \<longrightarrow> pelts sp5 (offset sp5) = ''-'' ! (0 :: nat)) \<and> (sint o4 = (0 :: int) \<longrightarrow> sint o4 < j1 + (1 :: int) \<longrightarrow> \<not>pelts sp5 (offset sp5) = ''-'' ! (0 :: nat))))))) \<and> ((sint o4 \<le> sint o11 + (1 :: int) \<and> sint o11 + (1 :: int) \<le> sint o10) \<and> (\<forall>(k :: int). offset sp4 + (sint o11 + (1 :: int)) \<le> offset sp4 + k \<and> offset sp4 + k < offset sp4 + sint o10 \<longrightarrow> pelts sp4 (offset sp4 + k) = pelts sp3 (offset sp4 + k)) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (sint o11 + (1 :: int)))) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (sint o11 + (1 :: int)))) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (sint o11 + (1 :: int)))) \<and> abs_value_sub_text (sint base1) (pelts sp4) (offset sp4 + sint o4) (offset sp4 + (sint o11 + (1 :: int))) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + sint o4) (offset usp1 + (sint o11 + (1 :: int))) \<and> (\<forall>(k :: int). offset sp4 \<le> k \<and> k < offset sp4 + (sint o11 + (1 :: int)) \<longrightarrow> \<not>of_char (pelts sp4 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp4) (offset sp4 + sint o4) (offset sp4 + (sint o11 + (1 :: int))) \<and> (sint o4 = (1 :: int) \<longrightarrow> pelts sp4 (offset sp4) = ''-'' ! (0 :: nat)) \<and> (sint o4 = (0 :: int) \<longrightarrow> sint o4 < sint o11 + (1 :: int) \<longrightarrow> \<not>pelts sp4 (offset sp4) = ''-'' ! (0 :: nat)) \<longrightarrow> (let o12 :: char = zero_char in ((c_C.min sp4 \<le> offset sp4 + sint o10 \<and> offset sp4 + sint o10 < c_C.max sp4) \<and> writable sp4 = True) \<and> (\<forall>(sp5 :: char ptr). length (data sp5) = length (data sp4) \<and> offset sp5 = offset sp4 \<and> c_C.min sp5 = c_C.min sp4 \<and> c_C.max sp5 = c_C.max sp4 \<and> writable sp5 = writable sp4 \<and> zone1 sp5 = zone1 sp4 \<longrightarrow> pelts sp5 = (pelts sp4)(offset sp5 + sint o10 := o12) \<and> pelts sp5 (offset sp5 + sint o10) = o12 \<longrightarrow> (zones mpz1 u = zone1 up1 \<and> (1 :: int) \<le> readers mpz1 u \<and> c_C.min up1 = (0 :: int) \<and> c_C.max up1 = plength up1) \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> readers mpz2 u = readers mpz1 u - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = u \<longrightarrow> readers mpz2 y = readers mpz1 y) \<longrightarrow> valid_string sp5 \<and> stringlemmas_String_value.string_in_base (effective (sint base)) (pelts sp5) (offset sp5) \<and> (\<forall>(x :: mpz_ptr). mpz_unchanged x mpz2 mpz) \<and> value_text (effective (sint base)) (pelts sp5) (offset sp5) = value_of u mpz2)))))) \<and> (sint o11 + (1 :: int) < sint o4 \<longrightarrow> (let o12 :: char = zero_char in ((c_C.min sp3 \<le> offset sp3 + sint o10 \<and> offset sp3 + sint o10 < c_C.max sp3) \<and> writable sp3 = True) \<and> (\<forall>(sp4 :: char ptr). length (data sp4) = length (data sp3) \<and> offset sp4 = offset sp3 \<and> c_C.min sp4 = c_C.min sp3 \<and> c_C.max sp4 = c_C.max sp3 \<and> writable sp4 = writable sp3 \<and> zone1 sp4 = zone1 sp3 \<longrightarrow> pelts sp4 = (pelts sp3)(offset sp4 + sint o10 := o12) \<and> pelts sp4 (offset sp4 + sint o10) = o12 \<longrightarrow> (zones mpz1 u = zone1 up1 \<and> (1 :: int) \<le> readers mpz1 u \<and> c_C.min up1 = (0 :: int) \<and> c_C.max up1 = plength up1) \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> readers mpz2 u = readers mpz1 u - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = u \<longrightarrow> readers mpz2 y = readers mpz1 y) \<longrightarrow> valid_string sp4 \<and> stringlemmas_String_value.string_in_base (effective (sint base)) (pelts sp4) (offset sp4) \<and> (\<forall>(x :: mpz_ptr). mpz_unchanged x mpz2 mpz) \<and> value_text (effective (sint base)) (pelts sp4) (offset sp4) = value_of u mpz2)))))))))))))))))))))))))) else (0 :: int) \<le> sint base1 \<and> (\<forall>(o3 :: 64 word). uint o3 = sint base1 \<longrightarrow> ((2 :: int) \<le> uint o3 \<and> uint o3 \<le> (256 :: int)) \<and> (\<forall>(bits :: 32 word). ((0 :: int) \<le> uint bits \<and> uint bits \<le> (8 :: int)) \<and> (\<not>uint bits = (0 :: int) \<longrightarrow> (2 :: int) ^\<^sub>i uint bits = uint o3) \<and> (uint bits = (0 :: int) \<longrightarrow> (\<forall>(n :: int). (0 :: int) \<le> n \<longrightarrow> \<not>(2 :: int) ^\<^sub>i n = uint o3)) \<longrightarrow> (0 :: int) \<le> readers mpz u \<and> (\<forall>(mpz1 :: mpz_memo). abs_value_of mpz1 = abs_value_of mpz \<and> alloc mpz1 = alloc mpz \<and> abs_size mpz1 = abs_size mpz \<and> sgn mpz1 = sgn mpz \<and> zones mpz1 = zones mpz \<longrightarrow> (\<forall>(up :: 64 word ptr). readers mpz1 u = readers mpz u + (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>u = y \<longrightarrow> readers mpz1 y = readers mpz y) \<and> value up (abs_size mpz1 u) = abs_value_of mpz1 u \<and> plength up = alloc mpz1 u \<and> offset up = (0 :: int) \<and> c_C.min up = (0 :: int) \<and> c_C.max up = plength up \<and> zone1 up = zones mpz1 u \<longrightarrow> writable sp = True \<and> (\<forall>(sp1 :: char ptr). offset sp1 = offset sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> (\<forall>(usp :: 8 word ptr) (mem :: cast_mem). (c_C.min usp = c_C.min sp \<and> c_C.min sp = mi mem) \<and> (c_C.max usp = c_C.max sp \<and> c_C.max sp = ma mem) \<and> zone1 sp = z mem \<and> (plength usp = plength sp \<and> plength sp = l mem) \<and> c_UChar.ok mem = True \<and> offset usp = offset sp \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < plength sp \<longrightarrow> pelts usp i = uchar_of_char (pelts sp i)) \<and> writable usp = True \<longrightarrow> (c_C.min usp \<le> offset usp + (0 :: int) \<and> offset usp + (0 :: int) \<le> c_C.max usp) \<and> (\<forall>(uspi :: 8 word ptr). offset uspi = offset usp + (0 :: int) \<and> plength uspi = plength usp \<and> pelts uspi = pelts usp \<and> data uspi = data usp \<and> c_C.min uspi = c_C.min usp \<and> c_C.max uspi = c_C.max usp \<and> zone1 uspi = zone1 usp \<and> writable uspi = writable usp \<longrightarrow> (uint bits = (0 :: int) \<longrightarrow> bits = (0 :: 32 word)) \<longrightarrow> (if \<not>bits = (0 :: 32 word) then int'32_in_bounds (sint un - (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint un - (1 :: int) \<longrightarrow> (c_C.min up \<le> offset up + sint o4 \<and> offset up + sint o4 < c_C.max up) \<and> (let um :: 64 word = pelts up (offset up + sint o4) in (0 :: int) < uint um \<and> (\<forall>(sb :: 64 word). ((1 :: int) \<le> uint sb \<and> uint sb \<le> (64 :: int)) \<and> (2 :: int) ^\<^sub>i (uint sb - (1 :: int)) \<le> uint um \<and> uint um < (2 :: int) ^\<^sub>i uint sb \<longrightarrow> uint sb \<le> (2147483647 :: int) \<and> (\<forall>(o5 :: 32 word). sint o5 = uint sb \<longrightarrow> int'32_in_bounds (sint un - (1 :: int)) \<and> (\<forall>(o6 :: 32 word). sint o6 = sint un - (1 :: int) \<longrightarrow> int'32_in_bounds ((64 :: int) * sint o6) \<and> (\<forall>(o7 :: 32 word). sint o7 = (64 :: int) * sint o6 \<longrightarrow> int'32_in_bounds (sint o7 + sint o5) \<and> (\<forall>(ub :: 32 word). sint ub = sint o7 + sint o5 \<longrightarrow> ((1 :: int) \<le> sint un \<and> valid up (sint un) \<and> ((1 :: int) \<le> uint bits \<and> uint bits \<le> (8 :: int)) \<and> valid uspi ((sint ub + uint bits - (1 :: int)) ediv uint bits) \<and> (0 :: int) \<le> sint ub \<and> value up (sint un) < (2 :: int) ^\<^sub>i sint ub \<and> (0 :: int) < uint (pelts up (offset up + sint un - (1 :: int))) \<and> (64 :: int) * sint un + (7 :: int) \<le> (2147483647 :: int) \<and> writable uspi = True) \<and> (\<forall>(uspi1 :: 8 word ptr) (usp1 :: 8 word ptr). data uspi1 = data usp1 \<and> length (data usp1) = length (data uspi) \<and> offset uspi1 = offset uspi \<and> c_C.min uspi1 = c_C.min uspi \<and> c_C.max uspi1 = c_C.max uspi \<and> writable uspi1 = writable uspi \<and> zone1 uspi1 = zone1 uspi \<longrightarrow> length (data usp1) = length (data usp) \<and> offset usp1 = offset usp \<and> c_C.min usp1 = c_C.min usp \<and> c_C.max usp1 = c_C.max usp \<and> writable usp1 = writable usp \<and> zone1 usp1 = zone1 usp \<longrightarrow> (\<forall>(g :: 32 word). in_base ((2 :: int) ^\<^sub>i uint bits) (pelts uspi1) (offset uspi1) (offset uspi1 + uint g) \<and> svalue ((2 :: int) ^\<^sub>i uint bits) uspi1 (uint g) = value up (sint un) \<and> ((0 :: int) < uint g \<and> uint g \<le> (sint ub + uint bits - (1 :: int)) ediv uint bits) \<and> (0 :: int) < uint (pelts uspi1 (offset uspi1)) \<and> (\<forall>(j :: int). j < offset uspi1 \<or> offset uspi1 + (sint ub + uint bits - (1 :: int)) ediv uint bits \<le> j \<longrightarrow> pelts uspi1 j = pelts uspi j) \<longrightarrow> uint g \<le> (2147483647 :: int) \<and> (\<forall>(o8 :: 32 word). sint o8 = uint g \<longrightarrow> int'32_in_bounds ((0 :: int) + sint o8) \<and> (\<forall>(o9 :: 32 word). sint o9 = (0 :: int) + sint o8 \<longrightarrow> (c_UChar.ok mem = True \<and> z mem = zone1 sp1 \<and> mi mem = c_C.min usp1 \<and> ma mem = c_C.max usp1 \<and> offset sp1 = offset usp1 \<and> plength usp1 = l mem) \<and> (\<forall>(mem1 :: cast_mem) (sp2 :: char ptr). mi mem1 = mi mem \<and> ma mem1 = ma mem \<and> z mem1 = z mem \<and> l mem1 = l mem \<longrightarrow> offset sp2 = offset sp1 \<and> writable sp2 = writable sp1 \<and> zone1 sp2 = zone1 sp1 \<longrightarrow> (c_C.min sp2 = mi mem1 \<and> c_C.max sp2 = ma mem1) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < plength sp2 \<longrightarrow> pelts sp2 i = char_of_uchar (pelts usp1 i)) \<and> plength sp2 = plength usp1 \<longrightarrow> int'32_in_bounds (sint o9 - (1 :: int)) \<and> (\<forall>(o10 :: 32 word). sint o10 = sint o9 - (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint o10 + (1 :: int) \<longrightarrow> (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> sint o9) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp2) (offset sp2) (offset sp2 + (0 :: int))) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp2) (offset sp2) (offset sp2 + (0 :: int))) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp2) (offset sp2) (offset sp2 + (0 :: int))) \<and> abs_value_sub_text (sint base1) (pelts sp2) (offset sp2 + (0 :: int)) (offset sp2 + (0 :: int)) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + (0 :: int)) (offset usp1 + (0 :: int)) \<and> (\<forall>(k :: int). offset sp2 \<le> k \<and> k < offset sp2 + (0 :: int) \<longrightarrow> \<not>of_char (pelts sp2 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp2) (offset sp2 + (0 :: int)) (offset sp2 + (0 :: int)) \<and> ((0 :: int) = (1 :: int) \<longrightarrow> pelts sp2 (offset sp2) = ''-'' ! (0 :: nat)) \<and> ((0 :: int) < (0 :: int) \<longrightarrow> \<not>pelts sp2 (offset sp2) = ''-'' ! (0 :: nat))) \<and> (\<forall>(sp3 :: char ptr). length (data sp3) = length (data sp2) \<and> offset sp3 = offset sp2 \<and> c_C.min sp3 = c_C.min sp2 \<and> c_C.max sp3 = c_C.max sp2 \<and> writable sp3 = writable sp2 \<and> zone1 sp3 = zone1 sp2 \<longrightarrow> (\<forall>(j :: 32 word). let j1 :: int = sint j in ((0 :: int) \<le> j1 \<and> j1 \<le> sint o10) \<and> ((0 :: int) \<le> j1 \<and> j1 \<le> sint o9) \<and> (\<forall>(k :: int). offset sp3 + j1 \<le> offset sp3 + k \<and> offset sp3 + k < offset sp3 + sint o9 \<longrightarrow> pelts sp3 (offset sp3 + k) = pelts sp2 (offset sp3 + k)) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + j1)) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + j1)) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + j1)) \<and> abs_value_sub_text (sint base1) (pelts sp3) (offset sp3 + (0 :: int)) (offset sp3 + j1) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + (0 :: int)) (offset usp1 + j1) \<and> (\<forall>(k :: int). offset sp3 \<le> k \<and> k < offset sp3 + j1 \<longrightarrow> \<not>of_char (pelts sp3 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp3) (offset sp3 + (0 :: int)) (offset sp3 + j1) \<and> ((0 :: int) = (1 :: int) \<longrightarrow> pelts sp3 (offset sp3) = ''-'' ! (0 :: nat)) \<and> ((0 :: int) < j1 \<longrightarrow> \<not>pelts sp3 (offset sp3) = ''-'' ! (0 :: nat)) \<longrightarrow> (c_C.min sp3 \<le> offset sp3 + sint j \<and> offset sp3 + sint j < c_C.max sp3) \<and> (let o11 :: char = pelts sp3 (offset sp3 + sint j); cj :: 8 word = uchar_of_char o11 in ((0 :: int) \<le> of_char o11 \<and> of_char o11 \<le> (127 :: int) \<longrightarrow> uint cj = of_char o11) \<longrightarrow> (\<forall>(o12 :: 32 word). sint o12 = uint cj \<longrightarrow> ((0 :: int) \<le> sint o12 \<and> sint o12 \<le> int (length digits)) \<and> (\<forall>(dc :: char). ((0 :: int) \<le> sint o12 \<and> sint o12 < int (length digits) \<longrightarrow> dc = digits ! nat (sint o12)) \<and> (sint o12 = int (length digits) \<longrightarrow> dc = char_of (0 :: int)) \<longrightarrow> ((c_C.min sp3 \<le> offset sp3 + sint j \<and> offset sp3 + sint j < c_C.max sp3) \<and> writable sp3 = True) \<and> (\<forall>(sp4 :: char ptr). length (data sp4) = length (data sp3) \<and> offset sp4 = offset sp3 \<and> c_C.min sp4 = c_C.min sp3 \<and> c_C.max sp4 = c_C.max sp3 \<and> writable sp4 = writable sp3 \<and> zone1 sp4 = zone1 sp3 \<longrightarrow> pelts sp4 = (pelts sp3)(offset sp4 + sint j := dc) \<and> pelts sp4 (offset sp4 + sint j) = dc \<longrightarrow> ((0 :: int) \<le> j1 + (1 :: int) \<and> j1 + (1 :: int) \<le> sint o9) \<and> (\<forall>(k :: int). offset sp4 + (j1 + (1 :: int)) \<le> offset sp4 + k \<and> offset sp4 + k < offset sp4 + sint o9 \<longrightarrow> pelts sp4 (offset sp4 + k) = pelts sp2 (offset sp4 + k)) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (j1 + (1 :: int)))) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (j1 + (1 :: int)))) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (j1 + (1 :: int)))) \<and> abs_value_sub_text (sint base1) (pelts sp4) (offset sp4 + (0 :: int)) (offset sp4 + (j1 + (1 :: int))) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + (0 :: int)) (offset usp1 + (j1 + (1 :: int))) \<and> (\<forall>(k :: int). offset sp4 \<le> k \<and> k < offset sp4 + (j1 + (1 :: int)) \<longrightarrow> \<not>of_char (pelts sp4 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp4) (offset sp4 + (0 :: int)) (offset sp4 + (j1 + (1 :: int))) \<and> ((0 :: int) = (1 :: int) \<longrightarrow> pelts sp4 (offset sp4) = ''-'' ! (0 :: nat)) \<and> ((0 :: int) < j1 + (1 :: int) \<longrightarrow> \<not>pelts sp4 (offset sp4) = ''-'' ! (0 :: nat))))))) \<and> (((0 :: int) \<le> sint o10 + (1 :: int) \<and> sint o10 + (1 :: int) \<le> sint o9) \<and> (\<forall>(k :: int). offset sp3 + (sint o10 + (1 :: int)) \<le> offset sp3 + k \<and> offset sp3 + k < offset sp3 + sint o9 \<longrightarrow> pelts sp3 (offset sp3 + k) = pelts sp2 (offset sp3 + k)) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + (sint o10 + (1 :: int)))) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + (sint o10 + (1 :: int)))) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + (sint o10 + (1 :: int)))) \<and> abs_value_sub_text (sint base1) (pelts sp3) (offset sp3 + (0 :: int)) (offset sp3 + (sint o10 + (1 :: int))) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + (0 :: int)) (offset usp1 + (sint o10 + (1 :: int))) \<and> (\<forall>(k :: int). offset sp3 \<le> k \<and> k < offset sp3 + (sint o10 + (1 :: int)) \<longrightarrow> \<not>of_char (pelts sp3 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp3) (offset sp3 + (0 :: int)) (offset sp3 + (sint o10 + (1 :: int))) \<and> ((0 :: int) = (1 :: int) \<longrightarrow> pelts sp3 (offset sp3) = ''-'' ! (0 :: nat)) \<and> ((0 :: int) < sint o10 + (1 :: int) \<longrightarrow> \<not>pelts sp3 (offset sp3) = ''-'' ! (0 :: nat)) \<longrightarrow> (let o11 :: char = zero_char in ((c_C.min sp3 \<le> offset sp3 + sint o9 \<and> offset sp3 + sint o9 < c_C.max sp3) \<and> writable sp3 = True) \<and> (\<forall>(sp4 :: char ptr). length (data sp4) = length (data sp3) \<and> offset sp4 = offset sp3 \<and> c_C.min sp4 = c_C.min sp3 \<and> c_C.max sp4 = c_C.max sp3 \<and> writable sp4 = writable sp3 \<and> zone1 sp4 = zone1 sp3 \<longrightarrow> pelts sp4 = (pelts sp3)(offset sp4 + sint o9 := o11) \<and> pelts sp4 (offset sp4 + sint o9) = o11 \<longrightarrow> (zones mpz1 u = zone1 up \<and> (1 :: int) \<le> readers mpz1 u \<and> c_C.min up = (0 :: int) \<and> c_C.max up = plength up) \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> readers mpz2 u = readers mpz1 u - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = u \<longrightarrow> readers mpz2 y = readers mpz1 y) \<longrightarrow> valid_string sp4 \<and> stringlemmas_String_value.string_in_base (effective (sint base)) (pelts sp4) (offset sp4) \<and> (\<forall>(x :: mpz_ptr). mpz_unchanged x mpz2 mpz) \<and> value_text (effective (sint base)) (pelts sp4) (offset sp4) = value_of u mpz2)))))) \<and> (sint o10 + (1 :: int) < (0 :: int) \<longrightarrow> (let o11 :: char = zero_char in ((c_C.min sp2 \<le> offset sp2 + sint o9 \<and> offset sp2 + sint o9 < c_C.max sp2) \<and> writable sp2 = True) \<and> (\<forall>(sp3 :: char ptr). length (data sp3) = length (data sp2) \<and> offset sp3 = offset sp2 \<and> c_C.min sp3 = c_C.min sp2 \<and> c_C.max sp3 = c_C.max sp2 \<and> writable sp3 = writable sp2 \<and> zone1 sp3 = zone1 sp2 \<longrightarrow> pelts sp3 = (pelts sp2)(offset sp3 + sint o9 := o11) \<and> pelts sp3 (offset sp3 + sint o9) = o11 \<longrightarrow> (zones mpz1 u = zone1 up \<and> (1 :: int) \<le> readers mpz1 u \<and> c_C.min up = (0 :: int) \<and> c_C.max up = plength up) \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> readers mpz2 u = readers mpz1 u - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = u \<longrightarrow> readers mpz2 y = readers mpz1 y) \<longrightarrow> valid_string sp3 \<and> stringlemmas_String_value.string_in_base (effective (sint base)) (pelts sp3) (offset sp3) \<and> (\<forall>(x :: mpz_ptr). mpz_unchanged x mpz2 mpz) \<and> value_text (effective (sint base)) (pelts sp3) (offset sp3) = value_of u mpz2))))))))))))))))) else (0 :: int) \<le> sint base1 \<and> (\<forall>(o4 :: 64 word). uint o4 = sint base1 \<longrightarrow> ((2 :: int) \<le> uint o4 \<and> uint o4 \<le> (256 :: int)) \<and> (\<forall>(info :: wmpn_base_info). b info = uint o4 \<longrightarrow> (0 :: int) \<le> sint un \<and> (\<forall>(o5 :: 32 word). uint o5 = sint un \<longrightarrow> (0 :: int) \<le> uint o5 \<and> (\<forall>(tp :: 64 word ptr). plength tp = uint o5 \<and> offset tp = (0 :: int) \<and> c_C.min tp = (0 :: int) \<and> c_C.max tp = uint o5 \<and> writable tp = True \<longrightarrow> (valid up (sint un) \<and> valid tp (sint un) \<and> writable tp = True) \<and> (\<forall>(tp1 :: 64 word ptr) (up1 :: 64 word ptr). offset tp1 = offset tp \<and> writable tp1 = writable tp \<and> zone1 tp1 = zone1 tp \<longrightarrow> offset up1 = offset up \<and> writable up1 = writable up \<and> zone1 up1 = zone1 up \<longrightarrow> map_eq_sub_shift (pelts tp1) (pelts up) (offset tp1) (offset up) (sint un) \<and> (\<forall>(j :: int). j < offset tp1 \<or> offset tp1 + sint un \<le> j \<longrightarrow> pelts tp1 j = pelts tp j) \<and> (\<forall>(j :: int). pelts up1 j = pelts up j) \<and> (c_C.min up1 = c_C.min up \<and> c_C.max up1 = c_C.max up \<and> plength up1 = plength up) \<and> c_C.min tp1 = c_C.min tp \<and> c_C.max tp1 = c_C.max tp \<and> plength tp1 = plength tp \<longrightarrow> int'32_in_bounds (sint sz - (0 :: int)) \<and> (\<forall>(o6 :: 32 word). sint o6 = sint sz - (0 :: int) \<longrightarrow> (valid tp1 (sint un) \<and> (1 :: int) \<le> sint un \<and> b info = sint base1 \<and> writable tp1 = True \<and> writable uspi = True \<and> (0 :: int) < uint (pelts tp1 (offset tp1 + sint un - (1 :: int))) \<and> (0 :: int) < sint o6 \<and> valid uspi (sint o6) \<and> value tp1 (sint un) < sint base1 ^\<^sub>i (sint o6 - (1 :: int))) \<and> (\<forall>(uspi1 :: 8 word ptr) (usp1 :: 8 word ptr). data uspi1 = data usp1 \<and> length (data usp1) = length (data uspi) \<and> offset uspi1 = offset uspi \<and> c_C.min uspi1 = c_C.min uspi \<and> c_C.max uspi1 = c_C.max uspi \<and> writable uspi1 = writable uspi \<and> zone1 uspi1 = zone1 uspi \<longrightarrow> length (data usp1) = length (data usp) \<and> offset usp1 = offset usp \<and> c_C.min usp1 = c_C.min usp \<and> c_C.max usp1 = c_C.max usp \<and> writable usp1 = writable usp \<and> zone1 usp1 = zone1 usp \<longrightarrow> (\<forall>(g :: 32 word). ((0 :: int) \<le> uint g \<and> uint g < sint o6) \<and> svalue (sint base1) uspi1 (uint g) = value tp1 (sint un) \<and> in_base (sint base1) (pelts uspi1) (offset uspi1) (offset uspi1 + uint g) \<and> (0 :: int) < uint (pelts uspi1 (offset uspi1)) \<and> (\<forall>(j :: int). j < offset uspi1 \<or> offset uspi1 + sint o6 \<le> j \<longrightarrow> pelts uspi1 j = pelts uspi j) \<longrightarrow> uint g \<le> (2147483647 :: int) \<and> (\<forall>(o7 :: 32 word). sint o7 = uint g \<longrightarrow> int'32_in_bounds ((0 :: int) + sint o7) \<and> (\<forall>(o8 :: 32 word). sint o8 = (0 :: int) + sint o7 \<longrightarrow> (c_UChar.ok mem = True \<and> z mem = zone1 sp1 \<and> mi mem = c_C.min usp1 \<and> ma mem = c_C.max usp1 \<and> offset sp1 = offset usp1 \<and> plength usp1 = l mem) \<and> (\<forall>(mem1 :: cast_mem) (sp2 :: char ptr). mi mem1 = mi mem \<and> ma mem1 = ma mem \<and> z mem1 = z mem \<and> l mem1 = l mem \<longrightarrow> offset sp2 = offset sp1 \<and> writable sp2 = writable sp1 \<and> zone1 sp2 = zone1 sp1 \<longrightarrow> (c_C.min sp2 = mi mem1 \<and> c_C.max sp2 = ma mem1) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < plength sp2 \<longrightarrow> pelts sp2 i = char_of_uchar (pelts usp1 i)) \<and> plength sp2 = plength usp1 \<longrightarrow> int'32_in_bounds (sint o8 - (1 :: int)) \<and> (\<forall>(o9 :: 32 word). sint o9 = sint o8 - (1 :: int) \<longrightarrow> ((0 :: int) \<le> sint o9 + (1 :: int) \<longrightarrow> (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> sint o8) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp2) (offset sp2) (offset sp2 + (0 :: int))) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp2) (offset sp2) (offset sp2 + (0 :: int))) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp2) (offset sp2) (offset sp2 + (0 :: int))) \<and> abs_value_sub_text (sint base1) (pelts sp2) (offset sp2 + (0 :: int)) (offset sp2 + (0 :: int)) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + (0 :: int)) (offset usp1 + (0 :: int)) \<and> (\<forall>(k :: int). offset sp2 \<le> k \<and> k < offset sp2 + (0 :: int) \<longrightarrow> \<not>of_char (pelts sp2 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp2) (offset sp2 + (0 :: int)) (offset sp2 + (0 :: int)) \<and> ((0 :: int) = (1 :: int) \<longrightarrow> pelts sp2 (offset sp2) = ''-'' ! (0 :: nat)) \<and> ((0 :: int) < (0 :: int) \<longrightarrow> \<not>pelts sp2 (offset sp2) = ''-'' ! (0 :: nat))) \<and> (\<forall>(sp3 :: char ptr). length (data sp3) = length (data sp2) \<and> offset sp3 = offset sp2 \<and> c_C.min sp3 = c_C.min sp2 \<and> c_C.max sp3 = c_C.max sp2 \<and> writable sp3 = writable sp2 \<and> zone1 sp3 = zone1 sp2 \<longrightarrow> (\<forall>(j :: 32 word). let j1 :: int = sint j in ((0 :: int) \<le> j1 \<and> j1 \<le> sint o9) \<and> ((0 :: int) \<le> j1 \<and> j1 \<le> sint o8) \<and> (\<forall>(k :: int). offset sp3 + j1 \<le> offset sp3 + k \<and> offset sp3 + k < offset sp3 + sint o8 \<longrightarrow> pelts sp3 (offset sp3 + k) = pelts sp2 (offset sp3 + k)) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + j1)) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + j1)) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + j1)) \<and> abs_value_sub_text (sint base1) (pelts sp3) (offset sp3 + (0 :: int)) (offset sp3 + j1) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + (0 :: int)) (offset usp1 + j1) \<and> (\<forall>(k :: int). offset sp3 \<le> k \<and> k < offset sp3 + j1 \<longrightarrow> \<not>of_char (pelts sp3 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp3) (offset sp3 + (0 :: int)) (offset sp3 + j1) \<and> ((0 :: int) = (1 :: int) \<longrightarrow> pelts sp3 (offset sp3) = ''-'' ! (0 :: nat)) \<and> ((0 :: int) < j1 \<longrightarrow> \<not>pelts sp3 (offset sp3) = ''-'' ! (0 :: nat)) \<longrightarrow> (c_C.min sp3 \<le> offset sp3 + sint j \<and> offset sp3 + sint j < c_C.max sp3) \<and> (let o10 :: char = pelts sp3 (offset sp3 + sint j); cj :: 8 word = uchar_of_char o10 in ((0 :: int) \<le> of_char o10 \<and> of_char o10 \<le> (127 :: int) \<longrightarrow> uint cj = of_char o10) \<longrightarrow> (\<forall>(o11 :: 32 word). sint o11 = uint cj \<longrightarrow> ((0 :: int) \<le> sint o11 \<and> sint o11 \<le> int (length digits)) \<and> (\<forall>(dc :: char). ((0 :: int) \<le> sint o11 \<and> sint o11 < int (length digits) \<longrightarrow> dc = digits ! nat (sint o11)) \<and> (sint o11 = int (length digits) \<longrightarrow> dc = char_of (0 :: int)) \<longrightarrow> ((c_C.min sp3 \<le> offset sp3 + sint j \<and> offset sp3 + sint j < c_C.max sp3) \<and> writable sp3 = True) \<and> (\<forall>(sp4 :: char ptr). length (data sp4) = length (data sp3) \<and> offset sp4 = offset sp3 \<and> c_C.min sp4 = c_C.min sp3 \<and> c_C.max sp4 = c_C.max sp3 \<and> writable sp4 = writable sp3 \<and> zone1 sp4 = zone1 sp3 \<longrightarrow> pelts sp4 = (pelts sp3)(offset sp4 + sint j := dc) \<and> pelts sp4 (offset sp4 + sint j) = dc \<longrightarrow> ((0 :: int) \<le> j1 + (1 :: int) \<and> j1 + (1 :: int) \<le> sint o8) \<and> (\<forall>(k :: int). offset sp4 + (j1 + (1 :: int)) \<le> offset sp4 + k \<and> offset sp4 + k < offset sp4 + sint o8 \<longrightarrow> pelts sp4 (offset sp4 + k) = pelts sp2 (offset sp4 + k)) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (j1 + (1 :: int)))) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (j1 + (1 :: int)))) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp4) (offset sp4) (offset sp4 + (j1 + (1 :: int)))) \<and> abs_value_sub_text (sint base1) (pelts sp4) (offset sp4 + (0 :: int)) (offset sp4 + (j1 + (1 :: int))) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + (0 :: int)) (offset usp1 + (j1 + (1 :: int))) \<and> (\<forall>(k :: int). offset sp4 \<le> k \<and> k < offset sp4 + (j1 + (1 :: int)) \<longrightarrow> \<not>of_char (pelts sp4 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp4) (offset sp4 + (0 :: int)) (offset sp4 + (j1 + (1 :: int))) \<and> ((0 :: int) = (1 :: int) \<longrightarrow> pelts sp4 (offset sp4) = ''-'' ! (0 :: nat)) \<and> ((0 :: int) < j1 + (1 :: int) \<longrightarrow> \<not>pelts sp4 (offset sp4) = ''-'' ! (0 :: nat))))))) \<and> (((0 :: int) \<le> sint o9 + (1 :: int) \<and> sint o9 + (1 :: int) \<le> sint o8) \<and> (\<forall>(k :: int). offset sp3 + (sint o9 + (1 :: int)) \<le> offset sp3 + k \<and> offset sp3 + k < offset sp3 + sint o8 \<longrightarrow> pelts sp3 (offset sp3 + k) = pelts sp2 (offset sp3 + k)) \<and> ((0 :: int) \<le> sint base \<and> sint base \<le> (36 :: int) \<longrightarrow> to_lowercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + (sint o9 + (1 :: int)))) \<and> ((36 :: int) < sint base \<longrightarrow> to_bothcase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + (sint o9 + (1 :: int)))) \<and> (sint base < (0 :: int) \<longrightarrow> to_uppercase_text (pelts usp1) (pelts sp3) (offset sp3) (offset sp3 + (sint o9 + (1 :: int)))) \<and> abs_value_sub_text (sint base1) (pelts sp3) (offset sp3 + (0 :: int)) (offset sp3 + (sint o9 + (1 :: int))) = svalue_sub (sint base1) (pelts usp1) (offset usp1 + (0 :: int)) (offset usp1 + (sint o9 + (1 :: int))) \<and> (\<forall>(k :: int). offset sp3 \<le> k \<and> k < offset sp3 + (sint o9 + (1 :: int)) \<longrightarrow> \<not>of_char (pelts sp3 k) = (0 :: int)) \<and> text_in_base (sint base1) (pelts sp3) (offset sp3 + (0 :: int)) (offset sp3 + (sint o9 + (1 :: int))) \<and> ((0 :: int) = (1 :: int) \<longrightarrow> pelts sp3 (offset sp3) = ''-'' ! (0 :: nat)) \<and> ((0 :: int) < sint o9 + (1 :: int) \<longrightarrow> \<not>pelts sp3 (offset sp3) = ''-'' ! (0 :: nat)) \<longrightarrow> (let o10 :: char = zero_char in ((c_C.min sp3 \<le> offset sp3 + sint o8 \<and> offset sp3 + sint o8 < c_C.max sp3) \<and> writable sp3 = True) \<and> (\<forall>(sp4 :: char ptr). length (data sp4) = length (data sp3) \<and> offset sp4 = offset sp3 \<and> c_C.min sp4 = c_C.min sp3 \<and> c_C.max sp4 = c_C.max sp3 \<and> writable sp4 = writable sp3 \<and> zone1 sp4 = zone1 sp3 \<longrightarrow> pelts sp4 = (pelts sp3)(offset sp4 + sint o8 := o10) \<and> pelts sp4 (offset sp4 + sint o8) = o10 \<longrightarrow> (zones mpz1 u = zone1 up1 \<and> (1 :: int) \<le> readers mpz1 u \<and> c_C.min up1 = (0 :: int) \<and> c_C.max up1 = plength up1) \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> readers mpz2 u = readers mpz1 u - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = u \<longrightarrow> readers mpz2 y = readers mpz1 y) \<longrightarrow> valid_string sp4 \<and> stringlemmas_String_value.string_in_base (effective (sint base)) (pelts sp4) (offset sp4) \<and> (\<forall>(x :: mpz_ptr). mpz_unchanged x mpz2 mpz) \<and> value_text (effective (sint base)) (pelts sp4) (offset sp4) = value_of u mpz2)))))) \<and> (sint o9 + (1 :: int) < (0 :: int) \<longrightarrow> (let o10 :: char = zero_char in ((c_C.min sp2 \<le> offset sp2 + sint o8 \<and> offset sp2 + sint o8 < c_C.max sp2) \<and> writable sp2 = True) \<and> (\<forall>(sp3 :: char ptr). length (data sp3) = length (data sp2) \<and> offset sp3 = offset sp2 \<and> c_C.min sp3 = c_C.min sp2 \<and> c_C.max sp3 = c_C.max sp2 \<and> writable sp3 = writable sp2 \<and> zone1 sp3 = zone1 sp2 \<longrightarrow> pelts sp3 = (pelts sp2)(offset sp3 + sint o8 := o10) \<and> pelts sp3 (offset sp3 + sint o8) = o10 \<longrightarrow> (zones mpz1 u = zone1 up1 \<and> (1 :: int) \<le> readers mpz1 u \<and> c_C.min up1 = (0 :: int) \<and> c_C.max up1 = plength up1) \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> readers mpz2 u = readers mpz1 u - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = u \<longrightarrow> readers mpz2 y = readers mpz1 y) \<longrightarrow> valid_string sp3 \<and> stringlemmas_String_value.string_in_base (effective (sint base)) (pelts sp3) (offset sp3) \<and> (\<forall>(x :: mpz_ptr). mpz_unchanged x mpz2 mpz) \<and> value_text (effective (sint base)) (pelts sp3) (offset sp3) = value_of u mpz2))))))))))))))))))))))))))))))"
  sorry
end
