import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace coincidence_count_CoincidenceCount_coincidence_countqtvc
axiom mixfix_lbrb_closure :  {α : Type} -> [Inhabited α] -> List α -> ℤ -> α
axiom mixfix_lbrb_closure_def {α : Type} [Inhabited α] (y : List α) (y1 : ℤ) : mixfix_lbrb_closure y y1 = y[Int.toNat y1]!
noncomputable def setof {α : Type} [Inhabited α] (a : List α) := Finset.image (mixfix_lbrb_closure a) (Finset.Ico (0 : ℤ) (Int.ofNat (List.length a)))
noncomputable def drop {α : Type} [Inhabited α] (a : List α) (n : ℤ) := Finset.image (mixfix_lbrb_closure a) (Finset.Ico n (Int.ofNat (List.length a)))
noncomputable def increasing (a : List ℤ) := ∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length a) → a[Int.toNat i]! < a[Int.toNat j]!
noncomputable def cc (a : List ℤ) (b : List ℤ) := Int.ofNat (Finset.card (setof a ∩ setof b))
theorem coincidence_count'vc (a : List ℤ) (b : List ℤ) (fact0 : increasing a) (fact1 : increasing b) : (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length a) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ Int.ofNat (List.length b) ∧ (0 : ℤ) + Int.ofNat (Finset.card (drop a (0 : ℤ) ∩ drop b (0 : ℤ))) = cc a b ∧ (∀(c : ℤ) (j : ℤ) (i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ j ∧ j ≤ Int.ofNat (List.length b)) ∧ c + Int.ofNat (Finset.card (drop a i ∩ drop b j)) = cc a b → (∀(o1 : Bool), (if i < Int.ofNat (List.length a) then o1 = (if j < Int.ofNat (List.length b) then true else false) else o1 = false) → (if o1 = true then ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length b)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if a[Int.toNat i]! < b[Int.toNat j]! then ((0 : ℤ) ≤ Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - j ∧ Int.ofNat (List.length a) - (i + (1 : ℤ)) + Int.ofNat (List.length b) - j < Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - j) ∧ ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ j ∧ j ≤ Int.ofNat (List.length b)) ∧ c + Int.ofNat (Finset.card (drop a (i + (1 : ℤ)) ∩ drop b j)) = cc a b else ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length b)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if b[Int.toNat j]! < a[Int.toNat i]! then ((0 : ℤ) ≤ Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - j ∧ Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - (j + (1 : ℤ)) < Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - j) ∧ ((0 : ℤ) ≤ i ∧ i ≤ Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ j + (1 : ℤ) ∧ j + (1 : ℤ) ≤ Int.ofNat (List.length b)) ∧ c + Int.ofNat (Finset.card (drop a i ∩ drop b (j + (1 : ℤ)))) = cc a b else ((0 : ℤ) ≤ Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - j ∧ Int.ofNat (List.length a) - (i + (1 : ℤ)) + Int.ofNat (List.length b) - (j + (1 : ℤ)) < Int.ofNat (List.length a) - i + Int.ofNat (List.length b) - j) ∧ ((0 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ j + (1 : ℤ) ∧ j + (1 : ℤ) ≤ Int.ofNat (List.length b)) ∧ c + (1 : ℤ) + Int.ofNat (Finset.card (drop a (i + (1 : ℤ)) ∩ drop b (j + (1 : ℤ)))) = cc a b)) else c = cc a b)))
  := sorry
end coincidence_count_CoincidenceCount_coincidence_countqtvc
