import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.mpz.Z
import pearl.multiprecision.lib.lean.mpz.Zutil
open Classical
open Lean4Why3
namespace mpz_abs_Zabs_wmpz_absqtvc
theorem wmpz_abs'vc (mpz : Z.mpz_memo) (u : Z.mpz_ptr) (w : Z.mpz_ptr) (fact0 : Z.readers mpz u = (0 : ℤ)) (fact1 : Z.readers mpz w = (0 : ℤ)) (fact2 : (1 : ℤ) ≤ Z.alloc mpz w) (fact3 : (1 : ℤ) ≤ Z.alloc mpz u) : -(2 : ℤ) < Z.readers mpz u ∧ (∀(size : BitVec 32), BitVec.toInt size = Z.abs_size mpz u → Z.mpz_eq u w = (u = w) → (if ¬Z.mpz_eq u w then (Z.readers mpz w = (0 : ℤ) ∧ (1 : ℤ) ≤ Z.alloc mpz w) ∧ (∀(mpz1 : Z.mpz_memo), Z.sgn mpz1 = Z.sgn mpz → (∀(wp : C.ptr (BitVec 64)), (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz1 mpz) ∧ Z.readers mpz1 w = -(1 : ℤ) ∧ Z.abs_value_of mpz1 w = Lemmas.value wp (Z.abs_size mpz1 w) ∧ Z.zones mpz1 w = C.zone1 wp ∧ C.offset wp = (0 : ℤ) ∧ C.plength wp = Z.alloc mpz1 w ∧ C.min wp = (0 : ℤ) ∧ C.max wp = C.plength wp ∧ C.writable wp = true ∧ Z.abs_size mpz1 w = Z.abs_size mpz w ∧ Lemmas.value wp (Z.abs_size mpz w) = Z.abs_value_of mpz w ∧ (if Z.alloc mpz w < BitVec.toInt size then Z.alloc mpz1 w = BitVec.toInt size else Z.alloc mpz1 w = Z.alloc mpz w) → (0 : ℤ) ≤ Z.readers mpz1 u ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(up : C.ptr (BitVec 64)), Z.readers mpz2 u = Z.readers mpz1 u + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬u = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value up (Z.abs_size mpz2 u) = Z.abs_value_of mpz2 u ∧ C.plength up = Z.alloc mpz2 u ∧ C.offset up = (0 : ℤ) ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up ∧ C.zone1 up = Z.zones mpz2 u → (C.valid up (BitVec.toInt size) ∧ C.valid wp (BitVec.toInt size) ∧ C.writable wp = true) ∧ (∀(up1 : C.ptr (BitVec 64)) (wp1 : C.ptr (BitVec 64)), C.offset up1 = C.offset up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → Lemmas.map_eq_sub_shift (C.pelts wp1) (C.pelts up) (C.offset wp1) (C.offset up) (BitVec.toInt size) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt size ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (∀(j : ℤ), C.pelts up1 j = C.pelts up j) ∧ (C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.plength up1 = C.plength up) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp → (Z.zones mpz2 u = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz2 u ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 u = Z.readers mpz2 u - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u → Z.readers mpz3 y = Z.readers mpz2 y) → (Z.zones mpz3 w = C.zone1 wp1 ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ C.offset wp1 = (0 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ abs (BitVec.toInt size) ≤ C.plength wp1 ∧ C.plength wp1 = Z.alloc mpz3 w ∧ (¬BitVec.toInt size = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt size) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt size)))) ∧ (∀(mpz4 : Z.mpz_memo), Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.readers mpz4 = Z.readers mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz4 mpz3) ∧ (Z.sgn mpz4 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt size) ∧ (Z.sgn mpz4 w = -(1 : ℤ)) = (BitVec.toInt size < (0 : ℤ)) ∧ Z.abs_size mpz4 w = abs (BitVec.toInt size) ∧ Z.abs_value_of mpz4 w = Lemmas.value wp1 (abs (BitVec.toInt size)) → (Z.zones mpz4 w = C.zone1 wp1 ∧ Z.readers mpz4 w = -(1 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ Z.abs_value_of mpz4 w = Lemmas.value wp1 (Z.abs_size mpz4 w)) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz5 y = Z.readers mpz4 y) → (Z.readers mpz5 u = (0 : ℤ) ∧ Z.readers mpz5 w = (0 : ℤ)) ∧ Z.value_of w mpz5 = abs (Z.value_of u mpz) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz5 mpz))))))))) else Z.readers mpz w = (0 : ℤ) ∧ (∀(mpz1 : Z.mpz_memo), Z.abs_value_of mpz1 = Z.abs_value_of mpz ∧ Z.alloc mpz1 = Z.alloc mpz ∧ Z.abs_size mpz1 = Z.abs_size mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(wp : C.ptr (BitVec 64)), Z.readers mpz1 w = -(1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬w = y → Z.readers mpz1 y = Z.readers mpz y) ∧ Lemmas.value wp (Z.abs_size mpz1 w) = Z.abs_value_of mpz1 w ∧ C.plength wp = Z.alloc mpz1 w ∧ C.offset wp = (0 : ℤ) ∧ C.min wp = (0 : ℤ) ∧ C.max wp = C.plength wp ∧ C.writable wp = true ∧ C.zone1 wp = Z.zones mpz1 w → (Z.zones mpz1 w = C.zone1 wp ∧ Z.readers mpz1 w = -(1 : ℤ) ∧ C.offset wp = (0 : ℤ) ∧ C.min wp = (0 : ℤ) ∧ C.max wp = C.plength wp ∧ abs (BitVec.toInt size) ≤ C.plength wp ∧ C.plength wp = Z.alloc mpz1 w ∧ (¬BitVec.toInt size = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt size) - (1 : ℤ))) ≤ Lemmas.value wp (abs (BitVec.toInt size)))) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz2 mpz1) ∧ (Z.sgn mpz2 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt size) ∧ (Z.sgn mpz2 w = -(1 : ℤ)) = (BitVec.toInt size < (0 : ℤ)) ∧ Z.abs_size mpz2 w = abs (BitVec.toInt size) ∧ Z.abs_value_of mpz2 w = Lemmas.value wp (abs (BitVec.toInt size)) → (Z.zones mpz2 w = C.zone1 wp ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ C.min wp = (0 : ℤ) ∧ C.max wp = C.plength wp ∧ Z.abs_value_of mpz2 w = Lemmas.value wp (Z.abs_size mpz2 w)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz3 y = Z.readers mpz2 y) → (Z.readers mpz3 u = (0 : ℤ) ∧ Z.readers mpz3 w = (0 : ℤ)) ∧ Z.value_of w mpz3 = abs (Z.value_of u mpz) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz)))))))
  := sorry
end mpz_abs_Zabs_wmpz_absqtvc
