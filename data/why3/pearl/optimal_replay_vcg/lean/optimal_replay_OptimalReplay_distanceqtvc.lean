import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace optimal_replay_OptimalReplay_distanceqtvc
axiom n : ℤ
axiom n'def : (0 : ℤ) < n
axiom f : ℤ -> ℤ
axiom f'spec (k : ℤ) (fact0 : (0 : ℤ) < k) (fact1 : k < n) : (0 : ℤ) ≤ f k ∧ f k < k
inductive path : ℤ -> ℤ -> Prop where
 | path0 : path (0 : ℤ) (0 : ℤ)
 | paths (i : ℤ) (d : ℤ) (j : ℤ) : (0 : ℤ) ≤ i → i < n → path d j → f i ≤ j → j < i → path (d + (1 : ℤ)) i
noncomputable def distance (d : ℤ) (i : ℤ) := path d i ∧ (∀(d' : ℤ), path d' i → d ≤ d')
theorem distance'vc : let o1 : ℤ := n; (0 : ℤ) ≤ o1 ∧ (∀(g : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o1 → g[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length g) = o1 → ((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < Int.ofNat (List.length g)) ∧ (List.length (List.set g (0 : ℕ) (-(1 : ℤ))) = List.length g → getElem! (List.set g (0 : ℕ) (-(1 : ℤ))) ∘ Int.toNat = Function.update (getElem! g ∘ Int.toNat) (0 : ℤ) (-(1 : ℤ)) → (let o2 : ℤ := n; (0 : ℤ) ≤ o2 ∧ (∀(d : List ℤ), (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < o2 → d[Int.toNat i]! = (0 : ℤ)) ∧ Int.ofNat (List.length d) = o2 → (let o3 : ℤ := n - (1 : ℤ); (1 : ℤ) ≤ o3 + (1 : ℤ) → ((d[(0 : ℕ)]! = (0 : ℤ) ∧ (List.set g (0 : ℕ) (-(1 : ℤ)))[(0 : ℕ)]! = -(1 : ℤ) ∧ (0 : ℤ) + d[Int.toNat ((1 : ℤ) - (1 : ℤ))]! ≤ (1 : ℤ) - (1 : ℤ)) ∧ (∀(k : ℤ), (0 : ℤ) < k ∧ k < (1 : ℤ) → ((List.set g (0 : ℕ) (-(1 : ℤ)))[Int.toNat ((List.set g (0 : ℕ) (-(1 : ℤ)))[Int.toNat k]!)]! < f k ∧ f k ≤ (List.set g (0 : ℕ) (-(1 : ℤ)))[Int.toNat k]! ∧ (List.set g (0 : ℕ) (-(1 : ℤ)))[Int.toNat k]! < k) ∧ ((0 : ℤ) < d[Int.toNat k]! ∧ d[Int.toNat k]! = d[Int.toNat ((List.set g (0 : ℕ) (-(1 : ℤ)))[Int.toNat k]!)]! + (1 : ℤ)) ∧ (∀(k' : ℤ), (List.set g (0 : ℕ) (-(1 : ℤ)))[Int.toNat k]! < k' ∧ k' < k → d[Int.toNat ((List.set g (0 : ℕ) (-(1 : ℤ)))[Int.toNat k]!)]! < d[Int.toNat k']!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < (1 : ℤ) → distance (d[Int.toNat k]!) k)) ∧ (∀(count : ℤ) (d1 : List ℤ) (g1 : List ℤ), List.length d1 = List.length d → List.length g1 = List.length (List.set g (0 : ℕ) (-(1 : ℤ))) → (∀(i : ℤ), ((1 : ℤ) ≤ i ∧ i ≤ o3) ∧ (d1[(0 : ℕ)]! = (0 : ℤ) ∧ g1[(0 : ℕ)]! = -(1 : ℤ) ∧ count + d1[Int.toNat (i - (1 : ℤ))]! ≤ i - (1 : ℤ)) ∧ (∀(k : ℤ), (0 : ℤ) < k ∧ k < i → (g1[Int.toNat (g1[Int.toNat k]!)]! < f k ∧ f k ≤ g1[Int.toNat k]! ∧ g1[Int.toNat k]! < k) ∧ ((0 : ℤ) < d1[Int.toNat k]! ∧ d1[Int.toNat k]! = d1[Int.toNat (g1[Int.toNat k]!)]! + (1 : ℤ)) ∧ (∀(k' : ℤ), g1[Int.toNat k]! < k' ∧ k' < k → d1[Int.toNat (g1[Int.toNat k]!)]! < d1[Int.toNat k']!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i → distance (d1[Int.toNat k]!) k) → (let o4 : ℤ := i - (1 : ℤ); (((f i ≤ o4 ∧ o4 < i) ∧ count + d1[Int.toNat o4]! ≤ i - (1 : ℤ)) ∧ (∀(k : ℤ), o4 < k ∧ k < i → d1[Int.toNat o4]! < d1[Int.toNat k]!)) ∧ (∀(j : ℤ) (count1 : ℤ), ((f i ≤ j ∧ j < i) ∧ count1 + d1[Int.toNat j]! ≤ i - (1 : ℤ)) ∧ (∀(k : ℤ), j < k ∧ k < i → d1[Int.toNat j]! < d1[Int.toNat k]!) → ((0 : ℤ) < i ∧ i < n) ∧ (let o5 : ℤ := f i; (0 : ℤ) ≤ o5 ∧ o5 < i → ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length g1)) ∧ (if o5 ≤ g1[Int.toNat j]! then ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length g1)) ∧ ((0 : ℤ) ≤ j ∧ g1[Int.toNat j]! < j) ∧ ((f i ≤ g1[Int.toNat j]! ∧ g1[Int.toNat j]! < i) ∧ count1 + (1 : ℤ) + d1[Int.toNat (g1[Int.toNat j]!)]! ≤ i - (1 : ℤ)) ∧ (∀(k : ℤ), g1[Int.toNat j]! < k ∧ k < i → d1[Int.toNat (g1[Int.toNat j]!)]! < d1[Int.toNat k]!) else ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length d1)) ∧ (let o6 : ℤ := (1 : ℤ) + d1[Int.toNat j]!; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length d1)) ∧ (List.length (List.set d1 (Int.toNat i) o6) = List.length d1 → getElem! (List.set d1 (Int.toNat i) o6) ∘ Int.toNat = Function.update (getElem! d1 ∘ Int.toNat) i o6 → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length g1)) ∧ (List.length (List.set g1 (Int.toNat i) j) = List.length g1 → getElem! (List.set g1 (Int.toNat i) j) ∘ Int.toNat = Function.update (getElem! g1 ∘ Int.toNat) i j → ((List.set d1 (Int.toNat i) o6)[(0 : ℕ)]! = (0 : ℤ) ∧ (List.set g1 (Int.toNat i) j)[(0 : ℕ)]! = -(1 : ℤ) ∧ count1 + (List.set d1 (Int.toNat i) o6)[Int.toNat (i + (1 : ℤ) - (1 : ℤ))]! ≤ i + (1 : ℤ) - (1 : ℤ)) ∧ (∀(k : ℤ), (0 : ℤ) < k ∧ k < i + (1 : ℤ) → ((List.set g1 (Int.toNat i) j)[Int.toNat ((List.set g1 (Int.toNat i) j)[Int.toNat k]!)]! < f k ∧ f k ≤ (List.set g1 (Int.toNat i) j)[Int.toNat k]! ∧ (List.set g1 (Int.toNat i) j)[Int.toNat k]! < k) ∧ ((0 : ℤ) < (List.set d1 (Int.toNat i) o6)[Int.toNat k]! ∧ (List.set d1 (Int.toNat i) o6)[Int.toNat k]! = (List.set d1 (Int.toNat i) o6)[Int.toNat ((List.set g1 (Int.toNat i) j)[Int.toNat k]!)]! + (1 : ℤ)) ∧ (∀(k' : ℤ), (List.set g1 (Int.toNat i) j)[Int.toNat k]! < k' ∧ k' < k → (List.set d1 (Int.toNat i) o6)[Int.toNat ((List.set g1 (Int.toNat i) j)[Int.toNat k]!)]! < (List.set d1 (Int.toNat i) o6)[Int.toNat k']!)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i + (1 : ℤ) → distance ((List.set d1 (Int.toNat i) o6)[Int.toNat k]!) k)))))))))))))))
  := sorry
end optimal_replay_OptimalReplay_distanceqtvc
