theory mpz_Zutil_wmpz_reallocqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "../../lib/isabelle/mpz_Z" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas"
begin
typedecl  mpz_mem
consts ptr :: "mpz_mem \<Rightarrow> mpz_ptr"
consts ok :: "mpz_mem \<Rightarrow> bool"
theorem wmpz_realloc'vc:
  fixes mpz :: "mpz_memo"
  fixes x :: "mpz_ptr"
  fixes sz :: "32 word"
  assumes fact0: "readers mpz x = (0 :: int)"
  assumes fact1: "(1 :: int) \<le> alloc mpz x"
  shows "-(2 :: int) < readers mpz x"
  and "\<forall>(o1 :: 32 word). sint o1 = alloc mpz x \<longrightarrow> (if sint o1 < sint sz then ((1 :: int) \<le> sint sz \<and> readers mpz x = (0 :: int) \<and> (1 :: int) \<le> alloc mpz x) \<and> (\<forall>(mpz1 :: mpz_memo). sgn mpz1 = sgn mpz \<longrightarrow> (\<forall>(result :: 64 word ptr). (\<forall>(y :: mpz_ptr). \<not>y = x \<longrightarrow> mpz_unchanged y mpz1 mpz) \<and> readers mpz1 x = -(1 :: int) \<and> alloc mpz1 x = sint sz \<and> abs_value_of mpz1 x = value result (abs_size mpz1 x) \<and> zones mpz1 x = zone1 result \<and> offset result = (0 :: int) \<and> plength result = sint sz \<and> c_C.min result = (0 :: int) \<and> c_C.max result = sint sz \<and> writable result = True \<and> (if abs_size mpz x \<le> sint sz then abs_size mpz1 x = abs_size mpz x \<and> value result (abs_size mpz x) = abs_value_of mpz x else abs_size mpz1 x = (0 :: int)) \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = x \<longrightarrow> mpz_unchanged y mpz1 mpz) \<and> readers mpz1 x = -(1 :: int) \<and> abs_value_of mpz1 x = value result (abs_size mpz1 x) \<and> zones mpz1 x = zone1 result \<and> offset result = (0 :: int) \<and> plength result = alloc mpz1 x \<and> c_C.min result = (0 :: int) \<and> c_C.max result = plength result \<and> writable result = True \<and> abs_size mpz1 x = abs_size mpz x \<and> value result (abs_size mpz x) = abs_value_of mpz x \<and> (if alloc mpz x < sint sz then alloc mpz1 x = sint sz else alloc mpz1 x = alloc mpz x))) else readers mpz x = (0 :: int) \<and> (\<forall>(mpz1 :: mpz_memo). abs_value_of mpz1 = abs_value_of mpz \<and> alloc mpz1 = alloc mpz \<and> abs_size mpz1 = abs_size mpz \<and> sgn mpz1 = sgn mpz \<and> zones mpz1 = zones mpz \<longrightarrow> (\<forall>(result :: 64 word ptr). readers mpz1 x = -(1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>x = y \<longrightarrow> readers mpz1 y = readers mpz y) \<and> value result (abs_size mpz1 x) = abs_value_of mpz1 x \<and> plength result = alloc mpz1 x \<and> offset result = (0 :: int) \<and> c_C.min result = (0 :: int) \<and> c_C.max result = plength result \<and> writable result = True \<and> zone1 result = zones mpz1 x \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = x \<longrightarrow> mpz_unchanged y mpz1 mpz) \<and> readers mpz1 x = -(1 :: int) \<and> abs_value_of mpz1 x = value result (abs_size mpz1 x) \<and> zones mpz1 x = zone1 result \<and> offset result = (0 :: int) \<and> plength result = alloc mpz1 x \<and> c_C.min result = (0 :: int) \<and> c_C.max result = plength result \<and> writable result = True \<and> abs_size mpz1 x = abs_size mpz x \<and> value result (abs_size mpz x) = abs_value_of mpz x \<and> (if alloc mpz x < sint sz then alloc mpz1 x = sint sz else alloc mpz1 x = alloc mpz x))))"
  sorry
end
