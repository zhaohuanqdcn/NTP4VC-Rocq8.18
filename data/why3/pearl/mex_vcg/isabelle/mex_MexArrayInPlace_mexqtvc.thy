theory mex_MexArrayInPlace_mexqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_NumOf" "Why3STD.map_MapExchange"
begin
definition mem :: "int \<Rightarrow> int list \<Rightarrow> _"
  where "mem x a \<longleftrightarrow> (\<exists>(i :: int). ((0 :: int) \<le> i \<and> i < int (length a)) \<and> a ! nat i = x)" for x a
consts placed :: "int list \<Rightarrow> int \<Rightarrow> bool"
axiomatization where placed'def:   "placed a i = True \<longleftrightarrow> a ! nat i = i"
  for a :: "int list"
  and i :: "int"
theorem mex'vc:
  fixes a :: "int list"
  shows "let n :: int = int (length a) in (((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> n) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> (0 :: int) \<le> a ! nat j \<and> a ! nat j < n \<longrightarrow> a ! nat (a ! nat j) = a ! nat j)) \<and> (\<forall>(i :: int) (a1 :: int list). length a1 = length a \<longrightarrow> ((0 :: int) \<le> i \<and> i \<le> n) \<and> (\<forall>(x :: int). mem x a1 \<longleftrightarrow> mem x a) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> (0 :: int) \<le> a1 ! nat j \<and> a1 ! nat j < n \<longrightarrow> a1 ! nat (a1 ! nat j) = a1 ! nat j) \<longrightarrow> (if i < n then ((0 :: int) \<le> i \<and> i < int (length a1)) \<and> (let x :: int = a1 ! nat i in (\<not>x < (0 :: int) \<longrightarrow> \<not>n \<le> x \<longrightarrow> (0 :: int) \<le> x \<and> x < int (length a1)) \<and> (\<forall>(o1 :: bool). (if x < (0 :: int) then o1 = True else if n \<le> x then o1 = True else o1 = (if a1 ! nat x = x then True else False)) \<longrightarrow> (if o1 = True then ((0 :: int) \<le> n - i + n - numof (placed a1) (0 :: int) n \<and> n - (i + (1 :: int)) + n - numof (placed a1) (0 :: int) n < n - i + n - numof (placed a1) (0 :: int) n) \<and> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> n) \<and> (\<forall>(x1 :: int). mem x1 a1 \<longleftrightarrow> mem x1 a) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> (0 :: int) \<le> a1 ! nat j \<and> a1 ! nat j < n \<longrightarrow> a1 ! nat (a1 ! nat j) = a1 ! nat j) else if x < i then (((0 :: int) \<le> i \<and> i < int (length a1)) \<and> (0 :: int) \<le> x \<and> x < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 i x \<longrightarrow> ((0 :: int) \<le> n - i + n - numof (placed a1) (0 :: int) n \<and> n - (i + (1 :: int)) + n - numof (placed a2) (0 :: int) n < n - i + n - numof (placed a1) (0 :: int) n) \<and> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> n) \<and> (\<forall>(x1 :: int). mem x1 a2 \<longleftrightarrow> mem x1 a) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> (0 :: int) \<le> a2 ! nat j \<and> a2 ! nat j < n \<longrightarrow> a2 ! nat (a2 ! nat j) = a2 ! nat j)) else (((0 :: int) \<le> i \<and> i < int (length a1)) \<and> (0 :: int) \<le> x \<and> x < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 i x \<longrightarrow> ((0 :: int) \<le> n - i + n - numof (placed a1) (0 :: int) n \<and> n - i + n - numof (placed a2) (0 :: int) n < n - i + n - numof (placed a1) (0 :: int) n) \<and> ((0 :: int) \<le> i \<and> i \<le> n) \<and> (\<forall>(x1 :: int). mem x1 a2 \<longleftrightarrow> mem x1 a) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> (0 :: int) \<le> a2 ! nat j \<and> a2 ! nat j < n \<longrightarrow> a2 ! nat (a2 ! nat j) = a2 ! nat j))))) else let o1 :: int = n - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> a1 ! nat j = j) \<and> (\<forall>(i1 :: int). ((0 :: int) \<le> i1 \<and> i1 \<le> o1) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i1 \<longrightarrow> a1 ! nat j = j) \<longrightarrow> ((0 :: int) \<le> i1 \<and> i1 < int (length a1)) \<and> (if \<not>a1 ! nat i1 = i1 then ((0 :: int) \<le> i1 \<and> i1 \<le> int (length a1)) \<and> \<not>mem i1 a \<and> (\<forall>(x :: int). (0 :: int) \<le> x \<and> x < i1 \<longrightarrow> mem x a) else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < i1 + (1 :: int) \<longrightarrow> a1 ! nat j = j)) \<and> ((\<forall>(j :: int). (0 :: int) \<le> j \<and> j < o1 + (1 :: int) \<longrightarrow> a1 ! nat j = j) \<longrightarrow> ((0 :: int) \<le> n \<and> n \<le> int (length a1)) \<and> \<not>mem n a \<and> (\<forall>(x :: int). (0 :: int) \<le> x \<and> x < n \<longrightarrow> mem x a))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> ((0 :: int) \<le> n \<and> n \<le> int (length a1)) \<and> \<not>mem n a \<and> (\<forall>(x :: int). (0 :: int) \<le> x \<and> x < n \<longrightarrow> mem x a))))"
  sorry
end
