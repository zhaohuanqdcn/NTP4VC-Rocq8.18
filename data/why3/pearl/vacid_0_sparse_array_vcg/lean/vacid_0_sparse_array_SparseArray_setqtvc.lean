import Why3.Base
import Why3.map.MapInjection
open Classical
open Lean4Why3
namespace vacid_0_sparse_array_SparseArray_setqtvc
axiom sparse_array : Type -> Type
axiom inhabited_axiom_sparse_array {α : Type} [Inhabited α] : Inhabited (sparse_array α)
attribute [instance] inhabited_axiom_sparse_array
axiom values :  {α : Type} -> [Inhabited α] -> sparse_array α -> List α
axiom index :  {α : Type} -> [Inhabited α] -> sparse_array α -> List ℤ
axiom back :  {α : Type} -> [Inhabited α] -> sparse_array α -> List ℤ
axiom card :  {α : Type} -> [Inhabited α] -> sparse_array α -> ℤ
axiom def1 :  {α : Type} -> [Inhabited α] -> sparse_array α -> α
axiom sparse_array'invariant {α : Type} [Inhabited α] (self : sparse_array α) : (0 : ℤ) ≤ card self ∧ card self ≤ Int.ofNat (List.length (values self)) ∧ Int.ofNat (List.length (values self)) ≤ (1000 : ℤ) ∧ List.length (values self) = List.length (index self) ∧ List.length (index self) = List.length (back self) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < card self → ((0 : ℤ) ≤ (back self)[Int.toNat i]! ∧ (back self)[Int.toNat i]! < Int.ofNat (List.length (values self))) ∧ (index self)[Int.toNat ((back self)[Int.toNat i]!)]! = i)
noncomputable def sparse_array'eq {α : Type} [Inhabited α] (a : sparse_array α) (b : sparse_array α) := values a = values b ∧ index a = index b ∧ back a = back b ∧ card a = card b ∧ def1 a = def1 b
axiom sparse_array'inj {α : Type} [Inhabited α] (a : sparse_array α) (b : sparse_array α) (fact0 : sparse_array'eq a b) : a = b
noncomputable def is_elt {α : Type} [Inhabited α] (a : sparse_array α) (i : ℤ) := ((0 : ℤ) ≤ (index a)[Int.toNat i]! ∧ (index a)[Int.toNat i]! < card a) ∧ (back a)[Int.toNat ((index a)[Int.toNat i]!)]! = i
noncomputable def value {α : Type} [Inhabited α] (a : sparse_array α) (i : ℤ) := if is_elt a i then (values a)[Int.toNat i]! else def1 a
noncomputable def length {α : Type} [Inhabited α] (a : sparse_array α) := Int.ofNat (List.length (values a))
theorem set'vc {α : Type} [Inhabited α] (i : ℤ) (a : sparse_array α) (v : α) (fact0 : (0 : ℤ) ≤ i) (fact1 : i < length a) : let o1 : List α := values a; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o1)) ∧ (∀(a1 : sparse_array α), List.length (List.set o1 (Int.toNat i) v) = List.length o1 → List.length (List.set o1 (Int.toNat i) v) = List.length (values a) → getElem! (List.set o1 (Int.toNat i) v) ∘ Int.toNat = Function.update (getElem! o1 ∘ Int.toNat) i v → (((0 : ℤ) ≤ card a ∧ card a ≤ Int.ofNat (List.length (List.set o1 (Int.toNat i) v)) ∧ Int.ofNat (List.length (List.set o1 (Int.toNat i) v)) ≤ (1000 : ℤ)) ∧ (List.length (List.set o1 (Int.toNat i) v) = List.length (index a) ∧ List.length (index a) = List.length (back a)) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < card a → ((0 : ℤ) ≤ (back a)[Int.toNat i1]! ∧ (back a)[Int.toNat i1]! < Int.ofNat (List.length (List.set o1 (Int.toNat i) v))) ∧ (index a)[Int.toNat ((back a)[Int.toNat i1]!)]! = i1)) ∧ (def1 a = def1 a1 ∧ card a = card a1 ∧ back a = back a1 ∧ index a = index a1 ∧ List.set o1 (Int.toNat i) v = values a1 → ((0 : ℤ) ≤ i ∧ i < length a1) ∧ (if ¬is_elt a1 i then let o2 : ℤ := card a1; let o3 : List ℤ := index a1; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o3)) ∧ (List.length (List.set o3 (Int.toNat i) o2) = List.length o3 → List.length (List.set o3 (Int.toNat i) o2) = List.length (index a1) → getElem! (List.set o3 (Int.toNat i) o2) ∘ Int.toNat = Function.update (getElem! o3 ∘ Int.toNat) i o2 → ((0 : ℤ) ≤ card a1 ∧ card a1 < Int.ofNat (List.length (back a1))) ∧ (List.length (List.set (back a1) (Int.toNat (card a1)) i) = List.length (back a1) → List.length (List.set (back a1) (Int.toNat (card a1)) i) = List.length (back a1) → getElem! (List.set (back a1) (Int.toNat (card a1)) i) ∘ Int.toNat = Function.update (getElem! (back a1) ∘ Int.toNat) (card a1) i → (∀(a2 : sparse_array α), (((0 : ℤ) ≤ card a1 + (1 : ℤ) ∧ card a1 + (1 : ℤ) ≤ Int.ofNat (List.length (values a1)) ∧ Int.ofNat (List.length (values a1)) ≤ (1000 : ℤ)) ∧ (List.length (values a1) = List.length (List.set o3 (Int.toNat i) o2) ∧ List.length (List.set o3 (Int.toNat i) o2) = List.length (List.set (back a1) (Int.toNat (card a1)) i)) ∧ (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < card a1 + (1 : ℤ) → ((0 : ℤ) ≤ (List.set (back a1) (Int.toNat (card a1)) i)[Int.toNat i1]! ∧ (List.set (back a1) (Int.toNat (card a1)) i)[Int.toNat i1]! < Int.ofNat (List.length (values a1))) ∧ (List.set o3 (Int.toNat i) o2)[Int.toNat ((List.set (back a1) (Int.toNat (card a1)) i)[Int.toNat i1]!)]! = i1)) ∧ (def1 a1 = def1 a2 ∧ card a1 + (1 : ℤ) = card a2 ∧ List.set (back a1) (Int.toNat (card a1)) i = back a2 ∧ List.set o3 (Int.toNat i) o2 = index a2 ∧ values a1 = values a2 → value a2 i = v ∧ (∀(j : ℤ), ¬j = i → value a2 j = value a j))))) else value a1 i = v ∧ (∀(j : ℤ), ¬j = i → value a1 j = value a j))))
  := sorry
end vacid_0_sparse_array_SparseArray_setqtvc
