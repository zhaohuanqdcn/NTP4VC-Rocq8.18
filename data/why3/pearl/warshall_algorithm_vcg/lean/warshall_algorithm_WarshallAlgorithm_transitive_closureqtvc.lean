import Why3.Base
import Why3.matrix.Matrix
open Classical
open Lean4Why3
namespace warshall_algorithm_WarshallAlgorithm_transitive_closureqtvc
inductive path : Matrix.matrix Bool -> ℤ -> ℤ -> ℤ -> Prop where
 | Path_empty (m : Matrix.matrix Bool) (i : ℤ) (j : ℤ) (k : ℤ) : Matrix.elts m i j = true → path m i j k
 | Path_cons (x : ℤ) (k : ℤ) (m : Matrix.matrix Bool) (i : ℤ) (j : ℤ) : (0 : ℤ) ≤ x → x < k → path m i x k → path m x j k → path m i j k
theorem transitive_closure'vc (m : Matrix.matrix Bool) (t : Matrix.matrix Bool) (fact0 : Matrix.rows m = Matrix.columns m) (fact1 : Matrix.rows t = Matrix.rows m) (fact2 : Matrix.columns t = Matrix.columns m) (fact3 : ∀(r : ℤ), (0 : ℤ) ≤ r ∧ r < Matrix.rows t → (∀(c : ℤ), (0 : ℤ) ≤ c ∧ c < Matrix.columns t → Matrix.elts t r c = Matrix.elts m r c)) : let n : ℤ := Matrix.rows m; let o1 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t x y = true) = path m x y (0 : ℤ)) ∧ (∀(t1 : Matrix.matrix Bool), Matrix.rows t1 = Matrix.rows t ∧ Matrix.columns t1 = Matrix.columns t → (∀(k : ℤ), ((0 : ℤ) ≤ k ∧ k ≤ o1) ∧ (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t1 x y = true) = path m x y k) → (let o2 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t1 x y = true) = (if x < (0 : ℤ) then path m x y (k + (1 : ℤ)) else path m x y k)) ∧ (∀(t2 : Matrix.matrix Bool), Matrix.rows t2 = Matrix.rows t1 ∧ Matrix.columns t2 = Matrix.columns t1 → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o2) ∧ (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t2 x y = true) = (if x < i then path m x y (k + (1 : ℤ)) else path m x y k)) → (let o3 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o3 + (1 : ℤ) → (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t2 x y = true) = (if x < i ∨ x = i ∧ y < (0 : ℤ) then path m x y (k + (1 : ℤ)) else path m x y k)) ∧ (∀(t3 : Matrix.matrix Bool), Matrix.rows t3 = Matrix.rows t2 ∧ Matrix.columns t3 = Matrix.columns t2 → (∀(j : ℤ), ((0 : ℤ) ≤ j ∧ j ≤ o3) ∧ (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t3 x y = true) = (if x < i ∨ x = i ∧ y < j then path m x y (k + (1 : ℤ)) else path m x y k)) → Matrix.valid_index t3 i j ∧ (let o4 : Bool := Matrix.elts t3 i j; (¬o4 = true → Matrix.valid_index t3 i k ∧ (Matrix.elts t3 i k = true → Matrix.valid_index t3 k j)) ∧ (∀(o5 : Bool), (if o4 = true then o5 = true else if Matrix.elts t3 i k = true then o5 = Matrix.elts t3 k j else o5 = false) → Matrix.valid_index t3 i j ∧ (∀(t4 : Matrix.matrix Bool), Matrix.rows t4 = Matrix.rows t3 ∧ Matrix.columns t4 = Matrix.columns t3 → Matrix.elts t4 = Function.update (Matrix.elts t3) i (Function.update (Matrix.elts t3 i) j o5) → (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t4 x y = true) = (if x < i ∨ x = i ∧ y < j + (1 : ℤ) then path m x y (k + (1 : ℤ)) else path m x y k)))))) ∧ ((∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t3 x y = true) = (if x < i ∨ x = i ∧ y < o3 + (1 : ℤ) then path m x y (k + (1 : ℤ)) else path m x y k)) → (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t3 x y = true) = (if x < i + (1 : ℤ) then path m x y (k + (1 : ℤ)) else path m x y k))))) ∧ (o3 + (1 : ℤ) < (0 : ℤ) → (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t2 x y = true) = (if x < i + (1 : ℤ) then path m x y (k + (1 : ℤ)) else path m x y k))))) ∧ ((∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t2 x y = true) = (if x < o2 + (1 : ℤ) then path m x y (k + (1 : ℤ)) else path m x y k)) → (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t2 x y = true) = path m x y (k + (1 : ℤ)))))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → (∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t1 x y = true) = path m x y (k + (1 : ℤ)))))) ∧ ((∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n → (0 : ℤ) ≤ y ∧ y < n → (Matrix.elts t1 x y = true) = path m x y (o1 + (1 : ℤ))) → (let n1 : ℤ := Matrix.rows m; ∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n1 → (0 : ℤ) ≤ y ∧ y < n1 → (Matrix.elts t1 x y = true) = path m x y n1)))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (let n1 : ℤ := Matrix.rows m; ∀(x : ℤ) (y : ℤ), (0 : ℤ) ≤ x ∧ x < n1 → (0 : ℤ) ≤ y ∧ y < n1 → (Matrix.elts t x y = true) = path m x y n1))
  := sorry
end warshall_algorithm_WarshallAlgorithm_transitive_closureqtvc
