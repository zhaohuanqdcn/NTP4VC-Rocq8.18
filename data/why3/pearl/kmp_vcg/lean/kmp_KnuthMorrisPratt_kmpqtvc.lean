import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace kmp_KnuthMorrisPratt_kmpqtvc
axiom char : Type
axiom inhabited_axiom_char : Inhabited char
attribute [instance] inhabited_axiom_char
noncomputable def matches1 (a1 : List char) (i1 : ℤ) (a2 : List char) (i2 : ℤ) (n : ℤ) := ((0 : ℤ) ≤ i1 ∧ i1 ≤ Int.ofNat (List.length a1) - n) ∧ ((0 : ℤ) ≤ i2 ∧ i2 ≤ Int.ofNat (List.length a2) - n) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < n → a1[Int.toNat (i1 + i)]! = a2[Int.toNat (i2 + i)]!)
noncomputable def is_next (p : List char) (j : ℤ) (n : ℤ) := ((0 : ℤ) ≤ n ∧ n < j) ∧ matches1 p (j - n) p (0 : ℤ) n ∧ (∀(z : ℤ), n < z ∧ z < j → ¬matches1 p (j - z) p (0 : ℤ) z)
noncomputable def first_occur (p : List char) (a : List char) (r : ℤ) := ((0 : ℤ) ≤ r ∧ r < Int.ofNat (List.length a) → matches1 a r p (0 : ℤ) (Int.ofNat (List.length p))) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < r → ¬matches1 a k p (0 : ℤ) (Int.ofNat (List.length p)))
theorem kmp'vc (p : List char) (a : List char) (fact0 : (1 : ℤ) ≤ Int.ofNat (List.length p)) : let m : ℤ := Int.ofNat (List.length p); let n : ℤ := Int.ofNat (List.length a); (1 : ℤ) ≤ Int.ofNat (List.length p) ∧ (∀(next : List ℤ), List.length next = List.length p ∧ (∀(j : ℤ), (0 : ℤ) < j ∧ j < Int.ofNat (List.length p) → is_next p j (next[Int.toNat j]!)) → ((((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ m) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ n) ∧ matches1 a ((0 : ℤ) - (0 : ℤ)) p (0 : ℤ) (0 : ℤ) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < (0 : ℤ) - (0 : ℤ) → ¬matches1 a k p (0 : ℤ) m)) ∧ (∀(j : ℤ) (i : ℤ), (((0 : ℤ) ≤ j ∧ j ≤ m) ∧ j ≤ i ∧ i ≤ n) ∧ matches1 a (i - j) p (0 : ℤ) j ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i - j → ¬matches1 a k p (0 : ℤ) m) → (∀(o1 : Bool), (if j < m then o1 = (if i < n then true else false) else o1 = false) → (if o1 = true then ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length p)) ∧ ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (if a[Int.toNat i]! = p[Int.toNat j]! then ((0 : ℤ) ≤ n - i ∧ n - (i + (1 : ℤ)) < n - i ∨ n - i = n - (i + (1 : ℤ)) ∧ (0 : ℤ) ≤ j ∧ j + (1 : ℤ) < j) ∧ (((0 : ℤ) ≤ j + (1 : ℤ) ∧ j + (1 : ℤ) ≤ m) ∧ j + (1 : ℤ) ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ n) ∧ matches1 a (i + (1 : ℤ) - (j + (1 : ℤ))) p (0 : ℤ) (j + (1 : ℤ)) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i + (1 : ℤ) - (j + (1 : ℤ)) → ¬matches1 a k p (0 : ℤ) m) else if j = (0 : ℤ) then ((0 : ℤ) ≤ n - i ∧ n - (i + (1 : ℤ)) < n - i ∨ n - i = n - (i + (1 : ℤ)) ∧ (0 : ℤ) ≤ j ∧ j < j) ∧ (((0 : ℤ) ≤ j ∧ j ≤ m) ∧ j ≤ i + (1 : ℤ) ∧ i + (1 : ℤ) ≤ n) ∧ matches1 a (i + (1 : ℤ) - j) p (0 : ℤ) j ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i + (1 : ℤ) - j → ¬matches1 a k p (0 : ℤ) m) else ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length next)) ∧ ((0 : ℤ) ≤ n - i ∧ n - i < n - i ∨ (0 : ℤ) ≤ j ∧ next[Int.toNat j]! < j) ∧ (((0 : ℤ) ≤ next[Int.toNat j]! ∧ next[Int.toNat j]! ≤ m) ∧ next[Int.toNat j]! ≤ i ∧ i ≤ n) ∧ matches1 a (i - next[Int.toNat j]!) p (0 : ℤ) (next[Int.toNat j]!) ∧ (∀(k : ℤ), (0 : ℤ) ≤ k ∧ k < i - next[Int.toNat j]! → ¬matches1 a k p (0 : ℤ) m)) else ∀(result : ℤ), (if j = m then result = i - m else result = i) → first_occur p a result))))
  := sorry
end kmp_KnuthMorrisPratt_kmpqtvc
