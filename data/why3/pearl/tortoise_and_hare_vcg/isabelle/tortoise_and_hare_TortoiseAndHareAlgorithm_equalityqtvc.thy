theory tortoise_and_hare_TortoiseAndHareAlgorithm_equalityqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_Iter" "Why3STD.pigeon_Pigeonhole"
begin
consts f :: "int \<Rightarrow> int"
consts m :: "int"
axiomatization where m_positive:   "(0 :: int) < m"
axiomatization where f_range'0:   "(0 :: int) \<le> f x"
 if "(0 :: int) \<le> x"
 and "x < m"
  for x :: "int"
axiomatization where f_range'1:   "f x < m"
 if "(0 :: int) \<le> x"
 and "x < m"
  for x :: "int"
consts x0 :: "int"
axiomatization where x0'def'0:   "(0 :: int) \<le> x0"
axiomatization where x0'def'1:   "x0 < m"
consts f_closure :: "int \<Rightarrow> int"
axiomatization where f_closure_def:   "f_closure y = f y"
  for y :: "int"
definition x :: "int \<Rightarrow> int"
  where "x i = iter f_closure i x0" for i
theorem equality'vc:
  fixes mu :: "int"
  fixes lambda :: "int"
  fixes n :: "int"
  fixes r :: "int"
  assumes fact0: "(0 :: int) \<le> mu"
  assumes fact1: "mu < m"
  assumes fact2: "(1 :: int) \<le> lambda"
  assumes fact3: "lambda \<le> m"
  assumes fact4: "mu + lambda \<le> m"
  assumes fact5: "x (mu + lambda) = x mu"
  assumes fact6: "\<forall>(i :: int) (j :: int). (0 :: int) \<le> i \<and> i < j \<and> j < mu + lambda \<longrightarrow> \<not>x i = x j"
  assumes fact7: "n < r"
  assumes fact8: "(0 :: int) \<le> n"
  shows "x r = x n \<longleftrightarrow> mu \<le> n \<and> (\<exists>(k :: int). (1 :: int) \<le> k \<and> r - n = k * lambda)"
  sorry
end
