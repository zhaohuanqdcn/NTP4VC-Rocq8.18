theory skew_heaps_HeapSort_heapsortqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut" "./skew_heaps_SkewHeaps" "Why3STD.bintree_Tree" "Why3STD.bintree_Size" "Why3STD.bintree_Occ"
begin
definition sorted_sub :: "elt list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "sorted_sub a l u \<longleftrightarrow> (\<forall>(i1 :: int) (i2 :: int). l \<le> i1 \<and> i1 < i2 \<and> i2 < u \<longrightarrow> le (a ! nat i1) (a ! nat i2))" for a l u
definition sorted :: "elt list \<Rightarrow> _"
  where "sorted a \<longleftrightarrow> (\<forall>(i1 :: int) (i2 :: int). (0 :: int) \<le> i1 \<and> i1 < i2 \<and> i2 < int (length a) \<longrightarrow> le (a ! nat i1) (a ! nat i2))" for a
theorem heapsort'vc:
  fixes a :: "elt list"
  shows "let n :: int = int (length a); o1 :: int = n - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((heap empty \<and> bintree_Size.size empty = (0 :: int)) \<and> (\<forall>(e :: elt). int (map_occ e (nth a o nat) (0 :: int) n) + occ e empty = int (map_occ e (nth a o nat) (0 :: int) n))) \<and> (\<forall>(t :: elt tree). (((0 :: int) \<le> bintree_Size.size t \<and> bintree_Size.size t \<le> o1) \<and> heap t \<and> (\<forall>(e :: elt). int (map_occ e (nth a o nat) (bintree_Size.size t) n) + occ e t = int (map_occ e (nth a o nat) (0 :: int) n)) \<longrightarrow> ((0 :: int) \<le> bintree_Size.size t \<and> bintree_Size.size t < int (length a)) \<and> (let o2 :: elt = a ! nat (bintree_Size.size t) in heap t \<and> (\<forall>(o3 :: elt tree). heap o3 \<and> occ o2 o3 = occ o2 t + (1 :: int) \<and> (\<forall>(e :: elt). \<not>e = o2 \<longrightarrow> occ e o3 = occ e t) \<and> bintree_Size.size o3 = bintree_Size.size t + (1 :: int) \<longrightarrow> (heap o3 \<and> bintree_Size.size o3 = bintree_Size.size t + (1 :: int)) \<and> (\<forall>(e :: elt). int (map_occ e (nth a o nat) (bintree_Size.size t + (1 :: int)) n) + occ e o3 = int (map_occ e (nth a o nat) (0 :: int) n))))) \<and> ((heap t \<and> bintree_Size.size t = o1 + (1 :: int)) \<and> (\<forall>(e :: elt). int (map_occ e (nth a o nat) (o1 + (1 :: int)) n) + occ e t = int (map_occ e (nth a o nat) (0 :: int) n)) \<longrightarrow> (let o2 :: int = n - (1 :: int) in ((0 :: int) \<le> o2 + (1 :: int) \<longrightarrow> (sorted_sub a (0 :: int) (0 :: int) \<and> (heap t \<and> bintree_Size.size t = n - (0 :: int)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> (\<forall>(e :: elt). mem e t \<longrightarrow> le (a ! nat j) e)) \<and> (\<forall>(e :: elt). int (map_occ e (nth a o nat) (0 :: int) (0 :: int)) + occ e t = int (map_occ e (nth a o nat) (0 :: int) n))) \<and> (\<forall>(t1 :: elt tree) (a1 :: elt list). length a1 = length a \<longrightarrow> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o2) \<and> sorted_sub a1 (0 :: int) i \<and> (heap t1 \<and> bintree_Size.size t1 = n - i) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> (\<forall>(e :: elt). mem e t1 \<longrightarrow> le (a1 ! nat j) e)) \<and> (\<forall>(e :: elt). int (map_occ e (nth a1 o nat) (0 :: int) i) + occ e t1 = int (map_occ e (nth a o nat) (0 :: int) n)) \<longrightarrow> (heap t1 \<and> (0 :: int) < bintree_Size.size t1) \<and> (let o3 :: elt = minimum t1 in ((0 :: int) \<le> i \<and> i < int (length a1)) \<and> (length (a1[nat i := o3]) = length a1 \<longrightarrow> nth (a1[nat i := o3]) o nat = (nth a1 o nat)(i := o3) \<longrightarrow> (heap t1 \<and> (0 :: int) < bintree_Size.size t1) \<and> (\<forall>(o4 :: elt tree). heap o4 \<and> occ (minimum t1) o4 = occ (minimum t1) t1 - (1 :: int) \<and> (\<forall>(e :: elt). \<not>e = minimum t1 \<longrightarrow> occ e o4 = occ e t1) \<and> bintree_Size.size o4 = bintree_Size.size t1 - (1 :: int) \<longrightarrow> sorted_sub (a1[nat i := o3]) (0 :: int) (i + (1 :: int)) \<and> (heap o4 \<and> bintree_Size.size o4 = n - (i + (1 :: int))) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> (\<forall>(e :: elt). mem e o4 \<longrightarrow> le (a1[nat i := o3] ! nat j) e)) \<and> (\<forall>(e :: elt). int (map_occ e (nth (a1[nat i := o3]) o nat) (0 :: int) (i + (1 :: int))) + occ e o4 = int (map_occ e (nth a o nat) (0 :: int) n)))))) \<and> (sorted_sub a1 (0 :: int) (o2 + (1 :: int)) \<and> (heap t1 \<and> bintree_Size.size t1 = n - (o2 + (1 :: int))) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < o2 + (1 :: int) \<longrightarrow> (\<forall>(e :: elt). mem e t1 \<longrightarrow> le (a1 ! nat j) e)) \<and> (\<forall>(e :: elt). int (map_occ e (nth a1 o nat) (0 :: int) (o2 + (1 :: int))) + occ e t1 = int (map_occ e (nth a o nat) (0 :: int) n)) \<longrightarrow> sorted a1 \<and> a <~~> a1))) \<and> (o2 + (1 :: int) < (0 :: int) \<longrightarrow> sorted a \<and> a <~~> a))))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> (let o2 :: int = n - (1 :: int) in ((0 :: int) \<le> o2 + (1 :: int) \<longrightarrow> (sorted_sub a (0 :: int) (0 :: int) \<and> (heap empty \<and> bintree_Size.size empty = n - (0 :: int)) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> (\<forall>(e :: elt). mem e empty \<longrightarrow> le (a ! nat j) e)) \<and> (\<forall>(e :: elt). int (map_occ e (nth a o nat) (0 :: int) (0 :: int)) + occ e empty = int (map_occ e (nth a o nat) (0 :: int) n))) \<and> (\<forall>(t :: elt tree) (a1 :: elt list). length a1 = length a \<longrightarrow> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o2) \<and> sorted_sub a1 (0 :: int) i \<and> (heap t \<and> bintree_Size.size t = n - i) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> (\<forall>(e :: elt). mem e t \<longrightarrow> le (a1 ! nat j) e)) \<and> (\<forall>(e :: elt). int (map_occ e (nth a1 o nat) (0 :: int) i) + occ e t = int (map_occ e (nth a o nat) (0 :: int) n)) \<longrightarrow> (heap t \<and> (0 :: int) < bintree_Size.size t) \<and> (let o3 :: elt = minimum t in ((0 :: int) \<le> i \<and> i < int (length a1)) \<and> (length (a1[nat i := o3]) = length a1 \<longrightarrow> nth (a1[nat i := o3]) o nat = (nth a1 o nat)(i := o3) \<longrightarrow> (heap t \<and> (0 :: int) < bintree_Size.size t) \<and> (\<forall>(o4 :: elt tree). heap o4 \<and> occ (minimum t) o4 = occ (minimum t) t - (1 :: int) \<and> (\<forall>(e :: elt). \<not>e = minimum t \<longrightarrow> occ e o4 = occ e t) \<and> bintree_Size.size o4 = bintree_Size.size t - (1 :: int) \<longrightarrow> sorted_sub (a1[nat i := o3]) (0 :: int) (i + (1 :: int)) \<and> (heap o4 \<and> bintree_Size.size o4 = n - (i + (1 :: int))) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> (\<forall>(e :: elt). mem e o4 \<longrightarrow> le (a1[nat i := o3] ! nat j) e)) \<and> (\<forall>(e :: elt). int (map_occ e (nth (a1[nat i := o3]) o nat) (0 :: int) (i + (1 :: int))) + occ e o4 = int (map_occ e (nth a o nat) (0 :: int) n)))))) \<and> (sorted_sub a1 (0 :: int) (o2 + (1 :: int)) \<and> (heap t \<and> bintree_Size.size t = n - (o2 + (1 :: int))) \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < o2 + (1 :: int) \<longrightarrow> (\<forall>(e :: elt). mem e t \<longrightarrow> le (a1 ! nat j) e)) \<and> (\<forall>(e :: elt). int (map_occ e (nth a1 o nat) (0 :: int) (o2 + (1 :: int))) + occ e t = int (map_occ e (nth a o nat) (0 :: int) n)) \<longrightarrow> sorted a1 \<and> a <~~> a1))) \<and> (o2 + (1 :: int) < (0 :: int) \<longrightarrow> sorted a \<and> a <~~> a)))"
  sorry
end
