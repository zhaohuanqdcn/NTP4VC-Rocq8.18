theory mpz_mul_Zmul_wmpz_mul_uiqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_Sub" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/sub_1_Sub_1" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/mpz_Z" "../../lib/isabelle/mpz_Zutil" "../../lib/isabelle/mpz_getset_Set"
begin
theorem wmpz_mul_ui'vc:
  fixes mpz :: "mpz_memo"
  fixes prod :: "mpz_ptr"
  fixes mult :: "mpz_ptr"
  fixes small_mult :: "64 word"
  assumes fact0: "(1 :: int) \<le> alloc mpz prod"
  assumes fact1: "(1 :: int) \<le> alloc mpz mult"
  assumes fact2: "readers mpz prod = (0 :: int)"
  assumes fact3: "readers mpz mult = (0 :: int)"
  assumes fact4: "abs_size mpz mult + (1 :: int) \<le> (2147483647 :: int)"
  shows "-(2 :: int) < readers mpz mult"
  and "\<forall>(sign_product :: 32 word). sint sign_product = sgn mpz mult * abs_size mpz mult \<longrightarrow> (\<forall>(o1 :: bool). (sint sign_product = sint (0 :: 32 word) \<longrightarrow> o1 = True) \<and> (o1 = True \<longrightarrow> sign_product = (0 :: 32 word)) \<longrightarrow> (\<forall>(o2 :: bool). (if o1 = True then o2 = True else (uint small_mult = uint (0 :: 64 word) \<longrightarrow> o2 = True) \<and> (o2 = True \<longrightarrow> small_mult = (0 :: 64 word))) \<longrightarrow> (if o2 = True then (-(1 :: int) \<le> readers mpz prod \<and> readers mpz prod \<le> (0 :: int)) \<and> (\<forall>(mpz1 :: mpz_memo). alloc mpz1 = alloc mpz \<and> sgn mpz1 = sgn mpz \<and> readers mpz1 = readers mpz \<and> zones mpz1 = zones mpz \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = prod \<longrightarrow> mpz_unchanged y mpz1 mpz) \<and> abs_size mpz1 prod = (0 :: int) \<and> abs_value_of mpz1 prod = (0 :: int) \<longrightarrow> value_of prod mpz1 = value_of mult mpz * uint small_mult \<and> (\<forall>(x :: mpz_ptr). \<not>x = prod \<longrightarrow> mpz_unchanged x mpz1 mpz) \<and> readers mpz1 prod = (0 :: int) \<and> readers mpz1 mult = (0 :: int)) else -(2147483648 :: int) < sint sign_product \<and> (\<forall>(o3 :: 32 word). sint o3 = abs (sint sign_product) \<longrightarrow> int'32_in_bounds (sint o3 + (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint o3 + (1 :: int) \<longrightarrow> (readers mpz prod = (0 :: int) \<and> (1 :: int) \<le> alloc mpz prod) \<and> (\<forall>(mpz1 :: mpz_memo). sgn mpz1 = sgn mpz \<longrightarrow> (\<forall>(pp :: 64 word ptr). (\<forall>(y :: mpz_ptr). \<not>y = prod \<longrightarrow> mpz_unchanged y mpz1 mpz) \<and> readers mpz1 prod = -(1 :: int) \<and> abs_value_of mpz1 prod = value pp (abs_size mpz1 prod) \<and> zones mpz1 prod = zone1 pp \<and> offset pp = (0 :: int) \<and> plength pp = alloc mpz1 prod \<and> c_C.min pp = (0 :: int) \<and> c_C.max pp = plength pp \<and> writable pp = True \<and> abs_size mpz1 prod = abs_size mpz prod \<and> value pp (abs_size mpz prod) = abs_value_of mpz prod \<and> (if alloc mpz prod < sint o4 then alloc mpz1 prod = sint o4 else alloc mpz1 prod = alloc mpz prod) \<longrightarrow> (mpz_eq prod mult \<longleftrightarrow> prod = mult) \<longrightarrow> (if mpz_eq prod mult then (valid pp (sint o3) \<and> writable pp = True) \<and> (\<forall>(pp1 :: 64 word ptr). length (data pp1) = length (data pp) \<and> offset pp1 = offset pp \<and> c_C.min pp1 = c_C.min pp \<and> c_C.max pp1 = c_C.max pp \<and> writable pp1 = writable pp \<and> zone1 pp1 = zone1 pp \<longrightarrow> (\<forall>(cy :: 64 word). value pp1 (sint o3) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o3 * uint cy = value pp (sint o3) * uint small_mult \<and> (\<forall>(j :: int). j < offset pp1 \<or> offset pp1 + sint o3 \<le> j \<longrightarrow> pelts pp1 j = pelts pp j) \<longrightarrow> ((c_C.min pp1 \<le> offset pp1 + sint o3 \<and> offset pp1 + sint o3 < c_C.max pp1) \<and> writable pp1 = True) \<and> (\<forall>(pp2 :: 64 word ptr). length (data pp2) = length (data pp1) \<and> offset pp2 = offset pp1 \<and> c_C.min pp2 = c_C.min pp1 \<and> c_C.max pp2 = c_C.max pp1 \<and> writable pp2 = writable pp1 \<and> zone1 pp2 = zone1 pp1 \<longrightarrow> pelts pp2 = (pelts pp1)(offset pp2 + sint o3 := cy) \<and> pelts pp2 (offset pp2 + sint o3) = cy \<longrightarrow> (\<forall>(o5 :: bool). (uint cy = uint (0 :: 64 word) \<longrightarrow> o5 = True) \<and> (o5 = True \<longrightarrow> cy = (0 :: 64 word)) \<longrightarrow> (\<forall>(o6 :: 32 word). (if \<not>o5 = True then o6 = (1 :: 32 word) else o6 = (0 :: 32 word)) \<longrightarrow> int'32_in_bounds (sint o3 + sint o6) \<and> (\<forall>(o7 :: 32 word). sint o7 = sint o3 + sint o6 \<longrightarrow> (sint sign_product < (0 :: int) \<longrightarrow> int'32_in_bounds (-sint o7)) \<and> (\<forall>(o8 :: 32 word). (if sint sign_product < (0 :: int) then sint o8 = -sint o7 else o8 = o7) \<longrightarrow> (zones mpz1 prod = zone1 pp2 \<and> readers mpz1 prod = -(1 :: int) \<and> offset pp2 = (0 :: int) \<and> c_C.min pp2 = (0 :: int) \<and> c_C.max pp2 = plength pp2 \<and> abs (sint o8) \<le> plength pp2 \<and> plength pp2 = alloc mpz1 prod \<and> (\<not>sint o8 = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint o8) - (1 :: int)) \<le> value pp2 (abs (sint o8)))) \<and> (\<forall>(mpz2 :: mpz_memo). alloc mpz2 = alloc mpz1 \<and> readers mpz2 = readers mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = prod \<longrightarrow> mpz_unchanged y mpz2 mpz1) \<and> (sgn mpz2 prod = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint o8) \<and> (sgn mpz2 prod = -(1 :: int) \<longleftrightarrow> sint o8 < (0 :: int)) \<and> abs_size mpz2 prod = abs (sint o8) \<and> abs_value_of mpz2 prod = value pp2 (abs (sint o8)) \<longrightarrow> (zones mpz2 prod = zone1 pp2 \<and> readers mpz2 prod = -(1 :: int) \<and> c_C.min pp2 = (0 :: int) \<and> c_C.max pp2 = plength pp2 \<and> abs_value_of mpz2 prod = value pp2 (abs_size mpz2 prod)) \<and> (\<forall>(mpz3 :: mpz_memo). abs_value_of mpz3 = abs_value_of mpz2 \<and> alloc mpz3 = alloc mpz2 \<and> abs_size mpz3 = abs_size mpz2 \<and> sgn mpz3 = sgn mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> readers mpz3 prod = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = prod \<longrightarrow> readers mpz3 y = readers mpz2 y) \<longrightarrow> value_of prod mpz3 = value_of mult mpz * uint small_mult \<and> (\<forall>(x :: mpz_ptr). \<not>x = prod \<longrightarrow> mpz_unchanged x mpz3 mpz) \<and> readers mpz3 prod = (0 :: int) \<and> readers mpz3 mult = (0 :: int)))))))))) else mpz_unchanged mult mpz1 mpz \<and> (readers mpz1 mult = readers mpz mult \<and> (-(2 :: int) < readers mpz1 mult \<longrightarrow> abs_value_of mpz1 mult = abs_value_of mpz mult \<and> alloc mpz1 mult = alloc mpz mult \<and> abs_size mpz1 mult = abs_size mpz mult \<and> sgn mpz1 mult = sgn mpz mult \<and> readers mpz1 mult = readers mpz mult \<and> zones mpz1 mult = zones mpz mult) \<longrightarrow> (0 :: int) \<le> readers mpz1 mult \<and> (\<forall>(mpz2 :: mpz_memo). abs_value_of mpz2 = abs_value_of mpz1 \<and> alloc mpz2 = alloc mpz1 \<and> abs_size mpz2 = abs_size mpz1 \<and> sgn mpz2 = sgn mpz1 \<and> zones mpz2 = zones mpz1 \<longrightarrow> (\<forall>(mp :: 64 word ptr). readers mpz2 mult = readers mpz1 mult + (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>mult = y \<longrightarrow> readers mpz2 y = readers mpz1 y) \<and> value mp (abs_size mpz2 mult) = abs_value_of mpz2 mult \<and> plength mp = alloc mpz2 mult \<and> offset mp = (0 :: int) \<and> c_C.min mp = (0 :: int) \<and> c_C.max mp = plength mp \<and> zone1 mp = zones mpz2 mult \<longrightarrow> (valid mp (sint o3) \<and> valid pp (sint o3) \<and> writable pp = True) \<and> (\<forall>(pp1 :: 64 word ptr). length (data pp1) = length (data pp) \<and> offset pp1 = offset pp \<and> c_C.min pp1 = c_C.min pp \<and> c_C.max pp1 = c_C.max pp \<and> writable pp1 = writable pp \<and> zone1 pp1 = zone1 pp \<longrightarrow> (\<forall>(cy :: 64 word). value pp1 (sint o3) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o3 * uint cy = value mp (sint o3) * uint small_mult \<and> (\<forall>(j :: int). j < offset pp1 \<or> offset pp1 + sint o3 \<le> j \<longrightarrow> pelts pp1 j = pelts pp j) \<longrightarrow> (zones mpz2 mult = zone1 mp \<and> (1 :: int) \<le> readers mpz2 mult \<and> c_C.min mp = (0 :: int) \<and> c_C.max mp = plength mp) \<and> (\<forall>(mpz3 :: mpz_memo). abs_value_of mpz3 = abs_value_of mpz2 \<and> alloc mpz3 = alloc mpz2 \<and> abs_size mpz3 = abs_size mpz2 \<and> sgn mpz3 = sgn mpz2 \<and> zones mpz3 = zones mpz2 \<longrightarrow> readers mpz3 mult = readers mpz2 mult - (1 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = mult \<longrightarrow> readers mpz3 y = readers mpz2 y) \<longrightarrow> ((c_C.min pp1 \<le> offset pp1 + sint o3 \<and> offset pp1 + sint o3 < c_C.max pp1) \<and> writable pp1 = True) \<and> (\<forall>(pp2 :: 64 word ptr). length (data pp2) = length (data pp1) \<and> offset pp2 = offset pp1 \<and> c_C.min pp2 = c_C.min pp1 \<and> c_C.max pp2 = c_C.max pp1 \<and> writable pp2 = writable pp1 \<and> zone1 pp2 = zone1 pp1 \<longrightarrow> pelts pp2 = (pelts pp1)(offset pp2 + sint o3 := cy) \<and> pelts pp2 (offset pp2 + sint o3) = cy \<longrightarrow> (\<forall>(o5 :: bool). (uint cy = uint (0 :: 64 word) \<longrightarrow> o5 = True) \<and> (o5 = True \<longrightarrow> cy = (0 :: 64 word)) \<longrightarrow> (\<forall>(o6 :: 32 word). (if \<not>o5 = True then o6 = (1 :: 32 word) else o6 = (0 :: 32 word)) \<longrightarrow> int'32_in_bounds (sint o3 + sint o6) \<and> (\<forall>(o7 :: 32 word). sint o7 = sint o3 + sint o6 \<longrightarrow> (sint sign_product < (0 :: int) \<longrightarrow> int'32_in_bounds (-sint o7)) \<and> (\<forall>(o8 :: 32 word). (if sint sign_product < (0 :: int) then sint o8 = -sint o7 else o8 = o7) \<longrightarrow> (zones mpz3 prod = zone1 pp2 \<and> readers mpz3 prod = -(1 :: int) \<and> offset pp2 = (0 :: int) \<and> c_C.min pp2 = (0 :: int) \<and> c_C.max pp2 = plength pp2 \<and> abs (sint o8) \<le> plength pp2 \<and> plength pp2 = alloc mpz3 prod \<and> (\<not>sint o8 = (0 :: int) \<longrightarrow> ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (abs (sint o8) - (1 :: int)) \<le> value pp2 (abs (sint o8)))) \<and> (\<forall>(mpz4 :: mpz_memo). alloc mpz4 = alloc mpz3 \<and> readers mpz4 = readers mpz3 \<and> zones mpz4 = zones mpz3 \<longrightarrow> (\<forall>(y :: mpz_ptr). \<not>y = prod \<longrightarrow> mpz_unchanged y mpz4 mpz3) \<and> (sgn mpz4 prod = (1 :: int) \<longleftrightarrow> (0 :: int) \<le> sint o8) \<and> (sgn mpz4 prod = -(1 :: int) \<longleftrightarrow> sint o8 < (0 :: int)) \<and> abs_size mpz4 prod = abs (sint o8) \<and> abs_value_of mpz4 prod = value pp2 (abs (sint o8)) \<longrightarrow> (zones mpz4 prod = zone1 pp2 \<and> readers mpz4 prod = -(1 :: int) \<and> c_C.min pp2 = (0 :: int) \<and> c_C.max pp2 = plength pp2 \<and> abs_value_of mpz4 prod = value pp2 (abs_size mpz4 prod)) \<and> (\<forall>(mpz5 :: mpz_memo). abs_value_of mpz5 = abs_value_of mpz4 \<and> alloc mpz5 = alloc mpz4 \<and> abs_size mpz5 = abs_size mpz4 \<and> sgn mpz5 = sgn mpz4 \<and> zones mpz5 = zones mpz4 \<longrightarrow> readers mpz5 prod = (0 :: int) \<and> (\<forall>(y :: mpz_ptr). \<not>y = prod \<longrightarrow> readers mpz5 y = readers mpz4 y) \<longrightarrow> value_of prod mpz5 = value_of mult mpz * uint small_mult \<and> (\<forall>(x :: mpz_ptr). \<not>x = prod \<longrightarrow> mpz_unchanged x mpz5 mpz) \<and> readers mpz5 prod = (0 :: int) \<and> readers mpz5 mult = (0 :: int))))))))))))))))))))))"
  sorry
end
