import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.c.C
import Why3.mach.int.Unsigned
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.ptralias.Alias
open Classical
open Lean4Why3
namespace add_Add_addqtvc
theorem add'vc (sy : BitVec 32) (sx : BitVec 32) (r : C.ptr (BitVec 64)) (x : C.ptr (BitVec 64)) (y : C.ptr (BitVec 64)) (fact0 : (0 : ℤ) ≤ BitVec.toInt sy) (fact1 : BitVec.toInt sy ≤ BitVec.toInt sx) (fact2 : C.valid r (BitVec.toInt sx)) (fact3 : C.valid x (BitVec.toInt sx)) (fact4 : C.valid y (BitVec.toInt sy)) (fact5 : C.writable r = true) : C.valid r (BitVec.toInt sx) ∧ C.valid x (BitVec.toInt sx) ∧ C.valid y (BitVec.toInt sy) ∧ C.writable r = true ∧ (0 : ℤ) ≤ BitVec.toInt sy ∧ BitVec.toInt sy ≤ BitVec.toInt sx ∧ (∀(y1 : C.ptr (BitVec 64)) (x1 : C.ptr (BitVec 64)) (r1 : C.ptr (BitVec 64)), C.offset y1 = C.offset y ∧ C.writable y1 = C.writable y ∧ C.zone1 y1 = C.zone1 y → C.offset x1 = C.offset x ∧ C.writable x1 = C.writable x ∧ C.zone1 x1 = C.zone1 x → C.offset r1 = C.offset r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → (∀(nr : C.ptr (BitVec 64)) (nx : C.ptr (BitVec 64)) (ny : C.ptr (BitVec 64)) (m : Alias.mem), C.writable nr = true ∧ (Lemmas.value nx (BitVec.toInt sx) = Lemmas.value x (BitVec.toInt sx) ∧ Lemmas.value ny (BitVec.toInt sy) = Lemmas.value y (BitVec.toInt sy)) ∧ (C.valid nr (BitVec.toInt sx) ∧ C.valid nx (BitVec.toInt sx) ∧ C.valid ny (BitVec.toInt sy)) ∧ ((0 : ℤ) ≤ C.offset nr ∧ C.offset nr + BitVec.toInt sx ≤ C.offset nx ∧ C.offset nx + BitVec.toInt sx ≤ C.offset ny) ∧ (Alias.zr m = C.zone1 r1 ∧ Alias.zx m = C.zone1 x1 ∧ Alias.zy m = C.zone1 y1) ∧ (BitVec.toInt (Alias.mr m) = C.max r ∧ BitVec.toInt (Alias.mx m) = C.max x ∧ BitVec.toInt (Alias.my m) = C.max y) ∧ (Alias.lr m = sx ∧ Alias.lx m = sx ∧ Alias.ly m = sy) ∧ Alias.ok m = true ∧ Lemmas.map_eq_sub_shift (C.pelts nr) (C.pelts r1) (C.offset nr) (C.offset r1) (BitVec.toInt sx) ∧ Lemmas.map_eq_sub_shift (C.pelts nx) (C.pelts x1) (C.offset nx) (C.offset x1) (BitVec.toInt sx) ∧ Lemmas.map_eq_sub_shift (C.pelts ny) (C.pelts y1) (C.offset ny) (C.offset y1) (BitVec.toInt sy) ∧ (C.pelts r1 = C.pelts r ∧ C.pelts x1 = C.pelts x ∧ C.pelts y1 = C.pelts y) ∧ (C.plength r1 = C.plength r ∧ C.plength x1 = C.plength x ∧ C.plength y1 = C.plength y) ∧ (C.min r1 = C.min r ∧ C.min x1 = C.min x ∧ C.min y1 = C.min y) ∧ C.data nr = C.data nx ∧ C.data nx = C.data ny → (((0 : ℤ) ≤ BitVec.toInt sy ∧ BitVec.toInt sy ≤ BitVec.toInt sx) ∧ (C.valid nr (BitVec.toInt sx) ∧ C.valid nx (BitVec.toInt sx) ∧ C.valid ny (BitVec.toInt sy)) ∧ (C.offset nr = C.offset nx ∨ C.offset nr + BitVec.toInt sx ≤ C.offset nx ∨ C.offset nx + BitVec.toInt sx ≤ C.offset nr) ∧ (C.offset nr = C.offset ny ∨ C.offset nr + BitVec.toInt sx ≤ C.offset ny ∨ C.offset ny + BitVec.toInt sy ≤ C.offset nr) ∧ (C.data nr = C.data nx ∧ C.data nx = C.data ny) ∧ C.writable nr = true) ∧ (∀(ny1 : C.ptr (BitVec 64)) (nx1 : C.ptr (BitVec 64)) (nr1 : C.ptr (BitVec 64)), C.data ny1 = C.data nr1 ∧ List.length (C.data nr1) = List.length (C.data ny) ∧ C.offset ny1 = C.offset ny ∧ C.min ny1 = C.min ny ∧ C.max ny1 = C.max ny ∧ C.writable ny1 = C.writable ny ∧ C.zone1 ny1 = C.zone1 ny → C.data nx1 = C.data nr1 ∧ List.length (C.data nr1) = List.length (C.data nx) ∧ C.offset nx1 = C.offset nx ∧ C.min nx1 = C.min nx ∧ C.max nx1 = C.max nx ∧ C.writable nx1 = C.writable nx ∧ C.zone1 nx1 = C.zone1 nx → List.length (C.data nr1) = List.length (C.data nr) ∧ C.offset nr1 = C.offset nr ∧ C.min nr1 = C.min nr ∧ C.max nr1 = C.max nr ∧ C.writable nr1 = C.writable nr ∧ C.zone1 nr1 = C.zone1 nr → (∀(res : BitVec 64), Lemmas.value nr1 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt res = Lemmas.value nx (BitVec.toInt sx) + Lemmas.value ny (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt res ∧ BitVec.toUInt res ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset nr1 ∨ C.offset nr1 + BitVec.toInt sx ≤ j → C.pelts nr1 j = C.pelts nr j) ∧ (C.offset nr1 = C.offset nx1 ∨ MapEq.map_eq_sub (C.pelts nx1) (C.pelts nx) (C.offset nx1) (C.offset nx1 + BitVec.toInt sx)) ∧ (C.offset nr1 = C.offset ny1 ∨ MapEq.map_eq_sub (C.pelts ny1) (C.pelts ny) (C.offset ny1) (C.offset ny1 + BitVec.toInt sy)) → (Alias.ok m = true ∧ ((0 : ℤ) ≤ BitVec.toInt sy ∧ BitVec.toInt sy ≤ BitVec.toInt sx) ∧ (Alias.zr m = C.zone1 r1 ∧ Alias.zx m = C.zone1 x1 ∧ Alias.zy m = C.zone1 y1) ∧ (Alias.lr m = sx ∧ Alias.lx m = sx ∧ Alias.ly m = sy) ∧ ((0 : ℤ) ≤ C.offset nr1 ∧ C.offset nr1 + BitVec.toInt sx ≤ C.offset nx1 ∧ C.offset nx1 + BitVec.toInt sx ≤ C.offset ny1) ∧ C.writable r1 = true ∧ C.writable nr1 = true) ∧ (∀(m1 : Alias.mem) (ny2 : C.ptr (BitVec 64)) (nx2 : C.ptr (BitVec 64)) (nr2 : C.ptr (BitVec 64)) (y2 : C.ptr (BitVec 64)) (x2 : C.ptr (BitVec 64)) (r2 : C.ptr (BitVec 64)), Alias.zr m1 = Alias.zr m ∧ Alias.zx m1 = Alias.zx m ∧ Alias.zy m1 = Alias.zy m ∧ Alias.mr m1 = Alias.mr m ∧ Alias.mx m1 = Alias.mx m ∧ Alias.my m1 = Alias.my m ∧ Alias.lr m1 = Alias.lr m ∧ Alias.lx m1 = Alias.lx m ∧ Alias.ly m1 = Alias.ly m → C.offset ny2 = C.offset ny1 ∧ C.writable ny2 = C.writable ny1 ∧ C.zone1 ny2 = C.zone1 ny1 → C.offset nx2 = C.offset nx1 ∧ C.writable nx2 = C.writable nx1 ∧ C.zone1 nx2 = C.zone1 nx1 → C.offset nr2 = C.offset nr1 ∧ C.writable nr2 = C.writable nr1 ∧ C.zone1 nr2 = C.zone1 nr1 → C.offset y2 = C.offset y1 ∧ C.min y2 = C.min y1 ∧ C.writable y2 = C.writable y1 ∧ C.zone1 y2 = C.zone1 y1 → C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → (C.max r2 = BitVec.toInt (Alias.mr m1) ∧ C.max x2 = BitVec.toInt (Alias.mx m1) ∧ C.max y2 = BitVec.toInt (Alias.my m1)) ∧ Lemmas.map_eq_sub_shift (C.pelts nr1) (C.pelts r2) (C.offset nr2) (C.offset r2) (BitVec.toInt sx) ∧ Lemmas.map_eq_sub_shift (C.pelts nx1) (C.pelts x2) (C.offset nx2) (C.offset x2) (BitVec.toInt sx) ∧ Lemmas.map_eq_sub_shift (C.pelts ny1) (C.pelts y2) (C.offset ny2) (C.offset y2) (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sx ≤ j → C.pelts r2 j = C.pelts r1 j) ∧ (∀(j : ℤ), j < C.offset x2 ∨ C.offset x2 + BitVec.toInt sx ≤ j → C.pelts x2 j = C.pelts x1 j) ∧ (∀(j : ℤ), j < C.offset y2 ∨ C.offset y2 + BitVec.toInt sy ≤ j → C.pelts y2 j = C.pelts y1 j) ∧ (C.plength r2 = C.plength r1 ∧ C.plength x2 = C.plength x1 ∧ C.plength y2 = C.plength y1) ∧ C.min r2 = C.min r1 ∧ C.min x2 = C.min x1 ∧ C.min y2 = C.min y1 → Lemmas.value r2 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt res = Lemmas.value x (BitVec.toInt sx) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt res ∧ BitVec.toUInt res ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sx ≤ j → C.pelts r2 j = C.pelts r j) ∧ (∀(j : ℤ), C.pelts x2 j = C.pelts x j) ∧ (∀(j : ℤ), C.pelts y2 j = C.pelts y j) ∧ Lemmas.value x2 (BitVec.toInt sx) = Lemmas.value x (BitVec.toInt sx) ∧ Lemmas.value y2 (BitVec.toInt sy) = Lemmas.value y (BitVec.toInt sy) ∧ (C.min x2 = C.min x ∧ C.max x2 = C.max x ∧ C.plength x2 = C.plength x) ∧ (C.min y2 = C.min y ∧ C.max y2 = C.max y ∧ C.plength y2 = C.plength y) ∧ C.min r2 = C.min r ∧ C.max r2 = C.max r ∧ C.plength r2 = C.plength r)))))
  := sorry
end add_Add_addqtvc
