import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.sub.Sub
import pearl.multiprecision.lib.lean.mpz.Z
import pearl.multiprecision.lib.lean.mpz.Zutil
open Classical
open Lean4Why3
namespace mpz_sub_Zsub_wmpz_subqtvc
theorem wmpz_sub'vc (mpz : Z.mpz_memo) (w : Z.mpz_ptr) (u : Z.mpz_ptr) (v : Z.mpz_ptr) (fact0 : (1 : ℤ) ≤ Z.alloc mpz w) (fact1 : (1 : ℤ) ≤ Z.alloc mpz u) (fact2 : (1 : ℤ) ≤ Z.alloc mpz v) (fact3 : Z.readers mpz w = (0 : ℤ)) (fact4 : Z.readers mpz u = (0 : ℤ)) (fact5 : Z.readers mpz v = (0 : ℤ)) (fact6 : Z.abs_size mpz u < (2147483647 : ℤ)) (fact7 : Z.abs_size mpz v < (2147483647 : ℤ)) (fact8 : Z.mpz_eq u v = (u = v)) : if Z.mpz_eq u v then (-(1 : ℤ) ≤ Z.readers mpz w ∧ Z.readers mpz w ≤ (0 : ℤ)) ∧ (∀(mpz1 : Z.mpz_memo), Z.alloc mpz1 = Z.alloc mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.readers mpz1 = Z.readers mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz1 mpz) ∧ Z.abs_size mpz1 w = (0 : ℤ) ∧ Z.abs_value_of mpz1 w = (0 : ℤ) → Z.value_of w mpz1 = Z.value_of u mpz - Z.value_of v mpz ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz1 mpz) ∧ Z.readers mpz1 w = (0 : ℤ) ∧ Z.readers mpz1 u = (0 : ℤ) ∧ Z.readers mpz1 v = (0 : ℤ)) else -(2 : ℤ) < Z.readers mpz u ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = Z.sgn mpz u * Z.abs_size mpz u → -(2 : ℤ) < Z.readers mpz v ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = Z.sgn mpz v * Z.abs_size mpz v → int'32_in_bounds (-BitVec.toInt o2) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = -BitVec.toInt o2 → -(2147483648 : ℤ) < BitVec.toInt o1 ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = abs (BitVec.toInt o1) → -(2147483648 : ℤ) < BitVec.toInt o3 ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = abs (BitVec.toInt o3) → (if BitVec.toInt o4 < BitVec.toInt o5 then (Z.readers mpz u = (0 : ℤ) ∧ Z.readers mpz v = (0 : ℤ)) ∧ (Z.readers mpz v = (0 : ℤ) ∧ Z.readers mpz u = (0 : ℤ) → (Z.abs_size mpz v = BitVec.toInt o5 ∧ Z.abs_size mpz u = BitVec.toInt o4) ∧ (BitVec.toInt o4 ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 < (2147483647 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ Z.alloc mpz u) ∧ ((0 : ℤ) ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 ≤ Z.alloc mpz v) ∧ ((0 : ℤ) < Z.alloc mpz v ∧ (0 : ℤ) < Z.alloc mpz u) ∧ (Z.readers mpz v = (0 : ℤ) ∧ Z.readers mpz u = (0 : ℤ)) ∧ True = (BitVec.toInt o4 < BitVec.toInt o5) ∧ (BitVec.toInt o5 * Z.sgn mpz v = -BitVec.toInt o3 ∧ BitVec.toInt o4 * Z.sgn mpz u = BitVec.toInt o1) ∧ (¬True → BitVec.toInt o5 * Z.sgn mpz v = BitVec.toInt o3 ∧ BitVec.toInt o4 * Z.sgn mpz u = -BitVec.toInt o1) ∧ -Z.value_of v mpz + Z.value_of u mpz = Z.value_of u mpz - Z.value_of v mpz ∧ (¬True → Z.value_of v mpz - Z.value_of u mpz = Z.value_of u mpz - Z.value_of v mpz) ∧ Z.mpz_unchanged v mpz mpz ∧ Z.mpz_unchanged u mpz mpz ∧ ¬Z.mpz_eq v u) else (Z.abs_size mpz u = BitVec.toInt o4 ∧ Z.abs_size mpz v = BitVec.toInt o5) ∧ (BitVec.toInt o5 ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 < (2147483647 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 ≤ Z.alloc mpz v) ∧ ((0 : ℤ) ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 ≤ Z.alloc mpz u) ∧ ((0 : ℤ) < Z.alloc mpz u ∧ (0 : ℤ) < Z.alloc mpz v) ∧ (Z.readers mpz u = (0 : ℤ) ∧ Z.readers mpz v = (0 : ℤ)) ∧ ¬BitVec.toInt o4 < BitVec.toInt o5 ∧ (BitVec.toInt o4 * Z.sgn mpz u = BitVec.toInt o1 ∧ BitVec.toInt o5 * Z.sgn mpz v = -BitVec.toInt o3) ∧ Z.mpz_unchanged u mpz mpz ∧ Z.mpz_unchanged v mpz mpz ∧ ¬Z.mpz_eq u v) ∧ (∀(swapped : Bool) (abs_vsize : BitVec 32) (abs_usize : BitVec 32) (vsize : BitVec 32) (usize : BitVec 32) (v1 : Z.mpz_ptr) (u1 : Z.mpz_ptr), (Z.abs_size mpz u1 = BitVec.toInt abs_usize ∧ Z.abs_size mpz v1 = BitVec.toInt abs_vsize) ∧ (BitVec.toInt abs_vsize ≤ BitVec.toInt abs_usize ∧ BitVec.toInt abs_usize < (2147483647 : ℤ)) ∧ ((0 : ℤ) ≤ BitVec.toInt abs_vsize ∧ BitVec.toInt abs_vsize ≤ Z.alloc mpz v1) ∧ ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ BitVec.toInt abs_usize ≤ Z.alloc mpz u1) ∧ ((0 : ℤ) < Z.alloc mpz u1 ∧ (0 : ℤ) < Z.alloc mpz v1) ∧ (Z.readers mpz u1 = (0 : ℤ) ∧ Z.readers mpz v1 = (0 : ℤ)) ∧ (swapped = true) = (BitVec.toInt o4 < BitVec.toInt o5) ∧ (swapped = true → BitVec.toInt abs_usize * Z.sgn mpz u1 = -BitVec.toInt usize ∧ BitVec.toInt abs_vsize * Z.sgn mpz v1 = BitVec.toInt vsize) ∧ (¬swapped = true → BitVec.toInt abs_usize * Z.sgn mpz u1 = BitVec.toInt usize ∧ BitVec.toInt abs_vsize * Z.sgn mpz v1 = -BitVec.toInt vsize) ∧ (swapped = true → -Z.value_of u1 mpz + Z.value_of v1 mpz = Z.value_of u mpz - Z.value_of v mpz) ∧ (¬swapped = true → Z.value_of u1 mpz - Z.value_of v1 mpz = Z.value_of u mpz - Z.value_of v mpz) ∧ Z.mpz_unchanged u1 mpz mpz ∧ Z.mpz_unchanged v1 mpz mpz ∧ ¬Z.mpz_eq u1 v1 → int'32_in_bounds (BitVec.toInt abs_usize + (1 : ℤ)) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt abs_usize + (1 : ℤ) → Z.mpz_eq u1 w = (u1 = w) → Z.mpz_eq v1 w = (v1 = w) → (Z.readers mpz w = (0 : ℤ) ∧ (1 : ℤ) ≤ Z.alloc mpz w) ∧ (∀(mpz1 : Z.mpz_memo), Z.sgn mpz1 = Z.sgn mpz → (∀(wp : C.ptr (BitVec 64)), (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz1 mpz) ∧ Z.readers mpz1 w = -(1 : ℤ) ∧ Z.abs_value_of mpz1 w = Lemmas.value wp (Z.abs_size mpz1 w) ∧ Z.zones mpz1 w = C.zone1 wp ∧ C.offset wp = (0 : ℤ) ∧ C.plength wp = Z.alloc mpz1 w ∧ C.min wp = (0 : ℤ) ∧ C.max wp = C.plength wp ∧ C.writable wp = true ∧ Z.abs_size mpz1 w = Z.abs_size mpz w ∧ Lemmas.value wp (Z.abs_size mpz w) = Z.abs_value_of mpz w ∧ (if Z.alloc mpz w < BitVec.toInt o6 then Z.alloc mpz1 w = BitVec.toInt o6 else Z.alloc mpz1 w = Z.alloc mpz w) → (∀(o7 : BitVec 32), (BitVec.toInt usize = (0 : ℤ) → o7 = vsize) ∧ (BitVec.toInt vsize = (0 : ℤ) → o7 = usize) ∧ ((0 : ℤ) ≤ BitVec.toInt usize ∧ (0 : ℤ) ≤ BitVec.toInt vsize ∨ BitVec.toInt usize < (0 : ℤ) ∧ BitVec.toInt vsize < (0 : ℤ) → (0 : ℤ) ≤ BitVec.toInt o7) ∧ (BitVec.toInt usize < (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt vsize ∨ (0 : ℤ) ≤ BitVec.toInt usize ∧ BitVec.toInt vsize < (0 : ℤ) → BitVec.toInt o7 < (0 : ℤ)) → (if BitVec.toInt o7 < (0 : ℤ) then (∀(o8 : Bool), (BitVec.toInt abs_usize = BitVec.toInt abs_vsize → o8 = true) ∧ (o8 = true → abs_usize = abs_vsize) → (if ¬o8 = true then (if Z.mpz_eq u1 w then (0 : ℤ) ≤ Z.readers mpz1 v1 ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(vp : C.ptr (BitVec 64)), Z.readers mpz2 v1 = Z.readers mpz1 v1 + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬v1 = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value vp (Z.abs_size mpz2 v1) = Z.abs_value_of mpz2 v1 ∧ C.plength vp = Z.alloc mpz2 v1 ∧ C.offset vp = (0 : ℤ) ∧ C.min vp = (0 : ℤ) ∧ C.max vp = C.plength vp ∧ C.zone1 vp = Z.zones mpz2 v1 → (((0 : ℤ) ≤ BitVec.toInt abs_vsize ∧ BitVec.toInt abs_vsize ≤ BitVec.toInt abs_usize) ∧ (C.valid wp (BitVec.toInt abs_usize) ∧ C.valid vp (BitVec.toInt abs_vsize)) ∧ C.writable wp = true) ∧ (∀(vp1 : C.ptr (BitVec 64)) (wp1 : C.ptr (BitVec 64)), C.offset vp1 = C.offset vp ∧ C.writable vp1 = C.writable vp ∧ C.zone1 vp1 = C.zone1 vp → C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(x_b : BitVec 64), Lemmas.value wp1 (BitVec.toInt abs_usize) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt abs_usize)) * BitVec.toUInt x_b = Lemmas.value wp (BitVec.toInt abs_usize) - Lemmas.value vp (BitVec.toInt abs_vsize) ∧ ((0 : ℤ) ≤ BitVec.toUInt x_b ∧ BitVec.toUInt x_b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt abs_usize ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (∀(j : ℤ), C.pelts vp1 j = C.pelts vp j) ∧ Lemmas.value vp1 (BitVec.toInt abs_vsize) = Lemmas.value vp (BitVec.toInt abs_vsize) ∧ (C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp) ∧ C.min vp1 = C.min vp ∧ C.max vp1 = C.max vp ∧ C.plength vp1 = C.plength vp → (Z.zones mpz2 v1 = C.zone1 vp1 ∧ (1 : ℤ) ≤ Z.readers mpz2 v1 ∧ C.min vp1 = (0 : ℤ) ∧ C.max vp1 = C.plength vp1) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 v1 = Z.readers mpz2 v1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v1 → Z.readers mpz3 y = Z.readers mpz2 y) → Lemmas.value wp1 (BitVec.toInt abs_usize) = Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1 ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz3 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz3 v1 = (0 : ℤ)) ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp))))) else if Z.mpz_eq v1 w then (0 : ℤ) ≤ Z.readers mpz1 u1 ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(up : C.ptr (BitVec 64)), Z.readers mpz2 u1 = Z.readers mpz1 u1 + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬u1 = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value up (Z.abs_size mpz2 u1) = Z.abs_value_of mpz2 u1 ∧ C.plength up = Z.alloc mpz2 u1 ∧ C.offset up = (0 : ℤ) ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up ∧ C.zone1 up = Z.zones mpz2 u1 → (((0 : ℤ) ≤ BitVec.toInt abs_vsize ∧ BitVec.toInt abs_vsize ≤ BitVec.toInt abs_usize) ∧ (C.valid up (BitVec.toInt abs_usize) ∧ C.valid wp (BitVec.toInt abs_usize)) ∧ C.writable wp = true) ∧ (∀(up1 : C.ptr (BitVec 64)) (wp1 : C.ptr (BitVec 64)), C.offset up1 = C.offset up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(x_b : BitVec 64), Lemmas.value wp1 (BitVec.toInt abs_usize) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt abs_usize)) * BitVec.toUInt x_b = Lemmas.value up (BitVec.toInt abs_usize) - Lemmas.value wp (BitVec.toInt abs_vsize) ∧ ((0 : ℤ) ≤ BitVec.toUInt x_b ∧ BitVec.toUInt x_b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt abs_usize ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (∀(j : ℤ), C.pelts up1 j = C.pelts up j) ∧ Lemmas.value up1 (BitVec.toInt abs_usize) = Lemmas.value up (BitVec.toInt abs_usize) ∧ (C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.plength up1 = C.plength up) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp → (Z.zones mpz2 u1 = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz2 u1 ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 u1 = Z.readers mpz2 u1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u1 → Z.readers mpz3 y = Z.readers mpz2 y) → Lemmas.value wp1 (BitVec.toInt abs_usize) = Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1 ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz3 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz3 v1 = (0 : ℤ)) ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp))))) else (0 : ℤ) ≤ Z.readers mpz1 u1 ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(up : C.ptr (BitVec 64)), Z.readers mpz2 u1 = Z.readers mpz1 u1 + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬u1 = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value up (Z.abs_size mpz2 u1) = Z.abs_value_of mpz2 u1 ∧ C.plength up = Z.alloc mpz2 u1 ∧ C.offset up = (0 : ℤ) ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up ∧ C.zone1 up = Z.zones mpz2 u1 → (0 : ℤ) ≤ Z.readers mpz2 v1 ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → (∀(vp : C.ptr (BitVec 64)), Z.readers mpz3 v1 = Z.readers mpz2 v1 + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬v1 = y → Z.readers mpz3 y = Z.readers mpz2 y) ∧ Lemmas.value vp (Z.abs_size mpz3 v1) = Z.abs_value_of mpz3 v1 ∧ C.plength vp = Z.alloc mpz3 v1 ∧ C.offset vp = (0 : ℤ) ∧ C.min vp = (0 : ℤ) ∧ C.max vp = C.plength vp ∧ C.zone1 vp = Z.zones mpz3 v1 → (((0 : ℤ) ≤ BitVec.toInt abs_vsize ∧ BitVec.toInt abs_vsize ≤ BitVec.toInt abs_usize) ∧ (C.valid wp (BitVec.toInt abs_usize) ∧ C.valid up (BitVec.toInt abs_usize) ∧ C.valid vp (BitVec.toInt abs_vsize)) ∧ C.writable wp = true) ∧ (∀(vp1 : C.ptr (BitVec 64)) (up1 : C.ptr (BitVec 64)) (wp1 : C.ptr (BitVec 64)), C.offset vp1 = C.offset vp ∧ C.writable vp1 = C.writable vp ∧ C.zone1 vp1 = C.zone1 vp → C.offset up1 = C.offset up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(x_b : BitVec 64), Lemmas.value wp1 (BitVec.toInt abs_usize) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt abs_usize)) * BitVec.toUInt x_b = Lemmas.value up (BitVec.toInt abs_usize) - Lemmas.value vp (BitVec.toInt abs_vsize) ∧ ((0 : ℤ) ≤ BitVec.toUInt x_b ∧ BitVec.toUInt x_b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt abs_usize ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (∀(j : ℤ), C.pelts up1 j = C.pelts up j) ∧ (∀(j : ℤ), C.pelts vp1 j = C.pelts vp j) ∧ Lemmas.value up1 (BitVec.toInt abs_usize) = Lemmas.value up (BitVec.toInt abs_usize) ∧ Lemmas.value vp1 (BitVec.toInt abs_vsize) = Lemmas.value vp (BitVec.toInt abs_vsize) ∧ (C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.plength up1 = C.plength up) ∧ (C.min vp1 = C.min vp ∧ C.max vp1 = C.max vp ∧ C.plength vp1 = C.plength vp) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp → (Z.zones mpz3 u1 = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz3 u1 ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz4 : Z.mpz_memo), Z.abs_value_of mpz4 = Z.abs_value_of mpz3 ∧ Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → Z.readers mpz4 u1 = Z.readers mpz3 u1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u1 → Z.readers mpz4 y = Z.readers mpz3 y) → (Z.zones mpz4 v1 = C.zone1 vp1 ∧ (1 : ℤ) ≤ Z.readers mpz4 v1 ∧ C.min vp1 = (0 : ℤ) ∧ C.max vp1 = C.plength vp1) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 v1 = Z.readers mpz4 v1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v1 → Z.readers mpz5 y = Z.readers mpz4 y) → Lemmas.value wp1 (BitVec.toInt abs_usize) = Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1 ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz5 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz5 v1 = (0 : ℤ)) ∧ Z.readers mpz5 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz5 mpz) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp))))))))) ∧ (∀(wp1 : C.ptr (BitVec 64)) (mpz2 : Z.mpz_memo), C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → Lemmas.value wp1 (BitVec.toInt abs_usize) = Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1 ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz2 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz2 v1 = (0 : ℤ)) ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz2 mpz) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp → ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ C.valid wp1 (BitVec.toInt abs_usize)) ∧ (∀(wsize : BitVec 32), ((0 : ℤ) ≤ BitVec.toInt wsize ∧ BitVec.toInt wsize ≤ BitVec.toInt abs_usize) ∧ Lemmas.value wp1 (BitVec.toInt wsize) = Lemmas.value wp1 (BitVec.toInt abs_usize) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ (0 : ℤ) < BitVec.toUInt (C.pelts wp1 (C.offset wp1 + BitVec.toInt wsize - (1 : ℤ)))) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt wsize - (1 : ℤ))) ≤ Lemmas.value wp1 (BitVec.toInt wsize)) → (if BitVec.toInt usize < (0 : ℤ) then int'32_in_bounds (-BitVec.toInt wsize) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = -BitVec.toInt wsize → Lemmas.value wp1 (abs (BitVec.toInt o9)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 o9 = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz2 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz2 v1 = (0 : ℤ)) ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz2 mpz) ∧ abs (BitVec.toInt o9) ≤ C.plength wp1 ∧ (¬BitVec.toInt o9 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o9) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt o9))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp) else Lemmas.value wp1 (abs (BitVec.toInt wsize)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 wsize = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz2 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz2 v1 = (0 : ℤ)) ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz2 mpz) ∧ abs (BitVec.toInt wsize) ≤ C.plength wp1 ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt wsize))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp))) else if Z.mpz_eq u1 w then (0 : ℤ) ≤ Z.readers mpz1 v1 ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(vp : C.ptr (BitVec 64)), Z.readers mpz2 v1 = Z.readers mpz1 v1 + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬v1 = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value vp (Z.abs_size mpz2 v1) = Z.abs_value_of mpz2 v1 ∧ C.plength vp = Z.alloc mpz2 v1 ∧ C.offset vp = (0 : ℤ) ∧ C.min vp = (0 : ℤ) ∧ C.max vp = C.plength vp ∧ C.zone1 vp = Z.zones mpz2 v1 → (C.valid wp (BitVec.toInt abs_usize) ∧ C.valid vp (BitVec.toInt abs_usize)) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = Compare.compare_int (Lemmas.value wp (BitVec.toInt abs_usize)) (Lemmas.value vp (BitVec.toInt abs_usize)) → (if BitVec.toInt o9 < (0 : ℤ) then ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ (C.valid vp (BitVec.toInt abs_usize) ∧ C.valid wp (BitVec.toInt abs_usize)) ∧ C.writable wp = true) ∧ (∀(vp1 : C.ptr (BitVec 64)) (wp1 : C.ptr (BitVec 64)), C.offset vp1 = C.offset vp ∧ C.writable vp1 = C.writable vp ∧ C.zone1 vp1 = C.zone1 vp → C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(x_b : BitVec 64), Lemmas.value wp1 (BitVec.toInt abs_usize) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt abs_usize)) * BitVec.toUInt x_b = Lemmas.value vp (BitVec.toInt abs_usize) - Lemmas.value wp (BitVec.toInt abs_usize) ∧ ((0 : ℤ) ≤ BitVec.toUInt x_b ∧ BitVec.toUInt x_b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt abs_usize ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (∀(j : ℤ), C.pelts vp1 j = C.pelts vp j) ∧ Lemmas.value vp1 (BitVec.toInt abs_usize) = Lemmas.value vp (BitVec.toInt abs_usize) ∧ (C.min vp1 = C.min vp ∧ C.max vp1 = C.max vp ∧ C.plength vp1 = C.plength vp) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp → ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ C.valid wp1 (BitVec.toInt abs_usize)) ∧ (∀(wsize : BitVec 32), ((0 : ℤ) ≤ BitVec.toInt wsize ∧ BitVec.toInt wsize ≤ BitVec.toInt abs_usize) ∧ Lemmas.value wp1 (BitVec.toInt wsize) = Lemmas.value wp1 (BitVec.toInt abs_usize) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ (0 : ℤ) < BitVec.toUInt (C.pelts wp1 (C.offset wp1 + BitVec.toInt wsize - (1 : ℤ)))) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt wsize - (1 : ℤ))) ≤ Lemmas.value wp1 (BitVec.toInt wsize)) → (if (0 : ℤ) ≤ BitVec.toInt usize then int'32_in_bounds (-BitVec.toInt wsize) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = -BitVec.toInt wsize → (Z.zones mpz2 v1 = C.zone1 vp1 ∧ (1 : ℤ) ≤ Z.readers mpz2 v1 ∧ C.min vp1 = (0 : ℤ) ∧ C.max vp1 = C.plength vp1) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 v1 = Z.readers mpz2 v1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v1 → Z.readers mpz3 y = Z.readers mpz2 y) → Lemmas.value wp1 (abs (BitVec.toInt o10)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 o10 = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz3 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz3 v1 = (0 : ℤ)) ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ abs (BitVec.toInt o10) ≤ C.plength wp1 ∧ (¬BitVec.toInt o10 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o10) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt o10))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp)) else (Z.zones mpz2 v1 = C.zone1 vp1 ∧ (1 : ℤ) ≤ Z.readers mpz2 v1 ∧ C.min vp1 = (0 : ℤ) ∧ C.max vp1 = C.plength vp1) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 v1 = Z.readers mpz2 v1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v1 → Z.readers mpz3 y = Z.readers mpz2 y) → Lemmas.value wp1 (abs (BitVec.toInt wsize)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 wsize = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz3 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz3 v1 = (0 : ℤ)) ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ abs (BitVec.toInt wsize) ≤ C.plength wp1 ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt wsize))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp))))) else ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ (C.valid wp (BitVec.toInt abs_usize) ∧ C.valid vp (BitVec.toInt abs_usize)) ∧ C.writable wp = true) ∧ (∀(vp1 : C.ptr (BitVec 64)) (wp1 : C.ptr (BitVec 64)), C.offset vp1 = C.offset vp ∧ C.writable vp1 = C.writable vp ∧ C.zone1 vp1 = C.zone1 vp → C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(x_b : BitVec 64), Lemmas.value wp1 (BitVec.toInt abs_usize) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt abs_usize)) * BitVec.toUInt x_b = Lemmas.value wp (BitVec.toInt abs_usize) - Lemmas.value vp (BitVec.toInt abs_usize) ∧ ((0 : ℤ) ≤ BitVec.toUInt x_b ∧ BitVec.toUInt x_b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt abs_usize ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (∀(j : ℤ), C.pelts vp1 j = C.pelts vp j) ∧ Lemmas.value vp1 (BitVec.toInt abs_usize) = Lemmas.value vp (BitVec.toInt abs_usize) ∧ (C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp) ∧ C.min vp1 = C.min vp ∧ C.max vp1 = C.max vp ∧ C.plength vp1 = C.plength vp → ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ C.valid wp1 (BitVec.toInt abs_usize)) ∧ (∀(wsize : BitVec 32), ((0 : ℤ) ≤ BitVec.toInt wsize ∧ BitVec.toInt wsize ≤ BitVec.toInt abs_usize) ∧ Lemmas.value wp1 (BitVec.toInt wsize) = Lemmas.value wp1 (BitVec.toInt abs_usize) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ (0 : ℤ) < BitVec.toUInt (C.pelts wp1 (C.offset wp1 + BitVec.toInt wsize - (1 : ℤ)))) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt wsize - (1 : ℤ))) ≤ Lemmas.value wp1 (BitVec.toInt wsize)) → (if BitVec.toInt usize < (0 : ℤ) then int'32_in_bounds (-BitVec.toInt wsize) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = -BitVec.toInt wsize → (Z.zones mpz2 v1 = C.zone1 vp1 ∧ (1 : ℤ) ≤ Z.readers mpz2 v1 ∧ C.min vp1 = (0 : ℤ) ∧ C.max vp1 = C.plength vp1) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 v1 = Z.readers mpz2 v1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v1 → Z.readers mpz3 y = Z.readers mpz2 y) → Lemmas.value wp1 (abs (BitVec.toInt o10)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 o10 = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz3 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz3 v1 = (0 : ℤ)) ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ abs (BitVec.toInt o10) ≤ C.plength wp1 ∧ (¬BitVec.toInt o10 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o10) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt o10))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp)) else (Z.zones mpz2 v1 = C.zone1 vp1 ∧ (1 : ℤ) ≤ Z.readers mpz2 v1 ∧ C.min vp1 = (0 : ℤ) ∧ C.max vp1 = C.plength vp1) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 v1 = Z.readers mpz2 v1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v1 → Z.readers mpz3 y = Z.readers mpz2 y) → Lemmas.value wp1 (abs (BitVec.toInt wsize)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 wsize = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz3 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz3 v1 = (0 : ℤ)) ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ abs (BitVec.toInt wsize) ≤ C.plength wp1 ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt wsize))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp))))))))) else if Z.mpz_eq v1 w then (0 : ℤ) ≤ Z.readers mpz1 u1 ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(up : C.ptr (BitVec 64)), Z.readers mpz2 u1 = Z.readers mpz1 u1 + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬u1 = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value up (Z.abs_size mpz2 u1) = Z.abs_value_of mpz2 u1 ∧ C.plength up = Z.alloc mpz2 u1 ∧ C.offset up = (0 : ℤ) ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up ∧ C.zone1 up = Z.zones mpz2 u1 → (C.valid up (BitVec.toInt abs_usize) ∧ C.valid wp (BitVec.toInt abs_usize)) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = Compare.compare_int (Lemmas.value up (BitVec.toInt abs_usize)) (Lemmas.value wp (BitVec.toInt abs_usize)) → (if BitVec.toInt o9 < (0 : ℤ) then ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ (C.valid wp (BitVec.toInt abs_usize) ∧ C.valid up (BitVec.toInt abs_usize)) ∧ C.writable wp = true) ∧ (∀(up1 : C.ptr (BitVec 64)) (wp1 : C.ptr (BitVec 64)), C.offset up1 = C.offset up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(x_b : BitVec 64), Lemmas.value wp1 (BitVec.toInt abs_usize) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt abs_usize)) * BitVec.toUInt x_b = Lemmas.value wp (BitVec.toInt abs_usize) - Lemmas.value up (BitVec.toInt abs_usize) ∧ ((0 : ℤ) ≤ BitVec.toUInt x_b ∧ BitVec.toUInt x_b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt abs_usize ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (∀(j : ℤ), C.pelts up1 j = C.pelts up j) ∧ Lemmas.value up1 (BitVec.toInt abs_usize) = Lemmas.value up (BitVec.toInt abs_usize) ∧ (C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp) ∧ C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.plength up1 = C.plength up → ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ C.valid wp1 (BitVec.toInt abs_usize)) ∧ (∀(wsize : BitVec 32), ((0 : ℤ) ≤ BitVec.toInt wsize ∧ BitVec.toInt wsize ≤ BitVec.toInt abs_usize) ∧ Lemmas.value wp1 (BitVec.toInt wsize) = Lemmas.value wp1 (BitVec.toInt abs_usize) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ (0 : ℤ) < BitVec.toUInt (C.pelts wp1 (C.offset wp1 + BitVec.toInt wsize - (1 : ℤ)))) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt wsize - (1 : ℤ))) ≤ Lemmas.value wp1 (BitVec.toInt wsize)) → (if (0 : ℤ) ≤ BitVec.toInt usize then int'32_in_bounds (-BitVec.toInt wsize) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = -BitVec.toInt wsize → (Z.zones mpz2 u1 = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz2 u1 ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 u1 = Z.readers mpz2 u1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u1 → Z.readers mpz3 y = Z.readers mpz2 y) → Lemmas.value wp1 (abs (BitVec.toInt o10)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 o10 = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz3 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz3 v1 = (0 : ℤ)) ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ abs (BitVec.toInt o10) ≤ C.plength wp1 ∧ (¬BitVec.toInt o10 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o10) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt o10))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp)) else (Z.zones mpz2 u1 = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz2 u1 ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 u1 = Z.readers mpz2 u1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u1 → Z.readers mpz3 y = Z.readers mpz2 y) → Lemmas.value wp1 (abs (BitVec.toInt wsize)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 wsize = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz3 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz3 v1 = (0 : ℤ)) ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ abs (BitVec.toInt wsize) ≤ C.plength wp1 ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt wsize))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp))))) else ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ (C.valid up (BitVec.toInt abs_usize) ∧ C.valid wp (BitVec.toInt abs_usize)) ∧ C.writable wp = true) ∧ (∀(up1 : C.ptr (BitVec 64)) (wp1 : C.ptr (BitVec 64)), C.offset up1 = C.offset up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(x_b : BitVec 64), Lemmas.value wp1 (BitVec.toInt abs_usize) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt abs_usize)) * BitVec.toUInt x_b = Lemmas.value up (BitVec.toInt abs_usize) - Lemmas.value wp (BitVec.toInt abs_usize) ∧ ((0 : ℤ) ≤ BitVec.toUInt x_b ∧ BitVec.toUInt x_b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt abs_usize ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (∀(j : ℤ), C.pelts up1 j = C.pelts up j) ∧ Lemmas.value up1 (BitVec.toInt abs_usize) = Lemmas.value up (BitVec.toInt abs_usize) ∧ (C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.plength up1 = C.plength up) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp → ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ C.valid wp1 (BitVec.toInt abs_usize)) ∧ (∀(wsize : BitVec 32), ((0 : ℤ) ≤ BitVec.toInt wsize ∧ BitVec.toInt wsize ≤ BitVec.toInt abs_usize) ∧ Lemmas.value wp1 (BitVec.toInt wsize) = Lemmas.value wp1 (BitVec.toInt abs_usize) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ (0 : ℤ) < BitVec.toUInt (C.pelts wp1 (C.offset wp1 + BitVec.toInt wsize - (1 : ℤ)))) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt wsize - (1 : ℤ))) ≤ Lemmas.value wp1 (BitVec.toInt wsize)) → (if BitVec.toInt usize < (0 : ℤ) then int'32_in_bounds (-BitVec.toInt wsize) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = -BitVec.toInt wsize → (Z.zones mpz2 u1 = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz2 u1 ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 u1 = Z.readers mpz2 u1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u1 → Z.readers mpz3 y = Z.readers mpz2 y) → Lemmas.value wp1 (abs (BitVec.toInt o10)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 o10 = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz3 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz3 v1 = (0 : ℤ)) ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ abs (BitVec.toInt o10) ≤ C.plength wp1 ∧ (¬BitVec.toInt o10 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o10) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt o10))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp)) else (Z.zones mpz2 u1 = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz2 u1 ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 u1 = Z.readers mpz2 u1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u1 → Z.readers mpz3 y = Z.readers mpz2 y) → Lemmas.value wp1 (abs (BitVec.toInt wsize)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 wsize = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz3 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz3 v1 = (0 : ℤ)) ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ abs (BitVec.toInt wsize) ≤ C.plength wp1 ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt wsize))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp))))))))) else (0 : ℤ) ≤ Z.readers mpz1 u1 ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(up : C.ptr (BitVec 64)), Z.readers mpz2 u1 = Z.readers mpz1 u1 + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬u1 = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value up (Z.abs_size mpz2 u1) = Z.abs_value_of mpz2 u1 ∧ C.plength up = Z.alloc mpz2 u1 ∧ C.offset up = (0 : ℤ) ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up ∧ C.zone1 up = Z.zones mpz2 u1 → (0 : ℤ) ≤ Z.readers mpz2 v1 ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → (∀(vp : C.ptr (BitVec 64)), Z.readers mpz3 v1 = Z.readers mpz2 v1 + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬v1 = y → Z.readers mpz3 y = Z.readers mpz2 y) ∧ Lemmas.value vp (Z.abs_size mpz3 v1) = Z.abs_value_of mpz3 v1 ∧ C.plength vp = Z.alloc mpz3 v1 ∧ C.offset vp = (0 : ℤ) ∧ C.min vp = (0 : ℤ) ∧ C.max vp = C.plength vp ∧ C.zone1 vp = Z.zones mpz3 v1 → (C.valid up (BitVec.toInt abs_usize) ∧ C.valid vp (BitVec.toInt abs_usize)) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = Compare.compare_int (Lemmas.value up (BitVec.toInt abs_usize)) (Lemmas.value vp (BitVec.toInt abs_usize)) → (if BitVec.toInt o9 < (0 : ℤ) then ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ (C.valid wp (BitVec.toInt abs_usize) ∧ C.valid vp (BitVec.toInt abs_usize) ∧ C.valid up (BitVec.toInt abs_usize)) ∧ C.writable wp = true) ∧ (∀(vp1 : C.ptr (BitVec 64)) (up1 : C.ptr (BitVec 64)) (wp1 : C.ptr (BitVec 64)), C.offset vp1 = C.offset vp ∧ C.writable vp1 = C.writable vp ∧ C.zone1 vp1 = C.zone1 vp → C.offset up1 = C.offset up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(x_b : BitVec 64), Lemmas.value wp1 (BitVec.toInt abs_usize) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt abs_usize)) * BitVec.toUInt x_b = Lemmas.value vp (BitVec.toInt abs_usize) - Lemmas.value up (BitVec.toInt abs_usize) ∧ ((0 : ℤ) ≤ BitVec.toUInt x_b ∧ BitVec.toUInt x_b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt abs_usize ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (∀(j : ℤ), C.pelts vp1 j = C.pelts vp j) ∧ (∀(j : ℤ), C.pelts up1 j = C.pelts up j) ∧ Lemmas.value vp1 (BitVec.toInt abs_usize) = Lemmas.value vp (BitVec.toInt abs_usize) ∧ Lemmas.value up1 (BitVec.toInt abs_usize) = Lemmas.value up (BitVec.toInt abs_usize) ∧ (C.min vp1 = C.min vp ∧ C.max vp1 = C.max vp ∧ C.plength vp1 = C.plength vp) ∧ (C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.plength up1 = C.plength up) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp → ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ C.valid wp1 (BitVec.toInt abs_usize)) ∧ (∀(wsize : BitVec 32), ((0 : ℤ) ≤ BitVec.toInt wsize ∧ BitVec.toInt wsize ≤ BitVec.toInt abs_usize) ∧ Lemmas.value wp1 (BitVec.toInt wsize) = Lemmas.value wp1 (BitVec.toInt abs_usize) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ (0 : ℤ) < BitVec.toUInt (C.pelts wp1 (C.offset wp1 + BitVec.toInt wsize - (1 : ℤ)))) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt wsize - (1 : ℤ))) ≤ Lemmas.value wp1 (BitVec.toInt wsize)) → (if (0 : ℤ) ≤ BitVec.toInt usize then int'32_in_bounds (-BitVec.toInt wsize) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = -BitVec.toInt wsize → (Z.zones mpz3 u1 = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz3 u1 ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz4 : Z.mpz_memo), Z.abs_value_of mpz4 = Z.abs_value_of mpz3 ∧ Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → Z.readers mpz4 u1 = Z.readers mpz3 u1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u1 → Z.readers mpz4 y = Z.readers mpz3 y) → (Z.zones mpz4 v1 = C.zone1 vp1 ∧ (1 : ℤ) ≤ Z.readers mpz4 v1 ∧ C.min vp1 = (0 : ℤ) ∧ C.max vp1 = C.plength vp1) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 v1 = Z.readers mpz4 v1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v1 → Z.readers mpz5 y = Z.readers mpz4 y) → Lemmas.value wp1 (abs (BitVec.toInt o10)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 o10 = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz5 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz5 v1 = (0 : ℤ)) ∧ Z.readers mpz5 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz5 mpz) ∧ abs (BitVec.toInt o10) ≤ C.plength wp1 ∧ (¬BitVec.toInt o10 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o10) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt o10))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp))) else (Z.zones mpz3 u1 = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz3 u1 ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz4 : Z.mpz_memo), Z.abs_value_of mpz4 = Z.abs_value_of mpz3 ∧ Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → Z.readers mpz4 u1 = Z.readers mpz3 u1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u1 → Z.readers mpz4 y = Z.readers mpz3 y) → (Z.zones mpz4 v1 = C.zone1 vp1 ∧ (1 : ℤ) ≤ Z.readers mpz4 v1 ∧ C.min vp1 = (0 : ℤ) ∧ C.max vp1 = C.plength vp1) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 v1 = Z.readers mpz4 v1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v1 → Z.readers mpz5 y = Z.readers mpz4 y) → Lemmas.value wp1 (abs (BitVec.toInt wsize)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 wsize = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz5 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz5 v1 = (0 : ℤ)) ∧ Z.readers mpz5 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz5 mpz) ∧ abs (BitVec.toInt wsize) ≤ C.plength wp1 ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt wsize))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp)))))) else ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ (C.valid wp (BitVec.toInt abs_usize) ∧ C.valid up (BitVec.toInt abs_usize) ∧ C.valid vp (BitVec.toInt abs_usize)) ∧ C.writable wp = true) ∧ (∀(vp1 : C.ptr (BitVec 64)) (up1 : C.ptr (BitVec 64)) (wp1 : C.ptr (BitVec 64)), C.offset vp1 = C.offset vp ∧ C.writable vp1 = C.writable vp ∧ C.zone1 vp1 = C.zone1 vp → C.offset up1 = C.offset up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(x_b : BitVec 64), Lemmas.value wp1 (BitVec.toInt abs_usize) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt abs_usize)) * BitVec.toUInt x_b = Lemmas.value up (BitVec.toInt abs_usize) - Lemmas.value vp (BitVec.toInt abs_usize) ∧ ((0 : ℤ) ≤ BitVec.toUInt x_b ∧ BitVec.toUInt x_b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt abs_usize ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (∀(j : ℤ), C.pelts up1 j = C.pelts up j) ∧ (∀(j : ℤ), C.pelts vp1 j = C.pelts vp j) ∧ Lemmas.value up1 (BitVec.toInt abs_usize) = Lemmas.value up (BitVec.toInt abs_usize) ∧ Lemmas.value vp1 (BitVec.toInt abs_usize) = Lemmas.value vp (BitVec.toInt abs_usize) ∧ (C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.plength up1 = C.plength up) ∧ (C.min vp1 = C.min vp ∧ C.max vp1 = C.max vp ∧ C.plength vp1 = C.plength vp) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp → ((0 : ℤ) ≤ BitVec.toInt abs_usize ∧ C.valid wp1 (BitVec.toInt abs_usize)) ∧ (∀(wsize : BitVec 32), ((0 : ℤ) ≤ BitVec.toInt wsize ∧ BitVec.toInt wsize ≤ BitVec.toInt abs_usize) ∧ Lemmas.value wp1 (BitVec.toInt wsize) = Lemmas.value wp1 (BitVec.toInt abs_usize) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ (0 : ℤ) < BitVec.toUInt (C.pelts wp1 (C.offset wp1 + BitVec.toInt wsize - (1 : ℤ)))) ∧ (BitVec.toInt wsize = (0 : ℤ) ∨ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt wsize - (1 : ℤ))) ≤ Lemmas.value wp1 (BitVec.toInt wsize)) → (if BitVec.toInt usize < (0 : ℤ) then int'32_in_bounds (-BitVec.toInt wsize) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = -BitVec.toInt wsize → (Z.zones mpz3 u1 = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz3 u1 ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz4 : Z.mpz_memo), Z.abs_value_of mpz4 = Z.abs_value_of mpz3 ∧ Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → Z.readers mpz4 u1 = Z.readers mpz3 u1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u1 → Z.readers mpz4 y = Z.readers mpz3 y) → (Z.zones mpz4 v1 = C.zone1 vp1 ∧ (1 : ℤ) ≤ Z.readers mpz4 v1 ∧ C.min vp1 = (0 : ℤ) ∧ C.max vp1 = C.plength vp1) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 v1 = Z.readers mpz4 v1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v1 → Z.readers mpz5 y = Z.readers mpz4 y) → Lemmas.value wp1 (abs (BitVec.toInt o10)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 o10 = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz5 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz5 v1 = (0 : ℤ)) ∧ Z.readers mpz5 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz5 mpz) ∧ abs (BitVec.toInt o10) ≤ C.plength wp1 ∧ (¬BitVec.toInt o10 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o10) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt o10))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp))) else (Z.zones mpz3 u1 = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz3 u1 ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz4 : Z.mpz_memo), Z.abs_value_of mpz4 = Z.abs_value_of mpz3 ∧ Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → Z.readers mpz4 u1 = Z.readers mpz3 u1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u1 → Z.readers mpz4 y = Z.readers mpz3 y) → (Z.zones mpz4 v1 = C.zone1 vp1 ∧ (1 : ℤ) ≤ Z.readers mpz4 v1 ∧ C.min vp1 = (0 : ℤ) ∧ C.max vp1 = C.plength vp1) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 v1 = Z.readers mpz4 v1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v1 → Z.readers mpz5 y = Z.readers mpz4 y) → Lemmas.value wp1 (abs (BitVec.toInt wsize)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 wsize = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz5 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz5 v1 = (0 : ℤ)) ∧ Z.readers mpz5 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz5 mpz) ∧ abs (BitVec.toInt wsize) ≤ C.plength wp1 ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt wsize))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp)))))))))))))) ∧ (∀(wp1 : C.ptr (BitVec 64)) (wsize : BitVec 32) (mpz2 : Z.mpz_memo), C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → Lemmas.value wp1 (abs (BitVec.toInt wsize)) = abs (Z.abs_value_of mpz1 u1 - Z.abs_value_of mpz1 v1) ∧ Z.sgn_value wp1 wsize = Z.value_of u mpz - Z.value_of v mpz ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz2 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz2 v1 = (0 : ℤ)) ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz2 mpz) ∧ abs (BitVec.toInt wsize) ≤ C.plength wp1 ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt wsize))) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp → (Z.zones mpz2 w = C.zone1 wp1 ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ C.offset wp1 = (0 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ abs (BitVec.toInt wsize) ≤ C.plength wp1 ∧ C.plength wp1 = Z.alloc mpz2 w ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt wsize)))) ∧ (∀(mpz3 : Z.mpz_memo), Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.readers mpz3 = Z.readers mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz3 mpz2) ∧ (Z.sgn mpz3 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt wsize) ∧ (Z.sgn mpz3 w = -(1 : ℤ)) = (BitVec.toInt wsize < (0 : ℤ)) ∧ Z.abs_size mpz3 w = abs (BitVec.toInt wsize) ∧ Z.abs_value_of mpz3 w = Lemmas.value wp1 (abs (BitVec.toInt wsize)) → (Z.zones mpz3 w = C.zone1 wp1 ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ Z.abs_value_of mpz3 w = Lemmas.value wp1 (Z.abs_size mpz3 w)) ∧ (∀(mpz4 : Z.mpz_memo), Z.abs_value_of mpz4 = Z.abs_value_of mpz3 ∧ Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → Z.readers mpz4 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz4 y = Z.readers mpz3 y) → Z.value_of w mpz4 = Z.value_of u mpz - Z.value_of v mpz ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz4 mpz) ∧ Z.readers mpz4 w = (0 : ℤ) ∧ Z.readers mpz4 u = (0 : ℤ) ∧ Z.readers mpz4 v = (0 : ℤ)))) else (if Z.mpz_eq u1 w then (0 : ℤ) ≤ Z.readers mpz1 v1 ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(vp : C.ptr (BitVec 64)), Z.readers mpz2 v1 = Z.readers mpz1 v1 + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬v1 = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value vp (Z.abs_size mpz2 v1) = Z.abs_value_of mpz2 v1 ∧ C.plength vp = Z.alloc mpz2 v1 ∧ C.offset vp = (0 : ℤ) ∧ C.min vp = (0 : ℤ) ∧ C.max vp = C.plength vp ∧ C.zone1 vp = Z.zones mpz2 v1 → (((0 : ℤ) ≤ BitVec.toInt abs_vsize ∧ BitVec.toInt abs_vsize ≤ BitVec.toInt abs_usize) ∧ (C.valid wp (BitVec.toInt abs_usize) ∧ C.valid vp (BitVec.toInt abs_vsize)) ∧ C.writable wp = true) ∧ (∀(vp1 : C.ptr (BitVec 64)) (wp1 : C.ptr (BitVec 64)), C.offset vp1 = C.offset vp ∧ C.writable vp1 = C.writable vp ∧ C.zone1 vp1 = C.zone1 vp → C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(o8 : BitVec 64), Lemmas.value wp1 (BitVec.toInt abs_usize) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt abs_usize)) * BitVec.toUInt o8 = Lemmas.value wp (BitVec.toInt abs_usize) + Lemmas.value vp (BitVec.toInt abs_vsize) ∧ ((0 : ℤ) ≤ BitVec.toUInt o8 ∧ BitVec.toUInt o8 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt abs_usize ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (∀(j : ℤ), C.pelts vp1 j = C.pelts vp j) ∧ Lemmas.value vp1 (BitVec.toInt abs_vsize) = Lemmas.value vp (BitVec.toInt abs_vsize) ∧ (C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp) ∧ C.min vp1 = C.min vp ∧ C.max vp1 = C.max vp ∧ C.plength vp1 = C.plength vp → (Z.zones mpz2 v1 = C.zone1 vp1 ∧ (1 : ℤ) ≤ Z.readers mpz2 v1 ∧ C.min vp1 = (0 : ℤ) ∧ C.max vp1 = C.plength vp1) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 v1 = Z.readers mpz2 v1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v1 → Z.readers mpz3 y = Z.readers mpz2 y) → ((C.min wp1 ≤ C.offset wp1 + BitVec.toInt abs_usize ∧ C.offset wp1 + BitVec.toInt abs_usize < C.max wp1) ∧ C.writable wp1 = true) ∧ (∀(wp2 : C.ptr (BitVec 64)), List.length (C.data wp2) = List.length (C.data wp1) ∧ C.offset wp2 = C.offset wp1 ∧ C.min wp2 = C.min wp1 ∧ C.max wp2 = C.max wp1 ∧ C.writable wp2 = C.writable wp1 ∧ C.zone1 wp2 = C.zone1 wp1 → C.pelts wp2 = Function.update (C.pelts wp1) (C.offset wp2 + BitVec.toInt abs_usize) o8 ∧ C.pelts wp2 (C.offset wp2 + BitVec.toInt abs_usize) = o8 → (BitVec.toUInt o8 ≤ (2147483647 : ℤ) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toUInt o8 → int'32_in_bounds (BitVec.toInt abs_usize + BitVec.toInt o9) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt abs_usize + BitVec.toInt o9 → (if BitVec.toUInt o8 = (0 : ℤ) then o10 = abs_usize else BitVec.toInt o10 = BitVec.toInt abs_usize + (1 : ℤ))))) ∧ (∀(wsize : BitVec 32), (if BitVec.toUInt o8 = (0 : ℤ) then wsize = abs_usize else BitVec.toInt wsize = BitVec.toInt abs_usize + (1 : ℤ)) → Lemmas.value wp2 (abs (BitVec.toInt wsize)) = abs (Z.abs_value_of mpz1 u1 + Z.abs_value_of mpz1 v1) ∧ Lemmas.value wp2 (BitVec.toInt wsize) = abs (Z.value_of u mpz - Z.value_of v mpz) ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz3 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz3 v1 = (0 : ℤ)) ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp2 (abs (BitVec.toInt wsize))) ∧ (C.min wp2 = C.min wp ∧ C.max wp2 = C.max wp ∧ C.plength wp2 = C.plength wp) ∧ BitVec.toInt abs_usize ≤ BitVec.toInt wsize ∧ BitVec.toInt wsize ≤ C.plength wp2))))))) else if Z.mpz_eq v1 w then (0 : ℤ) ≤ Z.readers mpz1 u1 ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(up : C.ptr (BitVec 64)), Z.readers mpz2 u1 = Z.readers mpz1 u1 + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬u1 = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value up (Z.abs_size mpz2 u1) = Z.abs_value_of mpz2 u1 ∧ C.plength up = Z.alloc mpz2 u1 ∧ C.offset up = (0 : ℤ) ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up ∧ C.zone1 up = Z.zones mpz2 u1 → (((0 : ℤ) ≤ BitVec.toInt abs_vsize ∧ BitVec.toInt abs_vsize ≤ BitVec.toInt abs_usize) ∧ (C.valid up (BitVec.toInt abs_usize) ∧ C.valid wp (BitVec.toInt abs_usize)) ∧ C.writable wp = true) ∧ (∀(up1 : C.ptr (BitVec 64)) (wp1 : C.ptr (BitVec 64)), C.offset up1 = C.offset up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(o8 : BitVec 64), Lemmas.value wp1 (BitVec.toInt abs_usize) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt abs_usize)) * BitVec.toUInt o8 = Lemmas.value up (BitVec.toInt abs_usize) + Lemmas.value wp (BitVec.toInt abs_vsize) ∧ ((0 : ℤ) ≤ BitVec.toUInt o8 ∧ BitVec.toUInt o8 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt abs_usize ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (∀(j : ℤ), C.pelts up1 j = C.pelts up j) ∧ Lemmas.value up1 (BitVec.toInt abs_usize) = Lemmas.value up (BitVec.toInt abs_usize) ∧ (C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.plength up1 = C.plength up) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp → (Z.zones mpz2 u1 = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz2 u1 ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 u1 = Z.readers mpz2 u1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u1 → Z.readers mpz3 y = Z.readers mpz2 y) → ((C.min wp1 ≤ C.offset wp1 + BitVec.toInt abs_usize ∧ C.offset wp1 + BitVec.toInt abs_usize < C.max wp1) ∧ C.writable wp1 = true) ∧ (∀(wp2 : C.ptr (BitVec 64)), List.length (C.data wp2) = List.length (C.data wp1) ∧ C.offset wp2 = C.offset wp1 ∧ C.min wp2 = C.min wp1 ∧ C.max wp2 = C.max wp1 ∧ C.writable wp2 = C.writable wp1 ∧ C.zone1 wp2 = C.zone1 wp1 → C.pelts wp2 = Function.update (C.pelts wp1) (C.offset wp2 + BitVec.toInt abs_usize) o8 ∧ C.pelts wp2 (C.offset wp2 + BitVec.toInt abs_usize) = o8 → (BitVec.toUInt o8 ≤ (2147483647 : ℤ) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toUInt o8 → int'32_in_bounds (BitVec.toInt abs_usize + BitVec.toInt o9) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt abs_usize + BitVec.toInt o9 → (if BitVec.toUInt o8 = (0 : ℤ) then o10 = abs_usize else BitVec.toInt o10 = BitVec.toInt abs_usize + (1 : ℤ))))) ∧ (∀(wsize : BitVec 32), (if BitVec.toUInt o8 = (0 : ℤ) then wsize = abs_usize else BitVec.toInt wsize = BitVec.toInt abs_usize + (1 : ℤ)) → Lemmas.value wp2 (abs (BitVec.toInt wsize)) = abs (Z.abs_value_of mpz1 u1 + Z.abs_value_of mpz1 v1) ∧ Lemmas.value wp2 (BitVec.toInt wsize) = abs (Z.value_of u mpz - Z.value_of v mpz) ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz3 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz3 v1 = (0 : ℤ)) ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz3 mpz) ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp2 (abs (BitVec.toInt wsize))) ∧ (C.min wp2 = C.min wp ∧ C.max wp2 = C.max wp ∧ C.plength wp2 = C.plength wp) ∧ BitVec.toInt abs_usize ≤ BitVec.toInt wsize ∧ BitVec.toInt wsize ≤ C.plength wp2))))))) else (0 : ℤ) ≤ Z.readers mpz1 u1 ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(up : C.ptr (BitVec 64)), Z.readers mpz2 u1 = Z.readers mpz1 u1 + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬u1 = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value up (Z.abs_size mpz2 u1) = Z.abs_value_of mpz2 u1 ∧ C.plength up = Z.alloc mpz2 u1 ∧ C.offset up = (0 : ℤ) ∧ C.min up = (0 : ℤ) ∧ C.max up = C.plength up ∧ C.zone1 up = Z.zones mpz2 u1 → (0 : ℤ) ≤ Z.readers mpz2 v1 ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → (∀(vp : C.ptr (BitVec 64)), Z.readers mpz3 v1 = Z.readers mpz2 v1 + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬v1 = y → Z.readers mpz3 y = Z.readers mpz2 y) ∧ Lemmas.value vp (Z.abs_size mpz3 v1) = Z.abs_value_of mpz3 v1 ∧ C.plength vp = Z.alloc mpz3 v1 ∧ C.offset vp = (0 : ℤ) ∧ C.min vp = (0 : ℤ) ∧ C.max vp = C.plength vp ∧ C.zone1 vp = Z.zones mpz3 v1 → (((0 : ℤ) ≤ BitVec.toInt abs_vsize ∧ BitVec.toInt abs_vsize ≤ BitVec.toInt abs_usize) ∧ (C.valid wp (BitVec.toInt abs_usize) ∧ C.valid up (BitVec.toInt abs_usize) ∧ C.valid vp (BitVec.toInt abs_vsize)) ∧ C.writable wp = true) ∧ (∀(vp1 : C.ptr (BitVec 64)) (up1 : C.ptr (BitVec 64)) (wp1 : C.ptr (BitVec 64)), C.offset vp1 = C.offset vp ∧ C.writable vp1 = C.writable vp ∧ C.zone1 vp1 = C.zone1 vp → C.offset up1 = C.offset up ∧ C.writable up1 = C.writable up ∧ C.zone1 up1 = C.zone1 up → C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → (∀(o8 : BitVec 64), Lemmas.value wp1 (BitVec.toInt abs_usize) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt abs_usize)) * BitVec.toUInt o8 = Lemmas.value up (BitVec.toInt abs_usize) + Lemmas.value vp (BitVec.toInt abs_vsize) ∧ ((0 : ℤ) ≤ BitVec.toUInt o8 ∧ BitVec.toUInt o8 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset wp1 ∨ C.offset wp1 + BitVec.toInt abs_usize ≤ j → C.pelts wp1 j = C.pelts wp j) ∧ (∀(j : ℤ), C.pelts up1 j = C.pelts up j) ∧ (∀(j : ℤ), C.pelts vp1 j = C.pelts vp j) ∧ Lemmas.value up1 (BitVec.toInt abs_usize) = Lemmas.value up (BitVec.toInt abs_usize) ∧ Lemmas.value vp1 (BitVec.toInt abs_vsize) = Lemmas.value vp (BitVec.toInt abs_vsize) ∧ (C.min up1 = C.min up ∧ C.max up1 = C.max up ∧ C.plength up1 = C.plength up) ∧ (C.min vp1 = C.min vp ∧ C.max vp1 = C.max vp ∧ C.plength vp1 = C.plength vp) ∧ C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp → (Z.zones mpz3 u1 = C.zone1 up1 ∧ (1 : ℤ) ≤ Z.readers mpz3 u1 ∧ C.min up1 = (0 : ℤ) ∧ C.max up1 = C.plength up1) ∧ (∀(mpz4 : Z.mpz_memo), Z.abs_value_of mpz4 = Z.abs_value_of mpz3 ∧ Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → Z.readers mpz4 u1 = Z.readers mpz3 u1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = u1 → Z.readers mpz4 y = Z.readers mpz3 y) → (Z.zones mpz4 v1 = C.zone1 vp1 ∧ (1 : ℤ) ≤ Z.readers mpz4 v1 ∧ C.min vp1 = (0 : ℤ) ∧ C.max vp1 = C.plength vp1) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 v1 = Z.readers mpz4 v1 - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = v1 → Z.readers mpz5 y = Z.readers mpz4 y) → ((C.min wp1 ≤ C.offset wp1 + BitVec.toInt abs_usize ∧ C.offset wp1 + BitVec.toInt abs_usize < C.max wp1) ∧ C.writable wp1 = true) ∧ (∀(wp2 : C.ptr (BitVec 64)), List.length (C.data wp2) = List.length (C.data wp1) ∧ C.offset wp2 = C.offset wp1 ∧ C.min wp2 = C.min wp1 ∧ C.max wp2 = C.max wp1 ∧ C.writable wp2 = C.writable wp1 ∧ C.zone1 wp2 = C.zone1 wp1 → C.pelts wp2 = Function.update (C.pelts wp1) (C.offset wp2 + BitVec.toInt abs_usize) o8 ∧ C.pelts wp2 (C.offset wp2 + BitVec.toInt abs_usize) = o8 → (BitVec.toUInt o8 ≤ (2147483647 : ℤ) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toUInt o8 → int'32_in_bounds (BitVec.toInt abs_usize + BitVec.toInt o9) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt abs_usize + BitVec.toInt o9 → (if BitVec.toUInt o8 = (0 : ℤ) then o10 = abs_usize else BitVec.toInt o10 = BitVec.toInt abs_usize + (1 : ℤ))))) ∧ (∀(wsize : BitVec 32), (if BitVec.toUInt o8 = (0 : ℤ) then wsize = abs_usize else BitVec.toInt wsize = BitVec.toInt abs_usize + (1 : ℤ)) → Lemmas.value wp2 (abs (BitVec.toInt wsize)) = abs (Z.abs_value_of mpz1 u1 + Z.abs_value_of mpz1 v1) ∧ Lemmas.value wp2 (BitVec.toInt wsize) = abs (Z.value_of u mpz - Z.value_of v mpz) ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz5 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz5 v1 = (0 : ℤ)) ∧ Z.readers mpz5 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz5 mpz) ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp2 (abs (BitVec.toInt wsize))) ∧ (C.min wp2 = C.min wp ∧ C.max wp2 = C.max wp ∧ C.plength wp2 = C.plength wp) ∧ BitVec.toInt abs_usize ≤ BitVec.toInt wsize ∧ BitVec.toInt wsize ≤ C.plength wp2))))))))))) ∧ (∀(wp1 : C.ptr (BitVec 64)) (wsize : BitVec 32) (mpz2 : Z.mpz_memo), C.offset wp1 = C.offset wp ∧ C.writable wp1 = C.writable wp ∧ C.zone1 wp1 = C.zone1 wp → Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → Lemmas.value wp1 (abs (BitVec.toInt wsize)) = abs (Z.abs_value_of mpz1 u1 + Z.abs_value_of mpz1 v1) ∧ Lemmas.value wp1 (BitVec.toInt wsize) = abs (Z.value_of u mpz - Z.value_of v mpz) ∧ (Z.mpz_eq u1 w ∨ Z.readers mpz2 u1 = (0 : ℤ)) ∧ (Z.mpz_eq v1 w ∨ Z.readers mpz2 v1 = (0 : ℤ)) ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz2 mpz) ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt wsize))) ∧ (C.min wp1 = C.min wp ∧ C.max wp1 = C.max wp ∧ C.plength wp1 = C.plength wp) ∧ BitVec.toInt abs_usize ≤ BitVec.toInt wsize ∧ BitVec.toInt wsize ≤ C.plength wp1 → (if BitVec.toInt usize < (0 : ℤ) then int'32_in_bounds (-BitVec.toInt wsize) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = -BitVec.toInt wsize → (Z.zones mpz2 w = C.zone1 wp1 ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ C.offset wp1 = (0 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ abs (BitVec.toInt o8) ≤ C.plength wp1 ∧ C.plength wp1 = Z.alloc mpz2 w ∧ (¬BitVec.toInt o8 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o8) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt o8)))) ∧ (∀(mpz3 : Z.mpz_memo), Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.readers mpz3 = Z.readers mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz3 mpz2) ∧ (Z.sgn mpz3 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o8) ∧ (Z.sgn mpz3 w = -(1 : ℤ)) = (BitVec.toInt o8 < (0 : ℤ)) ∧ Z.abs_size mpz3 w = abs (BitVec.toInt o8) ∧ Z.abs_value_of mpz3 w = Lemmas.value wp1 (abs (BitVec.toInt o8)) → (Z.zones mpz3 w = C.zone1 wp1 ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ Z.abs_value_of mpz3 w = Lemmas.value wp1 (Z.abs_size mpz3 w)) ∧ (∀(mpz4 : Z.mpz_memo), Z.abs_value_of mpz4 = Z.abs_value_of mpz3 ∧ Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → Z.readers mpz4 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz4 y = Z.readers mpz3 y) → Z.value_of w mpz4 = Z.value_of u mpz - Z.value_of v mpz ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz4 mpz) ∧ Z.readers mpz4 w = (0 : ℤ) ∧ Z.readers mpz4 u = (0 : ℤ) ∧ Z.readers mpz4 v = (0 : ℤ)))) else (Z.zones mpz2 w = C.zone1 wp1 ∧ Z.readers mpz2 w = -(1 : ℤ) ∧ C.offset wp1 = (0 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ abs (BitVec.toInt wsize) ≤ C.plength wp1 ∧ C.plength wp1 = Z.alloc mpz2 w ∧ (¬BitVec.toInt wsize = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt wsize) - (1 : ℤ))) ≤ Lemmas.value wp1 (abs (BitVec.toInt wsize)))) ∧ (∀(mpz3 : Z.mpz_memo), Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.readers mpz3 = Z.readers mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → (∀(y : Z.mpz_ptr), ¬y = w → Z.mpz_unchanged y mpz3 mpz2) ∧ (Z.sgn mpz3 w = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt wsize) ∧ (Z.sgn mpz3 w = -(1 : ℤ)) = (BitVec.toInt wsize < (0 : ℤ)) ∧ Z.abs_size mpz3 w = abs (BitVec.toInt wsize) ∧ Z.abs_value_of mpz3 w = Lemmas.value wp1 (abs (BitVec.toInt wsize)) → (Z.zones mpz3 w = C.zone1 wp1 ∧ Z.readers mpz3 w = -(1 : ℤ) ∧ C.min wp1 = (0 : ℤ) ∧ C.max wp1 = C.plength wp1 ∧ Z.abs_value_of mpz3 w = Lemmas.value wp1 (Z.abs_size mpz3 w)) ∧ (∀(mpz4 : Z.mpz_memo), Z.abs_value_of mpz4 = Z.abs_value_of mpz3 ∧ Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.abs_size mpz4 = Z.abs_size mpz3 ∧ Z.sgn mpz4 = Z.sgn mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → Z.readers mpz4 w = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = w → Z.readers mpz4 y = Z.readers mpz3 y) → Z.value_of w mpz4 = Z.value_of u mpz - Z.value_of v mpz ∧ (∀(x : Z.mpz_ptr), ¬x = w → Z.mpz_unchanged x mpz4 mpz) ∧ Z.readers mpz4 w = (0 : ℤ) ∧ Z.readers mpz4 u = (0 : ℤ) ∧ Z.readers mpz4 v = (0 : ℤ))))))))))))))))
  := sorry
end mpz_sub_Zsub_wmpz_subqtvc
