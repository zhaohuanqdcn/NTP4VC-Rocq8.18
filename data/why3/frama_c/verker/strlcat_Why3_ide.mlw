(* ---------------------------------------------------------- *)
(* --- Post-condition (file src/strlcat.c, line 9) in 'strlcat' --- *)
(* ---------------------------------------------------------- *)
theory VCstrlcat_post
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Compound.Compound
use import A_Strlen.A_Strlen
use import Cint.Cint

(*
goal WP "expl:Post-condition (file src/strlcat.c, line 9) in 'strlcat'":
*)
goal goal0:
  forall i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a_1 a : addr.
  let x = (l_strlen t_2 a) in
  let x_1 = (l_strlen t_2 a_1) in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = (to_uint64 (i_1 - x_1)) in
  let x_3 = x + x_1 in
  let a_3 = (havoc t_1 t_2 a_2 i) in
  let a_4 = a_3[((shift_sint8 a_1 (i + x_1))) <- 0] in
  let x_4 = (l_strlen a_4 a_1) in
  let x_5 = (to_uint64 x_3) in
  (t_2[(shift_sint8 a x)] = 0) ->
  (t_2[a_2] = 0) ->
  (x_1 < i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (i < x_2) ->
  (x_3 <= 18446744073709551615) ->
  ((linked t)) ->
  ((sconst t_2)) ->
  ((is_uint64 i)) ->
  ((is_uint64 i_1)) ->
  ((p_valid_str t t_2 a)) ->
  ((p_valid_str t t_2 a_1)) ->
  ((is_uint64 x)) ->
  ((is_uint64 x_1)) ->
  ((valid_rd t ((shift_sint8 a 0)) i)) ->
  ((valid_rw t ((shift_sint8 a_1 0)) (1 + i_1))) ->
  ((valid_rw t a_2 i)) ->
  ((p_valid_str t t_2 a_2)) ->
  ((p_valid_str t a_4 a_1)) ->
  ((p_valid_str t a_4 a_2)) ->
  (if (x_2 <= x) then (((to_uint64 (x_2 - 1))) = i) else (x = i)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x) ->
   (t_2[(shift_sint8 a i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x_1) ->
   (t_2[(shift_sint8 a_1 i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (a_3[(shift_sint8 a_1 (i_2 + x_1))] = a_3[(shift_sint8 a i_2)])) ->
  ((x_4 <= x_5) /\ (x_5 <= (((l_strlen a_4 a)) + x_4)))

end

(* ---------------------------------------------------------- *)
(* --- Assertion (file src/strlcat.c, line 23)            --- *)
(* ---------------------------------------------------------- *)
theory VCstrlcat_assert
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Compound.Compound
use import A_Strlen.A_Strlen
use import Cint.Cint

(*
goal WP "expl:Assertion (file src/strlcat.c, line 23)":
*)
goal goal1:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = (l_strlen t_1 a) in
  let x_1 = (l_strlen t_1 a_1) in
  let a_2 = (shift_sint8 a_1 x_1) in
  (t_1[(shift_sint8 a x)] = 0) ->
  (t_1[a_2] = 0) ->
  (x_1 < i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  ((x + x_1) <= 18446744073709551615) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint64 i)) ->
  ((p_valid_str t t_1 a)) ->
  ((p_valid_str t t_1 a_1)) ->
  ((is_uint64 x)) ->
  ((is_uint64 x_1)) ->
  ((valid_rw t ((shift_sint8 a_1 0)) (1 + i))) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < x) ->
   (t_1[(shift_sint8 a i_1)] <> 0)) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < x_1) ->
   (t_1[(shift_sint8 a_1 i_1)] <> 0)) ->
  ((p_valid_str t t_1 a_2))

end

(* ---------------------------------------------------------- *)
(* --- Assertion (file src/strlcat.c, line 29)            --- *)
(* ---------------------------------------------------------- *)
theory VCstrlcat_assert_4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Compound.Compound
use import A_Strlen.A_Strlen
use import Cint.Cint

(*
goal WP "expl:Assertion (file src/strlcat.c, line 29)":
*)
goal goal2:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = (l_strlen t_1 a) in
  let x_1 = (l_strlen t_1 a_1) in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = (to_uint64 (i - x_1)) in
  (t_1[(shift_sint8 a x)] = 0) ->
  (t_1[a_2] = 0) ->
  (x_1 < i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (x_2 <= x) ->
  ((x + x_1) <= 18446744073709551615) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint64 i)) ->
  ((p_valid_str t t_1 a)) ->
  ((p_valid_str t t_1 a_1)) ->
  ((is_uint64 x)) ->
  ((is_uint64 x_1)) ->
  ((valid_rw t ((shift_sint8 a_1 0)) (1 + i))) ->
  ((p_valid_str t t_1 a_2)) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < x) ->
   (t_1[(shift_sint8 a i_1)] <> 0)) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < x_1) ->
   (t_1[(shift_sint8 a_1 i_1)] <> 0)) ->
  (((to_uint64 (x_2 - 1))) < x_2)

end

(* ---------------------------------------------------------- *)
(* --- Assertion (file src/strlcat.c, line 32)            --- *)
(* ---------------------------------------------------------- *)
theory VCstrlcat_assert_5
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Compound.Compound
use import A_Strlen.A_Strlen
use import Cint.Cint

(*
goal WP "expl:Assertion (file src/strlcat.c, line 32)":
*)
goal goal3:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a_1 a : addr.
  let x = (l_strlen t_2 a) in
  let x_1 = (l_strlen t_2 a_1) in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = (to_uint64 (i_2 - x_1)) in
  let a_3 = (havoc t_1 t_2 a_2 i) in
  (t_2[(shift_sint8 a x)] = 0) ->
  (t_2[a_2] = 0) ->
  (0 <= i_1) ->
  (i_1 < i) ->
  (x_1 < i_2) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (i < x_2) ->
  ((x + x_1) <= 18446744073709551615) ->
  ((linked t)) ->
  ((sconst t_2)) ->
  ((is_uint64 i)) ->
  ((is_uint64 i_2)) ->
  ((p_valid_str t t_2 a)) ->
  ((p_valid_str t t_2 a_1)) ->
  ((is_uint64 x)) ->
  ((is_uint64 x_1)) ->
  ((valid_rd t ((shift_sint8 a 0)) i)) ->
  ((valid_rw t ((shift_sint8 a_1 0)) (1 + i_2))) ->
  ((valid_rw t a_2 i)) ->
  ((p_valid_str t t_2 a_2)) ->
  (if (x_2 <= x) then (((to_uint64 (x_2 - 1))) = i) else (x = i)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < x) ->
   (t_2[(shift_sint8 a i_3)] <> 0)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < x_1) ->
   (t_2[(shift_sint8 a_1 i_3)] <> 0)) ->
  (forall i_3 : int. (0 <= i_3) -> (i_3 < i) ->
   (a_3[(shift_sint8 a_1 (i_3 + x_1))] = a_3[(shift_sint8 a i_3)])) ->
  (a_3[(shift_sint8 a_1 (i_1 + x_1))] = a_3[(shift_sint8 a i_1)])

end

(* ---------------------------------------------------------- *)
(* --- Assertion (file src/strlcat.c, line 34)            --- *)
(* ---------------------------------------------------------- *)
theory VCstrlcat_assert_6
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Compound.Compound
use import A_Strlen.A_Strlen
use import Cint.Cint

(*
goal WP "expl:Assertion (file src/strlcat.c, line 34)":
*)
goal goal4:
  forall i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a_1 a : addr.
  let x = (l_strlen t_2 a) in
  let x_1 = (l_strlen t_2 a_1) in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = (to_uint64 (i_1 - x_1)) in
  let a_3 = (havoc t_1 t_2 a_2 i) in
  (t_2[(shift_sint8 a x)] = 0) ->
  (t_2[a_2] = 0) ->
  (x_1 < i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (i < x_2) ->
  ((x + x_1) <= 18446744073709551615) ->
  ((linked t)) ->
  ((sconst t_2)) ->
  ((is_uint64 i)) ->
  ((is_uint64 i_1)) ->
  ((p_valid_str t t_2 a)) ->
  ((p_valid_str t t_2 a_1)) ->
  ((is_uint64 x)) ->
  ((is_uint64 x_1)) ->
  ((valid_rd t ((shift_sint8 a 0)) i)) ->
  ((valid_rw t ((shift_sint8 a_1 0)) (1 + i_1))) ->
  ((valid_rw t a_2 i)) ->
  ((p_valid_str t t_2 a_2)) ->
  (if (x_2 <= x) then (((to_uint64 (x_2 - 1))) = i) else (x = i)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x) ->
   (t_2[(shift_sint8 a i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x_1) ->
   (t_2[(shift_sint8 a_1 i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (a_3[(shift_sint8 a_1 (i_2 + x_1))] = a_3[(shift_sint8 a i_2)])) ->
  ((p_valid_str t a_3[((shift_sint8 a_1 (i + x_1))) <- 0] a_2))

end

(* ---------------------------------------------------------- *)
(* --- Assertion (file src/strlcat.c, line 35)            --- *)
(* ---------------------------------------------------------- *)
theory VCstrlcat_assert_7
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Compound.Compound
use import A_Strlen.A_Strlen
use import Cint.Cint

(*
goal WP "expl:Assertion (file src/strlcat.c, line 35)":
*)
goal goal5:
  forall i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a_1 a : addr.
  let x = (l_strlen t_2 a) in
  let x_1 = (l_strlen t_2 a_1) in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = (to_uint64 (i_1 - x_1)) in
  let a_3 = (havoc t_1 t_2 a_2 i) in
  let a_4 = a_3[((shift_sint8 a_1 (i + x_1))) <- 0] in
  (t_2[(shift_sint8 a x)] = 0) ->
  (t_2[a_2] = 0) ->
  (x_1 < i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (i < x_2) ->
  ((x + x_1) <= 18446744073709551615) ->
  ((linked t)) ->
  ((sconst t_2)) ->
  ((is_uint64 i)) ->
  ((is_uint64 i_1)) ->
  ((p_valid_str t t_2 a)) ->
  ((p_valid_str t t_2 a_1)) ->
  ((is_uint64 x)) ->
  ((is_uint64 x_1)) ->
  ((valid_rd t ((shift_sint8 a 0)) i)) ->
  ((valid_rw t ((shift_sint8 a_1 0)) (1 + i_1))) ->
  ((valid_rw t a_2 i)) ->
  ((p_valid_str t t_2 a_2)) ->
  ((p_valid_str t a_4 a_2)) ->
  (if (x_2 <= x) then (((to_uint64 (x_2 - 1))) = i) else (x = i)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x) ->
   (t_2[(shift_sint8 a i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x_1) ->
   (t_2[(shift_sint8 a_1 i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (a_3[(shift_sint8 a_1 (i_2 + x_1))] = a_3[(shift_sint8 a i_2)])) ->
  ((p_valid_str t a_4 a_1))

end

(* ---------------------------------------------------------- *)
(* --- Assigns (file src/strlcat.c, line 8) in 'strlcat' (7/7) --- *)
(* ---------------------------------------------------------- *)
theory VCstrlcat_assign_exit_part7
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Compound.Compound
use import A_Strlen.A_Strlen
use import Cint.Cint

(*
goal WP "expl:Assigns (file src/strlcat.c, line 8) in 'strlcat' (7/7)":
*)
goal goal6:
  forall i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = (l_strlen t_1 a) in
  let x_1 = (l_strlen t_1 a_1) in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = (to_uint64 (i - x_1)) in
  let x_3 = (to_uint64 (x_2 - 1)) in
  (t_1[(shift_sint8 a x)] = 0) ->
  (t_1[a_2] = 0) ->
  (x_1 < i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (x_2 <= x) ->
  (0 < x_3) ->
  (x_3 < x_2) ->
  ((x + x_1) <= 18446744073709551615) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint64 i)) ->
  ((p_valid_str t t_1 a)) ->
  ((p_valid_str t t_1 a_1)) ->
  ((is_uint64 x)) ->
  ((is_uint64 x_1)) ->
  ((valid_rw t ((shift_sint8 a_1 0)) (1 + i))) ->
  ((p_valid_str t t_1 a_2)) ->
  ((valid_rd t ((shift_sint8 a 0)) x_3)) ->
  ((valid_rw t a_2 x_3)) ->
  (not (invalid t a_2 x_3)) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < x) ->
   (t_1[(shift_sint8 a i_1)] <> 0)) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < x_1) ->
   (t_1[(shift_sint8 a_1 i_1)] <> 0)) ->
  (x_3 <= (1 + x))

end

(* ---------------------------------------------------------- *)
(* --- Assigns (file src/strlcat.c, line 8) in 'strlcat' (7/8) --- *)
(* ---------------------------------------------------------- *)
theory VCstrlcat_assign_normal_part7
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Compound.Compound
use import A_Strlen.A_Strlen
use import Cint.Cint

(*
goal WP "expl:Assigns (file src/strlcat.c, line 8) in 'strlcat' (7/8)":
*)
goal goal7:
  forall i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a_1 a : addr.
  let x = (l_strlen t_2 a) in
  let x_1 = (l_strlen t_2 a_1) in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = (to_uint64 (i - x_1)) in
  let x_3 = (to_uint64 (x_2 - 1)) in
  let a_3 = (havoc t_1 t_2 a_2 x_3) in
  (t_2[(shift_sint8 a x)] = 0) ->
  (t_2[a_2] = 0) ->
  (x_1 < i) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (x_2 <= x) ->
  (0 < x_3) ->
  (x_3 < x_2) ->
  ((x + x_1) <= 18446744073709551615) ->
  ((linked t)) ->
  ((sconst t_2)) ->
  ((is_uint64 i)) ->
  ((p_valid_str t t_2 a)) ->
  ((p_valid_str t t_2 a_1)) ->
  ((is_uint64 x)) ->
  ((is_uint64 x_1)) ->
  ((valid_rw t ((shift_sint8 a_1 0)) (1 + i))) ->
  ((p_valid_str t t_2 a_2)) ->
  ((valid_rd t ((shift_sint8 a 0)) x_3)) ->
  ((valid_rw t a_2 x_3)) ->
  (not (invalid t a_2 x_3)) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < x) ->
   (t_2[(shift_sint8 a i_1)] <> 0)) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < x_1) ->
   (t_2[(shift_sint8 a_1 i_1)] <> 0)) ->
  (forall i_1 : int. (0 <= i_1) -> (i_1 < x_3) ->
   (a_3[(shift_sint8 a_1 (i_1 + x_1))] = a_3[(shift_sint8 a i_1)])) ->
  (x_3 <= (1 + x))

end

(* ---------------------------------------------------------- *)
(* --- Assigns (file src/strlcat.c, line 8) in 'strlcat' (8/8) --- *)
(* ---------------------------------------------------------- *)
theory VCstrlcat_assign_normal_part8
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Compound.Compound
use import A_Strlen.A_Strlen
use import Cint.Cint

(*
goal WP "expl:Assigns (file src/strlcat.c, line 8) in 'strlcat' (8/8)":
*)
goal goal8:
  forall i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a_1 a : addr.
  let x = (l_strlen t_2 a) in
  let x_1 = (l_strlen t_2 a_1) in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = (to_uint64 (i_1 - x_1)) in
  let a_3 = (shift_sint8 a_1 (i + x_1)) in
  let a_4 = (havoc t_1 t_2 a_2 i) in
  (t_2[(shift_sint8 a x)] = 0) ->
  (t_2[a_2] = 0) ->
  (x_1 < i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (i < x_2) ->
  ((x + x_1) <= 18446744073709551615) ->
  ((linked t)) ->
  ((sconst t_2)) ->
  ((is_uint64 i)) ->
  ((is_uint64 i_1)) ->
  ((p_valid_str t t_2 a)) ->
  ((p_valid_str t t_2 a_1)) ->
  ((is_uint64 x)) ->
  ((is_uint64 x_1)) ->
  ((valid_rd t ((shift_sint8 a 0)) i)) ->
  ((valid_rw t ((shift_sint8 a_1 0)) (1 + i_1))) ->
  ((valid_rw t a_2 i)) ->
  ((p_valid_str t t_2 a_2)) ->
  (not (invalid t a_3 1)) ->
  (if (x_2 <= x) then (((to_uint64 (x_2 - 1))) = i) else (x = i)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x) ->
   (t_2[(shift_sint8 a i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x_1) ->
   (t_2[(shift_sint8 a_1 i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < i) ->
   (a_4[(shift_sint8 a_1 (i_2 + x_1))] = a_4[(shift_sint8 a i_2)])) ->
  ((included a_3 1 a_2 (1 + x)))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition (file src/memcpy.h, line 16) in 'memcpy'' in 'strlcat' at call 'memcpy' (file src/strlcat.c, line 31)
 --- *)
(* ---------------------------------------------------------- *)
theory VCstrlcat_call_memcpy_pre
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Compound.Compound
use import A_Strlen.A_Strlen
use import Cint.Cint

(*
goal WP "expl:Instance of 'Pre-condition (file src/memcpy.h, line 16) in 'memcpy'' in 'strlcat' at call 'memcpy' (file src/strlcat.c, line 31)
":
*)
goal goal9:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = (l_strlen t_1 a) in
  let x_1 = (l_strlen t_1 a_1) in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = (to_uint64 (i_1 - x_1)) in
  (t_1[(shift_sint8 a x)] = 0) ->
  (t_1[a_2] = 0) ->
  (x_1 < i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (i < x_2) ->
  ((x + x_1) <= 18446744073709551615) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint64 i)) ->
  ((is_uint64 i_1)) ->
  ((p_valid_str t t_1 a)) ->
  ((p_valid_str t t_1 a_1)) ->
  ((is_uint64 x)) ->
  ((is_uint64 x_1)) ->
  ((valid_rw t ((shift_sint8 a_1 0)) (1 + i_1))) ->
  ((p_valid_str t t_1 a_2)) ->
  (if (x_2 <= x) then (((to_uint64 (x_2 - 1))) = i) else (x = i)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x) ->
   (t_1[(shift_sint8 a i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x_1) ->
   (t_1[(shift_sint8 a_1 i_2)] <> 0)) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition (file src/memcpy.h, line 17) in 'memcpy'' in 'strlcat' at call 'memcpy' (file src/strlcat.c, line 31)
 --- *)
(* ---------------------------------------------------------- *)
theory VCstrlcat_call_memcpy_pre_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Compound.Compound
use import A_Strlen.A_Strlen
use import Cint.Cint

(*
goal WP "expl:Instance of 'Pre-condition (file src/memcpy.h, line 17) in 'memcpy'' in 'strlcat' at call 'memcpy' (file src/strlcat.c, line 31)
":
*)
goal goal10:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = (l_strlen t_1 a) in
  let x_1 = (l_strlen t_1 a_1) in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = (to_uint64 (i_1 - x_1)) in
  (t_1[(shift_sint8 a x)] = 0) ->
  (t_1[a_2] = 0) ->
  (x_1 < i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (i < x_2) ->
  ((x + x_1) <= 18446744073709551615) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint64 i)) ->
  ((is_uint64 i_1)) ->
  ((p_valid_str t t_1 a)) ->
  ((p_valid_str t t_1 a_1)) ->
  ((is_uint64 x)) ->
  ((is_uint64 x_1)) ->
  ((valid_rw t ((shift_sint8 a_1 0)) (1 + i_1))) ->
  ((p_valid_str t t_1 a_2)) ->
  (if (x_2 <= x) then (((to_uint64 (x_2 - 1))) = i) else (x = i)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x) ->
   (t_1[(shift_sint8 a i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x_1) ->
   (t_1[(shift_sint8 a_1 i_2)] <> 0)) ->
  false

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition (file src/memcpy.h, line 18) in 'memcpy'' in 'strlcat' at call 'memcpy' (file src/strlcat.c, line 31)
 --- *)
(* ---------------------------------------------------------- *)
theory VCstrlcat_call_memcpy_pre_3
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Compound.Compound
use import A_Strlen.A_Strlen
use import Cint.Cint

(*
goal WP "expl:Instance of 'Pre-condition (file src/memcpy.h, line 18) in 'memcpy'' in 'strlcat' at call 'memcpy' (file src/strlcat.c, line 31)
":
*)
goal goal11:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = (l_strlen t_1 a) in
  let x_1 = (l_strlen t_1 a_1) in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = (to_uint64 (i_1 - x_1)) in
  (t_1[(shift_sint8 a x)] = 0) ->
  (t_1[a_2] = 0) ->
  (x_1 < i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (i < x_2) ->
  ((x + x_1) <= 18446744073709551615) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint64 i)) ->
  ((is_uint64 i_1)) ->
  ((p_valid_str t t_1 a)) ->
  ((p_valid_str t t_1 a_1)) ->
  ((is_uint64 x)) ->
  ((is_uint64 x_1)) ->
  ((valid_rw t ((shift_sint8 a_1 0)) (1 + i_1))) ->
  ((p_valid_str t t_1 a_2)) ->
  (if (x_2 <= x) then (((to_uint64 (x_2 - 1))) = i) else (x = i)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x) ->
   (t_1[(shift_sint8 a i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x_1) ->
   (t_1[(shift_sint8 a_1 i_2)] <> 0)) ->
  ((valid_rd t ((shift_sint8 a 0)) i))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition (file src/memcpy.h, line 19) in 'memcpy'' in 'strlcat' at call 'memcpy' (file src/strlcat.c, line 31)
 --- *)
(* ---------------------------------------------------------- *)
theory VCstrlcat_call_memcpy_pre_4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Axiomatic3.Axiomatic3
use import Memory.Memory
use import Compound.Compound
use import A_Strlen.A_Strlen
use import Cint.Cint

(*
goal WP "expl:Instance of 'Pre-condition (file src/memcpy.h, line 19) in 'memcpy'' in 'strlcat' at call 'memcpy' (file src/strlcat.c, line 31)
":
*)
goal goal12:
  forall i_1 i : int.
  forall t : map int int.
  forall t_1 : map addr int.
  forall a_1 a : addr.
  let x = (l_strlen t_1 a) in
  let x_1 = (l_strlen t_1 a_1) in
  let a_2 = (shift_sint8 a_1 x_1) in
  let x_2 = (to_uint64 (i_1 - x_1)) in
  (t_1[(shift_sint8 a x)] = 0) ->
  (t_1[a_2] = 0) ->
  (x_1 < i_1) ->
  (((region (a.base))) <= 0) ->
  (((region (a_1.base))) <= 0) ->
  (i < x_2) ->
  ((x + x_1) <= 18446744073709551615) ->
  ((linked t)) ->
  ((sconst t_1)) ->
  ((is_uint64 i)) ->
  ((is_uint64 i_1)) ->
  ((p_valid_str t t_1 a)) ->
  ((p_valid_str t t_1 a_1)) ->
  ((is_uint64 x)) ->
  ((is_uint64 x_1)) ->
  ((valid_rw t ((shift_sint8 a_1 0)) (1 + i_1))) ->
  ((p_valid_str t t_1 a_2)) ->
  (if (x_2 <= x) then (((to_uint64 (x_2 - 1))) = i) else (x = i)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x) ->
   (t_1[(shift_sint8 a i_2)] <> 0)) ->
  (forall i_2 : int. (0 <= i_2) -> (i_2 < x_1) ->
   (t_1[(shift_sint8 a_1 i_2)] <> 0)) ->
  ((valid_rw t a_2 i))

end

