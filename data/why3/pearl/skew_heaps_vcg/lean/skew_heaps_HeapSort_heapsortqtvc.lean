import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
import pearl.skew_heaps_vcg.lean.skew_heaps.SkewHeaps
import Why3.bintree.Tree
import Why3.bintree.Size
import Why3.bintree.Occ
open Classical
open Lean4Why3
namespace skew_heaps_HeapSort_heapsortqtvc
noncomputable def sorted_sub (a : List SkewHeaps.elt) (l : ℤ) (u : ℤ) := ∀(i1 : ℤ) (i2 : ℤ), l ≤ i1 ∧ i1 < i2 ∧ i2 < u → SkewHeaps.le (a[Int.toNat i1]!) (a[Int.toNat i2]!)
noncomputable def sorted (a : List SkewHeaps.elt) := ∀(i1 : ℤ) (i2 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < i2 ∧ i2 < Int.ofNat (List.length a) → SkewHeaps.le (a[Int.toNat i1]!) (a[Int.toNat i2]!)
theorem heapsort'vc (a : List SkewHeaps.elt) : let n : ℤ := Int.ofNat (List.length a); let o1 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → ((SkewHeaps.heap SkewHeaps.empty ∧ Size.size SkewHeaps.empty = (0 : ℤ)) ∧ (∀(e : SkewHeaps.elt), Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) n) + Occ.occ e SkewHeaps.empty = Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) n))) ∧ (∀(t : Tree.tree SkewHeaps.elt), (((0 : ℤ) ≤ Size.size t ∧ Size.size t ≤ o1) ∧ SkewHeaps.heap t ∧ (∀(e : SkewHeaps.elt), Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (Size.size t) n) + Occ.occ e t = Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) n)) → ((0 : ℤ) ≤ Size.size t ∧ Size.size t < Int.ofNat (List.length a)) ∧ (let o2 : SkewHeaps.elt := a[Int.toNat (Size.size t)]!; SkewHeaps.heap t ∧ (∀(o3 : Tree.tree SkewHeaps.elt), SkewHeaps.heap o3 ∧ Occ.occ o2 o3 = Occ.occ o2 t + (1 : ℤ) ∧ (∀(e : SkewHeaps.elt), ¬e = o2 → Occ.occ e o3 = Occ.occ e t) ∧ Size.size o3 = Size.size t + (1 : ℤ) → (SkewHeaps.heap o3 ∧ Size.size o3 = Size.size t + (1 : ℤ)) ∧ (∀(e : SkewHeaps.elt), Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (Size.size t + (1 : ℤ)) n) + Occ.occ e o3 = Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) n))))) ∧ ((SkewHeaps.heap t ∧ Size.size t = o1 + (1 : ℤ)) ∧ (∀(e : SkewHeaps.elt), Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (o1 + (1 : ℤ)) n) + Occ.occ e t = Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) n)) → (let o2 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → (sorted_sub a (0 : ℤ) (0 : ℤ) ∧ (SkewHeaps.heap t ∧ Size.size t = n - (0 : ℤ)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → (∀(e : SkewHeaps.elt), Occ.mem e t → SkewHeaps.le (a[Int.toNat j]!) e)) ∧ (∀(e : SkewHeaps.elt), Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) (0 : ℤ)) + Occ.occ e t = Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) n))) ∧ (∀(t1 : Tree.tree SkewHeaps.elt) (a1 : List SkewHeaps.elt), List.length a1 = List.length a → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o2) ∧ sorted_sub a1 (0 : ℤ) i ∧ (SkewHeaps.heap t1 ∧ Size.size t1 = n - i) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → (∀(e : SkewHeaps.elt), Occ.mem e t1 → SkewHeaps.le (a1[Int.toNat j]!) e)) ∧ (∀(e : SkewHeaps.elt), Int.ofNat (Lean4Why3.map_occ e (getElem! a1 ∘ Int.toNat) (0 : ℤ) i) + Occ.occ e t1 = Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) n)) → (SkewHeaps.heap t1 ∧ (0 : ℤ) < Size.size t1) ∧ (let o3 : SkewHeaps.elt := SkewHeaps.minimum t1; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (List.length (List.set a1 (Int.toNat i) o3) = List.length a1 → getElem! (List.set a1 (Int.toNat i) o3) ∘ Int.toNat = Function.update (getElem! a1 ∘ Int.toNat) i o3 → (SkewHeaps.heap t1 ∧ (0 : ℤ) < Size.size t1) ∧ (∀(o4 : Tree.tree SkewHeaps.elt), SkewHeaps.heap o4 ∧ Occ.occ (SkewHeaps.minimum t1) o4 = Occ.occ (SkewHeaps.minimum t1) t1 - (1 : ℤ) ∧ (∀(e : SkewHeaps.elt), ¬e = SkewHeaps.minimum t1 → Occ.occ e o4 = Occ.occ e t1) ∧ Size.size o4 = Size.size t1 - (1 : ℤ) → sorted_sub (List.set a1 (Int.toNat i) o3) (0 : ℤ) (i + (1 : ℤ)) ∧ (SkewHeaps.heap o4 ∧ Size.size o4 = n - (i + (1 : ℤ))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → (∀(e : SkewHeaps.elt), Occ.mem e o4 → SkewHeaps.le ((List.set a1 (Int.toNat i) o3)[Int.toNat j]!) e)) ∧ (∀(e : SkewHeaps.elt), Int.ofNat (Lean4Why3.map_occ e (getElem! (List.set a1 (Int.toNat i) o3) ∘ Int.toNat) (0 : ℤ) (i + (1 : ℤ))) + Occ.occ e o4 = Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) n)))))) ∧ (sorted_sub a1 (0 : ℤ) (o2 + (1 : ℤ)) ∧ (SkewHeaps.heap t1 ∧ Size.size t1 = n - (o2 + (1 : ℤ))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < o2 + (1 : ℤ) → (∀(e : SkewHeaps.elt), Occ.mem e t1 → SkewHeaps.le (a1[Int.toNat j]!) e)) ∧ (∀(e : SkewHeaps.elt), Int.ofNat (Lean4Why3.map_occ e (getElem! a1 ∘ Int.toNat) (0 : ℤ) (o2 + (1 : ℤ))) + Occ.occ e t1 = Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) n)) → sorted a1 ∧ List.Perm a a1))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → sorted a ∧ List.Perm a a))))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (let o2 : ℤ := n - (1 : ℤ); ((0 : ℤ) ≤ o2 + (1 : ℤ) → (sorted_sub a (0 : ℤ) (0 : ℤ) ∧ (SkewHeaps.heap SkewHeaps.empty ∧ Size.size SkewHeaps.empty = n - (0 : ℤ)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < (0 : ℤ) → (∀(e : SkewHeaps.elt), Occ.mem e SkewHeaps.empty → SkewHeaps.le (a[Int.toNat j]!) e)) ∧ (∀(e : SkewHeaps.elt), Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) (0 : ℤ)) + Occ.occ e SkewHeaps.empty = Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) n))) ∧ (∀(t : Tree.tree SkewHeaps.elt) (a1 : List SkewHeaps.elt), List.length a1 = List.length a → (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o2) ∧ sorted_sub a1 (0 : ℤ) i ∧ (SkewHeaps.heap t ∧ Size.size t = n - i) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → (∀(e : SkewHeaps.elt), Occ.mem e t → SkewHeaps.le (a1[Int.toNat j]!) e)) ∧ (∀(e : SkewHeaps.elt), Int.ofNat (Lean4Why3.map_occ e (getElem! a1 ∘ Int.toNat) (0 : ℤ) i) + Occ.occ e t = Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) n)) → (SkewHeaps.heap t ∧ (0 : ℤ) < Size.size t) ∧ (let o3 : SkewHeaps.elt := SkewHeaps.minimum t; ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (List.length (List.set a1 (Int.toNat i) o3) = List.length a1 → getElem! (List.set a1 (Int.toNat i) o3) ∘ Int.toNat = Function.update (getElem! a1 ∘ Int.toNat) i o3 → (SkewHeaps.heap t ∧ (0 : ℤ) < Size.size t) ∧ (∀(o4 : Tree.tree SkewHeaps.elt), SkewHeaps.heap o4 ∧ Occ.occ (SkewHeaps.minimum t) o4 = Occ.occ (SkewHeaps.minimum t) t - (1 : ℤ) ∧ (∀(e : SkewHeaps.elt), ¬e = SkewHeaps.minimum t → Occ.occ e o4 = Occ.occ e t) ∧ Size.size o4 = Size.size t - (1 : ℤ) → sorted_sub (List.set a1 (Int.toNat i) o3) (0 : ℤ) (i + (1 : ℤ)) ∧ (SkewHeaps.heap o4 ∧ Size.size o4 = n - (i + (1 : ℤ))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i + (1 : ℤ) → (∀(e : SkewHeaps.elt), Occ.mem e o4 → SkewHeaps.le ((List.set a1 (Int.toNat i) o3)[Int.toNat j]!) e)) ∧ (∀(e : SkewHeaps.elt), Int.ofNat (Lean4Why3.map_occ e (getElem! (List.set a1 (Int.toNat i) o3) ∘ Int.toNat) (0 : ℤ) (i + (1 : ℤ))) + Occ.occ e o4 = Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) n)))))) ∧ (sorted_sub a1 (0 : ℤ) (o2 + (1 : ℤ)) ∧ (SkewHeaps.heap t ∧ Size.size t = n - (o2 + (1 : ℤ))) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < o2 + (1 : ℤ) → (∀(e : SkewHeaps.elt), Occ.mem e t → SkewHeaps.le (a1[Int.toNat j]!) e)) ∧ (∀(e : SkewHeaps.elt), Int.ofNat (Lean4Why3.map_occ e (getElem! a1 ∘ Int.toNat) (0 : ℤ) (o2 + (1 : ℤ))) + Occ.occ e t = Int.ofNat (Lean4Why3.map_occ e (getElem! a ∘ Int.toNat) (0 : ℤ) n)) → sorted a1 ∧ List.Perm a a1))) ∧ (o2 + (1 : ℤ) < (0 : ℤ) → sorted a ∧ List.Perm a a)))
  := sorry
end skew_heaps_HeapSort_heapsortqtvc
