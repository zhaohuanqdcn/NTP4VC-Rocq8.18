theory verifythis_2018_register_allocation_Top_all_fromqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.ocaml_Exceptions"
begin
typedecl  var
typedecl  set
consts to_fset :: "set \<Rightarrow> var fset"
consts mk :: "var fset \<Rightarrow> set"
axiomatization where mk'spec:   "to_fset (mk s) = s"
  for s :: "var fset"
consts choose1 :: "set \<Rightarrow> var"
axiomatization where choose'spec:   "choose1 s |\<in>| to_fset s"
 if "\<not>to_fset s = fempty"
  for s :: "set"
typedecl 'v t
consts to_fmap :: "'v t \<Rightarrow> (var, 'v) fmap"
consts rem :: "var \<Rightarrow> set t \<Rightarrow> set t"
axiomatization where rem'spec'2:   "\<not>v |\<in>| fmdom (to_fmap (rem v g))"
 if "v |\<in>| fmdom (to_fmap g)"
  for v :: "var"
  and g :: "set t"
axiomatization where rem'spec'1:   "k |\<in>| fmdom (to_fmap (rem v g)) \<longleftrightarrow> \<not>k = v \<and> k |\<in>| fmdom (to_fmap g)"
 if "v |\<in>| fmdom (to_fmap g)"
  for v :: "var"
  and g :: "set t"
  and k :: "var"
axiomatization where rem'spec'0:   "to_fset (the (fmlookup (to_fmap (rem v g)) k)) = fset_remove v (to_fset (the (fmlookup (to_fmap g) k)))"
 if "v |\<in>| fmdom (to_fmap g)"
 and "k |\<in>| fmdom (to_fmap (rem v g))"
  for v :: "var"
  and g :: "set t"
  and k :: "var"
axiomatization where rem'spec:   "int (fcard (fset_of_fmap (to_fmap (rem v g)))) = int (fcard (fset_of_fmap (to_fmap g))) - (1 :: int)"
 if "v |\<in>| fmdom (to_fmap g)"
  for v :: "var"
  and g :: "set t"
consts replace :: "var \<Rightarrow> var \<Rightarrow> set \<Rightarrow> set"
axiomatization where replace'spec'1:   "u |\<in>| to_fset (replace v u s) \<longleftrightarrow> u |\<in>| to_fset s \<or> v |\<in>| to_fset s"
 if "\<not>v = u"
  for v :: "var"
  and u :: "var"
  and s :: "set"
axiomatization where replace'spec'0:   "\<not>v |\<in>| to_fset (replace v u s)"
 if "\<not>v = u"
  for v :: "var"
  and u :: "var"
  and s :: "set"
axiomatization where replace'spec:   "w |\<in>| to_fset (replace v u s) \<longleftrightarrow> w |\<in>| to_fset s"
 if "\<not>v = u"
 and "\<not>w = u"
 and "\<not>w = v"
  for v :: "var"
  and u :: "var"
  and w :: "var"
  and s :: "set"
consts merge :: "var \<Rightarrow> var \<Rightarrow> set t \<Rightarrow> set t"
axiomatization where merge'spec'2:   "k |\<in>| fmdom (to_fmap (merge v u g)) \<longleftrightarrow> \<not>k = v \<and> k |\<in>| fmdom (to_fmap g)"
 if "\<not>v = u"
 and "v |\<in>| fmdom (to_fmap g)"
 and "u |\<in>| fmdom (to_fmap g)"
  for v :: "var"
  and u :: "var"
  and g :: "set t"
  and k :: "var"
axiomatization where merge'spec'1:   "to_fset (the (fmlookup (to_fmap (merge v u g)) u)) = to_fset (replace v u (the (fmlookup (to_fmap g) u))) |\<union>| to_fset (replace v u (the (fmlookup (to_fmap g) v)))"
 if "\<not>v = u"
 and "v |\<in>| fmdom (to_fmap g)"
 and "u |\<in>| fmdom (to_fmap g)"
  for v :: "var"
  and u :: "var"
  and g :: "set t"
axiomatization where merge'spec'0:   "to_fset (the (fmlookup (to_fmap (merge v u g)) k)) = to_fset (replace v u (the (fmlookup (to_fmap g) k)))"
 if "\<not>v = u"
 and "v |\<in>| fmdom (to_fmap g)"
 and "u |\<in>| fmdom (to_fmap g)"
 and "k |\<in>| fmdom (to_fmap (merge v u g))"
 and "\<not>k = u"
  for v :: "var"
  and u :: "var"
  and g :: "set t"
  and k :: "var"
axiomatization where merge'spec:   "int (fcard (fset_of_fmap (to_fmap (merge v u g)))) = int (fcard (fset_of_fmap (to_fmap g))) - (1 :: int)"
 if "\<not>v = u"
 and "v |\<in>| fmdom (to_fmap g)"
 and "u |\<in>| fmdom (to_fmap g)"
  for v :: "var"
  and u :: "var"
  and g :: "set t"
theorem all_from'vc:
  fixes s :: "set"
  fixes a :: "var t"
  shows "\<not>to_fset s = fempty \<longrightarrow> \<not>to_fset s = fempty \<and> (let k :: var = choose1 s in k |\<in>| to_fset s \<longrightarrow> (\<forall>(sk :: set). to_fset sk = fset_remove k (to_fset s) \<and> (if k |\<in>| to_fset s then int (fcard (to_fset sk)) = int (fcard (to_fset s)) - (1 :: int) else fcard (to_fset sk) = fcard (to_fset s)) \<longrightarrow> (0 :: int) \<le> int (fcard (to_fset s)) \<and> fcard (to_fset sk) < fcard (to_fset s)))"
  and "\<forall>(result :: set). (if to_fset s = fempty then to_fset result = fempty \<and> int (fcard (to_fset result)) = (0 :: int) else let k :: var = choose1 s in k |\<in>| to_fset s \<and> (\<exists>(sk :: set). (to_fset sk = fset_remove k (to_fset s) \<and> (if k |\<in>| to_fset s then int (fcard (to_fset sk)) = int (fcard (to_fset s)) - (1 :: int) else fcard (to_fset sk) = fcard (to_fset s))) \<and> (\<exists>(allk :: set). (\<forall>(v :: var). v |\<in>| to_fset allk \<longleftrightarrow> (\<exists>(k1 :: var). k1 |\<in>| to_fset sk \<and> fmlookup (to_fmap a) k1 = Some v)) \<and> (if k |\<in>| fmdom (to_fmap a) then let o1 :: var = fm_contents (to_fmap a) k in o1 = the (fmlookup (to_fmap a) k) \<and> to_fset result = finsert o1 (to_fset allk) \<and> (if o1 |\<in>| to_fset allk then fcard (to_fset result) = fcard (to_fset allk) else int (fcard (to_fset result)) = int (fcard (to_fset allk)) + (1 :: int)) else result = allk)))) \<longrightarrow> (\<forall>(v :: var). v |\<in>| to_fset result \<longleftrightarrow> (\<exists>(k :: var). k |\<in>| to_fset s \<and> fmlookup (to_fmap a) k = Some v))"
  sorry
end
