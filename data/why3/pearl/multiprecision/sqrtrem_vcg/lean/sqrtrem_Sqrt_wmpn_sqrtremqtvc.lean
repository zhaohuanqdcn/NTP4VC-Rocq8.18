import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.real.Truncate
import Why3.mach.c.C
import Why3.mach.int.Unsigned
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub_1.Sub_1
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.logical.LogicalOld
import pearl.multiprecision.lib.lean.div.Div
import pearl.multiprecision.lib.lean.sqrt.Sqrt1
import Why3.mach.fxp.Fxp
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.valuation.Valuation
open Classical
open Lean4Why3
namespace sqrtrem_Sqrt_wmpn_sqrtremqtvc
noncomputable def ceilhalf (n : ℤ) := Int.tdiv (n + (1 : ℤ)) (2 : ℤ)
axiom ceilhalf'spec'0 (n : ℤ) : n ≤ (2 : ℤ) * ceilhalf n
axiom ceilhalf'spec (n : ℤ) : n < (2 : ℤ) * (ceilhalf n + (1 : ℤ))
theorem wmpn_sqrtrem'vc (sp : C.ptr (BitVec 64)) (n : BitVec 32) (rp : C.ptr (BitVec 64)) (np : C.ptr (BitVec 64)) (fact0 : C.valid sp (ceilhalf (BitVec.toInt n))) (fact1 : C.valid rp (BitVec.toInt n)) (fact2 : C.valid np (BitVec.toInt n)) (fact3 : C.writable sp = true) (fact4 : C.writable rp = true) (fact5 : C.writable np = true) (fact6 : (1 : ℤ) ≤ BitVec.toInt n) (fact7 : (4 : ℤ) * BitVec.toInt n < (2147483647 : ℤ)) (fact8 : (0 : ℤ) < BitVec.toUInt (C.pelts np (C.offset np + BitVec.toInt n - (1 : ℤ)))) : let o1 : ℤ := BitVec.toInt n; let k : ℤ := ceilhalf o1; o1 ≤ (2 : ℤ) * k ∧ o1 < (2 : ℤ) * (k + (1 : ℤ)) → int'32_in_bounds (BitVec.toInt n - (1 : ℤ)) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toInt n - (1 : ℤ) → (C.min np ≤ C.offset np + BitVec.toInt o2 ∧ C.offset np + BitVec.toInt o2 < C.max np) ∧ (let high : BitVec 64 := C.pelts np (C.offset np + BitVec.toInt o2); (0 : ℤ) < BitVec.toUInt high ∧ (∀(o3 : BitVec 32), HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt o3)) * BitVec.toUInt high ≤ (18446744073709551615 : ℤ) ∧ (18446744073709551615 : ℤ) < (2 : ℤ) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toInt o3)) * BitVec.toUInt high ∧ (0 : ℤ) ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 < (64 : ℤ) → (0 : ℤ) ≤ BitVec.toInt o3 ∧ (∀(o4 : BitVec 64), BitVec.toUInt o4 = BitVec.toInt o3 → (¬(2 : ℤ) = (0 : ℤ) ∧ uint'64_in_bounds (Int.tdiv (BitVec.toUInt o4) (2 : ℤ))) ∧ (∀(o5 : BitVec 64), BitVec.toUInt o5 = Int.tdiv (BitVec.toUInt o4) (2 : ℤ) → (∀(o6 : Bool), (BitVec.toInt n = BitVec.toInt (1 : BitVec 32) → o6 = true) ∧ (o6 = true → n = (1 : BitVec 32)) → (if o6 = true then ∀(o7 : Bool), (BitVec.toUInt o5 = BitVec.toUInt (0 : BitVec 64) → o7 = true) ∧ (o7 = true → o5 = (0 : BitVec 64)) → (if o7 = true then (C.valid rp (1 : ℤ) ∧ (4611686018427387904 : ℤ) ≤ BitVec.toUInt high ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(s : BitVec 64), (BitVec.toUInt s * BitVec.toUInt s ≤ BitVec.toUInt high ∧ BitVec.toUInt high < (BitVec.toUInt s + (1 : ℤ)) * (BitVec.toUInt s + (1 : ℤ))) ∧ BitVec.toUInt s * BitVec.toUInt s + BitVec.toUInt (C.pelts rp1 (C.offset rp1)) = BitVec.toUInt high ∧ BitVec.toUInt (C.pelts rp1 (C.offset rp1)) ≤ (2 : ℤ) * BitVec.toUInt s → ((C.min sp ≤ C.offset sp ∧ C.offset sp < C.max sp) ∧ C.writable sp = true) ∧ (∀(sp1 : C.ptr (BitVec 64)), List.length (C.data sp1) = List.length (C.data sp) ∧ C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.max sp1 = C.max sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → C.pelts sp1 = Function.update (C.pelts sp) (C.offset sp1) s → (C.min rp1 ≤ C.offset rp1 ∧ C.offset rp1 < C.max rp1) ∧ (let o8 : BitVec 64 := C.pelts rp1 (C.offset rp1); ∀(o9 : Bool), (BitVec.toUInt o8 = BitVec.toUInt (0 : BitVec 64) → o9 = true) ∧ (o9 = true → o8 = (0 : BitVec 64)) → (∀(res : BitVec 32), (if o9 = true then res = (0 : BitVec 32) else res = (1 : BitVec 32)) → Lemmas.value np (BitVec.toInt n) = Lemmas.value sp1 (ceilhalf (BitVec.toInt n)) * Lemmas.value sp1 (ceilhalf (BitVec.toInt n)) + Lemmas.value rp1 (BitVec.toInt res) ∧ ((0 : ℤ) ≤ BitVec.toInt res ∧ BitVec.toInt res ≤ BitVec.toInt n) ∧ Lemmas.value rp1 (BitVec.toInt res) ≤ (2 : ℤ) * Lemmas.value sp1 (ceilhalf (BitVec.toInt n)) ∧ ((0 : ℤ) < BitVec.toInt res → (0 : ℤ) < BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt res - (1 : ℤ)))) ∧ C.max rp1 = C.max rp ∧ C.min rp1 = C.min rp ∧ C.plength rp1 = C.plength rp ∧ C.max sp1 = C.max sp ∧ C.min sp1 = C.min sp ∧ C.plength sp1 = C.plength sp))))) else uint'64_in_bounds ((2 : ℤ) * BitVec.toUInt o5) ∧ (∀(o8 : BitVec 64), BitVec.toUInt o8 = (2 : ℤ) * BitVec.toUInt o5 → (((0 : ℤ) ≤ BitVec.toUInt o8 ∧ BitVec.toUInt o8 < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o8)) * BitVec.toUInt high ≤ (18446744073709551615 : ℤ)) ∧ (∀(nh : BitVec 64), BitVec.toUInt nh = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o8)) * BitVec.toUInt high → (C.valid rp (1 : ℤ) ∧ (4611686018427387904 : ℤ) ≤ BitVec.toUInt nh ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(ncc : BitVec 64), (BitVec.toUInt ncc * BitVec.toUInt ncc ≤ BitVec.toUInt nh ∧ BitVec.toUInt nh < (BitVec.toUInt ncc + (1 : ℤ)) * (BitVec.toUInt ncc + (1 : ℤ))) ∧ BitVec.toUInt ncc * BitVec.toUInt ncc + BitVec.toUInt (C.pelts rp1 (C.offset rp1)) = BitVec.toUInt nh ∧ BitVec.toUInt (C.pelts rp1 (C.offset rp1)) ≤ (2 : ℤ) * BitVec.toUInt ncc → ((0 : ℤ) ≤ BitVec.toUInt o5 ∧ BitVec.toUInt o5 < (64 : ℤ)) ∧ (∀(cc : BitVec 64), BitVec.toUInt cc = BitVec.toUInt ncc / HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o5)) → ((C.min sp ≤ C.offset sp ∧ C.offset sp < C.max sp) ∧ C.writable sp = true) ∧ (∀(sp1 : C.ptr (BitVec 64)), List.length (C.data sp1) = List.length (C.data sp) ∧ C.offset sp1 = C.offset sp ∧ C.min sp1 = C.min sp ∧ C.max sp1 = C.max sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → C.pelts sp1 = Function.update (C.pelts sp) (C.offset sp1) cc → uint'64_in_bounds (BitVec.toUInt cc * BitVec.toUInt cc) ∧ (∀(o9 : BitVec 64), BitVec.toUInt o9 = BitVec.toUInt cc * BitVec.toUInt cc → uint'64_in_bounds (BitVec.toUInt high - BitVec.toUInt o9) ∧ (∀(o10 : BitVec 64), BitVec.toUInt o10 = BitVec.toUInt high - BitVec.toUInt o9 → ((C.min rp1 ≤ C.offset rp1 ∧ C.offset rp1 < C.max rp1) ∧ C.writable rp1 = true) ∧ (∀(rp2 : C.ptr (BitVec 64)), List.length (C.data rp2) = List.length (C.data rp1) ∧ C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.max rp2 = C.max rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → C.pelts rp2 = Function.update (C.pelts rp1) (C.offset rp2) o10 → (C.min rp2 ≤ C.offset rp2 ∧ C.offset rp2 < C.max rp2) ∧ (let o11 : BitVec 64 := C.pelts rp2 (C.offset rp2); ∀(o12 : Bool), (BitVec.toUInt o11 = BitVec.toUInt (0 : BitVec 64) → o12 = true) ∧ (o12 = true → o11 = (0 : BitVec 64)) → (∀(res : BitVec 32), (if o12 = true then res = (0 : BitVec 32) else res = (1 : BitVec 32)) → Lemmas.value np (BitVec.toInt n) = Lemmas.value sp1 (ceilhalf (BitVec.toInt n)) * Lemmas.value sp1 (ceilhalf (BitVec.toInt n)) + Lemmas.value rp2 (BitVec.toInt res) ∧ ((0 : ℤ) ≤ BitVec.toInt res ∧ BitVec.toInt res ≤ BitVec.toInt n) ∧ Lemmas.value rp2 (BitVec.toInt res) ≤ (2 : ℤ) * Lemmas.value sp1 (ceilhalf (BitVec.toInt n)) ∧ ((0 : ℤ) < BitVec.toInt res → (0 : ℤ) < BitVec.toUInt (C.pelts rp2 (C.offset rp2 + BitVec.toInt res - (1 : ℤ)))) ∧ C.max rp2 = C.max rp ∧ C.min rp2 = C.min rp ∧ C.plength rp2 = C.plength rp ∧ C.max sp1 = C.max sp ∧ C.min sp1 = C.min sp ∧ C.plength sp1 = C.plength sp)))))))))))) else int'32_in_bounds (BitVec.toInt n + (1 : ℤ)) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt n + (1 : ℤ) → (¬(2 : ℤ) = (0 : ℤ) ∧ int'32_in_bounds (Int.tdiv (BitVec.toInt o7) (2 : ℤ))) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = Int.tdiv (BitVec.toInt o7) (2 : ℤ) → (0 : ℤ) ≤ BitVec.toInt n ∧ (∀(o9 : BitVec 64), BitVec.toUInt o9 = BitVec.toInt n → (¬(2 : ℤ) = (0 : ℤ) ∧ uint'64_in_bounds (Int.tmod (BitVec.toUInt o9) (2 : ℤ))) ∧ (∀(o10 : BitVec 64), BitVec.toUInt o10 = Int.tmod (BitVec.toUInt o9) (2 : ℤ) → BitVec.toUInt o10 ≤ (2147483647 : ℤ) ∧ (∀(adj : BitVec 32), BitVec.toInt adj = BitVec.toUInt o10 → (0 : ℤ) ≤ BitVec.toInt o8 ∧ (∀(o11 : BitVec 32), BitVec.toUInt o11 = BitVec.toInt o8 → (¬(2 : ℤ) = (0 : ℤ) ∧ uint'32_in_bounds (Int.tdiv (BitVec.toUInt o11) (2 : ℤ))) ∧ (∀(o12 : BitVec 32), BitVec.toUInt o12 = Int.tdiv (BitVec.toUInt o11) (2 : ℤ) → uint'32_in_bounds (BitVec.toUInt o12 + (1 : ℤ)) ∧ (∀(o13 : BitVec 32), BitVec.toUInt o13 = BitVec.toUInt o12 + (1 : ℤ) → (0 : ℤ) ≤ BitVec.toUInt o13 ∧ (∀(scratch : C.ptr (BitVec 64)), C.plength scratch = BitVec.toUInt o13 ∧ C.offset scratch = (0 : ℤ) ∧ C.min scratch = (0 : ℤ) ∧ C.max scratch = BitVec.toUInt o13 ∧ C.writable scratch = true → (∀(o14 : Bool), (BitVec.toInt adj = BitVec.toInt (0 : BitVec 32) → o14 = true) ∧ (o14 = true → adj = (0 : BitVec 32)) → (∀(o15 : Bool), (if ¬o14 = true then o15 = true else ∃(o16 : Bool), ((BitVec.toUInt o5 = BitVec.toUInt (0 : BitVec 64) → o16 = true) ∧ (o16 = true → o5 = (0 : BitVec 64))) ∧ o15 = (if o16 = true then false else true)) → (if o15 = true then (0 : ℤ) ≤ BitVec.toInt o8 ∧ (∀(o16 : BitVec 32), BitVec.toUInt o16 = BitVec.toInt o8 → uint'32_in_bounds ((2 : ℤ) * BitVec.toUInt o16) ∧ (∀(o17 : BitVec 32), BitVec.toUInt o17 = (2 : ℤ) * BitVec.toUInt o16 → (0 : ℤ) ≤ BitVec.toUInt o17 ∧ (∀(o18 : C.ptr (BitVec 64)), C.plength o18 = BitVec.toUInt o17 ∧ C.offset o18 = (0 : ℤ) ∧ C.min o18 = (0 : ℤ) ∧ C.max o18 = BitVec.toUInt o17 ∧ C.writable o18 = true → ((C.min o18 ≤ C.offset o18 ∧ C.offset o18 < C.max o18) ∧ C.writable o18 = true) ∧ (∀(tp : C.ptr (BitVec 64)), List.length (C.data tp) = List.length (C.data o18) ∧ C.offset tp = C.offset o18 ∧ C.min tp = C.min o18 ∧ C.max tp = C.max o18 ∧ C.writable tp = C.writable o18 ∧ C.zone1 tp = C.zone1 o18 → List.length (C.data tp) = List.length (C.data o18) ∧ C.offset tp = C.offset o18 ∧ C.min tp = C.min o18 ∧ C.max tp = C.max o18 ∧ C.writable tp = C.writable o18 ∧ C.zone1 tp = C.zone1 o18 → C.pelts tp = Function.update (C.pelts o18) (C.offset tp) (0 : BitVec 64) → (((0 : ℤ) ≤ BitVec.toInt adj ∧ (C.min tp ≤ C.offset tp + BitVec.toInt adj ∧ C.offset tp + BitVec.toInt adj ≤ C.max tp) ∧ C.writable tp = true) ∧ (∀(tp1 : C.ptr (BitVec 64)), C.offset tp1 = C.offset tp ∧ C.min tp1 = C.min tp ∧ C.writable tp1 = C.writable tp ∧ C.zone1 tp1 = C.zone1 tp → C.offset tp1 = C.offset tp ∧ C.min tp1 = C.min tp ∧ C.writable tp1 = C.writable tp ∧ C.zone1 tp1 = C.zone1 tp → (∀(tpa : C.ptr (BitVec 64)), C.writable tpa = true ∧ C.offset tpa = C.offset tp1 + BitVec.toInt adj ∧ C.max tp1 = C.offset tp1 + BitVec.toInt adj ∧ C.min tpa = C.offset tp1 + BitVec.toInt adj ∧ C.max tpa = C.max tp ∧ C.zone1 tpa = C.zone1 tp1 ∧ C.pelts tp1 = C.pelts tp ∧ C.plength tp1 = C.plength tp ∧ C.pelts tpa = C.pelts tp ∧ C.plength tpa = C.plength tp → (∀(o19 : Bool), (BitVec.toUInt o5 = BitVec.toUInt (0 : BitVec 64) → o19 = true) ∧ (o19 = true → o5 = (0 : BitVec 64)) → (if ¬o19 = true then uint'64_in_bounds ((2 : ℤ) * BitVec.toUInt o5) ∧ (∀(o20 : BitVec 64), BitVec.toUInt o20 = (2 : ℤ) * BitVec.toUInt o5 → (((0 : ℤ) < BitVec.toUInt o20 ∧ BitVec.toUInt o20 < (64 : ℤ)) ∧ C.valid tpa (BitVec.toInt n) ∧ C.valid np (BitVec.toInt n) ∧ C.writable tpa = true ∧ (0 : ℤ) < BitVec.toInt n) ∧ (∀(tpa1 : C.ptr (BitVec 64)) (np1 : C.ptr (BitVec 64)), C.offset tpa1 = C.offset tpa ∧ C.writable tpa1 = C.writable tpa ∧ C.zone1 tpa1 = C.zone1 tpa → C.offset np1 = C.offset np ∧ C.writable np1 = C.writable np ∧ C.zone1 np1 = C.zone1 np → (∀(h : BitVec 64), Lemmas.value tpa1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt h = Lemmas.value np (BitVec.toInt n) * HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o20)) ∧ (∀(j : ℤ), j < C.offset tpa1 ∨ C.offset tpa1 + BitVec.toInt n ≤ j → C.pelts tpa1 j = C.pelts tpa j) ∧ (∀(j : ℤ), C.pelts np1 j = C.pelts np j) ∧ (C.min tpa1 = C.min tpa ∧ C.max tpa1 = C.max tpa ∧ C.plength tpa1 = C.plength tpa) ∧ C.min np1 = C.min np ∧ C.max np1 = C.max np ∧ C.plength np1 = C.plength np → (C.zone1 tp1 = C.zone1 tpa1 ∧ C.max tp1 = C.min tpa1 ∧ C.writable tp1 = true ∧ C.writable tpa1 = true) ∧ (∀(tp2 : C.ptr (BitVec 64)), List.length (C.data tp2) = List.length (C.data tp1) ∧ C.offset tp2 = C.offset tp1 ∧ C.min tp2 = C.min tp1 ∧ C.writable tp2 = C.writable tp1 ∧ C.zone1 tp2 = C.zone1 tp1 → List.length (C.data tp2) = List.length (C.data tp1) ∧ C.offset tp2 = C.offset tp1 ∧ C.min tp2 = C.min tp1 ∧ C.writable tp2 = C.writable tp1 ∧ C.zone1 tp2 = C.zone1 tp1 → C.max tp2 = C.max tpa1 ∧ C.plength tp2 = C.plength tp1 ∧ (∀(i : ℤ), C.min tp1 ≤ i ∧ i < C.max tp1 → C.pelts tp2 i = C.pelts tp1 i) ∧ (∀(i : ℤ), C.min tpa1 ≤ i ∧ i < C.max tpa1 → C.pelts tp2 i = C.pelts tpa1 i) → Lemmas.value tp2 (BitVec.toInt n + BitVec.toInt adj) = HPow.hPow (2 : ℤ) (Int.toNat ((2 : ℤ) * BitVec.toUInt o5)) * HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt adj)) * Lemmas.value np1 (BitVec.toInt n) ∧ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt adj)) ≤ (4 : ℤ) * Lemmas.value tp2 (BitVec.toInt n + BitVec.toInt adj) ∧ C.max tp2 = C.max tp ∧ C.plength tp2 = C.plength tp ∧ (C.min np1 = C.min np ∧ C.max np1 = C.max np ∧ C.plength np1 = C.plength np) ∧ (∀(j : ℤ), C.pelts np1 j = C.pelts np j))))) else (C.valid np (BitVec.toInt n) ∧ C.valid tpa (BitVec.toInt n) ∧ C.writable tpa = true) ∧ (∀(tpa1 : C.ptr (BitVec 64)), List.length (C.data tpa1) = List.length (C.data tpa) ∧ C.offset tpa1 = C.offset tpa ∧ C.min tpa1 = C.min tpa ∧ C.max tpa1 = C.max tpa ∧ C.writable tpa1 = C.writable tpa ∧ C.zone1 tpa1 = C.zone1 tpa → Lemmas.map_eq_sub_shift (C.pelts tpa1) (C.pelts np) (C.offset tpa1) (C.offset np) (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset tpa1 ∨ C.offset tpa1 + BitVec.toInt n ≤ j → C.pelts tpa1 j = C.pelts tpa j) → (C.zone1 tp1 = C.zone1 tpa1 ∧ C.max tp1 = C.min tpa1 ∧ C.writable tp1 = true ∧ C.writable tpa1 = true) ∧ (∀(tp2 : C.ptr (BitVec 64)), List.length (C.data tp2) = List.length (C.data tp1) ∧ C.offset tp2 = C.offset tp1 ∧ C.min tp2 = C.min tp1 ∧ C.writable tp2 = C.writable tp1 ∧ C.zone1 tp2 = C.zone1 tp1 → List.length (C.data tp2) = List.length (C.data tp1) ∧ C.offset tp2 = C.offset tp1 ∧ C.min tp2 = C.min tp1 ∧ C.writable tp2 = C.writable tp1 ∧ C.zone1 tp2 = C.zone1 tp1 → C.max tp2 = C.max tpa1 ∧ C.plength tp2 = C.plength tp1 ∧ (∀(i : ℤ), C.min tp1 ≤ i ∧ i < C.max tp1 → C.pelts tp2 i = C.pelts tp1 i) ∧ (∀(i : ℤ), C.min tpa1 ≤ i ∧ i < C.max tpa1 → C.pelts tp2 i = C.pelts tpa1 i) → Lemmas.value tp2 (BitVec.toInt n + BitVec.toInt adj) = HPow.hPow (2 : ℤ) (Int.toNat ((2 : ℤ) * BitVec.toUInt o5)) * HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt adj)) * Lemmas.value np (BitVec.toInt n) ∧ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt adj)) ≤ (4 : ℤ) * Lemmas.value tp2 (BitVec.toInt n + BitVec.toInt adj) ∧ C.max tp2 = C.max tp ∧ C.plength tp2 = C.plength tp))))))) ∧ (∀(tp1 : C.ptr (BitVec 64)) (np1 : C.ptr (BitVec 64)), C.offset tp1 = C.offset tp ∧ C.min tp1 = C.min tp ∧ C.writable tp1 = C.writable tp ∧ C.zone1 tp1 = C.zone1 tp → C.offset np1 = C.offset np ∧ C.writable np1 = C.writable np ∧ C.zone1 np1 = C.zone1 np → Lemmas.value tp1 (BitVec.toInt n + BitVec.toInt adj) = HPow.hPow (2 : ℤ) (Int.toNat ((2 : ℤ) * BitVec.toUInt o5)) * HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt adj)) * Lemmas.value np1 (BitVec.toInt n) ∧ HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt adj)) ≤ (4 : ℤ) * Lemmas.value tp1 (BitVec.toInt n + BitVec.toInt adj) ∧ C.max tp1 = C.max tp ∧ C.plength tp1 = C.plength tp ∧ (C.min np1 = C.min np ∧ C.max np1 = C.max np ∧ C.plength np1 = C.plength np) ∧ (∀(j : ℤ), C.pelts np1 j = C.pelts np j) → (∀(o19 : Bool), (BitVec.toInt adj = BitVec.toInt (0 : BitVec 32) → o19 = true) ∧ (o19 = true → adj = (0 : BitVec 32)) → (∀(o20 : BitVec 64), (if ¬o19 = true then o20 = (32 : BitVec 64) else o20 = (0 : BitVec 64)) → uint'64_in_bounds (BitVec.toUInt o5 + BitVec.toUInt o20) ∧ (∀(o21 : BitVec 64), BitVec.toUInt o21 = BitVec.toUInt o5 + BitVec.toUInt o20 → (let vn : ℤ := Lemmas.value np1 (BitVec.toInt n); (C.valid tp1 (BitVec.toInt o8 + BitVec.toInt o8) ∧ C.valid sp (BitVec.toInt o8) ∧ (1 : ℤ) ≤ BitVec.toInt o8 ∧ C.valid scratch ((1 : ℤ) + BitVec.toInt o8 / (2 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (2 : ℤ))) ≤ BitVec.toUInt (C.pelts tp1 (C.offset tp1 + BitVec.toInt o8 + BitVec.toInt o8 - (1 : ℤ))) ∧ (C.writable sp = true ∧ C.writable scratch = true ∧ C.writable tp1 = true) ∧ (4 : ℤ) * BitVec.toInt o8 < (2147483647 : ℤ)) ∧ (∀(tp2 : C.ptr (BitVec 64)) (scratch1 : C.ptr (BitVec 64)) (sp1 : C.ptr (BitVec 64)), C.offset tp2 = C.offset tp1 ∧ C.min tp2 = C.min tp1 ∧ C.writable tp2 = C.writable tp1 ∧ C.zone1 tp2 = C.zone1 tp1 → C.offset tp2 = C.offset tp1 ∧ C.min tp2 = C.min tp1 ∧ C.writable tp2 = C.writable tp1 ∧ C.zone1 tp2 = C.zone1 tp1 → C.offset scratch1 = C.offset scratch ∧ C.writable scratch1 = C.writable scratch ∧ C.zone1 scratch1 = C.zone1 scratch → C.offset sp1 = C.offset sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → (∀(o22 : BitVec 64), Lemmas.value sp1 (BitVec.toInt o8) * Lemmas.value sp1 (BitVec.toInt o8) + Lemmas.value tp2 (BitVec.toInt o8) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o8)) * BitVec.toUInt o22 = Lemmas.value tp1 (BitVec.toInt o8 + BitVec.toInt o8) ∧ Lemmas.value tp2 (BitVec.toInt o8) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o8)) * BitVec.toUInt o22 ≤ (2 : ℤ) * Lemmas.value sp1 (BitVec.toInt o8) ∧ HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (1 : ℤ))) ≤ BitVec.toUInt (C.pelts sp1 (C.offset sp1 + BitVec.toInt o8 - (1 : ℤ))) ∧ ((0 : ℤ) ≤ BitVec.toUInt o22 ∧ BitVec.toUInt o22 ≤ (1 : ℤ)) ∧ C.max tp2 = C.max tp1 ∧ C.min tp2 = C.min tp1 ∧ C.plength tp2 = C.plength tp1 ∧ C.max scratch1 = C.max scratch ∧ C.min scratch1 = C.min scratch ∧ C.plength scratch1 = C.plength scratch ∧ C.max sp1 = C.max sp ∧ C.min sp1 = C.min sp ∧ C.plength sp1 = C.plength sp → (let vs : ℤ := Lemmas.value sp1 (BitVec.toInt o8); let vr : ℤ := Lemmas.value tp2 (BitVec.toInt o8) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o8)) * BitVec.toUInt o22; let vs0 : ℤ := vs % HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o21)); (0 : ℤ) ≤ (1 : ℤ) ∧ (∀(s0 : C.ptr (BitVec 64)), C.plength s0 = (1 : ℤ) ∧ C.offset s0 = (0 : ℤ) ∧ C.min s0 = (0 : ℤ) ∧ C.max s0 = (1 : ℤ) ∧ C.writable s0 = true → (((0 : ℤ) ≤ BitVec.toUInt o21 ∧ BitVec.toUInt o21 < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o21)) * BitVec.toUInt (1 : BitVec 64) ≤ (18446744073709551615 : ℤ)) ∧ (∀(o23 : BitVec 64), BitVec.toUInt o23 = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o21)) * BitVec.toUInt (1 : BitVec 64) → (C.min sp1 ≤ C.offset sp1 ∧ C.offset sp1 < C.max sp1) ∧ (let o24 : BitVec 64 := C.pelts sp1 (C.offset sp1); (¬BitVec.toUInt o23 = (0 : ℤ) ∧ uint'64_in_bounds (Int.tmod (BitVec.toUInt o24) (BitVec.toUInt o23))) ∧ (∀(s00 : BitVec 64), BitVec.toUInt s00 = Int.tmod (BitVec.toUInt o24) (BitVec.toUInt o23) → ((C.min s0 ≤ C.offset s0 ∧ C.offset s0 < C.max s0) ∧ C.writable s0 = true) ∧ (∀(s01 : C.ptr (BitVec 64)), List.length (C.data s01) = List.length (C.data s0) ∧ C.offset s01 = C.offset s0 ∧ C.min s01 = C.min s0 ∧ C.max s01 = C.max s0 ∧ C.writable s01 = C.writable s0 ∧ C.zone1 s01 = C.zone1 s0 → C.pelts s01 = Function.update (C.pelts s0) (C.offset s01) s00 → uint'64_in_bounds ((2 : ℤ) * BitVec.toUInt s00) ∧ (∀(o25 : BitVec 64), BitVec.toUInt o25 = (2 : ℤ) * BitVec.toUInt s00 → (C.valid sp1 (BitVec.toInt o8) ∧ C.valid tp2 (BitVec.toInt o8) ∧ C.writable tp2 = true) ∧ (∀(tp3 : C.ptr (BitVec 64)), List.length (C.data tp3) = List.length (C.data tp2) ∧ C.offset tp3 = C.offset tp2 ∧ C.min tp3 = C.min tp2 ∧ C.max tp3 = C.max tp2 ∧ C.writable tp3 = C.writable tp2 ∧ C.zone1 tp3 = C.zone1 tp2 → List.length (C.data tp3) = List.length (C.data tp2) ∧ C.offset tp3 = C.offset tp2 ∧ C.min tp3 = C.min tp2 ∧ C.max tp3 = C.max tp2 ∧ C.writable tp3 = C.writable tp2 ∧ C.zone1 tp3 = C.zone1 tp2 → (∀(rc : BitVec 64), Lemmas.value tp3 (BitVec.toInt o8) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o8)) * BitVec.toUInt rc = Lemmas.value tp2 (BitVec.toInt o8) + Lemmas.value sp1 (BitVec.toInt o8) * BitVec.toUInt o25 ∧ (∀(j : ℤ), j < C.offset tp3 ∨ C.offset tp3 + BitVec.toInt o8 ≤ j → C.pelts tp3 j = C.pelts tp2 j) → uint'64_in_bounds (BitVec.toUInt o22 + BitVec.toUInt rc) ∧ (∀(o26 : BitVec 64), BitVec.toUInt o26 = BitVec.toUInt o22 + BitVec.toUInt rc → (C.valid s01 (1 : ℤ) ∧ C.valid tp3 (1 : ℤ) ∧ C.writable tp3 = true) ∧ (∀(tp4 : C.ptr (BitVec 64)), List.length (C.data tp4) = List.length (C.data tp3) ∧ C.offset tp4 = C.offset tp3 ∧ C.min tp4 = C.min tp3 ∧ C.max tp4 = C.max tp3 ∧ C.writable tp4 = C.writable tp3 ∧ C.zone1 tp4 = C.zone1 tp3 → List.length (C.data tp4) = List.length (C.data tp3) ∧ C.offset tp4 = C.offset tp3 ∧ C.min tp4 = C.min tp3 ∧ C.max tp4 = C.max tp3 ∧ C.writable tp4 = C.writable tp3 ∧ C.zone1 tp4 = C.zone1 tp3 → (∀(o27 : BitVec 64), Lemmas.value tp4 (1 : ℤ) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (1 : ℕ) * BitVec.toUInt o27 = Lemmas.value tp3 (1 : ℤ) - Lemmas.value s01 (1 : ℤ) * BitVec.toUInt s00 ∧ (∀(j : ℤ), j < C.offset tp4 ∨ C.offset tp4 + (1 : ℤ) ≤ j → C.pelts tp4 j = C.pelts tp3 j) → (if (1 : ℤ) < BitVec.toInt o8 then (C.min tp4 ≤ C.offset tp4 + (1 : ℤ) ∧ C.offset tp4 + (1 : ℤ) ≤ C.max tp4) ∧ (∀(tp11 : C.ptr (BitVec 64)), C.offset tp11 = C.offset tp4 + (1 : ℤ) ∧ C.plength tp11 = C.plength tp4 ∧ C.pelts tp11 = C.pelts tp4 ∧ C.data tp11 = C.data tp4 ∧ C.min tp11 = C.min tp4 ∧ C.max tp11 = C.max tp4 ∧ C.zone1 tp11 = C.zone1 tp4 ∧ C.writable tp11 = C.writable tp4 → int'32_in_bounds (BitVec.toInt o8 - (1 : ℤ)) ∧ (∀(o28 : BitVec 32), BitVec.toInt o28 = BitVec.toInt o8 - (1 : ℤ) → (C.valid tp11 (BitVec.toInt o28) ∧ (0 : ℤ) < BitVec.toInt o28 ∧ C.writable tp11 = true) ∧ (∀(tp12 : C.ptr (BitVec 64)) (tp5 : C.ptr (BitVec 64)), List.length (C.data tp12) = List.length (C.data tp11) ∧ C.offset tp12 = C.offset tp11 ∧ C.min tp12 = C.min tp11 ∧ C.max tp12 = C.max tp11 ∧ C.writable tp12 = C.writable tp11 ∧ C.zone1 tp12 = C.zone1 tp11 → C.data tp5 = C.data tp12 ∧ List.length (C.data tp12) = List.length (C.data tp4) ∧ C.offset tp5 = C.offset tp4 ∧ C.min tp5 = C.min tp4 ∧ C.max tp5 = C.max tp4 ∧ C.writable tp5 = C.writable tp4 ∧ C.zone1 tp5 = C.zone1 tp4 → (∀(o29 : BitVec 64), Lemmas.value tp12 (BitVec.toInt o28) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o28)) * BitVec.toUInt o29 = Lemmas.value tp11 (BitVec.toInt o28) - BitVec.toUInt o27 ∧ ((0 : ℤ) ≤ BitVec.toUInt o29 ∧ BitVec.toUInt o29 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset tp12 ∨ C.offset tp12 + BitVec.toInt o28 ≤ j → C.pelts tp12 j = C.pelts tp11 j) → uint'64_in_bounds (BitVec.toUInt o26 - BitVec.toUInt o29) ∧ (∀(o30 : BitVec 64), BitVec.toUInt o30 = BitVec.toUInt o26 - BitVec.toUInt o29 → Lemmas.value tp5 (BitVec.toInt o8) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o8)) * BitVec.toUInt o30 = vr + (2 : ℤ) * vs0 * vs - vs0 * vs0))))) else uint'64_in_bounds (BitVec.toUInt o26 - BitVec.toUInt o27) ∧ (∀(o28 : BitVec 64), BitVec.toUInt o28 = BitVec.toUInt o26 - BitVec.toUInt o27 → Lemmas.value tp4 (BitVec.toInt o8) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o8)) * BitVec.toUInt o28 = vr + (2 : ℤ) * vs0 * vs - vs0 * vs0)) ∧ (∀(rl : BitVec 64) (tp5 : C.ptr (BitVec 64)), List.length (C.data tp5) = List.length (C.data tp4) ∧ C.offset tp5 = C.offset tp4 ∧ C.min tp5 = C.min tp4 ∧ C.max tp5 = C.max tp4 ∧ C.writable tp5 = C.writable tp4 ∧ C.zone1 tp5 = C.zone1 tp4 → Lemmas.value tp5 (BitVec.toInt o8) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o8)) * BitVec.toUInt rl = vr + (2 : ℤ) * vs0 * vs - vs0 * vs0 → (((0 : ℤ) < BitVec.toUInt o21 ∧ BitVec.toUInt o21 < (64 : ℤ)) ∧ C.valid sp1 (BitVec.toInt o8) ∧ C.valid sp1 (BitVec.toInt o8) ∧ (0 : ℤ) < BitVec.toInt o8 ∧ C.writable sp1 = true ∧ (C.offset sp1 ≤ C.offset sp1 ∨ C.offset sp1 + BitVec.toInt o8 ≤ C.offset sp1)) ∧ (∀(sp2 : C.ptr (BitVec 64)), List.length (C.data sp2) = List.length (C.data sp1) ∧ C.offset sp2 = C.offset sp1 ∧ C.min sp2 = C.min sp1 ∧ C.max sp2 = C.max sp1 ∧ C.writable sp2 = C.writable sp1 ∧ C.zone1 sp2 = C.zone1 sp1 → (∀(r : BitVec 64), BitVec.toUInt r + ((18446744073709551615 : ℤ) + (1 : ℤ)) * Lemmas.value sp2 (BitVec.toInt o8) = Lemmas.value sp1 (BitVec.toInt o8) * HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - BitVec.toUInt o21)) ∧ (∀(j : ℤ), j < C.offset sp2 ∨ C.offset sp2 + BitVec.toInt o8 ≤ j → C.pelts sp2 j = C.pelts sp1 j) ∧ C.min sp2 = C.min sp1 ∧ C.max sp2 = C.max sp1 ∧ C.plength sp2 = C.plength sp1 → (let vsp : ℤ := Lemmas.value sp2 (BitVec.toInt o8); (0 : ℤ) < vn ∧ ((0 : ℤ) < vn → (((0 : ℤ) ≤ BitVec.toUInt (1 : BitVec 64) ∧ BitVec.toUInt (1 : BitVec 64) < (64 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt (1 : BitVec 64))) * BitVec.toUInt o21 ≤ (18446744073709551615 : ℤ)) ∧ (∀(o28 : BitVec 64), BitVec.toUInt o28 = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt (1 : BitVec 64))) * BitVec.toUInt o21 → (if BitVec.toUInt o28 < (64 : ℤ) then int'32_in_bounds (BitVec.toInt o8 + (1 : ℤ)) ∧ (∀(o29 : BitVec 32), BitVec.toInt o29 = BitVec.toInt o8 + (1 : ℤ) → HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o28)) * (vn - vsp * vsp) = Lemmas.value tp5 (BitVec.toInt o29) ∧ ((0 : ℤ) ≤ BitVec.toUInt o28 ∧ BitVec.toUInt o28 < (64 : ℤ)) ∧ C.valid tp5 (BitVec.toInt o29) ∧ (0 : ℤ) < BitVec.toInt o29 ∧ BitVec.toInt o29 ≤ k + (1 : ℤ)) else (C.min tp5 ≤ C.offset tp5 + (1 : ℤ) ∧ C.offset tp5 + (1 : ℤ) ≤ C.max tp5) ∧ (∀(tp11 : C.ptr (BitVec 64)), C.offset tp11 = C.offset tp5 + (1 : ℤ) ∧ C.plength tp11 = C.plength tp5 ∧ C.pelts tp11 = C.pelts tp5 ∧ C.data tp11 = C.data tp5 ∧ C.min tp11 = C.min tp5 ∧ C.max tp11 = C.max tp5 ∧ C.zone1 tp11 = C.zone1 tp5 ∧ C.writable tp11 = C.writable tp5 → uint'64_in_bounds (BitVec.toUInt o28 - (64 : ℤ)) ∧ (∀(o29 : BitVec 64), BitVec.toUInt o29 = BitVec.toUInt o28 - (64 : ℤ) → HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt o29)) * (vn - vsp * vsp) = Lemmas.value tp11 (BitVec.toInt o8) ∧ ((0 : ℤ) ≤ BitVec.toUInt o29 ∧ BitVec.toUInt o29 < (64 : ℤ)) ∧ C.valid tp11 (BitVec.toInt o8) ∧ (0 : ℤ) < BitVec.toInt o8 ∧ BitVec.toInt o8 ≤ k + (1 : ℤ)))) ∧ (∀(c2 : BitVec 64) (tp6 : C.ptr (BitVec 64)) (tn : BitVec 32), HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt c2)) * (vn - vsp * vsp) = Lemmas.value tp6 (BitVec.toInt tn) ∧ ((0 : ℤ) ≤ BitVec.toUInt c2 ∧ BitVec.toUInt c2 < (64 : ℤ)) ∧ C.valid tp6 (BitVec.toInt tn) ∧ (0 : ℤ) < BitVec.toInt tn ∧ BitVec.toInt tn ≤ k + (1 : ℤ) → (∀(o29 : Bool), (BitVec.toUInt c2 = BitVec.toUInt (0 : BitVec 64) → o29 = true) ∧ (o29 = true → c2 = (0 : BitVec 64)) → (if ¬o29 = true then (C.valid tp6 (BitVec.toInt tn) ∧ C.valid rp (BitVec.toInt tn) ∧ ((0 : ℤ) < BitVec.toUInt c2 ∧ BitVec.toUInt c2 < (64 : ℤ)) ∧ (0 : ℤ) < BitVec.toInt tn ∧ C.writable rp = true) ∧ (∀(o30 : C.ptr (BitVec 64)) (rp1 : C.ptr (BitVec 64)), C.offset o30 = C.offset tp6 ∧ C.writable o30 = C.writable tp6 ∧ C.zone1 o30 = C.zone1 tp6 → C.offset rp1 = C.offset rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → (∀(b : BitVec 64), BitVec.toUInt b + ((18446744073709551615 : ℤ) + (1 : ℤ)) * Lemmas.value rp1 (BitVec.toInt tn) = Lemmas.value o30 (BitVec.toInt tn) * HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - BitVec.toUInt c2)) ∧ (∀(j : ℤ), j < C.offset rp1 ∨ C.offset rp1 + BitVec.toInt tn ≤ j → C.pelts rp1 j = C.pelts rp j) ∧ C.pelts o30 = C.pelts tp6 ∧ (C.min o30 = C.min tp6 ∧ C.max o30 = C.max tp6 ∧ C.plength o30 = C.plength tp6) ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.plength rp1 = C.plength rp → Lemmas.value rp1 (BitVec.toInt tn) = vn - vsp * vsp ∧ ((0 : ℤ) < BitVec.toInt tn ∧ BitVec.toInt tn ≤ k + (1 : ℤ)) ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.plength rp1 = C.plength rp)) else (C.valid tp6 (BitVec.toInt tn) ∧ C.valid rp (BitVec.toInt tn) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → Lemmas.map_eq_sub_shift (C.pelts rp1) (C.pelts tp6) (C.offset rp1) (C.offset tp6) (BitVec.toInt tn) ∧ (∀(j : ℤ), j < C.offset rp1 ∨ C.offset rp1 + BitVec.toInt tn ≤ j → C.pelts rp1 j = C.pelts rp j) → Lemmas.value rp1 (BitVec.toInt tn) = vn - vsp * vsp ∧ ((0 : ℤ) < BitVec.toInt tn ∧ BitVec.toInt tn ≤ k + (1 : ℤ)) ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.plength rp1 = C.plength rp))) ∧ (∀(rn : BitVec 32) (rp1 : C.ptr (BitVec 64)), C.offset rp1 = C.offset rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → Lemmas.value rp1 (BitVec.toInt rn) = vn - vsp * vsp ∧ ((0 : ℤ) < BitVec.toInt rn ∧ BitVec.toInt rn ≤ k + (1 : ℤ)) ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.plength rp1 = C.plength rp → ((1 : ℤ) ≤ BitVec.toInt rn ∧ BitVec.toInt rn ≤ BitVec.toInt rn) ∧ (∀(rn1 : BitVec 32), Lemmas.value rp1 (BitVec.toInt rn1) = Lemmas.value rp1 (BitVec.toInt rn) ∧ (1 : ℤ) ≤ BitVec.toInt rn1 ∧ BitVec.toInt rn1 ≤ BitVec.toInt rn → int'32_in_bounds (BitVec.toInt rn1 - (1 : ℤ)) ∧ (∀(o29 : BitVec 32), BitVec.toInt o29 = BitVec.toInt rn1 - (1 : ℤ) → (C.min rp1 ≤ C.offset rp1 + BitVec.toInt o29 ∧ C.offset rp1 + BitVec.toInt o29 < C.max rp1) ∧ (let o30 : BitVec 64 := C.pelts rp1 (C.offset rp1 + BitVec.toInt o29); ∀(o31 : Bool), (BitVec.toUInt o30 = BitVec.toUInt (0 : BitVec 64) → o31 = true) ∧ (o31 = true → o30 = (0 : BitVec 64)) → (if o31 = true then int'32_in_bounds (BitVec.toInt rn1 - (1 : ℤ)) ∧ (∀(o32 : BitVec 32), BitVec.toInt o32 = BitVec.toInt rn1 - (1 : ℤ) → (∀(o33 : Bool), (BitVec.toInt o32 = BitVec.toInt (0 : BitVec 32) → o33 = true) ∧ (o33 = true → o32 = (0 : BitVec 32)) → (if o33 = true then Lemmas.value np1 (BitVec.toInt n) = Lemmas.value sp2 (ceilhalf (BitVec.toInt n)) * Lemmas.value sp2 (ceilhalf (BitVec.toInt n)) + Lemmas.value rp1 (BitVec.toInt o32) ∧ ((0 : ℤ) ≤ BitVec.toInt o32 ∧ BitVec.toInt o32 ≤ BitVec.toInt n) ∧ Lemmas.value rp1 (BitVec.toInt o32) ≤ (2 : ℤ) * Lemmas.value sp2 (ceilhalf (BitVec.toInt n)) ∧ ((0 : ℤ) < BitVec.toInt o32 → (0 : ℤ) < BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt o32 - (1 : ℤ)))) ∧ (∀(j : ℤ), C.pelts np1 j = C.pelts np j) ∧ C.max np1 = C.max np ∧ C.min np1 = C.min np ∧ C.plength np1 = C.plength np ∧ C.max rp1 = C.max rp ∧ C.min rp1 = C.min rp ∧ C.plength rp1 = C.plength rp ∧ C.max sp2 = C.max sp ∧ C.min sp2 = C.min sp ∧ C.plength sp2 = C.plength sp else BitVec.toInt o32 < BitVec.toInt rn1 ∧ Lemmas.value rp1 (BitVec.toInt o32) = Lemmas.value rp1 (BitVec.toInt rn) ∧ (1 : ℤ) ≤ BitVec.toInt o32 ∧ BitVec.toInt o32 ≤ BitVec.toInt rn))) else Lemmas.value np1 (BitVec.toInt n) = Lemmas.value sp2 (ceilhalf (BitVec.toInt n)) * Lemmas.value sp2 (ceilhalf (BitVec.toInt n)) + Lemmas.value rp1 (BitVec.toInt rn1) ∧ ((0 : ℤ) ≤ BitVec.toInt rn1 ∧ BitVec.toInt rn1 ≤ BitVec.toInt n) ∧ Lemmas.value rp1 (BitVec.toInt rn1) ≤ (2 : ℤ) * Lemmas.value sp2 (ceilhalf (BitVec.toInt n)) ∧ ((0 : ℤ) < BitVec.toInt rn1 → (0 : ℤ) < BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt rn1 - (1 : ℤ)))) ∧ (∀(j : ℤ), C.pelts np1 j = C.pelts np j) ∧ C.max np1 = C.max np ∧ C.min np1 = C.min np ∧ C.plength np1 = C.plength np ∧ C.max rp1 = C.max rp ∧ C.min rp1 = C.min rp ∧ C.plength rp1 = C.plength rp ∧ C.max sp2 = C.max sp ∧ C.min sp2 = C.min sp ∧ C.plength sp2 = C.plength sp))))))))))))))))))))))))))))))))))) else (C.valid np (BitVec.toInt n) ∧ C.valid rp (BitVec.toInt n) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)), List.length (C.data rp1) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → Lemmas.map_eq_sub_shift (C.pelts rp1) (C.pelts np) (C.offset rp1) (C.offset np) (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset rp1 ∨ C.offset rp1 + BitVec.toInt n ≤ j → C.pelts rp1 j = C.pelts rp j) → (C.valid rp1 (BitVec.toInt o8 + BitVec.toInt o8) ∧ C.valid sp (BitVec.toInt o8) ∧ (1 : ℤ) ≤ BitVec.toInt o8 ∧ C.valid scratch ((1 : ℤ) + BitVec.toInt o8 / (2 : ℤ)) ∧ HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (2 : ℤ))) ≤ BitVec.toUInt (C.pelts rp1 (C.offset rp1 + BitVec.toInt o8 + BitVec.toInt o8 - (1 : ℤ))) ∧ (C.writable sp = true ∧ C.writable scratch = true ∧ C.writable rp1 = true) ∧ (4 : ℤ) * BitVec.toInt o8 < (2147483647 : ℤ)) ∧ (∀(scratch1 : C.ptr (BitVec 64)) (rp2 : C.ptr (BitVec 64)) (sp1 : C.ptr (BitVec 64)), C.offset scratch1 = C.offset scratch ∧ C.writable scratch1 = C.writable scratch ∧ C.zone1 scratch1 = C.zone1 scratch → C.offset rp2 = C.offset rp1 ∧ C.min rp2 = C.min rp1 ∧ C.writable rp2 = C.writable rp1 ∧ C.zone1 rp2 = C.zone1 rp1 → C.offset sp1 = C.offset sp ∧ C.writable sp1 = C.writable sp ∧ C.zone1 sp1 = C.zone1 sp → (∀(h : BitVec 64), Lemmas.value sp1 (BitVec.toInt o8) * Lemmas.value sp1 (BitVec.toInt o8) + Lemmas.value rp2 (BitVec.toInt o8) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o8)) * BitVec.toUInt h = Lemmas.value rp1 (BitVec.toInt o8 + BitVec.toInt o8) ∧ Lemmas.value rp2 (BitVec.toInt o8) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o8)) * BitVec.toUInt h ≤ (2 : ℤ) * Lemmas.value sp1 (BitVec.toInt o8) ∧ HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (1 : ℤ))) ≤ BitVec.toUInt (C.pelts sp1 (C.offset sp1 + BitVec.toInt o8 - (1 : ℤ))) ∧ ((0 : ℤ) ≤ BitVec.toUInt h ∧ BitVec.toUInt h ≤ (1 : ℤ)) ∧ C.max rp2 = C.max rp1 ∧ C.min rp2 = C.min rp1 ∧ C.plength rp2 = C.plength rp1 ∧ C.max scratch1 = C.max scratch ∧ C.min scratch1 = C.min scratch ∧ C.plength scratch1 = C.plength scratch ∧ C.max sp1 = C.max sp ∧ C.min sp1 = C.min sp ∧ C.plength sp1 = C.plength sp → ((C.min rp2 ≤ C.offset rp2 + BitVec.toInt o8 ∧ C.offset rp2 + BitVec.toInt o8 < C.max rp2) ∧ C.writable rp2 = true) ∧ (∀(rp3 : C.ptr (BitVec 64)), List.length (C.data rp3) = List.length (C.data rp2) ∧ C.offset rp3 = C.offset rp2 ∧ C.min rp3 = C.min rp2 ∧ C.max rp3 = C.max rp2 ∧ C.writable rp3 = C.writable rp2 ∧ C.zone1 rp3 = C.zone1 rp2 → C.pelts rp3 = Function.update (C.pelts rp2) (C.offset rp3 + BitVec.toInt o8) h ∧ C.pelts rp3 (C.offset rp3 + BitVec.toInt o8) = h → BitVec.toUInt h ≤ (2147483647 : ℤ) ∧ (∀(o16 : BitVec 32), BitVec.toInt o16 = BitVec.toUInt h → int'32_in_bounds (BitVec.toInt o8 + BitVec.toInt o16) ∧ (∀(o17 : BitVec 32), BitVec.toInt o17 = BitVec.toInt o8 + BitVec.toInt o16 → ((1 : ℤ) ≤ BitVec.toInt o17 ∧ BitVec.toInt o17 ≤ BitVec.toInt o17) ∧ (∀(rn : BitVec 32), Lemmas.value rp3 (BitVec.toInt rn) = Lemmas.value rp3 (BitVec.toInt o17) ∧ (1 : ℤ) ≤ BitVec.toInt rn ∧ BitVec.toInt rn ≤ BitVec.toInt o17 → int'32_in_bounds (BitVec.toInt rn - (1 : ℤ)) ∧ (∀(o18 : BitVec 32), BitVec.toInt o18 = BitVec.toInt rn - (1 : ℤ) → (C.min rp3 ≤ C.offset rp3 + BitVec.toInt o18 ∧ C.offset rp3 + BitVec.toInt o18 < C.max rp3) ∧ (let o19 : BitVec 64 := C.pelts rp3 (C.offset rp3 + BitVec.toInt o18); ∀(o20 : Bool), (BitVec.toUInt o19 = BitVec.toUInt (0 : BitVec 64) → o20 = true) ∧ (o20 = true → o19 = (0 : BitVec 64)) → (if o20 = true then int'32_in_bounds (BitVec.toInt rn - (1 : ℤ)) ∧ (∀(o21 : BitVec 32), BitVec.toInt o21 = BitVec.toInt rn - (1 : ℤ) → (∀(o22 : Bool), (BitVec.toInt o21 = BitVec.toInt (0 : BitVec 32) → o22 = true) ∧ (o22 = true → o21 = (0 : BitVec 32)) → (if o22 = true then Lemmas.value np (BitVec.toInt n) = Lemmas.value sp1 (ceilhalf (BitVec.toInt n)) * Lemmas.value sp1 (ceilhalf (BitVec.toInt n)) + Lemmas.value rp3 (BitVec.toInt o21) ∧ ((0 : ℤ) ≤ BitVec.toInt o21 ∧ BitVec.toInt o21 ≤ BitVec.toInt n) ∧ Lemmas.value rp3 (BitVec.toInt o21) ≤ (2 : ℤ) * Lemmas.value sp1 (ceilhalf (BitVec.toInt n)) ∧ ((0 : ℤ) < BitVec.toInt o21 → (0 : ℤ) < BitVec.toUInt (C.pelts rp3 (C.offset rp3 + BitVec.toInt o21 - (1 : ℤ)))) ∧ C.max rp3 = C.max rp ∧ C.min rp3 = C.min rp ∧ C.plength rp3 = C.plength rp ∧ C.max sp1 = C.max sp ∧ C.min sp1 = C.min sp ∧ C.plength sp1 = C.plength sp else BitVec.toInt o21 < BitVec.toInt rn ∧ Lemmas.value rp3 (BitVec.toInt o21) = Lemmas.value rp3 (BitVec.toInt o17) ∧ (1 : ℤ) ≤ BitVec.toInt o21 ∧ BitVec.toInt o21 ≤ BitVec.toInt o17))) else Lemmas.value np (BitVec.toInt n) = Lemmas.value sp1 (ceilhalf (BitVec.toInt n)) * Lemmas.value sp1 (ceilhalf (BitVec.toInt n)) + Lemmas.value rp3 (BitVec.toInt rn) ∧ ((0 : ℤ) ≤ BitVec.toInt rn ∧ BitVec.toInt rn ≤ BitVec.toInt n) ∧ Lemmas.value rp3 (BitVec.toInt rn) ≤ (2 : ℤ) * Lemmas.value sp1 (ceilhalf (BitVec.toInt n)) ∧ ((0 : ℤ) < BitVec.toInt rn → (0 : ℤ) < BitVec.toUInt (C.pelts rp3 (C.offset rp3 + BitVec.toInt rn - (1 : ℤ)))) ∧ C.max rp3 = C.max rp ∧ C.min rp3 = C.min rp ∧ C.plength rp3 = C.plength rp ∧ C.max sp1 = C.max sp ∧ C.min sp1 = C.min sp ∧ C.plength sp1 = C.plength sp)))))))))))))))))))))))))))))
  := sorry
end sqrtrem_Sqrt_wmpn_sqrtremqtvc
