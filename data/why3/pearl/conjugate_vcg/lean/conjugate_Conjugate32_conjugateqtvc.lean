import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace conjugate_Conjugate32_conjugateqtvc
noncomputable def is_partition (a : array32 (BitVec 32)) := (0 : ℤ) < BitVec.toInt (array32_length a) ∧ (∀(i : ℤ) (j : ℤ), (0 : ℤ) ≤ i ∧ i ≤ j ∧ j < BitVec.toInt (array32_length a) → BitVec.toInt (array32_elts a j) ≤ BitVec.toInt (array32_elts a i)) ∧ BitVec.toInt (array32_elts a (BitVec.toInt (array32_length a) - (1 : ℤ))) = (0 : ℤ)
noncomputable def numofgt (a : array32 (BitVec 32)) (n : ℤ) (v : ℤ) := ((0 : ℤ) ≤ n ∧ n < BitVec.toInt (array32_length a)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < n → v < BitVec.toInt (array32_elts a j)) ∧ BitVec.toInt (array32_elts a n) ≤ v
noncomputable def is_conjugate (a : array32 (BitVec 32)) (b : array32 (BitVec 32)) := BitVec.toInt (array32_elts a (0 : ℤ)) < BitVec.toInt (array32_length b) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < BitVec.toInt (array32_length b) → numofgt a (BitVec.toInt (array32_elts b j)) j)
theorem conjugate'vc (a : array32 (BitVec 32)) (b : array32 (BitVec 32)) (fact0 : is_partition a) (fact1 : BitVec.toInt (array32_length b) = BitVec.toInt (array32_elts a (0 : ℤ)) + (1 : ℤ)) (fact2 : ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < BitVec.toInt (array32_length b) → BitVec.toInt (array32_elts b i) = (0 : ℤ)) : (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) < BitVec.toInt (array32_length a) ∧ (∀(j : ℤ), BitVec.toInt (array32_elts a (0 : ℤ)) ≤ j ∧ j < BitVec.toInt (array32_length b) → numofgt a (BitVec.toInt (array32_elts b j)) j) ∧ (∀(partc : BitVec 32) (b1 : array32 (BitVec 32)), array32_length b1 = array32_length b → ((0 : ℤ) ≤ BitVec.toInt partc ∧ BitVec.toInt partc < BitVec.toInt (array32_length a)) ∧ (∀(j : ℤ), BitVec.toInt (array32_elts a (BitVec.toInt partc)) ≤ j ∧ j < BitVec.toInt (array32_length b1) → numofgt a (BitVec.toInt (array32_elts b1 j)) j) → ((0 : ℤ) ≤ BitVec.toInt partc ∧ BitVec.toInt partc < BitVec.toInt (array32_length a)) ∧ (let o1 : BitVec 32 := array32_elts a (BitVec.toInt partc); (BitVec.toInt o1 = (0 : ℤ) → o1 = (0 : BitVec 32)) → (if ¬o1 = (0 : BitVec 32) then ((0 : ℤ) ≤ BitVec.toInt partc ∧ BitVec.toInt partc < BitVec.toInt (array32_length a)) ∧ (let edge : BitVec 32 := array32_elts a (BitVec.toInt partc); int'32_in_bounds (BitVec.toInt partc + (1 : ℤ)) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = BitVec.toInt partc + (1 : ℤ) → ((BitVec.toInt partc ≤ BitVec.toInt o2 ∧ BitVec.toInt o2 < BitVec.toInt (array32_length a)) ∧ (∀(j : ℤ), BitVec.toInt partc ≤ j ∧ j < BitVec.toInt o2 → array32_elts a j = edge)) ∧ (∀(partc1 : BitVec 32), (BitVec.toInt partc ≤ BitVec.toInt partc1 ∧ BitVec.toInt partc1 < BitVec.toInt (array32_length a)) ∧ (∀(j : ℤ), BitVec.toInt partc ≤ j ∧ j < BitVec.toInt partc1 → array32_elts a j = edge) → ((0 : ℤ) ≤ BitVec.toInt partc1 ∧ BitVec.toInt partc1 < BitVec.toInt (array32_length a)) ∧ (let o3 : BitVec 32 := array32_elts a (BitVec.toInt partc1); (BitVec.toInt o3 = BitVec.toInt edge → o3 = edge) → (if o3 = edge then int'32_in_bounds (BitVec.toInt partc1 + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt partc1 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt (array32_length a) - BitVec.toInt partc1 ∧ BitVec.toInt (array32_length a) - BitVec.toInt o4 < BitVec.toInt (array32_length a) - BitVec.toInt partc1) ∧ (BitVec.toInt partc ≤ BitVec.toInt o4 ∧ BitVec.toInt o4 < BitVec.toInt (array32_length a)) ∧ (∀(j : ℤ), BitVec.toInt partc ≤ j ∧ j < BitVec.toInt o4 → array32_elts a j = edge)) else int'32_in_bounds (BitVec.toInt edge - (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt edge - (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt partc1 ∧ BitVec.toInt partc1 < BitVec.toInt (array32_length a)) ∧ (let o5 : BitVec 32 := array32_elts a (BitVec.toInt partc1); (BitVec.toInt o5 ≤ BitVec.toInt o4 + (1 : ℤ) → (∀(j : ℤ), BitVec.toInt (array32_elts a (BitVec.toInt partc1)) ≤ j ∧ j < BitVec.toInt o5 → array32_elts b1 j = partc1) ∧ (∀(b2 : array32 (BitVec 32)), array32_length b2 = array32_length b1 → (∀(i : BitVec 32), let i1 : ℤ := BitVec.toInt i; (BitVec.toInt o5 ≤ i1 ∧ i1 ≤ BitVec.toInt o4) ∧ (∀(j : ℤ), BitVec.toInt edge ≤ j ∧ j < BitVec.toInt (array32_length b2) → array32_elts b2 j = array32_elts b1 j) ∧ (∀(j : ℤ), BitVec.toInt (array32_elts a (BitVec.toInt partc1)) ≤ j ∧ j < i1 → array32_elts b2 j = partc1) → ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i < BitVec.toInt (array32_length b2)) ∧ (∀(b3 : array32 (BitVec 32)), array32_length b3 = array32_length b2 → array32_elts b3 = Function.update (array32_elts b2) (BitVec.toInt i) partc1 → (∀(j : ℤ), BitVec.toInt edge ≤ j ∧ j < BitVec.toInt (array32_length b3) → array32_elts b3 j = array32_elts b1 j) ∧ (∀(j : ℤ), BitVec.toInt (array32_elts a (BitVec.toInt partc1)) ≤ j ∧ j < i1 + (1 : ℤ) → array32_elts b3 j = partc1))) ∧ ((∀(j : ℤ), BitVec.toInt edge ≤ j ∧ j < BitVec.toInt (array32_length b2) → array32_elts b2 j = array32_elts b1 j) ∧ (∀(j : ℤ), BitVec.toInt (array32_elts a (BitVec.toInt partc1)) ≤ j ∧ j < BitVec.toInt o4 + (1 : ℤ) → array32_elts b2 j = partc1) → ((0 : ℤ) ≤ BitVec.toInt (array32_length a) - BitVec.toInt partc ∧ BitVec.toInt (array32_length a) - BitVec.toInt partc1 < BitVec.toInt (array32_length a) - BitVec.toInt partc) ∧ ((0 : ℤ) ≤ BitVec.toInt partc1 ∧ BitVec.toInt partc1 < BitVec.toInt (array32_length a)) ∧ (∀(j : ℤ), BitVec.toInt (array32_elts a (BitVec.toInt partc1)) ≤ j ∧ j < BitVec.toInt (array32_length b2) → numofgt a (BitVec.toInt (array32_elts b2 j)) j)))) ∧ (BitVec.toInt o4 + (1 : ℤ) < BitVec.toInt o5 → ((0 : ℤ) ≤ BitVec.toInt (array32_length a) - BitVec.toInt partc ∧ BitVec.toInt (array32_length a) - BitVec.toInt partc1 < BitVec.toInt (array32_length a) - BitVec.toInt partc) ∧ ((0 : ℤ) ≤ BitVec.toInt partc1 ∧ BitVec.toInt partc1 < BitVec.toInt (array32_length a)) ∧ (∀(j : ℤ), BitVec.toInt (array32_elts a (BitVec.toInt partc1)) ≤ j ∧ j < BitVec.toInt (array32_length b1) → numofgt a (BitVec.toInt (array32_elts b1 j)) j))))))))) else is_conjugate a b1)))
  := sorry
end conjugate_Conjugate32_conjugateqtvc
