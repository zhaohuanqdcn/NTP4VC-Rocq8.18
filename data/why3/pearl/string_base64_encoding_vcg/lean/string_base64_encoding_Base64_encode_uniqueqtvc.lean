import Why3.Base
import Why3.string.StringBuffer
open Classical
open Lean4Why3
namespace string_base64_encoding_Base64_encode_uniqueqtvc
noncomputable def int2b64 (i : ℤ) := if (0 : ℤ) ≤ i ∧ i ≤ (25 : ℤ) then BitVec.ofNat 8 (Int.toNat (i + (65 : ℤ))) else if (26 : ℤ) ≤ i ∧ i ≤ (51 : ℤ) then BitVec.ofNat 8 (Int.toNat (i - (26 : ℤ) + (97 : ℤ))) else if (52 : ℤ) ≤ i ∧ i ≤ (61 : ℤ) then BitVec.ofNat 8 (Int.toNat (i - (52 : ℤ) + (48 : ℤ))) else if i = (62 : ℤ) then BitVec.ofNat 8 (43 : ℕ) else if i = (63 : ℤ) then BitVec.ofNat 8 (47 : ℕ) else BitVec.ofNat 8 (0 : ℕ)
noncomputable def valid_b64_char (c : BitVec 8) := (65 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (90 : ℤ) ∨ (97 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (122 : ℤ) ∨ (48 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (57 : ℤ) ∨ BitVec.toInt c = (43 : ℤ) ∨ BitVec.toInt c = (47 : ℤ)
noncomputable def b642int (c : BitVec 8) := if (65 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (90 : ℤ) then BitVec.toInt c - (65 : ℤ) else if (97 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (122 : ℤ) then BitVec.toInt c - (97 : ℤ) + (26 : ℤ) else if (48 : ℤ) ≤ BitVec.toInt c ∧ BitVec.toInt c ≤ (57 : ℤ) then BitVec.toInt c - (48 : ℤ) + (52 : ℤ) else if BitVec.toInt c = (43 : ℤ) then (62 : ℤ) else if BitVec.toInt c = (47 : ℤ) then (63 : ℤ) else if c = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) then (0 : ℤ) else (64 : ℤ)
noncomputable def get_pad (s : List (BitVec 8)) := if (1 : ℤ) ≤ Int.ofNat (List.length s) ∧ s[Int.toNat (Int.ofNat (List.length s) - (1 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) then if (2 : ℤ) ≤ Int.ofNat (List.length s) ∧ s[Int.toNat (Int.ofNat (List.length s) - (2 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) then (2 : ℤ) else (1 : ℤ) else (0 : ℤ)
noncomputable def calc_pad (s : List (BitVec 8)) := if Int.tmod (Int.ofNat (List.length s)) (3 : ℤ) = (1 : ℤ) then (2 : ℤ) else if Int.tmod (Int.ofNat (List.length s)) (3 : ℤ) = (2 : ℤ) then (1 : ℤ) else (0 : ℤ)
noncomputable def encoding (s1 : List (BitVec 8)) (s2 : List (BitVec 8)) := Int.ofNat (List.length s2) = Int.tdiv (Int.ofNat (List.length s1) + calc_pad s1) (3 : ℤ) * (4 : ℤ) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.tdiv (Int.ofNat (List.length s2)) (4 : ℤ) → (match (s2[Int.toNat ((4 : ℤ) * i)]!, s2[Int.toNat ((4 : ℤ) * i + (1 : ℤ))]!, s2[Int.toNat ((4 : ℤ) * i + (2 : ℤ))]!, s2[Int.toNat ((4 : ℤ) * i + (3 : ℤ))]!) with | (b1, b2, b3, b4) => s1[Int.toNat (i * (3 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (b642int b1 * (4 : ℤ) + Int.tdiv (b642int b2) (16 : ℤ))) ∧ (i * (3 : ℤ) + (1 : ℤ) < Int.ofNat (List.length s1) → s1[Int.toNat (i * (3 : ℤ) + (1 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (Int.tmod (b642int b2) (16 : ℤ) * (16 : ℤ) + Int.tdiv (b642int b3) (4 : ℤ)))) ∧ (i * (3 : ℤ) + (2 : ℤ) < Int.ofNat (List.length s1) → s1[Int.toNat (i * (3 : ℤ) + (2 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (Int.tmod (b642int b3) (4 : ℤ) * (64 : ℤ) + b642int b4))))) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s2) - get_pad s2 → valid_b64_char (s2[Int.toNat i]!)) ∧ (get_pad s2 = (1 : ℤ) → Int.tmod (b642int (s2[Int.toNat (Int.ofNat (List.length s2) - (2 : ℤ))]!)) (4 : ℤ) = (0 : ℤ) ∧ s2[Int.toNat (Int.ofNat (List.length s2) - (1 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63)))) ∧ (get_pad s2 = (2 : ℤ) → Int.tmod (b642int (s2[Int.toNat (Int.ofNat (List.length s2) - (3 : ℤ))]!)) (16 : ℤ) = (0 : ℤ) ∧ s2[Int.toNat (Int.ofNat (List.length s2) - (2 : ℤ))]! = s2[Int.toNat (Int.ofNat (List.length s2) - (1 : ℤ))]! ∧ s2[Int.toNat (Int.ofNat (List.length s2) - (1 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63)))) ∧ calc_pad s1 = get_pad s2
noncomputable def valid_b64 (s : List (BitVec 8)) := Int.tmod (Int.ofNat (List.length s)) (4 : ℤ) = (0 : ℤ) ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length s) - get_pad s → valid_b64_char (s[Int.toNat i]!)) ∧ (get_pad s = (1 : ℤ) → Int.tmod (b642int (s[Int.toNat (Int.ofNat (List.length s) - (2 : ℤ))]!)) (4 : ℤ) = (0 : ℤ) ∧ s[Int.toNat (Int.ofNat (List.length s) - (1 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63)))) ∧ (get_pad s = (2 : ℤ) → Int.tmod (b642int (s[Int.toNat (Int.ofNat (List.length s) - (3 : ℤ))]!)) (16 : ℤ) = (0 : ℤ) ∧ s[Int.toNat (Int.ofNat (List.length s) - (2 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))) ∧ s[Int.toNat (Int.ofNat (List.length s) - (1 : ℤ))]! = BitVec.ofNat 8 (Int.toNat (BitVec.toInt (61 : BitVec 63))))
theorem encode_unique'vc (s1 : List (BitVec 8)) (s2 : List (BitVec 8)) (s3 : List (BitVec 8)) (fact0 : encoding s1 s2) (fact1 : encoding s1 s3) : s2 = s3
  := sorry
end string_base64_encoding_Base64_encode_uniqueqtvc
