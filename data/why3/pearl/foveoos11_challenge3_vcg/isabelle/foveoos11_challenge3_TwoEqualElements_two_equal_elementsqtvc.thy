theory foveoos11_challenge3_TwoEqualElements_two_equal_elementsqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref"
begin
definition appear_twice :: "int list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> _"
  where "appear_twice a v u \<longleftrightarrow> (\<exists>(i :: int). ((0 :: int) \<le> i \<and> i < u) \<and> a ! nat i = v \<and> (\<exists>(j :: int). ((0 :: int) \<le> j \<and> j < u) \<and> \<not>j = i \<and> a ! nat j = v))" for a v u
theorem two_equal_elements'vc:
  fixes a :: "int list"
  fixes n :: "int"
  assumes fact0: "int (length a) = n + (2 :: int)"
  assumes fact1: "(2 :: int) \<le> n"
  assumes fact2: "\<forall>(i :: int). (0 :: int) \<le> i \<and> i < int (length a) \<longrightarrow> (0 :: int) \<le> a ! nat i \<and> a ! nat i < n"
  assumes fact3: "\<exists>(v1 :: int). appear_twice a v1 (n + (2 :: int)) \<and> (\<exists>(v2 :: int). appear_twice a v2 (n + (2 :: int)) \<and> \<not>v2 = v1)"
  shows "(0 :: int) \<le> n"
  and "\<forall>(deja_vu :: bool list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < n \<longrightarrow> deja_vu ! nat i = False) \<and> int (length deja_vu) = n \<longrightarrow> (let o1 :: int = n + (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((\<forall>(v :: int). (0 :: int) \<le> v \<and> v < n \<longrightarrow> (if deja_vu ! nat v = True then \<exists>(j :: int). ((0 :: int) \<le> j \<and> j < (0 :: int)) \<and> a ! nat j = v else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < (0 :: int) \<longrightarrow> \<not>a ! nat j = v)) \<and> (\<forall>(v :: int). (0 :: int) \<le> v \<and> v < n \<longrightarrow> \<not>appear_twice a v (0 :: int)) \<and> (\<forall>(v :: int). (0 :: int) \<le> v \<and> v < n \<longrightarrow> \<not>v = -(1 :: int) \<longrightarrow> \<not>appear_twice a v (0 :: int))) \<and> (\<forall>(v2 :: int) (v1 :: int) (deja_vu1 :: bool list). length deja_vu1 = length deja_vu \<longrightarrow> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o1) \<and> (v1 = -(1 :: int) \<longrightarrow> v2 = -(1 :: int)) \<and> (\<not>v1 = -(1 :: int) \<longrightarrow> appear_twice a v1 i) \<and> (\<not>v2 = -(1 :: int) \<longrightarrow> appear_twice a v2 i \<and> \<not>v2 = v1) \<and> (\<forall>(v :: int). (0 :: int) \<le> v \<and> v < n \<longrightarrow> (if deja_vu1 ! nat v = True then \<exists>(j :: int). ((0 :: int) \<le> j \<and> j < i) \<and> a ! nat j = v else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < i \<longrightarrow> \<not>a ! nat j = v)) \<and> (v1 = -(1 :: int) \<longrightarrow> (\<forall>(v :: int). (0 :: int) \<le> v \<and> v < n \<longrightarrow> \<not>appear_twice a v i)) \<and> (v2 = -(1 :: int) \<longrightarrow> (\<forall>(v :: int). (0 :: int) \<le> v \<and> v < n \<longrightarrow> \<not>v = v1 \<longrightarrow> \<not>appear_twice a v i)) \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (let v :: int = a ! nat i in ((0 :: int) \<le> v \<and> v < int (length deja_vu1)) \<and> (if deja_vu1 ! nat v = True then if v1 = -(1 :: int) then (v = -(1 :: int) \<longrightarrow> v2 = -(1 :: int)) \<and> (\<not>v = -(1 :: int) \<longrightarrow> appear_twice a v (i + (1 :: int))) \<and> (\<not>v2 = -(1 :: int) \<longrightarrow> appear_twice a v2 (i + (1 :: int)) \<and> \<not>v2 = v) \<and> (\<forall>(v3 :: int). (0 :: int) \<le> v3 \<and> v3 < n \<longrightarrow> (if deja_vu1 ! nat v3 = True then \<exists>(j :: int). ((0 :: int) \<le> j \<and> j < i + (1 :: int)) \<and> a ! nat j = v3 else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> \<not>a ! nat j = v3)) \<and> (v = -(1 :: int) \<longrightarrow> (\<forall>(v3 :: int). (0 :: int) \<le> v3 \<and> v3 < n \<longrightarrow> \<not>appear_twice a v3 (i + (1 :: int)))) \<and> (v2 = -(1 :: int) \<longrightarrow> (\<forall>(v3 :: int). (0 :: int) \<le> v3 \<and> v3 < n \<longrightarrow> \<not>v3 = v \<longrightarrow> \<not>appear_twice a v3 (i + (1 :: int)))) else \<forall>(o2 :: bool). (if v2 = -(1 :: int) then o2 = (if v = v1 then False else True) else o2 = False) \<longrightarrow> (if o2 = True then (v1 = -(1 :: int) \<longrightarrow> v = -(1 :: int)) \<and> (\<not>v1 = -(1 :: int) \<longrightarrow> appear_twice a v1 (i + (1 :: int))) \<and> (\<not>v = -(1 :: int) \<longrightarrow> appear_twice a v (i + (1 :: int)) \<and> \<not>v = v1) \<and> (\<forall>(v3 :: int). (0 :: int) \<le> v3 \<and> v3 < n \<longrightarrow> (if deja_vu1 ! nat v3 = True then \<exists>(j :: int). ((0 :: int) \<le> j \<and> j < i + (1 :: int)) \<and> a ! nat j = v3 else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> \<not>a ! nat j = v3)) \<and> (v1 = -(1 :: int) \<longrightarrow> (\<forall>(v3 :: int). (0 :: int) \<le> v3 \<and> v3 < n \<longrightarrow> \<not>appear_twice a v3 (i + (1 :: int)))) \<and> (v = -(1 :: int) \<longrightarrow> (\<forall>(v3 :: int). (0 :: int) \<le> v3 \<and> v3 < n \<longrightarrow> \<not>v3 = v1 \<longrightarrow> \<not>appear_twice a v3 (i + (1 :: int)))) else (v1 = -(1 :: int) \<longrightarrow> v2 = -(1 :: int)) \<and> (\<not>v1 = -(1 :: int) \<longrightarrow> appear_twice a v1 (i + (1 :: int))) \<and> (\<not>v2 = -(1 :: int) \<longrightarrow> appear_twice a v2 (i + (1 :: int)) \<and> \<not>v2 = v1) \<and> (\<forall>(v3 :: int). (0 :: int) \<le> v3 \<and> v3 < n \<longrightarrow> (if deja_vu1 ! nat v3 = True then \<exists>(j :: int). ((0 :: int) \<le> j \<and> j < i + (1 :: int)) \<and> a ! nat j = v3 else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> \<not>a ! nat j = v3)) \<and> (v1 = -(1 :: int) \<longrightarrow> (\<forall>(v3 :: int). (0 :: int) \<le> v3 \<and> v3 < n \<longrightarrow> \<not>appear_twice a v3 (i + (1 :: int)))) \<and> (v2 = -(1 :: int) \<longrightarrow> (\<forall>(v3 :: int). (0 :: int) \<le> v3 \<and> v3 < n \<longrightarrow> \<not>v3 = v1 \<longrightarrow> \<not>appear_twice a v3 (i + (1 :: int))))) else let o2 :: bool = True in ((0 :: int) \<le> v \<and> v < int (length deja_vu1)) \<and> (length (deja_vu1[nat v := o2]) = length deja_vu1 \<longrightarrow> nth (deja_vu1[nat v := o2]) o nat = (nth deja_vu1 o nat)(v := o2) \<longrightarrow> (v1 = -(1 :: int) \<longrightarrow> v2 = -(1 :: int)) \<and> (\<not>v1 = -(1 :: int) \<longrightarrow> appear_twice a v1 (i + (1 :: int))) \<and> (\<not>v2 = -(1 :: int) \<longrightarrow> appear_twice a v2 (i + (1 :: int)) \<and> \<not>v2 = v1) \<and> (\<forall>(v3 :: int). (0 :: int) \<le> v3 \<and> v3 < n \<longrightarrow> (if deja_vu1[nat v := o2] ! nat v3 = True then \<exists>(j :: int). ((0 :: int) \<le> j \<and> j < i + (1 :: int)) \<and> a ! nat j = v3 else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < i + (1 :: int) \<longrightarrow> \<not>a ! nat j = v3)) \<and> (v1 = -(1 :: int) \<longrightarrow> (\<forall>(v3 :: int). (0 :: int) \<le> v3 \<and> v3 < n \<longrightarrow> \<not>appear_twice a v3 (i + (1 :: int)))) \<and> (v2 = -(1 :: int) \<longrightarrow> (\<forall>(v3 :: int). (0 :: int) \<le> v3 \<and> v3 < n \<longrightarrow> \<not>v3 = v1 \<longrightarrow> \<not>appear_twice a v3 (i + (1 :: int)))))))) \<and> ((v1 = -(1 :: int) \<longrightarrow> v2 = -(1 :: int)) \<and> (\<not>v1 = -(1 :: int) \<longrightarrow> appear_twice a v1 (o1 + (1 :: int))) \<and> (\<not>v2 = -(1 :: int) \<longrightarrow> appear_twice a v2 (o1 + (1 :: int)) \<and> \<not>v2 = v1) \<and> (\<forall>(v :: int). (0 :: int) \<le> v \<and> v < n \<longrightarrow> (if deja_vu1 ! nat v = True then \<exists>(j :: int). ((0 :: int) \<le> j \<and> j < o1 + (1 :: int)) \<and> a ! nat j = v else \<forall>(j :: int). (0 :: int) \<le> j \<and> j < o1 + (1 :: int) \<longrightarrow> \<not>a ! nat j = v)) \<and> (v1 = -(1 :: int) \<longrightarrow> (\<forall>(v :: int). (0 :: int) \<le> v \<and> v < n \<longrightarrow> \<not>appear_twice a v (o1 + (1 :: int)))) \<and> (v2 = -(1 :: int) \<longrightarrow> (\<forall>(v :: int). (0 :: int) \<le> v \<and> v < n \<longrightarrow> \<not>v = v1 \<longrightarrow> \<not>appear_twice a v (o1 + (1 :: int)))) \<longrightarrow> appear_twice a v1 (n + (2 :: int)) \<and> appear_twice a v2 (n + (2 :: int)) \<and> \<not>v1 = v2))) \<and> \<not>o1 + (1 :: int) < (0 :: int))"
  sorry
end
