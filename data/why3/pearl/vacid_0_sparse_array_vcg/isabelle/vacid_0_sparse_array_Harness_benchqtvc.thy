theory vacid_0_sparse_array_Harness_benchqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.map_MapInjection" "./vacid_0_sparse_array_SparseArray"
begin
typedecl  elt
consts default :: "elt"
consts c1 :: "elt"
consts c2 :: "elt"
consts infix_exeq :: "elt \<Rightarrow> elt \<Rightarrow> bool"
axiomatization where infix_exeq'spec:   "infix_exeq x y \<longleftrightarrow> \<not>x = y"
  for x :: "elt"
  and y :: "elt"
theorem bench'vc:
  shows "(0 :: int) \<le> (10 :: int)"
  and "(10 :: int) \<le> (1000 :: int)"
  and "\<forall>(a :: elt sparse_array). card a = (0 :: int) \<and> def1 a = default \<and> vacid_0_sparse_array_SparseArray.length a = (10 :: int) \<longrightarrow> ((0 :: int) \<le> (20 :: int) \<and> (20 :: int) \<le> (1000 :: int)) \<and> (\<forall>(b :: elt sparse_array). card b = (0 :: int) \<and> def1 b = default \<and> vacid_0_sparse_array_SparseArray.length b = (20 :: int) \<longrightarrow> (let o1 :: elt = default in ((0 :: int) \<le> (5 :: int) \<and> (5 :: int) < vacid_0_sparse_array_SparseArray.length a) \<and> (let o2 :: elt = value a (5 :: int) in (infix_exeq o2 o1 \<longleftrightarrow> \<not>o2 = o1) \<longrightarrow> \<not>infix_exeq o2 o1 \<longrightarrow> (let o3 :: elt = default in ((0 :: int) \<le> (7 :: int) \<and> (7 :: int) < vacid_0_sparse_array_SparseArray.length b) \<and> (let o4 :: elt = value b (7 :: int) in (infix_exeq o4 o3 \<longleftrightarrow> \<not>o4 = o3) \<longrightarrow> \<not>infix_exeq o4 o3 \<longrightarrow> ((0 :: int) \<le> (5 :: int) \<and> (5 :: int) < vacid_0_sparse_array_SparseArray.length a) \<and> (\<forall>(a1 :: elt sparse_array). List.length (values a1) = List.length (values a) \<and> List.length (index a1) = List.length (index a) \<and> List.length (back a1) = List.length (back a) \<longrightarrow> def1 a = def1 a1 \<longrightarrow> value a1 (5 :: int) = c1 \<and> (\<forall>(j :: int). \<not>j = (5 :: int) \<longrightarrow> value a1 j = value a j) \<longrightarrow> ((0 :: int) \<le> (7 :: int) \<and> (7 :: int) < vacid_0_sparse_array_SparseArray.length b) \<and> (\<forall>(b1 :: elt sparse_array). List.length (values b1) = List.length (values b) \<and> List.length (index b1) = List.length (index b) \<and> List.length (back b1) = List.length (back b) \<longrightarrow> def1 b = def1 b1 \<longrightarrow> value b1 (7 :: int) = c2 \<and> (\<forall>(j :: int). \<not>j = (7 :: int) \<longrightarrow> value b1 j = value b j) \<longrightarrow> (let o5 :: elt = c1 in ((0 :: int) \<le> (5 :: int) \<and> (5 :: int) < vacid_0_sparse_array_SparseArray.length a1) \<and> (let o6 :: elt = value a1 (5 :: int) in (infix_exeq o6 o5 \<longleftrightarrow> \<not>o6 = o5) \<longrightarrow> \<not>infix_exeq o6 o5 \<longrightarrow> (let o7 :: elt = c2 in ((0 :: int) \<le> (7 :: int) \<and> (7 :: int) < vacid_0_sparse_array_SparseArray.length b1) \<and> (let o8 :: elt = value b1 (7 :: int) in (infix_exeq o8 o7 \<longleftrightarrow> \<not>o8 = o7) \<longrightarrow> \<not>infix_exeq o8 o7 \<longrightarrow> (let o9 :: elt = default in ((0 :: int) \<le> (7 :: int) \<and> (7 :: int) < vacid_0_sparse_array_SparseArray.length a1) \<and> (let o10 :: elt = value a1 (7 :: int) in (infix_exeq o10 o9 \<longleftrightarrow> \<not>o10 = o9) \<longrightarrow> \<not>infix_exeq o10 o9 \<longrightarrow> (let o11 :: elt = default in ((0 :: int) \<le> (5 :: int) \<and> (5 :: int) < vacid_0_sparse_array_SparseArray.length b1) \<and> (let o12 :: elt = value b1 (5 :: int) in (infix_exeq o12 o11 \<longleftrightarrow> \<not>o12 = o11) \<longrightarrow> \<not>infix_exeq o12 o11 \<longrightarrow> (let o13 :: elt = default in ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < vacid_0_sparse_array_SparseArray.length a1) \<and> (let o14 :: elt = value a1 (0 :: int) in (infix_exeq o14 o13 \<longleftrightarrow> \<not>o14 = o13) \<longrightarrow> \<not>infix_exeq o14 o13 \<longrightarrow> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) < vacid_0_sparse_array_SparseArray.length b1)))))))))))))))))"
  sorry
end
