(* ---------------------------------------------------------- *)
(* --- Post-condition 'left' in 'rotate'                  --- *)
(* ---------------------------------------------------------- *)
theory VCrotate_post_left
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition 'left' in 'rotate'":
*)
goal goal0:
  forall i_1 i : int.
  forall t : map int int.
  forall t_7 t_6 t_5 t_4 t_3 t_2 t_1 : map addr int.
  forall a : addr.
  let x = i_1 - i in
  let a_1 = (shift_sint32 a 0) in
  let a_2 = (shift_sint32 a x) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (i <= 4294967295) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 x)) ->
  ((valid_rw t a_1 i_1)) ->
  (if (i < i_1)
   then (if (0 < i)
         then ((((havoc t_3 t_5 a_1 i_1)) = t_7) /\
               (((havoc t_1 t_6 a_1 x)) = t_4) /\
               (((havoc t_2 t_4 a_2 i)) = t_5) /\ ((valid_rw t a_1 x)) /\
               ((p_reverse_6_ t_4 t_6 a x)) /\ ((valid_rw t a_2 i)) /\
               ((p_reverse_4_ t_5 t_6 a 0 x 0)) /\
               ((p_reverse_4_ t_5 t_6 a x i_1 x)) /\
               ((p_reverse_4_ t_7 t_5 a 0 x i)) /\
               ((p_reverse_4_ t_7 t_5 a x i_1 0)) /\
               ((p_reverse_6_ t_5 t_4 a_2 i))) else (t_7 = t_6))
   else (t_7 = t_6)) ->
  ((p_equalranges_4_ t_7 t_6 a 0 x i))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'right' in 'rotate'                 --- *)
(* ---------------------------------------------------------- *)
theory VCrotate_post_right
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition 'right' in 'rotate'":
*)
goal goal1:
  forall i_1 i : int.
  forall t : map int int.
  forall t_7 t_6 t_5 t_4 t_3 t_2 t_1 : map addr int.
  forall a : addr.
  let x = i_1 - i in
  let a_1 = (shift_sint32 a 0) in
  let a_2 = (shift_sint32 a x) in
  (0 <= i) ->
  (((region (a.base))) <= 0) ->
  (i <= 4294967295) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 x)) ->
  ((valid_rw t a_1 i_1)) ->
  (if (i < i_1)
   then (if (0 < i)
         then ((((havoc t_3 t_5 a_1 i_1)) = t_7) /\
               (((havoc t_1 t_6 a_1 x)) = t_4) /\
               (((havoc t_2 t_4 a_2 i)) = t_5) /\ ((valid_rw t a_1 x)) /\
               ((p_reverse_6_ t_4 t_6 a x)) /\ ((valid_rw t a_2 i)) /\
               ((p_reverse_4_ t_5 t_6 a 0 x 0)) /\
               ((p_reverse_4_ t_5 t_6 a x i_1 x)) /\
               ((p_reverse_4_ t_7 t_5 a 0 x i)) /\
               ((p_reverse_4_ t_7 t_5 a x i_1 0)) /\
               ((p_reverse_6_ t_5 t_4 a_2 i))) else (t_7 = t_6))
   else (t_7 = t_6)) ->
  ((p_equalranges_4_ t_7 t_6 a x i_1 0))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,unsigned_overflow' (file rotate.c, line 10) --- *)
(* ---------------------------------------------------------- *)
theory VCrotate_assert_rte_unsigned_overflow_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Assertion 'rte,unsigned_overflow' (file rotate.c, line 10)":
*)
goal goal2:
  forall i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  (0 < i_1) ->
  (i_1 <= i) ->
  (i_1 < i) ->
  (((region (a.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_1 i)) ->
  ((valid_rw t a_1 i_1)) ->
  ((p_reverse_6_ ((havoc t_1 t_2 a_1 i_1)) t_2 a i_1)) ->
  (i <= (4294967295 + i_1))

end

(* ---------------------------------------------------------- *)
(* --- Assertion 'rte,unsigned_overflow' (file rotate.c, line 27) --- *)
(* ---------------------------------------------------------- *)
theory VCrotate_assert_rte_unsigned_overflow_4
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Assertion 'rte,unsigned_overflow' (file rotate.c, line 27)":
*)
goal goal3:
  forall i_1 i : int.
  forall t : map int int.
  forall t_4 t_3 t_2 t_1 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  let x = 4294967295 + i_1 in
  let a_2 = (shift_sint32 a i_1) in
  let x_1 = i - i_1 in
  let a_3 = (havoc t_1 t_4 a_1 i_1) in
  let a_4 = (havoc t_2 a_3 a_2 x_1) in
  let a_5 = (havoc t_3 a_4 a_1 i) in
  (i_1 < i) ->
  (((region (a.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_1 i)) ->
  ((i_1 <= 0) \/
   ((i <= x) /\ ((valid_rw t a_1 i_1)) /\ ((valid_rw t a_2 x_1)) /\
    ((p_reverse_6_ a_3 t_4 a i_1)) /\ ((p_reverse_6_ a_4 a_3 a_2 x_1)) /\
    ((p_reverse_4_ a_4 t_4 a 0 i_1 0)) /\
    ((p_reverse_4_ a_4 t_4 a i_1 i i_1)) /\
    ((p_reverse_4_ a_5 a_4 a 0 i_1 x_1)) /\
    ((p_reverse_4_ a_5 a_4 a i_1 i 0)))) ->
  (i <= x)

end

(* ---------------------------------------------------------- *)
(* --- Assigns (file rotate.h, line 11) in 'rotate' (2/3) --- *)
(* ---------------------------------------------------------- *)
theory VCrotate_assign_exit_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Assigns (file rotate.h, line 11) in 'rotate' (2/3)":
*)
goal goal4:
  forall i_2 i_1 i : int.
  forall t : map int int.
  forall t_3 t_2 t_1 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  let a_2 = (havoc t_1 t_3 a_1 i_2) in
  let a_3 = (shift_sint32 a i_2) in
  let x = i_1 - i_2 in
  (0 < i_2) ->
  (i_2 <= i_1) ->
  (i_2 < i_1) ->
  (((region (a.base))) <= 0) ->
  (i_1 <= (4294967295 + i_2)) ->
  ((linked t)) ->
  ((is_uint32 i_1)) ->
  ((is_uint32 i_2)) ->
  ((is_sint32 i)) ->
  ((valid_rw t a_1 i_1)) ->
  ((valid_rw t a_1 i_2)) ->
  ((p_reverse_6_ a_2 t_3 a i_2)) ->
  ((((valid_rw t a_3 x)) /\ (not (invalid t a_3 x))) \/
   (((valid_rw t a_3 x)) /\ (not (invalid t a_3 x)) /\
    ((p_reverse_6_ ((havoc t_2 a_2 a_3 x)) a_2 a_3 x)))) ->
  ((included a_3 x a_1 i_1))

end

(* ---------------------------------------------------------- *)
(* --- Assigns (file rotate.h, line 11) in 'rotate' (2/4) --- *)
(* ---------------------------------------------------------- *)
theory VCrotate_assign_normal_part2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Assigns (file rotate.h, line 11) in 'rotate' (2/4)":
*)
goal goal5:
  forall i_1 i : int.
  forall t : map int int.
  forall t_3 t_2 t_1 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  let a_2 = (shift_sint32 a i_1) in
  let x = i - i_1 in
  let a_3 = (havoc t_1 t_3 a_1 i_1) in
  (0 < i_1) ->
  (i_1 <= i) ->
  (i_1 < i) ->
  (((region (a.base))) <= 0) ->
  (i <= (4294967295 + i_1)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_1 i)) ->
  ((valid_rw t a_1 i_1)) ->
  ((valid_rw t a_2 x)) ->
  (not (invalid t a_2 x)) ->
  ((p_reverse_6_ a_3 t_3 a i_1)) ->
  ((p_reverse_6_ ((havoc t_2 a_3 a_2 x)) a_3 a_2 x)) ->
  ((included a_2 x a_1 i))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition 'valid' in 'reverse'' in 'rotate' at call 'reverse' (file rotate.c, line 9)
 --- *)
(* ---------------------------------------------------------- *)
theory VCrotate_call_reverse_pre_valid
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound

(*
goal WP "expl:Instance of 'Pre-condition 'valid' in 'reverse'' in 'rotate' at call 'reverse' (file rotate.c, line 9)
":
*)
goal goal6:
  forall i_1 i : int.
  forall t : map int int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  (0 < i_1) ->
  (i_1 <= i) ->
  (i_1 < i) ->
  (((region (a.base))) <= 0) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_1 i)) ->
  ((valid_rw t a_1 i_1))

end

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition 'valid' in 'reverse'' in 'rotate' at call 'reverse' (file rotate.c, line 10)
 --- *)
(* ---------------------------------------------------------- *)
theory VCrotate_call_reverse_pre_valid_2
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Instance of 'Pre-condition 'valid' in 'reverse'' in 'rotate' at call 'reverse' (file rotate.c, line 10)
":
*)
goal goal7:
  forall i_1 i : int.
  forall t : map int int.
  forall t_2 t_1 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  (0 < i_1) ->
  (i_1 <= i) ->
  (i_1 < i) ->
  (((region (a.base))) <= 0) ->
  (i <= (4294967295 + i_1)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_1 i)) ->
  ((valid_rw t a_1 i_1)) ->
  ((p_reverse_6_ ((havoc t_1 t_2 a_1 i_1)) t_2 a i_1)) ->
  ((valid_rw t ((shift_sint32 a i_1)) (i - i_1)))

end

(* ---------------------------------------------------------- *)
(* --- Pre-condition 'left' at call 'reverse' (file rotate.c, line 21) --- *)
(* ---------------------------------------------------------- *)
theory VCrotate_stmt_pre_left
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Pre-condition 'left' at call 'reverse' (file rotate.c, line 21)":
*)
goal goal8:
  forall i_1 i : int.
  forall t : map int int.
  forall t_3 t_2 t_1 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  let a_2 = (shift_sint32 a i_1) in
  let x = i - i_1 in
  let a_3 = (havoc t_1 t_3 a_1 i_1) in
  let a_4 = (havoc t_2 a_3 a_2 x) in
  (0 < i_1) ->
  (i_1 <= i) ->
  (i_1 < i) ->
  (((region (a.base))) <= 0) ->
  (i <= (4294967295 + i_1)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_1 i)) ->
  ((valid_rw t a_1 i_1)) ->
  ((valid_rw t a_2 x)) ->
  ((p_reverse_6_ a_3 t_3 a i_1)) ->
  ((p_reverse_6_ a_4 a_3 a_2 x)) ->
  ((p_reverse_4_ a_4 t_3 a 0 i_1 0))

end

(* ---------------------------------------------------------- *)
(* --- Pre-condition 'right' at call 'reverse' (file rotate.c, line 21) --- *)
(* ---------------------------------------------------------- *)
theory VCrotate_stmt_pre_right
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Pre-condition 'right' at call 'reverse' (file rotate.c, line 21)":
*)
goal goal9:
  forall i_1 i : int.
  forall t : map int int.
  forall t_3 t_2 t_1 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  let a_2 = (shift_sint32 a i_1) in
  let x = i - i_1 in
  let a_3 = (havoc t_1 t_3 a_1 i_1) in
  let a_4 = (havoc t_2 a_3 a_2 x) in
  (0 < i_1) ->
  (i_1 <= i) ->
  (i_1 < i) ->
  (((region (a.base))) <= 0) ->
  (i <= (4294967295 + i_1)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_1 i)) ->
  ((valid_rw t a_1 i_1)) ->
  ((valid_rw t a_2 x)) ->
  ((p_reverse_6_ a_3 t_3 a i_1)) ->
  ((p_reverse_6_ a_4 a_3 a_2 x)) ->
  ((p_reverse_4_ a_4 t_3 a i_1 i i_1))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'left' at call 'reverse' (file rotate.c, line 21) --- *)
(* ---------------------------------------------------------- *)
theory VCrotate_stmt_post_left
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition 'left' at call 'reverse' (file rotate.c, line 21)":
*)
goal goal10:
  forall i_1 i : int.
  forall t : map int int.
  forall t_4 t_3 t_2 t_1 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  let a_2 = (shift_sint32 a i_1) in
  let x = i - i_1 in
  let a_3 = (havoc t_1 t_4 a_1 i_1) in
  let a_4 = (havoc t_2 a_3 a_2 x) in
  let a_5 = (havoc t_3 a_4 a_1 i) in
  (0 < i_1) ->
  (i_1 <= i) ->
  (i_1 < i) ->
  (((region (a.base))) <= 0) ->
  (i <= (4294967295 + i_1)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_1 i)) ->
  ((valid_rw t a_1 i_1)) ->
  ((valid_rw t a_2 x)) ->
  ((p_reverse_6_ a_3 t_4 a i_1)) ->
  ((p_reverse_6_ a_4 a_3 a_2 x)) ->
  ((p_reverse_4_ a_4 t_4 a 0 i_1 0)) ->
  ((p_reverse_4_ a_4 t_4 a i_1 i i_1)) ->
  ((p_reverse_6_ a_5 a_4 a i)) ->
  ((p_reverse_4_ a_5 a_4 a 0 i_1 x))

end

(* ---------------------------------------------------------- *)
(* --- Post-condition 'right' at call 'reverse' (file rotate.c, line 21) --- *)
(* ---------------------------------------------------------- *)
theory VCrotate_stmt_post_right
  
use import bool.Bool
use import int.Int
use import int.ComputerDivision
use import real.RealInfix
use import Qed.Qed
use import int.Abs as IAbs
use import map.Map
use import Memory.Memory
use import Cint.Cint
use import Compound.Compound
use import Axiomatic.Axiomatic

(*
goal WP "expl:Post-condition 'right' at call 'reverse' (file rotate.c, line 21)":
*)
goal goal11:
  forall i_1 i : int.
  forall t : map int int.
  forall t_4 t_3 t_2 t_1 : map addr int.
  forall a : addr.
  let a_1 = (shift_sint32 a 0) in
  let a_2 = (shift_sint32 a i_1) in
  let x = i - i_1 in
  let a_3 = (havoc t_1 t_4 a_1 i_1) in
  let a_4 = (havoc t_2 a_3 a_2 x) in
  let a_5 = (havoc t_3 a_4 a_1 i) in
  (0 < i_1) ->
  (i_1 <= i) ->
  (i_1 < i) ->
  (((region (a.base))) <= 0) ->
  (i <= (4294967295 + i_1)) ->
  ((linked t)) ->
  ((is_uint32 i)) ->
  ((is_uint32 i_1)) ->
  ((valid_rw t a_1 i)) ->
  ((valid_rw t a_1 i_1)) ->
  ((valid_rw t a_2 x)) ->
  ((p_reverse_6_ a_3 t_4 a i_1)) ->
  ((p_reverse_6_ a_4 a_3 a_2 x)) ->
  ((p_reverse_4_ a_4 t_4 a 0 i_1 0)) ->
  ((p_reverse_4_ a_4 t_4 a i_1 i i_1)) ->
  ((p_reverse_6_ a_5 a_4 a i)) ->
  ((p_reverse_4_ a_5 a_4 a i_1 i 0))

end

