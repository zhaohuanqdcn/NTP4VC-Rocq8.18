import Why3.Base
import Why3.why3.Ref.Ref
import pearl.prover.lib.lean.Unification.Types
import pearl.prover.lib.lean.Functions.Config
import pearl.prover.lib.lean.Functions.Func
import pearl.prover.lib.lean.BacktrackArray.Types
import pearl.prover.lib.lean.Predicates.Pred
import pearl.prover.lib.lean.BacktrackArray.Logic
import pearl.prover.lib.lean.Choice.Choice
import pearl.prover.lib.lean.BacktrackArray.Impl
import pearl.prover.lib.lean.Firstorder_symbol_spec.Spec
import pearl.prover.lib.lean.Nat.Nat
import pearl.prover.lib.lean.OptionFuncs.Funcs
import pearl.prover.lib.lean.Sum.Sum
import pearl.prover.lib.lean.Firstorder_symbol_impl.Types
import pearl.prover.lib.lean.Firstorder_symbol_impl.Logic
import pearl.prover.lib.lean.Firstorder_symbol_impl.Impl
import pearl.prover.lib.lean.Firstorder_term_spec.Spec
import pearl.prover.lib.lean.Firstorder_term_impl.Types
import pearl.prover.lib.lean.Firstorder_term_impl.Logic
import pearl.prover.lib.lean.Firstorder_term_impl.Impl
import pearl.prover.lib.lean.Unification.Logic
open Classical
open Lean4Why3
namespace Unification_Impl_unification_term_listqtvc
theorem unification_term_list'vc (t1 : Types.nlimpl_fo_term_list) (t2 : Types.nlimpl_fo_term_list) (rhob : Types.t Types.sdata) (rho : Types.unifier_subst) (lv : List ℤ) (lp : ℤ -> Bool) (fact0 : Logic.nlimpl_fo_term_list_ok t1) (fact1 : Logic.nlimpl_fo_term_list_ok t2) (fact2 : Logic.unifier_subst_ok rhob rho) (fact3 : ∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term_list y (Types.nlimpl_fo_term_list.model_fo_term_list_field t1) → (0 : ℤ) ≤ y) (fact4 : ∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term_list y (Types.nlimpl_fo_term_list.model_fo_term_list_field t2) → (0 : ℤ) ≤ y) (fact5 : ∀(x : ℤ), x ∈ lv → lp x = true ∧ (0 : ℤ) ≤ x) (fact6 : ∀(x : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x → lp x = true) : Logic.nlimpl_fo_term_list_ok t2 ∧ (∀(o1 : Types.cons_fo_term_list), Logic.cons_ok_fo_term_list o1 ∧ Logic.cons_rel_fo_term_list o1 t2 ∧ Logic.cons_open_rel_fo_term_list o1 t2 → Logic.nlimpl_fo_term_list_ok t1 ∧ (∀(o2 : Types.cons_fo_term_list), Logic.cons_ok_fo_term_list o2 ∧ Logic.cons_rel_fo_term_list o2 t1 ∧ Logic.cons_open_rel_fo_term_list o2 t1 → (match o1 with | Types.cons_fo_term_list.NLC_FONil => (match o2 with | Types.cons_fo_term_list.NLC_FONil => Logic.unifier_subst_ok rhob rho ∧ Logic.precede rhob rhob ∧ (∀(x : ℤ), x ∈ lv → lp x = true ∧ (0 : ℤ) ≤ x) ∧ (∀(x : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x → lp x = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol Spec.subst_id_fo_term = Types.unifier_subst.unifier rho ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) | Types.cons_fo_term_list.NLC_FOCons x x1 => Logic.precede rhob rhob ∧ Logic.correct rhob) | Types.cons_fo_term_list.NLC_FOCons x x1 => (match o2 with | Types.cons_fo_term_list.NLC_FOCons x2 x3 => (Logic.nlimpl_fo_term_list_ok x3 ∧ Logic.nlimpl_fo_term_list_ok x1 ∧ Logic.unifier_subst_ok rhob rho ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term_list y (Types.nlimpl_fo_term_list.model_fo_term_list_field x3) → (0 : ℤ) ≤ y) ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term_list y (Types.nlimpl_fo_term_list.model_fo_term_list_field x1) → (0 : ℤ) ≤ y) ∧ (∀(x4 : ℤ), x4 ∈ lv → lp x4 = true ∧ (0 : ℤ) ≤ x4) ∧ (∀(x4 : ℤ), Logic.unassigned (Logic.current_timestamp rhob) x4 → lp x4 = true)) ∧ (∀(rhob1 : Types.t Types.sdata) (lv1 : List ℤ), Types.t.inv rhob1 = Types.t.inv rhob → (∀(rho2 : Types.unification_return), Logic.unifier_subst_ok rhob1 (Types.unification_return.final_unifier rho2) ∧ Logic.precede rhob rhob1 ∧ (∀(x4 : ℤ), x4 ∈ lv1 → lp x4 = true ∧ (0 : ℤ) ≤ x4) ∧ (∀(x4 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x4 → lp x4 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Types.unification_return.unifier_factor rho2) = Types.unifier_subst.unifier (Types.unification_return.final_unifier rho2) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field x3) Spec.subst_id_symbol s' = Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field x1) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier rho2)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier rho2); Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field x3) Spec.subst_id_symbol s0 = Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field x1) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier rho2); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier rho2); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) → (let rho2f : Types.unifier_subst := Types.unification_return.final_unifier rho2; (Logic.nlimpl_fo_term_ok x2 ∧ Logic.nlimpl_fo_term_ok x ∧ Logic.unifier_subst_ok rhob1 rho2f ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field x2) → (0 : ℤ) ≤ y) ∧ (∀(y : ℤ), Spec.is_fo_term_free_var_in_fo_term y (Types.nlimpl_fo_term.model_fo_term_field x) → (0 : ℤ) ≤ y) ∧ (∀(x4 : ℤ), x4 ∈ lv1 → lp x4 = true ∧ (0 : ℤ) ≤ x4) ∧ (∀(x4 : ℤ), Logic.unassigned (Logic.current_timestamp rhob1) x4 → lp x4 = true)) ∧ (∀(rhob2 : Types.t Types.sdata) (lv2 : List ℤ), Types.t.inv rhob2 = Types.t.inv rhob1 → (∀(rho3 : Types.unification_return), Logic.unifier_subst_ok rhob2 (Types.unification_return.final_unifier rho3) ∧ Logic.precede rhob1 rhob2 ∧ (∀(x4 : ℤ), x4 ∈ lv2 → lp x4 = true ∧ (0 : ℤ) ≤ x4) ∧ (∀(x4 : ℤ), Logic.unassigned (Logic.current_timestamp rhob2) x4 → lp x4 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho2f) Spec.subst_id_symbol (Types.unification_return.unifier_factor rho3) = Types.unifier_subst.unifier (Types.unification_return.final_unifier rho3) ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho2f) Spec.subst_id_symbol s; Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field x2) Spec.subst_id_symbol s' = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field x) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier (Types.unification_return.final_unifier rho3)) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier rho3); Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field x2) Spec.subst_id_symbol s0 = Spec.subst_fo_term (Types.nlimpl_fo_term.model_fo_term_field x) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier rho3); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho2f; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier (Types.unification_return.final_unifier rho3); let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho2f; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) → (let o3 : Types.unifier_subst := Types.unification_return.final_unifier rho3; Logic.unifier_subst_ok rhob2 o3 ∧ Logic.precede rhob rhob2 ∧ (∀(x4 : ℤ), x4 ∈ lv2 → lp x4 = true ∧ (0 : ℤ) ≤ x4) ∧ (∀(x4 : ℤ), Logic.unassigned (Logic.current_timestamp rhob2) x4 → lp x4 = true) ∧ Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol (Spec.subst_compose_fo_term (Types.unification_return.unifier_factor rho2) Spec.subst_id_symbol (Types.unification_return.unifier_factor rho3)) = Types.unifier_subst.unifier o3 ∧ (∀(s : ℤ -> Spec.fo_term ℤ ℤ), let s' : ℤ -> Spec.fo_term ℤ ℤ := Spec.subst_compose_fo_term (Types.unifier_subst.unifier rho) Spec.subst_id_symbol s; Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field t1) Spec.subst_id_symbol s' = Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field t2) Spec.subst_id_symbol s' → s' = Spec.subst_compose_fo_term (Types.unifier_subst.unifier o3) Spec.subst_id_symbol s) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier o3; Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field t1) Spec.subst_id_symbol s0 = Spec.subst_fo_term_list (Types.nlimpl_fo_term_list.model_fo_term_list_field t2) Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier o3; let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier_base_model rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0) ∧ (let s0 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier o3; let s1 : ℤ -> Spec.fo_term ℤ ℤ := Types.unifier_subst.unifier rho; Spec.subst_compose_fo_term s0 Spec.subst_id_symbol s1 = s0 ∧ s0 = Spec.subst_compose_fo_term s1 Spec.subst_id_symbol s0))) ∧ (Logic.precede rhob1 rhob2 ∧ Logic.correct rhob2 → Logic.precede rhob rhob2 ∧ Logic.correct rhob2))))) | Types.cons_fo_term_list.NLC_FONil => Logic.precede rhob rhob ∧ Logic.correct rhob))))
  := sorry
end Unification_Impl_unification_term_listqtvc
