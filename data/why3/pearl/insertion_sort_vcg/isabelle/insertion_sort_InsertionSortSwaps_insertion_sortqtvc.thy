theory insertion_sort_InsertionSortSwaps_insertion_sortqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut"
begin
theorem insertion_sort'vc:
  fixes a :: "int list"
  shows "let o1 :: int = int (length a) - (1 :: int) in ((1 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((\<forall>(p :: int) (q :: int). (0 :: int) \<le> p \<and> p \<le> q \<and> q < (1 :: int) \<longrightarrow> a ! nat p \<le> a ! nat q) \<and> a <~~> a) \<and> (\<forall>(a1 :: int list). length a1 = length a \<longrightarrow> (\<forall>(i :: int). ((1 :: int) \<le> i \<and> i \<le> o1) \<and> (\<forall>(p :: int) (q :: int). (0 :: int) \<le> p \<and> p \<le> q \<and> q < i \<longrightarrow> a1 ! nat p \<le> a1 ! nat q) \<and> a <~~> a1 \<longrightarrow> (((0 :: int) \<le> i \<and> i \<le> i) \<and> a <~~> a1 \<and> (\<forall>(p :: int) (q :: int). (0 :: int) \<le> p \<and> p \<le> q \<and> q \<le> i \<longrightarrow> \<not>q = i \<longrightarrow> a1 ! nat p \<le> a1 ! nat q)) \<and> (\<forall>(j :: int) (a2 :: int list). length a2 = length a1 \<longrightarrow> ((0 :: int) \<le> j \<and> j \<le> i) \<and> a <~~> a2 \<and> (\<forall>(p :: int) (q :: int). (0 :: int) \<le> p \<and> p \<le> q \<and> q \<le> i \<longrightarrow> \<not>q = j \<longrightarrow> a2 ! nat p \<le> a2 ! nat q) \<longrightarrow> ((0 :: int) < j \<longrightarrow> ((0 :: int) \<le> j \<and> j < int (length a2)) \<and> (let o2 :: int = j - (1 :: int) in (0 :: int) \<le> o2 \<and> o2 < int (length a2))) \<and> (\<forall>(o2 :: bool). (if (0 :: int) < j then o2 = (if a2 ! nat j < a2 ! nat (j - (1 :: int)) then True else False) else o2 = False) \<longrightarrow> (if o2 = True then let o3 :: int = j - (1 :: int) in (((0 :: int) \<le> o3 \<and> o3 < int (length a2)) \<and> (0 :: int) \<le> j \<and> j < int (length a2)) \<and> (\<forall>(a3 :: int list). length a3 = length a2 \<longrightarrow> list_exchange a2 a3 o3 j \<longrightarrow> ((0 :: int) \<le> j \<and> j - (1 :: int) < j) \<and> ((0 :: int) \<le> j - (1 :: int) \<and> j - (1 :: int) \<le> i) \<and> a <~~> a3 \<and> (\<forall>(p :: int) (q :: int). (0 :: int) \<le> p \<and> p \<le> q \<and> q \<le> i \<longrightarrow> \<not>q = j - (1 :: int) \<longrightarrow> a3 ! nat p \<le> a3 ! nat q)) else (\<forall>(p :: int) (q :: int). (0 :: int) \<le> p \<and> p \<le> q \<and> q < i + (1 :: int) \<longrightarrow> a2 ! nat p \<le> a2 ! nat q) \<and> a <~~> a2)))) \<and> ((\<forall>(p :: int) (q :: int). (0 :: int) \<le> p \<and> p \<le> q \<and> q < o1 + (1 :: int) \<longrightarrow> a1 ! nat p \<le> a1 ! nat q) \<and> a <~~> a1 \<longrightarrow> (\<forall>(p :: int) (q :: int). (0 :: int) \<le> p \<and> p \<le> q \<and> q < int (length a1) \<longrightarrow> a1 ! nat p \<le> a1 ! nat q) \<and> a <~~> a1))) \<and> (o1 + (1 :: int) < (1 :: int) \<longrightarrow> (\<forall>(p :: int) (q :: int). (0 :: int) \<le> p \<and> p \<le> q \<and> q < int (length a) \<longrightarrow> a ! nat p \<le> a ! nat q) \<and> a <~~> a)"
  sorry
end
