theory remove_duplicate_hash_RemoveDuplicate_remove_duplicateqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "./remove_duplicate_hash_Spec"
begin
typedecl  elt
typedecl  set
consts to_fset :: "set \<Rightarrow> elt fset"
consts choose1 :: "set \<Rightarrow> elt"
axiomatization where choose'spec:   "choose1 s |\<in>| to_fset s"
 if "\<not>to_fset s = fempty"
  for s :: "set"
theorem remove_duplicate'vc:
  fixes a :: "elt list"
  fixes s :: "set"
  assumes fact0: "(1 :: int) \<le> int (length a)"
  assumes fact1: "to_fset s = fempty"
  assumes fact2: "int (fcard (to_fset s)) = (0 :: int)"
  shows "let o1 :: int = int (length a) - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> (\<forall>(x :: elt). appears x a (0 :: int) \<longleftrightarrow> x |\<in>| to_fset s) \<and> (\<forall>(s1 :: set). (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o1) \<and> (\<forall>(x :: elt). appears x a i \<longleftrightarrow> x |\<in>| to_fset s1) \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (let o2 :: elt = a ! nat i in \<forall>(s2 :: set). to_fset s2 = finsert o2 (to_fset s1) \<and> (if o2 |\<in>| to_fset s1 then fcard (to_fset s2) = fcard (to_fset s1) else int (fcard (to_fset s2)) = int (fcard (to_fset s1)) + (1 :: int)) \<longrightarrow> (\<forall>(x :: elt). appears x a (i + (1 :: int)) \<longleftrightarrow> x |\<in>| to_fset s2))) \<and> ((\<forall>(x :: elt). appears x a (o1 + (1 :: int)) \<longleftrightarrow> x |\<in>| to_fset s1) \<longrightarrow> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length a)) \<and> (let o2 :: int = int (fcard (to_fset s1)) in (0 :: int) \<le> o2 \<and> (\<forall>(r :: elt list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < o2 \<longrightarrow> r ! nat i = a ! (0 :: nat)) \<and> int (length r) = o2 \<longrightarrow> (\<forall>(s2 :: set). to_fset s2 = fempty \<longrightarrow> (let o3 :: int = int (length a) - (1 :: int) in ((0 :: int) \<le> o3 + (1 :: int) \<longrightarrow> ((\<forall>(x :: elt). appears x a (0 :: int) \<longleftrightarrow> x |\<in>| to_fset s2) \<and> (\<forall>(x :: elt). x |\<in>| to_fset s2 \<longleftrightarrow> appears x r (0 :: int)) \<and> nodup r (0 :: int) \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) = int (fcard (to_fset s2)) \<and> fcard (to_fset s2) \<le> length r) \<and> to_fset s2 |\<subseteq>| to_fset s1) \<and> (\<forall>(j :: int) (r1 :: elt list) (s3 :: set). length r1 = length r \<longrightarrow> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o3) \<and> (\<forall>(x :: elt). appears x a i \<longleftrightarrow> x |\<in>| to_fset s3) \<and> (\<forall>(x :: elt). x |\<in>| to_fset s3 \<longleftrightarrow> appears x r1 j) \<and> nodup r1 j \<and> ((0 :: int) \<le> j \<and> j = int (fcard (to_fset s3)) \<and> fcard (to_fset s3) \<le> length r1) \<and> to_fset s3 |\<subseteq>| to_fset s1 \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if \<not>a ! nat i |\<in>| to_fset s3 then ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (let o4 :: elt = a ! nat i in \<forall>(s4 :: set). to_fset s4 = finsert o4 (to_fset s3) \<and> (if o4 |\<in>| to_fset s3 then fcard (to_fset s4) = fcard (to_fset s3) else int (fcard (to_fset s4)) = int (fcard (to_fset s3)) + (1 :: int)) \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (let o5 :: elt = a ! nat i in ((0 :: int) \<le> j \<and> j < int (length r1)) \<and> (length (r1[nat j := o5]) = length r1 \<longrightarrow> nth (r1[nat j := o5]) o nat = (nth r1 o nat)(j := o5) \<longrightarrow> (\<forall>(x :: elt). appears x a (i + (1 :: int)) \<longleftrightarrow> x |\<in>| to_fset s4) \<and> (\<forall>(x :: elt). x |\<in>| to_fset s4 \<longleftrightarrow> appears x (r1[nat j := o5]) (j + (1 :: int))) \<and> nodup (r1[nat j := o5]) (j + (1 :: int)) \<and> ((0 :: int) \<le> j + (1 :: int) \<and> j + (1 :: int) = int (fcard (to_fset s4)) \<and> fcard (to_fset s4) \<le> length (r1[nat j := o5])) \<and> to_fset s4 |\<subseteq>| to_fset s1))) else (\<forall>(x :: elt). appears x a (i + (1 :: int)) \<longleftrightarrow> x |\<in>| to_fset s3) \<and> (\<forall>(x :: elt). x |\<in>| to_fset s3 \<longleftrightarrow> appears x r1 j) \<and> nodup r1 j \<and> ((0 :: int) \<le> j \<and> j = int (fcard (to_fset s3)) \<and> fcard (to_fset s3) \<le> length r1) \<and> to_fset s3 |\<subseteq>| to_fset s1)) \<and> ((\<forall>(x :: elt). appears x a (o3 + (1 :: int)) \<longleftrightarrow> x |\<in>| to_fset s3) \<and> (\<forall>(x :: elt). x |\<in>| to_fset s3 \<longleftrightarrow> appears x r1 j) \<and> nodup r1 j \<and> ((0 :: int) \<le> j \<and> j = int (fcard (to_fset s3)) \<and> fcard (to_fset s3) \<le> length r1) \<and> to_fset s3 |\<subseteq>| to_fset s1 \<longrightarrow> nodup r1 (int (length r1)) \<and> (\<forall>(x :: elt). appears x a (int (length a)) \<longleftrightarrow> appears x r1 (int (length r1)))))) \<and> (o3 + (1 :: int) < (0 :: int) \<longrightarrow> nodup r (int (length r)) \<and> (\<forall>(x :: elt). appears x a (int (length a)) \<longleftrightarrow> appears x r (int (length r))))))))))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length a)) \<and> (let o2 :: int = int (fcard (to_fset s)) in (0 :: int) \<le> o2 \<and> (\<forall>(r :: elt list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < o2 \<longrightarrow> r ! nat i = a ! (0 :: nat)) \<and> int (length r) = o2 \<longrightarrow> (\<forall>(s1 :: set). to_fset s1 = fempty \<longrightarrow> (let o3 :: int = int (length a) - (1 :: int) in ((0 :: int) \<le> o3 + (1 :: int) \<longrightarrow> ((\<forall>(x :: elt). appears x a (0 :: int) \<longleftrightarrow> x |\<in>| to_fset s1) \<and> (\<forall>(x :: elt). x |\<in>| to_fset s1 \<longleftrightarrow> appears x r (0 :: int)) \<and> nodup r (0 :: int) \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) = int (fcard (to_fset s1)) \<and> fcard (to_fset s1) \<le> length r) \<and> to_fset s1 |\<subseteq>| to_fset s) \<and> (\<forall>(j :: int) (r1 :: elt list) (s2 :: set). length r1 = length r \<longrightarrow> (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o3) \<and> (\<forall>(x :: elt). appears x a i \<longleftrightarrow> x |\<in>| to_fset s2) \<and> (\<forall>(x :: elt). x |\<in>| to_fset s2 \<longleftrightarrow> appears x r1 j) \<and> nodup r1 j \<and> ((0 :: int) \<le> j \<and> j = int (fcard (to_fset s2)) \<and> fcard (to_fset s2) \<le> length r1) \<and> to_fset s2 |\<subseteq>| to_fset s \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if \<not>a ! nat i |\<in>| to_fset s2 then ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (let o4 :: elt = a ! nat i in \<forall>(s3 :: set). to_fset s3 = finsert o4 (to_fset s2) \<and> (if o4 |\<in>| to_fset s2 then fcard (to_fset s3) = fcard (to_fset s2) else int (fcard (to_fset s3)) = int (fcard (to_fset s2)) + (1 :: int)) \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (let o5 :: elt = a ! nat i in ((0 :: int) \<le> j \<and> j < int (length r1)) \<and> (length (r1[nat j := o5]) = length r1 \<longrightarrow> nth (r1[nat j := o5]) o nat = (nth r1 o nat)(j := o5) \<longrightarrow> (\<forall>(x :: elt). appears x a (i + (1 :: int)) \<longleftrightarrow> x |\<in>| to_fset s3) \<and> (\<forall>(x :: elt). x |\<in>| to_fset s3 \<longleftrightarrow> appears x (r1[nat j := o5]) (j + (1 :: int))) \<and> nodup (r1[nat j := o5]) (j + (1 :: int)) \<and> ((0 :: int) \<le> j + (1 :: int) \<and> j + (1 :: int) = int (fcard (to_fset s3)) \<and> fcard (to_fset s3) \<le> length (r1[nat j := o5])) \<and> to_fset s3 |\<subseteq>| to_fset s))) else (\<forall>(x :: elt). appears x a (i + (1 :: int)) \<longleftrightarrow> x |\<in>| to_fset s2) \<and> (\<forall>(x :: elt). x |\<in>| to_fset s2 \<longleftrightarrow> appears x r1 j) \<and> nodup r1 j \<and> ((0 :: int) \<le> j \<and> j = int (fcard (to_fset s2)) \<and> fcard (to_fset s2) \<le> length r1) \<and> to_fset s2 |\<subseteq>| to_fset s)) \<and> ((\<forall>(x :: elt). appears x a (o3 + (1 :: int)) \<longleftrightarrow> x |\<in>| to_fset s2) \<and> (\<forall>(x :: elt). x |\<in>| to_fset s2 \<longleftrightarrow> appears x r1 j) \<and> nodup r1 j \<and> ((0 :: int) \<le> j \<and> j = int (fcard (to_fset s2)) \<and> fcard (to_fset s2) \<le> length r1) \<and> to_fset s2 |\<subseteq>| to_fset s \<longrightarrow> nodup r1 (int (length r1)) \<and> (\<forall>(x :: elt). appears x a (int (length a)) \<longleftrightarrow> appears x r1 (int (length r1)))))) \<and> (o3 + (1 :: int) < (0 :: int) \<longrightarrow> nodup r (int (length r)) \<and> (\<forall>(x :: elt). appears x a (int (length a)) \<longleftrightarrow> appears x r (int (length r)))))))))"
  sorry
end
