theory mccarthy_McCarthy91Mach_f91_pseudorecqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.int_Iter"
begin
definition spec :: "int \<Rightarrow> int"
  where "spec x = (if x \<le> (100 :: int) then 91 :: int else x - (10 :: int))" for x
theorem f91_pseudorec'vc:
  fixes n0 :: "63 word"
  shows "\<forall>(n :: 63 word) (e :: nat). (0 :: int) \<le> int e \<longrightarrow> (if \<not>(0 :: nat) < e then int e = (0 :: int) else if (100 :: int) < sint n then int'63_in_bounds (sint n - (10 :: int)) \<and> (\<forall>(o1 :: 63 word). sint o1 = sint n - (10 :: int) \<longrightarrow> (\<forall>(o2 :: nat). int o2 = int e - (1 :: int) \<longrightarrow> (0 :: int) < int e \<and> (if (100 :: int) < sint n then sint o1 = sint n - (10 :: int) \<and> int o2 = int e - (1 :: int) else sint o1 = sint n + (11 :: int) \<and> int o2 = int e + (1 :: int)))) else int'63_in_bounds (sint n + (11 :: int)) \<and> (\<forall>(o1 :: 63 word). sint o1 = sint n + (11 :: int) \<longrightarrow> (\<forall>(o2 :: nat). int o2 = int e + (1 :: int) \<longrightarrow> (0 :: int) < int e \<and> (if (100 :: int) < sint n then sint o1 = sint n - (10 :: int) \<and> int o2 = int e - (1 :: int) else sint o1 = sint n + (11 :: int) \<and> int o2 = int e + (1 :: int)))))"
  and "\<forall>(n :: 63 word) (e :: nat). (0 :: int) < int e \<longrightarrow> (0 :: int) \<le> int e \<and> (\<forall>(n1 :: 63 word) (e1 :: nat). ((0 :: int) < int e \<and> (if (100 :: int) < sint n then sint n1 = sint n - (10 :: int) \<and> int e1 = int e - (1 :: int) else sint n1 = sint n + (11 :: int) \<and> int e1 = int e + (1 :: int)) \<longrightarrow> (if sint n \<le> (100 :: int) then (((0 :: int) \<le> (101 :: int) - sint n \<and> (101 :: int) - sint n1 < (101 :: int) - sint n) \<and> (0 :: int) < int e1) \<and> (\<forall>(n2 :: 63 word) (e2 :: nat). int e2 = int e1 - (1 :: int) \<and> sint n2 = spec (sint n1) \<longrightarrow> (((0 :: int) \<le> (101 :: int) - sint n \<and> (101 :: int) - sint n2 < (101 :: int) - sint n) \<and> (0 :: int) < int e2) \<and> (\<forall>(n3 :: 63 word) (e3 :: nat). int e3 = int e2 - (1 :: int) \<and> sint n3 = spec (sint n2) \<longrightarrow> int e3 = int e - (1 :: int) \<and> sint n3 = spec (sint n))) else int e1 = int e - (1 :: int) \<and> sint n1 = spec (sint n))) \<and> \<not>((e1 = e \<and> int e = (0 :: int)) \<and> n1 = n))"
  and "(0 :: int) < int (1 :: nat)"
  and "\<forall>(n :: 63 word) (e :: nat). int e = int (1 :: nat) - (1 :: int) \<and> sint n = spec (sint n0) \<longrightarrow> (0 :: int) \<le> int e \<and> (\<forall>(n1 :: 63 word) (e1 :: nat). \<not>((0 :: int) < int e \<and> (if (100 :: int) < sint n then sint n1 = sint n - (10 :: int) \<and> int e1 = int e - (1 :: int) else sint n1 = sint n + (11 :: int) \<and> int e1 = int e + (1 :: int))) \<and> ((e1 = e \<and> int e = (0 :: int)) \<and> n1 = n \<longrightarrow> sint n1 = spec (sint n0)))"
  sorry
end
