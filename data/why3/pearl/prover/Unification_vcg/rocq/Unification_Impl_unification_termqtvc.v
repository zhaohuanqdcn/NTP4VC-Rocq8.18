From Stdlib Require Import Strings.String.
From Stdlib Require Import String Ascii.
From Stdlib Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Stdlib Require Classical.
From Stdlib Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Stdlib Require Import Sorting.Sorted.
From Stdlib Require Import Reals.Rbasic_fun.
From Stdlib Require Import Reals.Abstract.ConstructiveAbs.
From Stdlib Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Stdlib Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Stdlib Require Import ZArith.Zeuclid.
From Stdlib Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Stdlib Require Import Reals.
Require Import Why3.Base.
Require Import Why3.why3.Ref.Ref.
Require Import prover.Unification.Types.
Require Import prover.Functions.Config.
Require Import prover.Functions.Func.
Require Import prover.BacktrackArray.Types.
Require Import prover.Predicates.Pred.
Require Import prover.BacktrackArray.Logic.
Require Import prover.Choice.Choice.
Require Import prover.BacktrackArray.Impl.
Require Import prover.Firstorder_symbol_spec.Spec.
Require Import prover.Nat.Nat.
Require Import prover.OptionFuncs.Funcs.
Require Import prover.Sum.Sum.
Require Import prover.Firstorder_symbol_impl.Types.
Require Import prover.Firstorder_symbol_impl.Logic.
Require Import prover.Firstorder_symbol_impl.Impl.
Require Import prover.Firstorder_term_spec.Spec.
Require Import prover.Firstorder_term_impl.Types.
Require Import prover.Firstorder_term_impl.Logic.
Require Import prover.Firstorder_term_impl.Impl.
Require Import prover.Unification.Logic.
Open Scope Z_scope.
Theorem unification_term'vc (t1 : nlimpl_fo_term) (t2 : nlimpl_fo_term) (rhob : t sdata) (rho : unifier_subst) (lv : list Z) (lp : Z -> bool) (fact0 : nlimpl_fo_term_ok t1) (fact1 : nlimpl_fo_term_ok t2) (fact2 : unifier_subst_ok rhob rho) (fact3 : ∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field t1) -> 0%Z ≤ y) (fact4 : ∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field t2) -> 0%Z ≤ y) (fact5 : ∀(x : Z), x ∈ lv -> lp x = true ∧ 0%Z ≤ x) (fact6 : ∀(x : Z), unassigned (current_timestamp rhob) x -> lp x = true) : nlimpl_fo_term_ok t2 ∧ (∀(o1 : cons_fo_term), cons_ok_fo_term o1 ∧ cons_rel_fo_term o1 t2 ∧ cons_open_rel_fo_term o1 t2 -> nlimpl_fo_term_ok t1 ∧ (∀(o2 : cons_fo_term), cons_ok_fo_term o2 ∧ cons_rel_fo_term o2 t1 ∧ cons_open_rel_fo_term o2 t1 -> (match o1 with | NLCVar_fo_term x => (match o2 with | NLCVar_fo_term x1 => (if decide (x1 = x) then unifier_subst_ok rhob rho ∧ precede rhob rhob ∧ (∀(x2 : Z), x2 ∈ lv -> lp x2 = true ∧ 0%Z ≤ x2) ∧ (∀(x2 : Z), unassigned (current_timestamp rhob) x2 -> lp x2 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (subst_id_fo_term : Z -> fo_term Z Z) = unifier rho ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier rho) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier rho in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier rho in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier rho in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) else (correct rhob ∧ 0%Z ≤ x1) ∧ (let bx : list sdata := table (current_timestamp rhob) x1 in list_forall (inv rhob) bx -> (match bx with | cons (Assign bx1) _ => (nlimpl_fo_term_ok bx1 ∧ nlimpl_fo_term_ok t2 ∧ unifier_subst_ok rhob rho ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field bx1) -> 0%Z ≤ y) ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field t2) -> 0%Z ≤ y) ∧ (∀(x2 : Z), x2 ∈ lv -> lp x2 = true ∧ 0%Z ≤ x2) ∧ (∀(x2 : Z), unassigned (current_timestamp rhob) x2 -> lp x2 = true)) ∧ (∀(rhob1 : t sdata) (lv1 : list Z), inv rhob1 = inv rhob -> (∀(res : unification_return), unifier_subst_ok rhob1 (final_unifier res) ∧ precede rhob rhob1 ∧ (∀(x2 : Z), x2 ∈ lv1 -> lp x2 = true ∧ 0%Z ≤ x2) ∧ (∀(x2 : Z), unassigned (current_timestamp rhob1) x2 -> lp x2 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field bx1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in subst_fo_term (model_fo_term_field bx1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) -> unifier_subst_ok rhob1 (final_unifier res) ∧ precede rhob rhob1 ∧ (∀(x2 : Z), x2 ∈ lv1 -> lp x2 = true ∧ 0%Z ≤ x2) ∧ (∀(x2 : Z), unassigned (current_timestamp rhob1) x2 -> lp x2 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0))) | _ => (correct rhob ∧ 0%Z ≤ x) ∧ (let by' : list sdata := table (current_timestamp rhob) x in list_forall (inv rhob) by' -> (match by' with | cons (Assign by'1) _ => (nlimpl_fo_term_ok t1 ∧ nlimpl_fo_term_ok by'1 ∧ unifier_subst_ok rhob rho ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field t1) -> 0%Z ≤ y) ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field by'1) -> 0%Z ≤ y) ∧ (∀(x2 : Z), x2 ∈ lv -> lp x2 = true ∧ 0%Z ≤ x2) ∧ (∀(x2 : Z), unassigned (current_timestamp rhob) x2 -> lp x2 = true)) ∧ (∀(rhob1 : t sdata) (lv1 : list Z), inv rhob1 = inv rhob -> (∀(res : unification_return), unifier_subst_ok rhob1 (final_unifier res) ∧ precede rhob rhob1 ∧ (∀(x2 : Z), x2 ∈ lv1 -> lp x2 = true ∧ 0%Z ≤ x2) ∧ (∀(x2 : Z), unassigned (current_timestamp rhob1) x2 -> lp x2 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field by'1) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field by'1) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) -> unifier_subst_ok rhob1 (final_unifier res) ∧ precede rhob rhob1 ∧ (∀(x2 : Z), x2 ∈ lv1 -> lp x2 = true ∧ 0%Z ≤ x2) ∧ (∀(x2 : Z), unassigned (current_timestamp rhob1) x2 -> lp x2 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0))) | _ => (unifier_subst_ok rhob rho ∧ unassigned (current_timestamp rhob) x) ∧ ((let tm : fo_term Z Z := Var_fo_term x in tm = subst_fo_term tm subst_id_symbol (unifier_base_model rho) ∧ tm = subst_fo_term tm subst_id_symbol (unifier rho)) -> (unifier_subst_ok rhob rho ∧ unassigned (current_timestamp rhob) x1) ∧ ((let tm : fo_term Z Z := Var_fo_term x1 in tm = subst_fo_term tm subst_id_symbol (unifier_base_model rho) ∧ tm = subst_fo_term tm subst_id_symbol (unifier rho)) -> (if decide (x1 < x) then (0%Z ≤ x1 ∧ nlimpl_fo_term_ok t2 ∧ unifier_subst_ok rhob rho ∧ unassigned (current_timestamp rhob) x1 ∧ ¬ subst_fo_term (model_fo_term_field t2) subst_id_symbol (unifier rho) = Var_fo_term x1 ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field t2) -> 0%Z ≤ y) ∧ (∀(x2 : Z), x2 ∈ lv -> lp x2 = true ∧ 0%Z ≤ x2) ∧ (∀(x2 : Z), unassigned (current_timestamp rhob) x2 -> lp x2 = true)) ∧ (∀(rhob1 : t sdata) (lv1 : list Z), inv rhob1 = inv rhob -> (∀(result : unification_return), (∀(x2 : Z), x2 ∈ lv1 -> lp x2 = true ∧ 0%Z ≤ x2) ∧ (∀(x2 : Z), unassigned (current_timestamp rhob1) x2 -> lp x2 = true) ∧ unifier_subst_ok rhob1 (final_unifier result) ∧ precede rhob rhob1 ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in s' x1 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in s0 x1 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) -> unifier_subst_ok rhob1 (final_unifier result) ∧ precede rhob rhob1 ∧ (∀(x2 : Z), x2 ∈ lv1 -> lp x2 = true ∧ 0%Z ≤ x2) ∧ (∀(x2 : Z), unassigned (current_timestamp rhob1) x2 -> lp x2 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0))) else (0%Z ≤ x ∧ nlimpl_fo_term_ok t1 ∧ unifier_subst_ok rhob rho ∧ unassigned (current_timestamp rhob) x ∧ ¬ subst_fo_term (model_fo_term_field t1) subst_id_symbol (unifier rho) = Var_fo_term x ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field t1) -> 0%Z ≤ y) ∧ (∀(x2 : Z), x2 ∈ lv -> lp x2 = true ∧ 0%Z ≤ x2) ∧ (∀(x2 : Z), unassigned (current_timestamp rhob) x2 -> lp x2 = true)) ∧ (∀(rhob1 : t sdata) (lv1 : list Z), inv rhob1 = inv rhob -> (∀(result : unification_return), (∀(x2 : Z), x2 ∈ lv1 -> lp x2 = true ∧ 0%Z ≤ x2) ∧ (∀(x2 : Z), unassigned (current_timestamp rhob1) x2 -> lp x2 = true) ∧ unifier_subst_ok rhob1 (final_unifier result) ∧ precede rhob rhob1 ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in s' x = subst_fo_term (model_fo_term_field t1) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in s0 x = subst_fo_term (model_fo_term_field t1) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) -> unifier_subst_ok rhob1 (final_unifier result) ∧ precede rhob rhob1 ∧ (∀(x2 : Z), x2 ∈ lv1 -> lp x2 = true ∧ 0%Z ≤ x2) ∧ (∀(x2 : Z), unassigned (current_timestamp rhob1) x2 -> lp x2 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0)))))) end)) end))) | NLC_App x1 x2 => (correct rhob ∧ 0%Z ≤ x) ∧ (let bx : list sdata := table (current_timestamp rhob) x in list_forall (inv rhob) bx -> (match bx with | cons (Assign bx1) _ => (nlimpl_fo_term_ok t1 ∧ nlimpl_fo_term_ok bx1 ∧ unifier_subst_ok rhob rho ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field t1) -> 0%Z ≤ y) ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field bx1) -> 0%Z ≤ y) ∧ (∀(x3 : Z), x3 ∈ lv -> lp x3 = true ∧ 0%Z ≤ x3) ∧ (∀(x3 : Z), unassigned (current_timestamp rhob) x3 -> lp x3 = true)) ∧ (∀(rhob1 : t sdata) (lv1 : list Z), inv rhob1 = inv rhob -> (∀(res : unification_return), unifier_subst_ok rhob1 (final_unifier res) ∧ precede rhob rhob1 ∧ (∀(x3 : Z), x3 ∈ lv1 -> lp x3 = true ∧ 0%Z ≤ x3) ∧ (∀(x3 : Z), unassigned (current_timestamp rhob1) x3 -> lp x3 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field bx1) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field bx1) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) -> unifier_subst_ok rhob1 (final_unifier res) ∧ precede rhob rhob1 ∧ (∀(x3 : Z), x3 ∈ lv1 -> lp x3 = true ∧ 0%Z ≤ x3) ∧ (∀(x3 : Z), unassigned (current_timestamp rhob1) x3 -> lp x3 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0))) | _ => (0%Z ≤ x ∧ nlimpl_fo_term_ok t1 ∧ unifier_subst_ok rhob rho ∧ unassigned (current_timestamp rhob) x ∧ ¬ subst_fo_term (model_fo_term_field t1) subst_id_symbol (unifier rho) = Var_fo_term x ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field t1) -> 0%Z ≤ y) ∧ (∀(x3 : Z), x3 ∈ lv -> lp x3 = true ∧ 0%Z ≤ x3) ∧ (∀(x3 : Z), unassigned (current_timestamp rhob) x3 -> lp x3 = true)) ∧ (∀(rhob1 : t sdata) (lv1 : list Z), inv rhob1 = inv rhob -> (∀(result : unification_return), (∀(x3 : Z), x3 ∈ lv1 -> lp x3 = true ∧ 0%Z ≤ x3) ∧ (∀(x3 : Z), unassigned (current_timestamp rhob1) x3 -> lp x3 = true) ∧ unifier_subst_ok rhob1 (final_unifier result) ∧ precede rhob rhob1 ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in s' x = subst_fo_term (model_fo_term_field t1) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in s0 x = subst_fo_term (model_fo_term_field t1) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) -> unifier_subst_ok rhob1 (final_unifier result) ∧ precede rhob rhob1 ∧ (∀(x3 : Z), x3 ∈ lv1 -> lp x3 = true ∧ 0%Z ≤ x3) ∧ (∀(x3 : Z), unassigned (current_timestamp rhob1) x3 -> lp x3 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0))) end)) end) | NLC_App x x1 => (match o2 with | NLC_App x2 x3 => nlimpl_symbol_ok x ∧ (∀(o3 : Z), let o4 : cons_symbol := NLCVar_symbol o3 in cons_ok_symbol o4 ∧ cons_rel_symbol o4 x ∧ cons_open_rel_symbol o4 x -> nlimpl_symbol_ok x2 ∧ (∀(o5 : Z), let o6 : cons_symbol := NLCVar_symbol o5 in cons_ok_symbol o6 ∧ cons_rel_symbol o6 x2 ∧ cons_open_rel_symbol o6 x2 -> (if decide (o5 = o3) then (nlimpl_fo_term_list_ok x3 ∧ nlimpl_fo_term_list_ok x1 ∧ unifier_subst_ok rhob rho ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term_list y (model_fo_term_list_field x3) -> 0%Z ≤ y) ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term_list y (model_fo_term_list_field x1) -> 0%Z ≤ y) ∧ (∀(x4 : Z), x4 ∈ lv -> lp x4 = true ∧ 0%Z ≤ x4) ∧ (∀(x4 : Z), unassigned (current_timestamp rhob) x4 -> lp x4 = true)) ∧ (∀(rhob1 : t sdata) (lv1 : list Z), inv rhob1 = inv rhob -> (∀(result : unification_return), unifier_subst_ok rhob1 (final_unifier result) ∧ precede rhob rhob1 ∧ (∀(x4 : Z), x4 ∈ lv1 -> lp x4 = true ∧ 0%Z ≤ x4) ∧ (∀(x4 : Z), unassigned (current_timestamp rhob1) x4 -> lp x4 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term_list (model_fo_term_list_field x3) subst_id_symbol s' = subst_fo_term_list (model_fo_term_list_field x1) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in subst_fo_term_list (model_fo_term_list_field x3) subst_id_symbol s0 = subst_fo_term_list (model_fo_term_list_field x1) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) -> unifier_subst_ok rhob1 (final_unifier result) ∧ precede rhob rhob1 ∧ (∀(x4 : Z), x4 ∈ lv1 -> lp x4 = true ∧ 0%Z ≤ x4) ∧ (∀(x4 : Z), unassigned (current_timestamp rhob1) x4 -> lp x4 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0))) else precede rhob rhob ∧ correct rhob))) | NLCVar_fo_term x2 => (correct rhob ∧ 0%Z ≤ x2) ∧ (let bx : list sdata := table (current_timestamp rhob) x2 in list_forall (inv rhob) bx -> (match bx with | cons (Assign bx1) _ => (nlimpl_fo_term_ok bx1 ∧ nlimpl_fo_term_ok t2 ∧ unifier_subst_ok rhob rho ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field bx1) -> 0%Z ≤ y) ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field t2) -> 0%Z ≤ y) ∧ (∀(x3 : Z), x3 ∈ lv -> lp x3 = true ∧ 0%Z ≤ x3) ∧ (∀(x3 : Z), unassigned (current_timestamp rhob) x3 -> lp x3 = true)) ∧ (∀(rhob1 : t sdata) (lv1 : list Z), inv rhob1 = inv rhob -> (∀(res : unification_return), unifier_subst_ok rhob1 (final_unifier res) ∧ precede rhob rhob1 ∧ (∀(x3 : Z), x3 ∈ lv1 -> lp x3 = true ∧ 0%Z ≤ x3) ∧ (∀(x3 : Z), unassigned (current_timestamp rhob1) x3 -> lp x3 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field bx1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in subst_fo_term (model_fo_term_field bx1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) -> unifier_subst_ok rhob1 (final_unifier res) ∧ precede rhob rhob1 ∧ (∀(x3 : Z), x3 ∈ lv1 -> lp x3 = true ∧ 0%Z ≤ x3) ∧ (∀(x3 : Z), unassigned (current_timestamp rhob1) x3 -> lp x3 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor res) = unifier (final_unifier res) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier res)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier res) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0))) | _ => (0%Z ≤ x2 ∧ nlimpl_fo_term_ok t2 ∧ unifier_subst_ok rhob rho ∧ unassigned (current_timestamp rhob) x2 ∧ ¬ subst_fo_term (model_fo_term_field t2) subst_id_symbol (unifier rho) = Var_fo_term x2 ∧ (∀(y : Z), is_fo_term_free_var_in_fo_term y (model_fo_term_field t2) -> 0%Z ≤ y) ∧ (∀(x3 : Z), x3 ∈ lv -> lp x3 = true ∧ 0%Z ≤ x3) ∧ (∀(x3 : Z), unassigned (current_timestamp rhob) x3 -> lp x3 = true)) ∧ (∀(rhob1 : t sdata) (lv1 : list Z), inv rhob1 = inv rhob -> (∀(result : unification_return), (∀(x3 : Z), x3 ∈ lv1 -> lp x3 = true ∧ 0%Z ≤ x3) ∧ (∀(x3 : Z), unassigned (current_timestamp rhob1) x3 -> lp x3 = true) ∧ unifier_subst_ok rhob1 (final_unifier result) ∧ precede rhob rhob1 ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in s' x2 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in s0 x2 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) -> unifier_subst_ok rhob1 (final_unifier result) ∧ precede rhob rhob1 ∧ (∀(x3 : Z), x3 ∈ lv1 -> lp x3 = true ∧ 0%Z ≤ x3) ∧ (∀(x3 : Z), unassigned (current_timestamp rhob1) x3 -> lp x3 = true) ∧ subst_compose_fo_term (unifier rho) subst_id_symbol (unifier_factor result) = unifier (final_unifier result) ∧ (∀(s : Z -> fo_term Z Z), let s' : Z -> fo_term Z Z := subst_compose_fo_term (unifier rho) subst_id_symbol s in subst_fo_term (model_fo_term_field t1) subst_id_symbol s' = subst_fo_term (model_fo_term_field t2) subst_id_symbol s' -> s' = subst_compose_fo_term (unifier (final_unifier result)) subst_id_symbol s) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in subst_fo_term (model_fo_term_field t1) subst_id_symbol s0 = subst_fo_term (model_fo_term_field t2) subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier_base_model rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0) ∧ (let s0 : Z -> fo_term Z Z := unifier (final_unifier result) in let s1 : Z -> fo_term Z Z := unifier rho in subst_compose_fo_term s0 subst_id_symbol s1 = s0 ∧ s0 = subst_compose_fo_term s1 subst_id_symbol s0))) end)) end) end))).
Admitted.
