import Why3.Base
import pearl.sudoku_vcg.lean.sudoku.Grid
open Classical
open Lean4Why3
namespace sudoku_Solver_solve_auxqtvc
noncomputable def valid_chunk_up_to (g : ℤ -> ℤ) (i : ℤ) (start : List ℤ) (offsets : List ℤ) (off : ℤ) := let s : ℤ := start[Int.toNat i]!; ∀(o1 : ℤ) (o2 : ℤ), ((0 : ℤ) ≤ o1 ∧ o1 < off) ∧ ((0 : ℤ) ≤ o2 ∧ o2 < off) ∧ ¬o1 = o2 → (let i1 : ℤ := s + offsets[Int.toNat o1]!; let i2 : ℤ := s + offsets[Int.toNat o2]!; ((1 : ℤ) ≤ g i1 ∧ g i1 ≤ (9 : ℤ)) ∧ (1 : ℤ) ≤ g i2 ∧ g i2 ≤ (9 : ℤ) → ¬g i1 = g i2)
noncomputable def valid_up_to (s : Grid.sudoku_chunks) (g : ℤ -> ℤ) (i : ℤ) := ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → Grid.valid_column s g j ∧ Grid.valid_row s g j ∧ Grid.valid_square s g j
noncomputable def full_up_to (g : ℤ -> ℤ) (i : ℤ) := ∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → (1 : ℤ) ≤ g j ∧ g j ≤ (9 : ℤ)
theorem solve_aux'vc (s : Grid.sudoku_chunks) (g : List ℤ) (i : ℤ) (fact0 : Grid.well_formed_sudoku s) (fact1 : Int.ofNat (List.length g) = (81 : ℤ)) (fact2 : Grid.valid_values (getElem! g ∘ Int.toNat)) (fact3 : (0 : ℤ) ≤ i) (fact4 : i ≤ (81 : ℤ)) (fact5 : valid_up_to s (getElem! g ∘ Int.toNat) i) (fact6 : full_up_to (getElem! g ∘ Int.toNat) i) : if i = (81 : ℤ) then Grid.is_solution_for s (getElem! g ∘ Int.toNat) (getElem! g ∘ Int.toNat) else ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length g)) ∧ (if ¬g[Int.toNat i]! = (0 : ℤ) then let o1 : List ℤ := Grid.sudoku_chunks.column_offsets s; let o2 : List ℤ := Grid.sudoku_chunks.column_start s; (Int.ofNat (List.length g) = (81 : ℤ) ∧ Grid.valid_values (getElem! g ∘ Int.toNat) ∧ Grid.is_index i ∧ Grid.chunk_valid_indexes o2 o1) ∧ (Grid.valid_chunk (getElem! g ∘ Int.toNat) i o2 o1 → (let o3 : List ℤ := Grid.sudoku_chunks.row_offsets s; let o4 : List ℤ := Grid.sudoku_chunks.row_start s; (Int.ofNat (List.length g) = (81 : ℤ) ∧ Grid.valid_values (getElem! g ∘ Int.toNat) ∧ Grid.is_index i ∧ Grid.chunk_valid_indexes o4 o3) ∧ (Grid.valid_chunk (getElem! g ∘ Int.toNat) i o4 o3 → (let o5 : List ℤ := Grid.sudoku_chunks.square_offsets s; let o6 : List ℤ := Grid.sudoku_chunks.square_start s; (Int.ofNat (List.length g) = (81 : ℤ) ∧ Grid.valid_values (getElem! g ∘ Int.toNat) ∧ Grid.is_index i ∧ Grid.chunk_valid_indexes o6 o5) ∧ (Grid.valid_chunk (getElem! g ∘ Int.toNat) i o6 o5 → (let o7 : ℤ := i + (1 : ℤ); ((0 : ℤ) ≤ (81 : ℤ) - i ∧ (81 : ℤ) - o7 < (81 : ℤ) - i) ∧ Grid.well_formed_sudoku s ∧ Int.ofNat (List.length g) = (81 : ℤ) ∧ Grid.valid_values (getElem! g ∘ Int.toNat) ∧ ((0 : ℤ) ≤ o7 ∧ o7 ≤ (81 : ℤ)) ∧ valid_up_to s (getElem! g ∘ Int.toNat) o7 ∧ full_up_to (getElem! g ∘ Int.toNat) o7)) ∧ (¬Grid.valid_chunk (getElem! g ∘ Int.toNat) i o6 o5 → Grid.grid_eq_sub (getElem! g ∘ Int.toNat) (getElem! g ∘ Int.toNat) (0 : ℤ) (81 : ℤ) ∧ (∀(h : ℤ -> ℤ), Grid.included (getElem! g ∘ Int.toNat) h ∧ Grid.full h → ¬Grid.valid s h)))) ∧ (¬Grid.valid_chunk (getElem! g ∘ Int.toNat) i o4 o3 → Grid.grid_eq_sub (getElem! g ∘ Int.toNat) (getElem! g ∘ Int.toNat) (0 : ℤ) (81 : ℤ) ∧ (∀(h : ℤ -> ℤ), Grid.included (getElem! g ∘ Int.toNat) h ∧ Grid.full h → ¬Grid.valid s h)))) ∧ (¬Grid.valid_chunk (getElem! g ∘ Int.toNat) i o2 o1 → Grid.grid_eq_sub (getElem! g ∘ Int.toNat) (getElem! g ∘ Int.toNat) (0 : ℤ) (81 : ℤ) ∧ (∀(h : ℤ -> ℤ), Grid.included (getElem! g ∘ Int.toNat) h ∧ Grid.full h → ¬Grid.valid s h)) else let old_g : ℤ -> ℤ := getElem! g ∘ Int.toNat; ((1 : ℤ) ≤ (9 : ℤ) + (1 : ℤ) → (Grid.grid_eq_sub old_g (Function.update (getElem! g ∘ Int.toNat) i (0 : ℤ)) (0 : ℤ) (81 : ℤ) ∧ full_up_to (getElem! g ∘ Int.toNat) i ∧ (∀(k' : ℤ), (1 : ℤ) ≤ k' ∧ k' < (1 : ℤ) → (∀(h : ℤ -> ℤ), Grid.included (Function.update old_g i k') h ∧ Grid.full h → ¬Grid.valid s h))) ∧ (∀(g1 : List ℤ), List.length g1 = List.length g → (∀(k : ℤ), ((1 : ℤ) ≤ k ∧ k ≤ (9 : ℤ)) ∧ Grid.grid_eq_sub old_g (Function.update (getElem! g1 ∘ Int.toNat) i (0 : ℤ)) (0 : ℤ) (81 : ℤ) ∧ full_up_to (getElem! g1 ∘ Int.toNat) i ∧ (∀(k' : ℤ), (1 : ℤ) ≤ k' ∧ k' < k → (∀(h : ℤ -> ℤ), Grid.included (Function.update old_g i k') h ∧ Grid.full h → ¬Grid.valid s h)) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length g1)) ∧ (List.length (List.set g1 (Int.toNat i) k) = List.length g1 → getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat = Function.update (getElem! g1 ∘ Int.toNat) i k → (let o1 : List ℤ := Grid.sudoku_chunks.column_offsets s; let o2 : List ℤ := Grid.sudoku_chunks.column_start s; (Int.ofNat (List.length (List.set g1 (Int.toNat i) k)) = (81 : ℤ) ∧ Grid.valid_values (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) ∧ Grid.is_index i ∧ Grid.chunk_valid_indexes o2 o1) ∧ (Grid.valid_chunk (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) i o2 o1 → (let o3 : List ℤ := Grid.sudoku_chunks.row_offsets s; let o4 : List ℤ := Grid.sudoku_chunks.row_start s; (Int.ofNat (List.length (List.set g1 (Int.toNat i) k)) = (81 : ℤ) ∧ Grid.valid_values (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) ∧ Grid.is_index i ∧ Grid.chunk_valid_indexes o4 o3) ∧ (Grid.valid_chunk (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) i o4 o3 → (let o5 : List ℤ := Grid.sudoku_chunks.square_offsets s; let o6 : List ℤ := Grid.sudoku_chunks.square_start s; (Int.ofNat (List.length (List.set g1 (Int.toNat i) k)) = (81 : ℤ) ∧ Grid.valid_values (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) ∧ Grid.is_index i ∧ Grid.chunk_valid_indexes o6 o5) ∧ (Grid.valid_chunk (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) i o6 o5 → (Grid.well_formed_sudoku s ∧ Grid.is_index i ∧ valid_up_to s old_g i ∧ ((1 : ℤ) ≤ k ∧ k ≤ (9 : ℤ)) ∧ Grid.valid_column s (Function.update old_g i k) i ∧ Grid.valid_row s (Function.update old_g i k) i ∧ Grid.valid_square s (Function.update old_g i k) i) ∧ (valid_up_to s (Function.update old_g i k) (i + (1 : ℤ)) → (let o7 : ℤ := i + (1 : ℤ); (((0 : ℤ) ≤ (81 : ℤ) - i ∧ (81 : ℤ) - o7 < (81 : ℤ) - i) ∧ Grid.well_formed_sudoku s ∧ Int.ofNat (List.length (List.set g1 (Int.toNat i) k)) = (81 : ℤ) ∧ Grid.valid_values (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) ∧ ((0 : ℤ) ≤ o7 ∧ o7 ≤ (81 : ℤ)) ∧ valid_up_to s (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) o7 ∧ full_up_to (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) o7) ∧ (∀(g2 : List ℤ), List.length g2 = List.length (List.set g1 (Int.toNat i) k) → (Grid.grid_eq_sub (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) (getElem! g2 ∘ Int.toNat) (0 : ℤ) (81 : ℤ) ∧ (∀(h : ℤ -> ℤ), Grid.included (getElem! g2 ∘ Int.toNat) h ∧ Grid.full h → ¬Grid.valid s h) → Grid.grid_eq_sub old_g (Function.update (getElem! g2 ∘ Int.toNat) i (0 : ℤ)) (0 : ℤ) (81 : ℤ) ∧ full_up_to (getElem! g2 ∘ Int.toNat) i ∧ (∀(k' : ℤ), (1 : ℤ) ≤ k' ∧ k' < k + (1 : ℤ) → (∀(h : ℤ -> ℤ), Grid.included (Function.update old_g i k') h ∧ Grid.full h → ¬Grid.valid s h))) ∧ (Grid.is_solution_for s (getElem! g2 ∘ Int.toNat) (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) → Grid.is_solution_for s (getElem! g2 ∘ Int.toNat) (getElem! g ∘ Int.toNat)))))) ∧ (¬Grid.valid_chunk (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) i o6 o5 → Grid.grid_eq_sub old_g (Function.update (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) i (0 : ℤ)) (0 : ℤ) (81 : ℤ) ∧ full_up_to (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) i ∧ (∀(k' : ℤ), (1 : ℤ) ≤ k' ∧ k' < k + (1 : ℤ) → (∀(h : ℤ -> ℤ), Grid.included (Function.update old_g i k') h ∧ Grid.full h → ¬Grid.valid s h))))) ∧ (¬Grid.valid_chunk (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) i o4 o3 → Grid.grid_eq_sub old_g (Function.update (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) i (0 : ℤ)) (0 : ℤ) (81 : ℤ) ∧ full_up_to (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) i ∧ (∀(k' : ℤ), (1 : ℤ) ≤ k' ∧ k' < k + (1 : ℤ) → (∀(h : ℤ -> ℤ), Grid.included (Function.update old_g i k') h ∧ Grid.full h → ¬Grid.valid s h))))) ∧ (¬Grid.valid_chunk (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) i o2 o1 → Grid.grid_eq_sub old_g (Function.update (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) i (0 : ℤ)) (0 : ℤ) (81 : ℤ) ∧ full_up_to (getElem! (List.set g1 (Int.toNat i) k) ∘ Int.toNat) i ∧ (∀(k' : ℤ), (1 : ℤ) ≤ k' ∧ k' < k + (1 : ℤ) → (∀(h : ℤ -> ℤ), Grid.included (Function.update old_g i k') h ∧ Grid.full h → ¬Grid.valid s h)))))) ∧ (Grid.grid_eq_sub old_g (Function.update (getElem! g1 ∘ Int.toNat) i (0 : ℤ)) (0 : ℤ) (81 : ℤ) ∧ full_up_to (getElem! g1 ∘ Int.toNat) i ∧ (∀(k' : ℤ), (1 : ℤ) ≤ k' ∧ k' < (9 : ℤ) + (1 : ℤ) → (∀(h : ℤ -> ℤ), Grid.included (Function.update old_g i k') h ∧ Grid.full h → ¬Grid.valid s h)) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length g1)) ∧ (List.length (List.set g1 (Int.toNat i) (0 : ℤ)) = List.length g1 → getElem! (List.set g1 (Int.toNat i) (0 : ℤ)) ∘ Int.toNat = Function.update (getElem! g1 ∘ Int.toNat) i (0 : ℤ) → Grid.grid_eq_sub (getElem! g ∘ Int.toNat) (getElem! (List.set g1 (Int.toNat i) (0 : ℤ)) ∘ Int.toNat) (0 : ℤ) (81 : ℤ) ∧ (∀(h : ℤ -> ℤ), Grid.included (getElem! (List.set g1 (Int.toNat i) (0 : ℤ)) ∘ Int.toNat) h ∧ Grid.full h → ¬Grid.valid s h))))) ∧ ((9 : ℤ) + (1 : ℤ) < (1 : ℤ) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length g)) ∧ (List.length (List.set g (Int.toNat i) (0 : ℤ)) = List.length g → getElem! (List.set g (Int.toNat i) (0 : ℤ)) ∘ Int.toNat = Function.update (getElem! g ∘ Int.toNat) i (0 : ℤ) → Grid.grid_eq_sub (getElem! g ∘ Int.toNat) (getElem! (List.set g (Int.toNat i) (0 : ℤ)) ∘ Int.toNat) (0 : ℤ) (81 : ℤ) ∧ (∀(h : ℤ -> ℤ), Grid.included (getElem! (List.set g (Int.toNat i) (0 : ℤ)) ∘ Int.toNat) h ∧ Grid.full h → ¬Grid.valid s h))))
  := sorry
end sudoku_Solver_solve_auxqtvc
