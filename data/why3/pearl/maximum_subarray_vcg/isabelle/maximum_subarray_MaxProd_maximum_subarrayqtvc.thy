theory maximum_subarray_MaxProd_maximum_subarrayqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref"
begin
consts prod :: "int list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int"
axiomatization where prod'def:   "if lo = hi then prod a lo hi = (1 :: int) else prod a lo hi = prod a lo (hi - (1 :: int)) * a ! nat (hi - (1 :: int))"
 if "(0 :: int) \<le> lo"
 and "lo \<le> hi"
 and "hi \<le> int (length a)"
  for lo :: "int"
  and hi :: "int"
  and a :: "int list"
theorem maximum_subarray'vc:
  fixes a :: "int list"
  shows "let o1 :: int = int (length a) - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> (((0 :: int) \<le> (0 :: int) \<and> prod a (0 :: int) (0 :: int) = (1 :: int) \<and> (1 :: int) \<le> (1 :: int)) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> (0 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (0 :: int) \<longrightarrow> prod a l (0 :: int) \<le> (1 :: int)) \<and> (0 :: int) \<le> (0 :: int) \<and> ((0 :: int) < (0 :: int) \<longrightarrow> (0 :: int) \<le> (0 :: int) \<and> prod a (0 :: int) (0 :: int) = (0 :: int) \<and> (0 :: int) < (0 :: int)) \<and> ((0 :: int) < (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> (0 :: int) \<longrightarrow> prod a l (0 :: int) < (0 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (0 :: int))) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> (0 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (0 :: int)) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> (0 :: int) \<longrightarrow> prod a l h \<le> (1 :: int)) \<and> (0 :: int) \<le> (0 :: int) \<and> prod a (0 :: int) (0 :: int) = (1 :: int) \<and> (1 :: int) \<le> (1 :: int)) \<and> (\<forall>(cln :: int) (clp :: int) (hi :: int) (lo :: int) (curmaxn :: int) (curmaxp :: int) (maxprd :: int). (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o1) \<and> (((0 :: int) \<le> clp \<and> clp \<le> i) \<and> prod a clp i = curmaxp \<and> (1 :: int) \<le> curmaxp) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i \<longrightarrow> (0 :: int) \<le> prod a l i \<longrightarrow> prod a l i \<le> curmaxp) \<and> curmaxn \<le> (0 :: int) \<and> (curmaxn < (0 :: int) \<longrightarrow> ((0 :: int) \<le> cln \<and> cln \<le> i) \<and> prod a cln i = curmaxn \<and> curmaxn < (0 :: int)) \<and> (curmaxn < (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i \<longrightarrow> prod a l i < (0 :: int) \<longrightarrow> curmaxn \<le> prod a l i)) \<and> (curmaxn = (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i \<longrightarrow> (0 :: int) \<le> prod a l i)) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i \<longrightarrow> prod a l h \<le> maxprd) \<and> ((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> i) \<and> prod a lo hi = maxprd \<and> (1 :: int) \<le> maxprd \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if a ! nat i = (0 :: int) then if maxprd < (1 :: int) then (((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> prod a (i + (1 :: int)) (i + (1 :: int)) = (1 :: int) \<and> (1 :: int) \<le> (1 :: int)) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)) \<longrightarrow> prod a l (i + (1 :: int)) \<le> (1 :: int)) \<and> (0 :: int) \<le> (0 :: int) \<and> ((0 :: int) < (0 :: int) \<longrightarrow> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> prod a (i + (1 :: int)) (i + (1 :: int)) = (0 :: int) \<and> (0 :: int) < (0 :: int)) \<and> ((0 :: int) < (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> prod a l (i + (1 :: int)) < (0 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)))) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int))) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i + (1 :: int) \<longrightarrow> prod a l h \<le> (1 :: int)) \<and> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> prod a (i + (1 :: int)) (i + (1 :: int)) = (1 :: int) \<and> (1 :: int) \<le> (1 :: int) else (((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> prod a (i + (1 :: int)) (i + (1 :: int)) = (1 :: int) \<and> (1 :: int) \<le> (1 :: int)) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)) \<longrightarrow> prod a l (i + (1 :: int)) \<le> (1 :: int)) \<and> (0 :: int) \<le> (0 :: int) \<and> ((0 :: int) < (0 :: int) \<longrightarrow> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> prod a (i + (1 :: int)) (i + (1 :: int)) = (0 :: int) \<and> (0 :: int) < (0 :: int)) \<and> ((0 :: int) < (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> prod a l (i + (1 :: int)) < (0 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)))) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int))) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i + (1 :: int) \<longrightarrow> prod a l h \<le> maxprd) \<and> ((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> i + (1 :: int)) \<and> prod a lo hi = maxprd \<and> (1 :: int) \<le> maxprd else ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if (0 :: int) < a ! nat i then ((0 :: int) \<le> i \<and> i < int (length a)) \<and> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if maxprd < curmaxp * a ! nat i then (((0 :: int) \<le> clp \<and> clp \<le> i + (1 :: int)) \<and> prod a clp (i + (1 :: int)) = curmaxp * a ! nat i \<and> (1 :: int) \<le> curmaxp * a ! nat i) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)) \<longrightarrow> prod a l (i + (1 :: int)) \<le> curmaxp * a ! nat i) \<and> curmaxn * a ! nat i \<le> (0 :: int) \<and> (curmaxn * a ! nat i < (0 :: int) \<longrightarrow> ((0 :: int) \<le> cln \<and> cln \<le> i + (1 :: int)) \<and> prod a cln (i + (1 :: int)) = curmaxn * a ! nat i \<and> curmaxn * a ! nat i < (0 :: int)) \<and> (curmaxn * a ! nat i < (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> prod a l (i + (1 :: int)) < (0 :: int) \<longrightarrow> curmaxn * a ! nat i \<le> prod a l (i + (1 :: int)))) \<and> (curmaxn * a ! nat i = (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)))) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i + (1 :: int) \<longrightarrow> prod a l h \<le> curmaxp * a ! nat i) \<and> ((0 :: int) \<le> clp \<and> clp \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> prod a clp (i + (1 :: int)) = curmaxp * a ! nat i \<and> (1 :: int) \<le> curmaxp * a ! nat i else (((0 :: int) \<le> clp \<and> clp \<le> i + (1 :: int)) \<and> prod a clp (i + (1 :: int)) = curmaxp * a ! nat i \<and> (1 :: int) \<le> curmaxp * a ! nat i) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)) \<longrightarrow> prod a l (i + (1 :: int)) \<le> curmaxp * a ! nat i) \<and> curmaxn * a ! nat i \<le> (0 :: int) \<and> (curmaxn * a ! nat i < (0 :: int) \<longrightarrow> ((0 :: int) \<le> cln \<and> cln \<le> i + (1 :: int)) \<and> prod a cln (i + (1 :: int)) = curmaxn * a ! nat i \<and> curmaxn * a ! nat i < (0 :: int)) \<and> (curmaxn * a ! nat i < (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> prod a l (i + (1 :: int)) < (0 :: int) \<longrightarrow> curmaxn * a ! nat i \<le> prod a l (i + (1 :: int)))) \<and> (curmaxn * a ! nat i = (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)))) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i + (1 :: int) \<longrightarrow> prod a l h \<le> maxprd) \<and> ((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> i + (1 :: int)) \<and> prod a lo hi = maxprd \<and> (1 :: int) \<le> maxprd) else if curmaxn < (0 :: int) then ((0 :: int) \<le> i \<and> i < int (length a)) \<and> ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if maxprd < curmaxn * a ! nat i then (((0 :: int) \<le> cln \<and> cln \<le> i + (1 :: int)) \<and> prod a cln (i + (1 :: int)) = curmaxn * a ! nat i \<and> (1 :: int) \<le> curmaxn * a ! nat i) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)) \<longrightarrow> prod a l (i + (1 :: int)) \<le> curmaxn * a ! nat i) \<and> curmaxp * a ! nat i \<le> (0 :: int) \<and> (curmaxp * a ! nat i < (0 :: int) \<longrightarrow> ((0 :: int) \<le> clp \<and> clp \<le> i + (1 :: int)) \<and> prod a clp (i + (1 :: int)) = curmaxp * a ! nat i \<and> curmaxp * a ! nat i < (0 :: int)) \<and> (curmaxp * a ! nat i < (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> prod a l (i + (1 :: int)) < (0 :: int) \<longrightarrow> curmaxp * a ! nat i \<le> prod a l (i + (1 :: int)))) \<and> (curmaxp * a ! nat i = (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)))) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i + (1 :: int) \<longrightarrow> prod a l h \<le> curmaxn * a ! nat i) \<and> ((0 :: int) \<le> cln \<and> cln \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> prod a cln (i + (1 :: int)) = curmaxn * a ! nat i \<and> (1 :: int) \<le> curmaxn * a ! nat i else (((0 :: int) \<le> cln \<and> cln \<le> i + (1 :: int)) \<and> prod a cln (i + (1 :: int)) = curmaxn * a ! nat i \<and> (1 :: int) \<le> curmaxn * a ! nat i) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)) \<longrightarrow> prod a l (i + (1 :: int)) \<le> curmaxn * a ! nat i) \<and> curmaxp * a ! nat i \<le> (0 :: int) \<and> (curmaxp * a ! nat i < (0 :: int) \<longrightarrow> ((0 :: int) \<le> clp \<and> clp \<le> i + (1 :: int)) \<and> prod a clp (i + (1 :: int)) = curmaxp * a ! nat i \<and> curmaxp * a ! nat i < (0 :: int)) \<and> (curmaxp * a ! nat i < (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> prod a l (i + (1 :: int)) < (0 :: int) \<longrightarrow> curmaxp * a ! nat i \<le> prod a l (i + (1 :: int)))) \<and> (curmaxp * a ! nat i = (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)))) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i + (1 :: int) \<longrightarrow> prod a l h \<le> maxprd) \<and> ((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> i + (1 :: int)) \<and> prod a lo hi = maxprd \<and> (1 :: int) \<le> maxprd) else ((0 :: int) \<le> i \<and> i < int (length a)) \<and> (if maxprd < (1 :: int) then (((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> prod a (i + (1 :: int)) (i + (1 :: int)) = (1 :: int) \<and> (1 :: int) \<le> (1 :: int)) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)) \<longrightarrow> prod a l (i + (1 :: int)) \<le> (1 :: int)) \<and> curmaxp * a ! nat i \<le> (0 :: int) \<and> (curmaxp * a ! nat i < (0 :: int) \<longrightarrow> ((0 :: int) \<le> clp \<and> clp \<le> i + (1 :: int)) \<and> prod a clp (i + (1 :: int)) = curmaxp * a ! nat i \<and> curmaxp * a ! nat i < (0 :: int)) \<and> (curmaxp * a ! nat i < (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> prod a l (i + (1 :: int)) < (0 :: int) \<longrightarrow> curmaxp * a ! nat i \<le> prod a l (i + (1 :: int)))) \<and> (curmaxp * a ! nat i = (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)))) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i + (1 :: int) \<longrightarrow> prod a l h \<le> (1 :: int)) \<and> ((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> prod a (i + (1 :: int)) (i + (1 :: int)) = (1 :: int) \<and> (1 :: int) \<le> (1 :: int) else (((0 :: int) \<le> i + (1 :: int) \<and> i + (1 :: int) \<le> i + (1 :: int)) \<and> prod a (i + (1 :: int)) (i + (1 :: int)) = (1 :: int) \<and> (1 :: int) \<le> (1 :: int)) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)) \<longrightarrow> prod a l (i + (1 :: int)) \<le> (1 :: int)) \<and> curmaxp * a ! nat i \<le> (0 :: int) \<and> (curmaxp * a ! nat i < (0 :: int) \<longrightarrow> ((0 :: int) \<le> clp \<and> clp \<le> i + (1 :: int)) \<and> prod a clp (i + (1 :: int)) = curmaxp * a ! nat i \<and> curmaxp * a ! nat i < (0 :: int)) \<and> (curmaxp * a ! nat i < (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> prod a l (i + (1 :: int)) < (0 :: int) \<longrightarrow> curmaxp * a ! nat i \<le> prod a l (i + (1 :: int)))) \<and> (curmaxp * a ! nat i = (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> i + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (i + (1 :: int)))) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> i + (1 :: int) \<longrightarrow> prod a l h \<le> maxprd) \<and> ((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> i + (1 :: int)) \<and> prod a lo hi = maxprd \<and> (1 :: int) \<le> maxprd)))) \<and> ((((0 :: int) \<le> clp \<and> clp \<le> o1 + (1 :: int)) \<and> prod a clp (o1 + (1 :: int)) = curmaxp \<and> (1 :: int) \<le> curmaxp) \<and> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> o1 + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (o1 + (1 :: int)) \<longrightarrow> prod a l (o1 + (1 :: int)) \<le> curmaxp) \<and> curmaxn \<le> (0 :: int) \<and> (curmaxn < (0 :: int) \<longrightarrow> ((0 :: int) \<le> cln \<and> cln \<le> o1 + (1 :: int)) \<and> prod a cln (o1 + (1 :: int)) = curmaxn \<and> curmaxn < (0 :: int)) \<and> (curmaxn < (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> o1 + (1 :: int) \<longrightarrow> prod a l (o1 + (1 :: int)) < (0 :: int) \<longrightarrow> curmaxn \<le> prod a l (o1 + (1 :: int)))) \<and> (curmaxn = (0 :: int) \<longrightarrow> (\<forall>(l :: int). (0 :: int) \<le> l \<and> l \<le> o1 + (1 :: int) \<longrightarrow> (0 :: int) \<le> prod a l (o1 + (1 :: int)))) \<and> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> o1 + (1 :: int) \<longrightarrow> prod a l h \<le> maxprd) \<and> ((0 :: int) \<le> lo \<and> lo \<le> hi \<and> hi \<le> o1 + (1 :: int)) \<and> prod a lo hi = maxprd \<and> (1 :: int) \<le> maxprd \<longrightarrow> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> int (length a) \<longrightarrow> prod a l h \<le> maxprd) \<and> (\<exists>(l :: int) (h :: int). ((0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> int (length a)) \<and> prod a l h = maxprd)))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> (\<forall>(l :: int) (h :: int). (0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> int (length a) \<longrightarrow> prod a l h \<le> (1 :: int)) \<and> (\<exists>(l :: int) (h :: int). ((0 :: int) \<le> l \<and> l \<le> h \<and> h \<le> int (length a)) \<and> prod a l h = (1 :: int)))"
  sorry
end
