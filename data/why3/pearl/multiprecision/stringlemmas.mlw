module String_lemmas

  use array.Array
  use map.Map
  use map.MapEq
  use map.Const
  use int.Int
  use int.Power
  use lemmas.Lemmas
  use mach.c.C
  use mach.c.UChar

  predicate in_base (b:int) (x:map int uchar) (n:int) (m:int) =
    forall i. n <= i < m -> 0 <= x[i] < b

  let ghost in_base_concat (b:int) (x:map int uchar) (n m l:int) : unit
    requires { in_base b x n m }
    requires { in_base b x m l }
    ensures  { in_base b x n l }
  = ()

  let rec ghost function
      svalue_le_sub (b:int) (x:map int uchar) (n:int) (m:int) : int
    variant  { m - n }
  =
    if n < m
    then uchar'int x[n] + b * svalue_le_sub b x (n+1) m
    else 0

  predicate string_in_base (b:int) (p:ptr uchar) =
    in_base b (pelts p) (min p) (max p)

  let ghost svalue_le_sub_tail (b:int) (x:map int uchar) (n m:int) : unit
    requires { n <= m }
    requires { in_base b x n (m+1) }
    requires { 2 <= b <= 256 }
    ensures  {
      svalue_le_sub b x n (m+1) =
        svalue_le_sub b x n m + (Map.get x m) * power b (m-n) }
  = ()

  let ghost svalue_le_sub_concat (b:int) (x:map int uchar) (n m l:int) : unit
    requires { n <= m <= l}
    requires { in_base b x n l }
    requires { 2 <= b <= 256 }
    ensures  {
      svalue_le_sub b x n l =
        svalue_le_sub b x n m + svalue_le_sub b x m l * power b (m-n) }
  = ()

  let ghost svalue_le_sub_head (b:int) (x:map int uchar) (n m:int) : unit
    requires { n < m }
    requires { in_base b x n m }
    requires { 2 <= b <= 256 }
    ensures { svalue_le_sub b x n m = x[n] + b * svalue_le_sub b x (n+1) m }
  = ()

  let ghost svalue_le_sub_frame (b:int) (x y:map int uchar) (n m:int) : unit
    requires { MapEq.map_eq_sub x y n m }
    ensures  { svalue_le_sub b x n m = svalue_le_sub b y n m }
  = ()

  use mach.int.Int32

  function svalue_le (b:int) (x:ptr uchar) (sz:int) : int
  =
    svalue_le_sub b (pelts x) x.offset (x.offset + sz)

   let ghost svalue_le_tail (b:int) (x:ptr uchar) (sz:int32) : unit
    requires { 0 <= sz }
    requires { in_base b (pelts x) x.offset (x.offset + sz + 1)  }
    requires { 2 <= b <= 256 }
    ensures  { svalue_le b x (sz + 1)
               = svalue_le b x sz + (pelts x)[x.offset + sz] * power b sz }
  = ()

  let ghost svalue_le_concat (b:int) (x:ptr uchar) (n m:int32) : unit
    requires { 0 <= n <= m }
    requires { in_base b (pelts x) x.offset (x.offset + p2i m)  }
    requires { 2 <= b <= 256 }
    ensures  { svalue_le b x m
               = svalue_le b x n
                 + power b n
                   * svalue_le_sub b (pelts x) (x.offset + n) (x.offset + m) }
  = ()

  (** Big-endian values for strings *)

  let rec ghost function
                svalue_sub (b:int) (x: map int uchar) (n:int) (m:int) : int
    variant { m - n }
  = if n < m
    then uchar'int x[m-1] + b * svalue_sub b x n (m-1)
    else 0

  let ghost svalue_sub_tail (b:int) (x:map int uchar) (n m:int) : unit
    requires { n <= m }
    requires { in_base b x (n-1) m }
    requires { 2 <= b <= 256 }
    ensures  { svalue_sub b x (n-1) m =
                 svalue_sub b x n m + (Map.get x (n-1)) * power b (m - n) }
  = ()

  let ghost svalue_sub_concat (b:int) (x:map int uchar) (n m l:int) : unit
    requires { n <= m <= l}
    requires { in_base b x n l }
    requires { 2 <= b <= 256 }
    ensures  { svalue_sub b x n l
               = svalue_sub b x m l + power b (l - m) * svalue_sub b x n m }
  = ()

  let ghost svalue_sub_head (b:int) (x:map int uchar) (n m:int) : unit
    requires { n < m }
    requires { in_base b x n m }
    requires { 2 <= b <= 256 }
    ensures { svalue_sub b x n m = x[m-1] + b * svalue_sub b x n (m-1) }
  = ()

  let ghost svalue_sub_frame (b:int) (x y:map int uchar) (n m:int) : unit
    requires { MapEq.map_eq_sub x y n m }
    ensures  { svalue_sub b x n m = svalue_sub b y n m }
  = ()

  function svalue (b:int) (x:ptr uchar) (sz:int) : int
  = svalue_sub b (pelts x) x.offset (x.offset + sz)

  let ghost svalue_le_sub_lower_bound (b:int) (x:map int uchar) (n m:int) : unit
    requires { 2 <= b <= 256 }
    ensures { 0 <= svalue_le_sub b x n m }
  = ()

  let ghost svalue_sub_lower_bound (b:int) (x:map int uchar) (n m:int) : unit
    requires { 2 <= b <= 256 }
    ensures { 0 <= svalue_sub b x n m }
  = ()

  let ghost svalue_le_sub_upper_bound (b:int) (x:map int uchar) (n m:int) : unit
    requires { 2 <= b <= 256 }
    requires { n <= m }
    requires { in_base b x n m }
    ensures  { svalue_le_sub b x n m < power b (m - n) }
    = ()

  let ghost svalue_sub_upper_bound (b:int) (x:map int uchar) (n m:int) : unit
    requires { 2 <= b <= 256 }
    requires { n <= m }
    requires { in_base b x n m }
    ensures  { svalue_sub b x n m < power b (m - n) }
    = ()
end

module Conversions [@W:non_conservative_extension:N]

  use array.Array
  use map.Map
  use map.MapEq
  use map.Const
  use int.Int
  use int.Power
  use lemmas.Lemmas
  use string.String
  use mach.c.String
  use string.Char
  use mach.int.Int32
  use mach.c.UChar

  constant numlowstring : string = "0123456789abcdefghijklmnopqrstuvwxyz"

  function num_to_lowercase_text (d:uchar) : char
  = if 0 <= d < 36
    then get numlowstring d
    else chr (-1)

  predicate to_lowercase_text (d:map int uchar) (t:map int char) (m n:int)
  = forall i. n <= i < m -> Map.get t i = num_to_lowercase_text (Map.get d i)

  constant numupstring : string = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

  function num_to_uppercase_text (d:uchar) : char
  = if 0 <= d < 36
    then get numupstring d
    else chr (-1)

  predicate to_uppercase_text (d:map int uchar) (t:map int char) (m n:int)
  = forall i. n <= i < m -> Map.get t i = num_to_uppercase_text (Map.get d i)

  constant numuplowstring : string
           = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

  function num_to_bothcase_text (d:uchar): char
  = if 0 <= d < 62
    then get numuplowstring d
    else chr (-1)

  predicate to_bothcase_text (d:map int uchar) (t:map int char) (m n:int)
  = forall i. n <= i < m -> Map.get t i = num_to_bothcase_text (Map.get d i)

  let ghost lowconcat () : unit
    ensures { numlowstring = concat digitstring lowstring }
  = ()
  let ghost upconcat () : unit
    ensures { numupstring = concat digitstring upstring }
  = ()
  let ghost digitsublow () : unit
    ensures { digitstring = substring numlowstring 0 10 }
  = ()
  let ghost digitsubup () : unit
    ensures { digitstring = substring numupstring 0 10 }
  = ()
  let ghost lowsub () : unit
    ensures { lowstring = substring numlowstring 10 26 }
  = ()
  let ghost upsub () : unit
    ensures { upstring = substring numupstring 10 26 }
  = ()
  let ghost lowupconcat () : unit
    ensures { numuplowstring = concat numupstring lowstring }
  = ()
  let ghost digitsublowup () : unit
    ensures { digitstring = substring numuplowstring 0 10 }
  = ()
  let ghost upsublowup () : unit
    ensures { upstring = substring numuplowstring 10 26 }
  = ()
  let ghost lowsublowup () : unit
    ensures { lowstring = substring numuplowstring 36 26 }
  = ()

  function text_to_num_onecase (c:char) : int
  = if (get "0" 0) <= c <= (get "9" 0)
    then c - (get "0" 0)
    else if (get "a" 0) <= c <= (get "z" 0)
    then c - (get "a" 0) + 10
    else if (get "A" 0) <= c <= (get "Z" 0)
    then c - (get "A" 0) + 10
    else -1

  function text_to_num_bothcase (c:char) : int
  = if (get "0" 0) <= c <= (get "9" 0)
    then c - (get "0" 0)
    else if (get "a" 0) <= c <= (get "z" 0)
    then c - (get "a" 0) + 36
    else if (get "A" 0) <= c <= (get "Z" 0)
    then c - (get "A" 0) + 10
    else -1

  function text_to_num (base:int) (c:char) : int
  = if - 36 <= base <= 36
    then text_to_num_onecase c
    else text_to_num_bothcase c

  function num_to_text (base:int) (d:uchar) : char
  = if 0 <= base <= 36
    then num_to_lowercase_text d
    else if 36 < base <= 62
    then num_to_bothcase_text d
    else if -36 <= base
    then num_to_uppercase_text d
    else chr (-1)

  predicate to_num (base:int) (t: map int char) (d: map int uchar) (n m:int)
    = forall i. n <= i < m -> Map.get d i = text_to_num base (Map.get t i)

  let ghost digits_lemma () : unit
    ensures { code (get "9" 0) = code (get "0" 0) + 9 }
  = ()

  let ghost lower_lem () : unit
    ensures { code (get "z" 0) = code (get "a" 0) + 25 }
  = ()

  let ghost upper_lem () : unit
    ensures { code (get "Z" 0) = code (get "A" 0) + 25 }
  = ()


  let ghost diglow () : unit
    ensures { code (get "9" 0) < code (get "a" 0) }
  = ()
  let ghost digup () : unit
    ensures { code (get "9" 0) < code (get "A" 0) }
  = ()
  let ghost lowup () : unit
    ensures { code (get "Z" 0) < code (get "a" 0) }
  = ()

  let ghost tnt_low (d:uchar) : unit
    requires { 0 <= d < 36 }
    ensures { text_to_num_onecase (num_to_lowercase_text d) = d }
  = ()

  let ghost tnt_up (d:uchar) : unit
    requires { 0 <= d < 36 }
    ensures { text_to_num_onecase (num_to_uppercase_text d) = d }
  = ()

  let ghost tnt_both (d:uchar) : unit
    requires { 0 <= d < 62 }
    ensures { text_to_num_bothcase (num_to_bothcase_text d) = d }
  = ()

  use int.Abs

  let ghost tnt (base:int) (d:uchar) : unit
    requires { -36 <= base <= 62 }
    requires { 0 <= d < abs base }
    ensures  { text_to_num base (num_to_text base d) = d }
  = ()

end
module String_value

  use mach.c.C
  use mach.c.String
  use string.Char
  use map.Map
  use int.Int
  use String_lemmas
  use Conversions
  use mach.c.UChar

  let rec ghost function
                abs_value_sub_text (b:int) (s:map int char) (n m: int) : int
    variant { m - n }
  = if n < m
    then text_to_num b s[m-1] + b * abs_value_sub_text b s n (m-1)
    else 0

  let ghost text_conversion (b:int) (t: map int char)
                                (d: map int uchar) (n m:int) : unit
    requires { to_num b t d n m }
    ensures  { abs_value_sub_text b t n m = svalue_sub b d n m }
  = ()

  function abs_value_text (b:int) (s:map int char) (ofs:int) : int
    = abs_value_sub_text b s ofs (ofs + strlen s ofs)

  function value_text (b:int) (s:map int char) (ofs:int) : int
    = if Char.(=) s[ofs] minus_char
      then - abs_value_text b s (ofs + 1)
      else abs_value_text b s ofs

  predicate text_in_base (b:int) (t: map int char) (n m:int)
    = forall i. n <= i < m -> 0 <= text_to_num b t[i] < b

  predicate string_in_base (b:int) (s:map int char) (ofs: int)
    = (text_in_base b s ofs (ofs + strlen s ofs) /\ strlen s ofs > 0)
      \/ (s[ofs] = minus_char
         /\ text_in_base b s (ofs + 1) (ofs + strlen s ofs)
         /\ strlen s ofs > 1)

  let ghost abs_value_sub_text_frame (b:int) (x y: map int char) (n m: int) : unit
    requires { forall i. n <= i < m -> x[i] = y[i] }
    ensures  { abs_value_sub_text b x n m = abs_value_sub_text b y n m }
  = ()

end
