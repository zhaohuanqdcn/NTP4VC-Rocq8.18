import Why3.Base
import pearl.imp.lib.lean.imp.Syntax
import pearl.imp.lib.lean.imp.ConcreteSemantics
import pearl.imp.lib.lean.imp.Svar
import pearl.imp.lib.lean.imp.Constraint
import pearl.imp.lib.lean.imp.SymState
import pearl.imp.lib.lean.imp.FreshSvar
import pearl.imp.lib.lean.imp.SymStateSet
open Classical
open Lean4Why3
namespace imp_SymbolicInterpreter_symbolic_interp_exprqtvc
axiom compose : (Svar.svar -> ℤ) -> Constraint.t -> Syntax.program_var -> Option ℤ
axiom compose'def (rho : Svar.svar -> ℤ) (sigma : Constraint.t) (x : Syntax.program_var) : compose rho sigma x = (match Constraint.get sigma x with | Option.some v => Option.some (rho v) | Option.none => Option.none)
theorem symbolic_interp_expr'vc (e : Syntax.expr) (s : SymState.sym_state) : match e with | Syntax.expr.Elit n => (let result : Constraint.symbolic_expr := Constraint.symbolic_expr.Slit n; ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e (ConcreteSemantics.expr_behaviour.Enormal (Constraint.interp_symbolic_expr (SymState.rho s) result)) ∧ (∀(v : Svar.svar), v ∈ Constraint.vars_in_symbolic_expr result → (∃(x : Syntax.program_var), Constraint.get (SymState.sigma s) x = Option.some v))) | Syntax.expr.Evar x => (∀(o1 : Svar.svar), Constraint.get (SymState.sigma s) x = Option.some o1 → (let result : Constraint.symbolic_expr := Constraint.symbolic_expr.Svar o1; ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e (ConcreteSemantics.expr_behaviour.Enormal (Constraint.interp_symbolic_expr (SymState.rho s) result)) ∧ (∀(v : Svar.svar), v ∈ Constraint.vars_in_symbolic_expr result → (∃(x1 : Syntax.program_var), Constraint.get (SymState.sigma s) x1 = Option.some v)))) ∧ (Constraint.get (SymState.sigma s) x = Option.none → ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e ConcreteSemantics.expr_behaviour.Eunbound_var) | Syntax.expr.Esub e1 e2 => (match e with | Syntax.expr.Elit _ => False | Syntax.expr.Evar _ => False | Syntax.expr.Esub f f1 => f = e2 ∨ f1 = e2) ∧ (∀(o1 : Constraint.symbolic_expr), ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e2 (ConcreteSemantics.expr_behaviour.Enormal (Constraint.interp_symbolic_expr (SymState.rho s) o1)) ∧ (∀(v : Svar.svar), v ∈ Constraint.vars_in_symbolic_expr o1 → (∃(x : Syntax.program_var), Constraint.get (SymState.sigma s) x = Option.some v)) → (match e with | Syntax.expr.Elit _ => False | Syntax.expr.Evar _ => False | Syntax.expr.Esub f f1 => f = e1 ∨ f1 = e1) ∧ (∀(o2 : Constraint.symbolic_expr), ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e1 (ConcreteSemantics.expr_behaviour.Enormal (Constraint.interp_symbolic_expr (SymState.rho s) o2)) ∧ (∀(v : Svar.svar), v ∈ Constraint.vars_in_symbolic_expr o2 → (∃(x : Syntax.program_var), Constraint.get (SymState.sigma s) x = Option.some v)) → (let result : Constraint.symbolic_expr := Constraint.symbolic_expr.Ssub o2 o1; ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e (ConcreteSemantics.expr_behaviour.Enormal (Constraint.interp_symbolic_expr (SymState.rho s) result)) ∧ (∀(v : Svar.svar), v ∈ Constraint.vars_in_symbolic_expr result → (∃(x : Syntax.program_var), Constraint.get (SymState.sigma s) x = Option.some v)))) ∧ (ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e1 ConcreteSemantics.expr_behaviour.Eunbound_var → ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e ConcreteSemantics.expr_behaviour.Eunbound_var)) ∧ (ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e2 ConcreteSemantics.expr_behaviour.Eunbound_var → ConcreteSemantics.eval_expr (compose (SymState.rho s) (SymState.sigma s)) e ConcreteSemantics.expr_behaviour.Eunbound_var)
  := sorry
end imp_SymbolicInterpreter_symbolic_interp_exprqtvc
