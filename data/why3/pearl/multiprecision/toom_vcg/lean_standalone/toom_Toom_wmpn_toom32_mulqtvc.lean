import Mathlib

open Classical

namespace Lean4Why3

instance {n : Nat} : HShiftLeft (BitVec n) Int (BitVec n) where
  hShiftLeft x k := x <<< k.toNat

instance {n : Nat} : HShiftRight (BitVec n) Int (BitVec n) where
  hShiftRight x k := x >>> k.toNat

abbrev sshiftRight'i {n : ℕ} (a : BitVec n) (s : Int) : BitVec n := a.sshiftRight s.toNat

abbrev make_str_i (size : Int) := String.mk (List.replicate (Int.toNat size) 'a')
abbrev _root_.List.create_i {α} (n : ℤ) (f : ℤ -> α) := (List.range n.toNat).map f
abbrev _root_.List.create {α} (n : ℕ) (f : ℕ -> α) := (List.range n).map f

abbrev _root_.Bool.imp (a b : Bool) : Bool := !a || b

abbrev _root_.List.replicate_i {α} (n : ℤ) (x : α) := List.replicate (Int.toNat n) x

abbrev take_i {α : Type} (n : ℤ) (l : List α) := List.take n.toNat l
abbrev drop_i {α : Type} (n : ℤ) (l : List α) := List.drop n.toNat l

abbrev getElem_i! {α : Type} [Inhabited α] (l : List α) (i : Int) := l[i.toNat]!
abbrev getElem_i? {α : Type} (l : List α) (i : Int) := l[i.toNat]?

abbrev length_i {α : Type} (l : List α) := Int.ofNat l.length
abbrev slice {α : Type} (l : List α) (i j : Nat) : List α :=
  (l.drop i).take (j - i)
abbrev slice_i {α : Type} (l : List α) (i j : Int) : List α :=
  (l.drop i.toNat).take (j.toNat - i.toNat)

abbrev Sorted {α : Type} [LE α] (l : List α) := List.Sorted LE.le l
abbrev _root_.List.set_i {α : Type} (l : List α) (n : ℤ) (a : α) :=
  List.set l n.toNat a

abbrev implication (P : Prop) (Q : Prop) := P -> Q

noncomputable def map_occ {α : Type} (v : α) (m : Int -> α) (l u : Int)
  := {n | l ≤ n ∧ n < u ∧ m n = v }.ncard
noncomputable abbrev map_occ_i {α : Type} (v : α) (m : Int -> α) (l u : Int)
  := Int.ofNat (map_occ (v : α) (m : Int -> α) (l : Int) u)

abbrev _root_.BitVec.toUInt {n : Nat} (x : BitVec n) := Int.ofNat x.toNat

abbrev int'16_max : BitVec 16 := 32767
abbrev int'16_min : BitVec 16 := -32768
abbrev int'31_max : BitVec 31 := 1073741823
abbrev int'31_min : BitVec 31 := -1073741824
abbrev int'32_max : BitVec 32 := 2147483647
abbrev int'32_min : BitVec 32 := -2147483648
abbrev int'63_max : BitVec 63 := 4611686018427387903
abbrev int'63_min : BitVec 63 := -4611686018427387904
abbrev int'64_max : BitVec 64 := 9223372036854775807
abbrev int'64_min : BitVec 64 := -9223372036854775808
abbrev uint'16_max : BitVec 16 := 65535
abbrev uint'16_min : BitVec 16 := 0
abbrev uint'31_max : BitVec 31 := 2147483647
abbrev uint'31_min : BitVec 31 := 0
abbrev uint'32_max : BitVec 32 := 4294967295
abbrev uint'32_min : BitVec 32 := 0
abbrev uint'63_max : BitVec 63 := 9223372036854775807
abbrev uint'63_min : BitVec 63 := 0
abbrev uint'64_max : BitVec 64 := 18446744073709551615
abbrev uint'64_min : BitVec 64 := 0

abbrev int'16_in_bounds (x : Int) := int'16_min.toInt ≤ x ∧ x ≤ int'16_max.toInt
abbrev int'31_in_bounds (x : Int) := int'31_min.toInt ≤ x ∧ x ≤ int'31_max.toInt
abbrev int'32_in_bounds (x : Int) := int'32_min.toInt ≤ x ∧ x ≤ int'32_max.toInt
abbrev int'63_in_bounds (x : Int) := int'63_min.toInt ≤ x ∧ x ≤ int'63_max.toInt
abbrev int'64_in_bounds (x : Int) := int'64_min.toInt ≤ x ∧ x ≤ int'64_max.toInt
abbrev uint'8_in_bounds (x : Int) := 0 ≤ x ∧ x ≤ 256
abbrev uint'16_in_bounds (x : Int) := 0 ≤ x ∧ x ≤ int'16_max.toUInt
abbrev uint'31_in_bounds (x : Int) := 0 ≤ x ∧ x ≤ int'31_max.toUInt
abbrev uint'32_in_bounds (x : Int) := 0 ≤ x ∧ x ≤ int'32_max.toUInt
abbrev uint'63_in_bounds (x : Int) := 0 ≤ x ∧ x ≤ int'63_max.toUInt
abbrev uint'64_in_bounds (x : Int) := 0 ≤ x ∧ x ≤ int'64_max.toUInt

axiom array31 : Type -> Type
axiom array32 : Type -> Type
axiom array63 : Type -> Type

axiom array31_elts : {α : Type} -> array31 α -> Int -> α
axiom array32_elts : {α : Type} -> array32 α -> Int -> α
axiom array63_elts : {α : Type} -> array63 α -> List α

noncomputable abbrev array63_nth {α : Type} [Inhabited α] (a : array63 α) (i : Int) := (array63_elts a)[i.toNat]!

axiom array31_length : {α : Type} -> array31 α -> BitVec 31
axiom array32_length : {α : Type} -> array32 α -> BitVec 32
axiom array63_length : {α : Type} -> array63 α -> BitVec 63

abbrev is_none {α : Type} (x : Option α) := x = none
abbrev is_nil {α : Type} (x : List α) := x = []

abbrev _root_.List.rev_append {α : Type} (a : List α) (b : List α) := a.reverse ++ b
abbrev _root_.Finset.is_empty {α : Type} (s : Finset α) := s = ∅
abbrev _root_.Finset.filter' {α : Type} (s : Finset α) (p : α → Prop) [DecidablePred p] : Finset α
  := Finset.filter p s

abbrev _root_.Finset.card_i {α : Type} (s : Finset α) := Int.ofNat s.card

abbrev int_power (x : Int) (n : Int) := x ^ n.toNat
abbrev bv2_power (n : Int) := Int.ofNat (2 ^ n.toNat)

abbrev take_bit_i {n : Nat} (x : BitVec n) (i : Int) := x[i.toNat]!
abbrev take_bit_bv {n m : Nat} (x : BitVec n) (i : BitVec m) := x[i.toNat]!

noncomputable def _root_.Finset.pick! {α} [Inhabited α] (s : Finset α) : α :=
  if h : s.Nonempty then Classical.choose h else default
noncomputable def _root_.Set.pick! {α} [Inhabited α] (s : Finset α) : α :=
  if h : s.Nonempty then Classical.choose h else default

noncomputable abbrev _root_.BitVec.eq_sub {m : Nat} (a b : BitVec m) (i n : Nat) :=
  BitVec.extractLsb (i+n-1) i a = BitVec.extractLsb (i+n-1) i b

noncomputable abbrev _root_.BitVec.eq_sub_i {m : Nat} (a b : BitVec m) (i n : Int) :=
  BitVec.eq_sub a b i.toNat n.toNat

noncomputable abbrev _root_.BitVec.eq_sub_bv {m : Nat} {m1 : Nat} {m2 : Nat} (a b : BitVec m) (i : BitVec m1) (n : BitVec m2) :=
  BitVec.eq_sub a b i.toNat n.toNat

abbrev w8_size_bv := (8 : BitVec 8)
abbrev w16_size_bv := (16 : BitVec 16)
abbrev w32_size_bv := (32 : BitVec 32)
abbrev w64_size_bv := (64 : BitVec 64)
abbrev w128_size_bv := (128 : BitVec 128)
abbrev w256_size_bv := (256 : BitVec 256)
abbrev w8_size_i := (8 : Int)
abbrev w16_size_i := (16 : Int)
abbrev w32_size_i := (32 : Int)
abbrev w64_size_i := (64 : Int)
abbrev w128_size_i := (128 : Int)
abbrev w256_size_i := (256 : Int)

abbrev _root_.Finset.erase' {α : Type} [DecidableEq α] (a : α) (s : Finset α) : Finset α
  := Finset.erase s a

abbrev _root_.BitVec.sge {n : ℕ} (x y : BitVec n) := BitVec.sle y x
abbrev _root_.BitVec.sgt {n : ℕ} (x y : BitVec n) := BitVec.slt y x

abbrev _root_.BitVec.sshiftRight_i {n : ℕ} (x : BitVec n) (s : ℤ) := BitVec.sshiftRight x s.toNat
abbrev _root_.BitVec.sshiftRight_bv {n m : ℕ} (x : BitVec n) (s : BitVec m)
  := BitVec.sshiftRight x s.toNat

abbrev _root_.BitVec.rotateLeft_i {w : ℕ} (x : BitVec w) (n : ℤ) := BitVec.rotateLeft x n.toNat
abbrev _root_.BitVec.rotateLeft_nv {w w2 : ℕ} (x : BitVec w) (n : BitVec w2)
  := BitVec.rotateLeft x n.toNat

abbrev _root_.BitVec.rotateRight_i {w : ℕ} (x : BitVec w) (n : ℤ) := BitVec.rotateRight x n.toNat
abbrev _root_.BitVec.rotateRight_nv {w w2 : ℕ} (x : BitVec w) (n : BitVec w2)
  := BitVec.rotateRight x n.toNat

abbrev _root_.Multiset.count_i {α : Type} [DecidableEq α] (a : α) (s : Multiset α)
  := Int.ofNat (s.count a)

abbrev _root_.Multiset.card_i {α : Type} (S : Multiset α) := Int.ofNat S.card

abbrev _root_.Int.gcd_i (a : ℤ) (b : ℤ) := Int.ofNat (Int.gcd a b)

abbrev _root_.Int.Prime (p : ℤ) := Nat.Prime p.toNat
abbrev _root_.Int.Coprime (a b : ℤ) := Nat.Coprime a.toNat b.toNat

abbrev _root_.Set.remove {α : Type} (x : α) (A : Set α) := A \ {x}
abbrev _root_.Set.filter {α : Type} (S : Set α) (P : α -> Bool) := {x ∈ S | P x }

abbrev _root_.Option.the {α : Type} [Inhabited α] (opt : Option α) := opt.getD default

noncomputable abbrev _root_.Finmap.lookup! {K : Type} {V : Type} [Inhabited V] (m : Finmap (fun _ : K => V)) (k : K) :=
  (Finmap.lookup k m).getD default

noncomputable abbrev _root_.Finmap.mapsto {K V : Type} (k : K) (v : V) (m : Finmap (fun _ : K => V))
  := Finmap.lookup k m = some v

abbrev _root_.Finmap.is_empty {K V : Type} (m : Finmap (fun _ : K => V)) := m = ∅
abbrev _root_.Finmap.size {K V : Type} (m : Finmap (fun _ : K => V)) := m.keys.card

abbrev _root_.Finset.min'' {α} [Inhabited α] [LinearOrder α] (s : Finset α) : α :=
  match s.min with
  | ⊤        => default
  | .some a  => a

abbrev _root_.Finset.max'' {α} [Inhabited α] [LinearOrder α] (s : Finset α) : α :=
  match s.max with
  | ⊥        => default
  | .some a  => a

abbrev arrayExchange {α} [Inhabited α] (a1 a2 : List α) (i j : Int) : Prop :=
  let i' := i.toNat
  let j' := j.toNat
  a1 = (a2.set i' a1[j']!).set j' (a1[i']!)

abbrev _root_.List.permut_sub {α} (a1 a2 : List α) (l u : ℕ) : Prop :=
  a1.length = a2.length ∧ (0 ≤ l ∧ l ≤ a1.length) ∧ (0 ≤ u ∧ u ≤ a1.length) ∧
  List.Perm (slice a1 l u) (slice a2 l u)

abbrev _root_.List.permut_sub' {α} (a1 a2 : List α) (l u : ℕ) : Prop :=
  a1.length = a2.length ∧ slice a1 0 l = slice a2 0 l ∧
  slice a1 u a1.length = slice a2 u a1.length ∧
  List.Perm (slice a1 l u) (slice a2 l u)

abbrev _root_.List.foldr' {α β} (f : α -> β -> β) (l : List α) (x : β) := List.foldr f x l

abbrev _root_.Int.to_Real (z : ℤ) : ℝ := z

abbrev _root_.List.mem' {α} (eq : α -> α -> Bool) (x : α) (l : List α) := List.all l (eq x)

noncomputable abbrev _root_.Real.truncate (x : ℝ) : ℤ := if 0 ≤ x then Int.floor x  else Int.ceil x

alias _root_.Math.abs := abs

end Lean4Why3

open Classical
open Lean4Why3

namespace Ref
structure ref (α : Type) where
  contents : α
axiom inhabited_axiom_ref {α : Type} [Inhabited α] : Inhabited (ref α)
attribute [instance] inhabited_axiom_ref
end Ref
namespace Const
axiom const :  {β : Type} -> [Inhabited β] ->  {α : Type} -> [Inhabited α] -> β -> α -> β
axiom const'def {β : Type} {α : Type} [Inhabited β] [Inhabited α] (v : β) (x : α) : (const : β -> α -> β) v x = v
end Const
namespace MapEq
noncomputable def map_eq_sub {α : Type} [Inhabited α] (a1 : ℤ -> α) (a2 : ℤ -> α) (l : ℤ) (u : ℤ) := ∀(i : ℤ), l ≤ i ∧ i < u → a1 i = a2 i
end MapEq
namespace Unsigned
axiom t : Type
axiom inhabited_axiom_t : Inhabited t
attribute [instance] inhabited_axiom_t
axiom max : ℤ
axiom to_int : t -> ℤ
noncomputable def in_bounds (n : ℤ) := (0 : ℤ) ≤ n ∧ n ≤ max
axiom to_int_in_bounds (n : t) : in_bounds (to_int n)
axiom extensionality (x : t) (y : t) (fact0 : to_int x = to_int y) : x = y
axiom zero_unsigned : t
axiom zero_unsigned_is_zero : to_int zero_unsigned = (0 : ℤ)
axiom radix : ℤ
axiom radix_def : radix = max + (1 : ℤ)
end Unsigned
namespace C
noncomputable def in_us_bounds (n : ℤ) := (0 : ℤ) ≤ n ∧ n ≤ (4294967295 : ℤ)
noncomputable def in_bounds (n : ℤ) := -(2147483648 : ℤ) ≤ n ∧ n ≤ (2147483647 : ℤ)
axiom zone : Type
axiom inhabited_axiom_zone : Inhabited zone
attribute [instance] inhabited_axiom_zone
axiom null_zone : zone
axiom ptr : Type -> Type
axiom inhabited_axiom_ptr {α : Type} [Inhabited α] : Inhabited (ptr α)
attribute [instance] inhabited_axiom_ptr
axiom data :  {α : Type} -> [Inhabited α] -> ptr α -> List α
axiom offset :  {α : Type} -> [Inhabited α] -> ptr α -> ℤ
axiom min :  {α : Type} -> [Inhabited α] -> ptr α -> ℤ
axiom max :  {α : Type} -> [Inhabited α] -> ptr α -> ℤ
axiom writable :  {α : Type} -> [Inhabited α] -> ptr α -> Bool
axiom zone1 :  {α : Type} -> [Inhabited α] -> ptr α -> zone
noncomputable def plength {α : Type} [Inhabited α] (p : ptr α) := Int.ofNat (List.length (data p))
noncomputable def pelts {α : Type} [Inhabited α] (p : ptr α) := getElem! (data p) ∘ Int.toNat
axiom is_not_null :  {α : Type} -> [Inhabited α] -> ptr α -> Prop
axiom is_not_null'spec {α : Type} [Inhabited α] (p : ptr α) : is_not_null p = (¬zone1 p = null_zone)
noncomputable def valid_ptr_shift {α : Type} [Inhabited α] (p : ptr α) (i : ℤ) := min p ≤ offset p + i ∧ offset p + i < max p
noncomputable def valid {α : Type} [Inhabited α] (p : ptr α) (sz : ℤ) := in_bounds sz ∧ (0 : ℤ) ≤ sz ∧ ((0 : ℤ) ≤ min p ∧ min p ≤ offset p) ∧ offset p + sz ≤ max p ∧ max p ≤ plength p
axiom valid_itv_to_shift {α : Type} [Inhabited α] (p : ptr α) (sz : ℤ) (i : ℤ) (fact0 : valid p sz) (fact1 : (0 : ℤ) ≤ i) (fact2 : i < sz) : valid_ptr_shift p i
end C
namespace Valuation
axiom valuation : ℤ -> ℤ -> ℤ
axiom valuation'def (p : ℤ) (n : ℤ) (fact0 : (1 : ℤ) < p) (fact1 : (1 : ℤ) ≤ n) : if Int.tmod n p = (0 : ℤ) then valuation n p = valuation (Int.tdiv n p) p + (1 : ℤ) else valuation n p = (0 : ℤ)
axiom valuation'spec'0 (p : ℤ) (n : ℤ) (fact0 : (1 : ℤ) < p) (fact1 : (1 : ℤ) ≤ n) : (0 : ℤ) ≤ valuation n p
axiom valuation'spec (p : ℤ) (n : ℤ) (fact0 : (1 : ℤ) < p) (fact1 : (1 : ℤ) ≤ n) : HPow.hPow p (Int.toNat (valuation n p)) ∣  n
end Valuation
namespace Config
end Config
namespace Types
axiom limb : Type
axiom inhabited_axiom_limb : Inhabited limb
attribute [instance] inhabited_axiom_limb
axiom t : Type
axiom inhabited_axiom_t : Inhabited t
attribute [instance] inhabited_axiom_t
end Types
namespace Int32Eq
end Int32Eq
namespace UInt64Eq
end UInt64Eq
namespace Lemmas
noncomputable def map_eq_sub_shift {α : Type} [Inhabited α] (x : ℤ -> α) (y : ℤ -> α) (xi : ℤ) (yi : ℤ) (sz : ℤ) := ∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < sz → x (xi + i) = y (yi + i)
axiom value_sub : (ℤ -> BitVec 64) -> ℤ -> ℤ -> ℤ
axiom value_sub'def (n : ℤ) (m : ℤ) (x : ℤ -> BitVec 64) : if n < m then value_sub x n m = BitVec.toUInt (x n) + ((18446744073709551615 : ℤ) + (1 : ℤ)) * value_sub x (n + (1 : ℤ)) m else value_sub x n m = (0 : ℤ)
noncomputable def value (x : C.ptr (BitVec 64)) (sz : ℤ) := value_sub (C.pelts x) (C.offset x) (C.offset x + sz)
end Lemmas
namespace Compare
noncomputable def compare_int (x : ℤ) (y : ℤ) := if x < y then -(1 : ℤ) else if x = y then (0 : ℤ) else (1 : ℤ)
end Compare
namespace Alias
axiom mem : Type
axiom inhabited_axiom_mem : Inhabited mem
attribute [instance] inhabited_axiom_mem
axiom zr : mem -> C.zone
axiom zx : mem -> C.zone
axiom zy : mem -> C.zone
axiom mr : mem -> BitVec 32
axiom mx : mem -> BitVec 32
axiom my : mem -> BitVec 32
axiom lr : mem -> BitVec 32
axiom lx : mem -> BitVec 32
axiom ly : mem -> BitVec 32
axiom ok : mem -> Bool
noncomputable def identical (p1 : C.ptr (BitVec 64)) (p2 : C.ptr (BitVec 64)) := C.data p1 = C.data p2 ∧ C.offset p1 = C.offset p2 ∧ C.min p1 = C.min p2 ∧ C.max p1 = C.max p2 ∧ C.zone1 p1 = C.zone1 p2
end Alias
namespace Util
end Util
namespace UtilOld
end UtilOld
namespace Add_1
end Add_1
namespace Add
end Add
namespace AddOld
end AddOld
namespace Sub_1
end Sub_1
namespace SubOld
end SubOld
namespace Mul
end Mul
namespace Mul_basecase
end Mul_basecase
namespace LogicalUtil
end LogicalUtil
namespace Logical
end Logical
namespace toom_Toom_wmpn_toom32_mulqtvc
theorem wmpn_toom32_mul'vc (x : C.ptr (BitVec 64)) (sx : BitVec 32) (y : C.ptr (BitVec 64)) (sy : BitVec 32) (r : C.ptr (BitVec 64)) (scratch : C.ptr (BitVec 64)) (k : ℤ) (fact0 : C.valid x (BitVec.toInt sx)) (fact1 : C.valid y (BitVec.toInt sy)) (fact2 : C.valid r (BitVec.toInt sx + BitVec.toInt sy)) (fact3 : C.writable r = true) (fact4 : C.writable scratch = true) (fact5 : BitVec.toInt (29 : BitVec 32) < BitVec.toInt sy) (fact6 : (0 : ℤ) < k) (fact7 : k ≤ (64 : ℤ)) (fact8 : BitVec.toInt sx ≤ BitVec.toInt (29 : BitVec 32) * HPow.hPow (2 : ℤ) (Int.toNat k)) (fact9 : C.valid scratch ((2 : ℤ) * (BitVec.toInt sx + k))) (fact10 : (8 : ℤ) * BitVec.toInt sx < (2147483647 : ℤ)) (fact11 : (4 : ℤ) < BitVec.toInt sy + (2 : ℤ)) (fact12 : BitVec.toInt sy + (2 : ℤ) ≤ BitVec.toInt sx) (fact13 : BitVec.toInt sx + (6 : ℤ) ≤ (3 : ℤ) * BitVec.toInt sy) : int'32_in_bounds ((3 : ℤ) * BitVec.toInt sy) ∧ (∀(o1 : BitVec 32), BitVec.toInt o1 = (3 : ℤ) * BitVec.toInt sy → int'32_in_bounds ((2 : ℤ) * BitVec.toInt sx) ∧ (∀(o2 : BitVec 32), BitVec.toInt o2 = (2 : ℤ) * BitVec.toInt sx → (if BitVec.toInt o1 ≤ BitVec.toInt o2 then int'32_in_bounds (BitVec.toInt sx - (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt sx - (1 : ℤ) → ¬(3 : ℤ) = (0 : ℤ) ∧ int'32_in_bounds (Int.tdiv (BitVec.toInt o3) (3 : ℤ))) else int'32_in_bounds (BitVec.toInt sy - (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt sy - (1 : ℤ) → ¬(2 : ℤ) = (0 : ℤ) ∧ int'32_in_bounds (Int.tdiv (BitVec.toInt o3) (2 : ℤ)))) ∧ (∀(o3 : BitVec 32), (if BitVec.toInt o1 ≤ BitVec.toInt o2 then ∃(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt sx - (1 : ℤ) ∧ BitVec.toInt o3 = Int.tdiv (BitVec.toInt o4) (3 : ℤ) else ∃(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt sy - (1 : ℤ) ∧ BitVec.toInt o3 = Int.tdiv (BitVec.toInt o4) (2 : ℤ)) → int'32_in_bounds ((1 : ℤ) + BitVec.toInt o3) ∧ (∀(n : BitVec 32), BitVec.toInt n = (1 : ℤ) + BitVec.toInt o3 → int'32_in_bounds ((2 : ℤ) * BitVec.toInt n) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = (2 : ℤ) * BitVec.toInt n → int'32_in_bounds (BitVec.toInt sx - BitVec.toInt o4) ∧ (∀(s : BitVec 32), BitVec.toInt s = BitVec.toInt sx - BitVec.toInt o4 → int'32_in_bounds (BitVec.toInt sy - BitVec.toInt n) ∧ (∀(t : BitVec 32), BitVec.toInt t = BitVec.toInt sy - BitVec.toInt n → (C.min x ≤ C.offset x + BitVec.toInt n ∧ C.offset x + BitVec.toInt n ≤ C.max x) ∧ (∀(x1 : C.ptr (BitVec 64)), C.offset x1 = C.offset x + BitVec.toInt n ∧ C.plength x1 = C.plength x ∧ C.pelts x1 = C.pelts x ∧ C.data x1 = C.data x ∧ C.min x1 = C.min x ∧ C.max x1 = C.max x ∧ C.zone1 x1 = C.zone1 x ∧ C.writable x1 = C.writable x → (C.min x1 ≤ C.offset x1 + BitVec.toInt n ∧ C.offset x1 + BitVec.toInt n ≤ C.max x1) ∧ (∀(x2 : C.ptr (BitVec 64)), C.offset x2 = C.offset x1 + BitVec.toInt n ∧ C.plength x2 = C.plength x1 ∧ C.pelts x2 = C.pelts x1 ∧ C.data x2 = C.data x1 ∧ C.min x2 = C.min x1 ∧ C.max x2 = C.max x1 ∧ C.zone1 x2 = C.zone1 x1 ∧ C.writable x2 = C.writable x1 → (C.min y ≤ C.offset y + BitVec.toInt n ∧ C.offset y + BitVec.toInt n ≤ C.max y) ∧ (∀(y1 : C.ptr (BitVec 64)), C.offset y1 = C.offset y + BitVec.toInt n ∧ C.plength y1 = C.plength y ∧ C.pelts y1 = C.pelts y ∧ C.data y1 = C.data y ∧ C.min y1 = C.min y ∧ C.max y1 = C.max y ∧ C.zone1 y1 = C.zone1 y ∧ C.writable y1 = C.writable y → (let a0 : ℤ := Lemmas.value x (BitVec.toInt n); let a1 : ℤ := Lemmas.value x1 (BitVec.toInt n); let a2 : ℤ := Lemmas.value x2 (BitVec.toInt s); let b0 : ℤ := Lemmas.value y (BitVec.toInt n); let b1 : ℤ := Lemmas.value y1 (BitVec.toInt t); let m : ℤ := HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)); ((0 : ℤ) ≤ (0 : ℤ) ∧ (C.min r ≤ C.offset r - (0 : ℤ) ∧ C.offset r - (0 : ℤ) ≤ C.max r) ∧ C.writable r = true) ∧ (∀(r1 : C.ptr (BitVec 64)), C.offset r1 = C.offset r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → (∀(rol : C.ptr (BitVec 64)), C.writable rol = true ∧ C.offset rol = C.offset r1 - (0 : ℤ) ∧ C.min r1 = C.offset r1 - (0 : ℤ) ∧ C.min rol = C.min r ∧ C.max rol = C.offset r1 - (0 : ℤ) ∧ C.zone1 rol = C.zone1 r1 ∧ C.pelts r1 = C.pelts r ∧ C.plength r1 = C.plength r ∧ C.pelts rol = C.pelts r ∧ C.plength rol = C.plength r → int'32_in_bounds (BitVec.toInt sx + BitVec.toInt sy) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt sx + BitVec.toInt sy → ((0 : ℤ) ≤ BitVec.toInt o5 ∧ (C.min r1 ≤ C.offset r1 + BitVec.toInt o5 ∧ C.offset r1 + BitVec.toInt o5 ≤ C.max r1) ∧ C.writable r1 = true) ∧ (∀(r2 : C.ptr (BitVec 64)), C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → (∀(ror : C.ptr (BitVec 64)), C.writable ror = true ∧ C.offset ror = C.offset r2 + BitVec.toInt o5 ∧ C.max r2 = C.offset r2 + BitVec.toInt o5 ∧ C.min ror = C.offset r2 + BitVec.toInt o5 ∧ C.max ror = C.max r1 ∧ C.zone1 ror = C.zone1 r2 ∧ C.pelts r2 = C.pelts r1 ∧ C.plength r2 = C.plength r1 ∧ C.pelts ror = C.pelts r1 ∧ C.plength ror = C.plength r1 → ((0 : ℤ) ≤ (0 : ℤ) ∧ (C.min scratch ≤ C.offset scratch - (0 : ℤ) ∧ C.offset scratch - (0 : ℤ) ≤ C.max scratch) ∧ C.writable scratch = true) ∧ (∀(scratch1 : C.ptr (BitVec 64)), C.offset scratch1 = C.offset scratch ∧ C.max scratch1 = C.max scratch ∧ C.writable scratch1 = C.writable scratch ∧ C.zone1 scratch1 = C.zone1 scratch → (∀(sol : C.ptr (BitVec 64)), C.writable sol = true ∧ C.offset sol = C.offset scratch1 - (0 : ℤ) ∧ C.min scratch1 = C.offset scratch1 - (0 : ℤ) ∧ C.min sol = C.min scratch ∧ C.max sol = C.offset scratch1 - (0 : ℤ) ∧ C.zone1 sol = C.zone1 scratch1 ∧ C.pelts scratch1 = C.pelts scratch ∧ C.plength scratch1 = C.plength scratch ∧ C.pelts sol = C.pelts scratch ∧ C.plength sol = C.plength scratch → int'32_in_bounds (BitVec.toInt n + BitVec.toInt n) ∧ (∀(o6 : BitVec 32), BitVec.toInt o6 = BitVec.toInt n + BitVec.toInt n → int'32_in_bounds (BitVec.toInt o6 + (1 : ℤ)) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt o6 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt o7 ∧ (C.min scratch1 ≤ C.offset scratch1 + BitVec.toInt o7 ∧ C.offset scratch1 + BitVec.toInt o7 ≤ C.max scratch1) ∧ C.writable scratch1 = true) ∧ (∀(scratch2 : C.ptr (BitVec 64)), C.offset scratch2 = C.offset scratch1 ∧ C.min scratch2 = C.min scratch1 ∧ C.writable scratch2 = C.writable scratch1 ∧ C.zone1 scratch2 = C.zone1 scratch1 → (∀(sor : C.ptr (BitVec 64)), C.writable sor = true ∧ C.offset sor = C.offset scratch2 + BitVec.toInt o7 ∧ C.max scratch2 = C.offset scratch2 + BitVec.toInt o7 ∧ C.min sor = C.offset scratch2 + BitVec.toInt o7 ∧ C.max sor = C.max scratch1 ∧ C.zone1 sor = C.zone1 scratch2 ∧ C.pelts scratch2 = C.pelts scratch1 ∧ C.plength scratch2 = C.plength scratch1 ∧ C.pelts sor = C.pelts scratch1 ∧ C.plength sor = C.plength scratch1 → ((0 : ℤ) ≤ BitVec.toInt n ∧ (C.min r2 ≤ C.offset r2 + BitVec.toInt n ∧ C.offset r2 + BitVec.toInt n ≤ C.max r2) ∧ C.writable r2 = true) ∧ (∀(r3 : C.ptr (BitVec 64)), C.offset r3 = C.offset r2 ∧ C.min r3 = C.min r2 ∧ C.writable r3 = C.writable r2 ∧ C.zone1 r3 = C.zone1 r2 → C.offset r3 = C.offset r2 ∧ C.min r3 = C.min r2 ∧ C.writable r3 = C.writable r2 ∧ C.zone1 r3 = C.zone1 r2 → (∀(yp1 : C.ptr (BitVec 64)), C.writable yp1 = true ∧ C.offset yp1 = C.offset r3 + BitVec.toInt n ∧ C.max r3 = C.offset r3 + BitVec.toInt n ∧ C.min yp1 = C.offset r3 + BitVec.toInt n ∧ C.max yp1 = C.max r2 ∧ C.zone1 yp1 = C.zone1 r3 ∧ C.pelts r3 = C.pelts r2 ∧ C.plength r3 = C.plength r2 ∧ C.pelts yp1 = C.pelts r2 ∧ C.plength yp1 = C.plength r2 → ((0 : ℤ) ≤ BitVec.toInt n ∧ (C.min yp1 ≤ C.offset yp1 + BitVec.toInt n ∧ C.offset yp1 + BitVec.toInt n ≤ C.max yp1) ∧ C.writable yp1 = true) ∧ (∀(yp11 : C.ptr (BitVec 64)), C.offset yp11 = C.offset yp1 ∧ C.min yp11 = C.min yp1 ∧ C.writable yp11 = C.writable yp1 ∧ C.zone1 yp11 = C.zone1 yp1 → (∀(xm1 : C.ptr (BitVec 64)), C.writable xm1 = true ∧ C.offset xm1 = C.offset yp11 + BitVec.toInt n ∧ C.max yp11 = C.offset yp11 + BitVec.toInt n ∧ C.min xm1 = C.offset yp11 + BitVec.toInt n ∧ C.max xm1 = C.max yp1 ∧ C.zone1 xm1 = C.zone1 yp11 ∧ C.pelts yp11 = C.pelts yp1 ∧ C.plength yp11 = C.plength yp1 ∧ C.pelts xm1 = C.pelts yp1 ∧ C.plength xm1 = C.plength yp1 → ((0 : ℤ) ≤ BitVec.toInt n ∧ (C.min xm1 ≤ C.offset xm1 + BitVec.toInt n ∧ C.offset xm1 + BitVec.toInt n ≤ C.max xm1) ∧ C.writable xm1 = true) ∧ (∀(xm11 : C.ptr (BitVec 64)), C.offset xm11 = C.offset xm1 ∧ C.min xm11 = C.min xm1 ∧ C.writable xm11 = C.writable xm1 ∧ C.zone1 xm11 = C.zone1 xm1 → (∀(ym1 : C.ptr (BitVec 64)), C.writable ym1 = true ∧ C.offset ym1 = C.offset xm11 + BitVec.toInt n ∧ C.max xm11 = C.offset xm11 + BitVec.toInt n ∧ C.min ym1 = C.offset xm11 + BitVec.toInt n ∧ C.max ym1 = C.max xm1 ∧ C.zone1 ym1 = C.zone1 xm11 ∧ C.pelts xm11 = C.pelts xm1 ∧ C.plength xm11 = C.plength xm1 ∧ C.pelts ym1 = C.pelts xm1 ∧ C.plength ym1 = C.plength xm1 → ((((0 : ℤ) ≤ BitVec.toInt s ∧ BitVec.toInt s ≤ BitVec.toInt n) ∧ C.valid x (BitVec.toInt n) ∧ C.valid x2 (BitVec.toInt s) ∧ C.valid r3 (BitVec.toInt n) ∧ C.writable r3 = true) ∧ (∀(xp1 : C.ptr (BitVec 64)), List.length (C.data xp1) = List.length (C.data r3) ∧ C.offset xp1 = C.offset r3 ∧ C.min xp1 = C.min r3 ∧ C.max xp1 = C.max r3 ∧ C.writable xp1 = C.writable r3 ∧ C.zone1 xp1 = C.zone1 r3 → (∀(o8 : BitVec 64), Lemmas.value xp1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt o8 = Lemmas.value x (BitVec.toInt n) + Lemmas.value x2 (BitVec.toInt s) ∧ (∀(j : ℤ), j < C.offset xp1 ∨ C.offset xp1 + BitVec.toInt n ≤ j → C.pelts xp1 j = C.pelts r3 j) ∧ (0 : ℤ) ≤ BitVec.toUInt o8 ∧ BitVec.toUInt o8 ≤ (1 : ℤ) → (C.valid xp1 (BitVec.toInt n) ∧ C.valid x1 (BitVec.toInt n)) ∧ (∀(cmp : BitVec 32), BitVec.toInt cmp = Compare.compare_int (Lemmas.value xp1 (BitVec.toInt n)) (Lemmas.value x1 (BitVec.toInt n)) → (∀(o9 : Bool), (BitVec.toUInt o8 = BitVec.toUInt (0 : BitVec 64) → o9 = true) ∧ (o9 = true → o8 = (0 : BitVec 64)) → (∀(o10 : Bool), (if o9 = true then o10 = (if BitVec.toInt cmp < (0 : ℤ) then true else false) else o10 = false) → (if o10 = true then (C.valid x1 (BitVec.toInt n) ∧ C.valid xp1 (BitVec.toInt n) ∧ C.valid xm11 (BitVec.toInt n) ∧ C.writable xm11 = true) ∧ (∀(xm12 : C.ptr (BitVec 64)), List.length (C.data xm12) = List.length (C.data xm11) ∧ C.offset xm12 = C.offset xm11 ∧ C.min xm12 = C.min xm11 ∧ C.max xm12 = C.max xm11 ∧ C.writable xm12 = C.writable xm11 ∧ C.zone1 xm12 = C.zone1 xm11 → (∀(b : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ Lemmas.value xm12 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt b = Lemmas.value x1 (BitVec.toInt n) - Lemmas.value xp1 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset xm12 ∨ C.offset xm12 + BitVec.toInt n ≤ j → C.pelts xm12 j = C.pelts xm11 j) → (C.valid xp1 (BitVec.toInt n) ∧ C.valid x1 (BitVec.toInt n) ∧ C.writable xp1 = true) ∧ (∀(xp11 : C.ptr (BitVec 64)), List.length (C.data xp11) = List.length (C.data xp1) ∧ C.offset xp11 = C.offset xp1 ∧ C.min xp11 = C.min xp1 ∧ C.max xp11 = C.max xp1 ∧ C.writable xp11 = C.writable xp1 ∧ C.zone1 xp11 = C.zone1 xp1 → (∀(c : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ Lemmas.value xp11 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt c = Lemmas.value xp1 (BitVec.toInt n) + Lemmas.value x1 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset xp11 ∨ C.offset xp11 + BitVec.toInt n ≤ j → C.pelts xp11 j = C.pelts xp1 j) → uint'64_in_bounds (BitVec.toUInt o8 + BitVec.toUInt c) ∧ (∀(o11 : BitVec 64), BitVec.toUInt o11 = BitVec.toUInt o8 + BitVec.toUInt c → Lemmas.value xp11 (BitVec.toInt n) + m * BitVec.toUInt o11 = a0 + a1 + a2 ∧ (Lemmas.value xm12 (BitVec.toInt n) + m * BitVec.toUInt (0 : BitVec 64) = a1 - (a0 + a2) ∨ ¬True ∧ Lemmas.value xm12 (BitVec.toInt n) + m * BitVec.toUInt (0 : BitVec 64) = a0 - a1 + a2) ∧ ((0 : ℤ) ≤ BitVec.toUInt o11 ∧ BitVec.toUInt o11 ≤ (2 : ℤ)) ∧ (0 : ℤ) ≤ BitVec.toUInt (0 : BitVec 64) ∧ BitVec.toUInt (0 : BitVec 64) ≤ (1 : ℤ)))))) else (C.valid xp1 (BitVec.toInt n) ∧ C.valid x1 (BitVec.toInt n) ∧ C.valid xm11 (BitVec.toInt n) ∧ C.writable xm11 = true) ∧ (∀(xm12 : C.ptr (BitVec 64)), List.length (C.data xm12) = List.length (C.data xm11) ∧ C.offset xm12 = C.offset xm11 ∧ C.min xm12 = C.min xm11 ∧ C.max xm12 = C.max xm11 ∧ C.writable xm12 = C.writable xm11 ∧ C.zone1 xm12 = C.zone1 xm11 → (∀(b : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ Lemmas.value xm12 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt b = Lemmas.value xp1 (BitVec.toInt n) - Lemmas.value x1 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset xm12 ∨ C.offset xm12 + BitVec.toInt n ≤ j → C.pelts xm12 j = C.pelts xm11 j) → uint'64_in_bounds (BitVec.toUInt o8 - BitVec.toUInt b) ∧ (∀(o11 : BitVec 64), BitVec.toUInt o11 = BitVec.toUInt o8 - BitVec.toUInt b → (C.valid xp1 (BitVec.toInt n) ∧ C.valid x1 (BitVec.toInt n) ∧ C.writable xp1 = true) ∧ (∀(xp11 : C.ptr (BitVec 64)), List.length (C.data xp11) = List.length (C.data xp1) ∧ C.offset xp11 = C.offset xp1 ∧ C.min xp11 = C.min xp1 ∧ C.max xp11 = C.max xp1 ∧ C.writable xp11 = C.writable xp1 ∧ C.zone1 xp11 = C.zone1 xp1 → (∀(c : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ Lemmas.value xp11 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt c = Lemmas.value xp1 (BitVec.toInt n) + Lemmas.value x1 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset xp11 ∨ C.offset xp11 + BitVec.toInt n ≤ j → C.pelts xp11 j = C.pelts xp1 j) → uint'64_in_bounds (BitVec.toUInt o8 + BitVec.toUInt c) ∧ (∀(o12 : BitVec 64), BitVec.toUInt o12 = BitVec.toUInt o8 + BitVec.toUInt c → Lemmas.value xp11 (BitVec.toInt n) + m * BitVec.toUInt o12 = a0 + a1 + a2 ∧ Lemmas.value xm12 (BitVec.toInt n) + m * BitVec.toUInt o11 = a0 - a1 + a2 ∧ ((0 : ℤ) ≤ BitVec.toUInt o12 ∧ BitVec.toUInt o12 ≤ (2 : ℤ)) ∧ (0 : ℤ) ≤ BitVec.toUInt o11 ∧ BitVec.toUInt o11 ≤ (1 : ℤ)))))))))))))) ∧ (∀(vm1_neg : Bool) (hi : BitVec 64) (xp1_hi : BitVec 64) (xm12 : C.ptr (BitVec 64)) (r4 : C.ptr (BitVec 64)), List.length (C.data r4) = List.length (C.data r3) ∧ C.offset r4 = C.offset r3 ∧ C.min r4 = C.min r3 ∧ C.max r4 = C.max r3 ∧ C.writable r4 = C.writable r3 ∧ C.zone1 r4 = C.zone1 r3 → List.length (C.data xm12) = List.length (C.data xm11) ∧ C.offset xm12 = C.offset xm11 ∧ C.min xm12 = C.min xm11 ∧ C.max xm12 = C.max xm11 ∧ C.writable xm12 = C.writable xm11 ∧ C.zone1 xm12 = C.zone1 xm11 → List.length (C.data r4) = List.length (C.data r3) ∧ C.offset r4 = C.offset r3 ∧ C.min r4 = C.min r3 ∧ C.max r4 = C.max r3 ∧ C.writable r4 = C.writable r3 ∧ C.zone1 r4 = C.zone1 r3 → List.length (C.data r4) = List.length (C.data r3) ∧ C.offset r4 = C.offset r3 ∧ C.min r4 = C.min r3 ∧ C.max r4 = C.max r3 ∧ C.writable r4 = C.writable r3 ∧ C.zone1 r4 = C.zone1 r3 → Lemmas.value r4 (BitVec.toInt n) + m * BitVec.toUInt xp1_hi = a0 + a1 + a2 ∧ (vm1_neg = true ∧ Lemmas.value xm12 (BitVec.toInt n) + m * BitVec.toUInt hi = a1 - (a0 + a2) ∨ ¬vm1_neg = true ∧ Lemmas.value xm12 (BitVec.toInt n) + m * BitVec.toUInt hi = a0 - a1 + a2) ∧ ((0 : ℤ) ≤ BitVec.toUInt xp1_hi ∧ BitVec.toUInt xp1_hi ≤ (2 : ℤ)) ∧ (0 : ℤ) ≤ BitVec.toUInt hi ∧ BitVec.toUInt hi ≤ (1 : ℤ) → (∀(o8 : Bool), (BitVec.toInt t = BitVec.toInt n → o8 = true) ∧ (o8 = true → t = n) → (if o8 = true then (C.valid y (BitVec.toInt n) ∧ C.valid y1 (BitVec.toInt n) ∧ C.valid yp11 (BitVec.toInt n) ∧ C.writable yp11 = true) ∧ (∀(yp12 : C.ptr (BitVec 64)), List.length (C.data yp12) = List.length (C.data yp11) ∧ C.offset yp12 = C.offset yp11 ∧ C.min yp12 = C.min yp11 ∧ C.max yp12 = C.max yp11 ∧ C.writable yp12 = C.writable yp11 ∧ C.zone1 yp12 = C.zone1 yp11 → (∀(o9 : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt o9 ∧ BitVec.toUInt o9 ≤ (1 : ℤ)) ∧ Lemmas.value yp12 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt o9 = Lemmas.value y (BitVec.toInt n) + Lemmas.value y1 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset yp12 ∨ C.offset yp12 + BitVec.toInt n ≤ j → C.pelts yp12 j = C.pelts yp11 j) → (C.valid y (BitVec.toInt n) ∧ C.valid y1 (BitVec.toInt n)) ∧ (∀(cmp : BitVec 32), BitVec.toInt cmp = Compare.compare_int (Lemmas.value y (BitVec.toInt n)) (Lemmas.value y1 (BitVec.toInt n)) → (if BitVec.toInt cmp < (0 : ℤ) then (C.valid y1 (BitVec.toInt n) ∧ C.valid y (BitVec.toInt n) ∧ C.valid ym1 (BitVec.toInt n) ∧ C.writable ym1 = true) ∧ (∀(ym11 : C.ptr (BitVec 64)), List.length (C.data ym11) = List.length (C.data ym1) ∧ C.offset ym11 = C.offset ym1 ∧ C.min ym11 = C.min ym1 ∧ C.max ym11 = C.max ym1 ∧ C.writable ym11 = C.writable ym1 ∧ C.zone1 ym11 = C.zone1 ym1 → (∀(b : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ Lemmas.value ym11 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt b = Lemmas.value y1 (BitVec.toInt n) - Lemmas.value y (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset ym11 ∨ C.offset ym11 + BitVec.toInt n ≤ j → C.pelts ym11 j = C.pelts ym1 j) → Lemmas.value yp12 (BitVec.toInt n) + m * BitVec.toUInt o9 = b0 + b1 ∧ ((if vm1_neg = true then false else true) = vm1_neg ∧ Lemmas.value ym11 (BitVec.toInt n) = b0 - b1 ∨ ((if vm1_neg = true then false else true) = true) = (¬vm1_neg = true) ∧ Lemmas.value ym11 (BitVec.toInt n) = b1 - b0) ∧ (0 : ℤ) ≤ BitVec.toUInt o9 ∧ BitVec.toUInt o9 ≤ (1 : ℤ))) else (C.valid y (BitVec.toInt n) ∧ C.valid y1 (BitVec.toInt n) ∧ C.valid ym1 (BitVec.toInt n) ∧ C.writable ym1 = true) ∧ (∀(ym11 : C.ptr (BitVec 64)), List.length (C.data ym11) = List.length (C.data ym1) ∧ C.offset ym11 = C.offset ym1 ∧ C.min ym11 = C.min ym1 ∧ C.max ym11 = C.max ym1 ∧ C.writable ym11 = C.writable ym1 ∧ C.zone1 ym11 = C.zone1 ym1 → (∀(b : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ Lemmas.value ym11 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt b = Lemmas.value y (BitVec.toInt n) - Lemmas.value y1 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset ym11 ∨ C.offset ym11 + BitVec.toInt n ≤ j → C.pelts ym11 j = C.pelts ym1 j) → Lemmas.value yp12 (BitVec.toInt n) + m * BitVec.toUInt o9 = b0 + b1 ∧ (Lemmas.value ym11 (BitVec.toInt n) = b0 - b1 ∨ (vm1_neg = true) = (¬vm1_neg = true) ∧ Lemmas.value ym11 (BitVec.toInt n) = b1 - b0) ∧ (0 : ℤ) ≤ BitVec.toUInt o9 ∧ BitVec.toUInt o9 ≤ (1 : ℤ))))))) else (((0 : ℤ) ≤ BitVec.toInt t ∧ BitVec.toInt t ≤ BitVec.toInt n) ∧ C.valid y (BitVec.toInt n) ∧ C.valid y1 (BitVec.toInt t) ∧ C.valid yp11 (BitVec.toInt n) ∧ C.writable yp11 = true) ∧ (∀(yp12 : C.ptr (BitVec 64)), List.length (C.data yp12) = List.length (C.data yp11) ∧ C.offset yp12 = C.offset yp11 ∧ C.min yp12 = C.min yp11 ∧ C.max yp12 = C.max yp11 ∧ C.writable yp12 = C.writable yp11 ∧ C.zone1 yp12 = C.zone1 yp11 → (∀(o9 : BitVec 64), Lemmas.value yp12 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt o9 = Lemmas.value y (BitVec.toInt n) + Lemmas.value y1 (BitVec.toInt t) ∧ (∀(j : ℤ), j < C.offset yp12 ∨ C.offset yp12 + BitVec.toInt n ≤ j → C.pelts yp12 j = C.pelts yp11 j) ∧ (0 : ℤ) ≤ BitVec.toUInt o9 ∧ BitVec.toUInt o9 ≤ (1 : ℤ) → (C.min y ≤ C.offset y + BitVec.toInt t ∧ C.offset y + BitVec.toInt t ≤ C.max y) ∧ (∀(y0t : C.ptr (BitVec 64)), C.offset y0t = C.offset y + BitVec.toInt t ∧ C.plength y0t = C.plength y ∧ C.pelts y0t = C.pelts y ∧ C.data y0t = C.data y ∧ C.min y0t = C.min y ∧ C.max y0t = C.max y ∧ C.zone1 y0t = C.zone1 y ∧ C.writable y0t = C.writable y → int'32_in_bounds (BitVec.toInt n - BitVec.toInt t) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = BitVec.toInt n - BitVec.toInt t → C.valid y0t (BitVec.toInt o10) ∧ (∀(o11 : BitVec 32), ((0 : ℤ) ≤ BitVec.toInt o11 ∧ BitVec.toInt o11 ≤ (1 : ℤ)) ∧ (BitVec.toInt o11 = (1 : ℤ)) = (Lemmas.value y0t (BitVec.toInt o10) = (0 : ℤ)) → (∀(c0 : Bool), (BitVec.toInt o11 = BitVec.toInt (1 : BitVec 32) → c0 = true) ∧ (c0 = true → o11 = (1 : BitVec 32)) → (C.valid y (BitVec.toInt t) ∧ C.valid y1 (BitVec.toInt t)) ∧ (∀(cmp : BitVec 32), BitVec.toInt cmp = Compare.compare_int (Lemmas.value y (BitVec.toInt t)) (Lemmas.value y1 (BitVec.toInt t)) → (if c0 = true ∧ BitVec.toInt cmp < (0 : ℤ) then (C.valid y1 (BitVec.toInt t) ∧ C.valid y (BitVec.toInt t) ∧ C.valid ym1 (BitVec.toInt t) ∧ C.writable ym1 = true) ∧ (∀(ym11 : C.ptr (BitVec 64)), List.length (C.data ym11) = List.length (C.data ym1) ∧ C.offset ym11 = C.offset ym1 ∧ C.min ym11 = C.min ym1 ∧ C.max ym11 = C.max ym1 ∧ C.writable ym11 = C.writable ym1 ∧ C.zone1 ym11 = C.zone1 ym1 → (∀(b : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ Lemmas.value ym11 (BitVec.toInt t) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt t)) * BitVec.toUInt b = Lemmas.value y1 (BitVec.toInt t) - Lemmas.value y (BitVec.toInt t) ∧ (∀(j : ℤ), j < C.offset ym11 ∨ C.offset ym11 + BitVec.toInt t ≤ j → C.pelts ym11 j = C.pelts ym1 j) → (C.min ym11 ≤ C.offset ym11 + BitVec.toInt t ∧ C.offset ym11 + BitVec.toInt t ≤ C.max ym11) ∧ (∀(ym1t : C.ptr (BitVec 64)), C.offset ym1t = C.offset ym11 + BitVec.toInt t ∧ C.plength ym1t = C.plength ym11 ∧ C.pelts ym1t = C.pelts ym11 ∧ C.data ym1t = C.data ym11 ∧ C.min ym1t = C.min ym11 ∧ C.max ym1t = C.max ym11 ∧ C.zone1 ym1t = C.zone1 ym11 ∧ C.writable ym1t = C.writable ym11 → int'32_in_bounds (BitVec.toInt n - BitVec.toInt t) ∧ (∀(o12 : BitVec 32), BitVec.toInt o12 = BitVec.toInt n - BitVec.toInt t → (C.valid ym1t (BitVec.toInt o12) ∧ C.writable ym1t = true) ∧ (∀(ym1t1 : C.ptr (BitVec 64)) (ym12 : C.ptr (BitVec 64)), C.data ym1t1 = C.data ym12 ∧ List.length (C.data ym12) = List.length (C.data ym1t) ∧ C.offset ym1t1 = C.offset ym1t ∧ C.min ym1t1 = C.min ym1t ∧ C.max ym1t1 = C.max ym1t ∧ C.writable ym1t1 = C.writable ym1t ∧ C.zone1 ym1t1 = C.zone1 ym1t → List.length (C.data ym12) = List.length (C.data ym11) ∧ C.offset ym12 = C.offset ym11 ∧ C.min ym12 = C.min ym11 ∧ C.max ym12 = C.max ym11 ∧ C.writable ym12 = C.writable ym11 ∧ C.zone1 ym12 = C.zone1 ym11 → Lemmas.value ym1t1 (BitVec.toInt o12) = (0 : ℤ) ∧ (∀(j : ℤ), j < C.offset ym1t1 ∨ C.offset ym1t1 + BitVec.toInt o12 ≤ j → C.pelts ym1t1 j = C.pelts ym1t j) → Lemmas.value yp12 (BitVec.toInt n) + m * BitVec.toUInt o9 = b0 + b1 ∧ ((if vm1_neg = true then false else true) = vm1_neg ∧ Lemmas.value ym12 (BitVec.toInt n) = b0 - b1 ∨ ((if vm1_neg = true then false else true) = true) = (¬vm1_neg = true) ∧ Lemmas.value ym12 (BitVec.toInt n) = b1 - b0) ∧ (0 : ℤ) ≤ BitVec.toUInt o9 ∧ BitVec.toUInt o9 ≤ (1 : ℤ)))))) else (((0 : ℤ) ≤ BitVec.toInt t ∧ BitVec.toInt t ≤ BitVec.toInt n) ∧ C.valid y (BitVec.toInt n) ∧ C.valid y1 (BitVec.toInt t) ∧ C.valid ym1 (BitVec.toInt n) ∧ C.writable ym1 = true) ∧ (∀(ym11 : C.ptr (BitVec 64)), List.length (C.data ym11) = List.length (C.data ym1) ∧ C.offset ym11 = C.offset ym1 ∧ C.min ym11 = C.min ym1 ∧ C.max ym11 = C.max ym1 ∧ C.writable ym11 = C.writable ym1 ∧ C.zone1 ym11 = C.zone1 ym1 → (∀(b : BitVec 64), Lemmas.value ym11 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt b = Lemmas.value y (BitVec.toInt n) - Lemmas.value y1 (BitVec.toInt t) ∧ (∀(j : ℤ), j < C.offset ym11 ∨ C.offset ym11 + BitVec.toInt n ≤ j → C.pelts ym11 j = C.pelts ym1 j) ∧ (0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ) → Lemmas.value yp12 (BitVec.toInt n) + m * BitVec.toUInt o9 = b0 + b1 ∧ (Lemmas.value ym11 (BitVec.toInt n) = b0 - b1 ∨ (vm1_neg = true) = (¬vm1_neg = true) ∧ Lemmas.value ym11 (BitVec.toInt n) = b1 - b0) ∧ (0 : ℤ) ≤ BitVec.toUInt o9 ∧ BitVec.toUInt o9 ≤ (1 : ℤ))))))))))))) ∧ (∀(vm1_neg1 : Bool) (yp1_hi : BitVec 64) (ym11 : C.ptr (BitVec 64)) (yp12 : C.ptr (BitVec 64)), List.length (C.data ym11) = List.length (C.data ym1) ∧ C.offset ym11 = C.offset ym1 ∧ C.min ym11 = C.min ym1 ∧ C.max ym11 = C.max ym1 ∧ C.writable ym11 = C.writable ym1 ∧ C.zone1 ym11 = C.zone1 ym1 → List.length (C.data yp12) = List.length (C.data yp11) ∧ C.offset yp12 = C.offset yp11 ∧ C.min yp12 = C.min yp11 ∧ C.max yp12 = C.max yp11 ∧ C.writable yp12 = C.writable yp11 ∧ C.zone1 yp12 = C.zone1 yp11 → Lemmas.value yp12 (BitVec.toInt n) + m * BitVec.toUInt yp1_hi = b0 + b1 ∧ (vm1_neg1 = vm1_neg ∧ Lemmas.value ym11 (BitVec.toInt n) = b0 - b1 ∨ (vm1_neg1 = true) = (¬vm1_neg = true) ∧ Lemmas.value ym11 (BitVec.toInt n) = b1 - b0) ∧ (0 : ℤ) ≤ BitVec.toUInt yp1_hi ∧ BitVec.toUInt yp1_hi ≤ (1 : ℤ) → (let am1_abs : ℤ := Lemmas.value xm12 (BitVec.toInt n) + m * BitVec.toUInt hi; let bm1_abs : ℤ := Lemmas.value ym11 (BitVec.toInt n); let o8 : ℤ := k - (1 : ℤ); (((0 : ℤ) ≤ k + k ∧ o8 + o8 + (1 : ℤ) < k + k) ∧ C.valid r4 (BitVec.toInt n) ∧ C.valid yp12 (BitVec.toInt n) ∧ C.valid scratch2 (BitVec.toInt n + BitVec.toInt n) ∧ (C.writable scratch2 = true ∧ C.writable sor = true) ∧ (0 : ℤ) < BitVec.toInt n ∧ (8 : ℤ) * BitVec.toInt n < (2147483647 : ℤ) ∧ ((0 : ℤ) ≤ o8 ∧ o8 ≤ (64 : ℤ)) ∧ BitVec.toInt n ≤ BitVec.toInt (29 : BitVec 32) * HPow.hPow (2 : ℤ) (Int.toNat o8) ∧ C.valid sor ((2 : ℤ) * (BitVec.toInt n + o8))) ∧ (∀(sor1 : C.ptr (BitVec 64)) (scratch3 : C.ptr (BitVec 64)), C.offset scratch3 = C.offset scratch2 ∧ C.writable scratch3 = C.writable scratch2 ∧ C.zone1 scratch3 = C.zone1 scratch2 → C.offset sor1 = C.offset sor ∧ C.writable sor1 = C.writable sor ∧ C.zone1 sor1 = C.zone1 sor → C.offset scratch3 = C.offset scratch2 ∧ C.writable scratch3 = C.writable scratch2 ∧ C.zone1 scratch3 = C.zone1 scratch2 → Lemmas.value scratch3 (BitVec.toInt n + BitVec.toInt n) = Lemmas.value r4 (BitVec.toInt n) * Lemmas.value yp12 (BitVec.toInt n) ∧ (∀(j : ℤ), C.min scratch3 ≤ j ∧ j < C.offset scratch3 ∨ C.offset scratch3 + BitVec.toInt n + BitVec.toInt n ≤ j ∧ j < C.max scratch3 → C.pelts scratch3 j = C.pelts scratch2 j) ∧ (∀(j : ℤ), C.min sor1 ≤ j ∧ j < C.offset sor1 → C.pelts sor1 j = C.pelts sor j) ∧ C.min scratch3 = C.min scratch2 ∧ C.max scratch3 = C.max scratch2 ∧ C.plength scratch3 = C.plength scratch2 ∧ C.min sor1 = C.min sor ∧ C.max sor1 = C.max sor ∧ C.plength sor1 = C.plength sor → ((∀(o9 : Bool), (BitVec.toUInt xp1_hi = BitVec.toUInt (1 : BitVec 64) → o9 = true) ∧ (o9 = true → xp1_hi = (1 : BitVec 64)) → (if o9 = true then (C.min scratch3 ≤ C.offset scratch3 + BitVec.toInt n ∧ C.offset scratch3 + BitVec.toInt n ≤ C.max scratch3) ∧ (∀(sn : C.ptr (BitVec 64)), C.offset sn = C.offset scratch3 + BitVec.toInt n ∧ C.plength sn = C.plength scratch3 ∧ C.pelts sn = C.pelts scratch3 ∧ C.data sn = C.data scratch3 ∧ C.min sn = C.min scratch3 ∧ C.max sn = C.max scratch3 ∧ C.zone1 sn = C.zone1 scratch3 ∧ C.writable sn = C.writable scratch3 → (C.valid sn (BitVec.toInt n) ∧ C.valid yp12 (BitVec.toInt n) ∧ C.writable sn = true) ∧ (∀(sn1 : C.ptr (BitVec 64)) (scratch4 : C.ptr (BitVec 64)), C.data sn1 = C.data scratch4 ∧ List.length (C.data scratch4) = List.length (C.data sn) ∧ C.offset sn1 = C.offset sn ∧ C.min sn1 = C.min sn ∧ C.max sn1 = C.max sn ∧ C.writable sn1 = C.writable sn ∧ C.zone1 sn1 = C.zone1 sn → List.length (C.data scratch4) = List.length (C.data scratch3) ∧ C.offset scratch4 = C.offset scratch3 ∧ C.min scratch4 = C.min scratch3 ∧ C.max scratch4 = C.max scratch3 ∧ C.writable scratch4 = C.writable scratch3 ∧ C.zone1 scratch4 = C.zone1 scratch3 → (∀(c : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ Lemmas.value sn1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt c = Lemmas.value sn (BitVec.toInt n) + Lemmas.value yp12 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset sn1 ∨ C.offset sn1 + BitVec.toInt n ≤ j → C.pelts sn1 j = C.pelts sn j) → Lemmas.value scratch4 (BitVec.toInt n + BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt n)) * BitVec.toUInt c = (a0 + a1 + a2) * Lemmas.value yp12 (BitVec.toInt n) ∧ (0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (3 : ℤ)))) else ∀(o10 : Bool), (BitVec.toUInt xp1_hi = BitVec.toUInt (2 : BitVec 64) → o10 = true) ∧ (o10 = true → xp1_hi = (2 : BitVec 64)) → (if o10 = true then (C.min scratch3 ≤ C.offset scratch3 + BitVec.toInt n ∧ C.offset scratch3 + BitVec.toInt n ≤ C.max scratch3) ∧ (∀(sn : C.ptr (BitVec 64)), C.offset sn = C.offset scratch3 + BitVec.toInt n ∧ C.plength sn = C.plength scratch3 ∧ C.pelts sn = C.pelts scratch3 ∧ C.data sn = C.data scratch3 ∧ C.min sn = C.min scratch3 ∧ C.max sn = C.max scratch3 ∧ C.zone1 sn = C.zone1 scratch3 ∧ C.writable sn = C.writable scratch3 → (C.valid yp12 (BitVec.toInt n) ∧ C.valid sn (BitVec.toInt n) ∧ C.writable sn = true) ∧ (∀(sn1 : C.ptr (BitVec 64)) (scratch4 : C.ptr (BitVec 64)), C.data sn1 = C.data scratch4 ∧ List.length (C.data scratch4) = List.length (C.data sn) ∧ C.offset sn1 = C.offset sn ∧ C.min sn1 = C.min sn ∧ C.max sn1 = C.max sn ∧ C.writable sn1 = C.writable sn ∧ C.zone1 sn1 = C.zone1 sn → List.length (C.data scratch4) = List.length (C.data scratch3) ∧ C.offset scratch4 = C.offset scratch3 ∧ C.min scratch4 = C.min scratch3 ∧ C.max scratch4 = C.max scratch3 ∧ C.writable scratch4 = C.writable scratch3 ∧ C.zone1 scratch4 = C.zone1 scratch3 → (∀(c : BitVec 64), Lemmas.value sn1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt c = Lemmas.value sn (BitVec.toInt n) + Lemmas.value yp12 (BitVec.toInt n) * (2 : ℤ) ∧ (∀(j : ℤ), j < C.offset sn1 ∨ C.offset sn1 + BitVec.toInt n ≤ j → C.pelts sn1 j = C.pelts sn j) → Lemmas.value scratch4 (BitVec.toInt n + BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt n)) * BitVec.toUInt c = (a0 + a1 + a2) * Lemmas.value yp12 (BitVec.toInt n) ∧ (0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (3 : ℤ)))) else Lemmas.value scratch3 (BitVec.toInt n + BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt n)) * (0 : ℤ) = (a0 + a1 + a2) * Lemmas.value yp12 (BitVec.toInt n) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (3 : ℤ)))) ∧ (∀(cy : BitVec 64) (scratch4 : C.ptr (BitVec 64)), List.length (C.data scratch4) = List.length (C.data scratch3) ∧ C.offset scratch4 = C.offset scratch3 ∧ C.min scratch4 = C.min scratch3 ∧ C.max scratch4 = C.max scratch3 ∧ C.writable scratch4 = C.writable scratch3 ∧ C.zone1 scratch4 = C.zone1 scratch3 → Lemmas.value scratch4 (BitVec.toInt n + BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt n)) * BitVec.toUInt cy = (a0 + a1 + a2) * Lemmas.value yp12 (BitVec.toInt n) ∧ (0 : ℤ) ≤ BitVec.toUInt cy ∧ BitVec.toUInt cy ≤ (3 : ℤ) → (∀(o9 : Bool), (BitVec.toUInt yp1_hi = BitVec.toUInt (0 : BitVec 64) → o9 = true) ∧ (o9 = true → yp1_hi = (0 : BitVec 64)) → (if ¬o9 = true then (C.min scratch4 ≤ C.offset scratch4 + BitVec.toInt n ∧ C.offset scratch4 + BitVec.toInt n ≤ C.max scratch4) ∧ (∀(sn : C.ptr (BitVec 64)), C.offset sn = C.offset scratch4 + BitVec.toInt n ∧ C.plength sn = C.plength scratch4 ∧ C.pelts sn = C.pelts scratch4 ∧ C.data sn = C.data scratch4 ∧ C.min sn = C.min scratch4 ∧ C.max sn = C.max scratch4 ∧ C.zone1 sn = C.zone1 scratch4 ∧ C.writable sn = C.writable scratch4 → (C.valid sn (BitVec.toInt n) ∧ C.valid r4 (BitVec.toInt n) ∧ C.writable sn = true) ∧ (∀(sn1 : C.ptr (BitVec 64)) (scratch5 : C.ptr (BitVec 64)), C.data sn1 = C.data scratch5 ∧ List.length (C.data scratch5) = List.length (C.data sn) ∧ C.offset sn1 = C.offset sn ∧ C.min sn1 = C.min sn ∧ C.max sn1 = C.max sn ∧ C.writable sn1 = C.writable sn ∧ C.zone1 sn1 = C.zone1 sn → List.length (C.data scratch5) = List.length (C.data scratch4) ∧ C.offset scratch5 = C.offset scratch4 ∧ C.min scratch5 = C.min scratch4 ∧ C.max scratch5 = C.max scratch4 ∧ C.writable scratch5 = C.writable scratch4 ∧ C.zone1 scratch5 = C.zone1 scratch4 → (∀(c : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ Lemmas.value sn1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt c = Lemmas.value sn (BitVec.toInt n) + Lemmas.value r4 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset sn1 ∨ C.offset sn1 + BitVec.toInt n ≤ j → C.pelts sn1 j = C.pelts sn j) → uint'64_in_bounds (BitVec.toUInt xp1_hi * BitVec.toUInt yp1_hi) ∧ (∀(o10 : BitVec 64), BitVec.toUInt o10 = BitVec.toUInt xp1_hi * BitVec.toUInt yp1_hi → uint'64_in_bounds (BitVec.toUInt o10 + BitVec.toUInt c) ∧ (∀(o11 : BitVec 64), BitVec.toUInt o11 = BitVec.toUInt o10 + BitVec.toUInt c → uint'64_in_bounds (BitVec.toUInt o11 + BitVec.toUInt cy) ∧ (∀(o12 : BitVec 64), BitVec.toUInt o12 = BitVec.toUInt o11 + BitVec.toUInt cy → Lemmas.value scratch5 (BitVec.toInt n + BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt n)) * BitVec.toUInt o12 = (a0 + a1 + a2) * (b0 + b1))))))) else Lemmas.value scratch4 (BitVec.toInt n + BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt n)) * BitVec.toUInt cy = (a0 + a1 + a2) * (b0 + b1))) ∧ (∀(cy1 : BitVec 64) (scratch5 : C.ptr (BitVec 64)), List.length (C.data scratch5) = List.length (C.data scratch4) ∧ C.offset scratch5 = C.offset scratch4 ∧ C.min scratch5 = C.min scratch4 ∧ C.max scratch5 = C.max scratch4 ∧ C.writable scratch5 = C.writable scratch4 ∧ C.zone1 scratch5 = C.zone1 scratch4 → Lemmas.value scratch5 (BitVec.toInt n + BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt n)) * BitVec.toUInt cy1 = (a0 + a1 + a2) * (b0 + b1) → Lemmas.value scratch5 ((2 : ℤ) * BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt n)) * BitVec.toUInt cy1 = (a0 + a1 + a2) * (b0 + b1)))) ∧ (∀(cy : BitVec 64) (scratch4 : C.ptr (BitVec 64)), List.length (C.data scratch4) = List.length (C.data scratch3) ∧ C.offset scratch4 = C.offset scratch3 ∧ C.min scratch4 = C.min scratch3 ∧ C.max scratch4 = C.max scratch3 ∧ C.writable scratch4 = C.writable scratch3 ∧ C.zone1 scratch4 = C.zone1 scratch3 → Lemmas.value scratch4 ((2 : ℤ) * BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n + BitVec.toInt n)) * BitVec.toUInt cy = (a0 + a1 + a2) * (b0 + b1) → (C.zone1 r4 = C.zone1 yp12 ∧ C.max r4 = C.min yp12 ∧ C.writable r4 = true ∧ C.writable yp12 = true) ∧ (∀(r5 : C.ptr (BitVec 64)), List.length (C.data r5) = List.length (C.data r4) ∧ C.offset r5 = C.offset r4 ∧ C.min r5 = C.min r4 ∧ C.writable r5 = C.writable r4 ∧ C.zone1 r5 = C.zone1 r4 → List.length (C.data r5) = List.length (C.data r4) ∧ C.offset r5 = C.offset r4 ∧ C.min r5 = C.min r4 ∧ C.writable r5 = C.writable r4 ∧ C.zone1 r5 = C.zone1 r4 → C.max r5 = C.max yp12 ∧ C.plength r5 = C.plength r4 ∧ (∀(i : ℤ), C.min r4 ≤ i ∧ i < C.max r4 → C.pelts r5 i = C.pelts r4 i) ∧ (∀(i : ℤ), C.min yp12 ≤ i ∧ i < C.max yp12 → C.pelts r5 i = C.pelts yp12 i) → (let o9 : ℤ := k - (1 : ℤ); (((0 : ℤ) ≤ k + k ∧ o9 + o9 + (1 : ℤ) < k + k) ∧ C.valid xm12 (BitVec.toInt n) ∧ C.valid ym11 (BitVec.toInt n) ∧ C.valid r5 (BitVec.toInt n + BitVec.toInt n) ∧ (C.writable r5 = true ∧ C.writable sor1 = true) ∧ (0 : ℤ) < BitVec.toInt n ∧ (8 : ℤ) * BitVec.toInt n < (2147483647 : ℤ) ∧ ((0 : ℤ) ≤ o9 ∧ o9 ≤ (64 : ℤ)) ∧ BitVec.toInt n ≤ BitVec.toInt (29 : BitVec 32) * HPow.hPow (2 : ℤ) (Int.toNat o9) ∧ C.valid sor1 ((2 : ℤ) * (BitVec.toInt n + o9))) ∧ (∀(sor2 : C.ptr (BitVec 64)) (r6 : C.ptr (BitVec 64)), C.offset r6 = C.offset r5 ∧ C.writable r6 = C.writable r5 ∧ C.zone1 r6 = C.zone1 r5 → C.offset sor2 = C.offset sor1 ∧ C.writable sor2 = C.writable sor1 ∧ C.zone1 sor2 = C.zone1 sor1 → C.offset r6 = C.offset r5 ∧ C.writable r6 = C.writable r5 ∧ C.zone1 r6 = C.zone1 r5 → Lemmas.value r6 (BitVec.toInt n + BitVec.toInt n) = Lemmas.value xm12 (BitVec.toInt n) * Lemmas.value ym11 (BitVec.toInt n) ∧ (∀(j : ℤ), C.min r6 ≤ j ∧ j < C.offset r6 ∨ C.offset r6 + BitVec.toInt n + BitVec.toInt n ≤ j ∧ j < C.max r6 → C.pelts r6 j = C.pelts r5 j) ∧ (∀(j : ℤ), C.min sor2 ≤ j ∧ j < C.offset sor2 → C.pelts sor2 j = C.pelts sor1 j) ∧ C.min r6 = C.min r5 ∧ C.max r6 = C.max r5 ∧ C.plength r6 = C.plength r5 ∧ C.min sor2 = C.min sor1 ∧ C.max sor2 = C.max sor1 ∧ C.plength sor2 = C.plength sor1 → (∀(o10 : Bool), (BitVec.toUInt hi = BitVec.toUInt (0 : BitVec 64) → o10 = true) ∧ (o10 = true → hi = (0 : BitVec 64)) → (if ¬o10 = true then ((0 : ℤ) ≤ BitVec.toInt n ∧ (C.min r6 ≤ C.offset r6 + BitVec.toInt n ∧ C.offset r6 + BitVec.toInt n ≤ C.max r6) ∧ C.writable r6 = true) ∧ (∀(r7 : C.ptr (BitVec 64)), C.offset r7 = C.offset r6 ∧ C.min r7 = C.min r6 ∧ C.writable r7 = C.writable r6 ∧ C.zone1 r7 = C.zone1 r6 → C.offset r7 = C.offset r6 ∧ C.min r7 = C.min r6 ∧ C.writable r7 = C.writable r6 ∧ C.zone1 r7 = C.zone1 r6 → (∀(vm1n : C.ptr (BitVec 64)), C.writable vm1n = true ∧ C.offset vm1n = C.offset r7 + BitVec.toInt n ∧ C.max r7 = C.offset r7 + BitVec.toInt n ∧ C.min vm1n = C.offset r7 + BitVec.toInt n ∧ C.max vm1n = C.max r6 ∧ C.zone1 vm1n = C.zone1 r7 ∧ C.pelts r7 = C.pelts r6 ∧ C.plength r7 = C.plength r6 ∧ C.pelts vm1n = C.pelts r6 ∧ C.plength vm1n = C.plength r6 → (C.valid vm1n (BitVec.toInt n) ∧ C.valid ym11 (BitVec.toInt n) ∧ C.writable vm1n = true) ∧ (∀(vm1n1 : C.ptr (BitVec 64)), List.length (C.data vm1n1) = List.length (C.data vm1n) ∧ C.offset vm1n1 = C.offset vm1n ∧ C.min vm1n1 = C.min vm1n ∧ C.max vm1n1 = C.max vm1n ∧ C.writable vm1n1 = C.writable vm1n ∧ C.zone1 vm1n1 = C.zone1 vm1n → (∀(c : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ Lemmas.value vm1n1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt c = Lemmas.value vm1n (BitVec.toInt n) + Lemmas.value ym11 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset vm1n1 ∨ C.offset vm1n1 + BitVec.toInt n ≤ j → C.pelts vm1n1 j = C.pelts vm1n j) → (C.zone1 r7 = C.zone1 vm1n1 ∧ C.max r7 = C.min vm1n1 ∧ C.writable r7 = true ∧ C.writable vm1n1 = true) ∧ (∀(r8 : C.ptr (BitVec 64)), List.length (C.data r8) = List.length (C.data r7) ∧ C.offset r8 = C.offset r7 ∧ C.min r8 = C.min r7 ∧ C.writable r8 = C.writable r7 ∧ C.zone1 r8 = C.zone1 r7 → List.length (C.data r8) = List.length (C.data r7) ∧ C.offset r8 = C.offset r7 ∧ C.min r8 = C.min r7 ∧ C.writable r8 = C.writable r7 ∧ C.zone1 r8 = C.zone1 r7 → C.max r8 = C.max vm1n1 ∧ C.plength r8 = C.plength r7 ∧ (∀(i : ℤ), C.min r7 ≤ i ∧ i < C.max r7 → C.pelts r8 i = C.pelts r7 i) ∧ (∀(i : ℤ), C.min vm1n1 ≤ i ∧ i < C.max vm1n1 → C.pelts r8 i = C.pelts vm1n1 i) → Lemmas.value r8 ((2 : ℤ) * BitVec.toInt n) + m * m * BitVec.toUInt c = am1_abs * bm1_abs ∧ C.min r8 = C.min r6 ∧ C.max r8 = C.max r6 ∧ C.plength r8 = C.plength r6 ∧ (0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)))))) else Lemmas.value r6 ((2 : ℤ) * BitVec.toInt n) + m * m * BitVec.toUInt hi = am1_abs * bm1_abs ∧ (0 : ℤ) ≤ BitVec.toUInt hi ∧ BitVec.toUInt hi ≤ (1 : ℤ))) ∧ (∀(hi1 : BitVec 64) (r7 : C.ptr (BitVec 64)), C.offset r7 = C.offset r6 ∧ C.min r7 = C.min r6 ∧ C.writable r7 = C.writable r6 ∧ C.zone1 r7 = C.zone1 r6 → C.offset r7 = C.offset r6 ∧ C.min r7 = C.min r6 ∧ C.writable r7 = C.writable r6 ∧ C.zone1 r7 = C.zone1 r6 → Lemmas.value r7 ((2 : ℤ) * BitVec.toInt n) + m * m * BitVec.toUInt hi1 = am1_abs * bm1_abs ∧ C.min r7 = C.min r6 ∧ C.max r7 = C.max r6 ∧ C.plength r7 = C.plength r6 ∧ (0 : ℤ) ≤ BitVec.toUInt hi1 ∧ BitVec.toUInt hi1 ≤ (1 : ℤ) → (let vx0 : ℤ := a0 * b0; let vx1 : ℤ := a1 * b0 + a0 * b1; let vx2 : ℤ := a2 * b0 + a1 * b1; let vx3 : ℤ := a2 * b1; ((if vm1_neg1 = true then int'32_in_bounds ((2 : ℤ) * BitVec.toInt n) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = (2 : ℤ) * BitVec.toInt n → ((0 : ℤ) ≤ BitVec.toInt o10 ∧ C.valid scratch4 (BitVec.toInt o10) ∧ C.valid r7 (BitVec.toInt o10) ∧ C.writable scratch4 = true) ∧ (∀(scratch5 : C.ptr (BitVec 64)), List.length (C.data scratch5) = List.length (C.data scratch4) ∧ C.offset scratch5 = C.offset scratch4 ∧ C.min scratch5 = C.min scratch4 ∧ C.max scratch5 = C.max scratch4 ∧ C.writable scratch5 = C.writable scratch4 ∧ C.zone1 scratch5 = C.zone1 scratch4 → (∀(b : BitVec 64), Lemmas.value scratch5 (BitVec.toInt o10) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o10)) * BitVec.toUInt b = Lemmas.value scratch4 (BitVec.toInt o10) - Lemmas.value r7 (BitVec.toInt o10) ∧ ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset scratch5 ∨ C.offset scratch5 + BitVec.toInt o10 ≤ j → C.pelts scratch5 j = C.pelts scratch4 j) → ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ (∀(r8 : BitVec 64) (b' : BitVec 64), BitVec.toUInt r8 - ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt b' = BitVec.toUInt cy - BitVec.toUInt hi1 - BitVec.toUInt b ∧ (0 : ℤ) ≤ BitVec.toUInt b' ∧ BitVec.toUInt b' ≤ (1 : ℤ) → int'32_in_bounds ((2 : ℤ) * BitVec.toInt n) ∧ (∀(o11 : BitVec 32), BitVec.toInt o11 = (2 : ℤ) * BitVec.toInt n → ((C.min scratch5 ≤ C.offset scratch5 + BitVec.toInt o11 ∧ C.offset scratch5 + BitVec.toInt o11 < C.max scratch5) ∧ C.writable scratch5 = true) ∧ (∀(scratch6 : C.ptr (BitVec 64)), List.length (C.data scratch6) = List.length (C.data scratch5) ∧ C.offset scratch6 = C.offset scratch5 ∧ C.min scratch6 = C.min scratch5 ∧ C.max scratch6 = C.max scratch5 ∧ C.writable scratch6 = C.writable scratch5 ∧ C.zone1 scratch6 = C.zone1 scratch5 → C.pelts scratch6 = Function.update (C.pelts scratch5) (C.offset scratch6 + BitVec.toInt o11) r8 ∧ C.pelts scratch6 (C.offset scratch6 + BitVec.toInt o11) = r8 → Lemmas.value scratch6 ((2 : ℤ) * BitVec.toInt n + (1 : ℤ)) = (2 : ℤ) * (vx0 + vx2) ∧ (if vm1_neg1 = true then am1_abs * bm1_abs = (a0 - a1 + a2) * (b1 - b0) else am1_abs * bm1_abs = (a0 - a1 + a2) * (b0 - b1)))))))) else int'32_in_bounds ((2 : ℤ) * BitVec.toInt n) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = (2 : ℤ) * BitVec.toInt n → (C.valid scratch4 (BitVec.toInt o10) ∧ C.valid r7 (BitVec.toInt o10) ∧ C.writable scratch4 = true) ∧ (∀(scratch5 : C.ptr (BitVec 64)), List.length (C.data scratch5) = List.length (C.data scratch4) ∧ C.offset scratch5 = C.offset scratch4 ∧ C.min scratch5 = C.min scratch4 ∧ C.max scratch5 = C.max scratch4 ∧ C.writable scratch5 = C.writable scratch4 ∧ C.zone1 scratch5 = C.zone1 scratch4 → (∀(c : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ Lemmas.value scratch5 (BitVec.toInt o10) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o10)) * BitVec.toUInt c = Lemmas.value scratch4 (BitVec.toInt o10) + Lemmas.value r7 (BitVec.toInt o10) ∧ (∀(j : ℤ), j < C.offset scratch5 ∨ C.offset scratch5 + BitVec.toInt o10 ≤ j → C.pelts scratch5 j = C.pelts scratch4 j) → ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (∀(r8 : BitVec 64) (c' : BitVec 64), BitVec.toUInt r8 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt c' = BitVec.toUInt cy + BitVec.toUInt hi1 + BitVec.toUInt c ∧ (0 : ℤ) ≤ BitVec.toUInt c' ∧ BitVec.toUInt c' ≤ (1 : ℤ) → int'32_in_bounds ((2 : ℤ) * BitVec.toInt n) ∧ (∀(o11 : BitVec 32), BitVec.toInt o11 = (2 : ℤ) * BitVec.toInt n → ((C.min scratch5 ≤ C.offset scratch5 + BitVec.toInt o11 ∧ C.offset scratch5 + BitVec.toInt o11 < C.max scratch5) ∧ C.writable scratch5 = true) ∧ (∀(scratch6 : C.ptr (BitVec 64)), List.length (C.data scratch6) = List.length (C.data scratch5) ∧ C.offset scratch6 = C.offset scratch5 ∧ C.min scratch6 = C.min scratch5 ∧ C.max scratch6 = C.max scratch5 ∧ C.writable scratch6 = C.writable scratch5 ∧ C.zone1 scratch6 = C.zone1 scratch5 → C.pelts scratch6 = Function.update (C.pelts scratch5) (C.offset scratch6 + BitVec.toInt o11) r8 ∧ C.pelts scratch6 (C.offset scratch6 + BitVec.toInt o11) = r8 → Lemmas.value scratch6 ((2 : ℤ) * BitVec.toInt n + (1 : ℤ)) = (2 : ℤ) * (vx0 + vx2) ∧ (if vm1_neg1 = true then am1_abs * bm1_abs = (a0 - a1 + a2) * (b1 - b0) else am1_abs * bm1_abs = (a0 - a1 + a2) * (b0 - b1))))))))) ∧ (∀(scratch5 : C.ptr (BitVec 64)), List.length (C.data scratch5) = List.length (C.data scratch4) ∧ C.offset scratch5 = C.offset scratch4 ∧ C.min scratch5 = C.min scratch4 ∧ C.max scratch5 = C.max scratch4 ∧ C.writable scratch5 = C.writable scratch4 ∧ C.zone1 scratch5 = C.zone1 scratch4 → Lemmas.value scratch5 ((2 : ℤ) * BitVec.toInt n + (1 : ℤ)) = (2 : ℤ) * (vx0 + vx2) ∧ (if vm1_neg1 = true then am1_abs * bm1_abs = (a0 - a1 + a2) * (b1 - b0) else am1_abs * bm1_abs = (a0 - a1 + a2) * (b0 - b1)) → int'32_in_bounds ((2 : ℤ) * BitVec.toInt n) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = (2 : ℤ) * BitVec.toInt n → int'32_in_bounds (BitVec.toInt o10 + (1 : ℤ)) ∧ (∀(s1 : BitVec 32), BitVec.toInt s1 = BitVec.toInt o10 + (1 : ℤ) → (((0 : ℤ) < (1 : ℤ) ∧ (1 : ℤ) < (64 : ℤ)) ∧ C.valid scratch5 (BitVec.toInt s1) ∧ C.valid scratch5 (BitVec.toInt s1) ∧ (0 : ℤ) < BitVec.toInt s1 ∧ C.writable scratch5 = true ∧ (C.offset scratch5 ≤ C.offset scratch5 ∨ C.offset scratch5 + BitVec.toInt s1 ≤ C.offset scratch5)) ∧ (∀(scratch6 : C.ptr (BitVec 64)), List.length (C.data scratch6) = List.length (C.data scratch5) ∧ C.offset scratch6 = C.offset scratch5 ∧ C.min scratch6 = C.min scratch5 ∧ C.max scratch6 = C.max scratch5 ∧ C.writable scratch6 = C.writable scratch5 ∧ C.zone1 scratch6 = C.zone1 scratch5 → (∀(low : BitVec 64), BitVec.toUInt low + ((18446744073709551615 : ℤ) + (1 : ℤ)) * Lemmas.value scratch6 (BitVec.toInt s1) = Lemmas.value scratch5 (BitVec.toInt s1) * HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - (1 : ℤ))) ∧ (∀(j : ℤ), j < C.offset scratch6 ∨ C.offset scratch6 + BitVec.toInt s1 ≤ j → C.pelts scratch6 j = C.pelts scratch5 j) ∧ C.min scratch6 = C.min scratch5 ∧ C.max scratch6 = C.max scratch5 ∧ C.plength scratch6 = C.plength scratch5 → Lemmas.value scratch6 ((2 : ℤ) * BitVec.toInt n + (1 : ℤ)) = vx0 + vx2 ∧ (if vm1_neg1 = true then am1_abs * bm1_abs = (a0 - a1 + a2) * (b1 - b0) else am1_abs * bm1_abs = (a0 - a1 + a2) * (b0 - b1)))))))) ∧ (∀(scratch5 : C.ptr (BitVec 64)), List.length (C.data scratch5) = List.length (C.data scratch4) ∧ C.offset scratch5 = C.offset scratch4 ∧ C.min scratch5 = C.min scratch4 ∧ C.max scratch5 = C.max scratch4 ∧ C.writable scratch5 = C.writable scratch4 ∧ C.zone1 scratch5 = C.zone1 scratch4 → Lemmas.value scratch5 ((2 : ℤ) * BitVec.toInt n + (1 : ℤ)) = vx0 + vx2 ∧ (if vm1_neg1 = true then am1_abs * bm1_abs = (a0 - a1 + a2) * (b1 - b0) else am1_abs * bm1_abs = (a0 - a1 + a2) * (b0 - b1)) → (let vy : ℤ := vx1 + vx3 + (vx0 + vx2) * m; (C.zone1 xm12 = C.zone1 ym11 ∧ C.max xm12 = C.min ym11 ∧ C.writable xm12 = true ∧ C.writable ym11 = true) ∧ (∀(xm13 : C.ptr (BitVec 64)), List.length (C.data xm13) = List.length (C.data xm12) ∧ C.offset xm13 = C.offset xm12 ∧ C.min xm13 = C.min xm12 ∧ C.writable xm13 = C.writable xm12 ∧ C.zone1 xm13 = C.zone1 xm12 → C.max xm13 = C.max ym11 ∧ C.plength xm13 = C.plength xm12 ∧ (∀(i : ℤ), C.min xm12 ≤ i ∧ i < C.max xm12 → C.pelts xm13 i = C.pelts xm12 i) ∧ (∀(i : ℤ), C.min ym11 ≤ i ∧ i < C.max ym11 → C.pelts xm13 i = C.pelts ym11 i) → int'32_in_bounds ((2 : ℤ) * BitVec.toInt n) ∧ (∀(o10 : BitVec 32), BitVec.toInt o10 = (2 : ℤ) * BitVec.toInt n → int'32_in_bounds (BitVec.toInt o10 + (1 : ℤ)) ∧ (∀(ss : BitVec 32), BitVec.toInt ss = BitVec.toInt o10 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt n ∧ (C.min scratch5 ≤ C.offset scratch5 + BitVec.toInt n ∧ C.offset scratch5 + BitVec.toInt n ≤ C.max scratch5) ∧ C.writable scratch5 = true) ∧ (∀(scratch6 : C.ptr (BitVec 64)), C.offset scratch6 = C.offset scratch5 ∧ C.min scratch6 = C.min scratch5 ∧ C.writable scratch6 = C.writable scratch5 ∧ C.zone1 scratch6 = C.zone1 scratch5 → C.offset scratch6 = C.offset scratch5 ∧ C.min scratch6 = C.min scratch5 ∧ C.writable scratch6 = C.writable scratch5 ∧ C.zone1 scratch6 = C.zone1 scratch5 → (∀(vy2 : C.ptr (BitVec 64)), C.writable vy2 = true ∧ C.offset vy2 = C.offset scratch6 + BitVec.toInt n ∧ C.max scratch6 = C.offset scratch6 + BitVec.toInt n ∧ C.min vy2 = C.offset scratch6 + BitVec.toInt n ∧ C.max vy2 = C.max scratch5 ∧ C.zone1 vy2 = C.zone1 scratch6 ∧ C.pelts scratch6 = C.pelts scratch5 ∧ C.plength scratch6 = C.plength scratch5 ∧ C.pelts vy2 = C.pelts scratch5 ∧ C.plength vy2 = C.plength scratch5 → (C.min vy2 ≤ C.offset vy2 + BitVec.toInt n ∧ C.offset vy2 + BitVec.toInt n < C.max vy2) ∧ (let t02 : BitVec 64 := C.pelts vy2 (C.offset vy2 + BitVec.toInt n); ((C.valid scratch6 (BitVec.toInt n) ∧ C.valid vy2 (BitVec.toInt n) ∧ C.valid xm13 (BitVec.toInt n) ∧ C.writable xm13 = true) ∧ (∀(vy1 : C.ptr (BitVec 64)), List.length (C.data vy1) = List.length (C.data xm13) ∧ C.offset vy1 = C.offset xm13 ∧ C.min vy1 = C.min xm13 ∧ C.max vy1 = C.max xm13 ∧ C.writable vy1 = C.writable xm13 ∧ C.zone1 vy1 = C.zone1 xm13 → (∀(c : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ Lemmas.value vy1 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt c = Lemmas.value scratch6 (BitVec.toInt n) + Lemmas.value vy2 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset vy1 ∨ C.offset vy1 + BitVec.toInt n ≤ j → C.pelts vy1 j = C.pelts xm13 j) → uint'64_in_bounds (BitVec.toUInt c + BitVec.toUInt t02) ∧ (∀(o11 : BitVec 64), BitVec.toUInt o11 = BitVec.toUInt c + BitVec.toUInt t02 → int'32_in_bounds (BitVec.toInt n + (1 : ℤ)) ∧ (∀(o12 : BitVec 32), BitVec.toInt o12 = BitVec.toInt n + (1 : ℤ) → (C.valid vy2 (BitVec.toInt o12) ∧ (0 : ℤ) < BitVec.toInt o12 ∧ Lemmas.value vy2 (BitVec.toInt o12) + BitVec.toUInt o11 < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o12)) ∧ C.writable vy2 = true) ∧ (∀(vy21 : C.ptr (BitVec 64)), List.length (C.data vy21) = List.length (C.data vy2) ∧ C.offset vy21 = C.offset vy2 ∧ C.min vy21 = C.min vy2 ∧ C.max vy21 = C.max vy2 ∧ C.writable vy21 = C.writable vy2 ∧ C.zone1 vy21 = C.zone1 vy2 → Lemmas.value vy21 (BitVec.toInt o12) = Lemmas.value vy2 (BitVec.toInt o12) + BitVec.toUInt o11 ∧ (∀(j : ℤ), j < C.offset vy21 ∨ C.offset vy21 + BitVec.toInt o12 ≤ j → C.pelts vy21 j = C.pelts vy2 j) → (C.min r7 ≤ C.offset r7 + BitVec.toInt n ∧ C.offset r7 + BitVec.toInt n ≤ C.max r7) ∧ (∀(vm1n : C.ptr (BitVec 64)), C.offset vm1n = C.offset r7 + BitVec.toInt n ∧ C.plength vm1n = C.plength r7 ∧ C.pelts vm1n = C.pelts r7 ∧ C.data vm1n = C.data r7 ∧ C.min vm1n = C.min r7 ∧ C.max vm1n = C.max r7 ∧ C.zone1 vm1n = C.zone1 r7 ∧ C.writable vm1n = C.writable r7 → (if vm1_neg1 = true then (C.valid scratch6 (BitVec.toInt n) ∧ C.valid r7 (BitVec.toInt n) ∧ C.writable scratch6 = true) ∧ (∀(scratch7 : C.ptr (BitVec 64)), List.length (C.data scratch7) = List.length (C.data scratch6) ∧ C.offset scratch7 = C.offset scratch6 ∧ C.min scratch7 = C.min scratch6 ∧ C.max scratch7 = C.max scratch6 ∧ C.writable scratch7 = C.writable scratch6 ∧ C.zone1 scratch7 = C.zone1 scratch6 → List.length (C.data scratch7) = List.length (C.data scratch6) ∧ C.offset scratch7 = C.offset scratch6 ∧ C.min scratch7 = C.min scratch6 ∧ C.max scratch7 = C.max scratch6 ∧ C.writable scratch7 = C.writable scratch6 ∧ C.zone1 scratch7 = C.zone1 scratch6 → (∀(c1 : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt c1 ∧ BitVec.toUInt c1 ≤ (1 : ℤ)) ∧ Lemmas.value scratch7 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt c1 = Lemmas.value scratch6 (BitVec.toInt n) + Lemmas.value r7 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset scratch7 ∨ C.offset scratch7 + BitVec.toInt n ≤ j → C.pelts scratch7 j = C.pelts scratch6 j) → (C.valid vy1 (BitVec.toInt n) ∧ C.valid vm1n (BitVec.toInt n) ∧ C.writable vy1 = true) ∧ (∀(vy11 : C.ptr (BitVec 64)), List.length (C.data vy11) = List.length (C.data vy1) ∧ C.offset vy11 = C.offset vy1 ∧ C.min vy11 = C.min vy1 ∧ C.max vy11 = C.max vy1 ∧ C.writable vy11 = C.writable vy1 ∧ C.zone1 vy11 = C.zone1 vy1 → (∀(c2 : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt c2 ∧ BitVec.toUInt c2 ≤ (1 : ℤ)) ∧ Lemmas.value vy11 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt c2 = Lemmas.value vy1 (BitVec.toInt n) + Lemmas.value vm1n (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset vy11 ∨ C.offset vy11 + BitVec.toInt n ≤ j → C.pelts vy11 j = C.pelts vy1 j) → uint'64_in_bounds (BitVec.toUInt hi1 + BitVec.toUInt c2) ∧ (∀(o13 : BitVec 64), BitVec.toUInt o13 = BitVec.toUInt hi1 + BitVec.toUInt c2 → (C.valid vy11 (BitVec.toInt n) ∧ (0 : ℤ) < BitVec.toInt n ∧ C.writable vy11 = true) ∧ (∀(vy12 : C.ptr (BitVec 64)), List.length (C.data vy12) = List.length (C.data vy11) ∧ C.offset vy12 = C.offset vy11 ∧ C.min vy12 = C.min vy11 ∧ C.max vy12 = C.max vy11 ∧ C.writable vy12 = C.writable vy11 ∧ C.zone1 vy12 = C.zone1 vy11 → (∀(c3 : BitVec 64), Lemmas.value vy12 (BitVec.toInt n) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt c3 = Lemmas.value vy11 (BitVec.toInt n) + BitVec.toUInt c1 ∧ ((0 : ℤ) ≤ BitVec.toUInt c3 ∧ BitVec.toUInt c3 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset vy12 ∨ C.offset vy12 + BitVec.toInt n ≤ j → C.pelts vy12 j = C.pelts vy11 j) → uint'64_in_bounds (BitVec.toUInt o13 + BitVec.toUInt c3) ∧ (∀(o14 : BitVec 64), BitVec.toUInt o14 = BitVec.toUInt o13 + BitVec.toUInt c3 → int'32_in_bounds (BitVec.toInt n + (1 : ℤ)) ∧ (∀(o15 : BitVec 32), BitVec.toInt o15 = BitVec.toInt n + (1 : ℤ) → (C.valid vy21 (BitVec.toInt o15) ∧ (0 : ℤ) < BitVec.toInt o15 ∧ Lemmas.value vy21 (BitVec.toInt o15) + BitVec.toUInt o14 < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o15)) ∧ C.writable vy21 = true) ∧ (∀(vy22 : C.ptr (BitVec 64)), List.length (C.data vy22) = List.length (C.data vy21) ∧ C.offset vy22 = C.offset vy21 ∧ C.min vy22 = C.min vy21 ∧ C.max vy22 = C.max vy21 ∧ C.writable vy22 = C.writable vy21 ∧ C.zone1 vy22 = C.zone1 vy21 → Lemmas.value vy22 (BitVec.toInt o15) = Lemmas.value vy21 (BitVec.toInt o15) + BitVec.toUInt o14 ∧ (∀(j : ℤ), j < C.offset vy22 ∨ C.offset vy22 + BitVec.toInt o15 ≤ j → C.pelts vy22 j = C.pelts vy21 j) → Lemmas.value scratch7 (BitVec.toInt n) + m * Lemmas.value vy12 (BitVec.toInt n) + m * m * Lemmas.value vy22 (BitVec.toInt n + (1 : ℤ)) = Lemmas.value scratch6 (BitVec.toInt n) + m * Lemmas.value vy1 (BitVec.toInt n) + m * m * Lemmas.value vy21 (BitVec.toInt n + (1 : ℤ)) - (vx0 - vx1 + vx2 - vx3) ∧ Lemmas.value vy22 (BitVec.toInt n + (1 : ℤ)) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * (6 : ℤ))))))))))) else ((0 : ℤ) ≤ BitVec.toInt n ∧ C.valid scratch6 (BitVec.toInt n) ∧ C.valid r7 (BitVec.toInt n) ∧ C.writable scratch6 = true) ∧ (∀(scratch7 : C.ptr (BitVec 64)), List.length (C.data scratch7) = List.length (C.data scratch6) ∧ C.offset scratch7 = C.offset scratch6 ∧ C.min scratch7 = C.min scratch6 ∧ C.max scratch7 = C.max scratch6 ∧ C.writable scratch7 = C.writable scratch6 ∧ C.zone1 scratch7 = C.zone1 scratch6 → List.length (C.data scratch7) = List.length (C.data scratch6) ∧ C.offset scratch7 = C.offset scratch6 ∧ C.min scratch7 = C.min scratch6 ∧ C.max scratch7 = C.max scratch6 ∧ C.writable scratch7 = C.writable scratch6 ∧ C.zone1 scratch7 = C.zone1 scratch6 → (∀(b11 : BitVec 64), Lemmas.value scratch7 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt b11 = Lemmas.value scratch6 (BitVec.toInt n) - Lemmas.value r7 (BitVec.toInt n) ∧ ((0 : ℤ) ≤ BitVec.toUInt b11 ∧ BitVec.toUInt b11 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset scratch7 ∨ C.offset scratch7 + BitVec.toInt n ≤ j → C.pelts scratch7 j = C.pelts scratch6 j) → ((0 : ℤ) ≤ BitVec.toInt n ∧ C.valid vy1 (BitVec.toInt n) ∧ C.valid vm1n (BitVec.toInt n) ∧ C.writable vy1 = true) ∧ (∀(vy11 : C.ptr (BitVec 64)), List.length (C.data vy11) = List.length (C.data vy1) ∧ C.offset vy11 = C.offset vy1 ∧ C.min vy11 = C.min vy1 ∧ C.max vy11 = C.max vy1 ∧ C.writable vy11 = C.writable vy1 ∧ C.zone1 vy11 = C.zone1 vy1 → (∀(b2 : BitVec 64), Lemmas.value vy11 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt b2 = Lemmas.value vy1 (BitVec.toInt n) - Lemmas.value vm1n (BitVec.toInt n) ∧ ((0 : ℤ) ≤ BitVec.toUInt b2 ∧ BitVec.toUInt b2 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset vy11 ∨ C.offset vy11 + BitVec.toInt n ≤ j → C.pelts vy11 j = C.pelts vy1 j) → uint'64_in_bounds (BitVec.toUInt hi1 + BitVec.toUInt b2) ∧ (∀(o13 : BitVec 64), BitVec.toUInt o13 = BitVec.toUInt hi1 + BitVec.toUInt b2 → (C.valid vy11 (BitVec.toInt n) ∧ (0 : ℤ) < BitVec.toInt n ∧ C.writable vy11 = true) ∧ (∀(vy12 : C.ptr (BitVec 64)), List.length (C.data vy12) = List.length (C.data vy11) ∧ C.offset vy12 = C.offset vy11 ∧ C.min vy12 = C.min vy11 ∧ C.max vy12 = C.max vy11 ∧ C.writable vy12 = C.writable vy11 ∧ C.zone1 vy12 = C.zone1 vy11 → (∀(b3 : BitVec 64), Lemmas.value vy12 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt b3 = Lemmas.value vy11 (BitVec.toInt n) - BitVec.toUInt b11 ∧ ((0 : ℤ) ≤ BitVec.toUInt b3 ∧ BitVec.toUInt b3 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset vy12 ∨ C.offset vy12 + BitVec.toInt n ≤ j → C.pelts vy12 j = C.pelts vy11 j) → uint'64_in_bounds (BitVec.toUInt o13 + BitVec.toUInt b3) ∧ (∀(o14 : BitVec 64), BitVec.toUInt o14 = BitVec.toUInt o13 + BitVec.toUInt b3 → int'32_in_bounds (BitVec.toInt n + (1 : ℤ)) ∧ (∀(o15 : BitVec 32), BitVec.toInt o15 = BitVec.toInt n + (1 : ℤ) → (C.valid vy21 (BitVec.toInt o15) ∧ (0 : ℤ) < BitVec.toInt o15 ∧ (0 : ℤ) ≤ Lemmas.value vy21 (BitVec.toInt o15) - BitVec.toUInt o14 ∧ C.writable vy21 = true) ∧ (∀(vy22 : C.ptr (BitVec 64)), List.length (C.data vy22) = List.length (C.data vy21) ∧ C.offset vy22 = C.offset vy21 ∧ C.min vy22 = C.min vy21 ∧ C.max vy22 = C.max vy21 ∧ C.writable vy22 = C.writable vy21 ∧ C.zone1 vy22 = C.zone1 vy21 → Lemmas.value vy22 (BitVec.toInt o15) = Lemmas.value vy21 (BitVec.toInt o15) - BitVec.toUInt o14 ∧ (∀(j : ℤ), j < C.offset vy22 ∨ C.offset vy22 + BitVec.toInt o15 ≤ j → C.pelts vy22 j = C.pelts vy21 j) → Lemmas.value scratch7 (BitVec.toInt n) + m * Lemmas.value vy12 (BitVec.toInt n) + m * m * Lemmas.value vy22 (BitVec.toInt n + (1 : ℤ)) = Lemmas.value scratch6 (BitVec.toInt n) + m * Lemmas.value vy1 (BitVec.toInt n) + m * m * Lemmas.value vy21 (BitVec.toInt n + (1 : ℤ)) - (vx0 - vx1 + vx2 - vx3) ∧ Lemmas.value vy22 (BitVec.toInt n + (1 : ℤ)) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * (6 : ℤ)))))))))))) ∧ (∀(vy22 : C.ptr (BitVec 64)) (vy11 : C.ptr (BitVec 64)) (vy0 : C.ptr (BitVec 64)), List.length (C.data vy22) = List.length (C.data vy21) ∧ C.offset vy22 = C.offset vy21 ∧ C.min vy22 = C.min vy21 ∧ C.max vy22 = C.max vy21 ∧ C.writable vy22 = C.writable vy21 ∧ C.zone1 vy22 = C.zone1 vy21 → List.length (C.data vy11) = List.length (C.data vy1) ∧ C.offset vy11 = C.offset vy1 ∧ C.min vy11 = C.min vy1 ∧ C.max vy11 = C.max vy1 ∧ C.writable vy11 = C.writable vy1 ∧ C.zone1 vy11 = C.zone1 vy1 → List.length (C.data vy0) = List.length (C.data scratch6) ∧ C.offset vy0 = C.offset scratch6 ∧ C.min vy0 = C.min scratch6 ∧ C.max vy0 = C.max scratch6 ∧ C.writable vy0 = C.writable scratch6 ∧ C.zone1 vy0 = C.zone1 scratch6 → Lemmas.value vy0 (BitVec.toInt n) + m * Lemmas.value vy11 (BitVec.toInt n) + m * m * Lemmas.value vy22 (BitVec.toInt n + (1 : ℤ)) = Lemmas.value scratch6 (BitVec.toInt n) + m * Lemmas.value vy1 (BitVec.toInt n) + m * m * Lemmas.value vy21 (BitVec.toInt n + (1 : ℤ)) - (vx0 - vx1 + vx2 - vx3) ∧ Lemmas.value vy22 (BitVec.toInt n + (1 : ℤ)) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * (6 : ℤ) → Lemmas.value vy0 (BitVec.toInt n) + m * Lemmas.value vy11 (BitVec.toInt n) + m * m * Lemmas.value vy22 (BitVec.toInt n + (1 : ℤ)) = vy ∧ Lemmas.value vy22 (BitVec.toInt n + (1 : ℤ)) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * (6 : ℤ))))))))) ∧ (∀(vy21 : C.ptr (BitVec 64)) (xm14 : C.ptr (BitVec 64)) (scratch7 : C.ptr (BitVec 64)), List.length (C.data vy21) = List.length (C.data vy2) ∧ C.offset vy21 = C.offset vy2 ∧ C.min vy21 = C.min vy2 ∧ C.max vy21 = C.max vy2 ∧ C.writable vy21 = C.writable vy2 ∧ C.zone1 vy21 = C.zone1 vy2 → List.length (C.data xm14) = List.length (C.data xm13) ∧ C.offset xm14 = C.offset xm13 ∧ C.min xm14 = C.min xm13 ∧ C.max xm14 = C.max xm13 ∧ C.writable xm14 = C.writable xm13 ∧ C.zone1 xm14 = C.zone1 xm13 → List.length (C.data scratch7) = List.length (C.data scratch6) ∧ C.offset scratch7 = C.offset scratch6 ∧ C.min scratch7 = C.min scratch6 ∧ C.max scratch7 = C.max scratch6 ∧ C.writable scratch7 = C.writable scratch6 ∧ C.zone1 scratch7 = C.zone1 scratch6 → List.length (C.data xm14) = List.length (C.data xm13) ∧ C.offset xm14 = C.offset xm13 ∧ C.min xm14 = C.min xm13 ∧ C.max xm14 = C.max xm13 ∧ C.writable xm14 = C.writable xm13 ∧ C.zone1 xm14 = C.zone1 xm13 → List.length (C.data scratch7) = List.length (C.data scratch6) ∧ C.offset scratch7 = C.offset scratch6 ∧ C.min scratch7 = C.min scratch6 ∧ C.max scratch7 = C.max scratch6 ∧ C.writable scratch7 = C.writable scratch6 ∧ C.zone1 scratch7 = C.zone1 scratch6 → Lemmas.value scratch7 (BitVec.toInt n) + m * Lemmas.value xm14 (BitVec.toInt n) + m * m * Lemmas.value vy21 (BitVec.toInt n + (1 : ℤ)) = vy ∧ Lemmas.value vy21 (BitVec.toInt n + (1 : ℤ)) < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * (6 : ℤ) → (let o11 : ℤ := k - (1 : ℤ); (((0 : ℤ) ≤ k + k ∧ o11 + o11 + (1 : ℤ) < k + k) ∧ C.valid x (BitVec.toInt n) ∧ C.valid y (BitVec.toInt n) ∧ C.valid r7 (BitVec.toInt n + BitVec.toInt n) ∧ (C.writable r7 = true ∧ C.writable sor2 = true) ∧ (0 : ℤ) < BitVec.toInt n ∧ (8 : ℤ) * BitVec.toInt n < (2147483647 : ℤ) ∧ ((0 : ℤ) ≤ o11 ∧ o11 ≤ (64 : ℤ)) ∧ BitVec.toInt n ≤ BitVec.toInt (29 : BitVec 32) * HPow.hPow (2 : ℤ) (Int.toNat o11) ∧ C.valid sor2 ((2 : ℤ) * (BitVec.toInt n + o11))) ∧ (∀(sor3 : C.ptr (BitVec 64)) (r8 : C.ptr (BitVec 64)), C.offset sor3 = C.offset sor2 ∧ C.writable sor3 = C.writable sor2 ∧ C.zone1 sor3 = C.zone1 sor2 → C.offset r8 = C.offset r7 ∧ C.writable r8 = C.writable r7 ∧ C.zone1 r8 = C.zone1 r7 → Lemmas.value r8 (BitVec.toInt n + BitVec.toInt n) = Lemmas.value x (BitVec.toInt n) * Lemmas.value y (BitVec.toInt n) ∧ (∀(j : ℤ), C.min r8 ≤ j ∧ j < C.offset r8 ∨ C.offset r8 + BitVec.toInt n + BitVec.toInt n ≤ j ∧ j < C.max r8 → C.pelts r8 j = C.pelts r7 j) ∧ (∀(j : ℤ), C.min sor3 ≤ j ∧ j < C.offset sor3 → C.pelts sor3 j = C.pelts sor2 j) ∧ C.min r8 = C.min r7 ∧ C.max r8 = C.max r7 ∧ C.plength r8 = C.plength r7 ∧ C.min sor3 = C.min sor2 ∧ C.max sor3 = C.max sor2 ∧ C.plength sor3 = C.plength sor2 → ((0 : ℤ) ≤ BitVec.toInt n ∧ (C.min xm14 ≤ C.offset xm14 + BitVec.toInt n ∧ C.offset xm14 + BitVec.toInt n ≤ C.max xm14) ∧ C.writable xm14 = true) ∧ (∀(xm15 : C.ptr (BitVec 64)), C.offset xm15 = C.offset xm14 ∧ C.min xm15 = C.min xm14 ∧ C.writable xm15 = C.writable xm14 ∧ C.zone1 xm15 = C.zone1 xm14 → C.offset xm15 = C.offset xm14 ∧ C.min xm15 = C.min xm14 ∧ C.writable xm15 = C.writable xm14 ∧ C.zone1 xm15 = C.zone1 xm14 → (∀(r3n : C.ptr (BitVec 64)), C.writable r3n = true ∧ C.offset r3n = C.offset xm15 + BitVec.toInt n ∧ C.max xm15 = C.offset xm15 + BitVec.toInt n ∧ C.min r3n = C.offset xm15 + BitVec.toInt n ∧ C.max r3n = C.max xm14 ∧ C.zone1 r3n = C.zone1 xm15 ∧ C.pelts xm15 = C.pelts xm14 ∧ C.plength xm15 = C.plength xm14 ∧ C.pelts r3n = C.pelts xm14 ∧ C.plength r3n = C.plength xm14 → (if BitVec.toInt t < BitVec.toInt s then let o12 : ℤ := k - (1 : ℤ); (((0 : ℤ) ≤ k + k ∧ o12 + o12 + (1 : ℤ) < k + k) ∧ C.valid x2 (BitVec.toInt s) ∧ C.valid y1 (BitVec.toInt t) ∧ C.valid r3n (BitVec.toInt s + BitVec.toInt t) ∧ C.writable r3n = true ∧ ((0 : ℤ) < BitVec.toInt t ∧ BitVec.toInt t ≤ BitVec.toInt s) ∧ (8 : ℤ) * BitVec.toInt s < (2147483647 : ℤ) ∧ BitVec.toInt s ≤ BitVec.toInt (29 : BitVec 32) * HPow.hPow (2 : ℤ) (Int.toNat o12) ∧ (0 : ℤ) ≤ o12 ∧ o12 ≤ (64 : ℤ)) ∧ (∀(r3n1 : C.ptr (BitVec 64)), C.offset r3n1 = C.offset r3n ∧ C.writable r3n1 = C.writable r3n ∧ C.zone1 r3n1 = C.zone1 r3n → C.min r3n1 = C.min r3n ∧ C.max r3n1 = C.max r3n ∧ C.plength r3n1 = C.plength r3n ∧ Lemmas.value r3n1 (BitVec.toInt s + BitVec.toInt t) = Lemmas.value x2 (BitVec.toInt s) * Lemmas.value y1 (BitVec.toInt t) ∧ (∀(j : ℤ), C.min r3n1 ≤ j ∧ j < C.offset r3n1 ∨ C.offset r3n1 + BitVec.toInt s + BitVec.toInt t ≤ j ∧ j < C.max r3n1 → C.pelts r3n1 j = C.pelts r3n j) → Lemmas.value r3n1 (BitVec.toInt s + BitVec.toInt t) = vx3 ∧ (C.min r3n1 = C.min r3n ∧ C.max r3n1 = C.max r3n) ∧ C.plength r3n1 = C.plength r3n) else let o12 : ℤ := k - (1 : ℤ); (((0 : ℤ) ≤ k + k ∧ o12 + o12 + (1 : ℤ) < k + k) ∧ C.valid y1 (BitVec.toInt t) ∧ C.valid x2 (BitVec.toInt s) ∧ C.valid r3n (BitVec.toInt t + BitVec.toInt s) ∧ C.writable r3n = true ∧ ((0 : ℤ) < BitVec.toInt s ∧ BitVec.toInt s ≤ BitVec.toInt t) ∧ (8 : ℤ) * BitVec.toInt t < (2147483647 : ℤ) ∧ BitVec.toInt t ≤ BitVec.toInt (29 : BitVec 32) * HPow.hPow (2 : ℤ) (Int.toNat o12) ∧ (0 : ℤ) ≤ o12 ∧ o12 ≤ (64 : ℤ)) ∧ (∀(r3n1 : C.ptr (BitVec 64)), C.offset r3n1 = C.offset r3n ∧ C.writable r3n1 = C.writable r3n ∧ C.zone1 r3n1 = C.zone1 r3n → C.min r3n1 = C.min r3n ∧ C.max r3n1 = C.max r3n ∧ C.plength r3n1 = C.plength r3n ∧ Lemmas.value r3n1 (BitVec.toInt t + BitVec.toInt s) = Lemmas.value y1 (BitVec.toInt t) * Lemmas.value x2 (BitVec.toInt s) ∧ (∀(j : ℤ), C.min r3n1 ≤ j ∧ j < C.offset r3n1 ∨ C.offset r3n1 + BitVec.toInt t + BitVec.toInt s ≤ j ∧ j < C.max r3n1 → C.pelts r3n1 j = C.pelts r3n j) → Lemmas.value r3n1 (BitVec.toInt s + BitVec.toInt t) = vx3 ∧ (C.min r3n1 = C.min r3n ∧ C.max r3n1 = C.max r3n) ∧ C.plength r3n1 = C.plength r3n)) ∧ (∀(r3n1 : C.ptr (BitVec 64)), C.offset r3n1 = C.offset r3n ∧ C.writable r3n1 = C.writable r3n ∧ C.zone1 r3n1 = C.zone1 r3n → Lemmas.value r3n1 (BitVec.toInt s + BitVec.toInt t) = vx3 ∧ (C.min r3n1 = C.min r3n ∧ C.max r3n1 = C.max r3n) ∧ C.plength r3n1 = C.plength r3n → ((0 : ℤ) ≤ BitVec.toInt n ∧ (C.min r8 ≤ C.offset r8 + BitVec.toInt n ∧ C.offset r8 + BitVec.toInt n ≤ C.max r8) ∧ C.writable r8 = true) ∧ (∀(r9 : C.ptr (BitVec 64)), C.offset r9 = C.offset r8 ∧ C.min r9 = C.min r8 ∧ C.writable r9 = C.writable r8 ∧ C.zone1 r9 = C.zone1 r8 → (∀(r1n : C.ptr (BitVec 64)), C.writable r1n = true ∧ C.offset r1n = C.offset r9 + BitVec.toInt n ∧ C.max r9 = C.offset r9 + BitVec.toInt n ∧ C.min r1n = C.offset r9 + BitVec.toInt n ∧ C.max r1n = C.max r8 ∧ C.zone1 r1n = C.zone1 r9 ∧ C.pelts r9 = C.pelts r8 ∧ C.plength r9 = C.plength r8 ∧ C.pelts r1n = C.pelts r8 ∧ C.plength r1n = C.plength r8 → ((0 : ℤ) ≤ BitVec.toInt n ∧ (C.min r3n1 ≤ C.offset r3n1 + BitVec.toInt n ∧ C.offset r3n1 + BitVec.toInt n ≤ C.max r3n1) ∧ C.writable r3n1 = true) ∧ (∀(r3n2 : C.ptr (BitVec 64)), C.offset r3n2 = C.offset r3n1 ∧ C.min r3n2 = C.min r3n1 ∧ C.writable r3n2 = C.writable r3n1 ∧ C.zone1 r3n2 = C.zone1 r3n1 → (∀(r4n : C.ptr (BitVec 64)), C.writable r4n = true ∧ C.offset r4n = C.offset r3n2 + BitVec.toInt n ∧ C.max r3n2 = C.offset r3n2 + BitVec.toInt n ∧ C.min r4n = C.offset r3n2 + BitVec.toInt n ∧ C.max r4n = C.max r3n1 ∧ C.zone1 r4n = C.zone1 r3n2 ∧ C.pelts r3n2 = C.pelts r3n1 ∧ C.plength r3n2 = C.plength r3n1 ∧ C.pelts r4n = C.pelts r3n1 ∧ C.plength r4n = C.plength r3n1 → ((0 : ℤ) ≤ BitVec.toInt n ∧ C.valid r1n (BitVec.toInt n) ∧ C.valid r3n2 (BitVec.toInt n) ∧ C.writable r1n = true) ∧ (∀(r1n1 : C.ptr (BitVec 64)), List.length (C.data r1n1) = List.length (C.data r1n) ∧ C.offset r1n1 = C.offset r1n ∧ C.min r1n1 = C.min r1n ∧ C.max r1n1 = C.max r1n ∧ C.writable r1n1 = C.writable r1n ∧ C.zone1 r1n1 = C.zone1 r1n → (∀(bo1 : BitVec 64), Lemmas.value r1n1 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt bo1 = Lemmas.value r1n (BitVec.toInt n) - Lemmas.value r3n2 (BitVec.toInt n) ∧ ((0 : ℤ) ≤ BitVec.toUInt bo1 ∧ BitVec.toUInt bo1 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r1n1 ∨ C.offset r1n1 + BitVec.toInt n ≤ j → C.pelts r1n1 j = C.pelts r1n j) → (C.min vy21 ≤ C.offset vy21 + BitVec.toInt n ∧ C.offset vy21 + BitVec.toInt n < C.max vy21) ∧ (let ly2 : BitVec 64 := C.pelts vy21 (C.offset vy21 + BitVec.toInt n); uint'64_in_bounds (BitVec.toUInt ly2 + BitVec.toUInt bo1) ∧ (∀(o12 : BitVec 64), BitVec.toUInt o12 = BitVec.toUInt ly2 + BitVec.toUInt bo1 → BitVec.toUInt o12 ≤ (9223372036854775807 : ℤ) ∧ (∀(o13 : BitVec 64), BitVec.toInt o13 = BitVec.toUInt o12 → ((0 : ℤ) ≤ BitVec.toInt n ∧ C.valid xm15 (BitVec.toInt n) ∧ C.valid r9 (BitVec.toInt n) ∧ C.writable xm15 = true) ∧ (∀(r2n : C.ptr (BitVec 64)), List.length (C.data r2n) = List.length (C.data xm15) ∧ C.offset r2n = C.offset xm15 ∧ C.min r2n = C.min xm15 ∧ C.max r2n = C.max xm15 ∧ C.writable r2n = C.writable xm15 ∧ C.zone1 r2n = C.zone1 xm15 → (∀(bo2 : BitVec 64), Lemmas.value r2n (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt bo2 = Lemmas.value xm15 (BitVec.toInt n) - Lemmas.value r9 (BitVec.toInt n) ∧ ((0 : ℤ) ≤ BitVec.toUInt bo2 ∧ BitVec.toUInt bo2 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r2n ∨ C.offset r2n + BitVec.toInt n ≤ j → C.pelts r2n j = C.pelts xm15 j) → (C.valid r2n (BitVec.toInt n) ∧ (0 : ℤ) < BitVec.toInt n ∧ C.writable r2n = true) ∧ (∀(r2n1 : C.ptr (BitVec 64)), List.length (C.data r2n1) = List.length (C.data r2n) ∧ C.offset r2n1 = C.offset r2n ∧ C.min r2n1 = C.min r2n ∧ C.max r2n1 = C.max r2n ∧ C.writable r2n1 = C.writable r2n ∧ C.zone1 r2n1 = C.zone1 r2n → (∀(bo2' : BitVec 64), Lemmas.value r2n1 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt bo2' = Lemmas.value r2n (BitVec.toInt n) - BitVec.toUInt bo1 ∧ ((0 : ℤ) ≤ BitVec.toUInt bo2' ∧ BitVec.toUInt bo2' ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r2n1 ∨ C.offset r2n1 + BitVec.toInt n ≤ j → C.pelts r2n1 j = C.pelts r2n j) → uint'64_in_bounds (BitVec.toUInt bo2 + BitVec.toUInt bo2') ∧ (∀(o14 : BitVec 64), BitVec.toUInt o14 = BitVec.toUInt bo2 + BitVec.toUInt bo2' → (C.valid vy21 (BitVec.toInt n) ∧ C.valid r1n1 (BitVec.toInt n) ∧ C.valid r3n2 (BitVec.toInt n) ∧ C.writable r3n2 = true) ∧ (∀(r3n3 : C.ptr (BitVec 64)), List.length (C.data r3n3) = List.length (C.data r3n2) ∧ C.offset r3n3 = C.offset r3n2 ∧ C.min r3n3 = C.min r3n2 ∧ C.max r3n3 = C.max r3n2 ∧ C.writable r3n3 = C.writable r3n2 ∧ C.zone1 r3n3 = C.zone1 r3n2 → (∀(bo3 : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt bo3 ∧ BitVec.toUInt bo3 ≤ (1 : ℤ)) ∧ Lemmas.value r3n3 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt bo3 = Lemmas.value vy21 (BitVec.toInt n) - Lemmas.value r1n1 (BitVec.toInt n) ∧ (∀(j : ℤ), j < C.offset r3n3 ∨ C.offset r3n3 + BitVec.toInt n ≤ j → C.pelts r3n3 j = C.pelts r3n2 j) → (C.valid r3n3 (BitVec.toInt n) ∧ (0 : ℤ) < BitVec.toInt n ∧ C.writable r3n3 = true) ∧ (∀(r3n4 : C.ptr (BitVec 64)), List.length (C.data r3n4) = List.length (C.data r3n3) ∧ C.offset r3n4 = C.offset r3n3 ∧ C.min r3n4 = C.min r3n3 ∧ C.max r3n4 = C.max r3n3 ∧ C.writable r3n4 = C.writable r3n3 ∧ C.zone1 r3n4 = C.zone1 r3n3 → (∀(bo3' : BitVec 64), Lemmas.value r3n4 (BitVec.toInt n) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt n)) * BitVec.toUInt bo3' = Lemmas.value r3n3 (BitVec.toInt n) - BitVec.toUInt o14 ∧ ((0 : ℤ) ≤ BitVec.toUInt bo3' ∧ BitVec.toUInt bo3' ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r3n4 ∨ C.offset r3n4 + BitVec.toInt n ≤ j → C.pelts r3n4 j = C.pelts r3n3 j) → uint'64_in_bounds (BitVec.toUInt bo3 + BitVec.toUInt bo3') ∧ (∀(o15 : BitVec 64), BitVec.toUInt o15 = BitVec.toUInt bo3 + BitVec.toUInt bo3' → BitVec.toUInt o15 ≤ (9223372036854775807 : ℤ) ∧ (∀(o16 : BitVec 64), BitVec.toInt o16 = BitVec.toUInt o15 → int'64_in_bounds (BitVec.toInt o13 - BitVec.toInt o16) ∧ (∀(o17 : BitVec 64), BitVec.toInt o17 = BitVec.toInt o13 - BitVec.toInt o16 → (C.zone1 r2n1 = C.zone1 r3n4 ∧ C.max r2n1 = C.min r3n4 ∧ C.writable r2n1 = true ∧ C.writable r3n4 = true) ∧ (∀(r2n2 : C.ptr (BitVec 64)), List.length (C.data r2n2) = List.length (C.data r2n1) ∧ C.offset r2n2 = C.offset r2n1 ∧ C.min r2n2 = C.min r2n1 ∧ C.writable r2n2 = C.writable r2n1 ∧ C.zone1 r2n2 = C.zone1 r2n1 → C.max r2n2 = C.max r3n4 ∧ C.plength r2n2 = C.plength r2n1 ∧ (∀(i : ℤ), C.min r2n1 ≤ i ∧ i < C.max r2n1 → C.pelts r2n2 i = C.pelts r2n1 i) ∧ (∀(i : ℤ), C.min r3n4 ≤ i ∧ i < C.max r3n4 → C.pelts r2n2 i = C.pelts r3n4 i) → (C.zone1 r1n1 = C.zone1 r2n2 ∧ C.max r1n1 = C.min r2n2 ∧ C.writable r1n1 = true ∧ C.writable r2n2 = true) ∧ (∀(r1n2 : C.ptr (BitVec 64)), List.length (C.data r1n2) = List.length (C.data r1n1) ∧ C.offset r1n2 = C.offset r1n1 ∧ C.min r1n2 = C.min r1n1 ∧ C.writable r1n2 = C.writable r1n1 ∧ C.zone1 r1n2 = C.zone1 r1n1 → C.max r1n2 = C.max r2n2 ∧ C.plength r1n2 = C.plength r1n1 ∧ (∀(i : ℤ), C.min r1n1 ≤ i ∧ i < C.max r1n1 → C.pelts r1n2 i = C.pelts r1n1 i) ∧ (∀(i : ℤ), C.min r2n2 ≤ i ∧ i < C.max r2n2 → C.pelts r1n2 i = C.pelts r2n2 i) → int'32_in_bounds ((3 : ℤ) * BitVec.toInt n) ∧ (∀(o18 : BitVec 32), BitVec.toInt o18 = (3 : ℤ) * BitVec.toInt n → (((0 : ℤ) ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ BitVec.toInt o18) ∧ C.valid r1n2 (BitVec.toInt o18) ∧ C.valid scratch7 (BitVec.toInt n) ∧ C.writable r1n2 = true) ∧ (∀(r1n3 : C.ptr (BitVec 64)), List.length (C.data r1n3) = List.length (C.data r1n2) ∧ C.offset r1n3 = C.offset r1n2 ∧ C.min r1n3 = C.min r1n2 ∧ C.max r1n3 = C.max r1n2 ∧ C.writable r1n3 = C.writable r1n2 ∧ C.zone1 r1n3 = C.zone1 r1n2 → (∀(c : BitVec 64), Lemmas.value r1n3 (BitVec.toInt o18) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o18)) * BitVec.toUInt c = Lemmas.value r1n2 (BitVec.toInt o18) + Lemmas.value scratch7 (BitVec.toInt n) ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r1n3 ∨ C.offset r1n3 + BitVec.toInt o18 ≤ j → C.pelts r1n3 j = C.pelts r1n2 j) → BitVec.toUInt c ≤ (9223372036854775807 : ℤ) ∧ (∀(o19 : BitVec 64), BitVec.toInt o19 = BitVec.toUInt c → int'64_in_bounds (BitVec.toInt o17 + BitVec.toInt o19) ∧ (∀(o20 : BitVec 64), BitVec.toInt o20 = BitVec.toInt o17 + BitVec.toInt o19 → (C.zone1 r9 = C.zone1 r1n3 ∧ C.max r9 = C.min r1n3 ∧ C.writable r9 = true ∧ C.writable r1n3 = true) ∧ (∀(r10 : C.ptr (BitVec 64)), List.length (C.data r10) = List.length (C.data r9) ∧ C.offset r10 = C.offset r9 ∧ C.min r10 = C.min r9 ∧ C.writable r10 = C.writable r9 ∧ C.zone1 r10 = C.zone1 r9 → C.max r10 = C.max r1n3 ∧ C.plength r10 = C.plength r9 ∧ (∀(i : ℤ), C.min r9 ≤ i ∧ i < C.max r9 → C.pelts r10 i = C.pelts r9 i) ∧ (∀(i : ℤ), C.min r1n3 ≤ i ∧ i < C.max r1n3 → C.pelts r10 i = C.pelts r1n3 i) → int'32_in_bounds (BitVec.toInt s + BitVec.toInt t) ∧ (∀(o21 : BitVec 32), BitVec.toInt o21 = BitVec.toInt s + BitVec.toInt t → int'32_in_bounds (BitVec.toInt o21 - BitVec.toInt n) ∧ (∀(rs : BitVec 32), BitVec.toInt rs = BitVec.toInt o21 - BitVec.toInt n → (int'32_in_bounds (BitVec.toInt s + BitVec.toInt t) ∧ (∀(o22 : BitVec 32), BitVec.toInt o22 = BitVec.toInt s + BitVec.toInt t → (if BitVec.toInt n < BitVec.toInt o22 then int'32_in_bounds ((2 : ℤ) * BitVec.toInt n) ∧ (∀(o23 : BitVec 32), BitVec.toInt o23 = (2 : ℤ) * BitVec.toInt n → (C.min r10 ≤ C.offset r10 + BitVec.toInt o23 ∧ C.offset r10 + BitVec.toInt o23 ≤ C.max r10) ∧ (∀(r2n3 : C.ptr (BitVec 64)), C.offset r2n3 = C.offset r10 + BitVec.toInt o23 ∧ C.plength r2n3 = C.plength r10 ∧ C.pelts r2n3 = C.pelts r10 ∧ C.data r2n3 = C.data r10 ∧ C.min r2n3 = C.min r10 ∧ C.max r2n3 = C.max r10 ∧ C.zone1 r2n3 = C.zone1 r10 ∧ C.writable r2n3 = C.writable r10 → int'32_in_bounds ((2 : ℤ) * BitVec.toInt n) ∧ (∀(o24 : BitVec 32), BitVec.toInt o24 = (2 : ℤ) * BitVec.toInt n → (((0 : ℤ) ≤ BitVec.toInt rs ∧ BitVec.toInt rs ≤ BitVec.toInt o24) ∧ C.valid r2n3 (BitVec.toInt o24) ∧ C.valid r4n (BitVec.toInt rs) ∧ C.writable r2n3 = true) ∧ (∀(r2n4 : C.ptr (BitVec 64)) (r11 : C.ptr (BitVec 64)), C.data r2n4 = C.data r11 ∧ List.length (C.data r11) = List.length (C.data r2n3) ∧ C.offset r2n4 = C.offset r2n3 ∧ C.min r2n4 = C.min r2n3 ∧ C.max r2n4 = C.max r2n3 ∧ C.writable r2n4 = C.writable r2n3 ∧ C.zone1 r2n4 = C.zone1 r2n3 → List.length (C.data r11) = List.length (C.data r10) ∧ C.offset r11 = C.offset r10 ∧ C.min r11 = C.min r10 ∧ C.max r11 = C.max r10 ∧ C.writable r11 = C.writable r10 ∧ C.zone1 r11 = C.zone1 r10 → (∀(b : BitVec 64), Lemmas.value r2n4 (BitVec.toInt o24) - HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o24)) * BitVec.toUInt b = Lemmas.value r2n3 (BitVec.toInt o24) - Lemmas.value r4n (BitVec.toInt rs) ∧ ((0 : ℤ) ≤ BitVec.toUInt b ∧ BitVec.toUInt b ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r2n4 ∨ C.offset r2n4 + BitVec.toInt o24 ≤ j → C.pelts r2n4 j = C.pelts r2n3 j) → BitVec.toUInt b ≤ (9223372036854775807 : ℤ) ∧ (∀(o25 : BitVec 64), BitVec.toInt o25 = BitVec.toUInt b → int'64_in_bounds (BitVec.toInt o20 - BitVec.toInt o25) ∧ (∀(o26 : BitVec 64), BitVec.toInt o26 = BitVec.toInt o20 - BitVec.toInt o25 → (if BitVec.toInt o26 < (0 : ℤ) then int'64_in_bounds (-BitVec.toInt o26) ∧ (∀(o27 : BitVec 64), BitVec.toInt o27 = -BitVec.toInt o26 → (0 : ℤ) ≤ BitVec.toInt o27 ∧ (∀(o28 : BitVec 64), BitVec.toUInt o28 = BitVec.toInt o27 → (C.valid r4n (BitVec.toInt rs) ∧ (0 : ℤ) < BitVec.toInt rs ∧ (0 : ℤ) ≤ Lemmas.value r4n (BitVec.toInt rs) - BitVec.toUInt o28 ∧ C.writable r4n = true) ∧ (∀(r4n1 : C.ptr (BitVec 64)), List.length (C.data r4n1) = List.length (C.data r4n) ∧ C.offset r4n1 = C.offset r4n ∧ C.min r4n1 = C.min r4n ∧ C.max r4n1 = C.max r4n ∧ C.writable r4n1 = C.writable r4n ∧ C.zone1 r4n1 = C.zone1 r4n → Lemmas.value r4n1 (BitVec.toInt rs) = Lemmas.value r4n (BitVec.toInt rs) - BitVec.toUInt o28 ∧ (∀(j : ℤ), j < C.offset r4n1 ∨ C.offset r4n1 + BitVec.toInt rs ≤ j → C.pelts r4n1 j = C.pelts r4n j) → Lemmas.value r11 ((4 : ℤ) * BitVec.toInt n) + m * m * m * m * Lemmas.value r4n1 (BitVec.toInt rs) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt sy)))) else (0 : ℤ) ≤ BitVec.toInt o26 ∧ (∀(o27 : BitVec 64), BitVec.toUInt o27 = BitVec.toInt o26 → (C.valid r4n (BitVec.toInt rs) ∧ (0 : ℤ) < BitVec.toInt rs ∧ Lemmas.value r4n (BitVec.toInt rs) + BitVec.toUInt o27 < HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt rs)) ∧ C.writable r4n = true) ∧ (∀(r4n1 : C.ptr (BitVec 64)), List.length (C.data r4n1) = List.length (C.data r4n) ∧ C.offset r4n1 = C.offset r4n ∧ C.min r4n1 = C.min r4n ∧ C.max r4n1 = C.max r4n ∧ C.writable r4n1 = C.writable r4n ∧ C.zone1 r4n1 = C.zone1 r4n → Lemmas.value r4n1 (BitVec.toInt rs) = Lemmas.value r4n (BitVec.toInt rs) + BitVec.toUInt o27 ∧ (∀(j : ℤ), j < C.offset r4n1 ∨ C.offset r4n1 + BitVec.toInt rs ≤ j → C.pelts r4n1 j = C.pelts r4n j) → Lemmas.value r11 ((4 : ℤ) * BitVec.toInt n) + m * m * m * m * Lemmas.value r4n1 (BitVec.toInt rs) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt sy))))))))))) else Lemmas.value r10 ((4 : ℤ) * BitVec.toInt n) + m * m * m * m * Lemmas.value r4n (BitVec.toInt rs) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt sy)))) ∧ (∀(r4n1 : C.ptr (BitVec 64)) (r11 : C.ptr (BitVec 64)), List.length (C.data r4n1) = List.length (C.data r4n) ∧ C.offset r4n1 = C.offset r4n ∧ C.min r4n1 = C.min r4n ∧ C.max r4n1 = C.max r4n ∧ C.writable r4n1 = C.writable r4n ∧ C.zone1 r4n1 = C.zone1 r4n → List.length (C.data r11) = List.length (C.data r10) ∧ C.offset r11 = C.offset r10 ∧ C.min r11 = C.min r10 ∧ C.max r11 = C.max r10 ∧ C.writable r11 = C.writable r10 ∧ C.zone1 r11 = C.zone1 r10 → Lemmas.value r11 ((4 : ℤ) * BitVec.toInt n) + m * m * m * m * Lemmas.value r4n1 (BitVec.toInt rs) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt sy) → (C.zone1 r11 = C.zone1 r4n1 ∧ C.max r11 = C.min r4n1 ∧ C.writable r11 = true ∧ C.writable r4n1 = true) ∧ (∀(r12 : C.ptr (BitVec 64)), List.length (C.data r12) = List.length (C.data r11) ∧ C.offset r12 = C.offset r11 ∧ C.min r12 = C.min r11 ∧ C.writable r12 = C.writable r11 ∧ C.zone1 r12 = C.zone1 r11 → C.max r12 = C.max r4n1 ∧ C.plength r12 = C.plength r11 ∧ (∀(i : ℤ), C.min r11 ≤ i ∧ i < C.max r11 → C.pelts r12 i = C.pelts r11 i) ∧ (∀(i : ℤ), C.min r4n1 ≤ i ∧ i < C.max r4n1 → C.pelts r12 i = C.pelts r4n1 i) → (C.zone1 scratch7 = C.zone1 vy21 ∧ C.max scratch7 = C.min vy21 ∧ C.writable scratch7 = true ∧ C.writable vy21 = true) ∧ (∀(scratch8 : C.ptr (BitVec 64)), List.length (C.data scratch8) = List.length (C.data scratch7) ∧ C.offset scratch8 = C.offset scratch7 ∧ C.min scratch8 = C.min scratch7 ∧ C.writable scratch8 = C.writable scratch7 ∧ C.zone1 scratch8 = C.zone1 scratch7 → C.max scratch8 = C.max vy21 ∧ C.plength scratch8 = C.plength scratch7 ∧ (∀(i : ℤ), C.min scratch7 ≤ i ∧ i < C.max scratch7 → C.pelts scratch8 i = C.pelts scratch7 i) ∧ (∀(i : ℤ), C.min vy21 ≤ i ∧ i < C.max vy21 → C.pelts scratch8 i = C.pelts vy21 i) → (C.zone1 scratch8 = C.zone1 sor3 ∧ C.max scratch8 = C.min sor3 ∧ C.writable scratch8 = true ∧ C.writable sor3 = true) ∧ (∀(scratch9 : C.ptr (BitVec 64)), List.length (C.data scratch9) = List.length (C.data scratch8) ∧ C.offset scratch9 = C.offset scratch8 ∧ C.min scratch9 = C.min scratch8 ∧ C.writable scratch9 = C.writable scratch8 ∧ C.zone1 scratch9 = C.zone1 scratch8 → C.max scratch9 = C.max sor3 ∧ C.plength scratch9 = C.plength scratch8 ∧ (∀(i : ℤ), C.min scratch8 ≤ i ∧ i < C.max scratch8 → C.pelts scratch9 i = C.pelts scratch8 i) ∧ (∀(i : ℤ), C.min sor3 ≤ i ∧ i < C.max sor3 → C.pelts scratch9 i = C.pelts sor3 i) → (C.zone1 sol = C.zone1 scratch9 ∧ C.max sol = C.min scratch9 ∧ C.writable sol = true ∧ C.writable scratch9 = true) ∧ (∀(scratch10 : C.ptr (BitVec 64)), List.length (C.data scratch10) = List.length (C.data scratch9) ∧ C.offset scratch10 = C.offset scratch9 ∧ C.max scratch10 = C.max scratch9 ∧ C.writable scratch10 = C.writable scratch9 ∧ C.zone1 scratch10 = C.zone1 scratch9 → C.min scratch10 = C.min sol ∧ C.plength scratch10 = C.plength scratch9 ∧ (∀(i : ℤ), C.min sol ≤ i ∧ i < C.max sol → C.pelts scratch10 i = C.pelts sol i) ∧ (∀(i : ℤ), C.min scratch9 ≤ i ∧ i < C.max scratch9 → C.pelts scratch10 i = C.pelts scratch9 i) → (C.zone1 r12 = C.zone1 ror ∧ C.max r12 = C.min ror ∧ C.writable r12 = true ∧ C.writable ror = true) ∧ (∀(r13 : C.ptr (BitVec 64)), List.length (C.data r13) = List.length (C.data r12) ∧ C.offset r13 = C.offset r12 ∧ C.min r13 = C.min r12 ∧ C.writable r13 = C.writable r12 ∧ C.zone1 r13 = C.zone1 r12 → C.max r13 = C.max ror ∧ C.plength r13 = C.plength r12 ∧ (∀(i : ℤ), C.min r12 ≤ i ∧ i < C.max r12 → C.pelts r13 i = C.pelts r12 i) ∧ (∀(i : ℤ), C.min ror ≤ i ∧ i < C.max ror → C.pelts r13 i = C.pelts ror i) → (C.zone1 rol = C.zone1 r13 ∧ C.max rol = C.min r13 ∧ C.writable rol = true ∧ C.writable r13 = true) ∧ (∀(r14 : C.ptr (BitVec 64)), List.length (C.data r14) = List.length (C.data r13) ∧ C.offset r14 = C.offset r13 ∧ C.max r14 = C.max r13 ∧ C.writable r14 = C.writable r13 ∧ C.zone1 r14 = C.zone1 r13 → C.min r14 = C.min rol ∧ C.plength r14 = C.plength r13 ∧ (∀(i : ℤ), C.min rol ≤ i ∧ i < C.max rol → C.pelts r14 i = C.pelts rol i) ∧ (∀(i : ℤ), C.min r13 ≤ i ∧ i < C.max r13 → C.pelts r14 i = C.pelts r13 i) → C.min r14 = C.min r ∧ C.max r14 = C.max r ∧ C.plength r14 = C.plength r ∧ C.min scratch10 = C.min scratch ∧ C.max scratch10 = C.max scratch ∧ C.plength scratch10 = C.plength scratch ∧ Lemmas.value r14 (BitVec.toInt sx + BitVec.toInt sy) = Lemmas.value x (BitVec.toInt sx) * Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), C.min r14 ≤ j ∧ j < C.offset r14 ∨ C.offset r14 + BitVec.toInt sx + BitVec.toInt sy ≤ j ∧ j < C.max r14 → C.pelts r14 j = C.pelts r j) ∧ (∀(j : ℤ), C.min scratch10 ≤ j ∧ j < C.offset scratch10 → C.pelts scratch10 j = C.pelts scratch j)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
  := sorry
end toom_Toom_wmpn_toom32_mulqtvc
