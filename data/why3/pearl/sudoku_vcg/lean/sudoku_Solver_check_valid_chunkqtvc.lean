import Why3.Base
import pearl.sudoku_vcg.lean.sudoku.Grid
open Classical
open Lean4Why3
namespace sudoku_Solver_check_valid_chunkqtvc
noncomputable def valid_chunk_up_to (g : ℤ -> ℤ) (i : ℤ) (start : List ℤ) (offsets : List ℤ) (off : ℤ) := let s : ℤ := start[Int.toNat i]!; ∀(o1 : ℤ) (o2 : ℤ), ((0 : ℤ) ≤ o1 ∧ o1 < off) ∧ ((0 : ℤ) ≤ o2 ∧ o2 < off) ∧ ¬o1 = o2 → (let i1 : ℤ := s + offsets[Int.toNat o1]!; let i2 : ℤ := s + offsets[Int.toNat o2]!; ((1 : ℤ) ≤ g i1 ∧ g i1 ≤ (9 : ℤ)) ∧ (1 : ℤ) ≤ g i2 ∧ g i2 ≤ (9 : ℤ) → ¬g i1 = g i2)
theorem check_valid_chunk'vc (g : List ℤ) (i : ℤ) (start : List ℤ) (offsets : List ℤ) (fact0 : Int.ofNat (List.length g) = (81 : ℤ)) (fact1 : Grid.valid_values (getElem! g ∘ Int.toNat)) (fact2 : Grid.is_index i) (fact3 : Grid.chunk_valid_indexes start offsets) : (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length start) ∧ (let s : ℤ := start[Int.toNat i]!; (0 : ℤ) ≤ (10 : ℤ) ∧ (∀(b : List Bool), (∀(i1 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < (10 : ℤ) → b[Int.toNat i1]! = false) ∧ Int.ofNat (List.length b) = (10 : ℤ) → ((0 : ℤ) ≤ (8 : ℤ) + (1 : ℤ) → (valid_chunk_up_to (getElem! g ∘ Int.toNat) i start offsets (0 : ℤ) ∧ (∀(o1 : ℤ), (0 : ℤ) ≤ o1 ∧ o1 < (0 : ℤ) → (let v : ℤ := g[Int.toNat (s + offsets[Int.toNat o1]!)]!; (1 : ℤ) ≤ v ∧ v ≤ (9 : ℤ) → b[Int.toNat v]! = true)) ∧ (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j ≤ (9 : ℤ) → b[Int.toNat j]! = true → (∃(o1 : ℤ), ((0 : ℤ) ≤ o1 ∧ o1 < (0 : ℤ)) ∧ (getElem! g ∘ Int.toNat) (s + offsets[Int.toNat o1]!) = j))) ∧ (∀(b1 : List Bool), List.length b1 = List.length b → (∀(off : ℤ), ((0 : ℤ) ≤ off ∧ off ≤ (8 : ℤ)) ∧ valid_chunk_up_to (getElem! g ∘ Int.toNat) i start offsets off ∧ (∀(o1 : ℤ), (0 : ℤ) ≤ o1 ∧ o1 < off → (let v : ℤ := g[Int.toNat (s + offsets[Int.toNat o1]!)]!; (1 : ℤ) ≤ v ∧ v ≤ (9 : ℤ) → b1[Int.toNat v]! = true)) ∧ (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j ≤ (9 : ℤ) → b1[Int.toNat j]! = true → (∃(o1 : ℤ), ((0 : ℤ) ≤ o1 ∧ o1 < off) ∧ (getElem! g ∘ Int.toNat) (s + offsets[Int.toNat o1]!) = j)) → ((0 : ℤ) ≤ off ∧ off < Int.ofNat (List.length offsets)) ∧ (let o1 : ℤ := s + offsets[Int.toNat off]!; ((0 : ℤ) ≤ o1 ∧ o1 < Int.ofNat (List.length g)) ∧ (let v : ℤ := g[Int.toNat o1]!; ∀(o2 : Bool), (if (1 : ℤ) ≤ v then o2 = (if v ≤ (9 : ℤ) then true else false) else o2 = false) → (if o2 = true then ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length b1)) ∧ (if b1[Int.toNat v]! = true then ¬Grid.valid_chunk (getElem! g ∘ Int.toNat) i start offsets else let o3 : Bool := true; ((0 : ℤ) ≤ v ∧ v < Int.ofNat (List.length b1)) ∧ (List.length (List.set b1 (Int.toNat v) o3) = List.length b1 → getElem! (List.set b1 (Int.toNat v) o3) ∘ Int.toNat = Function.update (getElem! b1 ∘ Int.toNat) v o3 → valid_chunk_up_to (getElem! g ∘ Int.toNat) i start offsets (off + (1 : ℤ)) ∧ (∀(o4 : ℤ), (0 : ℤ) ≤ o4 ∧ o4 < off + (1 : ℤ) → (let v1 : ℤ := g[Int.toNat (s + offsets[Int.toNat o4]!)]!; (1 : ℤ) ≤ v1 ∧ v1 ≤ (9 : ℤ) → (List.set b1 (Int.toNat v) o3)[Int.toNat v1]! = true)) ∧ (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j ≤ (9 : ℤ) → (List.set b1 (Int.toNat v) o3)[Int.toNat j]! = true → (∃(o4 : ℤ), ((0 : ℤ) ≤ o4 ∧ o4 < off + (1 : ℤ)) ∧ (getElem! g ∘ Int.toNat) (s + offsets[Int.toNat o4]!) = j)))) else valid_chunk_up_to (getElem! g ∘ Int.toNat) i start offsets (off + (1 : ℤ)) ∧ (∀(o3 : ℤ), (0 : ℤ) ≤ o3 ∧ o3 < off + (1 : ℤ) → (let v1 : ℤ := g[Int.toNat (s + offsets[Int.toNat o3]!)]!; (1 : ℤ) ≤ v1 ∧ v1 ≤ (9 : ℤ) → b1[Int.toNat v1]! = true)) ∧ (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j ≤ (9 : ℤ) → b1[Int.toNat j]! = true → (∃(o3 : ℤ), ((0 : ℤ) ≤ o3 ∧ o3 < off + (1 : ℤ)) ∧ (getElem! g ∘ Int.toNat) (s + offsets[Int.toNat o3]!) = j)))))) ∧ (valid_chunk_up_to (getElem! g ∘ Int.toNat) i start offsets ((8 : ℤ) + (1 : ℤ)) ∧ (∀(o1 : ℤ), (0 : ℤ) ≤ o1 ∧ o1 < (8 : ℤ) + (1 : ℤ) → (let v : ℤ := g[Int.toNat (s + offsets[Int.toNat o1]!)]!; (1 : ℤ) ≤ v ∧ v ≤ (9 : ℤ) → b1[Int.toNat v]! = true)) ∧ (∀(j : ℤ), (1 : ℤ) ≤ j ∧ j ≤ (9 : ℤ) → b1[Int.toNat j]! = true → (∃(o1 : ℤ), ((0 : ℤ) ≤ o1 ∧ o1 < (8 : ℤ) + (1 : ℤ)) ∧ (getElem! g ∘ Int.toNat) (s + offsets[Int.toNat o1]!) = j)) → Grid.valid_chunk (getElem! g ∘ Int.toNat) i start offsets))) ∧ ((8 : ℤ) + (1 : ℤ) < (0 : ℤ) → Grid.valid_chunk (getElem! g ∘ Int.toNat) i start offsets)))
  := sorry
end sudoku_Solver_check_valid_chunkqtvc
