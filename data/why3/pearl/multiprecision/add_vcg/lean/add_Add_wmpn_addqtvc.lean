import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.c.C
import Why3.mach.int.Unsigned
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.ptralias.Alias
open Classical
open Lean4Why3
namespace add_Add_wmpn_addqtvc
theorem wmpn_add'vc (sy : BitVec 32) (sx : BitVec 32) (r : C.ptr (BitVec 64)) (x : C.ptr (BitVec 64)) (y : C.ptr (BitVec 64)) (fact0 : (0 : ℤ) ≤ BitVec.toInt sy) (fact1 : BitVec.toInt sy ≤ BitVec.toInt sx) (fact2 : C.valid r (BitVec.toInt sx)) (fact3 : C.valid x (BitVec.toInt sx)) (fact4 : C.valid y (BitVec.toInt sy)) (fact5 : C.offset r = C.offset x ∨ C.offset r + BitVec.toInt sx ≤ C.offset x ∨ C.offset x + BitVec.toInt sx ≤ C.offset r) (fact6 : C.offset r = C.offset y ∨ C.offset r + BitVec.toInt sx ≤ C.offset y ∨ C.offset y + BitVec.toInt sy ≤ C.offset r) (fact7 : C.data r = C.data x) (fact8 : C.data x = C.data y) (fact9 : C.writable r = true) : (0 : ℤ) ≤ BitVec.toInt sy ∧ C.valid r (BitVec.toInt sy) ∧ C.valid x (BitVec.toInt sy) ∧ C.valid y (BitVec.toInt sy) ∧ (C.offset r = C.offset x ∨ C.offset r + BitVec.toInt sy ≤ C.offset x ∨ C.offset x + BitVec.toInt sy ≤ C.offset r) ∧ (C.offset r = C.offset y ∨ C.offset r + BitVec.toInt sy ≤ C.offset y ∨ C.offset y + BitVec.toInt sy ≤ C.offset r) ∧ C.data r = C.data x ∧ C.data x = C.data y ∧ C.writable r = true ∧ (∀(y1 : C.ptr (BitVec 64)) (x1 : C.ptr (BitVec 64)) (r1 : C.ptr (BitVec 64)), C.data y1 = C.data r1 ∧ List.length (C.data r1) = List.length (C.data y) ∧ C.offset y1 = C.offset y ∧ C.min y1 = C.min y ∧ C.max y1 = C.max y ∧ C.writable y1 = C.writable y ∧ C.zone1 y1 = C.zone1 y → C.data x1 = C.data r1 ∧ List.length (C.data r1) = List.length (C.data x) ∧ C.offset x1 = C.offset x ∧ C.min x1 = C.min x ∧ C.max x1 = C.max x ∧ C.writable x1 = C.writable x ∧ C.zone1 x1 = C.zone1 x → List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → (∀(o1 : BitVec 64), Lemmas.value r1 (BitVec.toInt sy) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sy)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt sy) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sy ≤ j → C.pelts r1 j = C.pelts r j) ∧ (C.offset r1 = C.offset x1 ∨ MapEq.map_eq_sub (C.pelts x1) (C.pelts x) (C.offset x1) (C.offset x1 + BitVec.toInt sy)) ∧ (C.offset r1 = C.offset y1 ∨ MapEq.map_eq_sub (C.pelts y1) (C.pelts y) (C.offset y1) (C.offset y1 + BitVec.toInt sy)) → (∀(o2 : Bool), (BitVec.toUInt o1 = BitVec.toUInt (0 : BitVec 64) → o2 = true) ∧ (o2 = true → o1 = (0 : BitVec 64)) → (if ¬o2 = true then ((BitVec.toInt sy ≤ BitVec.toInt sy ∧ BitVec.toInt sy ≤ BitVec.toInt sx) ∧ Lemmas.value r1 (BitVec.toInt sy) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sy)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt sy) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sy ≤ j → C.pelts r1 j = C.pelts r j) ∧ C.pelts x1 = C.pelts r1 ∧ C.pelts y1 = C.pelts r1 ∧ (C.offset r1 = C.offset x1 ∨ MapEq.map_eq_sub (C.pelts x1) (C.pelts x) (C.offset x1) (C.offset x1 + BitVec.toInt sx)) ∧ (C.offset r1 = C.offset y1 ∨ MapEq.map_eq_sub (C.pelts y1) (C.pelts y) (C.offset y1) (C.offset y1 + BitVec.toInt sy)) ∧ ((0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (1 : ℤ)) ∧ (sy = sx ∨ BitVec.toUInt o1 = (1 : ℤ))) ∧ (∀(i : BitVec 32) (c : BitVec 64) (y2 : C.ptr (BitVec 64)) (x2 : C.ptr (BitVec 64)) (r2 : C.ptr (BitVec 64)), C.data y2 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data y1) ∧ C.offset y2 = C.offset y1 ∧ C.min y2 = C.min y1 ∧ C.max y2 = C.max y1 ∧ C.writable y2 = C.writable y1 ∧ C.zone1 y2 = C.zone1 y1 → C.data x2 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data x1) ∧ C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.max x2 = C.max x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → List.length (C.data r2) = List.length (C.data r1) ∧ C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.max r2 = C.max r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → (BitVec.toInt sy ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sx) ∧ Lemmas.value r2 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt i) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt i ≤ j → C.pelts r2 j = C.pelts r j) ∧ C.pelts x2 = C.pelts r2 ∧ C.pelts y2 = C.pelts r2 ∧ (C.offset r2 = C.offset x2 ∨ MapEq.map_eq_sub (C.pelts x2) (C.pelts x) (C.offset x2) (C.offset x2 + BitVec.toInt sx)) ∧ (C.offset r2 = C.offset y2 ∨ MapEq.map_eq_sub (C.pelts y2) (C.pelts y) (C.offset y2) (C.offset y2 + BitVec.toInt sy)) ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (i = sx ∨ BitVec.toUInt c = (1 : ℤ)) → (if BitVec.toInt i < BitVec.toInt sx then (C.min x2 ≤ C.offset x2 + BitVec.toInt i ∧ C.offset x2 + BitVec.toInt i < C.max x2) ∧ (C.min x ≤ C.offset x + BitVec.toInt i ∧ C.offset x + BitVec.toInt i < C.max x) ∧ (∀(res : BitVec 64), BitVec.toUInt res = (BitVec.toUInt (C.pelts x2 (C.offset x2 + BitVec.toInt i)) + (1 : ℤ)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → ((C.min r2 ≤ C.offset r2 + BitVec.toInt i ∧ C.offset r2 + BitVec.toInt i < C.max r2) ∧ C.writable r2 = true) ∧ (∀(y3 : C.ptr (BitVec 64)) (x3 : C.ptr (BitVec 64)) (r3 : C.ptr (BitVec 64)), C.data y3 = C.data r3 ∧ List.length (C.data r3) = List.length (C.data y2) ∧ C.offset y3 = C.offset y2 ∧ C.min y3 = C.min y2 ∧ C.max y3 = C.max y2 ∧ C.writable y3 = C.writable y2 ∧ C.zone1 y3 = C.zone1 y2 → C.data x3 = C.data r3 ∧ List.length (C.data r3) = List.length (C.data x2) ∧ C.offset x3 = C.offset x2 ∧ C.min x3 = C.min x2 ∧ C.max x3 = C.max x2 ∧ C.writable x3 = C.writable x2 ∧ C.zone1 x3 = C.zone1 x2 → List.length (C.data r3) = List.length (C.data r2) ∧ C.offset r3 = C.offset r2 ∧ C.min r3 = C.min r2 ∧ C.max r3 = C.max r2 ∧ C.writable r3 = C.writable r2 ∧ C.zone1 r3 = C.zone1 r2 → C.pelts r3 = Function.update (C.pelts r2) (C.offset r3 + BitVec.toInt i) res ∧ C.pelts r3 (C.offset r3 + BitVec.toInt i) = res → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt i + (1 : ℤ) → (∀(o4 : Bool), (BitVec.toUInt res = BitVec.toUInt (0 : BitVec 64) → o4 = true) ∧ (o4 = true → res = (0 : BitVec 64)) → (if ¬o4 = true then ((BitVec.toInt sy ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ BitVec.toInt sx) ∧ (o3 = sx ∨ BitVec.toUInt (0 : BitVec 64) = (0 : ℤ)) ∧ Lemmas.value r3 (BitVec.toInt o3) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o3)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt o3) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt o3 ≤ j → C.pelts r3 j = C.pelts r j) ∧ C.pelts x3 = C.pelts r3 ∧ C.pelts y3 = C.pelts r3 ∧ (C.offset r3 = C.offset x3 ∨ MapEq.map_eq_sub (C.pelts x3) (C.pelts x) (C.offset x3) (C.offset x3 + BitVec.toInt sx)) ∧ (C.offset r3 = C.offset y3 ∨ MapEq.map_eq_sub (C.pelts y3) (C.pelts y) (C.offset y3) (C.offset y3 + BitVec.toInt sy)) ∧ (0 : ℤ) ≤ BitVec.toUInt (0 : BitVec 64) ∧ BitVec.toUInt (0 : BitVec 64) ≤ (1 : ℤ)) ∧ (∀(i1 : BitVec 32) (y4 : C.ptr (BitVec 64)) (x4 : C.ptr (BitVec 64)) (r4 : C.ptr (BitVec 64)), C.data y4 = C.data r4 ∧ List.length (C.data r4) = List.length (C.data y3) ∧ C.offset y4 = C.offset y3 ∧ C.min y4 = C.min y3 ∧ C.max y4 = C.max y3 ∧ C.writable y4 = C.writable y3 ∧ C.zone1 y4 = C.zone1 y3 → C.data x4 = C.data r4 ∧ List.length (C.data r4) = List.length (C.data x3) ∧ C.offset x4 = C.offset x3 ∧ C.min x4 = C.min x3 ∧ C.max x4 = C.max x3 ∧ C.writable x4 = C.writable x3 ∧ C.zone1 x4 = C.zone1 x3 → List.length (C.data r4) = List.length (C.data r3) ∧ C.offset r4 = C.offset r3 ∧ C.min r4 = C.min r3 ∧ C.max r4 = C.max r3 ∧ C.writable r4 = C.writable r3 ∧ C.zone1 r4 = C.zone1 r3 → (BitVec.toInt sy ≤ BitVec.toInt i1 ∧ BitVec.toInt i1 ≤ BitVec.toInt sx) ∧ (i1 = sx ∨ BitVec.toUInt (0 : BitVec 64) = (0 : ℤ)) ∧ Lemmas.value r4 (BitVec.toInt i1) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i1)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt i1) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r4 ∨ C.offset r4 + BitVec.toInt i1 ≤ j → C.pelts r4 j = C.pelts r j) ∧ C.pelts x4 = C.pelts r4 ∧ C.pelts y4 = C.pelts r4 ∧ (C.offset r4 = C.offset x4 ∨ MapEq.map_eq_sub (C.pelts x4) (C.pelts x) (C.offset x4) (C.offset x4 + BitVec.toInt sx)) ∧ (C.offset r4 = C.offset y4 ∨ MapEq.map_eq_sub (C.pelts y4) (C.pelts y) (C.offset y4) (C.offset y4 + BitVec.toInt sy)) ∧ (0 : ℤ) ≤ BitVec.toUInt (0 : BitVec 64) ∧ BitVec.toUInt (0 : BitVec 64) ≤ (1 : ℤ) → (if BitVec.toInt i1 < BitVec.toInt sx then (C.min x4 ≤ C.offset x4 + BitVec.toInt i1 ∧ C.offset x4 + BitVec.toInt i1 < C.max x4) ∧ (C.min x ≤ C.offset x + BitVec.toInt i1 ∧ C.offset x + BitVec.toInt i1 < C.max x) ∧ ((C.min r4 ≤ C.offset r4 + BitVec.toInt i1 ∧ C.offset r4 + BitVec.toInt i1 < C.max r4) ∧ C.writable r4 = true) ∧ (∀(y5 : C.ptr (BitVec 64)) (x5 : C.ptr (BitVec 64)) (r5 : C.ptr (BitVec 64)), C.data y5 = C.data r5 ∧ List.length (C.data r5) = List.length (C.data y4) ∧ C.offset y5 = C.offset y4 ∧ C.min y5 = C.min y4 ∧ C.max y5 = C.max y4 ∧ C.writable y5 = C.writable y4 ∧ C.zone1 y5 = C.zone1 y4 → C.data x5 = C.data r5 ∧ List.length (C.data r5) = List.length (C.data x4) ∧ C.offset x5 = C.offset x4 ∧ C.min x5 = C.min x4 ∧ C.max x5 = C.max x4 ∧ C.writable x5 = C.writable x4 ∧ C.zone1 x5 = C.zone1 x4 → List.length (C.data r5) = List.length (C.data r4) ∧ C.offset r5 = C.offset r4 ∧ C.min r5 = C.min r4 ∧ C.max r5 = C.max r4 ∧ C.writable r5 = C.writable r4 ∧ C.zone1 r5 = C.zone1 r4 → C.pelts r5 = Function.update (C.pelts r4) (C.offset r5 + BitVec.toInt i1) (C.pelts x4 (C.offset x4 + BitVec.toInt i1)) ∧ C.pelts r5 (C.offset r5 + BitVec.toInt i1) = C.pelts x4 (C.offset x4 + BitVec.toInt i1) → int'32_in_bounds (BitVec.toInt i1 + (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt i1 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt sx - BitVec.toInt i1 ∧ BitVec.toInt sx - BitVec.toInt o5 < BitVec.toInt sx - BitVec.toInt i1) ∧ (BitVec.toInt sy ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 ≤ BitVec.toInt sx) ∧ (o5 = sx ∨ BitVec.toUInt (0 : BitVec 64) = (0 : ℤ)) ∧ Lemmas.value r5 (BitVec.toInt o5) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o5)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt o5) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r5 ∨ C.offset r5 + BitVec.toInt o5 ≤ j → C.pelts r5 j = C.pelts r j) ∧ C.pelts x5 = C.pelts r5 ∧ C.pelts y5 = C.pelts r5 ∧ (C.offset r5 = C.offset x5 ∨ MapEq.map_eq_sub (C.pelts x5) (C.pelts x) (C.offset x5) (C.offset x5 + BitVec.toInt sx)) ∧ (C.offset r5 = C.offset y5 ∨ MapEq.map_eq_sub (C.pelts y5) (C.pelts y) (C.offset y5) (C.offset y5 + BitVec.toInt sy)) ∧ (0 : ℤ) ≤ BitVec.toUInt (0 : BitVec 64) ∧ BitVec.toUInt (0 : BitVec 64) ≤ (1 : ℤ))) else Lemmas.value r4 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt sx) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt (0 : BitVec 64) ∧ BitVec.toUInt (0 : BitVec 64) ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r4 ∨ C.offset r4 + BitVec.toInt sx ≤ j → C.pelts r4 j = C.pelts r j) ∧ (C.offset r4 = C.offset x4 ∨ MapEq.map_eq_sub (C.pelts x4) (C.pelts x) (C.offset x4) (C.offset x4 + BitVec.toInt sx)) ∧ (C.offset r4 = C.offset y4 ∨ MapEq.map_eq_sub (C.pelts y4) (C.pelts y) (C.offset y4) (C.offset y4 + BitVec.toInt sy)))) else ((0 : ℤ) ≤ BitVec.toInt sx - BitVec.toInt i ∧ BitVec.toInt sx - BitVec.toInt o3 < BitVec.toInt sx - BitVec.toInt i) ∧ (BitVec.toInt sy ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ BitVec.toInt sx) ∧ Lemmas.value r3 (BitVec.toInt o3) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o3)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt o3) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt o3 ≤ j → C.pelts r3 j = C.pelts r j) ∧ C.pelts x3 = C.pelts r3 ∧ C.pelts y3 = C.pelts r3 ∧ (C.offset r3 = C.offset x3 ∨ MapEq.map_eq_sub (C.pelts x3) (C.pelts x) (C.offset x3) (C.offset x3 + BitVec.toInt sx)) ∧ (C.offset r3 = C.offset y3 ∨ MapEq.map_eq_sub (C.pelts y3) (C.pelts y) (C.offset y3) (C.offset y3 + BitVec.toInt sy)) ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (o3 = sx ∨ BitVec.toUInt c = (1 : ℤ))))))) else ((BitVec.toInt sy ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sx) ∧ (i = sx ∨ BitVec.toUInt c = (0 : ℤ)) ∧ Lemmas.value r2 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt i) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt i ≤ j → C.pelts r2 j = C.pelts r j) ∧ C.pelts x2 = C.pelts r2 ∧ C.pelts y2 = C.pelts r2 ∧ (C.offset r2 = C.offset x2 ∨ MapEq.map_eq_sub (C.pelts x2) (C.pelts x) (C.offset x2) (C.offset x2 + BitVec.toInt sx)) ∧ (C.offset r2 = C.offset y2 ∨ MapEq.map_eq_sub (C.pelts y2) (C.pelts y) (C.offset y2) (C.offset y2 + BitVec.toInt sy)) ∧ (0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (∀(i1 : BitVec 32) (y3 : C.ptr (BitVec 64)) (x3 : C.ptr (BitVec 64)) (r3 : C.ptr (BitVec 64)), C.data y3 = C.data r3 ∧ List.length (C.data r3) = List.length (C.data y2) ∧ C.offset y3 = C.offset y2 ∧ C.min y3 = C.min y2 ∧ C.max y3 = C.max y2 ∧ C.writable y3 = C.writable y2 ∧ C.zone1 y3 = C.zone1 y2 → C.data x3 = C.data r3 ∧ List.length (C.data r3) = List.length (C.data x2) ∧ C.offset x3 = C.offset x2 ∧ C.min x3 = C.min x2 ∧ C.max x3 = C.max x2 ∧ C.writable x3 = C.writable x2 ∧ C.zone1 x3 = C.zone1 x2 → List.length (C.data r3) = List.length (C.data r2) ∧ C.offset r3 = C.offset r2 ∧ C.min r3 = C.min r2 ∧ C.max r3 = C.max r2 ∧ C.writable r3 = C.writable r2 ∧ C.zone1 r3 = C.zone1 r2 → (BitVec.toInt sy ≤ BitVec.toInt i1 ∧ BitVec.toInt i1 ≤ BitVec.toInt sx) ∧ (i1 = sx ∨ BitVec.toUInt c = (0 : ℤ)) ∧ Lemmas.value r3 (BitVec.toInt i1) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i1)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt i1) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt i1 ≤ j → C.pelts r3 j = C.pelts r j) ∧ C.pelts x3 = C.pelts r3 ∧ C.pelts y3 = C.pelts r3 ∧ (C.offset r3 = C.offset x3 ∨ MapEq.map_eq_sub (C.pelts x3) (C.pelts x) (C.offset x3) (C.offset x3 + BitVec.toInt sx)) ∧ (C.offset r3 = C.offset y3 ∨ MapEq.map_eq_sub (C.pelts y3) (C.pelts y) (C.offset y3) (C.offset y3 + BitVec.toInt sy)) ∧ (0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ) → (if BitVec.toInt i1 < BitVec.toInt sx then (C.min x3 ≤ C.offset x3 + BitVec.toInt i1 ∧ C.offset x3 + BitVec.toInt i1 < C.max x3) ∧ (C.min x ≤ C.offset x + BitVec.toInt i1 ∧ C.offset x + BitVec.toInt i1 < C.max x) ∧ ((C.min r3 ≤ C.offset r3 + BitVec.toInt i1 ∧ C.offset r3 + BitVec.toInt i1 < C.max r3) ∧ C.writable r3 = true) ∧ (∀(y4 : C.ptr (BitVec 64)) (x4 : C.ptr (BitVec 64)) (r4 : C.ptr (BitVec 64)), C.data y4 = C.data r4 ∧ List.length (C.data r4) = List.length (C.data y3) ∧ C.offset y4 = C.offset y3 ∧ C.min y4 = C.min y3 ∧ C.max y4 = C.max y3 ∧ C.writable y4 = C.writable y3 ∧ C.zone1 y4 = C.zone1 y3 → C.data x4 = C.data r4 ∧ List.length (C.data r4) = List.length (C.data x3) ∧ C.offset x4 = C.offset x3 ∧ C.min x4 = C.min x3 ∧ C.max x4 = C.max x3 ∧ C.writable x4 = C.writable x3 ∧ C.zone1 x4 = C.zone1 x3 → List.length (C.data r4) = List.length (C.data r3) ∧ C.offset r4 = C.offset r3 ∧ C.min r4 = C.min r3 ∧ C.max r4 = C.max r3 ∧ C.writable r4 = C.writable r3 ∧ C.zone1 r4 = C.zone1 r3 → C.pelts r4 = Function.update (C.pelts r3) (C.offset r4 + BitVec.toInt i1) (C.pelts x3 (C.offset x3 + BitVec.toInt i1)) ∧ C.pelts r4 (C.offset r4 + BitVec.toInt i1) = C.pelts x3 (C.offset x3 + BitVec.toInt i1) → int'32_in_bounds (BitVec.toInt i1 + (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt i1 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt sx - BitVec.toInt i1 ∧ BitVec.toInt sx - BitVec.toInt o3 < BitVec.toInt sx - BitVec.toInt i1) ∧ (BitVec.toInt sy ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ BitVec.toInt sx) ∧ (o3 = sx ∨ BitVec.toUInt c = (0 : ℤ)) ∧ Lemmas.value r4 (BitVec.toInt o3) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o3)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt o3) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r4 ∨ C.offset r4 + BitVec.toInt o3 ≤ j → C.pelts r4 j = C.pelts r j) ∧ C.pelts x4 = C.pelts r4 ∧ C.pelts y4 = C.pelts r4 ∧ (C.offset r4 = C.offset x4 ∨ MapEq.map_eq_sub (C.pelts x4) (C.pelts x) (C.offset x4) (C.offset x4 + BitVec.toInt sx)) ∧ (C.offset r4 = C.offset y4 ∨ MapEq.map_eq_sub (C.pelts y4) (C.pelts y) (C.offset y4) (C.offset y4 + BitVec.toInt sy)) ∧ (0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ))) else Lemmas.value r3 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt sx) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt sx ≤ j → C.pelts r3 j = C.pelts r j) ∧ (C.offset r3 = C.offset x3 ∨ MapEq.map_eq_sub (C.pelts x3) (C.pelts x) (C.offset x3) (C.offset x3 + BitVec.toInt sx)) ∧ (C.offset r3 = C.offset y3 ∨ MapEq.map_eq_sub (C.pelts y3) (C.pelts y) (C.offset y3) (C.offset y3 + BitVec.toInt sy)))))) else ((BitVec.toInt sy ≤ BitVec.toInt sy ∧ BitVec.toInt sy ≤ BitVec.toInt sx) ∧ (sy = sx ∨ BitVec.toUInt o1 = (0 : ℤ)) ∧ Lemmas.value r1 (BitVec.toInt sy) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sy)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt sy) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sy ≤ j → C.pelts r1 j = C.pelts r j) ∧ C.pelts x1 = C.pelts r1 ∧ C.pelts y1 = C.pelts r1 ∧ (C.offset r1 = C.offset x1 ∨ MapEq.map_eq_sub (C.pelts x1) (C.pelts x) (C.offset x1) (C.offset x1 + BitVec.toInt sx)) ∧ (C.offset r1 = C.offset y1 ∨ MapEq.map_eq_sub (C.pelts y1) (C.pelts y) (C.offset y1) (C.offset y1 + BitVec.toInt sy)) ∧ (0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (1 : ℤ)) ∧ (∀(i : BitVec 32) (y2 : C.ptr (BitVec 64)) (x2 : C.ptr (BitVec 64)) (r2 : C.ptr (BitVec 64)), C.data y2 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data y1) ∧ C.offset y2 = C.offset y1 ∧ C.min y2 = C.min y1 ∧ C.max y2 = C.max y1 ∧ C.writable y2 = C.writable y1 ∧ C.zone1 y2 = C.zone1 y1 → C.data x2 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data x1) ∧ C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.max x2 = C.max x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → List.length (C.data r2) = List.length (C.data r1) ∧ C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.max r2 = C.max r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → (BitVec.toInt sy ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sx) ∧ (i = sx ∨ BitVec.toUInt o1 = (0 : ℤ)) ∧ Lemmas.value r2 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt i) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt i ≤ j → C.pelts r2 j = C.pelts r j) ∧ C.pelts x2 = C.pelts r2 ∧ C.pelts y2 = C.pelts r2 ∧ (C.offset r2 = C.offset x2 ∨ MapEq.map_eq_sub (C.pelts x2) (C.pelts x) (C.offset x2) (C.offset x2 + BitVec.toInt sx)) ∧ (C.offset r2 = C.offset y2 ∨ MapEq.map_eq_sub (C.pelts y2) (C.pelts y) (C.offset y2) (C.offset y2 + BitVec.toInt sy)) ∧ (0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (1 : ℤ) → (if BitVec.toInt i < BitVec.toInt sx then (C.min x2 ≤ C.offset x2 + BitVec.toInt i ∧ C.offset x2 + BitVec.toInt i < C.max x2) ∧ (C.min x ≤ C.offset x + BitVec.toInt i ∧ C.offset x + BitVec.toInt i < C.max x) ∧ ((C.min r2 ≤ C.offset r2 + BitVec.toInt i ∧ C.offset r2 + BitVec.toInt i < C.max r2) ∧ C.writable r2 = true) ∧ (∀(y3 : C.ptr (BitVec 64)) (x3 : C.ptr (BitVec 64)) (r3 : C.ptr (BitVec 64)), C.data y3 = C.data r3 ∧ List.length (C.data r3) = List.length (C.data y2) ∧ C.offset y3 = C.offset y2 ∧ C.min y3 = C.min y2 ∧ C.max y3 = C.max y2 ∧ C.writable y3 = C.writable y2 ∧ C.zone1 y3 = C.zone1 y2 → C.data x3 = C.data r3 ∧ List.length (C.data r3) = List.length (C.data x2) ∧ C.offset x3 = C.offset x2 ∧ C.min x3 = C.min x2 ∧ C.max x3 = C.max x2 ∧ C.writable x3 = C.writable x2 ∧ C.zone1 x3 = C.zone1 x2 → List.length (C.data r3) = List.length (C.data r2) ∧ C.offset r3 = C.offset r2 ∧ C.min r3 = C.min r2 ∧ C.max r3 = C.max r2 ∧ C.writable r3 = C.writable r2 ∧ C.zone1 r3 = C.zone1 r2 → C.pelts r3 = Function.update (C.pelts r2) (C.offset r3 + BitVec.toInt i) (C.pelts x2 (C.offset x2 + BitVec.toInt i)) ∧ C.pelts r3 (C.offset r3 + BitVec.toInt i) = C.pelts x2 (C.offset x2 + BitVec.toInt i) → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt sx - BitVec.toInt i ∧ BitVec.toInt sx - BitVec.toInt o3 < BitVec.toInt sx - BitVec.toInt i) ∧ (BitVec.toInt sy ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ BitVec.toInt sx) ∧ (o3 = sx ∨ BitVec.toUInt o1 = (0 : ℤ)) ∧ Lemmas.value r3 (BitVec.toInt o3) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o3)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt o3) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt o3 ≤ j → C.pelts r3 j = C.pelts r j) ∧ C.pelts x3 = C.pelts r3 ∧ C.pelts y3 = C.pelts r3 ∧ (C.offset r3 = C.offset x3 ∨ MapEq.map_eq_sub (C.pelts x3) (C.pelts x) (C.offset x3) (C.offset x3 + BitVec.toInt sx)) ∧ (C.offset r3 = C.offset y3 ∨ MapEq.map_eq_sub (C.pelts y3) (C.pelts y) (C.offset y3) (C.offset y3 + BitVec.toInt sy)) ∧ (0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (1 : ℤ))) else Lemmas.value r2 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt sx) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sx ≤ j → C.pelts r2 j = C.pelts r j) ∧ (C.offset r2 = C.offset x2 ∨ MapEq.map_eq_sub (C.pelts x2) (C.pelts x) (C.offset x2) (C.offset x2 + BitVec.toInt sx)) ∧ (C.offset r2 = C.offset y2 ∨ MapEq.map_eq_sub (C.pelts y2) (C.pelts y) (C.offset y2) (C.offset y2 + BitVec.toInt sy))))))))
  := sorry
end add_Add_wmpn_addqtvc
