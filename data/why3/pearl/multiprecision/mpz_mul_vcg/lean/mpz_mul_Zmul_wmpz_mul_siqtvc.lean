import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.add.Add
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.Sub
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.mul.Mul
import pearl.multiprecision.lib.lean.mul.Mul_basecase
import pearl.multiprecision.lib.lean.toom.Toom
import pearl.multiprecision.lib.lean.valuation.Valuation
import pearl.multiprecision.lib.lean.add_1.Add_1
import pearl.multiprecision.lib.lean.sub_1.Sub_1
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.Logical
import pearl.multiprecision.lib.lean.mpz.Z
import pearl.multiprecision.lib.lean.mpz.Zutil
import pearl.multiprecision.lib.lean.mpz_getset.Set
open Classical
open Lean4Why3
namespace mpz_mul_Zmul_wmpz_mul_siqtvc
theorem wmpz_mul_si'vc (mpz : Z.mpz_memo) (prod : Z.mpz_ptr) (mult : Z.mpz_ptr) (small_mult : BitVec 64) (fact0 : (1 : ℤ) ≤ Z.alloc mpz prod) (fact1 : (1 : ℤ) ≤ Z.alloc mpz mult) (fact2 : Z.readers mpz prod = (0 : ℤ)) (fact3 : Z.readers mpz mult = (0 : ℤ)) (fact4 : Z.abs_size mpz mult + (1 : ℤ) ≤ (2147483647 : ℤ)) : -(2 : ℤ) < Z.readers mpz mult ∧ (∀(sign_product : BitVec 32), BitVec.toInt sign_product = Z.sgn mpz mult * Z.abs_size mpz mult → (∀(o1 : Bool), (BitVec.toInt sign_product = BitVec.toInt (0 : BitVec 32) → o1 = true) ∧ (o1 = true → sign_product = (0 : BitVec 32)) → (∀(o2 : Bool), (if o1 = true then o2 = true else o2 = (if small_mult = (0 : BitVec 64) then true else false) ∧ (BitVec.toInt small_mult = (0 : ℤ) → o2 = true)) → (if o2 = true then (-(1 : ℤ) ≤ Z.readers mpz prod ∧ Z.readers mpz prod ≤ (0 : ℤ)) ∧ (∀(mpz1 : Z.mpz_memo), Z.alloc mpz1 = Z.alloc mpz ∧ Z.sgn mpz1 = Z.sgn mpz ∧ Z.readers mpz1 = Z.readers mpz ∧ Z.zones mpz1 = Z.zones mpz → (∀(y : Z.mpz_ptr), ¬y = prod → Z.mpz_unchanged y mpz1 mpz) ∧ Z.abs_size mpz1 prod = (0 : ℤ) ∧ Z.abs_value_of mpz1 prod = (0 : ℤ) → Z.value_of prod mpz1 = Z.value_of mult mpz * BitVec.toInt small_mult ∧ (∀(x : Z.mpz_ptr), ¬x = prod → Z.mpz_unchanged x mpz1 mpz) ∧ Z.readers mpz1 prod = (0 : ℤ) ∧ Z.readers mpz1 mult = (0 : ℤ)) else -(2147483648 : ℤ) < BitVec.toInt sign_product ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = abs (BitVec.toInt sign_product) → (∀(sml : BitVec 64), BitVec.toUInt sml = abs (BitVec.toInt small_mult) → int'32_in_bounds (BitVec.toInt o3 + (1 : ℤ)) ∧ (∀(o4 : BitVec 32), BitVec.toInt o4 = BitVec.toInt o3 + (1 : ℤ) → (Z.readers mpz prod = (0 : ℤ) ∧ (1 : ℤ) ≤ Z.alloc mpz prod) ∧ (∀(mpz1 : Z.mpz_memo), Z.sgn mpz1 = Z.sgn mpz → (∀(pp : C.ptr (BitVec 64)), (∀(y : Z.mpz_ptr), ¬y = prod → Z.mpz_unchanged y mpz1 mpz) ∧ Z.readers mpz1 prod = -(1 : ℤ) ∧ Z.abs_value_of mpz1 prod = Lemmas.value pp (Z.abs_size mpz1 prod) ∧ Z.zones mpz1 prod = C.zone1 pp ∧ C.offset pp = (0 : ℤ) ∧ C.plength pp = Z.alloc mpz1 prod ∧ C.min pp = (0 : ℤ) ∧ C.max pp = C.plength pp ∧ C.writable pp = true ∧ Z.abs_size mpz1 prod = Z.abs_size mpz prod ∧ Lemmas.value pp (Z.abs_size mpz prod) = Z.abs_value_of mpz prod ∧ (if Z.alloc mpz prod < BitVec.toInt o4 then Z.alloc mpz1 prod = BitVec.toInt o4 else Z.alloc mpz1 prod = Z.alloc mpz prod) → Z.mpz_eq prod mult = (prod = mult) → (if Z.mpz_eq prod mult then (C.valid pp (BitVec.toInt o3) ∧ C.writable pp = true) ∧ (∀(pp1 : C.ptr (BitVec 64)), List.length (C.data pp1) = List.length (C.data pp) ∧ C.offset pp1 = C.offset pp ∧ C.min pp1 = C.min pp ∧ C.max pp1 = C.max pp ∧ C.writable pp1 = C.writable pp ∧ C.zone1 pp1 = C.zone1 pp → (∀(cy : BitVec 64), Lemmas.value pp1 (BitVec.toInt o3) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o3)) * BitVec.toUInt cy = Lemmas.value pp (BitVec.toInt o3) * BitVec.toUInt sml ∧ (∀(j : ℤ), j < C.offset pp1 ∨ C.offset pp1 + BitVec.toInt o3 ≤ j → C.pelts pp1 j = C.pelts pp j) → ((C.min pp1 ≤ C.offset pp1 + BitVec.toInt o3 ∧ C.offset pp1 + BitVec.toInt o3 < C.max pp1) ∧ C.writable pp1 = true) ∧ (∀(pp2 : C.ptr (BitVec 64)), List.length (C.data pp2) = List.length (C.data pp1) ∧ C.offset pp2 = C.offset pp1 ∧ C.min pp2 = C.min pp1 ∧ C.max pp2 = C.max pp1 ∧ C.writable pp2 = C.writable pp1 ∧ C.zone1 pp2 = C.zone1 pp1 → C.pelts pp2 = Function.update (C.pelts pp1) (C.offset pp2 + BitVec.toInt o3) cy ∧ C.pelts pp2 (C.offset pp2 + BitVec.toInt o3) = cy → (∀(o5 : Bool), (BitVec.toUInt cy = BitVec.toUInt (0 : BitVec 64) → o5 = true) ∧ (o5 = true → cy = (0 : BitVec 64)) → (∀(o6 : BitVec 32), (if ¬o5 = true then o6 = (1 : BitVec 32) else o6 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt o3 + BitVec.toInt o6) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt o3 + BitVec.toInt o6 → (let o8 : Bool := (if BitVec.toInt sign_product < (0 : ℤ) then true else false) ^^ (if BitVec.toInt small_mult < (0 : ℤ) then true else false); (o8 = true → int'32_in_bounds (-BitVec.toInt o7)) ∧ (∀(o9 : BitVec 32), (if o8 = true then BitVec.toInt o9 = -BitVec.toInt o7 else o9 = o7) → (Z.zones mpz1 prod = C.zone1 pp2 ∧ Z.readers mpz1 prod = -(1 : ℤ) ∧ C.offset pp2 = (0 : ℤ) ∧ C.min pp2 = (0 : ℤ) ∧ C.max pp2 = C.plength pp2 ∧ abs (BitVec.toInt o9) ≤ C.plength pp2 ∧ C.plength pp2 = Z.alloc mpz1 prod ∧ (¬BitVec.toInt o9 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o9) - (1 : ℤ))) ≤ Lemmas.value pp2 (abs (BitVec.toInt o9)))) ∧ (∀(mpz2 : Z.mpz_memo), Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.readers mpz2 = Z.readers mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(y : Z.mpz_ptr), ¬y = prod → Z.mpz_unchanged y mpz2 mpz1) ∧ (Z.sgn mpz2 prod = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o9) ∧ (Z.sgn mpz2 prod = -(1 : ℤ)) = (BitVec.toInt o9 < (0 : ℤ)) ∧ Z.abs_size mpz2 prod = abs (BitVec.toInt o9) ∧ Z.abs_value_of mpz2 prod = Lemmas.value pp2 (abs (BitVec.toInt o9)) → (Z.zones mpz2 prod = C.zone1 pp2 ∧ Z.readers mpz2 prod = -(1 : ℤ) ∧ C.min pp2 = (0 : ℤ) ∧ C.max pp2 = C.plength pp2 ∧ Z.abs_value_of mpz2 prod = Lemmas.value pp2 (Z.abs_size mpz2 prod)) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 prod = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = prod → Z.readers mpz3 y = Z.readers mpz2 y) → Z.value_of prod mpz3 = Z.value_of mult mpz * BitVec.toInt small_mult ∧ (∀(x : Z.mpz_ptr), ¬x = prod → Z.mpz_unchanged x mpz3 mpz) ∧ Z.readers mpz3 prod = (0 : ℤ) ∧ Z.readers mpz3 mult = (0 : ℤ))))))))))) else Z.mpz_unchanged mult mpz1 mpz ∧ (Z.readers mpz1 mult = Z.readers mpz mult ∧ (-(2 : ℤ) < Z.readers mpz1 mult → Z.abs_value_of mpz1 mult = Z.abs_value_of mpz mult ∧ Z.alloc mpz1 mult = Z.alloc mpz mult ∧ Z.abs_size mpz1 mult = Z.abs_size mpz mult ∧ Z.sgn mpz1 mult = Z.sgn mpz mult ∧ Z.readers mpz1 mult = Z.readers mpz mult ∧ Z.zones mpz1 mult = Z.zones mpz mult) → (0 : ℤ) ≤ Z.readers mpz1 mult ∧ (∀(mpz2 : Z.mpz_memo), Z.abs_value_of mpz2 = Z.abs_value_of mpz1 ∧ Z.alloc mpz2 = Z.alloc mpz1 ∧ Z.abs_size mpz2 = Z.abs_size mpz1 ∧ Z.sgn mpz2 = Z.sgn mpz1 ∧ Z.zones mpz2 = Z.zones mpz1 → (∀(mp : C.ptr (BitVec 64)), Z.readers mpz2 mult = Z.readers mpz1 mult + (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬mult = y → Z.readers mpz2 y = Z.readers mpz1 y) ∧ Lemmas.value mp (Z.abs_size mpz2 mult) = Z.abs_value_of mpz2 mult ∧ C.plength mp = Z.alloc mpz2 mult ∧ C.offset mp = (0 : ℤ) ∧ C.min mp = (0 : ℤ) ∧ C.max mp = C.plength mp ∧ C.zone1 mp = Z.zones mpz2 mult → (C.valid mp (BitVec.toInt o3) ∧ C.valid pp (BitVec.toInt o3) ∧ C.writable pp = true) ∧ (∀(pp1 : C.ptr (BitVec 64)), List.length (C.data pp1) = List.length (C.data pp) ∧ C.offset pp1 = C.offset pp ∧ C.min pp1 = C.min pp ∧ C.max pp1 = C.max pp ∧ C.writable pp1 = C.writable pp ∧ C.zone1 pp1 = C.zone1 pp → (∀(cy : BitVec 64), Lemmas.value pp1 (BitVec.toInt o3) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o3)) * BitVec.toUInt cy = Lemmas.value mp (BitVec.toInt o3) * BitVec.toUInt sml ∧ (∀(j : ℤ), j < C.offset pp1 ∨ C.offset pp1 + BitVec.toInt o3 ≤ j → C.pelts pp1 j = C.pelts pp j) → (Z.zones mpz2 mult = C.zone1 mp ∧ (1 : ℤ) ≤ Z.readers mpz2 mult ∧ C.min mp = (0 : ℤ) ∧ C.max mp = C.plength mp) ∧ (∀(mpz3 : Z.mpz_memo), Z.abs_value_of mpz3 = Z.abs_value_of mpz2 ∧ Z.alloc mpz3 = Z.alloc mpz2 ∧ Z.abs_size mpz3 = Z.abs_size mpz2 ∧ Z.sgn mpz3 = Z.sgn mpz2 ∧ Z.zones mpz3 = Z.zones mpz2 → Z.readers mpz3 mult = Z.readers mpz2 mult - (1 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = mult → Z.readers mpz3 y = Z.readers mpz2 y) → ((C.min pp1 ≤ C.offset pp1 + BitVec.toInt o3 ∧ C.offset pp1 + BitVec.toInt o3 < C.max pp1) ∧ C.writable pp1 = true) ∧ (∀(pp2 : C.ptr (BitVec 64)), List.length (C.data pp2) = List.length (C.data pp1) ∧ C.offset pp2 = C.offset pp1 ∧ C.min pp2 = C.min pp1 ∧ C.max pp2 = C.max pp1 ∧ C.writable pp2 = C.writable pp1 ∧ C.zone1 pp2 = C.zone1 pp1 → C.pelts pp2 = Function.update (C.pelts pp1) (C.offset pp2 + BitVec.toInt o3) cy ∧ C.pelts pp2 (C.offset pp2 + BitVec.toInt o3) = cy → (∀(o5 : Bool), (BitVec.toUInt cy = BitVec.toUInt (0 : BitVec 64) → o5 = true) ∧ (o5 = true → cy = (0 : BitVec 64)) → (∀(o6 : BitVec 32), (if ¬o5 = true then o6 = (1 : BitVec 32) else o6 = (0 : BitVec 32)) → int'32_in_bounds (BitVec.toInt o3 + BitVec.toInt o6) ∧ (∀(o7 : BitVec 32), BitVec.toInt o7 = BitVec.toInt o3 + BitVec.toInt o6 → (let o8 : Bool := (if BitVec.toInt sign_product < (0 : ℤ) then true else false) ^^ (if BitVec.toInt small_mult < (0 : ℤ) then true else false); (o8 = true → int'32_in_bounds (-BitVec.toInt o7)) ∧ (∀(o9 : BitVec 32), (if o8 = true then BitVec.toInt o9 = -BitVec.toInt o7 else o9 = o7) → (Z.zones mpz3 prod = C.zone1 pp2 ∧ Z.readers mpz3 prod = -(1 : ℤ) ∧ C.offset pp2 = (0 : ℤ) ∧ C.min pp2 = (0 : ℤ) ∧ C.max pp2 = C.plength pp2 ∧ abs (BitVec.toInt o9) ≤ C.plength pp2 ∧ C.plength pp2 = Z.alloc mpz3 prod ∧ (¬BitVec.toInt o9 = (0 : ℤ) → HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (abs (BitVec.toInt o9) - (1 : ℤ))) ≤ Lemmas.value pp2 (abs (BitVec.toInt o9)))) ∧ (∀(mpz4 : Z.mpz_memo), Z.alloc mpz4 = Z.alloc mpz3 ∧ Z.readers mpz4 = Z.readers mpz3 ∧ Z.zones mpz4 = Z.zones mpz3 → (∀(y : Z.mpz_ptr), ¬y = prod → Z.mpz_unchanged y mpz4 mpz3) ∧ (Z.sgn mpz4 prod = (1 : ℤ)) = ((0 : ℤ) ≤ BitVec.toInt o9) ∧ (Z.sgn mpz4 prod = -(1 : ℤ)) = (BitVec.toInt o9 < (0 : ℤ)) ∧ Z.abs_size mpz4 prod = abs (BitVec.toInt o9) ∧ Z.abs_value_of mpz4 prod = Lemmas.value pp2 (abs (BitVec.toInt o9)) → (Z.zones mpz4 prod = C.zone1 pp2 ∧ Z.readers mpz4 prod = -(1 : ℤ) ∧ C.min pp2 = (0 : ℤ) ∧ C.max pp2 = C.plength pp2 ∧ Z.abs_value_of mpz4 prod = Lemmas.value pp2 (Z.abs_size mpz4 prod)) ∧ (∀(mpz5 : Z.mpz_memo), Z.abs_value_of mpz5 = Z.abs_value_of mpz4 ∧ Z.alloc mpz5 = Z.alloc mpz4 ∧ Z.abs_size mpz5 = Z.abs_size mpz4 ∧ Z.sgn mpz5 = Z.sgn mpz4 ∧ Z.zones mpz5 = Z.zones mpz4 → Z.readers mpz5 prod = (0 : ℤ) ∧ (∀(y : Z.mpz_ptr), ¬y = prod → Z.readers mpz5 y = Z.readers mpz4 y) → Z.value_of prod mpz5 = Z.value_of mult mpz * BitVec.toInt small_mult ∧ (∀(x : Z.mpz_ptr), ¬x = prod → Z.mpz_unchanged x mpz5 mpz) ∧ Z.readers mpz5 prod = (0 : ℤ) ∧ Z.readers mpz5 mult = (0 : ℤ)))))))))))))))))))))))))
  := sorry
end mpz_mul_Zmul_wmpz_mul_siqtvc
