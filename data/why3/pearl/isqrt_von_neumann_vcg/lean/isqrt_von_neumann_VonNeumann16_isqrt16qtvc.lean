import Why3.Base
import Why3.why3.WellFounded.WellFounded
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace isqrt_von_neumann_VonNeumann16_isqrt16qtvc
noncomputable def sqr (x : BitVec 16) := x * x
noncomputable def is_pow2 (x : BitVec 16) (n : BitVec 16) := x &&& ((1 : BitVec 16) <<< BitVec.toNat n) - (1 : BitVec 16) = (0 : BitVec 16)
theorem isqrt16'vc (x : BitVec 16) : (8 : BitVec 16) ≤ (8 : BitVec 16) ∧ (128 : BitVec 16) = (if (8 : BitVec 16) = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat ((8 : BitVec 16) - (1 : BitVec 16))) ∧ (16384 : BitVec 16) = sqr (128 : BitVec 16) ∧ is_pow2 (0 : BitVec 16) (8 : BitVec 16) ∧ (0 : BitVec 16) < (256 : BitVec 16) ∧ (0 : BitVec 16) = (0 : BitVec 16) * ((1 : BitVec 16) <<< BitVec.toNat (8 : BitVec 16)) ∧ x ≤ x ∧ x - x = sqr (0 : BitVec 16) ∧ (0 : BitVec 16) + ((1 : BitVec 16) <<< BitVec.toNat (8 : BitVec 16)) ≤ (256 : BitVec 16) ∧ x ≤ sqr ((0 : BitVec 16) + ((1 : BitVec 16) <<< BitVec.toNat (8 : BitVec 16))) - (1 : BitVec 16) ∧ (∀(res_g : BitVec 16) (m : BitVec 16) (num : BitVec 16), m ≤ (8 : BitVec 16) ∧ is_pow2 res_g m ∧ res_g < (256 : BitVec 16) ∧ num ≤ x ∧ x - num = sqr res_g ∧ res_g + ((1 : BitVec 16) <<< BitVec.toNat m) ≤ (256 : BitVec 16) ∧ x ≤ sqr (res_g + ((1 : BitVec 16) <<< BitVec.toNat m)) - (1 : BitVec 16) → (if ¬sqr (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) = (0 : BitVec 16) then let b : BitVec 16 := res_g * ((1 : BitVec 16) <<< BitVec.toNat m) ||| sqr (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))); if num ≥ b then BitVec.toUInt (sqr (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) >>> BitVec.toNat (2 : BitVec 16)) < BitVec.toUInt (sqr (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16)))) ∧ m - (1 : BitVec 16) ≤ (8 : BitVec 16) ∧ (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) >>> BitVec.toNat (1 : BitVec 16) = (if m - (1 : BitVec 16) = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16) - (1 : BitVec 16))) ∧ sqr (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) >>> BitVec.toNat (2 : BitVec 16) = sqr ((if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) >>> BitVec.toNat (1 : BitVec 16)) ∧ is_pow2 (res_g + (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16)))) (m - (1 : BitVec 16)) ∧ res_g + (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) < (256 : BitVec 16) ∧ res_g * ((1 : BitVec 16) <<< BitVec.toNat m) >>> BitVec.toNat (1 : BitVec 16) ||| sqr (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) = (res_g + (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16)))) * ((1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) ∧ num - b ≤ x ∧ x - (num - b) = sqr (res_g + (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16)))) ∧ res_g + (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) + ((1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) ≤ (256 : BitVec 16) ∧ x ≤ sqr (res_g + (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) + ((1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16)))) - (1 : BitVec 16) else BitVec.toUInt (sqr (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) >>> BitVec.toNat (2 : BitVec 16)) < BitVec.toUInt (sqr (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16)))) ∧ m - (1 : BitVec 16) ≤ (8 : BitVec 16) ∧ (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) >>> BitVec.toNat (1 : BitVec 16) = (if m - (1 : BitVec 16) = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16) - (1 : BitVec 16))) ∧ sqr (if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) >>> BitVec.toNat (2 : BitVec 16) = sqr ((if m = (0 : BitVec 16) then (0 : BitVec 16) else (1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) >>> BitVec.toNat (1 : BitVec 16)) ∧ is_pow2 res_g (m - (1 : BitVec 16)) ∧ res_g < (256 : BitVec 16) ∧ res_g * ((1 : BitVec 16) <<< BitVec.toNat m) >>> BitVec.toNat (1 : BitVec 16) = res_g * ((1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) ∧ num ≤ x ∧ x - num = sqr res_g ∧ res_g + ((1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16))) ≤ (256 : BitVec 16) ∧ x ≤ sqr (res_g + ((1 : BitVec 16) <<< BitVec.toNat (m - (1 : BitVec 16)))) - (1 : BitVec 16) else sqr (res_g * ((1 : BitVec 16) <<< BitVec.toNat m)) ≤ x ∧ x ≤ sqr (res_g * ((1 : BitVec 16) <<< BitVec.toNat m) + (1 : BitVec 16)) - (1 : BitVec 16)))
  := sorry
end isqrt_von_neumann_VonNeumann16_isqrt16qtvc
