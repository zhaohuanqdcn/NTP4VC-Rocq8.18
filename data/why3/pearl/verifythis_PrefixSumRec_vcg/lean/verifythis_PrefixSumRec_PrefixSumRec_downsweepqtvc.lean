import Why3.Base
import Why3.int.Sum
open Classical
open Lean4Why3
namespace verifythis_PrefixSumRec_PrefixSumRec_downsweepqtvc
noncomputable def is_power_of_2 (x : ℤ) := ∃(k : ℤ), (0 : ℤ) ≤ k ∧ x = HPow.hPow (2 : ℤ) (Int.toNat k)
noncomputable def go_left (left1 : ℤ) (right1 : ℤ) := let space : ℤ := right1 - left1; left1 - Int.tdiv space (2 : ℤ)
noncomputable def go_right (left1 : ℤ) (right1 : ℤ) := let space : ℤ := right1 - left1; right1 - Int.tdiv space (2 : ℤ)
inductive phase1 : ℤ -> ℤ -> List ℤ -> List ℤ -> Prop where
 | Leaf (right1 : ℤ) (left1 : ℤ) (a : List ℤ) (a0 : List ℤ) : right1 = left1 + (1 : ℤ) → a[Int.toNat left1]! = a0[Int.toNat left1]! → phase1 left1 right1 a0 a
 | Node (left1 : ℤ) (right1 : ℤ) (a0 : List ℤ) (a : List ℤ) : left1 + (1 : ℤ) < right1 → phase1 (go_left left1 right1) left1 a0 a → phase1 (go_right left1 right1) right1 a0 a → a[Int.toNat left1]! = List.sum (List.drop (Int.toNat (left1 - (right1 - left1) + (1 : ℤ))) (List.take (Int.toNat (left1 + (1 : ℤ)) - Int.toNat (left1 - (right1 - left1) + (1 : ℤ))) a0)) → phase1 left1 right1 a0 a
noncomputable def partial_sum (left1 : ℤ) (right1 : ℤ) (a0 : List ℤ) (a : List ℤ) := ∀(i : ℤ), left1 - (right1 - left1) < i ∧ i ≤ right1 → a[Int.toNat i]! = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a0))
theorem downsweep'vc (left1 : ℤ) (right1 : ℤ) (a : List ℤ) (a0 : List ℤ) (fact0 : (0 : ℤ) ≤ left1) (fact1 : left1 < right1) (fact2 : right1 < Int.ofNat (List.length a)) (fact3 : -(1 : ℤ) ≤ left1 - (right1 - left1)) (fact4 : is_power_of_2 (right1 - left1)) (fact5 : a[Int.toNat right1]! = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat (left1 - (right1 - left1) + (1 : ℤ)) - (0 : ℕ)) a0))) (fact6 : phase1 left1 right1 a0 a) : (0 : ℤ) ≤ right1 ∧ right1 < Int.ofNat (List.length a) ∧ (let tmp : ℤ := a[Int.toNat right1]!; ((0 : ℤ) ≤ left1 ∧ left1 < Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ right1 ∧ right1 < Int.ofNat (List.length a)) ∧ (let o1 : ℤ := a[Int.toNat right1]! + a[Int.toNat left1]!; ((0 : ℤ) ≤ right1 ∧ right1 < Int.ofNat (List.length a)) ∧ (List.length (List.set a (Int.toNat right1) o1) = List.length a → getElem! (List.set a (Int.toNat right1) o1) ∘ Int.toNat = Function.update (getElem! a ∘ Int.toNat) right1 o1 → ((0 : ℤ) ≤ left1 ∧ left1 < Int.ofNat (List.length (List.set a (Int.toNat right1) o1))) ∧ (List.length (List.set (List.set a (Int.toNat right1) o1) (Int.toNat left1) tmp) = List.length (List.set a (Int.toNat right1) o1) → getElem! (List.set (List.set a (Int.toNat right1) o1) (Int.toNat left1) tmp) ∘ Int.toNat = Function.update (getElem! (List.set a (Int.toNat right1) o1) ∘ Int.toNat) left1 tmp → (if left1 + (1 : ℤ) < right1 then let space : ℤ := right1 - left1; ¬(2 : ℤ) = (0 : ℤ) ∧ (let o2 : ℤ := left1 - Int.tdiv space (2 : ℤ); (((0 : ℤ) ≤ right1 - left1 ∧ left1 - o2 < right1 - left1) ∧ ((0 : ℤ) ≤ o2 ∧ o2 < left1 ∧ left1 < Int.ofNat (List.length (List.set (List.set a (Int.toNat right1) o1) (Int.toNat left1) tmp))) ∧ -(1 : ℤ) ≤ o2 - (left1 - o2) ∧ is_power_of_2 (left1 - o2) ∧ (List.set (List.set a (Int.toNat right1) o1) (Int.toNat left1) tmp)[Int.toNat left1]! = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat (o2 - (left1 - o2) + (1 : ℤ)) - (0 : ℕ)) a0)) ∧ phase1 o2 left1 a0 (List.set (List.set a (Int.toNat right1) o1) (Int.toNat left1) tmp)) ∧ (∀(a1 : List ℤ), List.length a1 = List.length (List.set (List.set a (Int.toNat right1) o1) (Int.toNat left1) tmp) → partial_sum o2 left1 a0 a1 ∧ (∀(i : ℤ), i ≤ o2 - (left1 - o2) → a1[Int.toNat i]! = (List.set (List.set a (Int.toNat right1) o1) (Int.toNat left1) tmp)[Int.toNat i]!) ∧ (∀(i : ℤ), left1 < i → a1[Int.toNat i]! = (List.set (List.set a (Int.toNat right1) o1) (Int.toNat left1) tmp)[Int.toNat i]!) → ¬(2 : ℤ) = (0 : ℤ) ∧ (let o3 : ℤ := right1 - Int.tdiv space (2 : ℤ); (((0 : ℤ) ≤ right1 - left1 ∧ right1 - o3 < right1 - left1) ∧ ((0 : ℤ) ≤ o3 ∧ o3 < right1 ∧ right1 < Int.ofNat (List.length a1)) ∧ -(1 : ℤ) ≤ o3 - (right1 - o3) ∧ is_power_of_2 (right1 - o3) ∧ a1[Int.toNat right1]! = List.sum (List.drop (0 : ℕ) (List.take (Int.toNat (o3 - (right1 - o3) + (1 : ℤ)) - (0 : ℕ)) a0)) ∧ phase1 o3 right1 a0 a1) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → partial_sum o3 right1 a0 a2 ∧ (∀(i : ℤ), i ≤ o3 - (right1 - o3) → a2[Int.toNat i]! = a1[Int.toNat i]!) ∧ (∀(i : ℤ), right1 < i → a2[Int.toNat i]! = a1[Int.toNat i]!) → partial_sum left1 right1 a0 a2 ∧ (∀(i : ℤ), i ≤ left1 - (right1 - left1) → a2[Int.toNat i]! = a[Int.toNat i]!) ∧ (∀(i : ℤ), right1 < i → a2[Int.toNat i]! = a[Int.toNat i]!))))) else partial_sum left1 right1 a0 (List.set (List.set a (Int.toNat right1) o1) (Int.toNat left1) tmp) ∧ (∀(i : ℤ), i ≤ left1 - (right1 - left1) → (List.set (List.set a (Int.toNat right1) o1) (Int.toNat left1) tmp)[Int.toNat i]! = a[Int.toNat i]!) ∧ (∀(i : ℤ), right1 < i → (List.set (List.set a (Int.toNat right1) o1) (Int.toNat left1) tmp)[Int.toNat i]! = a[Int.toNat i]!))))))
  := sorry
end verifythis_PrefixSumRec_PrefixSumRec_downsweepqtvc
