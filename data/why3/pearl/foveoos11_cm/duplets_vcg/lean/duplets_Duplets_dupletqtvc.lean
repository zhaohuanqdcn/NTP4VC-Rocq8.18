import Why3.Base
import Why3.why3.Ref.Ref
open Classical
open Lean4Why3
namespace duplets_Duplets_dupletqtvc
noncomputable def is_duplet (a : List ℤ) (i : ℤ) (j : ℤ) := ((0 : ℤ) ≤ i ∧ i < j ∧ j < Int.ofNat (List.length a)) ∧ a[Int.toNat i]! = a[Int.toNat j]!
noncomputable def eq_opt (x : ℤ) (o1 : Option ℤ) := match o1 with | Option.none => False | Option.some v => v = x
theorem duplet'vc (a : List ℤ) (except : Option ℤ) (fact0 : (2 : ℤ) ≤ Int.ofNat (List.length a)) (fact1 : ∃(i : ℤ) (j : ℤ), is_duplet a i j ∧ ¬eq_opt (a[Int.toNat i]!) except) : let o1 : ℤ := Int.ofNat (List.length a) - (2 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < (0 : ℤ)) ∧ k < l ∧ l < Int.ofNat (List.length a) → ¬eq_opt (a[Int.toNat k]!) except → ¬is_duplet a k l) ∧ (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < i) ∧ k < l ∧ l < Int.ofNat (List.length a) → ¬eq_opt (a[Int.toNat k]!) except → ¬is_duplet a k l) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let v : ℤ := a[Int.toNat i]!; if eq_opt v except then ∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < i + (1 : ℤ)) ∧ k < l ∧ l < Int.ofNat (List.length a) → ¬eq_opt (a[Int.toNat k]!) except → ¬is_duplet a k l else let o2 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); let o3 : ℤ := i + (1 : ℤ); (o3 ≤ o2 + (1 : ℤ) → (∀(l : ℤ), i < l ∧ l < o3 → ¬is_duplet a i l) ∧ (∀(j : ℤ), (o3 ≤ j ∧ j ≤ o2) ∧ (∀(l : ℤ), i < l ∧ l < j → ¬is_duplet a i l) → ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a)) ∧ (if a[Int.toNat j]! = v then is_duplet a i j ∧ ¬eq_opt (a[Int.toNat i]!) except else ∀(l : ℤ), i < l ∧ l < j + (1 : ℤ) → ¬is_duplet a i l)) ∧ ((∀(l : ℤ), i < l ∧ l < o2 + (1 : ℤ) → ¬is_duplet a i l) → (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < i + (1 : ℤ)) ∧ k < l ∧ l < Int.ofNat (List.length a) → ¬eq_opt (a[Int.toNat k]!) except → ¬is_duplet a k l))) ∧ (o2 + (1 : ℤ) < o3 → (∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < i + (1 : ℤ)) ∧ k < l ∧ l < Int.ofNat (List.length a) → ¬eq_opt (a[Int.toNat k]!) except → ¬is_duplet a k l)))) ∧ ¬(∀(k : ℤ) (l : ℤ), ((0 : ℤ) ≤ k ∧ k < o1 + (1 : ℤ)) ∧ k < l ∧ l < Int.ofNat (List.length a) → ¬eq_opt (a[Int.toNat k]!) except → ¬is_duplet a k l)) ∧ ¬o1 + (1 : ℤ) < (0 : ℤ)
  := sorry
end duplets_Duplets_dupletqtvc
