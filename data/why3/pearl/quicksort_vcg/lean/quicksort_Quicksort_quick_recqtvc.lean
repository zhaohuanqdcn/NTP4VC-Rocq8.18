import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
import Why3.array.IntArraySorted
open Classical
open Lean4Why3
namespace quicksort_Quicksort_quick_recqtvc
noncomputable def qs_partition (a1 : List ℤ) (a2 : List ℤ) (l : ℤ) (m : ℤ) (r : ℤ) (v : ℤ) := List.permut_sub' a1 a2 (Int.toNat l) (Int.toNat r) ∧ (∀(j : ℤ), l ≤ j ∧ j < m → a2[Int.toNat j]! < v) ∧ (∀(j : ℤ), m < j ∧ j < r → v ≤ a2[Int.toNat j]!) ∧ a2[Int.toNat m]! = v
theorem quick_rec'vc (l : ℤ) (r : ℤ) (a : List ℤ) (fact0 : (0 : ℤ) ≤ l) (fact1 : l ≤ r) (fact2 : r ≤ Int.ofNat (List.length a)) : if l + (1 : ℤ) < r then ((0 : ℤ) ≤ l ∧ l < Int.ofNat (List.length a)) ∧ (let v : ℤ := a[Int.toNat l]!; let o1 : ℤ := r - (1 : ℤ); let o2 : ℤ := l + (1 : ℤ); (o2 ≤ o1 + (1 : ℤ) → ((a[Int.toNat l]! = v ∧ l ≤ l ∧ l < o2) ∧ (∀(j : ℤ), l < j ∧ j ≤ l → a[Int.toNat j]! < v) ∧ (∀(j : ℤ), l < j ∧ j < o2 → v ≤ a[Int.toNat j]!) ∧ List.permut_sub' a a (Int.toNat l) (Int.toNat r)) ∧ (∀(m : ℤ) (a1 : List ℤ), List.length a1 = List.length a → (∀(i : ℤ), (o2 ≤ i ∧ i ≤ o1) ∧ (a1[Int.toNat l]! = v ∧ l ≤ m ∧ m < i) ∧ (∀(j : ℤ), l < j ∧ j ≤ m → a1[Int.toNat j]! < v) ∧ (∀(j : ℤ), m < j ∧ j < i → v ≤ a1[Int.toNat j]!) ∧ List.permut_sub' a a1 (Int.toNat l) (Int.toNat r) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (if a1[Int.toNat i]! < v then (((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ m + (1 : ℤ) ∧ m + (1 : ℤ) < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 i (m + (1 : ℤ)) → (a2[Int.toNat l]! = v ∧ l ≤ m + (1 : ℤ) ∧ m + (1 : ℤ) < i + (1 : ℤ)) ∧ (∀(j : ℤ), l < j ∧ j ≤ m + (1 : ℤ) → a2[Int.toNat j]! < v) ∧ (∀(j : ℤ), m + (1 : ℤ) < j ∧ j < i + (1 : ℤ) → v ≤ a2[Int.toNat j]!) ∧ List.permut_sub' a a2 (Int.toNat l) (Int.toNat r)) else (a1[Int.toNat l]! = v ∧ l ≤ m ∧ m < i + (1 : ℤ)) ∧ (∀(j : ℤ), l < j ∧ j ≤ m → a1[Int.toNat j]! < v) ∧ (∀(j : ℤ), m < j ∧ j < i + (1 : ℤ) → v ≤ a1[Int.toNat j]!) ∧ List.permut_sub' a a1 (Int.toNat l) (Int.toNat r))) ∧ ((a1[Int.toNat l]! = v ∧ l ≤ m ∧ m < o1 + (1 : ℤ)) ∧ (∀(j : ℤ), l < j ∧ j ≤ m → a1[Int.toNat j]! < v) ∧ (∀(j : ℤ), m < j ∧ j < o1 + (1 : ℤ) → v ≤ a1[Int.toNat j]!) ∧ List.permut_sub' a a1 (Int.toNat l) (Int.toNat r) → (((0 : ℤ) ≤ l ∧ l < Int.ofNat (List.length a1)) ∧ (0 : ℤ) ≤ m ∧ m < Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → Lean4Why3.arrayExchange a1 a2 l m → (((0 : ℤ) ≤ r - l ∧ m - l < r - l) ∧ (0 : ℤ) ≤ l ∧ l ≤ m ∧ m ≤ Int.ofNat (List.length a2)) ∧ (∀(a3 : List ℤ), List.length a3 = List.length a2 → IntArraySorted.sorted_sub1 a3 l m ∧ List.permut_sub' a2 a3 (Int.toNat l) (Int.toNat m) → (let o3 : ℤ := m + (1 : ℤ); (((0 : ℤ) ≤ r - l ∧ r - o3 < r - l) ∧ (0 : ℤ) ≤ o3 ∧ o3 ≤ r ∧ r ≤ Int.ofNat (List.length a3)) ∧ (∀(a4 : List ℤ), List.length a4 = List.length a3 → IntArraySorted.sorted_sub1 a4 o3 r ∧ List.permut_sub' a3 a4 (Int.toNat o3) (Int.toNat r) → IntArraySorted.sorted_sub1 a4 l r ∧ List.permut_sub' a a4 (Int.toNat l) (Int.toNat r)))))))) ∧ (o1 + (1 : ℤ) < o2 → ((0 : ℤ) ≤ l ∧ l < Int.ofNat (List.length a)) ∧ (∀(a1 : List ℤ), List.length a1 = List.length a → Lean4Why3.arrayExchange a a1 l l → (((0 : ℤ) ≤ r - l ∧ l - l < r - l) ∧ (0 : ℤ) ≤ l ∧ l ≤ l ∧ l ≤ Int.ofNat (List.length a1)) ∧ (∀(a2 : List ℤ), List.length a2 = List.length a1 → IntArraySorted.sorted_sub1 a2 l l ∧ List.permut_sub' a1 a2 (Int.toNat l) (Int.toNat l) → (let o3 : ℤ := l + (1 : ℤ); (((0 : ℤ) ≤ r - l ∧ r - o3 < r - l) ∧ (0 : ℤ) ≤ o3 ∧ o3 ≤ r ∧ r ≤ Int.ofNat (List.length a2)) ∧ (∀(a3 : List ℤ), List.length a3 = List.length a2 → IntArraySorted.sorted_sub1 a3 o3 r ∧ List.permut_sub' a2 a3 (Int.toNat o3) (Int.toNat r) → IntArraySorted.sorted_sub1 a3 l r ∧ List.permut_sub' a a3 (Int.toNat l) (Int.toNat r))))))) else IntArraySorted.sorted_sub1 a l r ∧ List.permut_sub' a a (Int.toNat l) (Int.toNat r)
  := sorry
end quicksort_Quicksort_quick_recqtvc
