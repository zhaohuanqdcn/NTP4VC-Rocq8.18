theory get_str_Get_str_wmpn_limb_get_strqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "mach.c_UChar" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/powm_Powm" "../../lib/isabelle/compare_Compare" "../../lib/isabelle/valuation_Valuation" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/util_UtilOld" "../../lib/isabelle/add_Add" "../../lib/isabelle/add_AddOld" "../../lib/isabelle/sub_SubOld" "../../lib/isabelle/mul_Mul" "../../lib/isabelle/mul_Mul_basecase" "../../lib/isabelle/logical_LogicalUtil" "../../lib/isabelle/logical_Logical" "../../lib/isabelle/logical_LogicalOld" "../../lib/isabelle/div_Div" "../../lib/isabelle/toom_Toom" "../../lib/isabelle/add_1_Add_1" "../../lib/isabelle/sub_1_Sub_1" "../../lib/isabelle/stringlemmas_String_lemmas" "../../lib/isabelle/base_info_BaseInfo"
begin
theorem wmpn_limb_get_str'vc:
  fixes binfo :: "wmpn_base_info"
  fixes sp :: "8 word ptr"
  fixes d1 :: "64 word"
  fixes shift :: "64 word"
  fixes di :: "64 word"
  fixes sz :: "32 word"
  fixes w :: "64 word"
  assumes fact0: "(2 :: int) \<le> b binfo"
  assumes fact1: "b binfo \<le> (256 :: int)"
  assumes fact2: "writable sp = True"
  assumes fact3: "((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint d1"
  assumes fact4: "(0 :: int) \<le> uint shift"
  assumes fact5: "uint shift \<le> (63 :: int)"
  assumes fact6: "b binfo * (2 :: int) ^\<^sub>i uint shift = uint d1"
  assumes fact7: "reciprocal di d1"
  assumes fact8: "valid sp (sint sz)"
  assumes fact9: "(0 :: int) < sint sz"
  assumes fact10: "uint w < b binfo ^\<^sub>i sint sz"
  shows "let base :: int = b binfo in (((0 :: int) \<le> uint w \<and> uint w < (18446744073709551615 :: int) + (1 :: int)) \<and> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) \<le> sint sz) \<and> ((0 :: int) < uint w \<longrightarrow> (0 :: int) \<le> (0 :: int) \<and> (0 :: int) < sint sz) \<and> in_base base (pelts sp) (offset sp) (offset sp + (0 :: int)) \<and> (uint w = (0 :: int) \<longrightarrow> (0 :: int) < (0 :: int) \<longrightarrow> (0 :: int) < uint (pelts sp (offset sp + (0 :: int) - (1 :: int)))) \<and> uint w = svalue_le base sp (0 :: int) + base ^\<^sub>i (0 :: int) * uint w) \<and> (\<forall>(i :: 32 word) (w1 :: 64 word) (sp1 :: 8 word ptr). length (data sp1) = length (data sp) \<and> offset sp1 = offset sp \<and> c_C.min sp1 = c_C.min sp \<and> c_C.max sp1 = c_C.max sp \<and> writable sp1 = writable sp \<and> zone1 sp1 = zone1 sp \<longrightarrow> ((0 :: int) \<le> uint w1 \<and> uint w1 < (18446744073709551615 :: int) + (1 :: int)) \<and> ((0 :: int) \<le> sint i \<and> sint i \<le> sint sz) \<and> ((0 :: int) < uint w1 \<longrightarrow> (0 :: int) \<le> sint i \<and> sint i < sint sz) \<and> in_base base (pelts sp1) (offset sp1) (offset sp1 + sint i) \<and> (uint w1 = (0 :: int) \<longrightarrow> (0 :: int) < sint i \<longrightarrow> (0 :: int) < uint (pelts sp1 (offset sp1 + sint i - (1 :: int)))) \<and> uint w = svalue_le base sp1 (sint i) + base ^\<^sub>i sint i * uint w1 \<and> (\<forall>(j :: int). j < offset sp1 \<or> offset sp1 + sint i \<le> j \<longrightarrow> pelts sp1 j = pelts sp j) \<longrightarrow> (if (0 :: int) < uint w1 then uint'64_in_bounds ((64 :: int) - uint shift) \<and> (\<forall>(o1 :: 64 word). uint o1 = (64 :: int) - uint shift \<longrightarrow> ((0 :: int) \<le> uint o1 \<and> uint o1 < (64 :: int)) \<and> (\<forall>(h :: 64 word). uint h = uint w1 ediv (2 :: int) ^\<^sub>i uint o1 \<longrightarrow> ((0 :: int) \<le> uint shift \<and> uint shift < (64 :: int)) \<and> (\<forall>(l :: 64 word). uint l = uint w1 * (2 :: int) ^\<^sub>i uint shift emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (((18446744073709551615 :: int) + (1 :: int)) ediv (2 :: int) \<le> uint d1 \<and> uint h < uint d1 \<and> reciprocal di d1) \<and> (\<forall>(q :: 64 word) (r :: 64 word). uint q * uint d1 + uint r = uint l + ((18446744073709551615 :: int) + (1 :: int)) * uint h \<and> (0 :: int) \<le> uint r \<and> uint r < uint d1 \<longrightarrow> (((0 :: int) \<le> uint shift \<and> uint shift < (64 :: int)) \<and> uint r emod (2 :: int) ^\<^sub>i uint shift = (0 :: int)) \<and> (\<forall>(nr :: 64 word). uint r = (2 :: int) ^\<^sub>i uint shift * uint nr \<longrightarrow> (((0 :: int) \<le> uint shift \<and> uint shift < (64 :: int)) \<and> uint r emod (2 :: int) ^\<^sub>i uint shift = (0 :: int)) \<and> (\<forall>(o2 :: 64 word). uint r = (2 :: int) ^\<^sub>i uint shift * uint o2 \<longrightarrow> ((0 :: int) \<le> uint o2 \<and> uint o2 \<le> (255 :: int)) \<and> (\<forall>(o3 :: 8 word). uint o3 = uint o2 \<longrightarrow> ((c_C.min sp1 \<le> offset sp1 + sint i \<and> offset sp1 + sint i < c_C.max sp1) \<and> writable sp1 = True) \<and> (\<forall>(sp2 :: 8 word ptr). length (data sp2) = length (data sp1) \<and> offset sp2 = offset sp1 \<and> c_C.min sp2 = c_C.min sp1 \<and> c_C.max sp2 = c_C.max sp1 \<and> writable sp2 = writable sp1 \<and> zone1 sp2 = zone1 sp1 \<longrightarrow> pelts sp2 = (pelts sp1)(offset sp2 + sint i := o3) \<and> pelts sp2 (offset sp2 + sint i) = o3 \<longrightarrow> int'32_in_bounds (sint i + (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint i + (1 :: int) \<longrightarrow> uint q < uint w1 \<and> ((0 :: int) \<le> uint q \<and> uint q < (18446744073709551615 :: int) + (1 :: int)) \<and> ((0 :: int) \<le> sint o4 \<and> sint o4 \<le> sint sz) \<and> ((0 :: int) < uint q \<longrightarrow> (0 :: int) \<le> sint o4 \<and> sint o4 < sint sz) \<and> in_base base (pelts sp2) (offset sp2) (offset sp2 + sint o4) \<and> (uint q = (0 :: int) \<longrightarrow> (0 :: int) < sint o4 \<longrightarrow> (0 :: int) < uint (pelts sp2 (offset sp2 + sint o4 - (1 :: int)))) \<and> uint w = svalue_le base sp2 (sint o4) + base ^\<^sub>i sint o4 * uint q \<and> (\<forall>(j :: int). j < offset sp2 \<or> offset sp2 + sint o4 \<le> j \<longrightarrow> pelts sp2 j = pelts sp j)))))))))) else (0 :: int) \<le> sint i \<and> (\<forall>(result :: 32 word). uint result = sint i \<longrightarrow> svalue_le (b binfo) sp1 (uint result) = uint w \<and> ((0 :: int) \<le> uint result \<and> uint result \<le> sint sz) \<and> ((0 :: int) < uint result \<longrightarrow> (0 :: int) < uint (pelts sp1 (offset sp1 + uint result - (1 :: int)))) \<and> (\<forall>(i1 :: int). i1 < offset sp1 \<or> offset sp1 + uint result \<le> i1 \<longrightarrow> pelts sp1 i1 = pelts sp i1) \<and> in_base (b binfo) (pelts sp1) (offset sp1) (offset sp1 + uint result))))"
  sorry
end
