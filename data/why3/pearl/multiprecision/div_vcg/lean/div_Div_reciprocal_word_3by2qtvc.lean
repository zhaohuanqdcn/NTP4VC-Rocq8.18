import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.compare.Compare
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.util.UtilOld
import pearl.multiprecision.lib.lean.add.AddOld
import pearl.multiprecision.lib.lean.sub.SubOld
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import pearl.multiprecision.lib.lean.logical.LogicalOld
open Classical
open Lean4Why3
namespace div_Div_reciprocal_word_3by2qtvc
noncomputable def reciprocal (v : BitVec 64) (d : BitVec 64) := BitVec.toUInt v = (((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) - (1 : ℤ)) / BitVec.toUInt d - ((18446744073709551615 : ℤ) + (1 : ℤ))
noncomputable def reciprocal_3by2 (v : BitVec 64) (dh : BitVec 64) (dl : BitVec 64) := BitVec.toUInt v = (((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) * ((18446744073709551615 : ℤ) + (1 : ℤ)) - (1 : ℤ)) / (BitVec.toUInt dl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt dh) - ((18446744073709551615 : ℤ) + (1 : ℤ))
theorem reciprocal_word_3by2'vc (dh : BitVec 64) (dl : BitVec 64) (fact0 : ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt dh) : ((18446744073709551615 : ℤ) + (1 : ℤ)) / (2 : ℤ) ≤ BitVec.toUInt dh ∧ (∀(o1 : BitVec 64), reciprocal o1 dh → (∀(o2 : BitVec 64), BitVec.toUInt o2 = BitVec.toUInt dh * BitVec.toUInt o1 % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (∀(o3 : BitVec 64), BitVec.toUInt o3 = (BitVec.toUInt o2 + BitVec.toUInt dl) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (if BitVec.toUInt o3 < BitVec.toUInt dl then if BitVec.toUInt dh ≤ BitVec.toUInt o3 then uint'64_in_bounds (BitVec.toUInt o1 - (1 : ℤ)) ∧ (∀(o4 : BitVec 64), BitVec.toUInt o4 = BitVec.toUInt o1 - (1 : ℤ) → uint'64_in_bounds (BitVec.toUInt o3 - BitVec.toUInt dh) ∧ (∀(o5 : BitVec 64), BitVec.toUInt o5 = BitVec.toUInt o3 - BitVec.toUInt dh → uint'64_in_bounds (BitVec.toUInt o4 - (1 : ℤ)) ∧ (∀(o6 : BitVec 64), BitVec.toUInt o6 = BitVec.toUInt o4 - (1 : ℤ) → (∀(o7 : BitVec 64), BitVec.toUInt o7 = (BitVec.toUInt o5 - BitVec.toUInt dh) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (∀(tl : BitVec 64) (th : BitVec 64), BitVec.toUInt tl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt th = BitVec.toUInt o6 * BitVec.toUInt dl → (∀(o8 : BitVec 64), BitVec.toUInt o8 = (BitVec.toUInt o7 + BitVec.toUInt th) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (if BitVec.toUInt o8 < BitVec.toUInt th then ∀(o9 : Bool), (if BitVec.toUInt dh < BitVec.toUInt o8 then o9 = true else ∃(o10 : Bool), ((BitVec.toUInt o8 = BitVec.toUInt dh → o10 = true) ∧ (o10 = true → o8 = dh)) ∧ (if o10 = true then o9 = (if BitVec.toUInt dl ≤ BitVec.toUInt tl then true else false) else o9 = false)) → (if o9 = true then uint'64_in_bounds (BitVec.toUInt o6 - (1 : ℤ)) ∧ (∀(o10 : BitVec 64), BitVec.toUInt o10 = BitVec.toUInt o6 - (1 : ℤ) → uint'64_in_bounds (BitVec.toUInt o10 - (1 : ℤ)) ∧ (∀(o11 : BitVec 64), BitVec.toUInt o11 = BitVec.toUInt o10 - (1 : ℤ) → reciprocal_3by2 o11 dh dl)) else uint'64_in_bounds (BitVec.toUInt o6 - (1 : ℤ)) ∧ (∀(o10 : BitVec 64), BitVec.toUInt o10 = BitVec.toUInt o6 - (1 : ℤ) → reciprocal_3by2 o10 dh dl)) else reciprocal_3by2 o6 dh dl))))))) else uint'64_in_bounds (BitVec.toUInt o1 - (1 : ℤ)) ∧ (∀(o4 : BitVec 64), BitVec.toUInt o4 = BitVec.toUInt o1 - (1 : ℤ) → (∀(o5 : BitVec 64), BitVec.toUInt o5 = (BitVec.toUInt o3 - BitVec.toUInt dh) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (∀(tl : BitVec 64) (th : BitVec 64), BitVec.toUInt tl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt th = BitVec.toUInt o4 * BitVec.toUInt dl → (∀(o6 : BitVec 64), BitVec.toUInt o6 = (BitVec.toUInt o5 + BitVec.toUInt th) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (if BitVec.toUInt o6 < BitVec.toUInt th then ∀(o7 : Bool), (if BitVec.toUInt dh < BitVec.toUInt o6 then o7 = true else ∃(o8 : Bool), ((BitVec.toUInt o6 = BitVec.toUInt dh → o8 = true) ∧ (o8 = true → o6 = dh)) ∧ (if o8 = true then o7 = (if BitVec.toUInt dl ≤ BitVec.toUInt tl then true else false) else o7 = false)) → (if o7 = true then uint'64_in_bounds (BitVec.toUInt o4 - (1 : ℤ)) ∧ (∀(o8 : BitVec 64), BitVec.toUInt o8 = BitVec.toUInt o4 - (1 : ℤ) → uint'64_in_bounds (BitVec.toUInt o8 - (1 : ℤ)) ∧ (∀(o9 : BitVec 64), BitVec.toUInt o9 = BitVec.toUInt o8 - (1 : ℤ) → reciprocal_3by2 o9 dh dl)) else uint'64_in_bounds (BitVec.toUInt o4 - (1 : ℤ)) ∧ (∀(o8 : BitVec 64), BitVec.toUInt o8 = BitVec.toUInt o4 - (1 : ℤ) → reciprocal_3by2 o8 dh dl)) else reciprocal_3by2 o4 dh dl))))) else ∀(tl : BitVec 64) (th : BitVec 64), BitVec.toUInt tl + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt th = BitVec.toUInt o1 * BitVec.toUInt dl → (∀(o4 : BitVec 64), BitVec.toUInt o4 = (BitVec.toUInt o3 + BitVec.toUInt th) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (if BitVec.toUInt o4 < BitVec.toUInt th then ∀(o5 : Bool), (if BitVec.toUInt dh < BitVec.toUInt o4 then o5 = true else ∃(o6 : Bool), ((BitVec.toUInt o4 = BitVec.toUInt dh → o6 = true) ∧ (o6 = true → o4 = dh)) ∧ (if o6 = true then o5 = (if BitVec.toUInt dl ≤ BitVec.toUInt tl then true else false) else o5 = false)) → (if o5 = true then uint'64_in_bounds (BitVec.toUInt o1 - (1 : ℤ)) ∧ (∀(o6 : BitVec 64), BitVec.toUInt o6 = BitVec.toUInt o1 - (1 : ℤ) → uint'64_in_bounds (BitVec.toUInt o6 - (1 : ℤ)) ∧ (∀(o7 : BitVec 64), BitVec.toUInt o7 = BitVec.toUInt o6 - (1 : ℤ) → reciprocal_3by2 o7 dh dl)) else uint'64_in_bounds (BitVec.toUInt o1 - (1 : ℤ)) ∧ (∀(o6 : BitVec 64), BitVec.toUInt o6 = BitVec.toUInt o1 - (1 : ℤ) → reciprocal_3by2 o6 dh dl)) else reciprocal_3by2 o1 dh dl))))))
  := sorry
end div_Div_reciprocal_word_3by2qtvc
