import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.util.Util
import pearl.multiprecision.lib.lean.ptralias.Alias
import pearl.multiprecision.lib.lean.add.Add
open Classical
open Lean4Why3
namespace mul_Mul_wmpn_addmul_1qtvc
theorem wmpn_addmul_1'vc (x : C.ptr (BitVec 64)) (sz : BitVec 32) (r : C.ptr (BitVec 64)) (y : BitVec 64) (fact0 : C.valid x (BitVec.toInt sz)) (fact1 : C.valid r (BitVec.toInt sz)) (fact2 : C.writable r = true) : C.min r ≤ C.offset r + (0 : ℤ) ∧ C.offset r + (0 : ℤ) ≤ C.max r ∧ (∀(o1 : C.ptr (BitVec 64)), C.offset o1 = C.offset r + (0 : ℤ) ∧ C.plength o1 = C.plength r ∧ C.pelts o1 = C.pelts r ∧ C.data o1 = C.data r ∧ C.min o1 = C.min r ∧ C.max o1 = C.max r ∧ C.zone1 o1 = C.zone1 r ∧ C.writable o1 = C.writable r → (C.min x ≤ C.offset x + (0 : ℤ) ∧ C.offset x + (0 : ℤ) ≤ C.max x) ∧ (∀(o2 : C.ptr (BitVec 64)), C.offset o2 = C.offset x + (0 : ℤ) ∧ C.plength o2 = C.plength x ∧ C.pelts o2 = C.pelts x ∧ C.data o2 = C.data x ∧ C.min o2 = C.min x ∧ C.max o2 = C.max x ∧ C.zone1 o2 = C.zone1 x ∧ C.writable o2 = C.writable x → (((0 : ℤ) ≤ BitVec.toInt sz ∧ BitVec.toInt sz ≤ BitVec.toInt sz) ∧ (0 : ℤ) = BitVec.toInt sz - BitVec.toInt sz ∧ Lemmas.value r (0 : ℤ) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (0 : ℕ) * (0 : ℤ) = Lemmas.value r (0 : ℤ) + Lemmas.value x (0 : ℤ) * BitVec.toUInt y ∧ C.offset o1 = C.offset r + (0 : ℤ) ∧ C.min o1 = C.min r ∧ C.max o1 = C.max r ∧ C.writable o1 = true ∧ C.pelts o1 = C.pelts r ∧ C.offset o2 = C.offset x + (0 : ℤ) ∧ C.plength o2 = C.plength x ∧ C.min o2 = C.min x ∧ C.max o2 = C.max x ∧ C.pelts o2 = C.pelts x) ∧ (∀(up : C.ptr (BitVec 64)) (rp : C.ptr (BitVec 64)) (i : BitVec 32) (n : BitVec 32) (cl : BitVec 64) (r1 : C.ptr (BitVec 64)), List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → ((0 : ℤ) ≤ BitVec.toInt n ∧ BitVec.toInt n ≤ BitVec.toInt sz) ∧ BitVec.toInt i = BitVec.toInt sz - BitVec.toInt n ∧ Lemmas.value r1 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt cl = Lemmas.value r (BitVec.toInt i) + Lemmas.value x (BitVec.toInt i) * BitVec.toUInt y ∧ C.offset rp = C.offset r1 + BitVec.toInt i ∧ C.min rp = C.min r1 ∧ C.max rp = C.max r1 ∧ C.writable rp = true ∧ C.pelts rp = C.pelts r1 ∧ C.offset up = C.offset x + BitVec.toInt i ∧ C.plength up = C.plength x ∧ C.min up = C.min x ∧ C.max up = C.max x ∧ C.pelts up = C.pelts x ∧ (∀(j : ℤ), C.offset r1 + BitVec.toInt i ≤ j ∧ j < C.offset r1 + BitVec.toInt sz → C.pelts r j = C.pelts r1 j) ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sz ≤ j → C.pelts r1 j = C.pelts r j) → (∀(o3 : Bool), (BitVec.toInt n = BitVec.toInt (0 : BitVec 32) → o3 = true) ∧ (o3 = true → n = (0 : BitVec 32)) → (if ¬o3 = true then (C.min up ≤ C.offset up ∧ C.offset up < C.max up) ∧ (C.min up ≤ C.offset up + (1 : ℤ) ∧ C.offset up + (1 : ℤ) ≤ C.max up) ∧ (∀(o4 : C.ptr (BitVec 64)), C.offset o4 = C.offset up + (1 : ℤ) ∧ C.plength o4 = C.plength up ∧ C.pelts o4 = C.pelts up ∧ C.data o4 = C.data up ∧ C.min o4 = C.min up ∧ C.max o4 = C.max up ∧ C.zone1 o4 = C.zone1 up ∧ C.writable o4 = C.writable up → (∀(l : BitVec 64) (h : BitVec 64), BitVec.toUInt l + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt h = BitVec.toUInt (C.pelts up (C.offset up)) * BitVec.toUInt y → (∀(o5 : BitVec 64), BitVec.toUInt o5 = (BitVec.toUInt l + BitVec.toUInt cl) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (∀(o6 : BitVec 64), (if BitVec.toUInt o5 < BitVec.toUInt cl then o6 = (1 : BitVec 64) else o6 = (0 : BitVec 64)) → uint'64_in_bounds (BitVec.toUInt o6 + BitVec.toUInt h) ∧ (∀(o7 : BitVec 64), BitVec.toUInt o7 = BitVec.toUInt o6 + BitVec.toUInt h → BitVec.toUInt o5 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt o7 = BitVec.toUInt (C.pelts up (C.offset up)) * BitVec.toUInt y + BitVec.toUInt cl)) ∧ (∀(cl1 : BitVec 64), BitVec.toUInt o5 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt cl1 = BitVec.toUInt (C.pelts up (C.offset up)) * BitVec.toUInt y + BitVec.toUInt cl → (C.min rp ≤ C.offset rp ∧ C.offset rp < C.max rp) ∧ (∀(o6 : BitVec 64), BitVec.toUInt o6 = (BitVec.toUInt (C.pelts rp (C.offset rp)) + BitVec.toUInt o5) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → (∀(o7 : BitVec 64), (if BitVec.toUInt o6 < BitVec.toUInt (C.pelts rp (C.offset rp)) then o7 = (1 : BitVec 64) else o7 = (0 : BitVec 64)) → uint'64_in_bounds (BitVec.toUInt o7 + BitVec.toUInt cl1) ∧ (∀(o8 : BitVec 64), BitVec.toUInt o8 = BitVec.toUInt o7 + BitVec.toUInt cl1 → BitVec.toUInt o6 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt o8 = BitVec.toUInt (C.pelts up (C.offset up)) * BitVec.toUInt y + BitVec.toUInt cl + BitVec.toUInt (C.pelts rp (C.offset rp)))) ∧ (∀(cl2 : BitVec 64), BitVec.toUInt o6 + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt cl2 = BitVec.toUInt (C.pelts up (C.offset up)) * BitVec.toUInt y + BitVec.toUInt cl + BitVec.toUInt (C.pelts rp (C.offset rp)) → ((C.min rp ≤ C.offset rp ∧ C.offset rp < C.max rp) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)) (r2 : C.ptr (BitVec 64)), C.data rp1 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → C.data rp1 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → List.length (C.data r2) = List.length (C.data r1) ∧ C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.max r2 = C.max r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → C.pelts rp1 = Function.update (C.pelts rp) (C.offset rp1) o6 → (C.min rp1 ≤ C.offset rp1 + (1 : ℤ) ∧ C.offset rp1 + (1 : ℤ) ≤ C.max rp1) ∧ (∀(o7 : C.ptr (BitVec 64)), C.offset o7 = C.offset rp1 + (1 : ℤ) ∧ C.plength o7 = C.plength rp1 ∧ C.pelts o7 = C.pelts rp1 ∧ C.data o7 = C.data rp1 ∧ C.min o7 = C.min rp1 ∧ C.max o7 = C.max rp1 ∧ C.zone1 o7 = C.zone1 rp1 ∧ C.writable o7 = C.writable rp1 → int'32_in_bounds (BitVec.toInt n - (1 : ℤ)) ∧ (∀(o8 : BitVec 32), BitVec.toInt o8 = BitVec.toInt n - (1 : ℤ) → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o9 : BitVec 32), BitVec.toInt o9 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt sz - BitVec.toInt i ∧ BitVec.toInt sz - BitVec.toInt o9 < BitVec.toInt sz - BitVec.toInt i) ∧ ((0 : ℤ) ≤ BitVec.toInt o8 ∧ BitVec.toInt o8 ≤ BitVec.toInt sz) ∧ BitVec.toInt o9 = BitVec.toInt sz - BitVec.toInt o8 ∧ Lemmas.value r2 (BitVec.toInt o9) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o9)) * BitVec.toUInt cl2 = Lemmas.value r (BitVec.toInt o9) + Lemmas.value x (BitVec.toInt o9) * BitVec.toUInt y ∧ C.offset o7 = C.offset r2 + BitVec.toInt o9 ∧ C.min o7 = C.min r2 ∧ C.max o7 = C.max r2 ∧ C.writable o7 = true ∧ C.pelts o7 = C.pelts r2 ∧ C.offset o4 = C.offset x + BitVec.toInt o9 ∧ C.plength o4 = C.plength x ∧ C.min o4 = C.min x ∧ C.max o4 = C.max x ∧ C.pelts o4 = C.pelts x ∧ (∀(j : ℤ), C.offset r2 + BitVec.toInt o9 ≤ j ∧ j < C.offset r2 + BitVec.toInt sz → C.pelts r j = C.pelts r2 j) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sz ≤ j → C.pelts r2 j = C.pelts r j))))))))))) else Lemmas.value r1 (BitVec.toInt sz) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sz)) * BitVec.toUInt cl = Lemmas.value r (BitVec.toInt sz) + Lemmas.value x (BitVec.toInt sz) * BitVec.toUInt y ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sz ≤ j → C.pelts r1 j = C.pelts r j))))))
  := sorry
end mul_Mul_wmpn_addmul_1qtvc
