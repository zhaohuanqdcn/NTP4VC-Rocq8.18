import Why3.Base
import Why3.why3.Ref.Ref
import pearl.longest_increasing_subsequence_vcg.lean.longest_increasing_subsequence.Spec
open Classical
open Lean4Why3
namespace longest_increasing_subsequence_Backtracking_lissqtvc
theorem liss'vc (w : List Spec.elt) : (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length w) → (let o1 : List ℤ := [i]; Int.ofNat (List.length o1) = (1 : ℤ) ∧ o1[(0 : ℕ)]! = i → (let o2 : ℤ := Int.ofNat (List.length w) - (1 : ℤ); let o3 : ℤ := i + (1 : ℤ); (o3 ≤ o2 + (1 : ℤ) → (((1 : ℤ) = Int.ofNat (List.length o1) ∧ (0 : ℤ) < Int.ofNat (List.length o1)) ∧ o1[(0 : ℕ)]! = i ∧ Spec.iss o1 w ∧ (∀(s' : List ℤ), Spec.iss s' w → (2 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! = i ∧ i < s'[(1 : ℕ)]! ∧ s'[(1 : ℕ)]! < o3 → List.length s' ≤ List.length o1)) ∧ (∀(s : List ℤ) (len : ℤ), (∀(j : ℤ), (o3 ≤ j ∧ j ≤ o2) ∧ (len = Int.ofNat (List.length s) ∧ (0 : ℤ) < Int.ofNat (List.length s)) ∧ s[(0 : ℕ)]! = i ∧ Spec.iss s w ∧ (∀(s' : List ℤ), Spec.iss s' w → (2 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! = i ∧ i < s'[(1 : ℕ)]! ∧ s'[(1 : ℕ)]! < j → List.length s' ≤ List.length s) → (if Spec.lt (w[Int.toNat i]!) (w[Int.toNat j]!) then (((0 : ℤ) ≤ Int.ofNat (List.length w) - i ∧ Int.ofNat (List.length w) - j < Int.ofNat (List.length w) - i) ∧ (0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length w)) ∧ (∀(sj : List ℤ), (0 : ℤ) < Int.ofNat (List.length sj) ∧ sj[(0 : ℕ)]! = j ∧ Spec.iss sj w ∧ (∀(s' : List ℤ), Spec.iss s' w → (1 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! = j → List.length s' ≤ List.length sj) → (if len < (1 : ℤ) + Int.ofNat (List.length sj) then let o4 : List ℤ := List.cons i sj; Int.ofNat (List.length o4) = (1 : ℤ) + Int.ofNat (List.length sj) ∧ o4[(0 : ℕ)]! = i ∧ (∀(i1 : ℤ), (0 : ℤ) < i1 ∧ i1 ≤ Int.ofNat (List.length sj) → o4[Int.toNat i1]! = sj[Int.toNat (i1 - (1 : ℤ))]!) → ((1 : ℤ) + Int.ofNat (List.length sj) = Int.ofNat (List.length o4) ∧ (0 : ℤ) < Int.ofNat (List.length o4)) ∧ o4[(0 : ℕ)]! = i ∧ Spec.iss o4 w ∧ (∀(s' : List ℤ), Spec.iss s' w → (2 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! = i ∧ i < s'[(1 : ℕ)]! ∧ s'[(1 : ℕ)]! < j + (1 : ℤ) → List.length s' ≤ List.length o4) else (len = Int.ofNat (List.length s) ∧ (0 : ℤ) < Int.ofNat (List.length s)) ∧ s[(0 : ℕ)]! = i ∧ Spec.iss s w ∧ (∀(s' : List ℤ), Spec.iss s' w → (2 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! = i ∧ i < s'[(1 : ℕ)]! ∧ s'[(1 : ℕ)]! < j + (1 : ℤ) → List.length s' ≤ List.length s))) else (len = Int.ofNat (List.length s) ∧ (0 : ℤ) < Int.ofNat (List.length s)) ∧ s[(0 : ℕ)]! = i ∧ Spec.iss s w ∧ (∀(s' : List ℤ), Spec.iss s' w → (2 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! = i ∧ i < s'[(1 : ℕ)]! ∧ s'[(1 : ℕ)]! < j + (1 : ℤ) → List.length s' ≤ List.length s))) ∧ ((len = Int.ofNat (List.length s) ∧ (0 : ℤ) < Int.ofNat (List.length s)) ∧ s[(0 : ℕ)]! = i ∧ Spec.iss s w ∧ (∀(s' : List ℤ), Spec.iss s' w → (2 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! = i ∧ i < s'[(1 : ℕ)]! ∧ s'[(1 : ℕ)]! < o2 + (1 : ℤ) → List.length s' ≤ List.length s) → (len = Int.ofNat (List.length s) ∧ (0 : ℤ) < Int.ofNat (List.length s)) ∧ s[(0 : ℕ)]! = i ∧ Spec.iss s w ∧ (∀(s' : List ℤ), Spec.iss s' w → (1 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! = i → List.length s' ≤ List.length s)))) ∧ (o2 + (1 : ℤ) < o3 → ((1 : ℤ) = Int.ofNat (List.length o1) ∧ (0 : ℤ) < Int.ofNat (List.length o1)) ∧ o1[(0 : ℕ)]! = i ∧ Spec.iss o1 w ∧ (∀(s' : List ℤ), Spec.iss s' w → (1 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! = i → List.length s' ≤ List.length o1))))) ∧ (let o1 : ℤ := Int.ofNat (List.length w) - (1 : ℤ); ((0 : ℤ) ≤ o1 + (1 : ℤ) → ((0 : ℤ) = Int.ofNat (List.length ([] : List ℤ)) ∧ Spec.iss ([] : List ℤ) w ∧ (∀(s' : List ℤ), Spec.iss s' w → (1 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! < (0 : ℤ) → List.length s' ≤ List.length ([] : List ℤ))) ∧ (∀(s : List ℤ) (len : ℤ), (∀(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ o1) ∧ len = Int.ofNat (List.length s) ∧ Spec.iss s w ∧ (∀(s' : List ℤ), Spec.iss s' w → (1 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! < i → List.length s' ≤ List.length s) → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length w)) ∧ (∀(si : List ℤ), (0 : ℤ) < Int.ofNat (List.length si) ∧ si[(0 : ℕ)]! = i ∧ Spec.iss si w ∧ (∀(s' : List ℤ), Spec.iss s' w → (1 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! = i → List.length s' ≤ List.length si) → (if len < Int.ofNat (List.length si) then Spec.iss si w ∧ (∀(s' : List ℤ), Spec.iss s' w → (1 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! < i + (1 : ℤ) → List.length s' ≤ List.length si) else len = Int.ofNat (List.length s) ∧ Spec.iss s w ∧ (∀(s' : List ℤ), Spec.iss s' w → (1 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! < i + (1 : ℤ) → List.length s' ≤ List.length s)))) ∧ (len = Int.ofNat (List.length s) ∧ Spec.iss s w ∧ (∀(s' : List ℤ), Spec.iss s' w → (1 : ℤ) ≤ Int.ofNat (List.length s') → s'[(0 : ℕ)]! < o1 + (1 : ℤ) → List.length s' ≤ List.length s) → len = Int.ofNat (List.length s) ∧ Spec.liss s w))) ∧ (o1 + (1 : ℤ) < (0 : ℤ) → (0 : ℤ) = Int.ofNat (List.length ([] : List ℤ)) ∧ Spec.liss ([] : List ℤ) w))
  := sorry
end longest_increasing_subsequence_Backtracking_lissqtvc
