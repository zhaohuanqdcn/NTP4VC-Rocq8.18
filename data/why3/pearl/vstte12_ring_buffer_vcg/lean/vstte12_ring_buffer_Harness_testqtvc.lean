import Why3.Base
import pearl.vstte12_ring_buffer_vcg.lean.vstte12_ring_buffer.RingBuffer
open Classical
open Lean4Why3
namespace vstte12_ring_buffer_Harness_testqtvc
theorem test'vc (x : ℤ) (y : ℤ) (z : ℤ) : (0 : ℤ) < (2 : ℤ) ∧ (∀(b : RingBuffer.buffer ℤ), RingBuffer.size b = (2 : ℤ) ∧ RingBuffer.sequence b = ([] : List ℤ) → RingBuffer.len b < RingBuffer.size b ∧ (∀(b1 : RingBuffer.buffer ℤ), List.length (RingBuffer.data b1) = List.length (RingBuffer.data b) → RingBuffer.first b = RingBuffer.first b1 → RingBuffer.len b1 = RingBuffer.len b + (1 : ℤ) ∧ RingBuffer.sequence b1 = RingBuffer.sequence b ++ List.cons x ([] : List ℤ) → RingBuffer.len b1 < RingBuffer.size b1 ∧ (∀(b2 : RingBuffer.buffer ℤ), List.length (RingBuffer.data b2) = List.length (RingBuffer.data b1) → RingBuffer.first b1 = RingBuffer.first b2 → RingBuffer.len b2 = RingBuffer.len b1 + (1 : ℤ) ∧ RingBuffer.sequence b2 = RingBuffer.sequence b1 ++ List.cons y ([] : List ℤ) → (0 : ℤ) < RingBuffer.len b2 ∧ (∀(b3 : RingBuffer.buffer ℤ), RingBuffer.data b2 = RingBuffer.data b3 → (∀(h : ℤ), RingBuffer.len b3 = RingBuffer.len b2 - (1 : ℤ) ∧ (match RingBuffer.sequence b2 with | ([] : List ℤ) => False | List.cons x1 l => h = x1 ∧ RingBuffer.sequence b3 = l) → RingBuffer.len b3 < RingBuffer.size b3 ∧ (∀(b4 : RingBuffer.buffer ℤ), List.length (RingBuffer.data b4) = List.length (RingBuffer.data b3) → RingBuffer.first b3 = RingBuffer.first b4 → RingBuffer.len b4 = RingBuffer.len b3 + (1 : ℤ) ∧ RingBuffer.sequence b4 = RingBuffer.sequence b3 ++ List.cons z ([] : List ℤ) → (0 : ℤ) < RingBuffer.len b4 ∧ (∀(b5 : RingBuffer.buffer ℤ), RingBuffer.data b4 = RingBuffer.data b5 → (∀(h1 : ℤ), RingBuffer.len b5 = RingBuffer.len b4 - (1 : ℤ) ∧ (match RingBuffer.sequence b4 with | ([] : List ℤ) => False | List.cons x1 l => h1 = x1 ∧ RingBuffer.sequence b5 = l) → (0 : ℤ) < RingBuffer.len b5))))))))
  := sorry
end vstte12_ring_buffer_Harness_testqtvc
