theory optimal_replay_OptimalReplay_distanceqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref"
begin
consts n :: "int"
axiomatization where n'def:   "(0 :: int) < n"
consts f :: "int \<Rightarrow> int"
axiomatization where f'spec'0:   "(0 :: int) \<le> f k"
 if "(0 :: int) < k"
 and "k < n"
  for k :: "int"
axiomatization where f'spec'1:   "f k < k"
 if "(0 :: int) < k"
 and "k < n"
  for k :: "int"
inductive path :: "int \<Rightarrow> int \<Rightarrow> bool" where
   path0: "path (0 :: int) (0 :: int)"
 | paths: "(0 :: int) \<le> i \<Longrightarrow> i < n \<Longrightarrow> path d j \<Longrightarrow> f i \<le> j \<Longrightarrow> j < i \<Longrightarrow> path (d + (1 :: int)) i" for i :: "int" and d :: "int" and j :: "int"
definition distance :: "int \<Rightarrow> int \<Rightarrow> _"
  where "distance d i \<longleftrightarrow> path d i \<and> (\<forall>(d' :: int). path d' i \<longrightarrow> d \<le> d')" for d i
theorem distance'vc:
  shows "let o1 :: int = n in (0 :: int) \<le> o1 \<and> (\<forall>(g :: int list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < o1 \<longrightarrow> g ! nat i = (0 :: int)) \<and> int (length g) = o1 \<longrightarrow> ((0 :: int) \<le> (0 :: int) \<and> (0 :: int) < int (length g)) \<and> (length (g[nat (0 :: int) := -(1 :: int)]) = length g \<longrightarrow> nth (g[nat (0 :: int) := -(1 :: int)]) o nat = (nth g o nat)(0 :: int := -(1 :: int)) \<longrightarrow> (let o2 :: int = n in (0 :: int) \<le> o2 \<and> (\<forall>(d :: int list). (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < o2 \<longrightarrow> d ! nat i = (0 :: int)) \<and> int (length d) = o2 \<longrightarrow> (let o3 :: int = n - (1 :: int) in (1 :: int) \<le> o3 + (1 :: int) \<longrightarrow> ((d ! (0 :: nat) = (0 :: int) \<and> g[nat (0 :: int) := -(1 :: int)] ! (0 :: nat) = -(1 :: int) \<and> (0 :: int) + d ! nat ((1 :: int) - (1 :: int)) \<le> (1 :: int) - (1 :: int)) \<and> (\<forall>(k :: int). (0 :: int) < k \<and> k < (1 :: int) \<longrightarrow> (g[nat (0 :: int) := -(1 :: int)] ! nat (g[nat (0 :: int) := -(1 :: int)] ! nat k) < f k \<and> f k \<le> g[nat (0 :: int) := -(1 :: int)] ! nat k \<and> g[nat (0 :: int) := -(1 :: int)] ! nat k < k) \<and> ((0 :: int) < d ! nat k \<and> d ! nat k = d ! nat (g[nat (0 :: int) := -(1 :: int)] ! nat k) + (1 :: int)) \<and> (\<forall>(k' :: int). g[nat (0 :: int) := -(1 :: int)] ! nat k < k' \<and> k' < k \<longrightarrow> d ! nat (g[nat (0 :: int) := -(1 :: int)] ! nat k) < d ! nat k')) \<and> (\<forall>(k :: int). (0 :: int) \<le> k \<and> k < (1 :: int) \<longrightarrow> distance (d ! nat k) k)) \<and> (\<forall>(count :: int) (d1 :: int list) (g1 :: int list). length d1 = length d \<longrightarrow> length g1 = length (g[nat (0 :: int) := -(1 :: int)]) \<longrightarrow> (\<forall>(i :: int). ((1 :: int) \<le> i \<and> i \<le> o3) \<and> (d1 ! (0 :: nat) = (0 :: int) \<and> g1 ! (0 :: nat) = -(1 :: int) \<and> count + d1 ! nat (i - (1 :: int)) \<le> i - (1 :: int)) \<and> (\<forall>(k :: int). (0 :: int) < k \<and> k < i \<longrightarrow> (g1 ! nat (g1 ! nat k) < f k \<and> f k \<le> g1 ! nat k \<and> g1 ! nat k < k) \<and> ((0 :: int) < d1 ! nat k \<and> d1 ! nat k = d1 ! nat (g1 ! nat k) + (1 :: int)) \<and> (\<forall>(k' :: int). g1 ! nat k < k' \<and> k' < k \<longrightarrow> d1 ! nat (g1 ! nat k) < d1 ! nat k')) \<and> (\<forall>(k :: int). (0 :: int) \<le> k \<and> k < i \<longrightarrow> distance (d1 ! nat k) k) \<longrightarrow> (let o4 :: int = i - (1 :: int) in (((f i \<le> o4 \<and> o4 < i) \<and> count + d1 ! nat o4 \<le> i - (1 :: int)) \<and> (\<forall>(k :: int). o4 < k \<and> k < i \<longrightarrow> d1 ! nat o4 < d1 ! nat k)) \<and> (\<forall>(j :: int) (count1 :: int). ((f i \<le> j \<and> j < i) \<and> count1 + d1 ! nat j \<le> i - (1 :: int)) \<and> (\<forall>(k :: int). j < k \<and> k < i \<longrightarrow> d1 ! nat j < d1 ! nat k) \<longrightarrow> ((0 :: int) < i \<and> i < n) \<and> (let o5 :: int = f i in (0 :: int) \<le> o5 \<and> o5 < i \<longrightarrow> ((0 :: int) \<le> j \<and> j < int (length g1)) \<and> (if o5 \<le> g1 ! nat j then ((0 :: int) \<le> j \<and> j < int (length g1)) \<and> ((0 :: int) \<le> j \<and> g1 ! nat j < j) \<and> ((f i \<le> g1 ! nat j \<and> g1 ! nat j < i) \<and> count1 + (1 :: int) + d1 ! nat (g1 ! nat j) \<le> i - (1 :: int)) \<and> (\<forall>(k :: int). g1 ! nat j < k \<and> k < i \<longrightarrow> d1 ! nat (g1 ! nat j) < d1 ! nat k) else ((0 :: int) \<le> j \<and> j < int (length d1)) \<and> (let o6 :: int = (1 :: int) + d1 ! nat j in ((0 :: int) \<le> i \<and> i < int (length d1)) \<and> (length (d1[nat i := o6]) = length d1 \<longrightarrow> nth (d1[nat i := o6]) o nat = (nth d1 o nat)(i := o6) \<longrightarrow> ((0 :: int) \<le> i \<and> i < int (length g1)) \<and> (length (g1[nat i := j]) = length g1 \<longrightarrow> nth (g1[nat i := j]) o nat = (nth g1 o nat)(i := j) \<longrightarrow> (d1[nat i := o6] ! (0 :: nat) = (0 :: int) \<and> g1[nat i := j] ! (0 :: nat) = -(1 :: int) \<and> count1 + d1[nat i := o6] ! nat (i + (1 :: int) - (1 :: int)) \<le> i + (1 :: int) - (1 :: int)) \<and> (\<forall>(k :: int). (0 :: int) < k \<and> k < i + (1 :: int) \<longrightarrow> (g1[nat i := j] ! nat (g1[nat i := j] ! nat k) < f k \<and> f k \<le> g1[nat i := j] ! nat k \<and> g1[nat i := j] ! nat k < k) \<and> ((0 :: int) < d1[nat i := o6] ! nat k \<and> d1[nat i := o6] ! nat k = d1[nat i := o6] ! nat (g1[nat i := j] ! nat k) + (1 :: int)) \<and> (\<forall>(k' :: int). g1[nat i := j] ! nat k < k' \<and> k' < k \<longrightarrow> d1[nat i := o6] ! nat (g1[nat i := j] ! nat k) < d1[nat i := o6] ! nat k')) \<and> (\<forall>(k :: int). (0 :: int) \<le> k \<and> k < i + (1 :: int) \<longrightarrow> distance (d1[nat i := o6] ! nat k) k)))))))))))))))"
  sorry
end
