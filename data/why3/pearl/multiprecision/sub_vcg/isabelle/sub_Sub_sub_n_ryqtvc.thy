theory sub_Sub_sub_n_ryqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.c_C" "mach.int_Unsigned" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/ptralias_Alias"
begin
theorem sub_n_ry'vc:
  fixes sz :: "32 word"
  fixes x :: "64 word ptr"
  fixes y :: "64 word ptr"
  assumes fact0: "(0 :: int) \<le> sint sz"
  assumes fact1: "valid x (sint sz)"
  assumes fact2: "valid y (sint sz)"
  assumes fact3: "writable y = True"
  shows "valid y (sint sz)"
  and "valid x (sint sz)"
  and "(0 :: int) \<le> sint sz"
  and "sint sz \<le> sint sz"
  and "writable y = True"
  and "\<forall>(y1 :: 64 word ptr) (x1 :: 64 word ptr). offset y1 = offset y \<and> writable y1 = writable y \<and> zone1 y1 = zone1 y \<longrightarrow> offset x1 = offset x \<and> writable x1 = writable x \<and> zone1 x1 = zone1 x \<longrightarrow> (\<forall>(nr :: 64 word ptr) (ny :: 64 word ptr) (nx :: 64 word ptr) (m :: mem). writable nr = True \<and> (value ny (sint sz) = value y (sint sz) \<and> value nx (sint sz) = value x (sint sz)) \<and> (valid ny (sint sz) \<and> valid nx (sint sz)) \<and> identical nr ny \<and> ((0 :: int) \<le> offset ny \<and> offset ny + sint sz \<le> offset nx \<or> (0 :: int) \<le> offset nx \<and> offset nx + sint sz \<le> offset ny) \<and> (zx m = zone1 y1 \<and> zy m = zone1 x1) \<and> (sint (mx m) = c_C.max y \<and> sint (my m) = c_C.max x) \<and> (lx m = sz \<and> ly m = sz) \<and> ok m = True \<and> map_eq_sub_shift (pelts ny) (pelts y1) (offset ny) (offset y1) (sint sz) \<and> map_eq_sub_shift (pelts nx) (pelts x1) (offset nx) (offset x1) (sint sz) \<and> (pelts y1 = pelts y \<and> pelts x1 = pelts x) \<and> (plength y1 = plength y \<and> plength x1 = plength x) \<and> (c_C.min y1 = c_C.min y \<and> c_C.min x1 = c_C.min x) \<and> data nr = data ny \<and> data ny = data nx \<longrightarrow> ((0 :: int) \<le> sint sz \<and> (valid nr (sint sz) \<and> valid nx (sint sz) \<and> valid ny (sint sz)) \<and> (offset nr = offset nx \<or> offset nr + sint sz \<le> offset nx \<or> offset nx + sint sz \<le> offset nr) \<and> (offset nr = offset ny \<or> offset nr + sint sz \<le> offset ny \<or> offset ny + sint sz \<le> offset nr) \<and> (data nr = data nx \<and> data nx = data ny) \<and> writable nr = True) \<and> (\<forall>(nx1 :: 64 word ptr) (ny1 :: 64 word ptr) (nr1 :: 64 word ptr). data nx1 = data nr1 \<and> length (data nr1) = length (data nx) \<and> offset nx1 = offset nx \<and> c_C.min nx1 = c_C.min nx \<and> c_C.max nx1 = c_C.max nx \<and> writable nx1 = writable nx \<and> zone1 nx1 = zone1 nx \<longrightarrow> data ny1 = data nr1 \<and> length (data nr1) = length (data ny) \<and> offset ny1 = offset ny \<and> c_C.min ny1 = c_C.min ny \<and> c_C.max ny1 = c_C.max ny \<and> writable ny1 = writable ny \<and> zone1 ny1 = zone1 ny \<longrightarrow> length (data nr1) = length (data nr) \<and> offset nr1 = offset nr \<and> c_C.min nr1 = c_C.min nr \<and> c_C.max nr1 = c_C.max nr \<and> writable nr1 = writable nr \<and> zone1 nr1 = zone1 nr \<longrightarrow> (\<forall>(res :: 64 word). value nr1 (sint sz) - ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sz * uint res = value nx (sint sz) - value ny (sint sz) \<and> ((0 :: int) \<le> uint res \<and> uint res \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset nr1 \<or> offset nr1 + sint sz \<le> j \<longrightarrow> pelts nr1 j = pelts nr j) \<and> (offset nr1 = offset nx1 \<or> map_eq_sub (pelts nx1) (pelts nx) (offset nx1) (offset nx1 + sint sz)) \<and> (offset nr1 = offset ny1 \<or> map_eq_sub (pelts ny1) (pelts ny) (offset ny1) (offset ny1 + sint sz)) \<longrightarrow> ((writable y1 = True \<and> writable nr1 = True) \<and> ok m = True \<and> ((0 :: int) \<le> sint sz \<and> sint sz \<le> sint sz) \<and> identical nr1 ny1 \<and> ((0 :: int) \<le> offset ny1 \<and> offset ny1 + sint sz \<le> offset nx1 \<or> (0 :: int) \<le> offset nx1 \<and> offset nx1 + sint sz \<le> offset ny1) \<and> (zx m = zone1 y1 \<and> zy m = zone1 x1) \<and> lx m = sz \<and> ly m = sz) \<and> (\<forall>(m1 :: mem) (nx2 :: 64 word ptr) (ny2 :: 64 word ptr) (y2 :: 64 word ptr) (x2 :: 64 word ptr). zr m1 = zr m \<and> zx m1 = zx m \<and> zy m1 = zy m \<and> mr m1 = mr m \<and> mx m1 = mx m \<and> my m1 = my m \<and> lr m1 = lr m \<and> lx m1 = lx m \<and> ly m1 = ly m \<longrightarrow> offset nx2 = offset nx1 \<and> writable nx2 = writable nx1 \<and> zone1 nx2 = zone1 nx1 \<longrightarrow> offset ny2 = offset ny1 \<and> writable ny2 = writable ny1 \<and> zone1 ny2 = zone1 ny1 \<longrightarrow> offset y2 = offset y1 \<and> c_C.min y2 = c_C.min y1 \<and> writable y2 = writable y1 \<and> zone1 y2 = zone1 y1 \<longrightarrow> offset x2 = offset x1 \<and> c_C.min x2 = c_C.min x1 \<and> writable x2 = writable x1 \<and> zone1 x2 = zone1 x1 \<longrightarrow> (c_C.max y2 = sint (mx m1) \<and> c_C.max x2 = sint (my m1)) \<and> map_eq_sub_shift (pelts ny1) (pelts y2) (offset ny2) (offset y2) (sint sz) \<and> map_eq_sub_shift (pelts nx1) (pelts x2) (offset nx2) (offset x2) (sint sz) \<and> (\<forall>(j :: int). j < offset y2 \<or> offset y2 + sint sz \<le> j \<longrightarrow> pelts y2 j = pelts y1 j) \<and> (\<forall>(j :: int). j < offset x2 \<or> offset x2 + sint sz \<le> j \<longrightarrow> pelts x2 j = pelts x1 j) \<and> (plength y2 = plength y1 \<and> plength x2 = plength x1) \<and> c_C.min y2 = c_C.min y1 \<and> c_C.min x2 = c_C.min x1 \<longrightarrow> value y2 (sint sz) - ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sz * uint res = value x (sint sz) - value y (sint sz) \<and> ((0 :: int) \<le> uint res \<and> uint res \<le> (1 :: int)) \<and> (\<forall>(j :: int). j < offset y2 \<or> offset y2 + sint sz \<le> j \<longrightarrow> pelts y2 j = pelts y j) \<and> (\<forall>(j :: int). pelts x2 j = pelts x j) \<and> value x2 (sint sz) = value x (sint sz) \<and> (c_C.min x2 = c_C.min x \<and> c_C.max x2 = c_C.max x \<and> plength x2 = plength x) \<and> c_C.min y2 = c_C.min y \<and> c_C.max y2 = c_C.max y \<and> plength y2 = plength y))))"
  sorry
end
