import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.c.C
import Why3.mach.int.Unsigned
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.ptralias.Alias
open Classical
open Lean4Why3
namespace add_AddOld_wmpn_add_in_placeqtvc
theorem wmpn_add_in_place'vc (sy : BitVec 32) (sx : BitVec 32) (x : C.ptr (BitVec 64)) (y : C.ptr (BitVec 64)) (fact0 : (0 : ℤ) ≤ BitVec.toInt sy) (fact1 : BitVec.toInt sy ≤ BitVec.toInt sx) (fact2 : C.valid x (BitVec.toInt sx)) (fact3 : C.valid y (BitVec.toInt sy)) (fact4 : C.writable x = true) : C.valid x (BitVec.toInt sy) ∧ C.valid y (BitVec.toInt sy) ∧ C.writable x = true ∧ (∀(x1 : C.ptr (BitVec 64)), List.length (C.data x1) = List.length (C.data x) ∧ C.offset x1 = C.offset x ∧ C.min x1 = C.min x ∧ C.max x1 = C.max x ∧ C.writable x1 = C.writable x ∧ C.zone1 x1 = C.zone1 x → (∀(o1 : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (1 : ℤ)) ∧ Lemmas.value x1 (BitVec.toInt sy) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sy)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt sy) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset x1 ∨ C.offset x1 + BitVec.toInt sy ≤ j → C.pelts x1 j = C.pelts x j) → (∀(o2 : Bool), (BitVec.toUInt o1 = BitVec.toUInt (0 : BitVec 64) → o2 = true) ∧ (o2 = true → o1 = (0 : BitVec 64)) → (if ¬o2 = true then ((BitVec.toInt sy ≤ BitVec.toInt sy ∧ BitVec.toInt sy ≤ BitVec.toInt sx) ∧ Lemmas.value x1 (BitVec.toInt sy) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sy)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt sy) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (1 : ℤ)) ∧ (sy = sx ∨ BitVec.toUInt o1 = (1 : ℤ)) ∧ (∀(j : ℤ), BitVec.toInt sy ≤ j ∧ j < BitVec.toInt sx → C.pelts x1 (C.offset x1 + j) = C.pelts x (C.offset x1 + j)) ∧ (∀(j : ℤ), j < C.offset x1 ∨ C.offset x1 + BitVec.toInt sx ≤ j → C.pelts x1 j = C.pelts x j)) ∧ (∀(i : BitVec 32) (c : BitVec 64) (x2 : C.ptr (BitVec 64)), List.length (C.data x2) = List.length (C.data x1) ∧ C.offset x2 = C.offset x1 ∧ C.min x2 = C.min x1 ∧ C.max x2 = C.max x1 ∧ C.writable x2 = C.writable x1 ∧ C.zone1 x2 = C.zone1 x1 → (BitVec.toInt sy ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sx) ∧ Lemmas.value x2 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt i) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (i = sx ∨ BitVec.toUInt c = (1 : ℤ)) ∧ (∀(j : ℤ), BitVec.toInt i ≤ j ∧ j < BitVec.toInt sx → C.pelts x2 (C.offset x2 + j) = C.pelts x (C.offset x2 + j)) ∧ (∀(j : ℤ), j < C.offset x2 ∨ C.offset x2 + BitVec.toInt sx ≤ j → C.pelts x2 j = C.pelts x j) → (if BitVec.toInt i < BitVec.toInt sx then (C.min x2 ≤ C.offset x2 + BitVec.toInt i ∧ C.offset x2 + BitVec.toInt i < C.max x2) ∧ (∀(res : BitVec 64), BitVec.toUInt res = (BitVec.toUInt (C.pelts x2 (C.offset x2 + BitVec.toInt i)) + (1 : ℤ)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → ((C.min x2 ≤ C.offset x2 + BitVec.toInt i ∧ C.offset x2 + BitVec.toInt i < C.max x2) ∧ C.writable x2 = true) ∧ (∀(x3 : C.ptr (BitVec 64)), List.length (C.data x3) = List.length (C.data x2) ∧ C.offset x3 = C.offset x2 ∧ C.min x3 = C.min x2 ∧ C.max x3 = C.max x2 ∧ C.writable x3 = C.writable x2 ∧ C.zone1 x3 = C.zone1 x2 → C.pelts x3 = Function.update (C.pelts x2) (C.offset x3 + BitVec.toInt i) res ∧ C.pelts x3 (C.offset x3 + BitVec.toInt i) = res → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt i + (1 : ℤ) → (∀(o4 : Bool), (BitVec.toUInt res = BitVec.toUInt (0 : BitVec 64) → o4 = true) ∧ (o4 = true → res = (0 : BitVec 64)) → (if ¬o4 = true then Lemmas.value x3 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt sx) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt (0 : BitVec 64) ∧ BitVec.toUInt (0 : BitVec 64) ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset x3 ∨ C.offset x3 + BitVec.toInt sx ≤ j → C.pelts x3 j = C.pelts x j) else ((0 : ℤ) ≤ BitVec.toInt sx - BitVec.toInt i ∧ BitVec.toInt sx - BitVec.toInt o3 < BitVec.toInt sx - BitVec.toInt i) ∧ (BitVec.toInt sy ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ BitVec.toInt sx) ∧ Lemmas.value x3 (BitVec.toInt o3) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o3)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt o3) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (o3 = sx ∨ BitVec.toUInt c = (1 : ℤ)) ∧ (∀(j : ℤ), BitVec.toInt o3 ≤ j ∧ j < BitVec.toInt sx → C.pelts x3 (C.offset x3 + j) = C.pelts x (C.offset x3 + j)) ∧ (∀(j : ℤ), j < C.offset x3 ∨ C.offset x3 + BitVec.toInt sx ≤ j → C.pelts x3 j = C.pelts x j)))))) else Lemmas.value x2 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt sx) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset x2 ∨ C.offset x2 + BitVec.toInt sx ≤ j → C.pelts x2 j = C.pelts x j))) else Lemmas.value x1 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt sx) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset x1 ∨ C.offset x1 + BitVec.toInt sx ≤ j → C.pelts x1 j = C.pelts x j)))))
  := sorry
end add_AddOld_wmpn_add_in_placeqtvc
