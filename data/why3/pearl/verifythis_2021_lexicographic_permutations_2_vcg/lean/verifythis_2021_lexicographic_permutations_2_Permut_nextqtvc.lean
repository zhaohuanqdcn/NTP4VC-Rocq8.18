import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.MapEq
import Why3.map.MapExchange
import Why3.map.MapPermut
import Why3.array.IntArraySorted
open Classical
open Lean4Why3
namespace verifythis_2021_lexicographic_permutations_2_Permut_nextqtvc
noncomputable def sorted_sub (a : List ℤ) (l : ℤ) (u : ℤ) := ∀(i1 : ℤ) (i2 : ℤ), l ≤ i1 ∧ i1 < i2 ∧ i2 < u → a[Int.toNat i2]! ≤ a[Int.toNat i1]!
noncomputable def sorted (a : List ℤ) := ∀(i1 : ℤ) (i2 : ℤ), (0 : ℤ) ≤ i1 ∧ i1 < i2 ∧ i2 < Int.ofNat (List.length a) → a[Int.toNat i2]! ≤ a[Int.toNat i1]!
noncomputable def le (a1 : List ℤ) (a2 : List ℤ) := List.length a1 = List.length a2 ∧ (∃(i : ℤ), ((0 : ℤ) ≤ i ∧ i ≤ Int.ofNat (List.length a1)) ∧ (∀(j : ℤ), (0 : ℤ) ≤ j ∧ j < i → a1[Int.toNat j]! = a2[Int.toNat j]!) ∧ (i < Int.ofNat (List.length a1) → a1[Int.toNat i]! < a2[Int.toNat i]!))
noncomputable def lt (a1 : List ℤ) (a2 : List ℤ) := le a1 a2 ∧ ¬a1 = a2
axiom find_eq : List ℤ -> List ℤ -> ℤ -> ℤ
axiom find_eq'def (a1 : List ℤ) (a2 : List ℤ) (i : ℤ) (fact0 : List.length a1 = List.length a2) (fact1 : (0 : ℤ) ≤ i) (fact2 : i ≤ Int.ofNat (List.length a1)) (fact3 : List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a1) = List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a2)) : if i = Int.ofNat (List.length a1) ∨ ¬a1[Int.toNat i]! = a2[Int.toNat i]! then find_eq a1 a2 i = i else find_eq a1 a2 i = find_eq a1 a2 (i + (1 : ℤ))
axiom find_eq'spec'1 (a1 : List ℤ) (a2 : List ℤ) (i : ℤ) (fact0 : List.length a1 = List.length a2) (fact1 : (0 : ℤ) ≤ i) (fact2 : i ≤ Int.ofNat (List.length a1)) (fact3 : List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a1) = List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a2)) : (0 : ℤ) ≤ find_eq a1 a2 i ∧ find_eq a1 a2 i ≤ Int.ofNat (List.length a1)
axiom find_eq'spec'0 (a1 : List ℤ) (a2 : List ℤ) (i : ℤ) (fact0 : List.length a1 = List.length a2) (fact1 : (0 : ℤ) ≤ i) (fact2 : i ≤ Int.ofNat (List.length a1)) (fact3 : List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a1) = List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a2)) : List.drop (0 : ℕ) (List.take (Int.toNat (find_eq a1 a2 i) - (0 : ℕ)) a1) = List.drop (0 : ℕ) (List.take (Int.toNat (find_eq a1 a2 i) - (0 : ℕ)) a2)
axiom find_eq'spec (a1 : List ℤ) (a2 : List ℤ) (i : ℤ) (fact0 : List.length a1 = List.length a2) (fact1 : (0 : ℤ) ≤ i) (fact2 : i ≤ Int.ofNat (List.length a1)) (fact3 : List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a1) = List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a2)) (fact4 : find_eq a1 a2 i < Int.ofNat (List.length a1)) : ¬a1[Int.toNat (find_eq a1 a2 i)]! = a2[Int.toNat (find_eq a1 a2 i)]!
noncomputable def find_le (a1 : List ℤ) (a2 : List ℤ) := if List.length a1 = List.length a2 then let i : ℤ := find_eq a1 a2 (0 : ℤ); if i = Int.ofNat (List.length a1) then true else if a1[Int.toNat i]! < a2[Int.toNat i]! then true else false else false
axiom find_le'spec (a1 : List ℤ) (a2 : List ℤ) : (find_le a1 a2 = true) = le a1 a2
theorem next'vc (a : List ℤ) : let o1 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); (o1 ≤ Int.ofNat (List.length a) - (1 : ℤ) ∧ sorted_sub a o1 (Int.ofNat (List.length a))) ∧ (∀(i : ℤ), i ≤ Int.ofNat (List.length a) - (1 : ℤ) ∧ sorted_sub a i (Int.ofNat (List.length a)) → ((0 : ℤ) < i → ((0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length a)) ∧ (let o2 : ℤ := i - (1 : ℤ); (0 : ℤ) ≤ o2 ∧ o2 < Int.ofNat (List.length a))) ∧ (∀(o2 : Bool), (if (0 : ℤ) < i then o2 = (if a[Int.toNat i]! ≤ a[Int.toNat (i - (1 : ℤ))]! then true else false) else o2 = false) → (if o2 = true then ((0 : ℤ) ≤ i ∧ i - (1 : ℤ) < i) ∧ i - (1 : ℤ) ≤ Int.ofNat (List.length a) - (1 : ℤ) ∧ sorted_sub a (i - (1 : ℤ)) (Int.ofNat (List.length a)) else if i ≤ (0 : ℤ) then List.Perm a a ∧ (∀(a' : List ℤ), List.Perm a a' → le a a' → a = a') else let o3 : ℤ := Int.ofNat (List.length a) - (1 : ℤ); ((i ≤ o3 ∧ o3 ≤ Int.ofNat (List.length a) - (1 : ℤ)) ∧ (∀(k : ℤ), o3 < k ∧ k < Int.ofNat (List.length a) → a[Int.toNat k]! ≤ a[Int.toNat (i - (1 : ℤ))]!)) ∧ (∀(j : ℤ), (i ≤ j ∧ j ≤ Int.ofNat (List.length a) - (1 : ℤ)) ∧ (∀(k : ℤ), j < k ∧ k < Int.ofNat (List.length a) → a[Int.toNat k]! ≤ a[Int.toNat (i - (1 : ℤ))]!) → (let o4 : ℤ := i - (1 : ℤ); ((0 : ℤ) ≤ o4 ∧ o4 < Int.ofNat (List.length a)) ∧ ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a)) ∧ (if a[Int.toNat j]! ≤ a[Int.toNat o4]! then ((0 : ℤ) ≤ j ∧ j - (1 : ℤ) < j) ∧ (i ≤ j - (1 : ℤ) ∧ j - (1 : ℤ) ≤ Int.ofNat (List.length a) - (1 : ℤ)) ∧ (∀(k : ℤ), j - (1 : ℤ) < k ∧ k < Int.ofNat (List.length a) → a[Int.toNat k]! ≤ a[Int.toNat (i - (1 : ℤ))]!) else let o5 : ℤ := i - (1 : ℤ); ((0 : ℤ) ≤ o5 ∧ o5 < Int.ofNat (List.length a)) ∧ (let o6 : ℤ := a[Int.toNat o5]!; ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length a)) ∧ (let o7 : ℤ := a[Int.toNat j]!; let o8 : ℤ := i - (1 : ℤ); ((0 : ℤ) ≤ o8 ∧ o8 < Int.ofNat (List.length a)) ∧ (List.length (List.set a (Int.toNat o8) o7) = List.length a → getElem! (List.set a (Int.toNat o8) o7) ∘ Int.toNat = Function.update (getElem! a ∘ Int.toNat) o8 o7 → ((0 : ℤ) ≤ j ∧ j < Int.ofNat (List.length (List.set a (Int.toNat o8) o7))) ∧ (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6) = List.length (List.set a (Int.toNat o8) o7) → getElem! (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6) ∘ Int.toNat = Function.update (getElem! (List.set a (Int.toNat o8) o7) ∘ Int.toNat) j o6 → ((i ≤ i ∧ i < Int.ofNat (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6))) ∧ (i ≤ Int.ofNat (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) - (1 : ℤ) ∧ Int.ofNat (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) - (1 : ℤ) < Int.ofNat (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6))) ∧ List.Perm (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6) (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6) ∧ List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) = List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) ∧ (∀(k1 : ℤ) (k2 : ℤ), i ≤ k1 ∧ k1 < k2 ∧ k2 < i → (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)[Int.toNat k1]! ≤ (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)[Int.toNat k2]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), i ≤ k1 ∧ k1 < k2 ∧ k2 < Int.ofNat (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) - (1 : ℤ) + (1 : ℤ) → (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)[Int.toNat k2]! ≤ (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)[Int.toNat k1]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), Int.ofNat (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) - (1 : ℤ) + (1 : ℤ) ≤ k1 ∧ k1 < k2 ∧ k2 < Int.ofNat (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) → (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)[Int.toNat k1]! ≤ (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)[Int.toNat k2]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), i ≤ k1 ∧ k1 < i → i ≤ k2 ∧ k2 ≤ Int.ofNat (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) - (1 : ℤ) → (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)[Int.toNat k1]! ≤ (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)[Int.toNat k2]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), i ≤ k1 ∧ k1 ≤ Int.ofNat (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) - (1 : ℤ) → Int.ofNat (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) - (1 : ℤ) < k2 ∧ k2 < Int.ofNat (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) → (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)[Int.toNat k1]! ≤ (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)[Int.toNat k2]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), i ≤ k1 ∧ k1 < i → Int.ofNat (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) - (1 : ℤ) < k2 ∧ k2 < Int.ofNat (List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) → (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)[Int.toNat k1]! ≤ (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)[Int.toNat k2]!)) ∧ (∀(j1 : ℤ) (i1 : ℤ) (a1 : List ℤ), List.length a1 = List.length (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6) → (i ≤ i1 ∧ i1 < Int.ofNat (List.length a1)) ∧ (i ≤ j1 ∧ j1 < Int.ofNat (List.length a1)) ∧ List.Perm a1 (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6) ∧ List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) a1) = List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) ∧ (∀(k1 : ℤ) (k2 : ℤ), i ≤ k1 ∧ k1 < k2 ∧ k2 < i1 → a1[Int.toNat k1]! ≤ a1[Int.toNat k2]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), i1 ≤ k1 ∧ k1 < k2 ∧ k2 < j1 + (1 : ℤ) → a1[Int.toNat k2]! ≤ a1[Int.toNat k1]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), j1 + (1 : ℤ) ≤ k1 ∧ k1 < k2 ∧ k2 < Int.ofNat (List.length a1) → a1[Int.toNat k1]! ≤ a1[Int.toNat k2]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), i ≤ k1 ∧ k1 < i1 → i1 ≤ k2 ∧ k2 ≤ j1 → a1[Int.toNat k1]! ≤ a1[Int.toNat k2]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), i1 ≤ k1 ∧ k1 ≤ j1 → j1 < k2 ∧ k2 < Int.ofNat (List.length a1) → a1[Int.toNat k1]! ≤ a1[Int.toNat k2]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), i ≤ k1 ∧ k1 < i1 → j1 < k2 ∧ k2 < Int.ofNat (List.length a1) → a1[Int.toNat k1]! ≤ a1[Int.toNat k2]!) → (if i1 < j1 then ((0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a1)) ∧ ((0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length a1)) ∧ (let o9 : ℤ := a1[Int.toNat j1]!; ((0 : ℤ) ≤ i1 ∧ i1 < Int.ofNat (List.length a1)) ∧ (List.length (List.set a1 (Int.toNat i1) o9) = List.length a1 → getElem! (List.set a1 (Int.toNat i1) o9) ∘ Int.toNat = Function.update (getElem! a1 ∘ Int.toNat) i1 o9 → ((0 : ℤ) ≤ j1 ∧ j1 < Int.ofNat (List.length (List.set a1 (Int.toNat i1) o9))) ∧ (List.length (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!)) = List.length (List.set a1 (Int.toNat i1) o9) → getElem! (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!)) ∘ Int.toNat = Function.update (getElem! (List.set a1 (Int.toNat i1) o9) ∘ Int.toNat) j1 (a1[Int.toNat i1]!) → ((0 : ℤ) ≤ j1 - i1 ∧ j1 - (1 : ℤ) - (i1 + (1 : ℤ)) < j1 - i1) ∧ (i ≤ i1 + (1 : ℤ) ∧ i1 + (1 : ℤ) < Int.ofNat (List.length (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!)))) ∧ (i ≤ j1 - (1 : ℤ) ∧ j1 - (1 : ℤ) < Int.ofNat (List.length (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!)))) ∧ List.Perm (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!)) (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6) ∧ List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))) = List.drop (0 : ℕ) (List.take (Int.toNat i - (0 : ℕ)) (List.set (List.set a (Int.toNat o8) o7) (Int.toNat j) o6)) ∧ (∀(k1 : ℤ) (k2 : ℤ), i ≤ k1 ∧ k1 < k2 ∧ k2 < i1 + (1 : ℤ) → (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))[Int.toNat k1]! ≤ (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))[Int.toNat k2]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), i1 + (1 : ℤ) ≤ k1 ∧ k1 < k2 ∧ k2 < j1 - (1 : ℤ) + (1 : ℤ) → (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))[Int.toNat k2]! ≤ (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))[Int.toNat k1]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), j1 - (1 : ℤ) + (1 : ℤ) ≤ k1 ∧ k1 < k2 ∧ k2 < Int.ofNat (List.length (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))) → (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))[Int.toNat k1]! ≤ (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))[Int.toNat k2]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), i ≤ k1 ∧ k1 < i1 + (1 : ℤ) → i1 + (1 : ℤ) ≤ k2 ∧ k2 ≤ j1 - (1 : ℤ) → (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))[Int.toNat k1]! ≤ (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))[Int.toNat k2]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), i1 + (1 : ℤ) ≤ k1 ∧ k1 ≤ j1 - (1 : ℤ) → j1 - (1 : ℤ) < k2 ∧ k2 < Int.ofNat (List.length (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))) → (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))[Int.toNat k1]! ≤ (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))[Int.toNat k2]!) ∧ (∀(k1 : ℤ) (k2 : ℤ), i ≤ k1 ∧ k1 < i1 + (1 : ℤ) → j1 - (1 : ℤ) < k2 ∧ k2 < Int.ofNat (List.length (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))) → (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))[Int.toNat k1]! ≤ (List.set (List.set a1 (Int.toNat i1) o9) (Int.toNat j1) (a1[Int.toNat i1]!))[Int.toNat k2]!)))) else List.Perm a1 a ∧ lt a a1 ∧ (∀(a' : List ℤ), List.Perm a a' → lt a a' → le a1 a')))))))))))))
  := sorry
end verifythis_2021_lexicographic_permutations_2_Permut_nextqtvc
