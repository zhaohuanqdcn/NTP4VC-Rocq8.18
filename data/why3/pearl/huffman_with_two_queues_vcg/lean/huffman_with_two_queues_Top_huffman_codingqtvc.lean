import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Sum
open Classical
open Lean4Why3
namespace huffman_with_two_queues_Top_huffman_codingqtvc
axiom get_closure :  {α : Type} -> [Inhabited α] -> List α -> ℤ -> α
axiom get_closure_def {α : Type} [Inhabited α] (y : List α) (y1 : ℤ) : get_closure y y1 = y[Int.toNat y1]!
noncomputable def last (s : List ℤ) := s[Int.toNat (Int.ofNat (List.length s) - (1 : ℤ))]!
theorem huffman_coding'vc (s : List ℤ) (fact0 : (0 : ℤ) < Int.ofNat (List.length s)) (fact1 : Sorted s) : (0 : ℤ) < Int.ofNat (List.length s) + Int.ofNat (List.length ([] : List ℤ)) ∧ List.sum s + List.sum ([] : List ℤ) = List.sum s ∧ Sorted s ∧ Sorted ([] : List ℤ) ∧ ((2 : ℤ) ≤ Int.ofNat (List.length s) → (1 : ℤ) ≤ Int.ofNat (List.length ([] : List ℤ)) → last ([] : List ℤ) ≤ s[(0 : ℕ)]! + s[(1 : ℕ)]!) ∧ ((1 : ℤ) ≤ Int.ofNat (List.length s) → (2 : ℤ) ≤ Int.ofNat (List.length ([] : List ℤ)) → last ([] : List ℤ) ≤ s[(0 : ℕ)]! + ([] : List ℤ)[(0 : ℕ)]!) ∧ ((2 : ℤ) ≤ Int.ofNat (List.length ([] : List ℤ)) → last ([] : List ℤ) ≤ ([] : List ℤ)[(0 : ℕ)]! + ([] : List ℤ)[(1 : ℕ)]!) ∧ (∀(y : List ℤ) (x : List ℤ), (0 : ℤ) < Int.ofNat (List.length x) + Int.ofNat (List.length y) ∧ List.sum x + List.sum y = List.sum s ∧ Sorted x ∧ Sorted y ∧ ((2 : ℤ) ≤ Int.ofNat (List.length x) → (1 : ℤ) ≤ Int.ofNat (List.length y) → last y ≤ x[(0 : ℕ)]! + x[(1 : ℕ)]!) ∧ ((1 : ℤ) ≤ Int.ofNat (List.length x) → (2 : ℤ) ≤ Int.ofNat (List.length y) → last y ≤ x[(0 : ℕ)]! + y[(0 : ℕ)]!) ∧ ((2 : ℤ) ≤ Int.ofNat (List.length y) → last y ≤ y[(0 : ℕ)]! + y[(1 : ℕ)]!) → (if (2 : ℤ) ≤ Int.ofNat (List.length x) + Int.ofNat (List.length y) then if Int.ofNat (List.length y) = (0 : ℤ) then let o1 : ℤ := x[(0 : ℕ)]! + x[(1 : ℕ)]!; let o2 : List ℤ := y ++ [o1]; Int.ofNat (List.length o2) = (1 : ℤ) + Int.ofNat (List.length y) ∧ o2[List.length y]! = o1 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length y) → o2[Int.toNat i]! = y[Int.toNat i]!) → ((0 : ℤ) ≤ (2 : ℤ) ∧ (2 : ℤ) ≤ Int.ofNat (List.length x)) ∧ ((0 : ℤ) ≤ Int.ofNat (List.length x) + Int.ofNat (List.length y) ∧ Int.ofNat (List.length (List.drop (2 : ℕ) x)) + Int.ofNat (List.length o2) < Int.ofNat (List.length x) + Int.ofNat (List.length y)) ∧ (0 : ℤ) < Int.ofNat (List.length (List.drop (2 : ℕ) x)) + Int.ofNat (List.length o2) ∧ List.sum (List.drop (2 : ℕ) x) + List.sum o2 = List.sum s ∧ Sorted (List.drop (2 : ℕ) x) ∧ Sorted o2 ∧ ((2 : ℤ) ≤ Int.ofNat (List.length (List.drop (2 : ℕ) x)) → (1 : ℤ) ≤ Int.ofNat (List.length o2) → last o2 ≤ (List.drop (2 : ℕ) x)[(0 : ℕ)]! + (List.drop (2 : ℕ) x)[(1 : ℕ)]!) ∧ ((1 : ℤ) ≤ Int.ofNat (List.length (List.drop (2 : ℕ) x)) → (2 : ℤ) ≤ Int.ofNat (List.length o2) → last o2 ≤ (List.drop (2 : ℕ) x)[(0 : ℕ)]! + o2[(0 : ℕ)]!) ∧ ((2 : ℤ) ≤ Int.ofNat (List.length o2) → last o2 ≤ o2[(0 : ℕ)]! + o2[(1 : ℕ)]!) else if Int.ofNat (List.length x) = (0 : ℤ) then let o1 : ℤ := y[(0 : ℕ)]! + y[(1 : ℕ)]!; ((0 : ℤ) ≤ (2 : ℤ) ∧ (2 : ℤ) ≤ Int.ofNat (List.length y)) ∧ (let o2 : List ℤ := List.drop (2 : ℕ) y; let o3 : List ℤ := o2 ++ [o1]; Int.ofNat (List.length o3) = (1 : ℤ) + Int.ofNat (List.length o2) ∧ o3[List.length o2]! = o1 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o2) → o3[Int.toNat i]! = o2[Int.toNat i]!) → ((0 : ℤ) ≤ Int.ofNat (List.length x) + Int.ofNat (List.length y) ∧ Int.ofNat (List.length x) + Int.ofNat (List.length o3) < Int.ofNat (List.length x) + Int.ofNat (List.length y)) ∧ (0 : ℤ) < Int.ofNat (List.length x) + Int.ofNat (List.length o3) ∧ List.sum x + List.sum o3 = List.sum s ∧ Sorted x ∧ Sorted o3 ∧ ((2 : ℤ) ≤ Int.ofNat (List.length x) → (1 : ℤ) ≤ Int.ofNat (List.length o3) → last o3 ≤ x[(0 : ℕ)]! + x[(1 : ℕ)]!) ∧ ((1 : ℤ) ≤ Int.ofNat (List.length x) → (2 : ℤ) ≤ Int.ofNat (List.length o3) → last o3 ≤ x[(0 : ℕ)]! + o3[(0 : ℕ)]!) ∧ ((2 : ℤ) ≤ Int.ofNat (List.length o3) → last o3 ≤ o3[(0 : ℕ)]! + o3[(1 : ℕ)]!)) else if x[(0 : ℕ)]! ≤ y[(0 : ℕ)]! then ∀(o1 : Bool), (if (2 : ℤ) ≤ Int.ofNat (List.length x) then o1 = (if x[(1 : ℕ)]! ≤ y[(0 : ℕ)]! then true else false) else o1 = false) → (if o1 = true then let o2 : ℤ := x[(0 : ℕ)]! + x[(1 : ℕ)]!; let o3 : List ℤ := y ++ [o2]; Int.ofNat (List.length o3) = (1 : ℤ) + Int.ofNat (List.length y) ∧ o3[List.length y]! = o2 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length y) → o3[Int.toNat i]! = y[Int.toNat i]!) → ((0 : ℤ) ≤ (2 : ℤ) ∧ (2 : ℤ) ≤ Int.ofNat (List.length x)) ∧ ((0 : ℤ) ≤ Int.ofNat (List.length x) + Int.ofNat (List.length y) ∧ Int.ofNat (List.length (List.drop (2 : ℕ) x)) + Int.ofNat (List.length o3) < Int.ofNat (List.length x) + Int.ofNat (List.length y)) ∧ (0 : ℤ) < Int.ofNat (List.length (List.drop (2 : ℕ) x)) + Int.ofNat (List.length o3) ∧ List.sum (List.drop (2 : ℕ) x) + List.sum o3 = List.sum s ∧ Sorted (List.drop (2 : ℕ) x) ∧ Sorted o3 ∧ ((2 : ℤ) ≤ Int.ofNat (List.length (List.drop (2 : ℕ) x)) → (1 : ℤ) ≤ Int.ofNat (List.length o3) → last o3 ≤ (List.drop (2 : ℕ) x)[(0 : ℕ)]! + (List.drop (2 : ℕ) x)[(1 : ℕ)]!) ∧ ((1 : ℤ) ≤ Int.ofNat (List.length (List.drop (2 : ℕ) x)) → (2 : ℤ) ≤ Int.ofNat (List.length o3) → last o3 ≤ (List.drop (2 : ℕ) x)[(0 : ℕ)]! + o3[(0 : ℕ)]!) ∧ ((2 : ℤ) ≤ Int.ofNat (List.length o3) → last o3 ≤ o3[(0 : ℕ)]! + o3[(1 : ℕ)]!) else let o2 : ℤ := x[(0 : ℕ)]! + y[(0 : ℕ)]!; ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ Int.ofNat (List.length y)) ∧ (let o3 : List ℤ := List.drop (1 : ℕ) y; let o4 : List ℤ := o3 ++ [o2]; Int.ofNat (List.length o4) = (1 : ℤ) + Int.ofNat (List.length o3) ∧ o4[List.length o3]! = o2 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o3) → o4[Int.toNat i]! = o3[Int.toNat i]!) → ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ Int.ofNat (List.length x)) ∧ ((0 : ℤ) ≤ Int.ofNat (List.length x) + Int.ofNat (List.length y) ∧ Int.ofNat (List.length (List.drop (1 : ℕ) x)) + Int.ofNat (List.length o4) < Int.ofNat (List.length x) + Int.ofNat (List.length y)) ∧ (0 : ℤ) < Int.ofNat (List.length (List.drop (1 : ℕ) x)) + Int.ofNat (List.length o4) ∧ List.sum (List.drop (1 : ℕ) x) + List.sum o4 = List.sum s ∧ Sorted (List.drop (1 : ℕ) x) ∧ Sorted o4 ∧ ((2 : ℤ) ≤ Int.ofNat (List.length (List.drop (1 : ℕ) x)) → (1 : ℤ) ≤ Int.ofNat (List.length o4) → last o4 ≤ (List.drop (1 : ℕ) x)[(0 : ℕ)]! + (List.drop (1 : ℕ) x)[(1 : ℕ)]!) ∧ ((1 : ℤ) ≤ Int.ofNat (List.length (List.drop (1 : ℕ) x)) → (2 : ℤ) ≤ Int.ofNat (List.length o4) → last o4 ≤ (List.drop (1 : ℕ) x)[(0 : ℕ)]! + o4[(0 : ℕ)]!) ∧ ((2 : ℤ) ≤ Int.ofNat (List.length o4) → last o4 ≤ o4[(0 : ℕ)]! + o4[(1 : ℕ)]!))) else ∀(o1 : Bool), (if (2 : ℤ) ≤ Int.ofNat (List.length y) then o1 = (if y[(1 : ℕ)]! ≤ x[(0 : ℕ)]! then true else false) else o1 = false) → (if o1 = true then let o2 : ℤ := y[(0 : ℕ)]! + y[(1 : ℕ)]!; ((0 : ℤ) ≤ (2 : ℤ) ∧ (2 : ℤ) ≤ Int.ofNat (List.length y)) ∧ (let o3 : List ℤ := List.drop (2 : ℕ) y; let o4 : List ℤ := o3 ++ [o2]; Int.ofNat (List.length o4) = (1 : ℤ) + Int.ofNat (List.length o3) ∧ o4[List.length o3]! = o2 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o3) → o4[Int.toNat i]! = o3[Int.toNat i]!) → ((0 : ℤ) ≤ Int.ofNat (List.length x) + Int.ofNat (List.length y) ∧ Int.ofNat (List.length x) + Int.ofNat (List.length o4) < Int.ofNat (List.length x) + Int.ofNat (List.length y)) ∧ (0 : ℤ) < Int.ofNat (List.length x) + Int.ofNat (List.length o4) ∧ List.sum x + List.sum o4 = List.sum s ∧ Sorted x ∧ Sorted o4 ∧ ((2 : ℤ) ≤ Int.ofNat (List.length x) → (1 : ℤ) ≤ Int.ofNat (List.length o4) → last o4 ≤ x[(0 : ℕ)]! + x[(1 : ℕ)]!) ∧ ((1 : ℤ) ≤ Int.ofNat (List.length x) → (2 : ℤ) ≤ Int.ofNat (List.length o4) → last o4 ≤ x[(0 : ℕ)]! + o4[(0 : ℕ)]!) ∧ ((2 : ℤ) ≤ Int.ofNat (List.length o4) → last o4 ≤ o4[(0 : ℕ)]! + o4[(1 : ℕ)]!)) else let o2 : ℤ := x[(0 : ℕ)]! + y[(0 : ℕ)]!; ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ Int.ofNat (List.length y)) ∧ (let o3 : List ℤ := List.drop (1 : ℕ) y; let o4 : List ℤ := o3 ++ [o2]; Int.ofNat (List.length o4) = (1 : ℤ) + Int.ofNat (List.length o3) ∧ o4[List.length o3]! = o2 ∧ (∀(i : ℤ), (0 : ℤ) ≤ i ∧ i < Int.ofNat (List.length o3) → o4[Int.toNat i]! = o3[Int.toNat i]!) → ((0 : ℤ) ≤ (1 : ℤ) ∧ (1 : ℤ) ≤ Int.ofNat (List.length x)) ∧ ((0 : ℤ) ≤ Int.ofNat (List.length x) + Int.ofNat (List.length y) ∧ Int.ofNat (List.length (List.drop (1 : ℕ) x)) + Int.ofNat (List.length o4) < Int.ofNat (List.length x) + Int.ofNat (List.length y)) ∧ (0 : ℤ) < Int.ofNat (List.length (List.drop (1 : ℕ) x)) + Int.ofNat (List.length o4) ∧ List.sum (List.drop (1 : ℕ) x) + List.sum o4 = List.sum s ∧ Sorted (List.drop (1 : ℕ) x) ∧ Sorted o4 ∧ ((2 : ℤ) ≤ Int.ofNat (List.length (List.drop (1 : ℕ) x)) → (1 : ℤ) ≤ Int.ofNat (List.length o4) → last o4 ≤ (List.drop (1 : ℕ) x)[(0 : ℕ)]! + (List.drop (1 : ℕ) x)[(1 : ℕ)]!) ∧ ((1 : ℤ) ≤ Int.ofNat (List.length (List.drop (1 : ℕ) x)) → (2 : ℤ) ≤ Int.ofNat (List.length o4) → last o4 ≤ (List.drop (1 : ℕ) x)[(0 : ℕ)]! + o4[(0 : ℕ)]!) ∧ ((2 : ℤ) ≤ Int.ofNat (List.length o4) → last o4 ≤ o4[(0 : ℕ)]! + o4[(1 : ℕ)]!))) else ∀(result : ℤ), (if (0 : ℤ) < Int.ofNat (List.length x) then result = x[(0 : ℕ)]! else result = y[(0 : ℕ)]!) → result = List.sum s))
  := sorry
end huffman_with_two_queues_Top_huffman_codingqtvc
