theory euler_sieve_EulerSieve_remove_productsqtvc
  imports "NTP4Verif.NTP4Verif" "./euler_sieve_ArithmeticResults" "./euler_sieve_DivisibilityResults" "./euler_sieve_EulerSieveSpec"
begin
typedecl  t
consts nexts :: "t \<Rightarrow> int list"
consts marked :: "t \<Rightarrow> bool list"
consts max :: "t \<Rightarrow> 63 word"
axiomatization where t'invariant'0:   "sint (max self) < sint int'63_max"
  for self :: "t"
axiomatization where t'invariant'1:   "(3 :: int) \<le> sint (max self)"
  for self :: "t"
axiomatization where t'invariant'2:   "length (nexts self) = length (marked self)"
  for self :: "t"
axiomatization where t'invariant'3:   "int (length (marked self)) = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'4:   "inv_nexts (nexts self) (int (length (nexts self)))"
  for self :: "t"
axiomatization where t'invariant'5:   "all_eliminated_marked (marked self) (nexts self)"
  for self :: "t"
axiomatization where t'invariant'6:   "\<forall>(i :: int). (3 :: int) \<le> i \<and> i \<le> sint (max self) \<longrightarrow> i emod (2 :: int) = (0 :: int) \<longrightarrow> marked self ! nat i = True"
  for self :: "t"
axiomatization where t'invariant'7:   "\<forall>(i :: int). (3 :: int) \<le> i \<and> i < sint (max self) - (1 :: int) \<longrightarrow> i emod (2 :: int) = (1 :: int) \<longrightarrow> nexts self ! nat i emod (2 :: int) = (1 :: int) \<or> nexts self ! nat i = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'8:   "nexts self ! nat (sint (max self)) = sint (max self) + (1 :: int)"
  for self :: "t"
axiomatization where t'invariant'9:   "(sint (max self) - (1 :: int)) emod (2 :: int) = (0 :: int) \<longrightarrow> nexts self ! nat (sint (max self) - (1 :: int)) = sint (max self)"
  for self :: "t"
axiomatization where t'invariant'10:   "(sint (max self) - (1 :: int)) emod (2 :: int) = (1 :: int) \<longrightarrow> nexts self ! nat (sint (max self) - (1 :: int)) = sint (max self) + (1 :: int)"
  for self :: "t"
theorem remove_products'vc:
  fixes n :: "63 word"
  fixes t1 :: "t"
  assumes fact0: "(3 :: int) \<le> sint n"
  assumes fact1: "sint n \<le> sint (max t1)"
  assumes fact2: "sint n * sint n \<le> sint (max t1)"
  assumes fact3: "inv_remove_products (nexts t1) (marked t1) (sint n)"
  assumes fact4: "previously_marked_multiples (marked t1) (sint n)"
  assumes fact5: "only_multiples_marked (marked t1) (sint n)"
  assumes fact6: "not_marked_impl_next_not_marked (marked t1) (nexts t1) (sint n)"
  shows "let o1 :: 63 word = max t1 in (2 :: int) \<le> sint o1 \<longrightarrow> (\<not>sint n = (0 :: int) \<and> int'63_in_bounds (sint o1 cdiv sint n)) \<and> (\<forall>(d :: 63 word). sint d = sint o1 cdiv sint n \<longrightarrow> (let max1 :: 63 word = max t1; marked_old :: bool list = marked t1 in (\<forall>(t2 :: t). max t2 = max t1 \<longrightarrow> (\<forall>(p :: 63 word) (x :: int). ((sint n \<le> sint p \<and> sint p \<le> sint max1) \<and> ((3 :: int) \<le> sint n \<and> sint n \<le> sint max1) \<and> sint p emod (2 :: int) = (1 :: int) \<and> (sint p \<le> x \<and> x < nexts t2 ! nat (sint p)) \<and> nexts t2 ! nat x = nexts t2 ! nat (sint p) \<and> marked t2 ! nat (sint n * sint n) = True) \<and> inv_remove_products (nexts t2) (marked t2) (sint n) \<and> previously_marked_multiples (marked t2) (sint n) \<and> \<not>marked t2 ! nat (sint p) = True \<and> is_copy (marked t2) marked_old \<and> all_eliminated_marked_partial marked_old (nexts t2) x \<and> not_marked_impl_next_not_marked marked_old (nexts t2) (sint n) \<and> prime_multiples_marked marked_old (marked t2) (sint n) (nexts t2 ! nat x) \<and> not_marked_impl_next_not_marked_partial (marked t2) (nexts t2) (sint n) (sint p) \<and> only_multiples_marked (marked t2) (sint n + (1 :: int)) \<longrightarrow> (((3 :: int) \<le> sint p \<and> sint p \<le> sint (max t2)) \<and> sint p emod (2 :: int) = (1 :: int)) \<and> (\<forall>(next :: 63 word). ((3 :: int) \<le> sint next \<and> sint next \<le> sint (max t2) + (1 :: int)) \<and> sint next = nexts t2 ! nat (sint p) \<and> (sint next emod (2 :: int) = (1 :: int) \<or> sint next = sint (max t2) + (1 :: int)) \<longrightarrow> (\<forall>(o2 :: bool). (if (0 :: int) \<le> sint next then let o3 :: 63 word = max t2 in (2 :: int) \<le> sint o3 \<and> o2 = (if sint next \<le> sint o3 then True else False) else o2 = False) \<longrightarrow> (if o2 = True then if sint next \<le> sint d then int'63_in_bounds (sint n * sint next) \<and> (\<forall>(o3 :: 63 word). sint o3 = sint n * sint next \<longrightarrow> (((0 :: int) \<le> sint o3 \<and> sint o3 \<le> sint (max t2)) \<and> sint o3 emod (2 :: int) = (1 :: int)) \<and> (\<forall>(t3 :: t). nexts t3 = nexts t2 \<and> max t3 = max t2 \<longrightarrow> marked t3 = (marked t2)[nat (sint o3) := True] \<longrightarrow> (((0 :: int) \<le> sint next \<and> sint next \<le> sint (max t3)) \<and> sint next emod (2 :: int) = (1 :: int)) \<and> (if marked t3 ! nat (sint next) = True then (((3 :: int) \<le> sint next \<and> sint next \<le> sint (max t3)) \<and> sint next emod (2 :: int) = (1 :: int)) \<and> (\<forall>(o4 :: 63 word). ((3 :: int) \<le> sint o4 \<and> sint o4 \<le> sint (max t3) + (1 :: int)) \<and> sint o4 = nexts t3 ! nat (sint next) \<and> (sint o4 emod (2 :: int) = (1 :: int) \<or> sint o4 = sint (max t3) + (1 :: int)) \<longrightarrow> ((((0 :: int) \<le> sint p \<and> sint p \<le> sint (max t3)) \<and> sint p < sint o4 \<and> sint o4 \<le> sint (max t3) + (1 :: int)) \<and> sint p emod (2 :: int) = (1 :: int) \<and> (\<forall>(j :: int). sint p < j \<and> j < sint o4 \<longrightarrow> marked t3 ! nat j = True) \<and> \<not>marked t3 ! nat (sint p) = True \<and> (sint o4 emod (2 :: int) = (1 :: int) \<or> sint o4 = sint (max t3) + (1 :: int))) \<and> (\<forall>(t4 :: t). marked t4 = marked t3 \<and> max t4 = max t3 \<longrightarrow> nexts t4 = (nexts t3)[nat (sint p) := sint o4] \<longrightarrow> (let o5 :: int = sint next in ((0 :: int) \<le> sint max1 - nexts t2 ! nat (sint p) \<and> sint max1 - nexts t4 ! nat (sint p) < sint max1 - nexts t2 ! nat (sint p)) \<and> ((sint n \<le> sint p \<and> sint p \<le> sint max1) \<and> ((3 :: int) \<le> sint n \<and> sint n \<le> sint max1) \<and> sint p emod (2 :: int) = (1 :: int) \<and> (sint p \<le> o5 \<and> o5 < nexts t4 ! nat (sint p)) \<and> nexts t4 ! nat o5 = nexts t4 ! nat (sint p) \<and> marked t4 ! nat (sint n * sint n) = True) \<and> inv_remove_products (nexts t4) (marked t4) (sint n) \<and> previously_marked_multiples (marked t4) (sint n) \<and> \<not>marked t4 ! nat (sint p) = True \<and> is_copy (marked t4) marked_old \<and> all_eliminated_marked_partial marked_old (nexts t4) o5 \<and> not_marked_impl_next_not_marked marked_old (nexts t4) (sint n) \<and> prime_multiples_marked marked_old (marked t4) (sint n) (nexts t4 ! nat o5) \<and> not_marked_impl_next_not_marked_partial (marked t4) (nexts t4) (sint n) (sint p) \<and> only_multiples_marked (marked t4) (sint n + (1 :: int))))) else let o4 :: int = sint next in ((0 :: int) \<le> sint max1 - nexts t2 ! nat (sint p) \<and> sint max1 - nexts t3 ! nat (sint next) < sint max1 - nexts t2 ! nat (sint p)) \<and> ((sint n \<le> sint next \<and> sint next \<le> sint max1) \<and> ((3 :: int) \<le> sint n \<and> sint n \<le> sint max1) \<and> sint next emod (2 :: int) = (1 :: int) \<and> (sint next \<le> o4 \<and> o4 < nexts t3 ! nat (sint next)) \<and> nexts t3 ! nat o4 = nexts t3 ! nat (sint next) \<and> marked t3 ! nat (sint n * sint n) = True) \<and> inv_remove_products (nexts t3) (marked t3) (sint n) \<and> previously_marked_multiples (marked t3) (sint n) \<and> \<not>marked t3 ! nat (sint next) = True \<and> is_copy (marked t3) marked_old \<and> all_eliminated_marked_partial marked_old (nexts t3) o4 \<and> not_marked_impl_next_not_marked marked_old (nexts t3) (sint n) \<and> prime_multiples_marked marked_old (marked t3) (sint n) (nexts t3 ! nat o4) \<and> not_marked_impl_next_not_marked_partial (marked t3) (nexts t3) (sint n) (sint next) \<and> only_multiples_marked (marked t3) (sint n + (1 :: int))))) else inv_remove_products (nexts t2) (marked t2) (sint n) \<and> not_marked_impl_next_not_marked (marked t2) (nexts t2) (nexts t2 ! nat (sint n)) \<and> is_copy (marked t2) marked_old \<and> previously_marked_multiples (marked t2) (sint n) \<and> prime_multiples_marked marked_old (marked t2) (sint n) (int (length (marked t2))) \<and> only_multiples_marked (marked t2) (sint n + (1 :: int)) else inv_remove_products (nexts t2) (marked t2) (sint n) \<and> not_marked_impl_next_not_marked (marked t2) (nexts t2) (nexts t2 ! nat (sint n)) \<and> is_copy (marked t2) marked_old \<and> previously_marked_multiples (marked t2) (sint n) \<and> prime_multiples_marked marked_old (marked t2) (sint n) (int (length (marked t2))) \<and> only_multiples_marked (marked t2) (sint n + (1 :: int))))))) \<and> int'63_in_bounds (sint n * sint n) \<and> (\<forall>(o2 :: 63 word). sint o2 = sint n * sint n \<longrightarrow> (((0 :: int) \<le> sint o2 \<and> sint o2 \<le> sint (max t1)) \<and> sint o2 emod (2 :: int) = (1 :: int)) \<and> (\<forall>(t2 :: t). nexts t2 = nexts t1 \<and> max t2 = max t1 \<longrightarrow> marked t2 = (marked t1)[nat (sint o2) := True] \<longrightarrow> (let o3 :: int = sint n in (((sint n \<le> sint n \<and> sint n \<le> sint max1) \<and> ((3 :: int) \<le> sint n \<and> sint n \<le> sint max1) \<and> sint n emod (2 :: int) = (1 :: int) \<and> (sint n \<le> o3 \<and> o3 < nexts t2 ! nat (sint n)) \<and> nexts t2 ! nat o3 = nexts t2 ! nat (sint n) \<and> marked t2 ! nat (sint n * sint n) = True) \<and> inv_remove_products (nexts t2) (marked t2) (sint n) \<and> previously_marked_multiples (marked t2) (sint n) \<and> \<not>marked t2 ! nat (sint n) = True \<and> is_copy (marked t2) marked_old \<and> all_eliminated_marked_partial marked_old (nexts t2) o3 \<and> not_marked_impl_next_not_marked marked_old (nexts t2) (sint n) \<and> prime_multiples_marked marked_old (marked t2) (sint n) (nexts t2 ! nat o3) \<and> not_marked_impl_next_not_marked_partial (marked t2) (nexts t2) (sint n) (sint n) \<and> only_multiples_marked (marked t2) (sint n + (1 :: int))) \<and> (\<forall>(t3 :: t). max t3 = max t2 \<longrightarrow> inv_remove_products (nexts t3) (marked t3) (sint n) \<and> not_marked_impl_next_not_marked (marked t3) (nexts t3) (nexts t3 ! nat (sint n)) \<and> is_copy (marked t3) marked_old \<and> previously_marked_multiples (marked t3) (sint n) \<and> prime_multiples_marked marked_old (marked t3) (sint n) (int (length (marked t3))) \<and> only_multiples_marked (marked t3) (sint n + (1 :: int)) \<longrightarrow> inv_remove_products (nexts t3) (marked t3) (sint n) \<and> not_marked_impl_next_not_marked (marked t3) (nexts t3) (nexts t3 ! nat (sint n)) \<and> previously_marked_multiples (marked t3) (nexts t3 ! nat (sint n)) \<and> only_multiples_marked (marked t3) (nexts t3 ! nat (sint n))))))))"
  sorry
end
