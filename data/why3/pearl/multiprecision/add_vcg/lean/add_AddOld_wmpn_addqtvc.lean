import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import Why3.mach.c.C
import Why3.mach.int.Unsigned
import pearl.multiprecision.lib.lean.lemmas.Lemmas
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.ptralias.Alias
open Classical
open Lean4Why3
namespace add_AddOld_wmpn_addqtvc
theorem wmpn_add'vc (sy : BitVec 32) (sx : BitVec 32) (x : C.ptr (BitVec 64)) (y : C.ptr (BitVec 64)) (r : C.ptr (BitVec 64)) (fact0 : (0 : ℤ) ≤ BitVec.toInt sy) (fact1 : BitVec.toInt sy ≤ BitVec.toInt sx) (fact2 : C.valid x (BitVec.toInt sx)) (fact3 : C.valid y (BitVec.toInt sy)) (fact4 : C.valid r (BitVec.toInt sx)) (fact5 : C.writable r = true) : C.valid x (BitVec.toInt sy) ∧ C.valid y (BitVec.toInt sy) ∧ C.valid r (BitVec.toInt sy) ∧ C.writable r = true ∧ (∀(r1 : C.ptr (BitVec 64)), List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → (∀(o1 : BitVec 64), ((0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (1 : ℤ)) ∧ Lemmas.value r1 (BitVec.toInt sy) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sy)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt sy) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sy ≤ j → C.pelts r1 j = C.pelts r j) → (∀(o2 : Bool), (BitVec.toUInt o1 = BitVec.toUInt (0 : BitVec 64) → o2 = true) ∧ (o2 = true → o1 = (0 : BitVec 64)) → (if ¬o2 = true then ((BitVec.toInt sy ≤ BitVec.toInt sy ∧ BitVec.toInt sy ≤ BitVec.toInt sx) ∧ Lemmas.value r1 (BitVec.toInt sy) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sy)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt sy) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (1 : ℤ)) ∧ (sy = sx ∨ BitVec.toUInt o1 = (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sx ≤ j → C.pelts r1 j = C.pelts r j)) ∧ (∀(i : BitVec 32) (c : BitVec 64) (r2 : C.ptr (BitVec 64)), List.length (C.data r2) = List.length (C.data r1) ∧ C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.max r2 = C.max r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → (BitVec.toInt sy ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sx) ∧ Lemmas.value r2 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt i) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (i = sx ∨ BitVec.toUInt c = (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sx ≤ j → C.pelts r2 j = C.pelts r j) → (if BitVec.toInt i < BitVec.toInt sx then (C.min x ≤ C.offset x + BitVec.toInt i ∧ C.offset x + BitVec.toInt i < C.max x) ∧ (∀(res : BitVec 64), BitVec.toUInt res = (BitVec.toUInt (C.pelts x (C.offset x + BitVec.toInt i)) + (1 : ℤ)) % ((18446744073709551615 : ℤ) + (1 : ℤ)) → ((C.min r2 ≤ C.offset r2 + BitVec.toInt i ∧ C.offset r2 + BitVec.toInt i < C.max r2) ∧ C.writable r2 = true) ∧ (∀(r3 : C.ptr (BitVec 64)), List.length (C.data r3) = List.length (C.data r2) ∧ C.offset r3 = C.offset r2 ∧ C.min r3 = C.min r2 ∧ C.max r3 = C.max r2 ∧ C.writable r3 = C.writable r2 ∧ C.zone1 r3 = C.zone1 r2 → C.pelts r3 = Function.update (C.pelts r2) (C.offset r3 + BitVec.toInt i) res ∧ C.pelts r3 (C.offset r3 + BitVec.toInt i) = res → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt i + (1 : ℤ) → (∀(o4 : Bool), (BitVec.toUInt res = BitVec.toUInt (0 : BitVec 64) → o4 = true) ∧ (o4 = true → res = (0 : BitVec 64)) → (if ¬o4 = true then ((BitVec.toInt sy ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ BitVec.toInt sx) ∧ (o3 = sx ∨ BitVec.toUInt (0 : BitVec 64) = (0 : ℤ)) ∧ Lemmas.value r3 (BitVec.toInt o3) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o3)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt o3) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt sx ≤ j → C.pelts r3 j = C.pelts r j)) ∧ (∀(i1 : BitVec 32) (r4 : C.ptr (BitVec 64)), List.length (C.data r4) = List.length (C.data r3) ∧ C.offset r4 = C.offset r3 ∧ C.min r4 = C.min r3 ∧ C.max r4 = C.max r3 ∧ C.writable r4 = C.writable r3 ∧ C.zone1 r4 = C.zone1 r3 → (BitVec.toInt sy ≤ BitVec.toInt i1 ∧ BitVec.toInt i1 ≤ BitVec.toInt sx) ∧ (i1 = sx ∨ BitVec.toUInt (0 : BitVec 64) = (0 : ℤ)) ∧ Lemmas.value r4 (BitVec.toInt i1) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i1)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt i1) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r4 ∨ C.offset r4 + BitVec.toInt sx ≤ j → C.pelts r4 j = C.pelts r j) → (if BitVec.toInt i1 < BitVec.toInt sx then (C.min x ≤ C.offset x + BitVec.toInt i1 ∧ C.offset x + BitVec.toInt i1 < C.max x) ∧ ((C.min r4 ≤ C.offset r4 + BitVec.toInt i1 ∧ C.offset r4 + BitVec.toInt i1 < C.max r4) ∧ C.writable r4 = true) ∧ (∀(r5 : C.ptr (BitVec 64)), List.length (C.data r5) = List.length (C.data r4) ∧ C.offset r5 = C.offset r4 ∧ C.min r5 = C.min r4 ∧ C.max r5 = C.max r4 ∧ C.writable r5 = C.writable r4 ∧ C.zone1 r5 = C.zone1 r4 → C.pelts r5 = Function.update (C.pelts r4) (C.offset r5 + BitVec.toInt i1) (C.pelts x (C.offset x + BitVec.toInt i1)) ∧ C.pelts r5 (C.offset r5 + BitVec.toInt i1) = C.pelts x (C.offset x + BitVec.toInt i1) → int'32_in_bounds (BitVec.toInt i1 + (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt i1 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt sx - BitVec.toInt i1 ∧ BitVec.toInt sx - BitVec.toInt o5 < BitVec.toInt sx - BitVec.toInt i1) ∧ (BitVec.toInt sy ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 ≤ BitVec.toInt sx) ∧ (o5 = sx ∨ BitVec.toUInt (0 : BitVec 64) = (0 : ℤ)) ∧ Lemmas.value r5 (BitVec.toInt o5) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o5)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt o5) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r5 ∨ C.offset r5 + BitVec.toInt sx ≤ j → C.pelts r5 j = C.pelts r j))) else Lemmas.value r4 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt (0 : BitVec 64) = Lemmas.value x (BitVec.toInt sx) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r4 ∨ C.offset r4 + BitVec.toInt sx ≤ j → C.pelts r4 j = C.pelts r j) ∧ (0 : ℤ) ≤ BitVec.toUInt (0 : BitVec 64) ∧ BitVec.toUInt (0 : BitVec 64) ≤ (1 : ℤ))) else ((0 : ℤ) ≤ BitVec.toInt sx - BitVec.toInt i ∧ BitVec.toInt sx - BitVec.toInt o3 < BitVec.toInt sx - BitVec.toInt i) ∧ (BitVec.toInt sy ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ BitVec.toInt sx) ∧ Lemmas.value r3 (BitVec.toInt o3) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o3)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt o3) + Lemmas.value y (BitVec.toInt sy) ∧ ((0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ)) ∧ (o3 = sx ∨ BitVec.toUInt c = (1 : ℤ)) ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt sx ≤ j → C.pelts r3 j = C.pelts r j)))))) else ((BitVec.toInt sy ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sx) ∧ (i = sx ∨ BitVec.toUInt c = (0 : ℤ)) ∧ Lemmas.value r2 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt i) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sx ≤ j → C.pelts r2 j = C.pelts r j)) ∧ (∀(i1 : BitVec 32) (r3 : C.ptr (BitVec 64)), List.length (C.data r3) = List.length (C.data r2) ∧ C.offset r3 = C.offset r2 ∧ C.min r3 = C.min r2 ∧ C.max r3 = C.max r2 ∧ C.writable r3 = C.writable r2 ∧ C.zone1 r3 = C.zone1 r2 → (BitVec.toInt sy ≤ BitVec.toInt i1 ∧ BitVec.toInt i1 ≤ BitVec.toInt sx) ∧ (i1 = sx ∨ BitVec.toUInt c = (0 : ℤ)) ∧ Lemmas.value r3 (BitVec.toInt i1) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i1)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt i1) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt sx ≤ j → C.pelts r3 j = C.pelts r j) → (if BitVec.toInt i1 < BitVec.toInt sx then (C.min x ≤ C.offset x + BitVec.toInt i1 ∧ C.offset x + BitVec.toInt i1 < C.max x) ∧ ((C.min r3 ≤ C.offset r3 + BitVec.toInt i1 ∧ C.offset r3 + BitVec.toInt i1 < C.max r3) ∧ C.writable r3 = true) ∧ (∀(r4 : C.ptr (BitVec 64)), List.length (C.data r4) = List.length (C.data r3) ∧ C.offset r4 = C.offset r3 ∧ C.min r4 = C.min r3 ∧ C.max r4 = C.max r3 ∧ C.writable r4 = C.writable r3 ∧ C.zone1 r4 = C.zone1 r3 → C.pelts r4 = Function.update (C.pelts r3) (C.offset r4 + BitVec.toInt i1) (C.pelts x (C.offset x + BitVec.toInt i1)) ∧ C.pelts r4 (C.offset r4 + BitVec.toInt i1) = C.pelts x (C.offset x + BitVec.toInt i1) → int'32_in_bounds (BitVec.toInt i1 + (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt i1 + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt sx - BitVec.toInt i1 ∧ BitVec.toInt sx - BitVec.toInt o3 < BitVec.toInt sx - BitVec.toInt i1) ∧ (BitVec.toInt sy ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ BitVec.toInt sx) ∧ (o3 = sx ∨ BitVec.toUInt c = (0 : ℤ)) ∧ Lemmas.value r4 (BitVec.toInt o3) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o3)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt o3) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r4 ∨ C.offset r4 + BitVec.toInt sx ≤ j → C.pelts r4 j = C.pelts r j))) else Lemmas.value r3 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt c = Lemmas.value x (BitVec.toInt sx) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt sx ≤ j → C.pelts r3 j = C.pelts r j) ∧ (0 : ℤ) ≤ BitVec.toUInt c ∧ BitVec.toUInt c ≤ (1 : ℤ))))) else ((BitVec.toInt sy ≤ BitVec.toInt sy ∧ BitVec.toInt sy ≤ BitVec.toInt sx) ∧ (sy = sx ∨ BitVec.toUInt o1 = (0 : ℤ)) ∧ Lemmas.value r1 (BitVec.toInt sy) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sy)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt sy) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r1 ∨ C.offset r1 + BitVec.toInt sx ≤ j → C.pelts r1 j = C.pelts r j)) ∧ (∀(i : BitVec 32) (r2 : C.ptr (BitVec 64)), List.length (C.data r2) = List.length (C.data r1) ∧ C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.max r2 = C.max r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → (BitVec.toInt sy ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt sx) ∧ (i = sx ∨ BitVec.toUInt o1 = (0 : ℤ)) ∧ Lemmas.value r2 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt i) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sx ≤ j → C.pelts r2 j = C.pelts r j) → (if BitVec.toInt i < BitVec.toInt sx then (C.min x ≤ C.offset x + BitVec.toInt i ∧ C.offset x + BitVec.toInt i < C.max x) ∧ ((C.min r2 ≤ C.offset r2 + BitVec.toInt i ∧ C.offset r2 + BitVec.toInt i < C.max r2) ∧ C.writable r2 = true) ∧ (∀(r3 : C.ptr (BitVec 64)), List.length (C.data r3) = List.length (C.data r2) ∧ C.offset r3 = C.offset r2 ∧ C.min r3 = C.min r2 ∧ C.max r3 = C.max r2 ∧ C.writable r3 = C.writable r2 ∧ C.zone1 r3 = C.zone1 r2 → C.pelts r3 = Function.update (C.pelts r2) (C.offset r3 + BitVec.toInt i) (C.pelts x (C.offset x + BitVec.toInt i)) ∧ C.pelts r3 (C.offset r3 + BitVec.toInt i) = C.pelts x (C.offset x + BitVec.toInt i) → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o3 : BitVec 32), BitVec.toInt o3 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt sx - BitVec.toInt i ∧ BitVec.toInt sx - BitVec.toInt o3 < BitVec.toInt sx - BitVec.toInt i) ∧ (BitVec.toInt sy ≤ BitVec.toInt o3 ∧ BitVec.toInt o3 ≤ BitVec.toInt sx) ∧ (o3 = sx ∨ BitVec.toUInt o1 = (0 : ℤ)) ∧ Lemmas.value r3 (BitVec.toInt o3) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o3)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt o3) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r3 ∨ C.offset r3 + BitVec.toInt sx ≤ j → C.pelts r3 j = C.pelts r j))) else Lemmas.value r2 (BitVec.toInt sx) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt sx)) * BitVec.toUInt o1 = Lemmas.value x (BitVec.toInt sx) + Lemmas.value y (BitVec.toInt sy) ∧ (∀(j : ℤ), j < C.offset r2 ∨ C.offset r2 + BitVec.toInt sx ≤ j → C.pelts r2 j = C.pelts r j) ∧ (0 : ℤ) ≤ BitVec.toUInt o1 ∧ BitVec.toUInt o1 ≤ (1 : ℤ)))))))
  := sorry
end add_AddOld_wmpn_addqtvc
