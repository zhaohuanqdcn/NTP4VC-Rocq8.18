import Why3.Base
import pearl.register_allocation_vcg.lean.register_allocation.Spec
import pearl.register_allocation_vcg.lean.register_allocation.DWP
open Classical
open Lean4Why3
namespace register_allocation_OptimalNumberOfRegisters_compileqtvc
axiom k : ℤ
axiom k'def : (2 : ℤ) ≤ k
noncomputable def n : Spec.expr -> ℤ
  | (Spec.expr.Evar x) => (1 : ℤ)
  | (Spec.expr.Eneg e1) => n e1
  | (Spec.expr.Eadd e1 e2) => let n1 : ℤ := n e1; let n2 : ℤ := n e2; if n1 = n2 then (1 : ℤ) + n1 else max n1 n2
noncomputable def measure : Spec.expr -> ℤ
  | (Spec.expr.Evar x) => (0 : ℤ)
  | (Spec.expr.Eneg e1) => (1 : ℤ) + measure e1
  | (Spec.expr.Eadd e1 e2) => (1 : ℤ) + (if n e2 ≤ n e1 then measure e1 + measure e2 else (1 : ℤ) + measure e1 + measure e2)
axiom identity : (Spec.state -> Bool) -> Spec.state -> Bool
axiom exec_closure : Spec.instr -> Spec.state -> Spec.state
axiom identity_def (y : Spec.state -> Bool) : identity y = y
axiom exec_closure_def (y : Spec.instr) (y1 : Spec.state) : exec_closure y y1 = Spec.exec y y1
theorem compile'vc (r : ℤ) (e : Spec.expr) (fact0 : (0 : ℤ) ≤ r) (fact1 : r < k) : let o1 : Spec.state -> Spec.state -> Bool := Spec.expr_post e r; (match e with | Spec.expr.Evar x => (∀(o2 : DWP.wcode), DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = identity → DWP.wcode_ok o2) | Spec.expr.Eneg e1 => (∀(o2 : DWP.wcode), DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = identity → DWP.wcode_ok o2 ∧ (∀(o3 : DWP.wcode), DWP.wcode_ok o3 ∧ DWP.wcode.trans1 o3 = DWP.rcompose (DWP.wcode.trans1 o2) (DWP.rcompose (exec_closure (Spec.instr.Ineg r))) → (((0 : ℤ) ≤ measure e ∧ measure e1 < measure e) ∧ (0 : ℤ) ≤ r ∧ r < k) ∧ (∀(o4 : DWP.hcode), DWP.hcode_ok o4 ∧ DWP.hcode.post1 o4 = Spec.expr_post e1 r → DWP.hcode_ok o4 ∧ (∀(o5 : DWP.wcode), DWP.wcode_ok o5 ∧ DWP.wcode.trans1 o5 = DWP.to_wp (DWP.hcode.post1 o4) → DWP.wcode_ok o5 ∧ DWP.wcode_ok o3)))) | Spec.expr.Eadd e1 e2 => (if n e2 ≤ n e1 then if r < k - (1 : ℤ) then ∀(o2 : DWP.wcode), DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = identity → DWP.wcode_ok o2 ∧ (∀(o3 : DWP.wcode), DWP.wcode_ok o3 ∧ DWP.wcode.trans1 o3 = DWP.rcompose (DWP.wcode.trans1 o2) (DWP.rcompose (exec_closure (Spec.instr.Iadd (r + (1 : ℤ)) r))) → (let o4 : ℤ := r + (1 : ℤ); (((0 : ℤ) ≤ measure e ∧ measure e2 < measure e) ∧ (0 : ℤ) ≤ o4 ∧ o4 < k) ∧ (∀(o5 : DWP.hcode), DWP.hcode_ok o5 ∧ DWP.hcode.post1 o5 = Spec.expr_post e2 o4 → DWP.hcode_ok o5 ∧ (∀(o6 : DWP.wcode), DWP.wcode_ok o6 ∧ DWP.wcode.trans1 o6 = DWP.to_wp (DWP.hcode.post1 o5) → (((0 : ℤ) ≤ measure e ∧ measure e1 < measure e) ∧ (0 : ℤ) ≤ r ∧ r < k) ∧ (∀(o7 : DWP.hcode), DWP.hcode_ok o7 ∧ DWP.hcode.post1 o7 = Spec.expr_post e1 r → DWP.hcode_ok o7 ∧ (∀(o8 : DWP.wcode), DWP.wcode_ok o8 ∧ DWP.wcode.trans1 o8 = DWP.to_wp (DWP.hcode.post1 o7) → (DWP.wcode_ok o8 ∧ DWP.wcode_ok o6) ∧ (∀(o9 : DWP.wcode), DWP.wcode_ok o9 ∧ DWP.wcode.trans1 o9 = DWP.rcompose (DWP.wcode.trans1 o6) (DWP.wcode.trans1 o8) → DWP.wcode_ok o9 ∧ DWP.wcode_ok o3))))))) else ∀(o2 : DWP.wcode), DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = identity → DWP.wcode_ok o2 ∧ (∀(o3 : DWP.wcode), DWP.wcode_ok o3 ∧ DWP.wcode.trans1 o3 = DWP.rcompose (DWP.wcode.trans1 o2) (DWP.rcompose (exec_closure (Spec.instr.Ipop (k - (2 : ℤ))))) → DWP.wcode_ok o3 ∧ (∀(o4 : DWP.wcode), DWP.wcode_ok o4 ∧ DWP.wcode.trans1 o4 = DWP.rcompose (DWP.wcode.trans1 o3) (DWP.rcompose (exec_closure (Spec.instr.Iadd (k - (2 : ℤ)) (k - (1 : ℤ))))) → (let o5 : ℤ := k - (1 : ℤ); (((0 : ℤ) ≤ measure e ∧ measure e2 < measure e) ∧ (0 : ℤ) ≤ o5 ∧ o5 < k) ∧ (∀(o6 : DWP.hcode), DWP.hcode_ok o6 ∧ DWP.hcode.post1 o6 = Spec.expr_post e2 o5 → DWP.hcode_ok o6 ∧ (∀(o7 : DWP.wcode), DWP.wcode_ok o7 ∧ DWP.wcode.trans1 o7 = DWP.to_wp (DWP.hcode.post1 o6) → (let o8 : ℤ := k - (2 : ℤ); (((0 : ℤ) ≤ measure e ∧ measure e1 < measure e) ∧ (0 : ℤ) ≤ o8 ∧ o8 < k) ∧ (∀(o9 : DWP.hcode), DWP.hcode_ok o9 ∧ DWP.hcode.post1 o9 = Spec.expr_post e1 o8 → DWP.hcode_ok o9 ∧ (∀(o10 : DWP.wcode), DWP.wcode_ok o10 ∧ DWP.wcode.trans1 o10 = DWP.to_wp (DWP.hcode.post1 o9) → (DWP.wcode_ok o10 ∧ DWP.wcode_ok o7) ∧ (∀(o11 : DWP.wcode), DWP.wcode_ok o11 ∧ DWP.wcode.trans1 o11 = DWP.rcompose (DWP.wcode.trans1 o7) (DWP.wcode.trans1 o10) → (DWP.wcode_ok o11 ∧ DWP.wcode_ok o4) ∧ (∀(o12 : DWP.wcode), DWP.wcode_ok o12 ∧ DWP.wcode.trans1 o12 = DWP.rcompose (DWP.wcode.trans1 o4) (DWP.wcode.trans1 o11) → DWP.wcode_ok o12)))))))))) else let o2 : Spec.expr := Spec.expr.Eadd e2 e1; (((0 : ℤ) ≤ measure e ∧ measure o2 < measure e) ∧ (0 : ℤ) ≤ r ∧ r < k) ∧ (∀(o3 : DWP.hcode), DWP.hcode_ok o3 ∧ DWP.hcode.post1 o3 = Spec.expr_post o2 r → DWP.hcode_ok o3))) ∧ (∀(o2 : DWP.wcode), (match e with | Spec.expr.Evar x => (∃(o3 : DWP.wcode), (DWP.wcode_ok o3 ∧ DWP.wcode.trans1 o3 = identity) ∧ DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = DWP.rcompose (DWP.wcode.trans1 o3) (DWP.rcompose (exec_closure (Spec.instr.Iload x r)))) | Spec.expr.Eneg e1 => (∃(o3 : DWP.wcode), (DWP.wcode_ok o3 ∧ DWP.wcode.trans1 o3 = identity) ∧ (∃(o4 : DWP.wcode), (DWP.wcode_ok o4 ∧ DWP.wcode.trans1 o4 = DWP.rcompose (DWP.wcode.trans1 o3) (DWP.rcompose (exec_closure (Spec.instr.Ineg r)))) ∧ (∃(o5 : DWP.hcode), (DWP.hcode_ok o5 ∧ DWP.hcode.post1 o5 = Spec.expr_post e1 r) ∧ (∃(o6 : DWP.wcode), (DWP.wcode_ok o6 ∧ DWP.wcode.trans1 o6 = DWP.to_wp (DWP.hcode.post1 o5)) ∧ DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = DWP.rcompose (DWP.wcode.trans1 o4) (DWP.wcode.trans1 o6))))) | Spec.expr.Eadd e1 e2 => (if n e2 ≤ n e1 then if r < k - (1 : ℤ) then ∃(o3 : DWP.wcode), (DWP.wcode_ok o3 ∧ DWP.wcode.trans1 o3 = identity) ∧ (∃(o4 : DWP.wcode), (DWP.wcode_ok o4 ∧ DWP.wcode.trans1 o4 = DWP.rcompose (DWP.wcode.trans1 o3) (DWP.rcompose (exec_closure (Spec.instr.Iadd (r + (1 : ℤ)) r)))) ∧ (∃(o5 : DWP.hcode), (DWP.hcode_ok o5 ∧ DWP.hcode.post1 o5 = Spec.expr_post e2 (r + (1 : ℤ))) ∧ (∃(o6 : DWP.wcode), (DWP.wcode_ok o6 ∧ DWP.wcode.trans1 o6 = DWP.to_wp (DWP.hcode.post1 o5)) ∧ (∃(o7 : DWP.hcode), (DWP.hcode_ok o7 ∧ DWP.hcode.post1 o7 = Spec.expr_post e1 r) ∧ (∃(o8 : DWP.wcode), (DWP.wcode_ok o8 ∧ DWP.wcode.trans1 o8 = DWP.to_wp (DWP.hcode.post1 o7)) ∧ (∃(o9 : DWP.wcode), (DWP.wcode_ok o9 ∧ DWP.wcode.trans1 o9 = DWP.rcompose (DWP.wcode.trans1 o6) (DWP.wcode.trans1 o8)) ∧ DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = DWP.rcompose (DWP.wcode.trans1 o4) (DWP.wcode.trans1 o9))))))) else ∃(o3 : DWP.wcode), (DWP.wcode_ok o3 ∧ DWP.wcode.trans1 o3 = identity) ∧ (∃(o4 : DWP.wcode), (DWP.wcode_ok o4 ∧ DWP.wcode.trans1 o4 = DWP.rcompose (DWP.wcode.trans1 o3) (DWP.rcompose (exec_closure (Spec.instr.Ipop (k - (2 : ℤ)))))) ∧ (∃(o5 : DWP.wcode), (DWP.wcode_ok o5 ∧ DWP.wcode.trans1 o5 = DWP.rcompose (DWP.wcode.trans1 o4) (DWP.rcompose (exec_closure (Spec.instr.Iadd (k - (2 : ℤ)) (k - (1 : ℤ)))))) ∧ (∃(o6 : DWP.hcode), (DWP.hcode_ok o6 ∧ DWP.hcode.post1 o6 = Spec.expr_post e2 (k - (1 : ℤ))) ∧ (∃(o7 : DWP.wcode), (DWP.wcode_ok o7 ∧ DWP.wcode.trans1 o7 = DWP.to_wp (DWP.hcode.post1 o6)) ∧ (∃(o8 : DWP.hcode), (DWP.hcode_ok o8 ∧ DWP.hcode.post1 o8 = Spec.expr_post e1 (k - (2 : ℤ))) ∧ (∃(o9 : DWP.wcode), (DWP.wcode_ok o9 ∧ DWP.wcode.trans1 o9 = DWP.to_wp (DWP.hcode.post1 o8)) ∧ (∃(o10 : DWP.wcode), (DWP.wcode_ok o10 ∧ DWP.wcode.trans1 o10 = DWP.rcompose (DWP.wcode.trans1 o7) (DWP.wcode.trans1 o9)) ∧ (∃(o11 : DWP.wcode), (DWP.wcode_ok o11 ∧ DWP.wcode.trans1 o11 = DWP.rcompose (DWP.wcode.trans1 o5) (DWP.wcode.trans1 o10)) ∧ DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = DWP.rcompose (DWP.wcode.trans1 o11) (DWP.rcompose (exec_closure (Spec.instr.Ipush (k - (2 : ℤ))))))))))))) else ∃(o3 : DWP.hcode), (DWP.hcode_ok o3 ∧ DWP.hcode.post1 o3 = Spec.expr_post (Spec.expr.Eadd e2 e1) r) ∧ DWP.wcode_ok o2 ∧ DWP.wcode.trans1 o2 = DWP.to_wp (DWP.hcode.post1 o3))) → (DWP.wcode_ok o2 ∧ (∀(x : Spec.state), DWP.wcode.trans1 o2 (o1 x) x = true)) ∧ (∀(result : DWP.hcode), DWP.hcode_ok result ∧ DWP.hcode.post1 result = o1 → DWP.hcode_ok result ∧ DWP.hcode.post1 result = Spec.expr_post e r))
  := sorry
end register_allocation_OptimalNumberOfRegisters_compileqtvc
