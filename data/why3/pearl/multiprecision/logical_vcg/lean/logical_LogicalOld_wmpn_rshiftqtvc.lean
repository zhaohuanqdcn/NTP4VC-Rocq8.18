import Why3.Base
import Why3.why3.Ref.Ref
import Why3.map.Const
import Why3.map.MapEq
import pearl.multiprecision.lib.lean.logical.LogicalUtil
import Why3.mach.int.Unsigned
import Why3.mach.c.C
import pearl.multiprecision.lib.lean.types.Config
import pearl.multiprecision.lib.lean.types.Types
import pearl.multiprecision.lib.lean.types.Int32Eq
import pearl.multiprecision.lib.lean.types.UInt64Eq
import pearl.multiprecision.lib.lean.lemmas.Lemmas
open Classical
open Lean4Why3
namespace logical_LogicalOld_wmpn_rshiftqtvc
theorem wmpn_rshift'vc (x : C.ptr (BitVec 64)) (sz : BitVec 32) (r : C.ptr (BitVec 64)) (cnt : BitVec 64) (fact0 : C.valid x (BitVec.toInt sz)) (fact1 : C.valid r (BitVec.toInt sz)) (fact2 : (0 : ℤ) < BitVec.toUInt cnt) (fact3 : BitVec.toUInt cnt < (64 : ℤ)) (fact4 : (0 : ℤ) < BitVec.toInt sz) (fact5 : C.writable r = true) : uint'64_in_bounds ((64 : ℤ) - BitVec.toUInt cnt) ∧ (∀(tnc : BitVec 64), BitVec.toUInt tnc = (64 : ℤ) - BitVec.toUInt cnt → int'32_in_bounds (BitVec.toInt sz - (1 : ℤ)) ∧ (∀(msb : BitVec 32), BitVec.toInt msb = BitVec.toInt sz - (1 : ℤ) → (C.min x ≤ C.offset x + (0 : ℤ) ∧ C.offset x + (0 : ℤ) ≤ C.max x) ∧ (∀(o1 : C.ptr (BitVec 64)), C.offset o1 = C.offset x + (0 : ℤ) ∧ C.plength o1 = C.plength x ∧ C.pelts o1 = C.pelts x ∧ C.data o1 = C.data x ∧ C.min o1 = C.min x ∧ C.max o1 = C.max x ∧ C.zone1 o1 = C.zone1 x ∧ C.writable o1 = C.writable x → (C.min r ≤ C.offset r + (0 : ℤ) ∧ C.offset r + (0 : ℤ) ≤ C.max r) ∧ (∀(o2 : C.ptr (BitVec 64)), C.offset o2 = C.offset r + (0 : ℤ) ∧ C.plength o2 = C.plength r ∧ C.pelts o2 = C.pelts r ∧ C.data o2 = C.data r ∧ C.min o2 = C.min r ∧ C.max o2 = C.max r ∧ C.zone1 o2 = C.zone1 r ∧ C.writable o2 = C.writable r → (C.min o1 ≤ C.offset o1 ∧ C.offset o1 < C.max o1) ∧ ((0 : ℤ) < BitVec.toUInt tnc ∧ BitVec.toUInt tnc < (64 : ℤ)) ∧ (∀(retval : BitVec 64) (h : BitVec 64), BitVec.toUInt retval + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt h = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt tnc)) * BitVec.toUInt (C.pelts o1 (C.offset o1)) ∧ BitVec.toUInt retval % HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt tnc)) = (0 : ℤ) ∧ BitVec.toUInt retval ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt tnc)) ∧ BitVec.toUInt h < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt tnc)) → (let c : ℤ := HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt tnc)); (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt msb) ∧ BitVec.toUInt retval + ((18446744073709551615 : ℤ) + (1 : ℤ)) * (Lemmas.value r (0 : ℤ) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (0 : ℕ) * BitVec.toUInt h) = Lemmas.value x ((0 : ℤ) + (1 : ℤ)) * c ∧ C.offset o2 = C.offset r + (0 : ℤ) ∧ C.offset o1 = C.offset x + (0 : ℤ) ∧ C.plength o2 = C.plength r ∧ C.min o2 = C.min r ∧ C.max o2 = C.max r ∧ C.writable o2 = true ∧ C.plength o1 = C.plength x ∧ C.min o1 = C.min x ∧ C.max o1 = C.max x ∧ C.pelts o2 = C.pelts r ∧ C.pelts o1 = C.pelts x ∧ BitVec.toUInt h < c) ∧ (∀(i : BitVec 32) (low : BitVec 64) (rp : C.ptr (BitVec 64)) (xp : C.ptr (BitVec 64)) (r1 : C.ptr (BitVec 64)), List.length (C.data r1) = List.length (C.data r) ∧ C.offset r1 = C.offset r ∧ C.min r1 = C.min r ∧ C.max r1 = C.max r ∧ C.writable r1 = C.writable r ∧ C.zone1 r1 = C.zone1 r → ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt msb) ∧ BitVec.toUInt retval + ((18446744073709551615 : ℤ) + (1 : ℤ)) * (Lemmas.value r1 (BitVec.toInt i) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt i)) * BitVec.toUInt low) = Lemmas.value x (BitVec.toInt i + (1 : ℤ)) * c ∧ C.offset rp = C.offset r1 + BitVec.toInt i ∧ C.offset xp = C.offset x + BitVec.toInt i ∧ C.plength rp = C.plength r1 ∧ C.min rp = C.min r1 ∧ C.max rp = C.max r1 ∧ C.writable rp = true ∧ C.plength xp = C.plength x ∧ C.min xp = C.min x ∧ C.max xp = C.max x ∧ C.pelts rp = C.pelts r1 ∧ C.pelts xp = C.pelts x ∧ BitVec.toUInt low < c → (if BitVec.toInt i < BitVec.toInt msb then (C.min xp ≤ C.offset xp + (1 : ℤ) ∧ C.offset xp + (1 : ℤ) ≤ C.max xp) ∧ (∀(o3 : C.ptr (BitVec 64)), C.offset o3 = C.offset xp + (1 : ℤ) ∧ C.plength o3 = C.plength xp ∧ C.pelts o3 = C.pelts xp ∧ C.data o3 = C.data xp ∧ C.min o3 = C.min xp ∧ C.max o3 = C.max xp ∧ C.zone1 o3 = C.zone1 xp ∧ C.writable o3 = C.writable xp → (C.min o3 ≤ C.offset o3 ∧ C.offset o3 < C.max o3) ∧ ((0 : ℤ) < BitVec.toUInt tnc ∧ BitVec.toUInt tnc < (64 : ℤ)) ∧ (∀(l : BitVec 64) (h1 : BitVec 64), BitVec.toUInt l + ((18446744073709551615 : ℤ) + (1 : ℤ)) * BitVec.toUInt h1 = HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt tnc)) * BitVec.toUInt (C.pelts o3 (C.offset o3)) ∧ BitVec.toUInt l % HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt tnc)) = (0 : ℤ) ∧ BitVec.toUInt l ≤ (18446744073709551615 : ℤ) + (1 : ℤ) - HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt tnc)) ∧ BitVec.toUInt h1 < HPow.hPow (2 : ℤ) (Int.toNat (BitVec.toUInt tnc)) → uint'64_in_bounds (BitVec.toUInt low + BitVec.toUInt l) ∧ (∀(v : BitVec 64), BitVec.toUInt v = BitVec.toUInt low + BitVec.toUInt l → uint'64_in_bounds (BitVec.toUInt low + BitVec.toUInt l) ∧ (∀(o4 : BitVec 64), BitVec.toUInt o4 = BitVec.toUInt low + BitVec.toUInt l → ((C.min rp ≤ C.offset rp ∧ C.offset rp < C.max rp) ∧ C.writable rp = true) ∧ (∀(rp1 : C.ptr (BitVec 64)) (r2 : C.ptr (BitVec 64)), C.data rp1 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → C.data rp1 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data rp) ∧ C.offset rp1 = C.offset rp ∧ C.min rp1 = C.min rp ∧ C.max rp1 = C.max rp ∧ C.writable rp1 = C.writable rp ∧ C.zone1 rp1 = C.zone1 rp → List.length (C.data r2) = List.length (C.data r1) ∧ C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.max r2 = C.max r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → C.pelts rp1 = Function.update (C.pelts rp) (C.offset rp1) o4 → int'32_in_bounds (BitVec.toInt i + (1 : ℤ)) ∧ (∀(o5 : BitVec 32), BitVec.toInt o5 = BitVec.toInt i + (1 : ℤ) → (C.min rp1 ≤ C.offset rp1 + (1 : ℤ) ∧ C.offset rp1 + (1 : ℤ) ≤ C.max rp1) ∧ (∀(o6 : C.ptr (BitVec 64)), C.offset o6 = C.offset rp1 + (1 : ℤ) ∧ C.plength o6 = C.plength rp1 ∧ C.pelts o6 = C.pelts rp1 ∧ C.data o6 = C.data rp1 ∧ C.min o6 = C.min rp1 ∧ C.max o6 = C.max rp1 ∧ C.zone1 o6 = C.zone1 rp1 ∧ C.writable o6 = C.writable rp1 → ((0 : ℤ) ≤ BitVec.toInt sz - BitVec.toInt i ∧ BitVec.toInt sz - BitVec.toInt o5 < BitVec.toInt sz - BitVec.toInt i) ∧ ((0 : ℤ) ≤ BitVec.toInt o5 ∧ BitVec.toInt o5 ≤ BitVec.toInt msb) ∧ BitVec.toUInt retval + ((18446744073709551615 : ℤ) + (1 : ℤ)) * (Lemmas.value r2 (BitVec.toInt o5) + HPow.hPow ((18446744073709551615 : ℤ) + (1 : ℤ)) (Int.toNat (BitVec.toInt o5)) * BitVec.toUInt h1) = Lemmas.value x (BitVec.toInt o5 + (1 : ℤ)) * c ∧ C.offset o6 = C.offset r2 + BitVec.toInt o5 ∧ C.offset o3 = C.offset x + BitVec.toInt o5 ∧ C.plength o6 = C.plength r2 ∧ C.min o6 = C.min r2 ∧ C.max o6 = C.max r2 ∧ C.writable o6 = true ∧ C.plength o3 = C.plength x ∧ C.min o3 = C.min x ∧ C.max o3 = C.max x ∧ C.pelts o6 = C.pelts r2 ∧ C.pelts o3 = C.pelts x ∧ BitVec.toUInt h1 < c))))))) else ((C.min rp ≤ C.offset rp ∧ C.offset rp < C.max rp) ∧ C.writable rp = true) ∧ (∀(o3 : C.ptr (BitVec 64)) (r2 : C.ptr (BitVec 64)), C.data o3 = C.data r2 ∧ List.length (C.data r2) = List.length (C.data rp) ∧ C.offset o3 = C.offset rp ∧ C.min o3 = C.min rp ∧ C.max o3 = C.max rp ∧ C.writable o3 = C.writable rp ∧ C.zone1 o3 = C.zone1 rp → List.length (C.data r2) = List.length (C.data r1) ∧ C.offset r2 = C.offset r1 ∧ C.min r2 = C.min r1 ∧ C.max r2 = C.max r1 ∧ C.writable r2 = C.writable r1 ∧ C.zone1 r2 = C.zone1 r1 → C.pelts o3 = Function.update (C.pelts rp) (C.offset o3) low → BitVec.toUInt retval + ((18446744073709551615 : ℤ) + (1 : ℤ)) * Lemmas.value r2 (BitVec.toInt sz) = Lemmas.value x (BitVec.toInt sz) * HPow.hPow (2 : ℤ) (Int.toNat ((64 : ℤ) - BitVec.toUInt cnt)))))))))))
  := sorry
end logical_LogicalOld_wmpn_rshiftqtvc
