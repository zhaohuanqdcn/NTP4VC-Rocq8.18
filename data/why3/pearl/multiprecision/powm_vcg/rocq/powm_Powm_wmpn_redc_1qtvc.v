From Coq Require Import Strings.String.
From Coq Require Import String Ascii.
From Coq Require Arith.
From stdpp Require Import base.
From stdpp Require Import fin_maps.
From stdpp Require Import gmap.
From stdpp Require Import base gmultiset.
From Coq Require Classical.
From Coq Require Import ZArith.
From stdpp.bitvector Require Import definitions tactics.
From Coq Require Import Sorting.Sorted.
From Coq Require Import Reals.Rbasic_fun.
From Coq Require Import Reals.Abstract.ConstructiveAbs.
From Coq Require Import Reals.Rdefinitions.
From stdpp Require Import list_relations.
From stdpp Require Import list_numbers.
From stdpp Require Import functions.
From Coq Require Import ClassicalEpsilon.
From stdpp Require Import base decidable.
From Coq Require Import ZArith.Zeuclid.
From Coq Require Import ZArith.Znumtheory.
From stdpp Require Import propset.
From Coq Require Import Reals.
Require Import Why3.Base.
Require Import Why3.why3.Ref.Ref.
Require Import Why3.map.Const.
Require Import Why3.map.MapEq.
Require Import Why3.mach.c.C.
Require Import Why3.mach.int.Unsigned.
Require Import multiprecision.types.Config.
Require Import multiprecision.types.Types.
Require Import multiprecision.types.Int32Eq.
Require Import multiprecision.types.UInt64Eq.
Require Import multiprecision.lemmas.Lemmas.
Require Import multiprecision.compare.Compare.
Require Import multiprecision.valuation.Valuation.
Require Import multiprecision.util.Util.
Require Import multiprecision.ptralias.Alias.
Require Import multiprecision.util.UtilOld.
Require Import multiprecision.add.Add.
Require Import multiprecision.add.AddOld.
Require Import multiprecision.sub.SubOld.
Require Import multiprecision.mul.Mul.
Require Import multiprecision.mul.Mul_basecase.
Require Import multiprecision.logical.LogicalUtil.
Require Import multiprecision.logical.Logical.
Require Import multiprecision.logical.LogicalOld.
Require Import multiprecision.div.Div.
Require Import multiprecision.toom.Toom.
Require Import multiprecision.add_1.Add_1.
Require Import multiprecision.sub_1.Sub_1.
Open Scope Z_scope.
Definition redc (ur : Z) (u : Z) (n : Z) (m : Z) := ZEuclid.modulo ur m = ZEuclid.modulo (Z.pow (18446744073709551615%Z + 1%Z) n * u) m.
Theorem wmpn_redc_1'vc (n : bv 32%N) (mp : ptr (bv 64%N)) (up : ptr (bv 64%N)) (rp : ptr (bv 64%N)) (invm : bv 64%N) (fact0 : 0%Z < bv_signed n) (fact1 : valid mp (bv_signed n)) (fact2 : valid up (2%Z * bv_signed n)) (fact3 : valid rp (bv_signed n)) (fact4 : Z.Odd (value mp (bv_signed n))) (fact5 : ZEuclid.modulo (value mp (bv_signed n) * bv_unsigned invm) (18446744073709551615%Z + 1%Z) = 18446744073709551615%Z + 1%Z - 1%Z) (fact6 : writable up = true) (fact7 : writable rp = true) : min up ≤ offset up + 0%Z ∧ offset up + 0%Z ≤ C.max up ∧ (∀(o1 : ptr (bv 64%N)), offset o1 = offset up + 0%Z ∧ plength o1 = plength up ∧ pelts o1 = pelts up ∧ data o1 = data up ∧ min o1 = min up ∧ C.max o1 = C.max up ∧ zone1 o1 = zone1 up ∧ writable o1 = writable up -> (let vm : Z := value mp (bv_signed n) in int'32_in_bounds (bv_signed n - 1%Z) ∧ (∀(o2 : bv 32%N), bv_signed o2 = bv_signed n - 1%Z -> (0%Z ≤ bv_signed o2 + 1%Z -> (offset o1 = offset up + 0%Z ∧ pelts o1 = pelts up ∧ min o1 = min up ∧ C.max o1 = C.max up ∧ plength o1 = plength up ∧ writable o1 = true ∧ Z.pow (18446744073709551615%Z + 1%Z) 0%Z * value o1 (bv_signed n + bv_signed n - 0%Z) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * value up 0%Z = value up (bv_signed n + bv_signed n) + vm * 0%Z ∧ (0%Z ≤ 0%Z ∧ 0%Z < Z.pow (18446744073709551615%Z + 1%Z) 0%Z) ∧ ZEuclid.modulo (Z.pow (18446744073709551615%Z + 1%Z) 0%Z * value o1 (bv_signed n + bv_signed n - 0%Z) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * value up 0%Z) vm = ZEuclid.modulo (value up (bv_signed n + bv_signed n)) vm) ∧ (∀(added : Z) (u : ptr (bv 64%N)) (up1 : ptr (bv 64%N)), length (data up1) = length (data up) ∧ offset up1 = offset up ∧ min up1 = min up ∧ C.max up1 = C.max up ∧ writable up1 = writable up ∧ zone1 up1 = zone1 up -> (∀(j : bv 32%N), let j1 : Z := bv_signed j in (0%Z ≤ j1 ∧ j1 ≤ bv_signed o2) ∧ offset u = offset up1 + j1 ∧ pelts u = pelts up1 ∧ min u = min up1 ∧ C.max u = C.max up1 ∧ plength u = plength up1 ∧ writable u = true ∧ Z.pow (18446744073709551615%Z + 1%Z) j1 * value u (bv_signed n + bv_signed n - j1) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * value up1 j1 = value up (bv_signed n + bv_signed n) + vm * added ∧ (0%Z ≤ added ∧ added < Z.pow (18446744073709551615%Z + 1%Z) j1) ∧ ZEuclid.modulo (Z.pow (18446744073709551615%Z + 1%Z) j1 * value u (bv_signed n + bv_signed n - j1) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * value up1 j1) vm = ZEuclid.modulo (value up (bv_signed n + bv_signed n)) vm -> (min u ≤ offset u ∧ offset u < C.max u) ∧ (∀(m : bv 64%N), bv_unsigned m = ZEuclid.modulo (bv_unsigned (pelts u (offset u)) * bv_unsigned invm) (18446744073709551615%Z + 1%Z) -> int'32_in_bounds (bv_signed n + bv_signed n) ∧ (∀(o3 : bv 32%N), bv_signed o3 = bv_signed n + bv_signed n -> int'32_in_bounds (bv_signed o3 - bv_signed j) ∧ (∀(nnj : bv 32%N), bv_signed nnj = bv_signed o3 - bv_signed j -> (valid mp (bv_signed n) ∧ valid u (bv_signed n) ∧ writable u = true) ∧ (∀(u1 : ptr (bv 64%N)) (up2 : ptr (bv 64%N)), data u1 = data up2 ∧ length (data up2) = length (data u) ∧ offset u1 = offset u ∧ min u1 = min u ∧ C.max u1 = C.max u ∧ writable u1 = writable u ∧ zone1 u1 = zone1 u -> data u1 = data up2 ∧ length (data up2) = length (data u) ∧ offset u1 = offset u ∧ min u1 = min u ∧ C.max u1 = C.max u ∧ writable u1 = writable u ∧ zone1 u1 = zone1 u -> length (data up2) = length (data up1) ∧ offset up2 = offset up1 ∧ min up2 = min up1 ∧ C.max up2 = C.max up1 ∧ writable up2 = writable up1 ∧ zone1 up2 = zone1 up1 -> (∀(o4 : bv 64%N), value u1 (bv_signed n) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * bv_unsigned o4 = value u (bv_signed n) + value mp (bv_signed n) * bv_unsigned m ∧ (∀(j2 : Z), j2 < offset u1 ∨ offset u1 + bv_signed n ≤ j2 -> pelts u1 j2 = pelts u j2) -> ((min u1 ≤ offset u1 ∧ offset u1 < C.max u1) ∧ writable u1 = true) ∧ (∀(u2 : ptr (bv 64%N)) (up3 : ptr (bv 64%N)), data u2 = data up3 ∧ length (data up3) = length (data u1) ∧ offset u2 = offset u1 ∧ min u2 = min u1 ∧ C.max u2 = C.max u1 ∧ writable u2 = writable u1 ∧ zone1 u2 = zone1 u1 -> data u2 = data up3 ∧ length (data up3) = length (data u1) ∧ offset u2 = offset u1 ∧ min u2 = min u1 ∧ C.max u2 = C.max u1 ∧ writable u2 = writable u1 ∧ zone1 u2 = zone1 u1 -> length (data up3) = length (data up2) ∧ offset up3 = offset up2 ∧ min up3 = min up2 ∧ C.max up3 = C.max up2 ∧ writable up3 = writable up2 ∧ zone1 up3 = zone1 up2 -> pelts u2 = fun_updt (pelts u1) (offset u2) o4 -> (min u2 ≤ offset u2 + 1%Z ∧ offset u2 + 1%Z ≤ C.max u2) ∧ (∀(o5 : ptr (bv 64%N)), offset o5 = offset u2 + 1%Z ∧ plength o5 = plength u2 ∧ pelts o5 = pelts u2 ∧ data o5 = data u2 ∧ min o5 = min u2 ∧ C.max o5 = C.max u2 ∧ zone1 o5 = zone1 u2 ∧ writable o5 = writable u2 -> offset o5 = offset up3 + (j1 + 1%Z) ∧ pelts o5 = pelts up3 ∧ min o5 = min up3 ∧ C.max o5 = C.max up3 ∧ plength o5 = plength up3 ∧ writable o5 = true ∧ Z.pow (18446744073709551615%Z + 1%Z) (j1 + 1%Z) * value o5 (bv_signed n + bv_signed n - (j1 + 1%Z)) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * value up3 (j1 + 1%Z) = value up (bv_signed n + bv_signed n) + vm * (added + bv_unsigned m * Z.pow (18446744073709551615%Z + 1%Z) (bv_signed j)) ∧ (0%Z ≤ added + bv_unsigned m * Z.pow (18446744073709551615%Z + 1%Z) (bv_signed j) ∧ added + bv_unsigned m * Z.pow (18446744073709551615%Z + 1%Z) (bv_signed j) < Z.pow (18446744073709551615%Z + 1%Z) (j1 + 1%Z)) ∧ ZEuclid.modulo (Z.pow (18446744073709551615%Z + 1%Z) (j1 + 1%Z) * value o5 (bv_signed n + bv_signed n - (j1 + 1%Z)) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * value up3 (j1 + 1%Z)) vm = ZEuclid.modulo (value up (bv_signed n + bv_signed n)) vm)))))))) ∧ (offset u = offset up1 + (bv_signed o2 + 1%Z) ∧ pelts u = pelts up1 ∧ min u = min up1 ∧ C.max u = C.max up1 ∧ plength u = plength up1 ∧ writable u = true ∧ Z.pow (18446744073709551615%Z + 1%Z) (bv_signed o2 + 1%Z) * value u (bv_signed n + bv_signed n - (bv_signed o2 + 1%Z)) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * value up1 (bv_signed o2 + 1%Z) = value up (bv_signed n + bv_signed n) + vm * added ∧ (0%Z ≤ added ∧ added < Z.pow (18446744073709551615%Z + 1%Z) (bv_signed o2 + 1%Z)) ∧ ZEuclid.modulo (Z.pow (18446744073709551615%Z + 1%Z) (bv_signed o2 + 1%Z) * value u (bv_signed n + bv_signed n - (bv_signed o2 + 1%Z)) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * value up1 (bv_signed o2 + 1%Z)) vm = ZEuclid.modulo (value up (bv_signed n + bv_signed n)) vm -> int'32_in_bounds (- bv_signed n) ∧ (∀(o3 : bv 32%N), bv_signed o3 = - bv_signed n -> (min u ≤ offset u + bv_signed o3 ∧ offset u + bv_signed o3 ≤ C.max u) ∧ (∀(u' : ptr (bv 64%N)), offset u' = offset u + bv_signed o3 ∧ plength u' = plength u ∧ pelts u' = pelts u ∧ data u' = data u ∧ min u' = min u ∧ C.max u' = C.max u ∧ zone1 u' = zone1 u ∧ writable u' = writable u -> int'32_in_bounds (- bv_signed n) ∧ (∀(o4 : bv 32%N), bv_signed o4 = - bv_signed n -> (min u ≤ offset u + bv_signed o4 ∧ offset u + bv_signed o4 ≤ C.max u) ∧ (∀(o5 : ptr (bv 64%N)), offset o5 = offset u + bv_signed o4 ∧ plength o5 = plength u ∧ pelts o5 = pelts u ∧ data o5 = data u ∧ min o5 = min u ∧ C.max o5 = C.max u ∧ zone1 o5 = zone1 u ∧ writable o5 = writable u -> (valid u (bv_signed n) ∧ valid o5 (bv_signed n) ∧ valid rp (bv_signed n) ∧ writable rp = true) ∧ (∀(rp1 : ptr (bv 64%N)), length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> (∀(o6 : bv 64%N), (0%Z ≤ bv_unsigned o6 ∧ bv_unsigned o6 ≤ 1%Z) ∧ value rp1 (bv_signed n) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * bv_unsigned o6 = value u (bv_signed n) + value o5 (bv_signed n) ∧ (∀(j : Z), j < offset rp1 ∨ offset rp1 + bv_signed n ≤ j -> pelts rp1 j = pelts rp j) -> (∀(o7 : bool), (bv_unsigned o6 = bv_unsigned (0%bv : bv 64%N) -> o7 = true) ∧ (o7 = true -> o6 = (0%bv : bv 64%N)) -> (if decide (¬ o7 = true) then (0%Z ≤ bv_signed n ∧ valid rp1 (bv_signed n) ∧ valid mp (bv_signed n) ∧ writable rp1 = true) ∧ (∀(rp2 : ptr (bv 64%N)), length (data rp2) = length (data rp1) ∧ offset rp2 = offset rp1 ∧ min rp2 = min rp1 ∧ C.max rp2 = C.max rp1 ∧ writable rp2 = writable rp1 ∧ zone1 rp2 = zone1 rp1 -> (∀(b : bv 64%N), value rp2 (bv_signed n) - Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * bv_unsigned b = value rp1 (bv_signed n) - value mp (bv_signed n) ∧ (0%Z ≤ bv_unsigned b ∧ bv_unsigned b ≤ 1%Z) ∧ (∀(j : Z), j < offset rp2 ∨ offset rp2 + bv_signed n ≤ j -> pelts rp2 j = pelts rp1 j) -> ZEuclid.modulo (value rp2 (bv_signed n)) vm = ZEuclid.modulo (value rp1 (bv_signed n) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * bv_unsigned o6) vm ∧ (∀(j : Z), j < offset rp2 ∨ offset rp2 + bv_signed n ≤ j -> pelts rp2 j = pelts rp1 j) ∧ (value up (2%Z * bv_signed n) < Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * vm -> value rp2 (bv_signed n) < 2%Z * vm))) else ZEuclid.modulo (value rp1 (bv_signed n)) vm = ZEuclid.modulo (value rp1 (bv_signed n) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * bv_unsigned o6) vm ∧ (value up (2%Z * bv_signed n) < Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * vm -> value rp1 (bv_signed n) < 2%Z * vm))) ∧ (∀(rp2 : ptr (bv 64%N)), length (data rp2) = length (data rp1) ∧ offset rp2 = offset rp1 ∧ min rp2 = min rp1 ∧ C.max rp2 = C.max rp1 ∧ writable rp2 = writable rp1 ∧ zone1 rp2 = zone1 rp1 -> ZEuclid.modulo (value rp2 (bv_signed n)) vm = ZEuclid.modulo (value rp1 (bv_signed n) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * bv_unsigned o6) vm ∧ (∀(j : Z), j < offset rp2 ∨ offset rp2 + bv_signed n ≤ j -> pelts rp2 j = pelts rp1 j) ∧ (value up (2%Z * bv_signed n) < Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * vm -> value rp2 (bv_signed n) < 2%Z * vm) -> redc (value up (2%Z * bv_signed n)) (value rp2 (bv_signed n)) (bv_signed n) (value mp (bv_signed n)) ∧ (∀(j : Z), j < offset rp2 ∨ offset rp2 + bv_signed n ≤ j -> pelts rp2 j = pelts rp j) ∧ (value up (2%Z * bv_signed n) < Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * value mp (bv_signed n) -> value rp2 (bv_signed n) < 2%Z * value mp (bv_signed n)))))))))))) ∧ (bv_signed o2 + 1%Z < 0%Z -> int'32_in_bounds (- bv_signed n) ∧ (∀(o3 : bv 32%N), bv_signed o3 = - bv_signed n -> (min o1 ≤ offset o1 + bv_signed o3 ∧ offset o1 + bv_signed o3 ≤ C.max o1) ∧ (∀(u' : ptr (bv 64%N)), offset u' = offset o1 + bv_signed o3 ∧ plength u' = plength o1 ∧ pelts u' = pelts o1 ∧ data u' = data o1 ∧ min u' = min o1 ∧ C.max u' = C.max o1 ∧ zone1 u' = zone1 o1 ∧ writable u' = writable o1 -> int'32_in_bounds (- bv_signed n) ∧ (∀(o4 : bv 32%N), bv_signed o4 = - bv_signed n -> (min o1 ≤ offset o1 + bv_signed o4 ∧ offset o1 + bv_signed o4 ≤ C.max o1) ∧ (∀(o5 : ptr (bv 64%N)), offset o5 = offset o1 + bv_signed o4 ∧ plength o5 = plength o1 ∧ pelts o5 = pelts o1 ∧ data o5 = data o1 ∧ min o5 = min o1 ∧ C.max o5 = C.max o1 ∧ zone1 o5 = zone1 o1 ∧ writable o5 = writable o1 -> (valid o1 (bv_signed n) ∧ valid o5 (bv_signed n) ∧ valid rp (bv_signed n) ∧ writable rp = true) ∧ (∀(rp1 : ptr (bv 64%N)), length (data rp1) = length (data rp) ∧ offset rp1 = offset rp ∧ min rp1 = min rp ∧ C.max rp1 = C.max rp ∧ writable rp1 = writable rp ∧ zone1 rp1 = zone1 rp -> (∀(o6 : bv 64%N), (0%Z ≤ bv_unsigned o6 ∧ bv_unsigned o6 ≤ 1%Z) ∧ value rp1 (bv_signed n) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * bv_unsigned o6 = value o1 (bv_signed n) + value o5 (bv_signed n) ∧ (∀(j : Z), j < offset rp1 ∨ offset rp1 + bv_signed n ≤ j -> pelts rp1 j = pelts rp j) -> (∀(o7 : bool), (bv_unsigned o6 = bv_unsigned (0%bv : bv 64%N) -> o7 = true) ∧ (o7 = true -> o6 = (0%bv : bv 64%N)) -> (if decide (¬ o7 = true) then (0%Z ≤ bv_signed n ∧ valid rp1 (bv_signed n) ∧ valid mp (bv_signed n) ∧ writable rp1 = true) ∧ (∀(rp2 : ptr (bv 64%N)), length (data rp2) = length (data rp1) ∧ offset rp2 = offset rp1 ∧ min rp2 = min rp1 ∧ C.max rp2 = C.max rp1 ∧ writable rp2 = writable rp1 ∧ zone1 rp2 = zone1 rp1 -> (∀(b : bv 64%N), value rp2 (bv_signed n) - Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * bv_unsigned b = value rp1 (bv_signed n) - value mp (bv_signed n) ∧ (0%Z ≤ bv_unsigned b ∧ bv_unsigned b ≤ 1%Z) ∧ (∀(j : Z), j < offset rp2 ∨ offset rp2 + bv_signed n ≤ j -> pelts rp2 j = pelts rp1 j) -> ZEuclid.modulo (value rp2 (bv_signed n)) vm = ZEuclid.modulo (value rp1 (bv_signed n) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * bv_unsigned o6) vm ∧ (∀(j : Z), j < offset rp2 ∨ offset rp2 + bv_signed n ≤ j -> pelts rp2 j = pelts rp1 j) ∧ (value up (2%Z * bv_signed n) < Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * vm -> value rp2 (bv_signed n) < 2%Z * vm))) else ZEuclid.modulo (value rp1 (bv_signed n)) vm = ZEuclid.modulo (value rp1 (bv_signed n) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * bv_unsigned o6) vm ∧ (value up (2%Z * bv_signed n) < Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * vm -> value rp1 (bv_signed n) < 2%Z * vm))) ∧ (∀(rp2 : ptr (bv 64%N)), length (data rp2) = length (data rp1) ∧ offset rp2 = offset rp1 ∧ min rp2 = min rp1 ∧ C.max rp2 = C.max rp1 ∧ writable rp2 = writable rp1 ∧ zone1 rp2 = zone1 rp1 -> ZEuclid.modulo (value rp2 (bv_signed n)) vm = ZEuclid.modulo (value rp1 (bv_signed n) + Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * bv_unsigned o6) vm ∧ (∀(j : Z), j < offset rp2 ∨ offset rp2 + bv_signed n ≤ j -> pelts rp2 j = pelts rp1 j) ∧ (value up (2%Z * bv_signed n) < Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * vm -> value rp2 (bv_signed n) < 2%Z * vm) -> redc (value up (2%Z * bv_signed n)) (value rp2 (bv_signed n)) (bv_signed n) (value mp (bv_signed n)) ∧ (∀(j : Z), j < offset rp2 ∨ offset rp2 + bv_signed n ≤ j -> pelts rp2 j = pelts rp j) ∧ (value up (2%Z * bv_signed n) < Z.pow (18446744073709551615%Z + 1%Z) (bv_signed n) * value mp (bv_signed n) -> value rp2 (bv_signed n) < 2%Z * value mp (bv_signed n))))))))))))).
Proof.
Admitted.
