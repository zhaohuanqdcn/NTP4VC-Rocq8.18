theory bubble_sort_TAOCP_bubble_sortqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut" "Why3STD.array_IntArraySorted"
begin
theorem bubble_sort'vc:
  fixes a :: "int list"
  shows "let n :: int = int (length a) in (n \<le> n \<and> a <~~> a \<and> (\<forall>(i1 :: int) (i2 :: int). (0 :: int) \<le> i1 \<and> i1 < n \<and> n \<le> i2 \<and> i2 < n \<longrightarrow> a ! nat i1 \<le> a ! nat i2) \<and> sorted_sub1 a n n) \<and> (\<forall>(bound :: int) (a1 :: int list). length a1 = length a \<longrightarrow> bound \<le> n \<and> a <~~> a1 \<and> (\<forall>(i1 :: int) (i2 :: int). (0 :: int) \<le> i1 \<and> i1 < bound \<and> bound \<le> i2 \<and> i2 < n \<longrightarrow> a1 ! nat i1 \<le> a1 ! nat i2) \<and> sorted_sub1 a1 bound n \<longrightarrow> (if (2 :: int) \<le> bound then let o1 :: int = bound - (2 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> ((0 :: int) \<le> (0 :: int) \<and> a <~~> a1 \<and> (\<forall>(i1 :: int) (i2 :: int). (0 :: int) \<le> i1 \<and> i1 < bound \<and> bound \<le> i2 \<and> i2 < n \<longrightarrow> a1 ! nat i1 \<le> a1 ! nat i2) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> (0 :: int) \<longrightarrow> a1 ! nat i \<le> a1 ! (0 :: nat)) \<and> sorted_sub1 a1 (0 :: int) ((0 :: int) + (1 :: int)) \<and> sorted_sub1 a1 bound n) \<and> (\<forall>(t :: int) (a2 :: int list). length a2 = length a1 \<longrightarrow> (\<forall>(j :: int). ((0 :: int) \<le> j \<and> j \<le> o1) \<and> ((0 :: int) \<le> t \<and> t \<le> j) \<and> a <~~> a2 \<and> (\<forall>(i1 :: int) (i2 :: int). (0 :: int) \<le> i1 \<and> i1 < bound \<and> bound \<le> i2 \<and> i2 < n \<longrightarrow> a2 ! nat i1 \<le> a2 ! nat i2) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> t \<longrightarrow> a2 ! nat i \<le> a2 ! nat t) \<and> sorted_sub1 a2 t (j + (1 :: int)) \<and> sorted_sub1 a2 bound n \<longrightarrow> (let o2 :: int = j + (1 :: int) in ((0 :: int) \<le> o2 \<and> o2 < int (length a2)) \<and> ((0 :: int) \<le> j \<and> j < int (length a2)) \<and> (if a2 ! nat o2 < a2 ! nat j then let o3 :: int = j + (1 :: int) in (((0 :: int) \<le> j \<and> j < int (length a2)) \<and> (0 :: int) \<le> o3 \<and> o3 < int (length a2)) \<and> (\<forall>(a3 :: int list). length a3 = length a2 \<longrightarrow> list_exchange a2 a3 j o3 \<longrightarrow> ((0 :: int) \<le> j + (1 :: int) \<and> j + (1 :: int) \<le> j + (1 :: int)) \<and> a <~~> a3 \<and> (\<forall>(i1 :: int) (i2 :: int). (0 :: int) \<le> i1 \<and> i1 < bound \<and> bound \<le> i2 \<and> i2 < n \<longrightarrow> a3 ! nat i1 \<le> a3 ! nat i2) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> j + (1 :: int) \<longrightarrow> a3 ! nat i \<le> a3 ! nat (j + (1 :: int))) \<and> sorted_sub1 a3 (j + (1 :: int)) (j + (1 :: int) + (1 :: int)) \<and> sorted_sub1 a3 bound n) else ((0 :: int) \<le> t \<and> t \<le> j + (1 :: int)) \<and> a <~~> a2 \<and> (\<forall>(i1 :: int) (i2 :: int). (0 :: int) \<le> i1 \<and> i1 < bound \<and> bound \<le> i2 \<and> i2 < n \<longrightarrow> a2 ! nat i1 \<le> a2 ! nat i2) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> t \<longrightarrow> a2 ! nat i \<le> a2 ! nat t) \<and> sorted_sub1 a2 t (j + (1 :: int) + (1 :: int)) \<and> sorted_sub1 a2 bound n))) \<and> (((0 :: int) \<le> t \<and> t \<le> o1 + (1 :: int)) \<and> a <~~> a2 \<and> (\<forall>(i1 :: int) (i2 :: int). (0 :: int) \<le> i1 \<and> i1 < bound \<and> bound \<le> i2 \<and> i2 < n \<longrightarrow> a2 ! nat i1 \<le> a2 ! nat i2) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i \<le> t \<longrightarrow> a2 ! nat i \<le> a2 ! nat t) \<and> sorted_sub1 a2 t (o1 + (1 :: int) + (1 :: int)) \<and> sorted_sub1 a2 bound n \<longrightarrow> ((0 :: int) \<le> bound \<and> t < bound) \<and> t \<le> n \<and> a <~~> a2 \<and> (\<forall>(i1 :: int) (i2 :: int). (0 :: int) \<le> i1 \<and> i1 < t \<and> t \<le> i2 \<and> i2 < n \<longrightarrow> a2 ! nat i1 \<le> a2 ! nat i2) \<and> sorted_sub1 a2 t n))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> ((0 :: int) \<le> bound \<and> (0 :: int) < bound) \<and> (0 :: int) \<le> n \<and> a <~~> a1 \<and> (\<forall>(i1 :: int) (i2 :: int). (0 :: int) \<le> i1 \<and> i1 < (0 :: int) \<and> (0 :: int) \<le> i2 \<and> i2 < n \<longrightarrow> a1 ! nat i1 \<le> a1 ! nat i2) \<and> sorted_sub1 a1 (0 :: int) n) else a <~~> a1 \<and> array_IntArraySorted.sorted a1))"
  sorry
end
