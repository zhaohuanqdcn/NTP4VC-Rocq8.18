theory patience_PatienceAbstract_play_cardqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const"
begin
typedecl  card
datatype  state = state'mk (num_stacks: "int") (num_elts: "int") ("values": "int \<Rightarrow> int") (stack_sizes: "int \<Rightarrow> int") (stacks1: "int \<Rightarrow> int \<Rightarrow> int") (positions: "int \<Rightarrow> int \<times> int") (preds: "int \<Rightarrow> int")
definition inv :: "state \<Rightarrow> _"
  where "inv s \<longleftrightarrow> ((0 :: int) \<le> num_stacks s \<and> num_stacks s \<le> num_elts s) \<and> ((0 :: int) < num_elts s \<longrightarrow> (0 :: int) < num_stacks s) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_stacks s \<longrightarrow> (1 :: int) \<le> stack_sizes s i \<and> (\<forall>(j :: int). (0 :: int) \<le> j \<and> j < stack_sizes s i \<longrightarrow> (0 :: int) \<le> stacks1 s i j \<and> stacks1 s i j < num_elts s)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_elts s \<longrightarrow> (case positions s i of (is, ip) \<Rightarrow> ((0 :: int) \<le> is \<and> is < num_stacks s) \<and> ((0 :: int) \<le> ip \<and> ip < stack_sizes s is) \<and> stacks1 s is ip = i)) \<and> (\<forall>(is :: int). (0 :: int) \<le> is \<and> is < num_stacks s \<longrightarrow> (\<forall>(ip :: int). (0 :: int) \<le> ip \<and> ip < stack_sizes s is \<longrightarrow> (is, ip) = positions s (stacks1 s is ip))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_stacks s \<longrightarrow> (let stack_i :: int \<Rightarrow> int = stacks1 s i in \<forall>(j :: int) (k :: int). (0 :: int) \<le> j \<and> j < k \<and> k < stack_sizes s i \<longrightarrow> stack_i j < stack_i k)) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_stacks s \<longrightarrow> (let stack_i :: int \<Rightarrow> int = stacks1 s i in \<forall>(j :: int) (k :: int). (0 :: int) \<le> j \<and> j \<le> k \<and> k < stack_sizes s i \<longrightarrow> values s (stack_i k) \<le> values s (stack_i j))) \<and> (\<forall>(i :: int). (0 :: int) \<le> i \<and> i < num_elts s \<longrightarrow> (let pred :: int = preds s i in (-(1 :: int) \<le> pred \<and> pred < num_elts s) \<and> pred < i \<and> (case positions s i of (is, x_ip) \<Rightarrow> (if pred < (0 :: int) then is = (0 :: int) else values s pred < values s i \<and> (0 :: int) < is \<and> (case positions s pred of (ps, x_pp) \<Rightarrow> ps = is - (1 :: int))))))" for s
theorem play_card'vc:
  fixes s :: "state"
  fixes c :: "int"
  assumes fact0: "inv s"
  shows "let o1 :: int = num_stacks s - (1 :: int) in ((0 :: int) \<le> o1 + (1 :: int) \<longrightarrow> (\<forall>(pred :: int). (\<forall>(i :: int). ((0 :: int) \<le> i \<and> i \<le> o1) \<and> (if i = (0 :: int) then pred = -(1 :: int) else pred = stacks1 s (i - (1 :: int)) (stack_sizes s (i - (1 :: int)) - (1 :: int)) \<and> values s pred < c \<and> ((0 :: int) \<le> pred \<and> pred < num_elts s) \<and> (case positions s pred of (ps, x_pp) \<Rightarrow> ps = i - (1 :: int))) \<longrightarrow> (let top_stack_i :: int = stacks1 s i (stack_sizes s i - (1 :: int)) in if c \<le> values s top_stack_i then let stack_i_size :: int = stack_sizes s i; idx :: int = num_elts s in \<forall>(s1 :: state). num_stacks s1 = num_stacks s \<and> num_elts s1 = idx + (1 :: int) \<and> values s1 = values s \<and> stack_sizes s1 = stack_sizes s \<and> stacks1 s1 = stacks1 s \<and> positions s1 = positions s \<and> preds s1 = preds s \<longrightarrow> (\<forall>(s2 :: state). num_stacks s2 = num_stacks s1 \<and> num_elts s2 = num_elts s1 \<and> values s2 = (values s1)(idx := c) \<and> stack_sizes s2 = stack_sizes s1 \<and> stacks1 s2 = stacks1 s1 \<and> positions s2 = positions s1 \<and> preds s2 = preds s1 \<longrightarrow> (\<forall>(s3 :: state). num_stacks s3 = num_stacks s2 \<and> num_elts s3 = num_elts s2 \<and> values s3 = values s2 \<and> stack_sizes s3 = (stack_sizes s2)(i := stack_i_size + (1 :: int)) \<and> stacks1 s3 = stacks1 s2 \<and> positions s3 = positions s2 \<and> preds s3 = preds s2 \<longrightarrow> (\<forall>(s4 :: state). num_stacks s4 = num_stacks s3 \<and> num_elts s4 = num_elts s3 \<and> values s4 = values s3 \<and> stack_sizes s4 = stack_sizes s3 \<and> stacks1 s4 = (stacks1 s3)(i := (stacks1 s i)(stack_i_size := idx)) \<and> positions s4 = positions s3 \<and> preds s4 = preds s3 \<longrightarrow> (\<forall>(s5 :: state). num_stacks s5 = num_stacks s4 \<and> num_elts s5 = num_elts s4 \<and> values s5 = values s4 \<and> stack_sizes s5 = stack_sizes s4 \<and> stacks1 s5 = stacks1 s4 \<and> positions s5 = (positions s4)(idx := (i, stack_i_size)) \<and> preds s5 = preds s4 \<longrightarrow> (\<forall>(s6 :: state). num_stacks s6 = num_stacks s5 \<and> num_elts s6 = num_elts s5 \<and> values s6 = values s5 \<and> stack_sizes s6 = stack_sizes s5 \<and> stacks1 s6 = stacks1 s5 \<and> positions s6 = positions s5 \<and> preds s6 = (preds s5)(idx := pred) \<longrightarrow> inv s6 \<and> num_elts s6 = num_elts s + (1 :: int) \<and> values s6 = (values s)(num_elts s := c)))))) else if i + (1 :: int) = (0 :: int) then top_stack_i = -(1 :: int) else top_stack_i = stacks1 s (i + (1 :: int) - (1 :: int)) (stack_sizes s (i + (1 :: int) - (1 :: int)) - (1 :: int)) \<and> values s top_stack_i < c \<and> ((0 :: int) \<le> top_stack_i \<and> top_stack_i < num_elts s) \<and> (case positions s top_stack_i of (ps, x_pp) \<Rightarrow> ps = i + (1 :: int) - (1 :: int)))) \<and> ((if o1 + (1 :: int) = (0 :: int) then pred = -(1 :: int) else pred = stacks1 s (o1 + (1 :: int) - (1 :: int)) (stack_sizes s (o1 + (1 :: int) - (1 :: int)) - (1 :: int)) \<and> values s pred < c \<and> ((0 :: int) \<le> pred \<and> pred < num_elts s) \<and> (case positions s pred of (ps, x_pp) \<Rightarrow> ps = o1 + (1 :: int) - (1 :: int))) \<longrightarrow> (let idx :: int = num_elts s; i :: int = num_stacks s in \<forall>(s1 :: state). num_stacks s1 = num_stacks s \<and> num_elts s1 = idx + (1 :: int) \<and> values s1 = values s \<and> stack_sizes s1 = stack_sizes s \<and> stacks1 s1 = stacks1 s \<and> positions s1 = positions s \<and> preds s1 = preds s \<longrightarrow> (\<forall>(s2 :: state). num_stacks s2 = num_stacks s1 \<and> num_elts s2 = num_elts s1 \<and> values s2 = (values s1)(idx := c) \<and> stack_sizes s2 = stack_sizes s1 \<and> stacks1 s2 = stacks1 s1 \<and> positions s2 = positions s1 \<and> preds s2 = preds s1 \<longrightarrow> (\<forall>(s3 :: state). num_stacks s3 = num_stacks s2 + (1 :: int) \<and> num_elts s3 = num_elts s2 \<and> values s3 = values s2 \<and> stack_sizes s3 = stack_sizes s2 \<and> stacks1 s3 = stacks1 s2 \<and> positions s3 = positions s2 \<and> preds s3 = preds s2 \<longrightarrow> (\<forall>(s4 :: state). num_stacks s4 = num_stacks s3 \<and> num_elts s4 = num_elts s3 \<and> values s4 = values s3 \<and> stack_sizes s4 = (stack_sizes s3)(i := 1 :: int) \<and> stacks1 s4 = stacks1 s3 \<and> positions s4 = positions s3 \<and> preds s4 = preds s3 \<longrightarrow> (\<forall>(s5 :: state). num_stacks s5 = num_stacks s4 \<and> num_elts s5 = num_elts s4 \<and> values s5 = values s4 \<and> stack_sizes s5 = stack_sizes s4 \<and> stacks1 s5 = (stacks1 s4)(i := (stacks1 s i)(0 :: int := idx)) \<and> positions s5 = positions s4 \<and> preds s5 = preds s4 \<longrightarrow> (\<forall>(s6 :: state). num_stacks s6 = num_stacks s5 \<and> num_elts s6 = num_elts s5 \<and> values s6 = values s5 \<and> stack_sizes s6 = stack_sizes s5 \<and> stacks1 s6 = stacks1 s5 \<and> positions s6 = (positions s5)(idx := (i, 0 :: int)) \<and> preds s6 = preds s5 \<longrightarrow> (\<forall>(s7 :: state). num_stacks s7 = num_stacks s6 \<and> num_elts s7 = num_elts s6 \<and> values s7 = values s6 \<and> stack_sizes s7 = stack_sizes s6 \<and> stacks1 s7 = stacks1 s6 \<and> positions s7 = positions s6 \<and> preds s7 = (preds s6)(idx := pred) \<longrightarrow> inv s7 \<and> num_elts s7 = num_elts s + (1 :: int) \<and> values s7 = (values s)(num_elts s := c))))))))))) \<and> (o1 + (1 :: int) < (0 :: int) \<longrightarrow> (let idx :: int = num_elts s; i :: int = num_stacks s in \<forall>(s1 :: state). num_stacks s1 = num_stacks s \<and> num_elts s1 = idx + (1 :: int) \<and> values s1 = values s \<and> stack_sizes s1 = stack_sizes s \<and> stacks1 s1 = stacks1 s \<and> positions s1 = positions s \<and> preds s1 = preds s \<longrightarrow> (\<forall>(s2 :: state). num_stacks s2 = num_stacks s1 \<and> num_elts s2 = num_elts s1 \<and> values s2 = (values s1)(idx := c) \<and> stack_sizes s2 = stack_sizes s1 \<and> stacks1 s2 = stacks1 s1 \<and> positions s2 = positions s1 \<and> preds s2 = preds s1 \<longrightarrow> (\<forall>(s3 :: state). num_stacks s3 = num_stacks s2 + (1 :: int) \<and> num_elts s3 = num_elts s2 \<and> values s3 = values s2 \<and> stack_sizes s3 = stack_sizes s2 \<and> stacks1 s3 = stacks1 s2 \<and> positions s3 = positions s2 \<and> preds s3 = preds s2 \<longrightarrow> (\<forall>(s4 :: state). num_stacks s4 = num_stacks s3 \<and> num_elts s4 = num_elts s3 \<and> values s4 = values s3 \<and> stack_sizes s4 = (stack_sizes s3)(i := 1 :: int) \<and> stacks1 s4 = stacks1 s3 \<and> positions s4 = positions s3 \<and> preds s4 = preds s3 \<longrightarrow> (\<forall>(s5 :: state). num_stacks s5 = num_stacks s4 \<and> num_elts s5 = num_elts s4 \<and> values s5 = values s4 \<and> stack_sizes s5 = stack_sizes s4 \<and> stacks1 s5 = (stacks1 s4)(i := (stacks1 s i)(0 :: int := idx)) \<and> positions s5 = positions s4 \<and> preds s5 = preds s4 \<longrightarrow> (\<forall>(s6 :: state). num_stacks s6 = num_stacks s5 \<and> num_elts s6 = num_elts s5 \<and> values s6 = values s5 \<and> stack_sizes s6 = stack_sizes s5 \<and> stacks1 s6 = stacks1 s5 \<and> positions s6 = (positions s5)(idx := (i, 0 :: int)) \<and> preds s6 = preds s5 \<longrightarrow> (\<forall>(s7 :: state). num_stacks s7 = num_stacks s6 \<and> num_elts s7 = num_elts s6 \<and> values s7 = values s6 \<and> stack_sizes s7 = stack_sizes s6 \<and> stacks1 s7 = stacks1 s6 \<and> positions s7 = positions s6 \<and> preds s7 = (preds s6)(idx := -(1 :: int)) \<longrightarrow> inv s7 \<and> num_elts s7 = num_elts s + (1 :: int) \<and> values s7 = (values s)(num_elts s := c)))))))))"
  sorry
end
