theory quicksort_Traditional_quick_recqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_MapEq" "Why3STD.map_MapExchange" "Why3STD.map_MapPermut" "Why3STD.array_IntArraySorted"
begin
theorem quick_rec'vc:
  fixes l :: "int"
  fixes r :: "int"
  fixes a :: "int list"
  assumes fact0: "(0 :: int) \<le> l"
  assumes fact1: "l \<le> r"
  assumes fact2: "r \<le> int (length a)"
  shows "if r \<le> l + (1 :: int) then sorted_sub1 a l r \<and> permut_sub' a a (nat l) (nat r) else ((0 :: int) \<le> l \<and> l < int (length a)) \<and> (let v :: int = a ! nat l in ((l \<le> l \<and> l < r - (1 :: int)) \<and> (\<forall>(k :: int). l \<le> k \<and> k \<le> l \<longrightarrow> a ! nat k \<le> v) \<and> (l < r \<and> r \<le> r) \<and> (\<forall>(k :: int). r \<le> k \<and> k < r \<longrightarrow> v \<le> a ! nat k) \<and> permut_sub' a a (nat l) (nat r) \<and> a ! nat l = v) \<and> (\<forall>(j :: int) (i :: int) (a1 :: int list). length a1 = length a \<longrightarrow> (l \<le> i \<and> i < r - (1 :: int)) \<and> (\<forall>(k :: int). l \<le> k \<and> k \<le> i \<longrightarrow> a1 ! nat k \<le> v) \<and> (l < j \<and> j \<le> r) \<and> (\<forall>(k :: int). j \<le> k \<and> k < r \<longrightarrow> v \<le> a1 ! nat k) \<and> permut_sub' a a1 (nat l) (nat r) \<and> a1 ! nat l = v \<longrightarrow> ((i < i + (1 :: int) \<and> i + (1 :: int) < r) \<and> (\<forall>(k :: int). l \<le> k \<and> k < i + (1 :: int) \<longrightarrow> a1 ! nat k \<le> v)) \<and> (\<forall>(i1 :: int). (i < i1 \<and> i1 < r) \<and> (\<forall>(k :: int). l \<le> k \<and> k < i1 \<longrightarrow> a1 ! nat k \<le> v) \<longrightarrow> ((0 :: int) \<le> i1 \<and> i1 < int (length a1)) \<and> (if a1 ! nat i1 < v then if i1 = r - (1 :: int) then ((l \<le> j - (1 :: int) \<and> j - (1 :: int) < j) \<and> (\<forall>(k :: int). j - (1 :: int) < k \<and> k < r \<longrightarrow> v \<le> a1 ! nat k)) \<and> (\<forall>(j1 :: int). (l \<le> j1 \<and> j1 < j) \<and> (\<forall>(k :: int). j1 < k \<and> k < r \<longrightarrow> v \<le> a1 ! nat k) \<longrightarrow> ((0 :: int) \<le> j1 \<and> j1 < int (length a1)) \<and> (if v < a1 ! nat j1 then if j1 = l then if j1 \<le> i1 then (((0 :: int) \<le> l \<and> l < int (length a1)) \<and> (0 :: int) \<le> j1 \<and> j1 < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 l j1 \<longrightarrow> (((0 :: int) \<le> r - l \<and> j1 - l < r - l) \<and> (0 :: int) \<le> l \<and> l \<le> j1 \<and> j1 \<le> int (length a2)) \<and> (\<forall>(a3 :: int list). length a3 = length a2 \<longrightarrow> sorted_sub1 a3 l j1 \<and> permut_sub' a2 a3 (nat l) (nat j1) \<longrightarrow> (let o1 :: int = j1 + (1 :: int) in (((0 :: int) \<le> r - l \<and> r - o1 < r - l) \<and> (0 :: int) \<le> o1 \<and> o1 \<le> r \<and> r \<le> int (length a3)) \<and> (\<forall>(a4 :: int list). length a4 = length a3 \<longrightarrow> sorted_sub1 a4 o1 r \<and> permut_sub' a3 a4 (nat o1) (nat r) \<longrightarrow> sorted_sub1 a4 l r \<and> permut_sub' a a4 (nat l) (nat r))))) else (((0 :: int) \<le> i1 \<and> i1 < int (length a1)) \<and> (0 :: int) \<le> j1 \<and> j1 < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 i1 j1 \<longrightarrow> ((0 :: int) \<le> j - i \<and> j1 - i1 < j - i) \<and> (l \<le> i1 \<and> i1 < r - (1 :: int)) \<and> (\<forall>(k :: int). l \<le> k \<and> k \<le> i1 \<longrightarrow> a2 ! nat k \<le> v) \<and> (l < j1 \<and> j1 \<le> r) \<and> (\<forall>(k :: int). j1 \<le> k \<and> k < r \<longrightarrow> v \<le> a2 ! nat k) \<and> permut_sub' a a2 (nat l) (nat r) \<and> a2 ! nat l = v) else ((0 :: int) \<le> j1 \<and> j1 - (1 :: int) < j1) \<and> (l \<le> j1 - (1 :: int) \<and> j1 - (1 :: int) < j) \<and> (\<forall>(k :: int). j1 - (1 :: int) < k \<and> k < r \<longrightarrow> v \<le> a1 ! nat k) else if j1 \<le> i1 then (((0 :: int) \<le> l \<and> l < int (length a1)) \<and> (0 :: int) \<le> j1 \<and> j1 < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 l j1 \<longrightarrow> (((0 :: int) \<le> r - l \<and> j1 - l < r - l) \<and> (0 :: int) \<le> l \<and> l \<le> j1 \<and> j1 \<le> int (length a2)) \<and> (\<forall>(a3 :: int list). length a3 = length a2 \<longrightarrow> sorted_sub1 a3 l j1 \<and> permut_sub' a2 a3 (nat l) (nat j1) \<longrightarrow> (let o1 :: int = j1 + (1 :: int) in (((0 :: int) \<le> r - l \<and> r - o1 < r - l) \<and> (0 :: int) \<le> o1 \<and> o1 \<le> r \<and> r \<le> int (length a3)) \<and> (\<forall>(a4 :: int list). length a4 = length a3 \<longrightarrow> sorted_sub1 a4 o1 r \<and> permut_sub' a3 a4 (nat o1) (nat r) \<longrightarrow> sorted_sub1 a4 l r \<and> permut_sub' a a4 (nat l) (nat r))))) else (((0 :: int) \<le> i1 \<and> i1 < int (length a1)) \<and> (0 :: int) \<le> j1 \<and> j1 < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 i1 j1 \<longrightarrow> ((0 :: int) \<le> j - i \<and> j1 - i1 < j - i) \<and> (l \<le> i1 \<and> i1 < r - (1 :: int)) \<and> (\<forall>(k :: int). l \<le> k \<and> k \<le> i1 \<longrightarrow> a2 ! nat k \<le> v) \<and> (l < j1 \<and> j1 \<le> r) \<and> (\<forall>(k :: int). j1 \<le> k \<and> k < r \<longrightarrow> v \<le> a2 ! nat k) \<and> permut_sub' a a2 (nat l) (nat r) \<and> a2 ! nat l = v))) else ((0 :: int) \<le> r - i1 \<and> r - (i1 + (1 :: int)) < r - i1) \<and> (i < i1 + (1 :: int) \<and> i1 + (1 :: int) < r) \<and> (\<forall>(k :: int). l \<le> k \<and> k < i1 + (1 :: int) \<longrightarrow> a1 ! nat k \<le> v) else ((l \<le> j - (1 :: int) \<and> j - (1 :: int) < j) \<and> (\<forall>(k :: int). j - (1 :: int) < k \<and> k < r \<longrightarrow> v \<le> a1 ! nat k)) \<and> (\<forall>(j1 :: int). (l \<le> j1 \<and> j1 < j) \<and> (\<forall>(k :: int). j1 < k \<and> k < r \<longrightarrow> v \<le> a1 ! nat k) \<longrightarrow> ((0 :: int) \<le> j1 \<and> j1 < int (length a1)) \<and> (if v < a1 ! nat j1 then if j1 = l then if j1 \<le> i1 then (((0 :: int) \<le> l \<and> l < int (length a1)) \<and> (0 :: int) \<le> j1 \<and> j1 < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 l j1 \<longrightarrow> (((0 :: int) \<le> r - l \<and> j1 - l < r - l) \<and> (0 :: int) \<le> l \<and> l \<le> j1 \<and> j1 \<le> int (length a2)) \<and> (\<forall>(a3 :: int list). length a3 = length a2 \<longrightarrow> sorted_sub1 a3 l j1 \<and> permut_sub' a2 a3 (nat l) (nat j1) \<longrightarrow> (let o1 :: int = j1 + (1 :: int) in (((0 :: int) \<le> r - l \<and> r - o1 < r - l) \<and> (0 :: int) \<le> o1 \<and> o1 \<le> r \<and> r \<le> int (length a3)) \<and> (\<forall>(a4 :: int list). length a4 = length a3 \<longrightarrow> sorted_sub1 a4 o1 r \<and> permut_sub' a3 a4 (nat o1) (nat r) \<longrightarrow> sorted_sub1 a4 l r \<and> permut_sub' a a4 (nat l) (nat r))))) else (((0 :: int) \<le> i1 \<and> i1 < int (length a1)) \<and> (0 :: int) \<le> j1 \<and> j1 < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 i1 j1 \<longrightarrow> ((0 :: int) \<le> j - i \<and> j1 - i1 < j - i) \<and> (l \<le> i1 \<and> i1 < r - (1 :: int)) \<and> (\<forall>(k :: int). l \<le> k \<and> k \<le> i1 \<longrightarrow> a2 ! nat k \<le> v) \<and> (l < j1 \<and> j1 \<le> r) \<and> (\<forall>(k :: int). j1 \<le> k \<and> k < r \<longrightarrow> v \<le> a2 ! nat k) \<and> permut_sub' a a2 (nat l) (nat r) \<and> a2 ! nat l = v) else ((0 :: int) \<le> j1 \<and> j1 - (1 :: int) < j1) \<and> (l \<le> j1 - (1 :: int) \<and> j1 - (1 :: int) < j) \<and> (\<forall>(k :: int). j1 - (1 :: int) < k \<and> k < r \<longrightarrow> v \<le> a1 ! nat k) else if j1 \<le> i1 then (((0 :: int) \<le> l \<and> l < int (length a1)) \<and> (0 :: int) \<le> j1 \<and> j1 < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 l j1 \<longrightarrow> (((0 :: int) \<le> r - l \<and> j1 - l < r - l) \<and> (0 :: int) \<le> l \<and> l \<le> j1 \<and> j1 \<le> int (length a2)) \<and> (\<forall>(a3 :: int list). length a3 = length a2 \<longrightarrow> sorted_sub1 a3 l j1 \<and> permut_sub' a2 a3 (nat l) (nat j1) \<longrightarrow> (let o1 :: int = j1 + (1 :: int) in (((0 :: int) \<le> r - l \<and> r - o1 < r - l) \<and> (0 :: int) \<le> o1 \<and> o1 \<le> r \<and> r \<le> int (length a3)) \<and> (\<forall>(a4 :: int list). length a4 = length a3 \<longrightarrow> sorted_sub1 a4 o1 r \<and> permut_sub' a3 a4 (nat o1) (nat r) \<longrightarrow> sorted_sub1 a4 l r \<and> permut_sub' a a4 (nat l) (nat r))))) else (((0 :: int) \<le> i1 \<and> i1 < int (length a1)) \<and> (0 :: int) \<le> j1 \<and> j1 < int (length a1)) \<and> (\<forall>(a2 :: int list). length a2 = length a1 \<longrightarrow> list_exchange a1 a2 i1 j1 \<longrightarrow> ((0 :: int) \<le> j - i \<and> j1 - i1 < j - i) \<and> (l \<le> i1 \<and> i1 < r - (1 :: int)) \<and> (\<forall>(k :: int). l \<le> k \<and> k \<le> i1 \<longrightarrow> a2 ! nat k \<le> v) \<and> (l < j1 \<and> j1 \<le> r) \<and> (\<forall>(k :: int). j1 \<le> k \<and> k < r \<longrightarrow> v \<le> a2 ! nat k) \<and> permut_sub' a a2 (nat l) (nat r) \<and> a2 ! nat l = v)))))))"
  sorry
end
