import Why3.Base
import Why3.why3.Ref.Ref
import Why3.int.Sum
open Classical
open Lean4Why3
namespace maximum_subarray_BoundedIntegers_maximum_subarrayqtvc
axiom fc : array63 (BitVec 63) -> ℤ -> ℤ
axiom fc'def (a : array63 (BitVec 63)) (i : ℤ) : fc a i = BitVec.toInt ((array63_elts a)[Int.toNat i]!)
noncomputable def sum (a : array63 (BitVec 63)) (lo : ℤ) (hi : ℤ) := int.Sum.sum (fc a) lo hi
theorem maximum_subarray'vc (a : array63 (BitVec 63)) (fact0 : ∀(l : ℤ) (h : ℤ), (0 : ℤ) ≤ l ∧ l ≤ h ∧ h ≤ BitVec.toInt (array63_length a) → sum a l h ≤ BitVec.toInt int'63_max) : let n : BitVec 63 := array63_length a; ((((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt (0 : BitVec 63) ∧ BitVec.toInt (0 : BitVec 63) ≤ BitVec.toInt n) ∧ (0 : ℤ) ≤ BitVec.toInt (0 : BitVec 63) ∧ BitVec.toInt (0 : BitVec 63) = sum a (0 : ℤ) (0 : ℤ)) ∧ (∀(l' : ℤ) (h' : ℤ), (0 : ℤ) ≤ l' ∧ l' ≤ h' ∧ h' ≤ BitVec.toInt (0 : BitVec 63) → sum a l' h' ≤ BitVec.toInt (0 : BitVec 63)) ∧ (((0 : ℤ) ≤ (0 : ℤ) ∧ (0 : ℤ) ≤ BitVec.toInt (0 : BitVec 63)) ∧ BitVec.toInt (0 : BitVec 63) = sum a (0 : ℤ) (BitVec.toInt (0 : BitVec 63))) ∧ (∀(l' : ℤ), (0 : ℤ) ≤ l' ∧ l' < BitVec.toInt (0 : BitVec 63) → sum a l' (BitVec.toInt (0 : BitVec 63)) ≤ BitVec.toInt (0 : BitVec 63))) ∧ (∀(i : BitVec 63) (s : BitVec 63) (l : ℤ) (ms : BitVec 63) (hi : ℤ) (lo : ℤ), (((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt n) ∧ (0 : ℤ) ≤ BitVec.toInt ms ∧ BitVec.toInt ms = sum a lo hi) ∧ (∀(l' : ℤ) (h' : ℤ), (0 : ℤ) ≤ l' ∧ l' ≤ h' ∧ h' ≤ BitVec.toInt i → sum a l' h' ≤ BitVec.toInt ms) ∧ (((0 : ℤ) ≤ l ∧ l ≤ BitVec.toInt i) ∧ BitVec.toInt s = sum a l (BitVec.toInt i)) ∧ (∀(l' : ℤ), (0 : ℤ) ≤ l' ∧ l' < BitVec.toInt i → sum a l' (BitVec.toInt i) ≤ BitVec.toInt s) → (if BitVec.toInt i < BitVec.toInt n then if BitVec.toInt s < BitVec.toInt (0 : BitVec 63) then ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i < BitVec.toInt (array63_length a)) ∧ (if BitVec.toInt ms < BitVec.toInt ((array63_elts a)[Int.toNat (BitVec.toInt i)]!) then BitVec.toInt i < (4611686018427387903 : ℤ) ∧ (∀(i1 : BitVec 63), BitVec.toInt i1 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt n - BitVec.toInt i ∧ BitVec.toInt n - BitVec.toInt i1 < BitVec.toInt n - BitVec.toInt i) ∧ (((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt i + (1 : ℤ) ∧ BitVec.toInt i + (1 : ℤ) ≤ BitVec.toInt i1 ∧ BitVec.toInt i1 ≤ BitVec.toInt n) ∧ (0 : ℤ) ≤ BitVec.toInt ((array63_elts a)[Int.toNat (BitVec.toInt i)]!) ∧ BitVec.toInt ((array63_elts a)[Int.toNat (BitVec.toInt i)]!) = sum a (BitVec.toInt i) (BitVec.toInt i + (1 : ℤ))) ∧ (∀(l' : ℤ) (h' : ℤ), (0 : ℤ) ≤ l' ∧ l' ≤ h' ∧ h' ≤ BitVec.toInt i1 → sum a l' h' ≤ BitVec.toInt ((array63_elts a)[Int.toNat (BitVec.toInt i)]!)) ∧ (((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt i1) ∧ BitVec.toInt ((array63_elts a)[Int.toNat (BitVec.toInt i)]!) = sum a (BitVec.toInt i) (BitVec.toInt i1)) ∧ (∀(l' : ℤ), (0 : ℤ) ≤ l' ∧ l' < BitVec.toInt i1 → sum a l' (BitVec.toInt i1) ≤ BitVec.toInt ((array63_elts a)[Int.toNat (BitVec.toInt i)]!))) else BitVec.toInt i < (4611686018427387903 : ℤ) ∧ (∀(i1 : BitVec 63), BitVec.toInt i1 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt n - BitVec.toInt i ∧ BitVec.toInt n - BitVec.toInt i1 < BitVec.toInt n - BitVec.toInt i) ∧ (((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ BitVec.toInt i1 ∧ BitVec.toInt i1 ≤ BitVec.toInt n) ∧ (0 : ℤ) ≤ BitVec.toInt ms ∧ BitVec.toInt ms = sum a lo hi) ∧ (∀(l' : ℤ) (h' : ℤ), (0 : ℤ) ≤ l' ∧ l' ≤ h' ∧ h' ≤ BitVec.toInt i1 → sum a l' h' ≤ BitVec.toInt ms) ∧ (((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i ≤ BitVec.toInt i1) ∧ BitVec.toInt ((array63_elts a)[Int.toNat (BitVec.toInt i)]!) = sum a (BitVec.toInt i) (BitVec.toInt i1)) ∧ (∀(l' : ℤ), (0 : ℤ) ≤ l' ∧ l' < BitVec.toInt i1 → sum a l' (BitVec.toInt i1) ≤ BitVec.toInt ((array63_elts a)[Int.toNat (BitVec.toInt i)]!)))) else ((0 : ℤ) ≤ BitVec.toInt i ∧ BitVec.toInt i < BitVec.toInt (array63_length a)) ∧ (let o1 : BitVec 63 := (array63_elts a)[Int.toNat (BitVec.toInt i)]!; int'63_in_bounds (BitVec.toInt s + BitVec.toInt o1) ∧ (∀(s1 : BitVec 63), BitVec.toInt s1 = BitVec.toInt s + BitVec.toInt o1 → (if BitVec.toInt ms < BitVec.toInt s1 then BitVec.toInt i < (4611686018427387903 : ℤ) ∧ (∀(i1 : BitVec 63), BitVec.toInt i1 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt n - BitVec.toInt i ∧ BitVec.toInt n - BitVec.toInt i1 < BitVec.toInt n - BitVec.toInt i) ∧ (((0 : ℤ) ≤ l ∧ l ≤ BitVec.toInt i + (1 : ℤ) ∧ BitVec.toInt i + (1 : ℤ) ≤ BitVec.toInt i1 ∧ BitVec.toInt i1 ≤ BitVec.toInt n) ∧ (0 : ℤ) ≤ BitVec.toInt s1 ∧ BitVec.toInt s1 = sum a l (BitVec.toInt i + (1 : ℤ))) ∧ (∀(l' : ℤ) (h' : ℤ), (0 : ℤ) ≤ l' ∧ l' ≤ h' ∧ h' ≤ BitVec.toInt i1 → sum a l' h' ≤ BitVec.toInt s1) ∧ (((0 : ℤ) ≤ l ∧ l ≤ BitVec.toInt i1) ∧ BitVec.toInt s1 = sum a l (BitVec.toInt i1)) ∧ (∀(l' : ℤ), (0 : ℤ) ≤ l' ∧ l' < BitVec.toInt i1 → sum a l' (BitVec.toInt i1) ≤ BitVec.toInt s1)) else BitVec.toInt i < (4611686018427387903 : ℤ) ∧ (∀(i1 : BitVec 63), BitVec.toInt i1 = BitVec.toInt i + (1 : ℤ) → ((0 : ℤ) ≤ BitVec.toInt n - BitVec.toInt i ∧ BitVec.toInt n - BitVec.toInt i1 < BitVec.toInt n - BitVec.toInt i) ∧ (((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ BitVec.toInt i1 ∧ BitVec.toInt i1 ≤ BitVec.toInt n) ∧ (0 : ℤ) ≤ BitVec.toInt ms ∧ BitVec.toInt ms = sum a lo hi) ∧ (∀(l' : ℤ) (h' : ℤ), (0 : ℤ) ≤ l' ∧ l' ≤ h' ∧ h' ≤ BitVec.toInt i1 → sum a l' h' ≤ BitVec.toInt ms) ∧ (((0 : ℤ) ≤ l ∧ l ≤ BitVec.toInt i1) ∧ BitVec.toInt s1 = sum a l (BitVec.toInt i1)) ∧ (∀(l' : ℤ), (0 : ℤ) ≤ l' ∧ l' < BitVec.toInt i1 → sum a l' (BitVec.toInt i1) ≤ BitVec.toInt s1))))) else (((0 : ℤ) ≤ lo ∧ lo ≤ hi ∧ hi ≤ BitVec.toInt (array63_length a)) ∧ BitVec.toInt ms = sum a lo hi) ∧ (∀(l1 : ℤ) (h : ℤ), (0 : ℤ) ≤ l1 ∧ l1 ≤ h ∧ h ≤ BitVec.toInt (array63_length a) → sum a lo hi ≤ BitVec.toInt ms)))
  := sorry
end maximum_subarray_BoundedIntegers_maximum_subarrayqtvc
