theory mul_Mul_wmpn_mul_1_in_placeqtvc
  imports "NTP4Verif.NTP4Verif" "Why3STD.Ref_Ref" "Why3STD.map_Const" "Why3STD.map_MapEq" "mach.int_Unsigned" "mach.c_C" "../../lib/isabelle/types_Config" "../../lib/isabelle/types_Types" "../../lib/isabelle/types_Int32Eq" "../../lib/isabelle/types_UInt64Eq" "../../lib/isabelle/lemmas_Lemmas" "../../lib/isabelle/util_Util" "../../lib/isabelle/ptralias_Alias" "../../lib/isabelle/add_Add"
begin
theorem wmpn_mul_1_in_place'vc:
  fixes x :: "64 word ptr"
  fixes sz :: "32 word"
  fixes y :: "64 word"
  assumes fact0: "valid x (sint sz)"
  assumes fact1: "writable x = True"
  shows "c_C.min x \<le> offset x + (0 :: int)"
  and "offset x + (0 :: int) \<le> c_C.max x"
  and "\<forall>(o1 :: 64 word ptr). offset o1 = offset x + (0 :: int) \<and> plength o1 = plength x \<and> pelts o1 = pelts x \<and> data o1 = data x \<and> c_C.min o1 = c_C.min x \<and> c_C.max o1 = c_C.max x \<and> zone1 o1 = zone1 x \<and> writable o1 = writable x \<longrightarrow> (((0 :: int) \<le> sint sz \<and> sint sz \<le> sint sz) \<and> (0 :: int) = sint sz - sint sz \<and> value x (0 :: int) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i (0 :: int) * (0 :: int) = value x (0 :: int) * uint y \<and> offset o1 = offset x + (0 :: int) \<and> plength o1 = plength x \<and> c_C.min o1 = c_C.min x \<and> c_C.max o1 = c_C.max x \<and> pelts o1 = pelts x \<and> writable o1 = True) \<and> (\<forall>(i :: 32 word) (up :: 64 word ptr) (n :: 32 word) (cl :: 64 word) (x1 :: 64 word ptr). length (data x1) = length (data x) \<and> offset x1 = offset x \<and> c_C.min x1 = c_C.min x \<and> c_C.max x1 = c_C.max x \<and> writable x1 = writable x \<and> zone1 x1 = zone1 x \<longrightarrow> ((0 :: int) \<le> sint n \<and> sint n \<le> sint sz) \<and> sint i = sint sz - sint n \<and> value x1 (sint i) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint i * uint cl = value x (sint i) * uint y \<and> offset up = offset x1 + sint i \<and> plength up = plength x1 \<and> c_C.min up = c_C.min x1 \<and> c_C.max up = c_C.max x1 \<and> pelts up = pelts x1 \<and> writable up = True \<and> (\<forall>(j :: int). j < offset x1 \<or> offset x1 + sint i \<le> j \<longrightarrow> pelts x1 j = pelts x j) \<longrightarrow> (\<forall>(o2 :: bool). (sint n = sint (0 :: 32 word) \<longrightarrow> o2 = True) \<and> (o2 = True \<longrightarrow> n = (0 :: 32 word)) \<longrightarrow> (if \<not>o2 = True then (c_C.min up \<le> offset up \<and> offset up < c_C.max up) \<and> (\<forall>(l :: 64 word) (h :: 64 word). uint l + ((18446744073709551615 :: int) + (1 :: int)) * uint h = uint (pelts up (offset up)) * uint y \<longrightarrow> (\<forall>(lpl :: 64 word). uint lpl = (uint l + uint cl) emod ((18446744073709551615 :: int) + (1 :: int)) \<longrightarrow> (\<forall>(o3 :: 64 word). (if uint lpl < uint cl then o3 = (1 :: 64 word) else o3 = (0 :: 64 word)) \<longrightarrow> uint'64_in_bounds (uint o3 + uint h) \<and> (\<forall>(o4 :: 64 word). uint o4 = uint o3 + uint h \<longrightarrow> uint lpl + ((18446744073709551615 :: int) + (1 :: int)) * uint o4 = uint (pelts up (offset up)) * uint y + uint cl)) \<and> (\<forall>(cl1 :: 64 word). uint lpl + ((18446744073709551615 :: int) + (1 :: int)) * uint cl1 = uint (pelts up (offset up)) * uint y + uint cl \<longrightarrow> ((c_C.min up \<le> offset up \<and> offset up < c_C.max up) \<and> writable up = True) \<and> (\<forall>(up1 :: 64 word ptr) (x2 :: 64 word ptr). data up1 = data x2 \<and> length (data x2) = length (data up) \<and> offset up1 = offset up \<and> c_C.min up1 = c_C.min up \<and> c_C.max up1 = c_C.max up \<and> writable up1 = writable up \<and> zone1 up1 = zone1 up \<longrightarrow> data up1 = data x2 \<and> length (data x2) = length (data up) \<and> offset up1 = offset up \<and> c_C.min up1 = c_C.min up \<and> c_C.max up1 = c_C.max up \<and> writable up1 = writable up \<and> zone1 up1 = zone1 up \<longrightarrow> length (data x2) = length (data x1) \<and> offset x2 = offset x1 \<and> c_C.min x2 = c_C.min x1 \<and> c_C.max x2 = c_C.max x1 \<and> writable x2 = writable x1 \<and> zone1 x2 = zone1 x1 \<longrightarrow> pelts up1 = (pelts up)(offset up1 := lpl) \<longrightarrow> (c_C.min up1 \<le> offset up1 + (1 :: int) \<and> offset up1 + (1 :: int) \<le> c_C.max up1) \<and> (\<forall>(o3 :: 64 word ptr). offset o3 = offset up1 + (1 :: int) \<and> plength o3 = plength up1 \<and> pelts o3 = pelts up1 \<and> data o3 = data up1 \<and> c_C.min o3 = c_C.min up1 \<and> c_C.max o3 = c_C.max up1 \<and> zone1 o3 = zone1 up1 \<and> writable o3 = writable up1 \<longrightarrow> int'32_in_bounds (sint n - (1 :: int)) \<and> (\<forall>(o4 :: 32 word). sint o4 = sint n - (1 :: int) \<longrightarrow> int'32_in_bounds (sint i + (1 :: int)) \<and> (\<forall>(o5 :: 32 word). sint o5 = sint i + (1 :: int) \<longrightarrow> sint o4 < sint n \<and> ((0 :: int) \<le> sint o4 \<and> sint o4 \<le> sint sz) \<and> sint o5 = sint sz - sint o4 \<and> value x2 (sint o5) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint o5 * uint cl1 = value x (sint o5) * uint y \<and> offset o3 = offset x2 + sint o5 \<and> plength o3 = plength x2 \<and> c_C.min o3 = c_C.min x2 \<and> c_C.max o3 = c_C.max x2 \<and> pelts o3 = pelts x2 \<and> writable o3 = True \<and> (\<forall>(j :: int). j < offset x2 \<or> offset x2 + sint o5 \<le> j \<longrightarrow> pelts x2 j = pelts x j)))))))) else value x1 (sint sz) + ((18446744073709551615 :: int) + (1 :: int)) ^\<^sub>i sint sz * uint cl = value x (sint sz) * uint y \<and> (\<forall>(j :: int). j < offset x1 \<or> offset x1 + sint sz \<le> j \<longrightarrow> pelts x1 j = pelts x j))))"
  sorry
end
